{"sha": "d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "node_id": "C_kwDOAAsO6NoAKGQ2M2E4ZDk2NWU3NmYyOWEyYjY1YzFmMjJhMzI2MTNkZjFmZTVjMmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-10T00:26:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-10T00:26:07Z"}, "message": "Auto merge of #92278 - Aaron1011:fix-fingerprint-caching, r=michaelwoerister\n\nEnsure that `Fingerprint` caching respects hashing configuration\n\nFixes #92266\n\nIn some `HashStable` impls, we use a cache to avoid re-computing\nthe same `Fingerprint` from the same structure (e.g. an `AdtDef`).\nHowever, the `StableHashingContext` used can be configured to\nperform hashing in different ways (e.g. skipping `Span`s). This\nconfiguration information is not included in the cache key,\nwhich will cause an incorrect `Fingerprint` to be used if\nwe hash the same structure with different `StableHashingContext`\nsettings.\n\nTo fix this, the configuration settings of `StableHashingContext`\nare split out into a separate `HashingControls` struct. This\nstruct is used as part of the cache key, ensuring that our caches\nalways produce the correct result for the given settings.\n\nWith this in place, we now turn off `Span` hashing during the\nentire process of computing the hash included in legacy symbols.\nThis current has no effect, but will matter when a future PR\nstarts hashing more `Span`s that we currently skip.", "tree": {"sha": "39fa2086774310f7ede68bad24ac33d6b5076f62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39fa2086774310f7ede68bad24ac33d6b5076f62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "html_url": "https://github.com/rust-lang/rust/commit/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "092e1c9d23158d81be27bb6f71bdd0c6282478fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/092e1c9d23158d81be27bb6f71bdd0c6282478fb", "html_url": "https://github.com/rust-lang/rust/commit/092e1c9d23158d81be27bb6f71bdd0c6282478fb"}, {"sha": "4ca275add0b443a3fe9f3a0fc4470bb9d9628cfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ca275add0b443a3fe9f3a0fc4470bb9d9628cfd", "html_url": "https://github.com/rust-lang/rust/commit/4ca275add0b443a3fe9f3a0fc4470bb9d9628cfd"}], "stats": {"total": 164, "additions": 118, "deletions": 46}, "files": [{"sha": "9c09a7f5f822e94c1abfa75918b1a2993b401a9b", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "patch": "@@ -583,3 +583,22 @@ fn stable_hash_reduce<HCX, I, C, F>(\n         }\n     }\n }\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Hash, Debug)]\n+pub enum NodeIdHashingMode {\n+    Ignore,\n+    HashDefPath,\n+}\n+\n+/// Controls what data we do or not not hash.\n+/// Whenever a `HashStable` implementation caches its\n+/// result, it needs to include `HashingControls` as part\n+/// of the key, to ensure that is does not produce an incorrect\n+/// result (for example, using a `Fingerprint` produced while\n+/// hashing `Span`s when a `Fingeprint` without `Span`s is\n+/// being requested)\n+#[derive(Clone, Hash, Eq, PartialEq, Debug)]\n+pub struct HashingControls {\n+    pub hash_spans: bool,\n+    pub node_id_hashing_mode: NodeIdHashingMode,\n+}"}, {"sha": "6cec75d36e2c2f2063ff543c34dce6f9aca9b178", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "patch": "@@ -4,6 +4,7 @@ use crate::ty::util::{Discr, IntTypeExt};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::HashingControls;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -136,12 +137,13 @@ impl Hash for AdtDef {\n impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n-            static CACHE: RefCell<FxHashMap<usize, Fingerprint>> = Default::default();\n+            static CACHE: RefCell<FxHashMap<(usize, HashingControls), Fingerprint>> = Default::default();\n         }\n \n         let hash: Fingerprint = CACHE.with(|cache| {\n             let addr = self as *const AdtDef as usize;\n-            *cache.borrow_mut().entry(addr).or_insert_with(|| {\n+            let hashing_controls = hcx.hashing_controls();\n+            *cache.borrow_mut().entry((addr, hashing_controls)).or_insert_with(|| {\n                 let ty::AdtDef { did, ref variants, ref flags, ref repr } = *self;\n \n                 let mut hasher = StableHasher::new();"}, {"sha": "00ce15bea3f28cb54acf0bfaf65f58d9b69d7b3a", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "patch": "@@ -6,6 +6,7 @@ use crate::mir;\n use crate::ty;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::HashingControls;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_query_system::ich::StableHashingContext;\n use std::cell::RefCell;\n@@ -17,12 +18,12 @@ where\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n-            static CACHE: RefCell<FxHashMap<(usize, usize), Fingerprint>> =\n+            static CACHE: RefCell<FxHashMap<(usize, usize, HashingControls), Fingerprint>> =\n                 RefCell::new(Default::default());\n         }\n \n         let hash = CACHE.with(|cache| {\n-            let key = (self.as_ptr() as usize, self.len());\n+            let key = (self.as_ptr() as usize, self.len(), hcx.hashing_controls());\n             if let Some(&hash) = cache.borrow().get(&key) {\n                 return hash;\n             }"}, {"sha": "76e21be17bc68e1665a02cc7e91d8a9d03a62c9b", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "patch": "@@ -3,6 +3,7 @@ use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::stable_hasher::{HashingControls, NodeIdHashingMode};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -26,20 +27,15 @@ fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n pub struct StableHashingContext<'a> {\n     definitions: &'a Definitions,\n     cstore: &'a dyn CrateStore,\n+    // The value of `-Z incremental-ignore-spans`.\n+    // This field should only be used by `debug_opts_incremental_ignore_span`\n+    incremental_ignore_spans: bool,\n     pub(super) body_resolver: BodyResolver<'a>,\n-    hash_spans: bool,\n-    pub(super) node_id_hashing_mode: NodeIdHashingMode,\n-\n     // Very often, we are hashing something that does not need the\n     // `CachingSourceMapView`, so we initialize it lazily.\n     raw_source_map: &'a SourceMap,\n     caching_source_map: Option<CachingSourceMapView<'a>>,\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy)]\n-pub enum NodeIdHashingMode {\n-    Ignore,\n-    HashDefPath,\n+    pub(super) hashing_controls: HashingControls,\n }\n \n /// The `BodyResolver` allows mapping a `BodyId` to the corresponding `hir::Body`.\n@@ -70,10 +66,13 @@ impl<'a> StableHashingContext<'a> {\n             body_resolver: BodyResolver::Forbidden,\n             definitions,\n             cstore,\n+            incremental_ignore_spans: sess.opts.debugging_opts.incremental_ignore_spans,\n             caching_source_map: None,\n             raw_source_map: sess.source_map(),\n-            hash_spans: hash_spans_initial,\n-            node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n+            hashing_controls: HashingControls {\n+                hash_spans: hash_spans_initial,\n+                node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n+            },\n         }\n     }\n \n@@ -133,10 +132,10 @@ impl<'a> StableHashingContext<'a> {\n \n     #[inline]\n     pub fn while_hashing_spans<F: FnOnce(&mut Self)>(&mut self, hash_spans: bool, f: F) {\n-        let prev_hash_spans = self.hash_spans;\n-        self.hash_spans = hash_spans;\n+        let prev_hash_spans = self.hashing_controls.hash_spans;\n+        self.hashing_controls.hash_spans = hash_spans;\n         f(self);\n-        self.hash_spans = prev_hash_spans;\n+        self.hashing_controls.hash_spans = prev_hash_spans;\n     }\n \n     #[inline]\n@@ -145,10 +144,10 @@ impl<'a> StableHashingContext<'a> {\n         mode: NodeIdHashingMode,\n         f: F,\n     ) {\n-        let prev = self.node_id_hashing_mode;\n-        self.node_id_hashing_mode = mode;\n+        let prev = self.hashing_controls.node_id_hashing_mode;\n+        self.hashing_controls.node_id_hashing_mode = mode;\n         f(self);\n-        self.node_id_hashing_mode = prev;\n+        self.hashing_controls.node_id_hashing_mode = prev;\n     }\n \n     #[inline]\n@@ -183,6 +182,11 @@ impl<'a> StableHashingContext<'a> {\n         }\n         IGNORED_ATTRIBUTES.with(|attrs| attrs.contains(&name))\n     }\n+\n+    #[inline]\n+    pub fn hashing_controls(&self) -> HashingControls {\n+        self.hashing_controls.clone()\n+    }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n@@ -195,7 +199,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n     #[inline]\n     fn hash_spans(&self) -> bool {\n-        self.hash_spans\n+        self.hashing_controls.hash_spans\n+    }\n+\n+    #[inline]\n+    fn debug_opts_incremental_ignore_spans(&self) -> bool {\n+        self.incremental_ignore_spans\n     }\n \n     #[inline]\n@@ -215,6 +224,11 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n     ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)> {\n         self.source_map().span_data_to_lines_and_cols(span)\n     }\n+\n+    #[inline]\n+    fn hashing_controls(&self) -> HashingControls {\n+        self.hashing_controls.clone()\n+    }\n }\n \n impl<'a> rustc_session::HashStableContext for StableHashingContext<'a> {}"}, {"sha": "bf3cf6a48fd03d706f11ebba2f091d0bc2aa446f", "filename": "compiler/rustc_query_system/src/ich/impls_hir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs?ref=d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "patch": "@@ -11,7 +11,7 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n     #[inline]\n     fn hash_hir_id(&mut self, hir_id: hir::HirId, hasher: &mut StableHasher) {\n         let hcx = self;\n-        match hcx.node_id_hashing_mode {\n+        match hcx.hashing_controls.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Don't do anything.\n             }\n@@ -89,12 +89,12 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n \n     #[inline]\n     fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self, f: F) {\n-        let prev_hash_node_ids = self.node_id_hashing_mode;\n-        self.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n+        let prev_hash_node_ids = self.hashing_controls.node_id_hashing_mode;\n+        self.hashing_controls.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n \n         f(self);\n \n-        self.node_id_hashing_mode = prev_hash_node_ids;\n+        self.hashing_controls.node_id_hashing_mode = prev_hash_node_ids;\n     }\n \n     #[inline]"}, {"sha": "c42fcc9c82e1eeda9d437d744b47df8a4c720b6f", "filename": "compiler/rustc_query_system/src/ich/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs?ref=d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "patch": "@@ -1,6 +1,7 @@\n //! ICH - Incremental Compilation Hash\n \n-pub use self::hcx::{NodeIdHashingMode, StableHashingContext};\n+pub use self::hcx::StableHashingContext;\n+pub use rustc_data_structures::stable_hasher::NodeIdHashingMode;\n use rustc_span::symbol::{sym, Symbol};\n \n mod hcx;"}, {"sha": "7b70c20d307f05cfdeffb843a754d7673bc4ea22", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "patch": "@@ -32,6 +32,7 @@ use crate::{HashStableContext, Span, DUMMY_SP};\n use crate::def_id::{CrateNum, DefId, StableCrateId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stable_hasher::HashingControls;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_data_structures::unhash::UnhashMap;\n@@ -88,6 +89,33 @@ rustc_index::newtype_index! {\n     }\n }\n \n+/// Assert that the provided `HashStableContext` is configured with the 'default'\n+/// `HashingControls`. We should always have bailed out before getting to here\n+/// with a non-default mode. With this check in place, we can avoid the need\n+/// to maintain separate versions of `ExpnData` hashes for each permutation\n+/// of `HashingControls` settings.\n+fn assert_default_hashing_controls<CTX: HashStableContext>(ctx: &CTX, msg: &str) {\n+    match ctx.hashing_controls() {\n+        // Ideally, we would also check that `node_id_hashing_mode` was always\n+        // `NodeIdHashingMode::HashDefPath`. However, we currently end up hashing\n+        // `Span`s in this mode, and there's not an easy way to change that.\n+        // All of the span-related data that we hash is pretty self-contained\n+        // (in particular, we don't hash any `HirId`s), so this shouldn't result\n+        // in any caching problems.\n+        // FIXME: Enforce that we don't end up transitively hashing any `HirId`s,\n+        // or ensure that this method is always invoked with the same\n+        // `NodeIdHashingMode`\n+        //\n+        // Note that we require that `hash_spans` be set according to the global\n+        // `-Z incremental-ignore-spans` option. Normally, this option is disabled,\n+        // which will cause us to require that this method always be called with `Span` hashing\n+        // enabled.\n+        HashingControls { hash_spans, node_id_hashing_mode: _ }\n+            if hash_spans == !ctx.debug_opts_incremental_ignore_spans() => {}\n+        other => panic!(\"Attempted hashing of {msg} with non-default HashingControls: {:?}\", other),\n+    }\n+}\n+\n /// A unique hash value associated to an expansion.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n pub struct ExpnHash(Fingerprint);\n@@ -1444,6 +1472,7 @@ fn update_disambiguator(expn_data: &mut ExpnData, mut ctx: impl HashStableContex\n         \"Already set disambiguator for ExpnData: {:?}\",\n         expn_data\n     );\n+    assert_default_hashing_controls(&ctx, \"ExpnData (disambiguator)\");\n     let mut expn_hash = expn_data.hash_expn(&mut ctx);\n \n     let disambiguator = HygieneData::with(|data| {\n@@ -1493,6 +1522,7 @@ impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {\n \n impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        assert_default_hashing_controls(ctx, \"ExpnId\");\n         let hash = if *self == ExpnId::root() {\n             // Avoid fetching TLS storage for a trivial often-used value.\n             Fingerprint::ZERO"}, {"sha": "9602bc5d0b7d47e88545b509503d0caef0f1bae8", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "patch": "@@ -42,6 +42,7 @@ pub mod hygiene;\n use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnKind, MacroKind};\n pub use hygiene::{ExpnData, ExpnHash, ExpnId, LocalExpnId, SyntaxContext};\n+use rustc_data_structures::stable_hasher::HashingControls;\n pub mod def_id;\n use def_id::{CrateNum, DefId, DefPathHash, LocalDefId, LOCAL_CRATE};\n pub mod lev_distance;\n@@ -2057,11 +2058,15 @@ impl InnerSpan {\n pub trait HashStableContext {\n     fn def_path_hash(&self, def_id: DefId) -> DefPathHash;\n     fn hash_spans(&self) -> bool;\n+    /// Accesses `sess.opts.debugging_opts.incremental_ignore_spans` since\n+    /// we don't have easy access to a `Session`\n+    fn debug_opts_incremental_ignore_spans(&self) -> bool;\n     fn def_span(&self, def_id: LocalDefId) -> Span;\n     fn span_data_to_lines_and_cols(\n         &mut self,\n         span: &SpanData,\n     ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)>;\n+    fn hashing_controls(&self) -> HashingControls;\n }\n \n impl<CTX> HashStable<CTX> for Span"}, {"sha": "6d02d04fe80e751d8af642010eeedffaf699a20c", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63a8d965e76f29a2b65c1f22a32613df1fe5c2c/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=d63a8d965e76f29a2b65c1f22a32613df1fe5c2c", "patch": "@@ -113,29 +113,29 @@ fn get_symbol_hash<'tcx>(\n         hcx.while_hashing_spans(false, |hcx| {\n             hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                 item_type.hash_stable(hcx, &mut hasher);\n-            });\n-        });\n \n-        // If this is a function, we hash the signature as well.\n-        // This is not *strictly* needed, but it may help in some\n-        // situations, see the `run-make/a-b-a-linker-guard` test.\n-        if let ty::FnDef(..) = item_type.kind() {\n-            item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n-        }\n+                // If this is a function, we hash the signature as well.\n+                // This is not *strictly* needed, but it may help in some\n+                // situations, see the `run-make/a-b-a-linker-guard` test.\n+                if let ty::FnDef(..) = item_type.kind() {\n+                    item_type.fn_sig(tcx).hash_stable(hcx, &mut hasher);\n+                }\n \n-        // also include any type parameters (for generic items)\n-        substs.hash_stable(&mut hcx, &mut hasher);\n+                // also include any type parameters (for generic items)\n+                substs.hash_stable(hcx, &mut hasher);\n \n-        if let Some(instantiating_crate) = instantiating_crate {\n-            tcx.def_path_hash(instantiating_crate.as_def_id())\n-                .stable_crate_id()\n-                .hash_stable(&mut hcx, &mut hasher);\n-        }\n+                if let Some(instantiating_crate) = instantiating_crate {\n+                    tcx.def_path_hash(instantiating_crate.as_def_id())\n+                        .stable_crate_id()\n+                        .hash_stable(hcx, &mut hasher);\n+                }\n \n-        // We want to avoid accidental collision between different types of instances.\n-        // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n-        // instances without this.\n-        discriminant(&instance.def).hash_stable(&mut hcx, &mut hasher);\n+                // We want to avoid accidental collision between different types of instances.\n+                // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n+                // instances without this.\n+                discriminant(&instance.def).hash_stable(hcx, &mut hasher);\n+            });\n+        });\n     });\n \n     // 64 bits should be enough to avoid collisions."}]}