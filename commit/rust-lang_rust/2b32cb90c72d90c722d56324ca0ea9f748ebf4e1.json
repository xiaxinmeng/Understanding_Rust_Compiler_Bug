{"sha": "2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMzJjYjkwYzcyZDkwYzcyMmQ1NjMyNGNhMGVhOWY3NDhlYmY0ZTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-27T20:48:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T18:01:01Z"}, "message": "retool MIR passes completely\n\nThe new setup is as follows. There is a pipeline of MIR passes that each\nrun **per def-id** to optimize a particular function. You are intended\nto request MIR at whatever stage you need it. At the moment, there is\nonly one stage you can request:\n\n- `optimized_mir(def_id)`\n\nThis yields the final product. Internally, it pulls the MIR for the\ngiven def-id through a series of steps. Right now, these are still using\nan \"interned ref-cell\" but they are intended to \"steal\" from one\nanother:\n\n- `mir_build` -- performs the initial construction for local MIR\n- `mir_pass_set` -- performs a suite of optimizations and transformations\n- `mir_pass` -- an individual optimization within a suite\n\nSo, to construct the optimized MIR, we invoke:\n\n    mir_pass_set((MIR_OPTIMIZED, def_id))\n\nwhich will build up the final MIR.", "tree": {"sha": "0cfe6e0ea8e729d8c0d3ec2781201a1ea5e6a01f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cfe6e0ea8e729d8c0d3ec2781201a1ea5e6a01f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "html_url": "https://github.com/rust-lang/rust/commit/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f23a7bc98a221db000991f6a618602a9a4b35759", "url": "https://api.github.com/repos/rust-lang/rust/commits/f23a7bc98a221db000991f6a618602a9a4b35759", "html_url": "https://github.com/rust-lang/rust/commit/f23a7bc98a221db000991f6a618602a9a4b35759"}], "stats": {"total": 530, "additions": 345, "deletions": 185}, "files": [{"sha": "9fab6564d9b002edfc893891bd6093a5a415d239", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 65, "deletions": 75, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use hir;\n-use hir::def_id::{DefId, LOCAL_CRATE};\n+use hir::def_id::DefId;\n use hir::map::DefPathData;\n use mir::{Mir, Promoted};\n use ty::TyCtxt;\n+use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n use syntax::ast::NodeId;\n-use util::common::time;\n \n use std::borrow::Cow;\n \n@@ -90,12 +90,37 @@ pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n     }\n }\n \n+/// Gives you access to various bits of state during your MIR pass.\n+pub trait MirCtxt<'a, 'tcx: 'a> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+    fn def_id(&self) -> DefId;\n+    fn pass_set(&self) -> MirPassSet;\n+    fn pass_num(&self) -> MirPassIndex;\n+    fn source(&self) -> MirSource;\n+    fn read_previous_mir(&self) -> Ref<'tcx, Mir<'tcx>>;\n+    fn steal_previous_mir(&self) -> &'tcx RefCell<Mir<'tcx>>;\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct MirPassSet(pub usize);\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct MirPassIndex(pub usize);\n+\n+/// A pass hook is invoked both before and after each pass executes.\n+/// This is primarily used to dump MIR for debugging.\n+///\n+/// You can tell whether this is before or after by inspecting the\n+/// `mir` parameter -- before the pass executes, it will be `None` (in\n+/// which case you can inspect the MIR from previous pass by executing\n+/// `mir_cx.read_previous_mir()`); after the pass executes, it will be\n+/// `Some()` with the result of the pass (in which case the output\n+/// from the previous pass is most likely stolen, so you would not\n+/// want to try and access it).\n pub trait PassHook {\n-    fn on_mir_pass<'a, 'tcx>(&self,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             pass_name: &str,\n-                             pass_num: usize,\n-                             is_after: bool);\n+    fn on_mir_pass<'a, 'tcx: 'a>(&self,\n+                                 mir_cx: &MirCtxt<'a, 'tcx>,\n+                                 mir: Option<&Mir<'tcx>>);\n }\n \n /// A streamlined trait that you can implement to create a pass; the\n@@ -107,21 +132,7 @@ pub trait DefIdPass {\n         default_name::<Self>()\n     }\n \n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          def_id: DefId);\n-}\n-\n-impl<T: DefIdPass> Pass for T {\n-    fn name<'a>(&'a self) -> Cow<'a, str> {\n-        DefIdPass::name(self)\n-    }\n-\n-    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-        for &def_id in tcx.mir_keys(LOCAL_CRATE).iter() {\n-            DefIdPass::run_pass(self, tcx, def_id);\n-        }\n-    }\n+    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>) -> &'tcx RefCell<Mir<'tcx>>;\n }\n \n /// A streamlined trait that you can implement to create a pass; the\n@@ -138,42 +149,32 @@ pub trait MirPass: DepGraphSafe {\n                           mir: &mut Mir<'tcx>);\n }\n \n-fn for_each_assoc_mir<'a, 'tcx, OP>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    def_id: DefId,\n-                                    mut op: OP)\n-    where OP: FnMut(MirSource, &mut Mir<'tcx>)\n-{\n-    let id = tcx.hir.as_local_node_id(def_id).expect(\"mir source requires local def-id\");\n-    let source = MirSource::from_node(tcx, id);\n-    let mir = &mut tcx.mir(def_id).borrow_mut();\n-    op(source, mir);\n-\n-    for (promoted_index, promoted_mir) in mir.promoted.iter_enumerated_mut() {\n-        let promoted_source = MirSource::Promoted(id, promoted_index);\n-        op(promoted_source, promoted_mir);\n-    }\n-}\n-\n impl<T: MirPass> DefIdPass for T {\n     fn name<'a>(&'a self) -> Cow<'a, str> {\n         MirPass::name(self)\n     }\n \n-    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-        for_each_assoc_mir(tcx, def_id, |src, mir| MirPass::run_pass(self, tcx, src, mir));\n+    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>) -> &'tcx RefCell<Mir<'tcx>> {\n+        let tcx = mir_cx.tcx();\n+        let source = mir_cx.source();\n+        let mir = mir_cx.steal_previous_mir();\n+        MirPass::run_pass(self, tcx, source, &mut mir.borrow_mut());\n+\n+        let item_id = source.item_id();\n+        for (promoted_index, promoted_mir) in mir.borrow_mut().promoted.iter_enumerated_mut() {\n+            let promoted_source = MirSource::Promoted(item_id, promoted_index);\n+            MirPass::run_pass(self, tcx, promoted_source, promoted_mir);\n+        }\n+\n+        mir\n     }\n }\n \n /// A manager for MIR passes.\n #[derive(Clone)]\n pub struct Passes {\n     pass_hooks: Vec<Rc<PassHook>>,\n-    sets: Vec<PassSet>,\n-}\n-\n-#[derive(Clone)]\n-struct PassSet {\n-    passes: Vec<Rc<DefIdPass>>,\n+    sets: Vec<Vec<Rc<DefIdPass>>>,\n }\n \n /// The number of \"pass sets\" that we have:\n@@ -184,52 +185,41 @@ struct PassSet {\n pub const MIR_PASS_SETS: usize = 3;\n \n /// Run the passes we need to do constant qualification and evaluation.\n-pub const MIR_CONST: usize = 0;\n+pub const MIR_CONST: MirPassSet = MirPassSet(0);\n \n /// Run the passes we need to consider the MIR validated and ready for borrowck etc.\n-pub const MIR_VALIDATED: usize = 1;\n+pub const MIR_VALIDATED: MirPassSet = MirPassSet(1);\n \n /// Run the passes we need to consider the MIR *optimized*.\n-pub const MIR_OPTIMIZED: usize = 2;\n+pub const MIR_OPTIMIZED: MirPassSet = MirPassSet(2);\n \n impl<'a, 'tcx> Passes {\n     pub fn new() -> Passes {\n         Passes {\n             pass_hooks: Vec::new(),\n-            sets: (0..MIR_PASS_SETS).map(|_| PassSet { passes: Vec::new() }).collect(),\n-        }\n-    }\n-\n-    pub fn run_passes(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, set_index: usize) {\n-        let set = &self.sets[set_index];\n-\n-        let start_num: usize = self.sets[..set_index].iter().map(|s| s.passes.len()).sum();\n-\n-        // NB: passes are numbered from 1, since \"construction\" is zero.\n-        for (pass, pass_num) in set.passes.iter().zip(start_num + 1..) {\n-            for hook in &self.pass_hooks {\n-                hook.on_mir_pass(tcx, &pass.name(), pass_num, false);\n-            }\n-\n-            time(tcx.sess.time_passes(), &*pass.name(), || {\n-                for &def_id in tcx.mir_keys(LOCAL_CRATE).iter() {\n-                    pass.run_pass(tcx, def_id);\n-                }\n-            });\n-\n-            for hook in &self.pass_hooks {\n-                hook.on_mir_pass(tcx, &pass.name(), pass_num, true);\n-            }\n+            sets: (0..MIR_PASS_SETS).map(|_| Vec::new()).collect(),\n         }\n     }\n \n     /// Pushes a built-in pass.\n-    pub fn push_pass<T: DefIdPass + 'static>(&mut self, set: usize, pass: T) {\n-        self.sets[set].passes.push(Rc::new(pass));\n+    pub fn push_pass<T: DefIdPass + 'static>(&mut self, set: MirPassSet, pass: T) {\n+        self.sets[set.0].push(Rc::new(pass));\n     }\n \n     /// Pushes a pass hook.\n     pub fn push_hook<T: PassHook + 'static>(&mut self, hook: T) {\n         self.pass_hooks.push(Rc::new(hook));\n     }\n+\n+    pub fn len_passes(&self, set: MirPassSet) -> usize {\n+        self.sets[set.0].len()\n+    }\n+\n+    pub fn pass(&self, set: MirPassSet, pass: MirPassIndex) -> &DefIdPass {\n+        &*self.sets[set.0][pass.0]\n+    }\n+\n+    pub fn hooks(&self) -> &[Rc<PassHook>] {\n+        &self.pass_hooks\n+    }\n }"}, {"sha": "dc70dcc81162f8a8a0ca0cbfac5e2c1f6c9370ff", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -16,6 +16,7 @@ use middle::const_val;\n use middle::privacy::AccessLevels;\n use middle::region::RegionMaps;\n use mir;\n+use mir::transform::{MirPassSet, MirPassIndex};\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::item_path;\n@@ -101,6 +102,24 @@ impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n     }\n }\n \n+impl Key for (MirPassSet, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.1.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (MirPassSet, MirPassIndex, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.2.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.2.default_span(tcx)\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n@@ -318,6 +337,18 @@ impl<'tcx> QueryDescription for queries::is_item_mir_available<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::mir_pass_set<'tcx> {\n+    fn describe(_: TyCtxt, (pass_set, _): (MirPassSet, DefId)) -> String {\n+        format!(\"MIR passes #{}.*\", pass_set.0)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::mir_pass<'tcx> {\n+    fn describe(_: TyCtxt, (pass_set, pass_num, _): (MirPassSet, MirPassIndex, DefId)) -> String {\n+        format!(\"MIR pass #{}.{}\", pass_set.0, pass_num.0)\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -542,15 +573,6 @@ define_maps! { <'tcx>\n     /// Methods in these implementations don't need to be exported.\n     [] inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n-    /// Maps from the def-id of a function/method or const/static\n-    /// to its MIR. Mutation is done at an item granularity to\n-    /// allow MIR optimization passes to function and still\n-    /// access cross-crate MIR (e.g. inlining or const eval).\n-    ///\n-    /// Note that cross-crate MIR appears to be always borrowed\n-    /// (in the `RefCell` sense) to prevent accidental mutation.\n-    [] mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n-\n     /// Set of all the def-ids in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors.\n@@ -561,6 +583,26 @@ define_maps! { <'tcx>\n     /// the value isn't known except to the pass itself.\n     [] mir_const_qualif: Mir(DefId) -> u8,\n \n+    /// Performs the initial MIR construction. You almost certainly do not\n+    /// want to use this query, because its output is intended to be stolen\n+    /// immediately by the MIR passes below. Consider `optimized_mir` instead.\n+    [] mir_build: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+\n+    /// Fetch the MIR for a given def-id after the given set of passes has ben\n+    /// applied to it. This is mostly an \"intermediate\" query. Normally, you would\n+    /// prefer to use `optimized_mir(def_id)`, which will fetch the MIR after all\n+    /// optimizations and so forth.\n+    [] mir_pass_set: mir_pass_set((MirPassSet, DefId)) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+\n+    /// Fetch the MIR for a given def-id after a given pass has been executed. This is\n+    /// **only** intended to be used by the `mir_pass_set` provider -- if you are using it\n+    /// manually, you're doing it wrong.\n+    [] mir_pass: mir_pass((MirPassSet, MirPassIndex, DefId)) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+\n+    /// MIR after our optimization passes have run. This is MIR that is ready\n+    /// for trans. This is also the only query that can fetch non-local MIR, at present.\n+    [] optimized_mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+\n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n     [] closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n@@ -658,3 +700,11 @@ fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n     DepNode::MirKeys\n }\n+\n+fn mir_pass_set((_pass_set, def_id): (MirPassSet, DefId)) -> DepNode<DefId> {\n+    DepNode::Mir(def_id)\n+}\n+\n+fn mir_pass((_pass_set, _pass_num, def_id): (MirPassSet, MirPassIndex, DefId)) -> DepNode<DefId> {\n+    DepNode::Mir(def_id)\n+}"}, {"sha": "cf66c83800d367d908b4a57f7c8b0dcec065f42c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -2323,18 +2323,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given the did of an item, returns its MIR, borrowed immutably.\n+    /// Given the did of an item, returns its (optimized) MIR, borrowed immutably.\n     pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n-        self.mir(did).borrow()\n+        self.optimized_mir(did).borrow()\n     }\n \n     /// Return the possibly-auto-generated MIR of a (DefId, Subst) pair.\n     pub fn instance_mir(self, instance: ty::InstanceDef<'gcx>)\n                         -> Ref<'gcx, Mir<'gcx>>\n     {\n         match instance {\n-            ty::InstanceDef::Item(did) if true => self.item_mir(did),\n-            _ => self.mir_shims(instance).borrow(),\n+            ty::InstanceDef::Item(did) => {\n+                self.item_mir(did)\n+            }\n+            ty::InstanceDef::Intrinsic(..) |\n+            ty::InstanceDef::FnPtrShim(..) |\n+            ty::InstanceDef::Virtual(..) |\n+            ty::InstanceDef::ClosureOnceShim { .. } |\n+            ty::InstanceDef::DropGlue(..) => {\n+                self.mir_shims(instance).borrow()\n+            }\n         }\n     }\n "}, {"sha": "9b11d168e007732d57261939e5fe10529693e541", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -1005,11 +1005,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             mir_stats::print_mir_stats(tcx, \"PRE CLEANUP MIR STATS\");\n         }\n \n-        time(time_passes, \"MIR cleanup and validation\", || {\n-            tcx.mir_passes.run_passes(tcx, MIR_CONST);\n-            tcx.mir_passes.run_passes(tcx, MIR_VALIDATED);\n-        });\n-\n         time(time_passes,\n              \"borrow checking\",\n              || borrowck::check_crate(tcx));\n@@ -1058,20 +1053,6 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          \"resolving dependency formats\",\n          || dependency_format::calculate(&tcx.sess));\n \n-    if tcx.sess.opts.debugging_opts.mir_stats {\n-        mir_stats::print_mir_stats(tcx, \"PRE OPTIMISATION MIR STATS\");\n-    }\n-\n-    // Run the passes that transform the MIR into a more suitable form for translation to LLVM\n-    // code.\n-    time(time_passes, \"MIR optimisations\", || {\n-        tcx.mir_passes.run_passes(tcx, MIR_OPTIMIZED);\n-    });\n-\n-    if tcx.sess.opts.debugging_opts.mir_stats {\n-        mir_stats::print_mir_stats(tcx, \"POST OPTIMISATION MIR STATS\");\n-    }\n-\n     let translation =\n         time(time_passes,\n              \"translation\","}, {"sha": "4ecce3cc132fe72af74a63d779f24271fad41c80", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -95,7 +95,7 @@ provide! { <'tcx> tcx, def_id, cdata\n             bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n         })\n     }\n-    mir => {\n+    optimized_mir => {\n         let mir = cdata.maybe_get_item_mir(tcx, def_id.index).unwrap_or_else(|| {\n             bug!(\"get_item_mir: missing MIR for `{:?}`\", def_id)\n         });"}, {"sha": "cf6a50563a08c34ee84dd4e51d4ef60b00db4f78", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -59,5 +59,5 @@ use rustc::ty::maps::Providers;\n pub fn provide(providers: &mut Providers) {\n     mir_map::provide(providers);\n     shim::provide(providers);\n-    transform::qualify_consts::provide(providers);\n+    transform::provide(providers);\n }"}, {"sha": "46f7c34c06e8d68b4c478e935fe52af2a865ef8b", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -52,8 +52,11 @@ pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n pub fn provide(providers: &mut Providers) {\n-    providers.mir = build_mir;\n-    providers.mir_keys = mir_keys;\n+    *providers = Providers {\n+        mir_build,\n+        mir_keys,\n+        ..*providers\n+    };\n }\n \n fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n@@ -95,8 +98,7 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n     Rc::new(set)\n }\n \n-fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                       -> &'tcx RefCell<Mir<'tcx>> {\n+fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx RefCell<Mir<'tcx>> {\n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let unsupported = || {\n         span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id);\n@@ -192,7 +194,7 @@ fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             mem::transmute::<Mir, Mir<'tcx>>(mir)\n         };\n \n-        mir_util::dump_mir(tcx, 0, \"mir_map\", &0, src, &mir);\n+        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n \n         tcx.alloc_mir(mir)\n     })\n@@ -251,7 +253,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 mem::transmute::<Mir, Mir<'tcx>>(mir)\n             };\n \n-            mir_util::dump_mir(tcx, 0, \"mir_map\", &0, src, &mir);\n+            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n \n             tcx.alloc_mir(mir)\n         })"}, {"sha": "a76ba8a8b688ccfcc7e1ba147ba5b0feaa40e17e", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -11,14 +11,15 @@\n //! This pass just dumps MIR at a specified point.\n \n use std::borrow::Cow;\n+use std::cell::RefCell;\n use std::fmt;\n use std::fs::File;\n use std::io;\n \n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::TyCtxt;\n-use rustc::mir::transform::{DefIdPass, Pass, PassHook, MirSource};\n+use rustc::mir::Mir;\n+use rustc::mir::transform::{DefIdPass, PassHook, MirCtxt};\n use util as mir_util;\n \n pub struct Marker(pub &'static str);\n@@ -28,8 +29,8 @@ impl DefIdPass for Marker {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass<'a, 'tcx>(&self, _: TyCtxt<'a, 'tcx, 'tcx>, _: DefId) {\n-        // no-op\n+    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>) -> &'tcx RefCell<Mir<'tcx>> {\n+        mir_cx.steal_previous_mir()\n     }\n }\n \n@@ -47,30 +48,31 @@ impl fmt::Display for Disambiguator {\n pub struct DumpMir;\n \n impl PassHook for DumpMir {\n-    fn on_mir_pass<'a, 'tcx>(\n-        &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        pass_name: &str,\n-        pass_num: usize,\n-        is_after: bool)\n+    fn on_mir_pass<'a, 'tcx: 'a>(&self,\n+                             mir_cx: &MirCtxt<'a, 'tcx>,\n+                             mir: Option<&Mir<'tcx>>)\n     {\n-        // No dump filters enabled.\n-        if tcx.sess.opts.debugging_opts.dump_mir.is_none() {\n-            return;\n-        }\n-\n-        for &def_id in tcx.mir_keys(LOCAL_CRATE).iter() {\n-            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-            let source = MirSource::from_node(tcx, id);\n-            let mir = tcx.item_mir(def_id);\n-            mir_util::dump_mir(\n-                tcx,\n-                pass_num,\n-                &pass_name,\n-                &Disambiguator { is_after },\n-                source,\n-                &mir\n-            );\n+        let tcx = mir_cx.tcx();\n+        let pass_set = mir_cx.pass_set();\n+        let pass_num = mir_cx.pass_num();\n+        let pass = tcx.mir_passes.pass(pass_set, pass_num);\n+        let name = &pass.name();\n+        let source = mir_cx.source();\n+        if mir_util::dump_enabled(tcx, name, source) {\n+            let previous_mir;\n+            let mir_to_dump = match mir {\n+                Some(m) => m,\n+                None => {\n+                    previous_mir = mir_cx.read_previous_mir();\n+                    &*previous_mir\n+                }\n+            };\n+            mir_util::dump_mir(tcx,\n+                               Some((pass_set, pass_num)),\n+                               name,\n+                               &Disambiguator { is_after: mir.is_some() },\n+                               source,\n+                               mir_to_dump);\n         }\n     }\n }"}, {"sha": "6eda2f5abb9d8b66dcff509af856f6bd15a3b9a0", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -27,6 +27,7 @@ use rustc::util::nodemap::{DefIdSet};\n \n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n \n+use std::cell::{Ref, RefCell};\n use syntax::{attr};\n use syntax::abi::Abi;\n \n@@ -74,6 +75,14 @@ struct CallSite<'tcx> {\n }\n \n impl<'a, 'tcx> Inliner<'a, 'tcx> {\n+    fn maybe_item_mir(&mut self, _def_id: DefId) -> Option<Ref<'tcx, Mir<'tcx>>> {\n+        panic!() // TODO -- hook up inline into the system\n+    }\n+\n+    fn mir(&mut self, _def_id: DefId) -> &'tcx RefCell<Mir<'tcx>> {\n+        panic!() // TODO -- hook up inline into the system\n+    }\n+\n     fn inline_scc(&mut self, callgraph: &callgraph::CallGraph, scc: &[graph::NodeIndex]) -> bool {\n         let mut callsites = Vec::new();\n         let mut in_scc = DefIdSet();\n@@ -146,7 +155,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 self.tcx.dep_graph.write(DepNode::Mir(callsite.caller));\n \n                 let callee_mir = {\n-                    if let Some(callee_mir) = self.tcx.maybe_item_mir(callsite.callee) {\n+                    if let Some(callee_mir) = self.maybe_item_mir(callsite.callee) {\n                         if !self.should_inline(callsite, &callee_mir) {\n                             continue;\n                         }\n@@ -158,7 +167,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                 };\n \n-                let mut caller_mir = self.tcx.mir(callsite.caller).borrow_mut();\n+                let mut caller_mir = self.mir(callsite.caller).borrow_mut();\n \n                 let start = caller_mir.basic_blocks().len();\n \n@@ -210,7 +219,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             let _task = self.tcx.dep_graph.in_task(DepNode::Mir(def_id));\n             self.tcx.dep_graph.write(DepNode::Mir(def_id));\n \n-            let mut caller_mir = self.tcx.mir(def_id).borrow_mut();\n+            let mut caller_mir = self.mir(def_id).borrow_mut();\n \n             debug!(\"Running simplify cfg on {:?}\", def_id);\n             CfgSimplifier::new(&mut caller_mir).simplify();"}, {"sha": "68070ded12d9899ba6ea17bc9f70356658f82767", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -8,6 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::hir::def_id::DefId;\n+use rustc::mir::Mir;\n+use rustc::mir::transform::{MirCtxt, MirPassIndex, MirPassSet, MirSource, MIR_OPTIMIZED};\n+use rustc::ty::TyCtxt;\n+use rustc::ty::maps::Providers;\n+use std::cell::{Ref, RefCell};\n+use std::mem;\n+\n pub mod simplify_branches;\n pub mod simplify;\n pub mod erase_regions;\n@@ -21,3 +29,101 @@ pub mod deaggregator;\n pub mod instcombine;\n pub mod copy_prop;\n pub mod inline;\n+\n+pub fn provide(providers: &mut Providers) {\n+    self::qualify_consts::provide(providers);\n+    *providers = Providers {\n+        optimized_mir,\n+        mir_pass_set,\n+        mir_pass,\n+        ..*providers\n+    };\n+}\n+\n+fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx RefCell<Mir<'tcx>> {\n+    let mir = tcx.mir_pass_set((MIR_OPTIMIZED, def_id));\n+\n+    // \"lock\" the ref cell into read mode; after this point,\n+    // there ought to be no more changes to the MIR.\n+    mem::drop(mir.borrow());\n+\n+    mir\n+}\n+\n+fn mir_pass_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          (pass_set, def_id): (MirPassSet, DefId))\n+                          -> &'tcx RefCell<Mir<'tcx>>\n+{\n+    let passes = &tcx.mir_passes;\n+    let len = passes.len_passes(pass_set);\n+    assert!(len > 0, \"no passes in {:?}\", pass_set);\n+    tcx.mir_pass((pass_set, MirPassIndex(len - 1), def_id))\n+}\n+\n+fn mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                      (pass_set, pass_num, def_id): (MirPassSet, MirPassIndex, DefId))\n+                      -> &'tcx RefCell<Mir<'tcx>>\n+{\n+    let passes = &tcx.mir_passes;\n+    let pass = passes.pass(pass_set, pass_num);\n+    let mir_ctxt = MirCtxtImpl { tcx, pass_num, pass_set, def_id };\n+\n+    for hook in passes.hooks() {\n+        hook.on_mir_pass(&mir_ctxt, None);\n+    }\n+\n+    let mir = pass.run_pass(&mir_ctxt);\n+\n+    for hook in passes.hooks() {\n+        hook.on_mir_pass(&mir_ctxt, Some(&mir.borrow()));\n+    }\n+\n+    mir\n+}\n+\n+struct MirCtxtImpl<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pass_num: MirPassIndex,\n+    pass_set: MirPassSet,\n+    def_id: DefId\n+}\n+\n+impl<'a, 'tcx> MirCtxt<'a, 'tcx> for MirCtxtImpl<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn pass_set(&self) -> MirPassSet {\n+        self.pass_set\n+    }\n+\n+    fn pass_num(&self) -> MirPassIndex {\n+        self.pass_num\n+    }\n+\n+    fn def_id(&self) -> DefId {\n+        self.def_id\n+    }\n+\n+    fn source(&self) -> MirSource {\n+        let id = self.tcx.hir.as_local_node_id(self.def_id)\n+                             .expect(\"mir source requires local def-id\");\n+        MirSource::from_node(self.tcx, id)\n+    }\n+\n+    fn read_previous_mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n+        self.steal_previous_mir().borrow()\n+    }\n+\n+    fn steal_previous_mir(&self) -> &'tcx RefCell<Mir<'tcx>> {\n+        let MirPassSet(pass_set) = self.pass_set;\n+        let MirPassIndex(pass_num) = self.pass_num;\n+        if pass_num > 0 {\n+            self.tcx.mir_pass((MirPassSet(pass_set), MirPassIndex(pass_num - 1), self.def_id))\n+        } else if pass_set > 0 {\n+            self.tcx.mir_pass_set((MirPassSet(pass_set - 1), self.def_id))\n+        } else {\n+            self.tcx.mir_build(self.def_id)\n+        }\n+    }\n+}"}, {"sha": "cb002acf009d1256351e9508e721d5174d74cba0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -16,7 +16,6 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n@@ -27,13 +26,14 @@ use rustc::ty::cast::CastTy;\n use rustc::ty::maps::Providers;\n use rustc::mir::*;\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::mir::transform::{DefIdPass, MirSource};\n+use rustc::mir::transform::{DefIdPass, MirCtxt, MirSource, MIR_CONST};\n use rustc::mir::visit::{LvalueContext, Visitor};\n use rustc::middle::lang_items;\n use syntax::abi::Abi;\n use syntax::feature_gate::UnstableFeatures;\n use syntax_pos::{Span, DUMMY_SP};\n \n+use std::cell::RefCell;\n use std::fmt;\n use std::usize;\n \n@@ -925,7 +925,7 @@ pub fn provide(providers: &mut Providers) {\n fn qualify_const_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 def_id: DefId)\n                                 -> u8 {\n-    let mir = &tcx.item_mir(def_id);\n+    let mir = &tcx.mir_pass_set((MIR_CONST, def_id)).borrow();\n     if mir.return_ty.references_error() {\n         return Qualif::NOT_CONST.bits();\n     }\n@@ -940,30 +940,32 @@ fn qualify_const_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub struct QualifyAndPromoteConstants;\n \n impl DefIdPass for QualifyAndPromoteConstants {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          def_id: DefId)\n-    {\n-        let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        let src = MirSource::from_node(tcx, id);\n-\n-        if let MirSource::Const(_) = src {\n-            tcx.mir_const_qualif(def_id);\n-            return;\n-        }\n-\n-        let mir = &mut tcx.mir(def_id).borrow_mut();\n-        tcx.dep_graph.write(DepNode::Mir(def_id));\n+    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>) -> &'tcx RefCell<Mir<'tcx>> {\n+        let tcx = mir_cx.tcx();\n+        match mir_cx.source() {\n+            MirSource::Const(_) => {\n+                // Ensure that we compute the `mir_const_qualif` for\n+                // constants at this point, before we do any further\n+                // optimization (and before we steal the previous\n+                // MIR).\n+                tcx.mir_const_qualif(mir_cx.def_id());\n+                mir_cx.steal_previous_mir()\n+            }\n \n-        self.run_pass(tcx, src, mir);\n+            src => {\n+                let mir = mir_cx.steal_previous_mir();\n+                self.run_pass(tcx, src, &mut mir.borrow_mut());\n+                mir\n+            }\n+        }\n     }\n }\n \n impl<'a, 'tcx> QualifyAndPromoteConstants {\n     fn run_pass(&self,\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                src: MirSource, mir: &mut Mir<'tcx>) {\n+                src: MirSource,\n+                mir: &mut Mir<'tcx>) {\n         let id = src.item_id();\n         let def_id = tcx.hir.local_def_id(id);\n         let mode = match src {"}, {"sha": "4386bab38c0399650bb461a6a6d7cfc16cacedbe", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -15,6 +15,6 @@ pub mod patch;\n mod graphviz;\n mod pretty;\n \n-pub use self::pretty::{dump_mir, write_mir_pretty};\n+pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty};\n pub use self::graphviz::{write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;"}, {"sha": "e8fc70b74bcb77570d8038e246e9bb43dab0e805", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b32cb90c72d90c722d56324ca0ea9f748ebf4e1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=2b32cb90c72d90c722d56324ca0ea9f748ebf4e1", "patch": "@@ -11,7 +11,7 @@\n use rustc::hir;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::*;\n-use rustc::mir::transform::MirSource;\n+use rustc::mir::transform::{MirPassSet, MirPassIndex, MirSource};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx};\n@@ -39,38 +39,45 @@ const ALIGN: usize = 40;\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          pass_num: usize,\n+                          pass_num: Option<(MirPassSet, MirPassIndex)>,\n                           pass_name: &str,\n                           disambiguator: &Display,\n                           source: MirSource,\n                           mir: &Mir<'tcx>) {\n-    let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n-        None => return,\n-        Some(ref filters) => filters,\n-    };\n-    let node_id = source.item_id();\n-    let node_path = tcx.item_path_str(tcx.hir.local_def_id(node_id));\n-    let is_matched =\n-        filters.split(\"&\")\n-               .any(|filter| {\n-                   filter == \"all\" ||\n-                       pass_name.contains(filter) ||\n-                       node_path.contains(filter)\n-               });\n-    if !is_matched {\n+    if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n \n-    dump_matched_mir_node(tcx, pass_num, pass_name, &node_path, disambiguator, source, mir);\n+    let node_path = tcx.item_path_str(tcx.hir.local_def_id(source.item_id()));\n+    dump_matched_mir_node(tcx, pass_num, pass_name, &node_path,\n+                          disambiguator, source, mir);\n     for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n         let promoted_source = MirSource::Promoted(source.item_id(), index);\n         dump_matched_mir_node(tcx, pass_num, pass_name, &node_path, disambiguator,\n                               promoted_source, promoted_mir);\n     }\n }\n \n+pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              pass_name: &str,\n+                              source: MirSource)\n+                              -> bool {\n+    let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n+        None => return false,\n+        Some(ref filters) => filters,\n+    };\n+    let node_id = source.item_id();\n+    let node_path = tcx.item_path_str(tcx.hir.local_def_id(node_id));\n+    filters.split(\"&\")\n+           .any(|filter| {\n+               filter == \"all\" ||\n+                   pass_name.contains(filter) ||\n+                   node_path.contains(filter)\n+           })\n+}\n+\n fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   pass_num: usize,\n+                                   pass_num: Option<(MirPassSet, MirPassIndex)>,\n                                    pass_name: &str,\n                                    node_path: &str,\n                                    disambiguator: &Display,\n@@ -84,7 +91,10 @@ fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let pass_num = if tcx.sess.opts.debugging_opts.dump_mir_exclude_pass_number {\n         format!(\"\")\n     } else {\n-        format!(\".{:03}\", pass_num)\n+        match pass_num {\n+            None => format!(\".-------\"),\n+            Some((pass_set, pass_num)) => format!(\".{:03}-{:03}\", pass_set.0, pass_num.0),\n+        }\n     };\n \n     let mut file_path = PathBuf::new();"}]}