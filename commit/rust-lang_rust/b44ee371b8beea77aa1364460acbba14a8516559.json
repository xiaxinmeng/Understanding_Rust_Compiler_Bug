{"sha": "b44ee371b8beea77aa1364460acbba14a8516559", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NGVlMzcxYjhiZWVhNzdhYTEzNjQ0NjBhY2JiYTE0YTg1MTY1NTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-24T05:48:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-24T05:48:20Z"}, "message": "grandfathered -> rust1", "tree": {"sha": "92f5140fe5a2e5e364a4298651bf3c6bdf0f0940", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92f5140fe5a2e5e364a4298651bf3c6bdf0f0940"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b44ee371b8beea77aa1364460acbba14a8516559", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b44ee371b8beea77aa1364460acbba14a8516559", "html_url": "https://github.com/rust-lang/rust/commit/b44ee371b8beea77aa1364460acbba14a8516559", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b44ee371b8beea77aa1364460acbba14a8516559/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7fe2c54b7d638e38fcbe3284ff6295f2df6c928", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7fe2c54b7d638e38fcbe3284ff6295f2df6c928", "html_url": "https://github.com/rust-lang/rust/commit/b7fe2c54b7d638e38fcbe3284ff6295f2df6c928"}], "stats": {"total": 2980, "additions": 1490, "deletions": 1490}, "files": [{"sha": "c8f568b07cbab00183dafa996b18d1aa1a92b4f4", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n //! Threadsafe reference-counted boxes (the `Arc<T>` type).\n //!\n@@ -110,7 +110,7 @@ use heap::deallocate;\n /// }\n /// ```\n #[unsafe_no_drop_flag]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -157,7 +157,7 @@ impl<T> Arc<T> {\n     /// let five = Arc::new(5i);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(data: T) -> Arc<T> {\n         // Start the weak pointer count as 1 which is the weak pointer that's\n         // held by all the strong pointers (kinda), see std/rc.rs for more info\n@@ -210,7 +210,7 @@ pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(SeqCst) - 1\n #[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(SeqCst) }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Arc<T> {\n     /// Makes a clone of the `Arc<T>`.\n     ///\n@@ -247,7 +247,7 @@ impl<T> BorrowFrom<Arc<T>> for T {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Arc<T> {\n     type Target = T;\n \n@@ -291,7 +291,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Sync + Send> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n@@ -421,7 +421,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Sync + Send> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///\n@@ -464,7 +464,7 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc<T>`s.\n     ///\n@@ -496,7 +496,7 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     /// ```\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// Partial comparison for two `Arc<T>`s.\n     ///\n@@ -575,11 +575,11 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Arc<T> {\n     fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Arc<T> {}\n \n impl<T: fmt::Show> fmt::Show for Arc<T> {\n@@ -588,16 +588,16 @@ impl<T: fmt::Show> fmt::Show for Arc<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::String> fmt::String for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&**self, f)\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default + Sync + Send> Default for Arc<T> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n "}, {"sha": "19fa6771fb7bcf73e7e88ef2149489079039f7f4", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! A unique pointer type.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::any::Any;\n use core::clone::Clone;\n@@ -50,30 +50,30 @@ pub static HEAP: () = ();\n \n /// A type that represents a uniquely-owned value.\n #[lang = \"owned_box\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Box<T>(Unique<T>);\n \n impl<T> Box<T> {\n     /// Moves `x` into a freshly allocated box on the global exchange heap.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(x: T) -> Box<T> {\n         box x\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Box<T> { box Default::default() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Box<[T]> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Box<[T]> { box [] }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for Box<T> {\n     /// Returns a copy of the owned box.\n     #[inline]\n@@ -86,14 +86,14 @@ impl<T: Clone> Clone for Box<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n@@ -108,14 +108,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n@@ -135,11 +135,11 @@ impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n pub trait BoxAny {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `Err(Self)` if it isn't.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Self>;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BoxAny for Box<Any> {\n     #[inline]\n     fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n@@ -164,7 +164,7 @@ impl<T: ?Sized + fmt::Show> fmt::Show for Box<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + fmt::String> fmt::String for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&**self, f)\n@@ -177,14 +177,14 @@ impl fmt::Show for Box<Any> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { &**self }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }"}, {"sha": "27153b12d871e6bfba18a72a1dfcc965494a3e53", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -142,7 +142,7 @@\n //! }\n //! ```\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::borrow::BorrowFrom;\n use core::cell::Cell;\n@@ -174,7 +174,7 @@ struct RcBox<T> {\n /// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n     // type via Deref\n@@ -187,7 +187,7 @@ pub struct Rc<T> {\n ///\n /// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n@@ -212,7 +212,7 @@ impl<T> Rc<T> {\n     /// let five = Rc::new(5i);\n     /// ```\n     #[cfg(stage0)] // NOTE remove after next snapshot\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -239,7 +239,7 @@ impl<T> Rc<T> {\n     ///\n     /// let five = Rc::new(5i);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n@@ -424,7 +424,7 @@ impl<T> BorrowFrom<Rc<T>> for T {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Rc<T> {\n     type Target = T;\n \n@@ -435,7 +435,7 @@ impl<T> Deref for Rc<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n     ///\n@@ -483,7 +483,7 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Rc<T> {\n     /// Makes a clone of the `Rc<T>`.\n     ///\n@@ -526,7 +526,7 @@ impl<T> Clone for Rc<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Rc<T> {\n     /// Creates a new `Rc<T>`, with the `Default` value for `T`.\n     ///\n@@ -539,13 +539,13 @@ impl<T: Default> Default for Rc<T> {\n     /// let x: Rc<int> = Default::default();\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Rc<T> {\n         Rc::new(Default::default())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc<T>`s.\n     ///\n@@ -580,10 +580,10 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Rc<T> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// Partial comparison for two `Rc<T>`s.\n     ///\n@@ -668,7 +668,7 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Rc<T> {\n     /// Comparison for two `Rc<T>`s.\n     ///\n@@ -702,7 +702,7 @@ impl<T: fmt::Show> fmt::Show for Rc<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::String> fmt::String for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&**self, f)\n@@ -807,7 +807,7 @@ impl<T> Weak<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///"}, {"sha": "13a37882ed9c9face4d283983106b297e1e7b63b", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -148,7 +148,7 @@\n //! ```\n \n #![allow(missing_docs)]\n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -164,12 +164,12 @@ use vec::{self, Vec};\n ///\n /// This will be a max-heap.\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n     fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n@@ -185,7 +185,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// heap.push(4u);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }\n \n     /// Creates an empty `BinaryHeap` with a specific capacity.\n@@ -200,7 +200,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::with_capacity(10);\n     /// heap.push(4u);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n@@ -238,7 +238,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.data.iter() }\n     }\n@@ -259,7 +259,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { iter: self.data.into_iter() }\n     }\n@@ -279,7 +279,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.peek(), Some(&5));\n     ///\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n     }\n@@ -294,7 +294,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n@@ -317,7 +317,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.data.reserve_exact(additional);\n     }\n@@ -338,13 +338,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert!(heap.capacity() >= 100);\n     /// heap.push(4u);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.data.reserve(additional);\n     }\n \n     /// Discards as much additional capacity as possible.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.data.shrink_to_fit();\n     }\n@@ -362,7 +362,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.pop(), Some(1));\n     /// assert_eq!(heap.pop(), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n             if !self.is_empty() {\n@@ -387,7 +387,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.len(), 3);\n     /// assert_eq!(heap.peek(), Some(&5));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n         self.data.push(item);\n@@ -542,11 +542,11 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Returns the length of the binary heap.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.data.len() }\n \n     /// Checks if the binary heap is empty.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the binary heap, returning an iterator over the removed elements.\n@@ -558,25 +558,25 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Drops all items from the binary heap.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.drain(); }\n }\n \n /// `BinaryHeap` iterator.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter <'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter { iter: self.iter.clone() }\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -587,22 +587,22 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     iter: vec::IntoIter<T>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -613,13 +613,13 @@ impl<T> Iterator for IntoIter<T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n@@ -628,7 +628,7 @@ pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -639,23 +639,23 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BinaryHeap<T> {\n         BinaryHeap::from_vec(iter.collect())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();"}, {"sha": "5ce88fff53af99b7dbb2b1cb90cf5e2c47980ea1", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -253,7 +253,7 @@ impl Bitv {\n     /// use std::collections::Bitv;\n     /// let mut bv = Bitv::new();\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Bitv {\n         Bitv { storage: Vec::new(), nbits: 0 }\n     }\n@@ -289,7 +289,7 @@ impl Bitv {\n     ///\n     /// It is important to note that this function does not specify the\n     /// *length* of the returned bitvector, but only the *capacity*.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(nbits: uint) -> Bitv {\n         Bitv {\n             storage: Vec::with_capacity(blocks_for_bits(nbits)),\n@@ -375,7 +375,7 @@ impl Bitv {\n     /// assert_eq!(bv[1], true);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, i: uint) -> Option<bool> {\n         if i >= self.nbits {\n             return None;\n@@ -587,7 +587,7 @@ impl Bitv {\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n         Iter { bitv: self, next_idx: 0, end_idx: self.nbits }\n     }\n@@ -708,7 +708,7 @@ impl Bitv {\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n@@ -735,7 +735,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n@@ -765,7 +765,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n@@ -787,7 +787,7 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.storage.capacity().checked_mul(u32::BITS).unwrap_or(uint::MAX)\n     }\n@@ -858,7 +858,7 @@ impl Bitv {\n     /// assert_eq!(bv.pop(), Some(false));\n     /// assert_eq!(bv.len(), 6);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<bool> {\n         if self.is_empty() {\n             None\n@@ -888,7 +888,7 @@ impl Bitv {\n     /// bv.push(false);\n     /// assert!(bv.eq_vec(&[true, false]));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, elem: bool) {\n         if self.nbits % u32::BITS == 0 {\n             self.storage.push(0);\n@@ -900,29 +900,29 @@ impl Bitv {\n \n     /// Return the total number of bits in this vector\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.nbits }\n \n     /// Returns true if there are no bits in this vector\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears all bits in this vector.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         for w in self.storage.iter_mut() { *w = 0u32; }\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for Bitv {\n     #[inline]\n     fn default() -> Bitv { Bitv::new() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<bool> for Bitv {\n     fn from_iter<I:Iterator<Item=bool>>(iterator: I) -> Bitv {\n         let mut ret = Bitv::new();\n@@ -931,7 +931,7 @@ impl FromIterator<bool> for Bitv {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<bool> for Bitv {\n     #[inline]\n     fn extend<I: Iterator<Item=bool>>(&mut self, mut iterator: I) {\n@@ -943,7 +943,7 @@ impl Extend<bool> for Bitv {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for Bitv {\n     #[inline]\n     fn clone(&self) -> Bitv {\n@@ -957,23 +957,23 @@ impl Clone for Bitv {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Bitv {\n     #[inline]\n     fn partial_cmp(&self, other: &Bitv) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for Bitv {\n     #[inline]\n     fn cmp(&self, other: &Bitv) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Show for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n@@ -983,7 +983,7 @@ impl fmt::Show for Bitv {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n@@ -993,7 +993,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for Bitv {\n     #[inline]\n     fn eq(&self, other: &Bitv) -> bool {\n@@ -1004,19 +1004,19 @@ impl cmp::PartialEq for Bitv {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Eq for Bitv {}\n \n /// An iterator for `Bitv`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Iter<'a> {\n     bitv: &'a Bitv,\n     next_idx: uint,\n     end_idx: uint,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Iter<'a> {\n     type Item = bool;\n \n@@ -1037,7 +1037,7 @@ impl<'a> Iterator for Iter<'a> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Iter<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<bool> {\n@@ -1050,10 +1050,10 @@ impl<'a> DoubleEndedIterator for Iter<'a> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> ExactSizeIterator for Iter<'a> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> RandomAccessIterator for Iter<'a> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1115,13 +1115,13 @@ pub struct BitvSet {\n     bitv: Bitv,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for BitvSet {\n     #[inline]\n     fn default() -> BitvSet { BitvSet::new() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<uint> for BitvSet {\n     fn from_iter<I:Iterator<Item=uint>>(iterator: I) -> BitvSet {\n         let mut ret = BitvSet::new();\n@@ -1130,7 +1130,7 @@ impl FromIterator<uint> for BitvSet {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<uint> for BitvSet {\n     #[inline]\n     fn extend<I: Iterator<Item=uint>>(&mut self, mut iterator: I) {\n@@ -1140,7 +1140,7 @@ impl Extend<uint> for BitvSet {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for BitvSet {\n     #[inline]\n     fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> {\n@@ -1149,7 +1149,7 @@ impl PartialOrd for BitvSet {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for BitvSet {\n     #[inline]\n     fn cmp(&self, other: &BitvSet) -> Ordering {\n@@ -1158,7 +1158,7 @@ impl Ord for BitvSet {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for BitvSet {\n     #[inline]\n     fn eq(&self, other: &BitvSet) -> bool {\n@@ -1167,7 +1167,7 @@ impl cmp::PartialEq for BitvSet {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Eq for BitvSet {}\n \n impl BitvSet {\n@@ -1181,7 +1181,7 @@ impl BitvSet {\n     /// let mut s = BitvSet::new();\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BitvSet {\n         BitvSet { bitv: Bitv::new() }\n     }\n@@ -1198,7 +1198,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n         let bitv = Bitv::from_elem(nbits, false);\n         BitvSet::from_bitv(bitv)\n@@ -1236,7 +1236,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.bitv.capacity()\n     }\n@@ -1257,7 +1257,7 @@ impl BitvSet {\n     /// s.reserve_len(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: uint) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n@@ -1283,7 +1283,7 @@ impl BitvSet {\n     /// s.reserve_len_exact(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: uint) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n@@ -1377,7 +1377,7 @@ impl BitvSet {\n     /// println!(\"new capacity: {}\", s.capacity());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         let bitv = &mut self.bitv;\n         // Obtain original length\n@@ -1405,7 +1405,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> bitv_set::Iter {\n         SetIter {set: self, next_idx: 0u}\n     }\n@@ -1427,7 +1427,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BitvSet) -> Union<'a> {\n         fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n \n@@ -1457,7 +1457,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Intersection<'a> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n         let min = cmp::min(self.bitv.len(), other.bitv.len());\n@@ -1494,7 +1494,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BitvSet) -> Difference<'a> {\n         fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n \n@@ -1525,7 +1525,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> SymmetricDifference<'a> {\n         fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n \n@@ -1642,28 +1642,28 @@ impl BitvSet {\n \n     /// Return the number of set bits in this set.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint  {\n         self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.bitv.none()\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.bitv.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains(&self, value: &uint) -> bool {\n         let bitv = &self.bitv;\n         *value < bitv.nbits && bitv[*value]\n@@ -1672,14 +1672,14 @@ impl BitvSet {\n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n     /// Returns `true` if the set is a subset of another.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BitvSet) -> bool {\n         let self_bitv = &self.bitv;\n         let other_bitv = &other.bitv;\n@@ -1693,14 +1693,14 @@ impl BitvSet {\n \n     /// Returns `true` if the set is a superset of another.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n \n     /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: uint) -> bool {\n         if self.contains(&value) {\n             return false;\n@@ -1718,7 +1718,7 @@ impl BitvSet {\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, value: &uint) -> bool {\n         if !self.contains(value) {\n             return false;\n@@ -1755,7 +1755,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n \n /// An iterator for `BitvSet`.\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SetIter<'a> {\n     set: &'a BitvSet,\n     next_idx: uint\n@@ -1771,16 +1771,16 @@ struct TwoBitPositions<'a> {\n     next_idx: uint\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a>(TwoBitPositions<'a>);\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a>(Take<TwoBitPositions<'a>>);\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a>(TwoBitPositions<'a>);\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SetIter<'a> {\n     type Item = uint;\n \n@@ -1803,7 +1803,7 @@ impl<'a> Iterator for SetIter<'a> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for TwoBitPositions<'a> {\n     type Item = uint;\n \n@@ -1841,31 +1841,31 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Union<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Intersection<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Difference<'a> {\n     type Item = uint;\n \n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SymmetricDifference<'a> {\n     type Item = uint;\n "}, {"sha": "8749c12abdbefc1464adfacd095129171457c127", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -81,7 +81,7 @@ use super::node::{self, Node, Found, GoDown};\n /// done on each operation isn't *catastrophic*, and *is* still bounded by O(B log<sub>B</sub>n),\n /// it is certainly much slower when it does.\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n     root: Node<K, V>,\n     length: uint,\n@@ -96,31 +96,31 @@ struct AbsIter<T> {\n }\n \n /// An iterator over a BTreeMap's entries.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: AbsIter<Traversal<'a, K, V>>\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: AbsIter<MutTraversal<'a, K, V>>\n }\n \n /// An owning iterator over a BTreeMap's entries.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     inner: AbsIter<MoveTraversal<K, V>>\n }\n \n /// An iterator over a BTreeMap's keys.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// An iterator over a BTreeMap's values.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n@@ -162,7 +162,7 @@ pub struct OccupiedEntry<'a, K:'a, V:'a> {\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with a reasonable choice for B.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeMap<K, V> {\n         //FIXME(Gankro): Tune this as a function of size_of<K/V>?\n         BTreeMap::with_b(6)\n@@ -193,7 +193,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n@@ -223,7 +223,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n@@ -255,7 +255,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n@@ -279,7 +279,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n@@ -340,7 +340,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {\n         // This is a stack of rawptrs to nodes paired with indices, respectively\n         // representing the nodes and edges of our search path. We have to store rawptrs\n@@ -449,7 +449,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n@@ -810,7 +810,7 @@ mod stack {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n@@ -819,7 +819,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n     fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n@@ -829,7 +829,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n         for elt in self.iter() {\n@@ -838,42 +838,42 @@ impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Default for BTreeMap<K, V> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> BTreeMap<K, V> {\n         BTreeMap::new()\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a == b)\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n     #[inline]\n     fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n     #[inline]\n     fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeMap {{\"));\n@@ -887,7 +887,7 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n@@ -898,7 +898,7 @@ impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n@@ -1009,75 +1009,75 @@ impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}\n \n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n impl<'a, K, V> Iterator for Range<'a, K, V> {\n@@ -1179,7 +1179,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let (first_key, first_value) = map.iter().next().unwrap();\n     /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n         let len = self.len();\n         // NB. The initial capacity for ringbuf is large enough to avoid reallocs in many cases.\n@@ -1212,7 +1212,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///     }\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         let len = self.len();\n         let mut lca = RingBuf::new();\n@@ -1241,7 +1241,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n         let mut lca = RingBuf::new();\n@@ -1268,7 +1268,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let keys: Vec<uint> = a.keys().cloned().collect();\n     /// assert_eq!(keys, vec![1u,2,]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n@@ -1290,7 +1290,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// let values: Vec<&str> = a.values().cloned().collect();\n     /// assert_eq!(values, vec![\"a\",\"b\"]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n@@ -1310,7 +1310,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -1325,7 +1325,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n "}, {"sha": "77dfac2893585b8fadc1da185e9be120e9595ff1", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -420,7 +420,7 @@ impl<K, V> Node<K, V> {\n }\n \n // FIXME(gereeter) Write an efficient clone_from\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Clone, V: Clone> Clone for Node<K, V> {\n     fn clone(&self) -> Node<K, V> {\n         let mut ret = if self.is_leaf() {"}, {"sha": "ef48074be490a9b660d2948bc248915e3264da4f", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -34,19 +34,19 @@ use Bound;\n /// See BTreeMap's documentation for a detailed discussion of this collection's performance\n /// benefits and drawbacks.\n #[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeSet<T>{\n     map: BTreeMap<T, ()>,\n }\n \n /// An iterator over a BTreeSet's items.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>\n }\n \n /// An owning iterator over a BTreeSet's items.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n@@ -57,28 +57,28 @@ pub struct Range<'a, T: 'a> {\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T:'a> {\n     a: Peekable<&'a T, Iter<'a, T>>,\n     b: Peekable<&'a T, Iter<'a, T>>,\n@@ -94,7 +94,7 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut set: BTreeSet<int> = BTreeSet::new();\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n@@ -126,7 +126,7 @@ impl<T> BTreeSet<T> {\n     /// let v: Vec<uint> = set.iter().map(|&x| x).collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n@@ -143,7 +143,7 @@ impl<T> BTreeSet<T> {\n     /// let v: Vec<uint> = set.into_iter().collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first; // coerce to fn pointer\n@@ -202,7 +202,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let diff: Vec<uint> = a.difference(&b).cloned().collect();\n     /// assert_eq!(diff, vec![1u]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n         Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -225,7 +225,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let sym_diff: Vec<uint> = a.symmetric_difference(&b).cloned().collect();\n     /// assert_eq!(sym_diff, vec![1u,3]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> SymmetricDifference<'a, T> {\n         SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -249,7 +249,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let intersection: Vec<uint> = a.intersection(&b).cloned().collect();\n     /// assert_eq!(intersection, vec![2u]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> Intersection<'a, T> {\n         Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -271,7 +271,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let union: Vec<uint> = a.union(&b).cloned().collect();\n     /// assert_eq!(union, vec![1u,2]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n         Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -288,7 +288,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -303,7 +303,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -318,7 +318,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.map.clear()\n     }\n@@ -338,7 +338,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n@@ -360,7 +360,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n@@ -381,7 +381,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Stolen from TreeMap\n         let mut x = self.iter();\n@@ -426,7 +426,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n         other.is_subset(self)\n     }\n@@ -445,7 +445,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.insert(2i), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool {\n         self.map.insert(value, ()).is_none()\n     }\n@@ -468,13 +468,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BTreeSet<T> {\n         let mut set = BTreeSet::new();\n@@ -483,7 +483,7 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n     fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n@@ -493,15 +493,15 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BTreeSet<T> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> BTreeSet<T> {\n         BTreeSet::new()\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -524,7 +524,7 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -547,7 +547,7 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -570,7 +570,7 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n@@ -593,7 +593,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Show> Show for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeSet {{\"));\n@@ -607,33 +607,33 @@ impl<T: Show> Show for BTreeSet<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n \n@@ -656,7 +656,7 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     type Item = &'a T;\n \n@@ -671,7 +671,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     type Item = &'a T;\n \n@@ -686,7 +686,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     type Item = &'a T;\n \n@@ -707,7 +707,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n "}, {"sha": "b580dfbdbf9e597bf99f0bd7157a60047589ffbe", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -19,7 +19,7 @@\n // Backlinks over DList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -33,7 +33,7 @@ use core::mem;\n use core::ptr;\n \n /// A doubly-linked list.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct DList<T> {\n     length: uint,\n     list_head: Link<T>,\n@@ -57,15 +57,15 @@ struct Node<T> {\n }\n \n /// An iterator over references to the items of a `DList`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: uint,\n }\n \n // FIXME #19839: deriving is too aggressive on the bounds (T doesn't need to be Clone).\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter {\n@@ -77,7 +77,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n }\n \n /// An iterator over mutable references to the items of a `DList`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n@@ -87,7 +87,7 @@ pub struct IterMut<'a, T:'a> {\n \n /// An iterator over mutable references to the items of a `DList`.\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     list: DList<T>\n }\n@@ -206,17 +206,17 @@ impl<T> DList<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for DList<T> {\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> DList<T> { DList::new() }\n }\n \n impl<T> DList<T> {\n     /// Creates an empty `DList`.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n@@ -273,14 +273,14 @@ impl<T> DList<T> {\n \n     /// Provides a forward iterator.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n@@ -296,7 +296,7 @@ impl<T> DList<T> {\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter{list: self}\n     }\n@@ -317,7 +317,7 @@ impl<T> DList<T> {\n     /// assert!(!dl.is_empty());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.list_head.is_none()\n     }\n@@ -344,7 +344,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint {\n         self.length\n     }\n@@ -371,7 +371,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         *self = DList::new()\n     }\n@@ -392,7 +392,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n         self.list_head.as_ref().map(|head| &head.value)\n     }\n@@ -419,7 +419,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list_head.as_mut().map(|head| &mut head.value)\n     }\n@@ -440,7 +440,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n         self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n     }\n@@ -467,7 +467,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list_tail.resolve().map(|tail| &mut tail.value)\n     }\n@@ -490,7 +490,7 @@ impl<T> DList<T> {\n     /// assert_eq!(dl.front().unwrap(), &1);\n     ///\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, elt: T) {\n         self.push_front_node(box Node::new(elt))\n     }\n@@ -516,7 +516,7 @@ impl<T> DList<T> {\n     ///\n     /// ```\n     ///\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(|box Node{value, ..}| value)\n     }\n@@ -533,7 +533,7 @@ impl<T> DList<T> {\n     /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, elt: T) {\n         self.push_back_node(box Node::new(elt))\n     }\n@@ -552,7 +552,7 @@ impl<T> DList<T> {\n     /// d.push_back(3);\n     /// assert_eq!(d.pop_back(), Some(3));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n         self.pop_back_node().map(|box Node{value, ..}| value)\n     }\n@@ -577,7 +577,7 @@ impl<T> DList<T> {\n     /// assert_eq!(splitted.pop_front(), Some(1));\n     /// assert_eq!(splitted.pop_front(), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn split_off(&mut self, at: uint) -> DList<T> {\n         let len = self.len();\n         assert!(at < len, \"Cannot split off at a nonexistent index\");\n@@ -620,7 +620,7 @@ impl<T> DList<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for DList<T> {\n     fn drop(&mut self) {\n         // Dissolve the dlist in backwards direction\n@@ -642,7 +642,7 @@ impl<T> Drop for DList<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n@@ -664,7 +664,7 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n@@ -679,10 +679,10 @@ impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n     #[inline]\n@@ -706,7 +706,7 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n@@ -721,7 +721,7 @@ impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n // private methods for IterMut\n@@ -802,7 +802,7 @@ impl<'a, A> IterMut<'a, A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n@@ -815,13 +815,13 @@ impl<A> Iterator for IntoIter<A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for DList<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> DList<A> {\n         let mut ret = DList::new();\n@@ -830,14 +830,14 @@ impl<A> FromIterator<A> for DList<A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for DList<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n         for elt in iterator { self.push_back(elt); }\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for DList<A> {\n     fn eq(&self, other: &DList<A>) -> bool {\n         self.len() == other.len() &&\n@@ -850,32 +850,32 @@ impl<A: PartialEq> PartialEq for DList<A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Eq> Eq for DList<A> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for DList<A> {\n     fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Ord> Ord for DList<A> {\n     #[inline]\n     fn cmp(&self, other: &DList<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> Clone for DList<A> {\n     fn clone(&self) -> DList<A> {\n         self.iter().map(|x| x.clone()).collect()\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: fmt::Show> fmt::Show for DList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"DList [\"));\n@@ -889,7 +889,7 @@ impl<A: fmt::Show> fmt::Show for DList<A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);"}, {"sha": "954de14a50a9314444518eda481885b10220d763", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -88,12 +88,12 @@ pub mod bitv_set {\n     pub use bit::SetIter as Iter;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod btree_map {\n     pub use btree::map::*;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod btree_set {\n     pub use btree::set::*;\n }"}, {"sha": "15ab7be7d909b8e20c97a783948f7ff9bc351622", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n /// Creates a `Vec` containing the arguments.\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! vec {\n     ($x:expr; $y:expr) => ({\n         let xs: $crate::boxed::Box<[_]> = $crate::boxed::Box::new([$x; $y]);"}, {"sha": "ff20716a1abba073ce607326fc259285d006b611", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -12,7 +12,7 @@\n //! ends of the container. It also has `O(1)` indexing like a vector. The contained elements are\n //! not required to be copyable, and the queue will be sendable if the contained type is sendable.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -36,7 +36,7 @@ static INITIAL_CAPACITY: uint = 7u; // 2^3 - 1\n static MINIMUM_CAPACITY: uint = 1u; // 2 - 1\n \n /// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RingBuf<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n@@ -50,21 +50,21 @@ pub struct RingBuf<T> {\n     ptr: *mut T\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Send> Send for RingBuf<T> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for RingBuf<T> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RingBuf<T> {\n     fn clone(&self) -> RingBuf<T> {\n         self.iter().map(|t| t.clone()).collect()\n     }\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for RingBuf<T> {\n     fn drop(&mut self) {\n         self.clear();\n@@ -78,7 +78,7 @@ impl<T> Drop for RingBuf<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for RingBuf<T> {\n     #[inline]\n     fn default() -> RingBuf<T> { RingBuf::new() }\n@@ -146,13 +146,13 @@ impl<T> RingBuf<T> {\n \n impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> RingBuf<T> {\n         RingBuf::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n@@ -191,7 +191,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(5);\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, i: uint) -> Option<&T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n@@ -221,7 +221,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// assert_eq!(buf[1], 7);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n@@ -250,7 +250,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[0], 5);\n     /// assert_eq!(buf[2], 3);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n@@ -273,7 +273,7 @@ impl<T> RingBuf<T> {\n     /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n@@ -296,7 +296,7 @@ impl<T> RingBuf<T> {\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.reserve(additional);\n     }\n@@ -317,7 +317,7 @@ impl<T> RingBuf<T> {\n     /// buf.reserve(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let new_len = self.len() + additional;\n         assert!(new_len + 1 > self.len(), \"capacity overflow\");\n@@ -502,7 +502,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&5, &3, &4];\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter {\n             tail: self.tail,\n@@ -528,7 +528,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n     /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         IterMut {\n             tail: self.tail,\n@@ -540,7 +540,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Consumes the list into an iterator yielding elements by value.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter {\n             inner: self,\n@@ -603,7 +603,7 @@ impl<T> RingBuf<T> {\n     /// v.push_back(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { count(self.tail, self.head, self.cap) }\n \n     /// Returns true if the buffer contains no elements\n@@ -618,7 +618,7 @@ impl<T> RingBuf<T> {\n     /// v.push_front(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Creates a draining iterator that clears the `RingBuf` and iterates over\n@@ -655,7 +655,7 @@ impl<T> RingBuf<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -676,7 +676,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.front(), Some(&1i));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[0]) } else { None }\n     }\n@@ -700,7 +700,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.front(), Some(&9i));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         if !self.is_empty() { Some(&mut self[0]) } else { None }\n     }\n@@ -720,7 +720,7 @@ impl<T> RingBuf<T> {\n     /// d.push_back(2i);\n     /// assert_eq!(d.back(), Some(&2i));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n         if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n     }\n@@ -744,7 +744,7 @@ impl<T> RingBuf<T> {\n     /// }\n     /// assert_eq!(d.back(), Some(&9i));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n         if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n@@ -766,7 +766,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(d.pop_front(), Some(2i));\n     /// assert_eq!(d.pop_front(), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         if self.is_empty() {\n             None\n@@ -789,7 +789,7 @@ impl<T> RingBuf<T> {\n     /// d.push_front(2i);\n     /// assert_eq!(d.front(), Some(&2i));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, t: T) {\n         if self.is_full() {\n             self.reserve(1);\n@@ -813,7 +813,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, t: T) {\n         if self.is_full() {\n             self.reserve(1);\n@@ -839,7 +839,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(3);\n     /// assert_eq!(buf.pop_back(), Some(3));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n         if self.is_empty() {\n             None\n@@ -1143,7 +1143,7 @@ impl<T> RingBuf<T> {\n     /// buf.remove(2);\n     /// assert_eq!(Some(&15), buf.get(2));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, i: uint) -> Option<T> {\n         if self.is_empty() || self.len() <= i {\n             return None;\n@@ -1338,7 +1338,7 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n }\n \n /// `RingBuf` iterator.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n     tail: uint,\n@@ -1356,7 +1356,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -1377,7 +1377,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n@@ -1389,10 +1389,10 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1415,7 +1415,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n     tail: uint,\n@@ -1424,7 +1424,7 @@ pub struct IterMut<'a, T:'a> {\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n@@ -1448,7 +1448,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n@@ -1463,16 +1463,16 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// A by-value RingBuf iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     inner: RingBuf<T>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -1488,15 +1488,15 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// A draining RingBuf iterator\n@@ -1507,7 +1507,7 @@ pub struct Drain<'a, T: 'a> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in *self {}\n@@ -1516,7 +1516,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1532,44 +1532,44 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Eq> Eq for RingBuf<A> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for RingBuf<A> {\n     fn partial_cmp(&self, other: &RingBuf<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Ord> Ord for RingBuf<A> {\n     #[inline]\n     fn cmp(&self, other: &RingBuf<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n@@ -1579,7 +1579,7 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Index<uint> for RingBuf<A> {\n     type Output = A;\n \n@@ -1589,7 +1589,7 @@ impl<A> Index<uint> for RingBuf<A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> IndexMut<uint> for RingBuf<A> {\n     type Output = A;\n \n@@ -1599,7 +1599,7 @@ impl<A> IndexMut<uint> for RingBuf<A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for RingBuf<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> RingBuf<A> {\n         let (lower, _) = iterator.size_hint();\n@@ -1609,7 +1609,7 @@ impl<A> FromIterator<A> for RingBuf<A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for RingBuf<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n         for elt in iterator {\n@@ -1618,7 +1618,7 @@ impl<A> Extend<A> for RingBuf<A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Show> fmt::Show for RingBuf<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"RingBuf [\"));"}, {"sha": "ae34c2de5d2d23bc28fbb7ed2fecfa4cfdf4769e", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -86,7 +86,7 @@\n //! * Further iterators exist that split, chunk or permute the slice.\n \n #![doc(primitive = \"slice\")]\n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n@@ -120,9 +120,9 @@ pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Allocating extension methods for slices.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait SliceExt {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n     /// Sorts the slice, in place, using `compare` to compare\n@@ -142,7 +142,7 @@ pub trait SliceExt {\n     /// v.sort_by(|a, b| b.cmp(a));\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sort_by<F>(&mut self, compare: F) where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n@@ -205,31 +205,31 @@ pub trait SliceExt {\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n     /// Panics if `mid > len`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n \n     /// Returns an iterator over the slice\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn iter(&self) -> Iter<Self::Item>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<F>(&self, pred: F) -> Split<Self::Item, F>\n                 where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n                  where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n                   where F: FnMut(&Self::Item) -> bool;\n \n@@ -252,7 +252,7 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", win);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn windows(&self, size: uint) -> Windows<Self::Item>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n@@ -275,16 +275,16 @@ pub trait SliceExt {\n     ///     println!(\"{:?}\", win);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chunks(&self, size: uint) -> Chunks<Self::Item>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn get(&self, index: uint) -> Option<&Self::Item>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn first(&self) -> Option<&Self::Item>;\n \n     /// Returns all but the first element of a slice.\n@@ -296,12 +296,12 @@ pub trait SliceExt {\n     fn init(&self) -> &[Self::Item];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last(&self) -> Option<&Self::Item>;\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n \n     /// Returns an unsafe pointer to the slice's buffer\n@@ -311,7 +311,7 @@ pub trait SliceExt {\n     ///\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_ptr(&self) -> *const Self::Item;\n \n     /// Binary search a sorted slice with a comparator function.\n@@ -346,7 +346,7 @@ pub trait SliceExt {\n     /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n         F: FnMut(&Self::Item) -> Ordering;\n \n@@ -358,7 +358,7 @@ pub trait SliceExt {\n     /// let a = [1i, 2, 3];\n     /// assert_eq!(a.len(), 3);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len(&self) -> uint;\n \n     /// Returns true if the slice has a length of 0\n@@ -370,16 +370,16 @@ pub trait SliceExt {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;\n \n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T; N].\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n@@ -411,11 +411,11 @@ pub trait SliceExt {\n     fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn iter_mut(&mut self) -> IterMut<Self::Item>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn first_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns all but the first element of a mutable slice\n@@ -429,27 +429,27 @@ pub trait SliceExt {\n     fn init_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable pointer to the last item in the slice.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_mut<F>(&mut self, pred: F) -> SplitMut<Self::Item, F>\n                     where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>\n                      where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>\n                       where F: FnMut(&Self::Item) -> bool;\n \n@@ -461,7 +461,7 @@ pub trait SliceExt {\n     /// # Panics\n     ///\n     /// Panics if `chunk_size` is 0.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;\n \n     /// Swaps two elements in a slice.\n@@ -482,7 +482,7 @@ pub trait SliceExt {\n     /// v.swap(1, 3);\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn swap(&mut self, a: uint, b: uint);\n \n     /// Divides one `&mut` into two at an index.\n@@ -519,7 +519,7 @@ pub trait SliceExt {\n     ///     assert!(right == []);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);\n \n     /// Reverse the order of elements in a slice, in place.\n@@ -531,11 +531,11 @@ pub trait SliceExt {\n     /// v.reverse();\n     /// assert!(v == [3i, 2, 1]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn reverse(&mut self);\n \n     /// Returns an unsafe mutable pointer to the element in index\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n \n     /// Return an unsafe mutable pointer to the slice's buffer.\n@@ -546,11 +546,11 @@ pub trait SliceExt {\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n     /// Copies `self` into a new `Vec`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;\n \n     /// Creates an iterator that yields every possible permutation of the\n@@ -612,7 +612,7 @@ pub trait SliceExt {\n     /// v.sort();\n     /// assert!(v == [-5i, -3, 1, 2, 4]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sort(&mut self) where Self::Item: Ord;\n \n     /// Binary search a sorted slice for a given element.\n@@ -638,7 +638,7 @@ pub trait SliceExt {\n     /// let r = s.binary_search(&1);\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n \n     /// Deprecated: use `binary_search` instead.\n@@ -697,23 +697,23 @@ pub trait SliceExt {\n     fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Return true if the slice contains an element with the given value.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n \n     /// Returns true if `needle` is a prefix of the slice.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Returns true if `needle` is a suffix of the slice.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Convert `self` into a vector without clones or allocation.\n     #[unstable(feature = \"collections\")]\n     fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -1005,12 +1005,12 @@ impl<T> SliceExt for [T] {\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<T: ?Sized, U> {\n     /// Flattens a slice of `T` into a single value `U`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn concat(&self) -> U;\n \n     /// Flattens a slice of `T` into a single value `U`, placing a\n     /// given separator between each.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn connect(&self, sep: &T) -> U;\n }\n \n@@ -1104,7 +1104,7 @@ struct SizeDirection {\n     dir: Direction,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ElementSwaps {\n     type Item = (uint, uint);\n "}, {"sha": "200637bb399247cc057b584ac2d7c6a83f9182ec", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -50,7 +50,7 @@\n //! is the same as `&[u8]`.\n \n #![doc(primitive = \"str\")]\n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::RecompositionState::*;\n use self::DecompositionType::*;\n@@ -173,7 +173,7 @@ pub struct Decompositions<'a> {\n     sorted: bool\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Decompositions<'a> {\n     type Item = char;\n \n@@ -264,7 +264,7 @@ pub struct Recompositions<'a> {\n     last_ccc: Option<u8>\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Recompositions<'a> {\n     type Item = char;\n \n@@ -357,7 +357,7 @@ pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Utf16Units<'a> {\n     type Item = u16;\n \n@@ -407,7 +407,7 @@ Section: Trait implementations\n */\n \n /// Any string that can be represented as a slice.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait StrExt: Index<FullRange, Output = str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n     #[unstable(feature = \"collections\",\n@@ -447,7 +447,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// // not found, so no change.\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn replace(&self, from: &str, to: &str) -> String {\n         let mut result = String::new();\n         let mut last_end = 0;\n@@ -529,7 +529,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"bananas\".contains(\"nana\"));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains(&self, pat: &str) -> bool {\n         core_str::StrExt::contains(&self[], pat)\n     }\n@@ -560,7 +560,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n     /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chars(&self) -> Chars {\n         core_str::StrExt::chars(&self[])\n     }\n@@ -573,13 +573,13 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<u8> = \"bors\".bytes().collect();\n     /// assert_eq!(v, b\"bors\".to_vec());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bytes(&self) -> Bytes {\n         core_str::StrExt::bytes(&self[])\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn char_indices(&self) -> CharIndices {\n         core_str::StrExt::char_indices(&self[])\n     }\n@@ -602,7 +602,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"\".split('X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n         core_str::StrExt::split(&self[], pat)\n     }\n@@ -629,7 +629,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n         core_str::StrExt::splitn(&self[], count, pat)\n     }\n@@ -679,7 +679,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n         core_str::StrExt::rsplitn(&self[], count, pat)\n     }\n@@ -738,7 +738,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = four_lines.lines().collect();\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(&self) -> Lines {\n         core_str::StrExt::lines(&self[])\n     }\n@@ -754,7 +754,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines_any(&self) -> LinesAny {\n         core_str::StrExt::lines_any(&self[])\n     }\n@@ -859,7 +859,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// Caller must check both UTF-8 character boundaries and the boundaries of\n     /// the entire slice as well.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice_unchecked(&self[], begin, end)\n     }\n@@ -871,7 +871,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"banana\".starts_with(\"ba\"));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with(&self, pat: &str) -> bool {\n         core_str::StrExt::starts_with(&self[], pat)\n     }\n@@ -883,7 +883,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"banana\".ends_with(\"nana\"));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ends_with(&self, pat: &str) -> bool {\n         core_str::StrExt::ends_with(&self[], pat)\n     }\n@@ -903,7 +903,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n     /// assert_eq!(\"123foo1bar123\".trim_matches(|&: c: char| c.is_numeric()), \"foo1bar\");\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_matches(&self[], pat)\n     }\n@@ -923,7 +923,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n     /// assert_eq!(\"123foo1bar123\".trim_left_matches(|&: c: char| c.is_numeric()), \"foo1bar123\");\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_left_matches(&self[], pat)\n     }\n@@ -943,7 +943,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n     /// assert_eq!(\"123foo1bar123\".trim_right_matches(|&: c: char| c.is_numeric()), \"123foo1bar\");\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_right_matches(&self[], pat)\n     }\n@@ -1092,7 +1092,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_bytes(&self) -> &[u8] {\n         core_str::StrExt::as_bytes(&self[])\n     }\n@@ -1120,7 +1120,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.find(x), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n         core_str::StrExt::find(&self[], pat)\n     }\n@@ -1148,7 +1148,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n         core_str::StrExt::rfind(&self[], pat)\n     }\n@@ -1227,7 +1227,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// The caller must ensure that the string outlives this pointer,\n     /// and that it is not reallocated (e.g. by pushing to the\n     /// string).\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n         core_str::StrExt::as_ptr(&self[])\n@@ -1248,7 +1248,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"foo\".len(), 3);\n     /// assert_eq!(\"\u0192oo\".len(), 4);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn len(&self) -> uint {\n         core_str::StrExt::len(&self[])\n@@ -1262,7 +1262,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert!(\"\".is_empty());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_empty(&self) -> bool {\n         core_str::StrExt::is_empty(&self[])\n     }\n@@ -1334,7 +1334,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = some_words.words().collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn words(&self) -> Words {\n         UnicodeStr::words(&self[])\n     }\n@@ -1355,25 +1355,25 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     }\n \n     /// Returns a string with leading and trailing whitespace removed.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim(&self) -> &str {\n         UnicodeStr::trim(&self[])\n     }\n \n     /// Returns a string with leading whitespace removed.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left(&self) -> &str {\n         UnicodeStr::trim_left(&self[])\n     }\n \n     /// Returns a string with trailing whitespace removed.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right(&self) -> &str {\n         UnicodeStr::trim_right(&self[])\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl StrExt for str {}\n \n #[cfg(test)]"}, {"sha": "00abe734d40ceb0717a6d9f5234b70f95ef8fe50", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -12,7 +12,7 @@\n \n //! An owned, growable string that enforces that its contents are valid UTF-8.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -33,20 +33,20 @@ use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n #[derive(Clone, PartialOrd, Eq, Ord)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct String {\n     vec: Vec<u8>,\n }\n \n /// A possible error value from the `String::from_utf8` function.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FromUtf8Error {\n     bytes: Vec<u8>,\n     error: Utf8Error,\n }\n \n /// A possible error value from the `String::from_utf16` function.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(missing_copy_implementations)]\n pub struct FromUtf16Error(());\n \n@@ -59,7 +59,7 @@ impl String {\n     /// let mut s = String::new();\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> String {\n         String {\n             vec: Vec::new(),\n@@ -76,7 +76,7 @@ impl String {\n     /// let mut s = String::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> String {\n         String {\n             vec: Vec::with_capacity(capacity),\n@@ -121,7 +121,7 @@ impl String {\n     /// assert_eq!(s.into_bytes(), vec![240, 144, 128]);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n         match str::from_utf8(vec.as_slice()) {\n             Ok(..) => Ok(String { vec: vec }),\n@@ -139,7 +139,7 @@ impl String {\n     /// let output = String::from_utf8_lossy(input);\n     /// assert_eq!(output.as_slice(), \"Hello \\u{FFFD}World\");\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n         let mut i = 0;\n         match str::from_utf8(v) {\n@@ -277,7 +277,7 @@ impl String {\n     /// v[4] = 0xD800;\n     /// assert!(String::from_utf16(v).is_err());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n         let mut s = String::with_capacity(v.len());\n         for c in unicode_str::utf16_items(v) {\n@@ -304,7 +304,7 @@ impl String {\n     ///            \"\ud834\udd1emus\\u{FFFD}ic\\u{FFFD}\".to_string());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n         unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n     }\n@@ -315,7 +315,7 @@ impl String {\n     /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n         String {\n             vec: Vec::from_raw_parts(buf, length, capacity),\n@@ -326,7 +326,7 @@ impl String {\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n     /// the UTF-8-ness of the vector has already been validated.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n         String { vec: bytes }\n     }\n@@ -341,7 +341,7 @@ impl String {\n     /// assert_eq!(bytes, vec![104, 101, 108, 108, 111]);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.vec\n     }\n@@ -356,7 +356,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"foobar\");\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_str(&mut self, string: &str) {\n         self.vec.push_all(string.as_bytes())\n     }\n@@ -371,7 +371,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n@@ -392,7 +392,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.vec.reserve(additional)\n     }\n@@ -417,7 +417,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.vec.reserve_exact(additional)\n     }\n@@ -434,7 +434,7 @@ impl String {\n     /// assert_eq!(s.capacity(), 3);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n@@ -451,7 +451,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"abc123\");\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, ch: char) {\n         if (ch as u32) < 0x80 {\n             self.vec.push(ch as u8);\n@@ -484,7 +484,7 @@ impl String {\n     /// assert_eq!(s.as_bytes(), b);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.vec.as_slice()\n     }\n@@ -504,7 +504,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"he\");\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, new_len: uint) {\n         assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n@@ -523,7 +523,7 @@ impl String {\n     /// assert_eq!(s.pop(), None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n@@ -559,7 +559,7 @@ impl String {\n     /// assert_eq!(s.remove(0), 'o');\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, idx: uint) -> char {\n         let len = self.len();\n         assert!(idx <= len);\n@@ -586,7 +586,7 @@ impl String {\n     /// If `idx` does not lie on a character boundary or is out of bounds, then\n     /// this function will panic.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n@@ -623,7 +623,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"olleh\");\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n     }\n@@ -637,7 +637,7 @@ impl String {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.vec.len() }\n \n     /// Returns true if the string contains no bytes\n@@ -651,7 +651,7 @@ impl String {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Truncates the string, returning it to 0 length.\n@@ -664,7 +664,7 @@ impl String {\n     /// assert!(s.is_empty());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.vec.clear()\n     }\n@@ -673,11 +673,11 @@ impl String {\n impl FromUtf8Error {\n     /// Consume this error, returning the bytes that were attempted to make a\n     /// `String` with.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_bytes(self) -> Vec<u8> { self.bytes }\n \n     /// Access the underlying UTF8-error that was the cause of this error.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn utf8_error(&self) -> Utf8Error { self.error }\n }\n \n@@ -687,7 +687,7 @@ impl fmt::Show for FromUtf8Error {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::String for FromUtf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&self.error, f)\n@@ -700,14 +700,14 @@ impl fmt::Show for FromUtf16Error {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::String for FromUtf16Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(\"invalid utf-16: lone surrogate found\", f)\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<char> for String {\n     fn from_iter<I:Iterator<Item=char>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -716,7 +716,7 @@ impl FromIterator<char> for String {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> FromIterator<&'a str> for String {\n     fn from_iter<I:Iterator<Item=&'a str>>(iterator: I) -> String {\n         let mut buf = String::new();\n@@ -750,7 +750,7 @@ impl<'a> Extend<&'a str> for String {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for String {\n     #[inline]\n     fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -760,15 +760,15 @@ impl PartialEq for String {\n \n macro_rules! impl_eq {\n     ($lhs:ty, $rhs: ty) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> PartialEq<$rhs> for $lhs {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n             fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n \n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> PartialEq<$lhs> for $rhs {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -782,15 +782,15 @@ macro_rules! impl_eq {\n impl_eq! { String, &'a str }\n impl_eq! { CowString<'a>, String }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n     #[inline]\n     fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n     #[inline]\n     fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }\n@@ -801,22 +801,22 @@ impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n #[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]\n impl Str for String {\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for String {\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> String {\n         String::new()\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::String for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -881,7 +881,7 @@ impl ops::Index<ops::FullRange> for String {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for String {\n     type Target = str;\n \n@@ -964,7 +964,7 @@ impl<'a> IntoCow<'a, String, str> for &'a str {\n }\n \n /// A clone-on-write string\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type CowString<'a> = Cow<'a, String, str>;\n \n impl<'a> Str for CowString<'a> {"}, {"sha": "567157e7d8fe72375e3b765a49cf4705c1776e2c", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -44,7 +44,7 @@\n //! let two = xs.pop();\n //! ```\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -134,7 +134,7 @@ use core::uint;\n /// to reallocate, which can be slow. For this reason, it is recommended to use\n /// `Vec::with_capacity` whenever possible to specify how big the vector is expected to get.\n #[unsafe_no_drop_flag]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     ptr: NonZero<*mut T>,\n     len: uint,\n@@ -159,7 +159,7 @@ impl<T> Vec<T> {\n     /// let mut vec: Vec<int> = Vec::new();\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Vec<T> {\n         // We want ptr to never be NULL so instead we set it to some arbitrary\n         // non-null value which is fine since we never call deallocate on the ptr\n@@ -194,7 +194,7 @@ impl<T> Vec<T> {\n     /// vec.push(11);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n             Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: uint::MAX }\n@@ -243,7 +243,7 @@ impl<T> Vec<T> {\n     ///     }\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n         Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n@@ -274,7 +274,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.cap\n     }\n@@ -293,7 +293,7 @@ impl<T> Vec<T> {\n     /// vec.reserve(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n             let err_msg = \"Vec::reserve: `uint` overflow\";\n@@ -322,7 +322,7 @@ impl<T> Vec<T> {\n     /// vec.reserve_exact(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n             match self.len.checked_add(additional) {\n@@ -346,7 +346,7 @@ impl<T> Vec<T> {\n     /// vec.shrink_to_fit();\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n@@ -399,7 +399,7 @@ impl<T> Vec<T> {\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             // drop any extra elements\n@@ -423,7 +423,7 @@ impl<T> Vec<T> {\n     /// foo(vec.as_mut_slice());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n@@ -447,7 +447,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let ptr = *self.ptr;\n@@ -478,7 +478,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn set_len(&mut self, len: uint) {\n         self.len = len;\n     }\n@@ -504,7 +504,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap_remove(&mut self, index: uint) -> T {\n         let length = self.len();\n         self.swap(index, length - 1);\n@@ -528,7 +528,7 @@ impl<T> Vec<T> {\n     /// vec.insert(4, 5);\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n@@ -564,7 +564,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v.remove(1), 2);\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: uint) -> T {\n         let len = self.len();\n         assert!(index < len);\n@@ -598,7 +598,7 @@ impl<T> Vec<T> {\n     /// vec.retain(|&x| x%2 == 0);\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n         let len = self.len();\n         let mut del = 0u;\n@@ -632,7 +632,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, value: T) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the\n@@ -670,7 +670,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         if self.len == 0 {\n             None\n@@ -765,7 +765,7 @@ impl<T> Vec<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.truncate(0)\n     }\n@@ -779,7 +779,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.len }\n \n     /// Returns `true` if the vector contains no elements.\n@@ -793,7 +793,7 @@ impl<T> Vec<T> {\n     /// v.push(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n@@ -1072,7 +1072,7 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -1314,19 +1314,19 @@ impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n }\n \n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n \n     fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n@@ -1446,7 +1446,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     /// foo(vec.as_slice());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n@@ -1470,7 +1470,7 @@ impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n@@ -1486,9 +1486,9 @@ impl<T> Drop for Vec<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Vec<T> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Vec<T> {\n         Vec::new()\n     }\n@@ -1541,7 +1541,7 @@ impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// An iterator that moves out of a vector.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n     cap: uint, // the capacity of the vector\n@@ -1566,7 +1566,7 @@ impl<T> IntoIter<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -1603,7 +1603,7 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n@@ -1627,11 +1627,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n@@ -1654,7 +1654,7 @@ pub struct Drain<'a, T> {\n     marker: ContravariantLifetime<'a>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1691,7 +1691,7 @@ impl<'a, T> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n@@ -1715,11 +1715,11 @@ impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         // self.ptr == self.end == null if drop has already been called,\n@@ -1752,7 +1752,7 @@ impl<'a, T> Deref for DerefVec<'a, T> {\n \n // Prevent the inner `Vec<T>` from attempting to deallocate memory.\n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for DerefVec<'a, T> {\n     fn drop(&mut self) {\n         self.x.len = 0;"}, {"sha": "f257d9a53e4919ea5cd3b6ac7496101c5796ebff", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -66,9 +66,9 @@ pub struct VecMap<V> {\n     v: Vec<Option<V>>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Default for VecMap<V> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn default() -> VecMap<V> { VecMap::new() }\n }\n@@ -107,7 +107,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> VecMap<V> { VecMap { v: vec![] } }\n \n     /// Creates an empty `VecMap` with space for at least `capacity`\n@@ -119,7 +119,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> VecMap<V> {\n         VecMap { v: Vec::with_capacity(capacity) }\n     }\n@@ -135,7 +135,7 @@ impl<V> VecMap<V> {\n     /// assert!(map.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.v.capacity()\n     }\n@@ -154,7 +154,7 @@ impl<V> VecMap<V> {\n     /// map.reserve_len(10);\n     /// assert!(map.capacity() >= 10);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: uint) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n@@ -178,7 +178,7 @@ impl<V> VecMap<V> {\n     /// map.reserve_len_exact(10);\n     /// assert!(map.capacity() >= 10);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: uint) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n@@ -188,7 +188,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all keys in ascending order of the keys.\n     /// The iterator's element type is `uint`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((uint, &'r V)) -> uint = first; // coerce to fn pointer\n@@ -198,7 +198,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all values in ascending order of the keys.\n     /// The iterator's element type is `&'r V`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((uint, &'r V)) -> &'r V = second; // coerce to fn pointer\n@@ -224,7 +224,7 @@ impl<V> VecMap<V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter<'r>(&'r self) -> Iter<'r, V> {\n         Iter {\n             front: 0,\n@@ -255,7 +255,7 @@ impl<V> VecMap<V> {\n     ///     assert_eq!(value, &\"x\");\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut<'r>(&'r mut self) -> IterMut<'r, V> {\n         IterMut {\n             front: 0,\n@@ -282,7 +282,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n@@ -333,7 +333,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n@@ -350,7 +350,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.v.iter().all(|elt| elt.is_none())\n     }\n@@ -367,7 +367,7 @@ impl<V> VecMap<V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.v.clear() }\n \n     /// Returns a reference to the value corresponding to the key.\n@@ -382,7 +382,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, key: &uint) -> Option<&V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -407,7 +407,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key(&self, key: &uint) -> bool {\n         self.get(key).is_some()\n     }\n@@ -427,7 +427,7 @@ impl<V> VecMap<V> {\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, key: &uint) -> Option<&mut V> {\n         if *key < self.v.len() {\n             match *(&mut self.v[*key]) {\n@@ -455,7 +455,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n@@ -477,7 +477,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, key: &uint) -> Option<V> {\n         if *key >= self.v.len() {\n             return None;\n@@ -487,33 +487,33 @@ impl<V> VecMap<V> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: PartialEq> PartialEq for VecMap<V> {\n     fn eq(&self, other: &VecMap<V>) -> bool {\n         iter::order::eq(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: Eq> Eq for VecMap<V> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: PartialOrd> PartialOrd for VecMap<V> {\n     #[inline]\n     fn partial_cmp(&self, other: &VecMap<V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: Ord> Ord for VecMap<V> {\n     #[inline]\n     fn cmp(&self, other: &VecMap<V>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: fmt::Show> fmt::Show for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"VecMap {{\"));\n@@ -527,7 +527,7 @@ impl<V: fmt::Show> fmt::Show for VecMap<V> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     fn from_iter<Iter: Iterator<Item=(uint, V)>>(iter: Iter) -> VecMap<V> {\n         let mut map = VecMap::new();\n@@ -536,7 +536,7 @@ impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Extend<(uint, V)> for VecMap<V> {\n     fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, mut iter: Iter) {\n         for (k, v) in iter {\n@@ -554,7 +554,7 @@ impl<V> Index<uint> for VecMap<V> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> IndexMut<uint> for VecMap<V> {\n     type Output = V;\n \n@@ -566,7 +566,7 @@ impl<V> IndexMut<uint> for VecMap<V> {\n \n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, V> Iterator for $name<'a, V> {\n             type Item = $elem;\n \n@@ -601,7 +601,7 @@ macro_rules! iterator {\n \n macro_rules! double_ended_iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, V> DoubleEndedIterator for $name<'a, V> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -627,7 +627,7 @@ macro_rules! double_ended_iterator {\n }\n \n /// An iterator over the key-value pairs of a map.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -650,7 +650,7 @@ double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -661,7 +661,7 @@ iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, V: 'a> {\n     iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n@@ -676,7 +676,7 @@ impl<'a, V> Clone for Keys<'a, V> {\n }\n \n /// An iterator over the values of a map.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, V: 'a> {\n     iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n@@ -691,7 +691,7 @@ impl<'a, V> Clone for Values<'a, V> {\n }\n \n /// A consuming iterator over the key-value pairs of a map.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n@@ -722,38 +722,38 @@ impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Keys<'a, V> {\n     type Item = uint;\n \n     fn next(&mut self) -> Option<uint> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Keys<'a, V> {\n     fn next_back(&mut self) -> Option<uint> { self.iter.next_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Values<'a, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Values<'a, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.iter.next_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Iterator for IntoIter<V> {\n     type Item = (uint, V);\n \n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> DoubleEndedIterator for IntoIter<V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }"}, {"sha": "955497861f57e7d5460c69aa85e69d26df9b0600", "filename": "src/libcore/any.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -69,7 +69,7 @@\n //! }\n //! ```\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use mem::transmute;\n use option::Option::{self, Some, None};\n@@ -86,7 +86,7 @@ use intrinsics;\n ///\n /// Every type with no non-`'static` references implements `Any`, so `Any` can\n /// be used as a trait object to emulate the effects dynamic typing.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Any: 'static {\n     /// Get the `TypeId` of `self`\n     #[unstable(feature = \"core\",\n@@ -104,7 +104,7 @@ impl<T: 'static> Any for T {\n \n impl Any {\n     /// Returns true if the boxed type is the same as `T`\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: 'static>(&self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n@@ -119,7 +119,7 @@ impl Any {\n \n     /// Returns some reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_ref<T: 'static>(&self) -> Option<&T> {\n         if self.is::<T>() {\n@@ -137,7 +137,7 @@ impl Any {\n \n     /// Returns some mutable reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_mut<T: 'static>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n@@ -168,7 +168,7 @@ impl Any {\n /// but this limitation may be removed in the future.\n #[cfg_attr(stage0, lang = \"type_id\")]\n #[derive(Clone, Copy, PartialEq, Eq, Show, Hash)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TypeId {\n     t: u64,\n }"}, {"sha": "c38c1b279cccbf7ee9cc1a052fb453f66ef55e13", "filename": "src/libcore/array.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -26,7 +26,7 @@ use option::Option;\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Copy> Clone for [T; $N] {\n                 fn clone(&self) -> [T; $N] {\n                     *self\n@@ -47,7 +47,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n@@ -59,7 +59,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<'a, A, B, Rhs> PartialEq<Rhs> for [A; $N] where\n                 A: PartialEq<B>,\n                 Rhs: Deref<Target=[B]>,\n@@ -74,7 +74,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<'a, A, B, Lhs> PartialEq<[B; $N]> for Lhs where\n                 A: PartialEq<B>,\n                 Lhs: Deref<Target=[A]>\n@@ -89,10 +89,10 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Eq> Eq for [T; $N] { }\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:PartialOrd> PartialOrd for [T; $N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n@@ -116,7 +116,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Ord> Ord for [T; $N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T; $N]) -> Ordering {"}, {"sha": "bdcba709bef5dd076bbf842d6c275d975c39cda7", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -68,7 +68,7 @@\n //! println!(\"live tasks: {}\", old_task_count + 1);\n //! ```\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Ordering::*;\n \n@@ -78,31 +78,31 @@ use intrinsics;\n use cell::UnsafeCell;\n \n /// A boolean type which can be safely shared between threads.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicBool {\n     v: UnsafeCell<usize>,\n }\n \n unsafe impl Sync for AtomicBool {}\n \n /// A signed integer type which can be safely shared between threads.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicIsize {\n     v: UnsafeCell<isize>,\n }\n \n unsafe impl Sync for AtomicIsize {}\n \n /// An unsigned integer type which can be safely shared between threads.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicUsize {\n     v: UnsafeCell<usize>,\n }\n \n unsafe impl Sync for AtomicUsize {}\n \n /// A raw pointer type which can be safely shared between threads.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<usize>,\n }\n@@ -119,42 +119,42 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n ///\n /// Rust's memory orderings are [the same as\n /// C++'s](http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync).\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n     /// to another thread that performs a load with `Acquire` ordering\n     /// on the same value.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n     /// written before a store with `Release` ordering on the same value\n     /// in another thread.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n     /// When coupled with a load, uses `Acquire` ordering, and with a store\n     /// `Release` ordering.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     SeqCst,\n }\n \n /// An `AtomicBool` initialized to `false`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_BOOL_INIT: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 } };\n /// An `AtomicIsize` initialized to `0`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_ISIZE_INIT: AtomicIsize =\n         AtomicIsize { v: UnsafeCell { value: 0 } };\n /// An `AtomicUsize` initialized to `0`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_USIZE_INIT: AtomicUsize =\n         AtomicUsize { v: UnsafeCell { value: 0, } };\n \n@@ -173,7 +173,7 @@ impl AtomicBool {\n     /// let atomic_false = AtomicBool::new(false);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n         AtomicBool { v: UnsafeCell::new(val) }\n@@ -197,7 +197,7 @@ impl AtomicBool {\n     /// let value = some_bool.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(self.v.get(), order) > 0 }\n     }\n@@ -220,7 +220,7 @@ impl AtomicBool {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -241,7 +241,7 @@ impl AtomicBool {\n     /// let value = some_bool.swap(false, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -265,7 +265,7 @@ impl AtomicBool {\n     /// let value = some_bool.store(false, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n         let old = if old { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n@@ -298,7 +298,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -331,7 +331,7 @@ impl AtomicBool {\n     /// assert_eq!(true, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -363,7 +363,7 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n@@ -395,15 +395,15 @@ impl AtomicBool {\n     /// assert_eq!(false, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n         unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AtomicIsize {\n     /// Creates a new `AtomicIsize`.\n     ///\n@@ -580,7 +580,7 @@ impl AtomicIsize {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AtomicUsize {\n     /// Creates a new `AtomicUsize`.\n     ///\n@@ -769,7 +769,7 @@ impl<T> AtomicPtr<T> {\n     /// let atomic_ptr  = AtomicPtr::new(ptr);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p as usize) }\n     }\n@@ -793,7 +793,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_load(self.p.get(), order) as *mut T\n@@ -821,7 +821,7 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(self.p.get(), ptr as usize, order); }\n     }\n@@ -843,7 +843,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get(), ptr as usize, order) as *mut T }\n     }\n@@ -869,7 +869,7 @@ impl<T> AtomicPtr<T> {\n     /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n             atomic_compare_and_swap(self.p.get(), old as usize,\n@@ -890,7 +890,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n@@ -902,7 +902,7 @@ unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n }\n \n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -915,7 +915,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_add).\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -928,7 +928,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_sub).\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -940,7 +940,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n@@ -952,7 +952,7 @@ unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering)\n }\n \n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -964,7 +964,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -977,7 +977,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -990,7 +990,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -1023,7 +1023,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n /// Panics if `order` is `Relaxed`.\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn fence(order: Ordering) {\n     unsafe {\n         match order {"}, {"sha": "0897710aaaac8f85a74f7cbc20eebf26e7b1b436", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -143,7 +143,7 @@ pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     Owned(T)\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n         match *self {\n@@ -197,7 +197,7 @@ impl<'a, T, B: ?Sized> Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     type Target = B;\n \n@@ -209,18 +209,18 @@ impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n     B: PartialEq<C> + ToOwned<T>,\n     C: ToOwned<U>,\n@@ -231,15 +231,15 @@ impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T,\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, B: ?Sized> fmt::String for Cow<'a, T, B> where\n     B: fmt::String + ToOwned<T>,\n     T: fmt::String,"}, {"sha": "aa04f9c1b206f7d090399d860b11f60fcfc1ffe1", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -154,7 +154,7 @@\n // FIXME: Can't be shared between threads. Dynamic borrows\n // FIXME: Relationship to Atomic types and RWLock\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n use cmp::PartialEq;\n@@ -165,14 +165,14 @@ use option::Option;\n use option::Option::{None, Some};\n \n /// A mutable memory location that admits only `Copy` data.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cell<T> {\n     value: UnsafeCell<T>,\n }\n \n impl<T:Copy> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n@@ -181,14 +181,14 @@ impl<T:Copy> Cell<T> {\n \n     /// Returns a copy of the contained value.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> T {\n         unsafe{ *self.value.get() }\n     }\n \n     /// Sets the contained value.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set(&self, value: T) {\n         unsafe {\n             *self.value.get() = value;\n@@ -207,33 +207,33 @@ impl<T:Copy> Cell<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for Cell<T> where T: Send {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Copy> Clone for Cell<T> {\n     fn clone(&self) -> Cell<T> {\n         Cell::new(self.get())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Default + Copy> Default for Cell<T> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Cell<T> {\n         Cell::new(Default::default())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n     fn eq(&self, other: &Cell<T>) -> bool {\n         self.get() == other.get()\n     }\n }\n \n /// A mutable memory location with dynamically checked borrow rules\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n     borrow: Cell<BorrowFlag>,\n@@ -247,7 +247,7 @@ const WRITING: BorrowFlag = -1;\n \n impl<T> RefCell<T> {\n     /// Create a new `RefCell` containing `value`\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> RefCell<T> {\n         RefCell {\n             value: UnsafeCell::new(value),\n@@ -256,7 +256,7 @@ impl<T> RefCell<T> {\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> T {\n         // Since this function takes `self` (the `RefCell`) by value, the\n         // compiler statically verifies that it is not currently borrowed.\n@@ -287,7 +287,7 @@ impl<T> RefCell<T> {\n     /// # Panics\n     ///\n     /// Panics if the value is currently mutably borrowed.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match self.try_borrow() {\n             Some(ptr) => ptr,\n@@ -317,7 +317,7 @@ impl<T> RefCell<T> {\n     /// # Panics\n     ///\n     /// Panics if the value is currently borrowed.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match self.try_borrow_mut() {\n             Some(ptr) => ptr,\n@@ -337,25 +337,25 @@ impl<T> RefCell<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for RefCell<T> where T: Send {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RefCell<T> {\n     fn clone(&self) -> RefCell<T> {\n         RefCell::new(self.borrow().clone())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Default> Default for RefCell<T> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> RefCell<T> {\n         RefCell::new(Default::default())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq> PartialEq for RefCell<T> {\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n@@ -399,15 +399,15 @@ impl<'b> Clone for BorrowRef<'b> {\n }\n \n /// Wraps a borrowed reference to a value in a `RefCell` box.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ref<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b T,\n     _borrow: BorrowRef<'b>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T> Deref for Ref<'b, T> {\n     type Target = T;\n \n@@ -458,15 +458,15 @@ impl<'b> BorrowRefMut<'b> {\n }\n \n /// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefMut<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b mut T,\n     _borrow: BorrowRefMut<'b>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T> Deref for RefMut<'b, T> {\n     type Target = T;\n \n@@ -476,7 +476,7 @@ impl<'b, T> Deref for RefMut<'b, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n@@ -522,7 +522,7 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n /// is not recommended to access its fields directly, `get` should be used\n /// instead.\n #[lang=\"unsafe\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct UnsafeCell<T> {\n     /// Wrapped value\n     ///\n@@ -538,21 +538,21 @@ impl<T> UnsafeCell<T> {\n     ///\n     /// All access to the inner value through methods is `unsafe`, and it is\n     /// highly discouraged to access the fields directly.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }\n \n     /// Gets a mutable pointer to the wrapped value.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n \n     /// Unwraps the value\n     ///\n     /// This function is unsafe because there is no guarantee that this or other\n     /// tasks are currently inspecting the inner value.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn into_inner(self) -> T { self.value }\n }"}, {"sha": "1213ea6cbeb503b18ad6835d13c7cf481af441ae", "filename": "src/libcore/char.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -64,12 +64,12 @@ static MAX_THREE_B: u32 =  0x10000u32;\n */\n \n /// The highest valid code point\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: char = '\\u{10ffff}';\n \n /// Converts from `u32` to a `char`\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_u32(i: u32) -> Option<char> {\n     // catch out-of-bounds and surrogates\n     if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n@@ -111,7 +111,7 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n }\n \n /// Basic `char` manipulations.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait CharExt {\n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n@@ -151,7 +151,7 @@ pub trait CharExt {\n     /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n     /// where `NNNN` is the shortest hexadecimal representation of the code\n     /// point.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode;\n \n     /// Returns an iterator that yields the 'default' ASCII and\n@@ -166,37 +166,37 @@ pub trait CharExt {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-16.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n     /// and then returns the number of `u16`s written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n@@ -220,12 +220,12 @@ impl CharExt for char {\n         else { None }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode {\n         EscapeUnicode { c: self, state: EscapeUnicodeState::Backslash }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault {\n         let init_state = match self {\n             '\\t' => EscapeDefaultState::Backslash('t'),\n@@ -241,7 +241,7 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint {\n         let code = self as u32;\n         match () {\n@@ -253,7 +253,7 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint {\n         let ch = self as u32;\n         if (ch & 0xFFFF_u32) == ch { 1 } else { 2 }\n@@ -313,7 +313,7 @@ impl CharExt for char {\n /// An iterator over the characters that represent a `char`, as escaped by\n /// Rust's unicode escaping rules.\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeUnicode {\n     c: char,\n     state: EscapeUnicodeState\n@@ -330,7 +330,7 @@ enum EscapeUnicodeState {\n     Done,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeUnicode {\n     type Item = char;\n \n@@ -376,7 +376,7 @@ impl Iterator for EscapeUnicode {\n /// An iterator over the characters that represent a `char`, escaped\n /// for maximum portability.\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeDefault {\n     state: EscapeDefaultState\n }\n@@ -390,7 +390,7 @@ enum EscapeDefaultState {\n     Unicode(EscapeUnicode),\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeDefault {\n     type Item = char;\n "}, {"sha": "28c306fc0099f2bce5cbf9a73138e11b703d1551", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -19,15 +19,15 @@\n //! explicitly, by convention implementing the `Clone` trait and calling\n //! the `clone` method.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n \n /// A common trait for cloning an object.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Clone : Sized {\n     /// Returns a copy of the value.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn clone(&self) -> Self;\n \n     /// Perform copy-assignment from `source`.\n@@ -43,7 +43,7 @@ pub trait Clone : Sized {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]\n@@ -52,7 +52,7 @@ impl<'a, T: ?Sized> Clone for &'a T {\n \n macro_rules! clone_impl {\n     ($t:ty) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Clone for $t {\n             /// Return a deep copy of the value.\n             #[inline]"}, {"sha": "1bd80fed293fff90ac01269165997f85cf204e3e", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -39,7 +39,7 @@\n //! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n //! ```\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Ordering::*;\n \n@@ -68,16 +68,16 @@ use option::Option::{self, Some, None};\n /// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n /// only if `a != b`.\n #[lang=\"eq\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[old_orphan_check]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq(&self, other: &Rhs) -> bool;\n \n     /// This method tests for `!=`.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n }\n \n@@ -90,7 +90,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Eq: PartialEq<Self> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n@@ -106,16 +106,16 @@ pub trait Eq: PartialEq<Self> {\n \n /// An ordering is, e.g, a result of a comparison between two values.\n #[derive(Clone, Copy, PartialEq, Show)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Ordering {\n     /// An ordering where a compared value is less [than another].\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Less = -1i,\n     /// An ordering where a compared value is equal [to another].\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Equal = 0i,\n     /// An ordering where a compared value is greater [than another].\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Greater = 1i,\n }\n \n@@ -141,7 +141,7 @@ impl Ordering {\n     /// assert!(data == b);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reverse(self) -> Ordering {\n         unsafe {\n             // this compiles really nicely (to a single instruction);\n@@ -164,7 +164,7 @@ impl Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n@@ -178,26 +178,26 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n     /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Eq for Ordering {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for Ordering {\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as int).cmp(&(*other as int))\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Ordering {\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n         (*self as int).partial_cmp(&(*other as int))\n     }\n@@ -224,16 +224,16 @@ impl PartialOrd for Ordering {\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n #[lang=\"ord\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n \n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) => true,\n@@ -243,7 +243,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests less than or equal to (`<=`).\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn le(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) | Some(Equal) => true,\n@@ -253,7 +253,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests greater than (`>`).\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn gt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) => true,\n@@ -263,7 +263,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n     /// This method tests greater than or equal to (`>=`).\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ge(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) | Some(Equal) => true,\n@@ -274,14 +274,14 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n /// Compare and return the minimum of two values.\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n /// Compare and return the maximum of two values.\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n@@ -322,7 +322,7 @@ mod impls {\n \n     macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n@@ -332,7 +332,7 @@ mod impls {\n         )*)\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool { true }\n@@ -346,7 +346,7 @@ mod impls {\n \n     macro_rules! eq_impl {\n         ($($t:ty)*) => ($(\n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl Eq for $t {}\n         )*)\n     }\n@@ -355,7 +355,7 @@ mod impls {\n \n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n@@ -378,15 +378,15 @@ mod impls {\n         )*)\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n@@ -398,7 +398,7 @@ mod impls {\n \n     macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n@@ -410,13 +410,13 @@ mod impls {\n         )*)\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering { Equal }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n@@ -428,14 +428,14 @@ mod impls {\n \n     // & pointers\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n@@ -450,24 +450,24 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Ord for &'a A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}\n \n     // &mut pointers\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n@@ -482,23 +482,23 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }"}, {"sha": "43ee21190dd2d95bdbe01d07e7f0b2eeb1e94bd0", "filename": "src/libcore/default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -81,7 +81,7 @@\n //! }\n //! ```\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n /// A trait that types which have a useful default value should implement.\n ///\n@@ -97,7 +97,7 @@\n ///     bar: f32,\n /// }\n /// ```\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Default {\n     /// Returns the \"default value\" for a type.\n     ///\n@@ -131,16 +131,16 @@ pub trait Default {\n     ///     fn default() -> Kind { Kind::A }\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Self;\n }\n \n macro_rules! default_impl {\n     ($t:ty, $v:expr) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Default for $t {\n             #[inline]\n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             fn default() -> $t { $v }\n         }\n     }"}, {"sha": "fceb301cc04dcd3602b91e986c5cdb09e93a9ac1", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -11,7 +11,7 @@\n //! Utilities for formatting and printing strings\n \n #![allow(unused_variables)]\n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use any;\n use cell::{Cell, RefCell, Ref, RefMut};\n@@ -207,7 +207,7 @@ impl<'a> Arguments<'a> {\n /// and pass it to a function or closure, passed as the first argument. The\n /// macro validates the format string at compile-time so usage of the `write`\n /// and `format` functions can be safely performed.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub struct Arguments<'a> {\n     // Format string pieces to print.\n@@ -227,7 +227,7 @@ impl<'a> Show for Arguments<'a> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> String for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n@@ -653,7 +653,7 @@ impl Show for bool {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl String for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         String::fmt(if *self { \"true\" } else { \"false\" }, f)\n@@ -670,7 +670,7 @@ impl Show for str {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl String for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self)\n@@ -688,7 +688,7 @@ impl Show for char {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl String for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n@@ -734,7 +734,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl String for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -901,7 +901,7 @@ impl<'b, T: Show> Show for RefMut<'b, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl String for Utf8Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match *self {"}, {"sha": "c48df72e446dec777ad84dcdcd4f8f52753dd50d", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -227,7 +227,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// `forget` is unsafe because the caller is responsible for\n     /// ensuring the argument is deallocated already.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn forget<T>(_: T) -> ();\n \n     /// Unsafely transforms a value of one type into a value of another type.\n@@ -243,7 +243,7 @@ extern \"rust-intrinsic\" {\n     /// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n     /// assert!(v == [76u8]);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn transmute<T,U>(e: T) -> U;\n \n     /// Gives the address for the return value of the enclosing function."}, {"sha": "9cf6d6ac64ec1c2fbc5900e5cc172facfe6250ca", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -54,7 +54,7 @@\n //!\n //! This `for` loop syntax can be applied to any iterator over any type.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::MinMaxResult::*;\n \n@@ -81,26 +81,26 @@ use uint;\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n #[lang=\"iterator\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Iterator {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next(&mut self) -> Option<Self::Item>;\n \n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n     /// An upper bound of `None` means either there is no known upper bound, or the upper bound\n     /// does not fit within a `uint`.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n }\n \n /// Conversion from an `Iterator`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n                           built from an iterator over elements of type `{A}`\"]\n pub trait FromIterator<A> {\n@@ -109,15 +109,15 @@ pub trait FromIterator<A> {\n }\n \n /// A type growable from an `Iterator` implementation\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n }\n \n /// An extension trait providing numerous methods applicable to all iterators.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IteratorExt: Iterator + Sized {\n     /// Counts the number of elements in this iterator.\n     ///\n@@ -129,7 +129,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.count() == 5);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn count(self) -> uint {\n         self.fold(0, |cnt, _x| cnt + 1)\n     }\n@@ -144,7 +144,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().last().unwrap() == &5);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last(mut self) -> Option<Self::Item> {\n         let mut last = None;\n         for x in self { last = Some(x); }\n@@ -163,7 +163,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.nth(2) == None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn nth(&mut self, mut n: uint) -> Option<Self::Item> {\n         for x in *self {\n             if n == 0 { return Some(x) }\n@@ -187,7 +187,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chain<U>(self, other: U) -> Chain<Self, U> where\n         U: Iterator<Item=Self::Item>,\n     {\n@@ -210,7 +210,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn zip<B, U>(self, other: U) -> Zip<Self, U> where\n         U: Iterator<Item=B>,\n     {\n@@ -230,7 +230,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn map<B, F>(self, f: F) -> Map<Self::Item, B, Self, F> where\n         F: FnMut(Self::Item) -> B,\n     {\n@@ -250,7 +250,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter<P>(self, predicate: P) -> Filter<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -270,7 +270,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self::Item, B, Self, F> where\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n@@ -291,7 +291,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn enumerate(self) -> Enumerate<Self> {\n         Enumerate{iter: self, count: 0}\n     }\n@@ -314,7 +314,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn peekable(self) -> Peekable<Self::Item, Self> {\n         Peekable{iter: self, peeked: None}\n     }\n@@ -334,7 +334,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn skip_while<P>(self, predicate: P) -> SkipWhile<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -355,7 +355,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take_while<P>(self, predicate: P) -> TakeWhile<Self::Item, Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -375,7 +375,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn skip(self, n: uint) -> Skip<Self> {\n         Skip{iter: self, n: n}\n     }\n@@ -394,7 +394,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, n: uint) -> Take<Self> {\n         Take{iter: self, n: n}\n     }\n@@ -420,7 +420,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn scan<St, B, F>(\n         self,\n         initial_state: St,\n@@ -450,7 +450,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// }\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn flat_map<B, U, F>(self, f: F) -> FlatMap<Self::Item, B, Self, U, F> where\n         U: Iterator<Item=B>,\n         F: FnMut(Self::Item) -> U,\n@@ -486,7 +486,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(process(x.into_iter()), 1006);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fuse(self) -> Fuse<Self> {\n         Fuse{iter: self, done: false}\n     }\n@@ -510,7 +510,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn inspect<F>(self, f: F) -> Inspect<Self::Item, Self, F> where\n         F: FnMut(&Self::Item),\n     {\n@@ -532,7 +532,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// // xs.next() is now `5`\n     /// assert!(xs.next() == Some(5));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> {\n         ByRef{iter: self}\n     }\n@@ -548,7 +548,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.as_slice() == b.as_slice());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B {\n         FromIterator::from_iter(self)\n     }\n@@ -594,7 +594,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n         F: FnMut(B, Self::Item) -> B,\n     {\n@@ -615,7 +615,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn all<F>(mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n@@ -633,7 +633,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!it.any(|x| *x == 3));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n@@ -643,7 +643,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Does not consume the iterator past the first found element.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n@@ -655,7 +655,7 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn position<P>(&mut self, mut predicate: P) -> Option<uint> where\n         P: FnMut(Self::Item) -> bool,\n     {\n@@ -673,7 +673,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// If no element matches, None is returned.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n         P: FnMut(Self::Item) -> bool,\n         Self: ExactSizeIterator + DoubleEndedIterator\n@@ -696,7 +696,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().max().unwrap() == &5);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self::Item: Ord\n     {\n         self.fold(None, |max, x| {\n@@ -716,7 +716,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().min().unwrap() == &1);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self::Item: Ord\n     {\n         self.fold(None, |min, x| {\n@@ -878,7 +878,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Note: Random access with flipped indices still only applies to the first\n     /// `uint::MAX` elements of the original iterator.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rev(self) -> Rev<Self> {\n         Rev{iter: self}\n     }\n@@ -941,7 +941,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(cy.next(), Some(1));\n     /// assert_eq!(cy.next(), Some(1));\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn cycle(self) -> Cycle<Self> where Self: Clone {\n         Cycle{orig: self.clone(), iter: self}\n@@ -962,17 +962,17 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> IteratorExt for I where I: Iterator {}\n \n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n /// elements from the *same* range, and do not work independently of each other.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DoubleEndedIterator: Iterator {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n }\n \n@@ -1000,7 +1000,7 @@ pub trait RandomAccessIterator: Iterator {\n ///\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n /// Note that the size must fit in `uint`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     /// Return the exact length of the iterator.\n@@ -1017,32 +1017,32 @@ pub trait ExactSizeIterator: Iterator {\n \n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n     I: ExactSizeIterator<Item=A>,\n     F: FnMut(&A),\n {}\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n     I: ExactSizeIterator<Item=A>,\n     F: FnMut(A) -> B,\n {}\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n /// An double-ended iterator with the direction inverted\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rev<T> {\n     iter: T\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1052,7 +1052,7 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n@@ -1071,12 +1071,12 @@ impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAcc\n \n /// A mutable reference to an iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ByRef<'a, I:'a> {\n     iter: &'a mut I,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1086,7 +1086,7 @@ impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n@@ -1232,7 +1232,7 @@ pub struct Cloned<I> {\n     it: I,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, D, I> Iterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1249,7 +1249,7 @@ impl<T, D, I> Iterator for Cloned<I> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1260,7 +1260,7 @@ impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, D, I> ExactSizeIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1270,13 +1270,13 @@ impl<T, D, I> ExactSizeIterator for Cloned<I> where\n /// An iterator that repeats endlessly\n #[derive(Clone, Copy)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cycle<I> {\n     orig: I,\n     iter: I,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1329,14 +1329,14 @@ impl<I> RandomAccessIterator for Cycle<I> where\n /// An iterator that strings two iterators together\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<A, B> {\n     a: A,\n     b: B,\n     flag: bool,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1370,7 +1370,7 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     A: DoubleEndedIterator<Item=T>,\n     B: DoubleEndedIterator<Item=T>,\n@@ -1409,13 +1409,13 @@ impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n /// An iterator that iterates two other iterators simultaneously\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Zip<A, B> {\n     a: A,\n     b: B\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, U, A, B> Iterator for Zip<A, B> where\n     A: Iterator<Item = T>,\n     B: Iterator<Item = U>,\n@@ -1451,7 +1451,7 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n     A: DoubleEndedIterator + ExactSizeIterator<Item=T>,\n     B: DoubleEndedIterator + ExactSizeIterator<Item=U>,\n@@ -1500,14 +1500,14 @@ impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n \n /// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Map<A, B, I: Iterator<Item=A>, F: FnMut(A) -> B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Clone for Map<A, B, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> B,\n@@ -1530,7 +1530,7 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     type Item = B;\n \n@@ -1546,7 +1546,7 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1577,14 +1577,14 @@ impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n \n /// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Clone for Filter<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1597,7 +1597,7 @@ impl<A, I, P> Clone for Filter<A, I, P> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1620,7 +1620,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n     I: DoubleEndedIterator<Item=A>,\n     P: FnMut(&A) -> bool,\n@@ -1638,14 +1638,14 @@ impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n \n /// An iterator that uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FilterMap<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> Option<B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> Option<B>,\n@@ -1658,7 +1658,7 @@ impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1683,7 +1683,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1703,13 +1703,13 @@ impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n /// An iterator that yields the current count and the element during iteration\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Enumerate<I> {\n     iter: I,\n     count: uint\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Enumerate<I> where I: Iterator {\n     type Item = (uint, <I as Iterator>::Item);\n \n@@ -1731,7 +1731,7 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Enumerate<I> where\n     I: ExactSizeIterator + DoubleEndedIterator\n {\n@@ -1765,14 +1765,14 @@ impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n \n /// An iterator with a `peek()` that returns an optional reference to the next element.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy)]\n pub struct Peekable<T, I> where I: Iterator<Item=T> {\n     iter: I,\n     peeked: Option<T>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1798,7 +1798,7 @@ impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n     /// Return a reference to the next element of the iterator with out advancing it,\n     /// or None if the iterator is exhausted.\n@@ -1822,15 +1822,15 @@ impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n \n /// An iterator that rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1844,7 +1844,7 @@ impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1868,15 +1868,15 @@ impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n \n /// An iterator that only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1890,7 +1890,7 @@ impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1923,13 +1923,13 @@ impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n /// An iterator that skips over `n` elements of `iter`.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Skip<I> {\n     iter: I,\n     n: uint\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Skip<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1993,13 +1993,13 @@ impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n /// An iterator that only iterates over the first `n` iterations of `iter`.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Take<I> {\n     iter: I,\n     n: uint\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Take<I> where I: Iterator{\n     type Item = <I as Iterator>::Item;\n \n@@ -2048,7 +2048,7 @@ impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n \n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n     iter: I,\n     f: F,\n@@ -2058,7 +2058,7 @@ pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Optio\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     I: Clone + Iterator<Item=A>,\n     St: Clone,\n@@ -2073,7 +2073,7 @@ impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(&mut St, A) -> Option<B>,\n@@ -2096,7 +2096,7 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n /// and yields the elements of the produced iterators\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2109,7 +2109,7 @@ pub struct FlatMap<A, B, I, U, F> where\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     I: Clone + Iterator<Item=A>,\n     U: Clone + Iterator<Item=B>,\n@@ -2125,7 +2125,7 @@ impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2160,7 +2160,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n     I: DoubleEndedIterator<Item=A>,\n     U: DoubleEndedIterator<Item=B>,\n@@ -2187,13 +2187,13 @@ impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n /// yields `None` once.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Fuse<I> {\n     iter: I,\n     done: bool\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Fuse<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2222,7 +2222,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n@@ -2267,14 +2267,14 @@ impl<I> Fuse<I> {\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> Clone for Inspect<A, I, F> where\n     I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(&A),\n@@ -2299,7 +2299,7 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     type Item = A;\n \n@@ -2315,7 +2315,7 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     I: DoubleEndedIterator<Item=A>,\n     F: FnMut(&A),\n@@ -2384,7 +2384,7 @@ pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, St, F> Clone for Unfold<A, St, F> where\n     F: Clone + FnMut(&mut St) -> Option<A>,\n     St: Clone,\n@@ -2410,7 +2410,7 @@ impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     type Item = A;\n \n@@ -2446,7 +2446,7 @@ pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n     type Item = A;\n \n@@ -2786,12 +2786,12 @@ step_impl_no_between!(u64 i64);\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat<A> {\n     element: A\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n@@ -2801,7 +2801,7 @@ impl<A: Clone> Iterator for Repeat<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n@@ -2855,7 +2855,7 @@ pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n \n /// Create a new iterator that endlessly repeats the element `elt`.\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n     Repeat{element: elt}\n }"}, {"sha": "0d7840ef286a797ff881c19129b6f1dfb32421f9", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -52,7 +52,7 @@ macro_rules! panic {\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n@@ -79,7 +79,7 @@ macro_rules! assert {\n /// assert_eq!(a, b);\n /// ```\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! assert_eq {\n     ($left:expr , $right:expr) => ({\n         match (&($left), &($right)) {\n@@ -123,7 +123,7 @@ macro_rules! assert_eq {\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! debug_assert {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n }\n@@ -185,7 +185,7 @@ macro_rules! write {\n /// Equivalent to the `write!` macro, except that a newline is appended after\n /// the message is written.\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! writeln {\n     ($dst:expr, $fmt:expr) => (\n         write!($dst, concat!($fmt, \"\\n\"))"}, {"sha": "7d9c131a721570b591c515216b6c841e0b831cbb", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -23,7 +23,7 @@\n //! implemented using unsafe code. In that case, you may want to embed\n //! some of the marker types below into your type.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n \n@@ -36,7 +36,7 @@ pub unsafe trait Send: 'static {\n }\n \n /// Types with a constant size known at compile-time.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n pub trait Sized {\n     // Empty.\n@@ -141,7 +141,7 @@ pub trait Sized {\n /// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n /// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n /// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"copy\"]\n pub trait Copy {\n     // Empty."}, {"sha": "8ee7afbbe3b52ef3933e6e164ab463f3248176ed", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -13,13 +13,13 @@\n //! This module contains functions for querying the size and alignment of\n //! types, initializing and manipulating memory.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n use intrinsics;\n use ptr;\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n \n /// Moves a thing into the void.\n@@ -29,7 +29,7 @@ pub use intrinsics::transmute;\n ///\n /// This function is the unsafe version of the `drop` function because it does\n /// not run any destructors.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::forget;\n \n /// Returns the size of a type in bytes.\n@@ -42,7 +42,7 @@ pub use intrinsics::forget;\n /// assert_eq!(4, mem::size_of::<i32>());\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of<T>() -> uint {\n     unsafe { intrinsics::size_of::<T>() }\n }\n@@ -57,7 +57,7 @@ pub fn size_of<T>() -> uint {\n /// assert_eq!(4, mem::size_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T>(_val: &T) -> uint {\n     size_of::<T>()\n }\n@@ -74,7 +74,7 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n /// assert_eq!(4, mem::min_align_of::<i32>());\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min_align_of<T>() -> uint {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n@@ -89,7 +89,7 @@ pub fn min_align_of<T>() -> uint {\n /// assert_eq!(4, mem::min_align_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min_align_of_val<T>(_val: &T) -> uint {\n     min_align_of::<T>()\n }\n@@ -107,7 +107,7 @@ pub fn min_align_of_val<T>(_val: &T) -> uint {\n /// assert_eq!(4, mem::align_of::<i32>());\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn align_of<T>() -> uint {\n     // We use the preferred alignment as the default alignment for a type. This\n     // appears to be what clang migrated towards as well:\n@@ -129,7 +129,7 @@ pub fn align_of<T>() -> uint {\n /// assert_eq!(4, mem::align_of_val(&5i32));\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn align_of_val<T>(_val: &T) -> uint {\n     align_of::<T>()\n }\n@@ -153,7 +153,7 @@ pub fn align_of_val<T>(_val: &T) -> uint {\n /// let x: int = unsafe { mem::zeroed() };\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n@@ -174,7 +174,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// let x: int = unsafe { mem::uninitialized() };\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n@@ -196,7 +196,7 @@ pub unsafe fn uninitialized<T>() -> T {\n /// assert_eq!(5i, *y);\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n         // Give ourselves some scratch space to work with\n@@ -261,7 +261,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// }\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n     swap(dest, &mut src);\n     src\n@@ -288,7 +288,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n /// Interprets `src` as `&U`, and then reads `src` without moving the contained value.\n@@ -311,7 +311,7 @@ pub fn drop<T>(_x: T) { }\n /// assert_eq!(1u, one);\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     ptr::read(src as *const T as *const U)\n }"}, {"sha": "9aace31044365f0b1b09dc8ec3497afbff5608a3", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -14,7 +14,7 @@\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n #![allow(overflowing_literals)]\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;\n use mem;\n@@ -30,17 +30,17 @@ pub const MANTISSA_DIGITS: uint = 24u;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const DIGITS: uint = 6u;\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f32 = 1.19209290e-07_f32;\n \n /// Smallest finite f32 value\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_VALUE: f32 = -3.40282347e+38_f32;\n /// Smallest positive, normalized f32 value\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n /// Largest finite f32 value\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n@@ -53,11 +53,11 @@ pub const MIN_10_EXP: int = -37;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_10_EXP: int = 38;\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NAN: f32 = 0.0_f32/0.0_f32;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const INFINITY: f32 = 1.0_f32/0.0_f32;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n /// Various useful constants."}, {"sha": "3c174b8d4ea26c108aa9417fcacd1e0c5daa4b28", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -14,7 +14,7 @@\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n #![allow(overflowing_literals)]\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;\n use mem;\n@@ -33,17 +33,17 @@ pub const MANTISSA_DIGITS: uint = 53u;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const DIGITS: uint = 15u;\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n /// Smallest finite f64 value\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n /// Smallest positive, normalized f64 value\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n /// Largest finite f64 value\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n@@ -56,11 +56,11 @@ pub const MIN_10_EXP: int = -307;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_10_EXP: int = 308;\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NAN: f64 = 0.0_f64/0.0_f64;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const INFINITY: f64 = 1.0_f64/0.0_f64;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n \n /// Various useful constants."}, {"sha": "5ea60d0d96d29f44943a0c751cf760d7c7deef0c", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i16\")]\n \n int_module! { i16, 16 }"}, {"sha": "7d9faa998c12e87769a8519d416b7085d802dcbf", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i32\")]\n \n int_module! { i32, 32 }"}, {"sha": "5a70911387b9b7192ab7a86fae52a90e77ddaa7b", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i64\")]\n \n int_module! { i64, 64 }"}, {"sha": "1d7d78ffa6c2352a20ad49cbfda99a0b3fc7ce17", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i8\")]\n \n int_module! { i8, 8 }"}, {"sha": "954c8a08e64d6bafdd15a6ef6c2fe9e6ad29e8c9", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -23,12 +23,12 @@ pub const BYTES : uint = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: $T = (-1 as $T) << (BITS - 1);\n // FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::max_value` function.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: $T = !MIN;\n \n ) }"}, {"sha": "0fd0d90b12501ea87b257bb523b56a1c6d0f1b47", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"isize\")]\n \n #[cfg(target_pointer_width = \"32\")]"}, {"sha": "4f9d7e07488fdf646a569605134bbc17a572ed74", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -12,7 +12,7 @@\n \n //! Numeric traits and functions for the built-in numeric types.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n use char::CharExt;\n@@ -30,7 +30,7 @@ use option::Option::{Some, None};\n use str::{FromStr, StrExt};\n \n /// A built-in signed or unsigned integer.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Int\n     : Copy + Clone\n     + NumCast\n@@ -183,7 +183,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.swap_bytes(), m);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn swap_bytes(self) -> Self;\n \n     /// Convert an integer from big endian to the target's endianness.\n@@ -203,7 +203,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn from_be(x: Self) -> Self {\n         if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n@@ -226,7 +226,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn from_le(x: Self) -> Self {\n         if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n@@ -249,7 +249,7 @@ pub trait Int\n     ///     assert_eq!(n.to_be(), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn to_be(self) -> Self { // or not to be?\n         if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n@@ -272,7 +272,7 @@ pub trait Int\n     ///     assert_eq!(n.to_le(), n.swap_bytes())\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn to_le(self) -> Self {\n         if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n@@ -289,7 +289,7 @@ pub trait Int\n     /// assert_eq!(5u16.checked_add(65530), Some(65535));\n     /// assert_eq!(6u16.checked_add(65530), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_add(self, other: Self) -> Option<Self>;\n \n     /// Checked integer subtraction. Computes `self - other`, returning `None`\n@@ -303,7 +303,7 @@ pub trait Int\n     /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n     /// assert_eq!((-128i8).checked_sub(1), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_sub(self, other: Self) -> Option<Self>;\n \n     /// Checked integer multiplication. Computes `self * other`, returning\n@@ -317,7 +317,7 @@ pub trait Int\n     /// assert_eq!(5u8.checked_mul(51), Some(255));\n     /// assert_eq!(5u8.checked_mul(52), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_mul(self, other: Self) -> Option<Self>;\n \n     /// Checked integer division. Computes `self / other`, returning `None` if\n@@ -332,12 +332,12 @@ pub trait Int\n     /// assert_eq!((-128i8).checked_div(-1), None);\n     /// assert_eq!((1i8).checked_div(0), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_div(self, other: Self) -> Option<Self>;\n \n     /// Saturating integer addition. Computes `self + other`, saturating at\n     /// the numeric bounds instead of overflowing.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn saturating_add(self, other: Self) -> Self {\n         match self.checked_add(other) {\n@@ -349,7 +349,7 @@ pub trait Int\n \n     /// Saturating integer subtraction. Computes `self - other`, saturating at\n     /// the numeric bounds instead of overflowing.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn saturating_sub(self, other: Self) -> Self {\n         match self.checked_sub(other) {\n@@ -401,7 +401,7 @@ macro_rules! uint_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -532,7 +532,7 @@ macro_rules! int_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -625,7 +625,7 @@ int_impl! { int = i64, u64, 64,\n     intrinsics::i64_mul_with_overflow }\n \n /// A built-in two's complement integer.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait SignedInt\n     : Int\n     + Neg<Output=Self>\n@@ -640,23 +640,23 @@ pub trait SignedInt\n     /// - `0` if the number is zero\n     /// - `1` if the number is positive\n     /// - `-1` if the number is negative\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn signum(self) -> Self;\n \n     /// Returns `true` if `self` is positive and `false` if the number\n     /// is zero or negative.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_positive(self) -> bool;\n \n     /// Returns `true` if `self` is negative and `false` if the number\n     /// is zero or positive.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_negative(self) -> bool;\n }\n \n macro_rules! signed_int_impl {\n     ($T:ty) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl SignedInt for $T {\n             #[inline]\n             fn abs(self) -> $T {\n@@ -688,18 +688,18 @@ signed_int_impl! { i64 }\n signed_int_impl! { int }\n \n /// A built-in unsigned integer.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait UnsignedInt: Int {\n     /// Returns `true` iff `self == 2^k` for some `k`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn is_power_of_two(self) -> bool {\n         (self - Int::one()) & self == Int::zero() && !(self == Int::zero())\n     }\n \n     /// Returns the smallest power of two greater than or equal to `self`.\n     /// Unspecified behavior on overflow.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn next_power_of_two(self) -> Self {\n         let bits = size_of::<Self>() * 8;\n@@ -710,7 +710,7 @@ pub trait UnsignedInt: Int {\n     /// Returns the smallest power of two greater than or equal to `n`. If the\n     /// next power of two is greater than the type's maximum value, `None` is\n     /// returned, otherwise the power of two is wrapped in `Some`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn checked_next_power_of_two(self) -> Option<Self> {\n         let npot = self.next_power_of_two();\n         if npot >= self {\n@@ -721,19 +721,19 @@ pub trait UnsignedInt: Int {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for uint {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u8 {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u16 {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u32 {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u64 {}\n \n /// A generic trait for converting a value to a number."}, {"sha": "21635799a77a26a458619bcd3b3431ce2ae0c7ba", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u16\")]\n \n uint_module! { u16, i16, 16 }"}, {"sha": "7d520770503d4b2507cb483afc8bcf04204ca443", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u32\")]\n \n uint_module! { u32, i32, 32 }"}, {"sha": "f10822077dc7511e3e44d12596e6e2198e0e941d", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u64\")]\n \n uint_module! { u64, i64, 64 }"}, {"sha": "3d6922b07b19407b325941dd14888e4fea334214", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u8\")]\n \n uint_module! { u8, i8, 8 }"}, {"sha": "06502be54aaccded31e2541928248cde27f77407", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -17,9 +17,9 @@ pub const BITS : uint = $bits;\n #[unstable(feature = \"core\")]\n pub const BYTES : uint = ($bits / 8);\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: $T = 0 as $T;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: $T = 0 as $T - 1 as $T;\n \n ) }"}, {"sha": "602ef4fe45e734e0f1a931a2a50c98ce98e0511a", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"usize\")]\n \n uint_module! { usize, isize, ::isize::BITS }"}, {"sha": "248e2f232e8adb0d70480f288bdfea3d11775bc6", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -67,7 +67,7 @@\n //! See the documentation for each trait for a minimum implementation that prints\n //! something to the screen.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n@@ -97,10 +97,10 @@ use fmt;\n /// }\n /// ```\n #[lang=\"drop\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Drop {\n     /// The `drop` method, called when the value goes out of scope.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn drop(&mut self);\n }\n \n@@ -189,19 +189,19 @@ macro_rules! forward_ref_binop {\n /// }\n /// ```\n #[lang=\"add\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Add<RHS=Self> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `+` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Add for $t {\n             type Output = $t;\n \n@@ -244,19 +244,19 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"sub\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Sub<RHS=Self> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `-` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Sub for $t {\n             type Output = $t;\n \n@@ -299,19 +299,19 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"mul\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Mul<RHS=Self> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `*` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Mul for $t {\n             type Output = $t;\n \n@@ -354,19 +354,19 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"div\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Div<RHS=Self> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `/` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Div for $t {\n             type Output = $t;\n \n@@ -409,19 +409,19 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"rem\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Rem<RHS=Self> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output = Self;\n \n     /// The method for the `%` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -435,7 +435,7 @@ macro_rules! rem_impl {\n \n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -484,25 +484,25 @@ rem_float_impl! { f64, fmod }\n /// }\n /// ```\n #[lang=\"neg\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Neg {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the unary `-` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn neg(self) -> Self::Output;\n }\n \n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Neg for $t {\n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             type Output = $t;\n \n             #[inline]\n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             fn neg(self) -> $t { -self }\n         }\n \n@@ -512,7 +512,7 @@ macro_rules! neg_impl {\n \n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Neg for $t {\n             type Output = $t;\n \n@@ -563,19 +563,19 @@ neg_uint_impl! { u64, i64 }\n /// }\n /// ```\n #[lang=\"not\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Not {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the unary `!` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn not(self) -> Self::Output;\n }\n \n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Not for $t {\n             type Output = $t;\n \n@@ -618,19 +618,19 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitand\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitAnd<RHS=Self> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `&` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitAnd for $t {\n             type Output = $t;\n \n@@ -673,19 +673,19 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitor\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitOr<RHS=Self> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `|` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitOr for $t {\n             type Output = $t;\n \n@@ -728,19 +728,19 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitxor\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitXor<RHS=Self> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `^` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitXor for $t {\n             type Output = $t;\n \n@@ -783,19 +783,19 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shl\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shl<RHS> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `<<` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! shl_impl {\n     ($t:ty, $f:ty) => (\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for $t {\n             type Output = $t;\n \n@@ -856,13 +856,13 @@ shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// }\n /// ```\n #[lang=\"shr\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shr<RHS> {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n     /// The method for the `>>` operator\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n \n@@ -1120,24 +1120,24 @@ impl<Idx: fmt::Show> fmt::Show for RangeTo<Idx> {\n /// }\n /// ```\n #[lang=\"deref\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Deref {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Target: ?Sized;\n \n     /// The method called to dereference a value\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Deref for &'a T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Deref for &'a mut T {\n     type Target = T;\n \n@@ -1182,14 +1182,14 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// }\n /// ```\n #[lang=\"deref_mut\"]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DerefMut: Deref {\n     /// The method called to mutably dereference a value\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut Self::Target;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }"}, {"sha": "3b2af3214ae3646957f8750d8e52992d9d3d9ff9", "filename": "src/libcore/option.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -141,7 +141,7 @@\n //! }\n //! ```\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Option::*;\n \n@@ -164,13 +164,13 @@ use slice;\n \n /// The `Option` type.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     None,\n     /// Some value `T`\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Some(T)\n }\n \n@@ -195,7 +195,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.is_some(), false);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_some(&self) -> bool {\n         match *self {\n             Some(_) => true,\n@@ -215,7 +215,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.is_none(), true);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_none(&self) -> bool {\n         !self.is_some()\n     }\n@@ -241,7 +241,7 @@ impl<T> Option<T> {\n     /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n         match *self {\n             Some(ref x) => Some(x),\n@@ -262,7 +262,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(42u));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self {\n             Some(ref mut x) => Some(x),\n@@ -323,7 +323,7 @@ impl<T> Option<T> {\n     /// x.expect(\"the world is ending\"); // panics with `world is ending`\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n             Some(val) => val,\n@@ -355,7 +355,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.unwrap(), \"air\"); // fails\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(val) => val,\n@@ -372,7 +372,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or(self, def: T) -> T {\n         match self {\n             Some(x) => x,\n@@ -390,7 +390,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20u);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n         match self {\n             Some(x) => x,\n@@ -414,7 +414,7 @@ impl<T> Option<T> {\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => Some(f(x)),\n@@ -434,7 +434,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or(42u, |v| v.len()), 42u);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map_or<U, F: FnOnce(T) -> U>(self, def: U, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -456,7 +456,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42u);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, def: D, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -522,7 +522,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { inner: Item { opt: self.as_ref() } }\n     }\n@@ -563,7 +563,7 @@ impl<T> Option<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: Item { opt: self } }\n     }\n@@ -594,7 +594,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.and(y), None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n         match self {\n             Some(_) => optb,\n@@ -617,7 +617,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.and_then(sq).and_then(sq), None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n@@ -647,7 +647,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.or(y), None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -669,7 +669,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.or_else(nobody), None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -695,7 +695,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n@@ -735,7 +735,7 @@ impl<T: Default> Option<T> {\n     /// assert_eq!(0i, bad_year);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Some(x) => x,\n@@ -764,10 +764,10 @@ impl<T> AsSlice<T> for Option<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> Option<T> { None }\n }\n \n@@ -807,10 +807,10 @@ impl<A> DoubleEndedIterator for Item<A> {\n impl<A> ExactSizeIterator for Item<A> {}\n \n /// An iterator over a reference of the contained item in an Option.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n@@ -820,27 +820,27 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Clone for Iter<'a, A> {\n     fn clone(&self) -> Iter<'a, A> {\n         Iter { inner: self.inner.clone() }\n     }\n }\n \n /// An iterator over a mutable reference of the contained item in an Option.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n \n@@ -850,20 +850,20 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n /// An iterator over the item contained inside an Option.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<A> { inner: Item<A> }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n@@ -873,20 +873,20 @@ impl<A> Iterator for IntoIter<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> ExactSizeIterator for IntoIter<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Takes each element in the `Iterator`: if it is `None`, no further\n     /// elements are taken, and the `None` is returned. Should no `None` occur, a\n@@ -906,7 +906,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// assert!(res == Some(vec!(2u, 3u)));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_iter<I: Iterator<Item=Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed."}, {"sha": "9c18cd0f6d9af0cc9d3dac1c4313ba2492aaf973", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -86,7 +86,7 @@\n //! but C APIs hand out a lot of pointers generally, so are a common source\n //! of unsafe pointers in Rust.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use mem;\n use clone::Clone;\n@@ -121,7 +121,7 @@ pub use intrinsics::set_memory;\n /// assert!(p.is_null());\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn null<T>() -> *const T { 0 as *const T }\n \n /// Creates a null mutable raw pointer.\n@@ -135,7 +135,7 @@ pub fn null<T>() -> *const T { 0 as *const T }\n /// assert!(p.is_null());\n /// ```\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n /// Zeroes out `count * size_of::<T>` bytes of memory at `dst`. `count` may be\n@@ -160,7 +160,7 @@ pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n ///\n /// This is only unsafe because it accepts a raw pointer.\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n     let mut tmp: T = mem::uninitialized();\n@@ -184,7 +184,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// This is only unsafe because it accepts a raw pointer.\n /// Otherwise, this operation is identical to `mem::replace`.\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(mem::transmute(dest), &mut src); // cannot overlap\n     src\n@@ -202,7 +202,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n #[inline(always)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n@@ -239,18 +239,18 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n #[inline]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n /// Methods on raw pointers\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PtrExt: Sized {\n     type Target;\n \n     /// Returns true if the pointer is null.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_null(self) -> bool;\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -275,12 +275,12 @@ pub trait PtrExt: Sized {\n     /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n     /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n     /// the pointer is used.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n /// Methods on mutable raw pointers\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait MutPtrExt {\n     type Target;\n \n@@ -297,16 +297,16 @@ pub trait MutPtrExt {\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut Self::Target>;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PtrExt for *const T {\n     type Target = T;\n \n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_null(self) -> bool { self as uint == 0 }\n \n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> *const T {\n         intrinsics::offset(self, count)\n     }\n@@ -324,16 +324,16 @@ impl<T> PtrExt for *const T {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_null(self) -> bool { self as uint == 0 }\n \n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn offset(self, count: int) -> *mut T {\n         intrinsics::offset(self, count) as *mut T\n     }\n@@ -351,7 +351,7 @@ impl<T> PtrExt for *mut T {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> MutPtrExt for *mut T {\n     type Target = T;\n \n@@ -369,7 +369,7 @@ impl<T> MutPtrExt for *mut T {\n }\n \n // Equality for pointers\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialEq for *const T {\n     #[inline]\n     fn eq(&self, other: &*const T) -> bool {\n@@ -379,10 +379,10 @@ impl<T> PartialEq for *const T {\n     fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Eq for *const T {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialEq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n@@ -392,18 +392,18 @@ impl<T> PartialEq for *mut T {\n     fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Eq for *mut T {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for *const T {\n     #[inline]\n     fn clone(&self) -> *const T {\n         *self\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for *mut T {\n     #[inline]\n     fn clone(&self) -> *mut T {\n@@ -416,7 +416,7 @@ mod externfnpointers {\n     use mem;\n     use cmp::PartialEq;\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<_R> PartialEq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n@@ -427,7 +427,7 @@ mod externfnpointers {\n     }\n     macro_rules! fnptreq {\n         ($($p:ident),*) => {\n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n@@ -447,7 +447,7 @@ mod externfnpointers {\n }\n \n // Comparison for pointers\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Ord for *const T {\n     #[inline]\n     fn cmp(&self, other: &*const T) -> Ordering {\n@@ -461,7 +461,7 @@ impl<T> Ord for *const T {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialOrd for *const T {\n     #[inline]\n     fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n@@ -481,7 +481,7 @@ impl<T> PartialOrd for *const T {\n     fn ge(&self, other: &*const T) -> bool { *self >= *other }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Ord for *mut T {\n     #[inline]\n     fn cmp(&self, other: &*mut T) -> Ordering {\n@@ -495,7 +495,7 @@ impl<T> Ord for *mut T {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {"}, {"sha": "4dec5fb9b3fd96bd28830cf4f62f55b38e5c29fb", "filename": "src/libcore/result.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -224,7 +224,7 @@\n //!\n //! `try!` is imported by the prelude, and is available everywhere.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::Result::{Ok, Err};\n \n@@ -241,22 +241,22 @@ use slice;\n /// See the [`std::result`](index.html) module documentation for details.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n #[must_use]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Result<T, E> {\n     /// Contains the success value\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Ok(T),\n \n     /// Contains the error value\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Err(E)\n }\n \n /////////////////////////////////////////////////////////////////////////////\n // Type implementation\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n     // Querying the contained values\n@@ -274,7 +274,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_ok(), false);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_ok(&self) -> bool {\n         match *self {\n             Ok(_) => true,\n@@ -294,7 +294,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_err(), true);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_err(&self) -> bool {\n         !self.is_ok()\n     }\n@@ -318,7 +318,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.ok(), None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ok(self) -> Option<T> {\n         match self {\n             Ok(x)  => Some(x),\n@@ -341,7 +341,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.err(), Some(\"Nothing here\"));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn err(self) -> Option<E> {\n         match self {\n             Ok(_)  => None,\n@@ -366,7 +366,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_ref(&self) -> Result<&T, &E> {\n         match *self {\n             Ok(ref x) => Ok(x),\n@@ -393,7 +393,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), 0);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_mut(&mut self) -> Result<&mut T, &mut E> {\n         match *self {\n             Ok(ref mut x) => Ok(x),\n@@ -464,7 +464,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(sum == 10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> {\n         match self {\n             Ok(t) => Ok(op(t)),\n@@ -490,7 +490,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -514,7 +514,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { inner: self.as_ref().ok() }\n     }\n@@ -535,7 +535,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut { inner: self.as_mut().ok() }\n     }\n@@ -554,7 +554,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(v, vec![]);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: self.ok() }\n     }\n@@ -585,7 +585,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.and(y), Ok(\"different result type\"));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(_) => res,\n@@ -609,7 +609,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n@@ -639,7 +639,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.or(y), Ok(2));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n         match self {\n             Ok(_) => self,\n@@ -663,7 +663,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n@@ -685,7 +685,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_or(optb), optb);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or(self, optb: T) -> T {\n         match self {\n             Ok(t) => t,\n@@ -705,7 +705,7 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3u);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n         match self {\n             Ok(t) => t,\n@@ -714,7 +714,7 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, E: Show> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n@@ -735,7 +735,7 @@ impl<T, E: Show> Result<T, E> {\n     /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n@@ -745,7 +745,7 @@ impl<T, E: Show> Result<T, E> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Show, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n@@ -766,7 +766,7 @@ impl<T: Show, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n@@ -783,7 +783,7 @@ impl<T: Show, E> Result<T, E> {\n impl<T, E> AsSlice<T> for Result<T, E> {\n     /// Convert from `Result<T, E>` to `&[T]` (without copying)\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Ok(ref x) => slice::ref_slice(x),\n@@ -801,10 +801,10 @@ impl<T, E> AsSlice<T> for Result<T, E> {\n /////////////////////////////////////////////////////////////////////////////\n \n /// An iterator over a reference to the `Ok` variant of a `Result`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n@@ -817,24 +817,24 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n }\n \n /// An iterator over a mutable reference to the `Ok` variant of a `Result`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for IterMut<'a, T> {\n     type Item = &'a mut T;\n \n@@ -847,20 +847,20 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An iterator over the value in a `Ok` variant of a `Result`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> { inner: Option<T> }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n@@ -873,20 +873,20 @@ impl<T> Iterator for IntoIter<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.inner.take() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur, a"}, {"sha": "9f44fe9612690d232cfe7711d8ad2e8b6c9e284d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -12,7 +12,7 @@\n //!\n //! For more details `std::slice`.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"slice\")]\n \n // How this module is organized.\n@@ -655,9 +655,9 @@ impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Default for &'a [T] {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> &'a [T] { &[] }\n }\n \n@@ -668,7 +668,7 @@ impl<'a, T> Default for &'a [T] {\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T> Iterator for $name<'a, T> {\n             type Item = $elem;\n \n@@ -706,7 +706,7 @@ macro_rules! iterator {\n             }\n         }\n \n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n@@ -748,7 +748,7 @@ macro_rules! make_slice {\n }\n \n /// Immutable slice iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n@@ -806,10 +806,10 @@ impl<'a,T> Copy for Iter<'a,T> {}\n \n iterator!{struct Iter -> *const T, &'a T}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }\n@@ -840,7 +840,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n }\n \n /// Mutable slice iterator.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n@@ -930,7 +930,7 @@ impl<'a, T> IterMut<'a, T> {\n \n iterator!{struct IterMut -> *mut T, &'a mut T}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An internal abstraction over the splitting iterators, so that\n@@ -943,15 +943,15 @@ trait SplitIter: DoubleEndedIterator {\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a [T],\n     pred: P,\n     finished: bool\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     fn clone(&self) -> Split<'a, T, P> {\n         Split {\n@@ -962,7 +962,7 @@ impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a [T];\n \n@@ -990,7 +990,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1016,7 +1016,7 @@ impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool {\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a mut [T],\n     pred: P,\n@@ -1035,7 +1035,7 @@ impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     type Item = &'a mut [T];\n \n@@ -1070,7 +1070,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n@@ -1125,37 +1125,37 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<Split<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n /// function, limited to a given number of splits.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n /// An iterator over subslices separated by elements that match a\n /// predicate function, limited to a given number of splits, starting\n /// from the end of the slice.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n     inner: GenericSplitN<SplitMut<'a, T, P>>\n }\n \n macro_rules! forward_iterator {\n     ($name:ident: $elem:ident, $iter_of:ty) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, $elem, P> Iterator for $name<'a, $elem, P> where\n             P: FnMut(&T) -> bool\n         {\n@@ -1181,13 +1181,13 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n \n /// An iterator over overlapping subslices of length `size`.\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Windows<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Windows<'a, T> {\n     type Item = &'a [T];\n \n@@ -1219,13 +1219,13 @@ impl<'a, T> Iterator for Windows<'a, T> {\n /// When the slice len is not evenly divided by the chunk size, the last slice\n /// of the iteration will be the remainder.\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chunks<'a, T:'a> {\n     v: &'a [T],\n     size: uint\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Chunks<'a, T> {\n     type Item = &'a [T];\n \n@@ -1254,7 +1254,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n@@ -1294,13 +1294,13 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n /// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n     chunk_size: uint\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for ChunksMut<'a, T> {\n     type Item = &'a mut [T];\n \n@@ -1330,7 +1330,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n@@ -1461,7 +1461,7 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     fn eq(&self, other: &[B]) -> bool {\n         self.len() == other.len() &&\n@@ -1473,17 +1473,17 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for [T] {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for [T] {\n     fn cmp(&self, other: &[T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for [T] {\n     #[inline]\n     fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {"}, {"sha": "37f643db54e3d07a282824a52c6ed9f5eccf2efa", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -45,7 +45,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     ($te:ty : $ti:ty) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> Iterator for $ti {\n             type Item = $te;\n \n@@ -58,7 +58,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -67,7 +67,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern $te:ty : $ti:ty) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -80,7 +80,7 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n@@ -89,7 +89,7 @@ macro_rules! delegate_iter {\n         }\n     };\n     (pattern forward $te:ty : $ti:ty) => {\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n \n@@ -169,15 +169,15 @@ pub enum Utf8Error {\n ///\n /// Returns `Err` if the slice is not utf-8 with a description as to why the\n /// provided slice is not utf-8.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     try!(run_utf8_validation_iterator(&mut v.iter()));\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n     mem::transmute(v)\n }\n@@ -255,7 +255,7 @@ Section: Iterators\n ///\n /// Created with the method `.chars()`.\n #[derive(Clone, Copy)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n }\n@@ -284,7 +284,7 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n \n@@ -330,7 +330,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n@@ -367,13 +367,13 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n     front_offset: uint,\n     iter: Chars<'a>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for CharIndices<'a> {\n     type Item = (uint, char);\n \n@@ -397,7 +397,7 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n@@ -416,7 +416,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n /// Use with the `std::iter` module.\n ///\n /// Created with `StrExt::bytes`\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);\n delegate_iter!{exact u8 : Bytes<'a>}\n@@ -456,13 +456,13 @@ struct CharSplitsN<'a, Sep> {\n }\n \n /// An iterator over the lines of a string, separated by `\\n`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Lines<'a> {\n     inner: CharSplits<'a, char>,\n }\n \n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinesAny<'a> {\n     inner: Map<&'a str, &'a str, Lines<'a>, fn(&str) -> &str>,\n }\n@@ -479,7 +479,7 @@ impl<'a, Sep> CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     type Item = &'a str;\n \n@@ -514,7 +514,7 @@ impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n@@ -556,7 +556,7 @@ impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n     type Item = &'a str;\n \n@@ -880,7 +880,7 @@ pub struct SplitStr<'a> {\n     finished: bool\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for MatchIndices<'a> {\n     type Item = (uint, uint);\n \n@@ -897,7 +897,7 @@ impl<'a> Iterator for MatchIndices<'a> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SplitStr<'a> {\n     type Item = &'a str;\n \n@@ -1084,7 +1084,7 @@ mod traits {\n     use ops;\n     use str::{StrExt, eq_slice};\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n@@ -1100,7 +1100,7 @@ mod traits {\n         }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialEq for str {\n         #[inline]\n         fn eq(&self, other: &str) -> bool {\n@@ -1110,10 +1110,10 @@ mod traits {\n         fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Eq for str {}\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl PartialOrd for str {\n         #[inline]\n         fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n@@ -1173,7 +1173,7 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n \n /// Return type of `StrExt::split`\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<'a, P>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : Split<'a, P>}\n \n@@ -1186,13 +1186,13 @@ delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n /// Return type of `StrExt::splitn`\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitN<'a, P>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n /// Return type of `StrExt::rsplitn`\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n \n@@ -1607,13 +1607,13 @@ impl StrExt for str {\n     fn parse<T: FromStr>(&self) -> Option<T> { FromStr::from_str(self) }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Default for &'a str {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> &'a str { \"\" }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Lines<'a> {\n     type Item = &'a str;\n \n@@ -1623,13 +1623,13 @@ impl<'a> Iterator for Lines<'a> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Lines<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for LinesAny<'a> {\n     type Item = &'a str;\n \n@@ -1639,7 +1639,7 @@ impl<'a> Iterator for LinesAny<'a> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }"}, {"sha": "64c2964eb7c6986fc36d3c2d89fc786e39ceeae8", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -33,7 +33,7 @@\n //! * `Ord`\n //! * `Default`\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n use cmp::*;\n@@ -55,14 +55,14 @@ macro_rules! tuple_impls {\n         }\n     )+) => {\n         $(\n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n                     ($(e!(self.$idx.clone()),)+)\n                 }\n             }\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n@@ -74,10 +74,10 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n@@ -101,17 +101,17 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                     lexical_cmp!($(self.$idx, other.$idx),+)\n                 }\n             }\n \n-            #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:Default),+> Default for ($($T,)+) {\n-                #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                 #[inline]\n                 fn default() -> ($($T,)+) {\n                     ($({ let x: $T = Default::default(); x},)+)"}, {"sha": "10c71cff5be80775a21557fb41664be5766e14a5", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -141,9 +141,9 @@ impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n         *rng = Default::default();\n     }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for ReseedWithDefault {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> ReseedWithDefault { ReseedWithDefault }\n }\n "}, {"sha": "c669da9b60ddd76de36015489f23b58dde76fdbe", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -59,7 +59,7 @@ impl<'a> Annotator<'a> {\n             Some(stab) => {\n                 self.index.local.insert(id, stab.clone());\n \n-                // Don't inherit #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+                // Don't inherit #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                 if stab.level != attr::Stable {\n                     let parent = replace(&mut self.parent, Some(stab));\n                     f(self);"}, {"sha": "0d8b233a1697d72f264a09526e50c18f62384888", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -11,5 +11,5 @@\n //! The boolean type\n \n #![doc(primitive = \"bool\")]\n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "4ce9639bedbc2e41ada3ad81abbfc59fe08513fa", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -296,7 +296,7 @@ fn test_resize_policy() {\n /// }\n /// ```\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashMap<K, V, S = RandomState> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n     hash_state: S,\n@@ -499,7 +499,7 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> HashMap<K, V, RandomState> {\n         Default::default()\n     }\n@@ -513,7 +513,7 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomState> {\n         HashMap::with_capacity_and_hash_state(capacity, Default::default())\n     }\n@@ -591,7 +591,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(map.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.resize_policy.usable_capacity(self.table.capacity())\n     }\n@@ -611,7 +611,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// map.reserve(10);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let min_cap = self.resize_policy.min_capacity(new_size);\n@@ -723,7 +723,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.shrink_to_fit();\n     /// assert!(map.capacity() >= 2);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         let min_capacity = self.resize_policy.min_capacity(self.len());\n         let min_capacity = max(min_capacity.next_power_of_two(), INITIAL_CAPACITY);\n@@ -817,7 +817,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((&'a K,&'a V)) -> &'a K = first; // coerce to fn ptr\n@@ -842,7 +842,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n         let second: fn((&'a K,&'a V)) -> &'a V = second; // coerce to fn ptr\n@@ -867,7 +867,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter { inner: self.table.iter() }\n     }\n@@ -895,7 +895,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         IterMut { inner: self.table.iter_mut() }\n     }\n@@ -917,7 +917,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// // Not possible with .iter()\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n         let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n@@ -951,7 +951,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.table.size() }\n \n     /// Return true if the map contains no elements.\n@@ -967,7 +967,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n@@ -1014,7 +1014,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n         self.drain();\n@@ -1036,7 +1036,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1059,7 +1059,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1085,7 +1085,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1108,7 +1108,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n         let hash = self.make_hash(&k);\n         self.reserve(1);\n@@ -1137,7 +1137,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n         where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n@@ -1210,14 +1210,14 @@ impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Eq for HashMap<K, V, S>\n     where K: Eq + Hash<H>, V: Eq,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Show for HashMap<K, V, S>\n     where K: Eq + Hash<H> + Show, V: Show,\n           S: HashState<Hasher=H>,\n@@ -1235,7 +1235,7 @@ impl<K, V, S, H> Show for HashMap<K, V, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Default for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -1246,7 +1246,7 @@ impl<K, V, S, H> Default for HashMap<K, V, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           Q: Eq + Hash<H> + BorrowFrom<K>,\n@@ -1261,7 +1261,7 @@ impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           Q: Eq + Hash<H> + BorrowFrom<K>,\n@@ -1277,7 +1277,7 @@ impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n }\n \n /// HashMap iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: table::Iter<'a, K, V>\n }\n@@ -1292,13 +1292,13 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n }\n \n /// HashMap mutable values iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: table::IterMut<'a, K, V>\n }\n \n /// HashMap move iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     inner: iter::Map<\n         (SafeHash, K, V),\n@@ -1309,7 +1309,7 @@ pub struct IntoIter<K, V> {\n }\n \n /// HashMap keys iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n@@ -1324,7 +1324,7 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n }\n \n /// HashMap values iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n@@ -1385,74 +1385,74 @@ enum VacantEntryState<K, V, M> {\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Drain<'a, K, V> {\n     type Item = (K, V);\n \n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n@@ -1518,7 +1518,7 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -1533,7 +1533,7 @@ impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H>,"}, {"sha": "a6ebc402adea6d493e3cfc96aca0c2da0f2d8d52", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -90,7 +90,7 @@ use super::state::HashState;\n /// }\n /// ```\n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashSet<T, S = RandomState> {\n     map: HashMap<T, (), S>\n }\n@@ -105,7 +105,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> HashSet<T, RandomState> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n@@ -120,7 +120,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: uint) -> HashSet<T, RandomState> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n@@ -189,7 +189,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert!(set.capacity() >= 100);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> uint {\n         self.map.capacity()\n     }\n@@ -209,7 +209,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// set.reserve(10);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: uint) {\n         self.map.reserve(additional)\n     }\n@@ -230,7 +230,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.shrink_to_fit();\n     /// assert!(set.capacity() >= 2);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.map.shrink_to_fit()\n     }\n@@ -251,7 +251,7 @@ impl<T, S, H> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n@@ -276,7 +276,7 @@ impl<T, S, H> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n         let first: fn((T, ())) -> T = first;\n@@ -306,7 +306,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n     /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n         Difference {\n             iter: self.iter(),\n@@ -334,7 +334,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(diff1, diff2);\n     /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n         -> SymmetricDifference<'a, T, S> {\n         SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n@@ -357,7 +357,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n         Intersection {\n             iter: self.iter(),\n@@ -382,7 +382,7 @@ impl<T, S, H> HashSet<T, S>\n     /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n         Union { iter: self.iter().chain(other.difference(self)) }\n     }\n@@ -399,7 +399,7 @@ impl<T, S, H> HashSet<T, S>\n     /// v.insert(1u);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -414,7 +414,7 @@ impl<T, S, H> HashSet<T, S>\n     /// v.insert(1u);\n     /// assert!(!v.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n \n     /// Clears the set, returning all elements in an iterator.\n@@ -440,7 +440,7 @@ impl<T, S, H> HashSet<T, S>\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -458,7 +458,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n@@ -482,7 +482,7 @@ impl<T, S, H> HashSet<T, S>\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n@@ -503,7 +503,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n@@ -528,7 +528,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n         other.is_subset(self)\n     }\n@@ -547,7 +547,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n \n     /// Removes a value from the set. Returns `true` if the value was\n@@ -568,15 +568,15 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n         self.map.remove(value).is_some()\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> PartialEq for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -589,14 +589,14 @@ impl<T, S, H> PartialEq for HashSet<T, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> Eq for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> fmt::Show for HashSet<T, S>\n     where T: Eq + Hash<H> + fmt::Show,\n           S: HashState<Hasher=H>,\n@@ -614,7 +614,7 @@ impl<T, S, H> fmt::Show for HashSet<T, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> FromIterator<T> for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n@@ -628,7 +628,7 @@ impl<T, S, H> FromIterator<T> for HashSet<T, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> Extend<T> for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -641,19 +641,19 @@ impl<T, S, H> Extend<T> for HashSet<T, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> Default for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H> + Default,\n           H: hash::Hasher<Output=u64>\n {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> HashSet<T, S> {\n         HashSet::with_hash_state(Default::default())\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -686,7 +686,7 @@ impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -719,7 +719,7 @@ impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -752,7 +752,7 @@ impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash<H> + Clone,\n           S: HashState<Hasher=H> + Default,\n@@ -786,25 +786,25 @@ impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n }\n \n /// HashSet iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n     iter: Keys<'a, K, ()>\n }\n \n /// HashSet move iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n     iter: Map<(K, ()), K, map::IntoIter<K, ()>, fn((K, ())) -> K>\n }\n \n /// HashSet drain iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n     iter: Map<(K, ()), K, map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n }\n \n /// Intersection iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n@@ -813,7 +813,7 @@ pub struct Intersection<'a, T: 'a, S: 'a> {\n }\n \n /// Difference iterator\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n@@ -822,54 +822,54 @@ pub struct Difference<'a, T: 'a, S: 'a> {\n }\n \n /// Symmetric difference iterator.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n     iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n }\n \n /// Set union iterator.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a, S: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Iter<'a, K> {\n     type Item = &'a K;\n \n     fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> Iterator for IntoIter<K> {\n     type Item = K;\n \n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for IntoIter<K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Drain<'a, K> {\n     type Item = K;\n \n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -894,7 +894,7 @@ impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -919,7 +919,7 @@ impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -931,7 +931,7 @@ impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> Iterator for Union<'a, T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,"}, {"sha": "1b8780120b159739ced26d909532a0680a56bdcc", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -309,7 +309,7 @@\n //! }\n //! ```\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use core_collections::Bound;\n pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n@@ -323,13 +323,13 @@ pub use self::hash_set::HashSet;\n \n mod hash;\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod hash_map {\n     //! A hashmap\n     pub use super::hash::map::*;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod hash_set {\n     //! A hashset\n     pub use super::hash::set::*;"}, {"sha": "68ad3193e74bae5ba3074579ce1a23d35ed5a03d", "filename": "src/libstd/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -78,7 +78,7 @@\n //! }\n //! ```\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use prelude::v1::*;\n \n@@ -100,22 +100,22 @@ pub trait Error {\n }\n \n /// A trait for types that can be converted from a given error type `E`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait FromError<E> {\n     /// Perform the conversion.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_error(err: E) -> Self;\n }\n \n // Any type is convertable from itself\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<E> FromError<E> for E {\n     fn from_error(err: E) -> E {\n         err\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for Utf8Error {\n     fn description(&self) -> &str {\n         match *self {\n@@ -127,13 +127,13 @@ impl Error for Utf8Error {\n     fn detail(&self) -> Option<String> { Some(self.to_string()) }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for FromUtf8Error {\n     fn description(&self) -> &str { \"invalid utf-8\" }\n     fn detail(&self) -> Option<String> { Some(self.to_string()) }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for FromUtf16Error {\n     fn description(&self) -> &str { \"invalid utf-16\" }\n }"}, {"sha": "20901d9c50e2a15cdeb6383bb448f00049eda0b8", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -134,7 +134,7 @@ impl ChanWriter {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for ChanWriter {\n     fn clone(&self) -> ChanWriter {\n         ChanWriter { tx: self.tx.clone() }"}, {"sha": "0046a323d07620d435f80299cf3dadc8b2f098ab", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1814,9 +1814,9 @@ bitflags! {\n }\n \n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for FilePermission {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn default() -> FilePermission { FilePermission::empty() }\n }"}, {"sha": "d708f4df2a5800e16ea519c0ebd56120bfcea570", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -95,7 +95,7 @@\n //! and `format!`, also available to all Rust code.\n \n #![crate_name = \"std\"]\n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -183,7 +183,7 @@ pub use alloc::rc;\n pub use core_collections::slice;\n pub use core_collections::str;\n pub use core_collections::string;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core_collections::vec;\n \n pub use unicode::char;"}, {"sha": "5d1f2aa9b1ead2c924ca3a819d0b8ffe0e6ed897", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -36,7 +36,7 @@\n /// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! panic {\n     () => ({\n         panic!(\"explicit panic\")\n@@ -71,15 +71,15 @@ macro_rules! panic {\n /// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n /// ```\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! format {\n     ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n }\n \n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! print {\n     ($($arg:tt)*) => ($crate::io::stdio::print_args(format_args!($($arg)*)))\n }\n@@ -97,7 +97,7 @@ macro_rules! print {\n /// println!(\"format {} arguments\", \"some\");\n /// ```\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! println {\n     ($($arg:tt)*) => ($crate::io::stdio::println_args(format_args!($($arg)*)))\n }\n@@ -106,7 +106,7 @@ macro_rules! println {\n /// error if the value of the expression is `Err`. For more information, see\n /// `std::io`.\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! try {\n     ($expr:expr) => (match $expr {\n         $crate::result::Result::Ok(val) => val,"}, {"sha": "9b5b0e62a3c1a7a141e4f965b867371ce36da187", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for 32-bits floats (`f32` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n #![allow(unsigned_negation)]\n #![doc(primitive = \"f32\")]\n@@ -73,7 +73,7 @@ mod cmath {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { num::Float::nan() }"}, {"sha": "1c9558325292b207fb98bda6639c113dcb99b52f", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for 64-bits floats (`f64` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n #![doc(primitive = \"f64\")]\n \n@@ -81,7 +81,7 @@ mod cmath {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Float for f64 {\n     // inlined methods from `num::Float`\n     #[inline]"}, {"sha": "498f19b9b8307f3d45a68c90ff3d4a5d216276b2", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i16\")]\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};"}, {"sha": "aea1e92117bb0f315e0f414b1ccf000584135543", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i32\")]\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};"}, {"sha": "43794345fe7a4ebcd9b2b88ed2263ae2efa3f2b3", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i64\")]\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};"}, {"sha": "1b03bf6f4f0097c7b8cb9e20c9ee1a1b74051355", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i8\")]\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};"}, {"sha": "7fb2cd81ababf2dbfc44f0722f3f31e781446df2", "filename": "src/libstd/num/isize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fisize.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"isize\")]\n \n pub use core::isize::{BITS, BYTES, MIN, MAX};"}, {"sha": "c81dfad63d7f130e602abf5b12804c967e9f2769", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -13,7 +13,7 @@\n //! These are implemented for the primitive numeric types in `std::{u8, u16,\n //! u32, u64, uint, i8, i16, i32, i64, int, f32, f64}`.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n #[cfg(test)] use fmt::Show;\n@@ -37,7 +37,7 @@ use option::Option;\n pub mod strconv;\n \n /// Mathematical operations on primitive floating point numbers.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Float\n     : Copy + Clone\n     + NumCast\n@@ -142,48 +142,48 @@ pub trait Float\n     #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_normal(self) -> bool;\n     /// Returns the category that this number falls into.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn classify(self) -> FpCategory;\n \n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     #[unstable(feature = \"std_misc\", reason = \"signature is undecided\")]\n     fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Return the largest integer less than or equal to a number.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn floor(self) -> Self;\n     /// Return the smallest integer greater than or equal to a number.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ceil(self) -> Self;\n     /// Return the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn round(self) -> Self;\n     /// Return the integer part of a number.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trunc(self) -> Self;\n     /// Return the fractional part of a number.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fract(self) -> Self;\n \n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn abs(self) -> Self;\n     /// Returns a number that represents the sign of `self`.\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n     /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n     /// - `Float::nan()` if the number is `Float::nan()`\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn signum(self) -> Self;\n     /// Returns `true` if `self` is positive, including `+0.0` and\n     /// `Float::infinity()`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_positive(self) -> bool;\n     /// Returns `true` if `self` is negative, including `-0.0` and\n     /// `Float::neg_infinity()`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_negative(self) -> bool;\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n@@ -200,39 +200,39 @@ pub trait Float\n     /// Raise a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn powi(self, n: i32) -> Self;\n     /// Raise a number to a floating point power.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn powf(self, n: Self) -> Self;\n \n     /// Take the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sqrt(self) -> Self;\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn rsqrt(self) -> Self;\n \n     /// Returns `e^(self)`, (the exponential function).\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn exp(self) -> Self;\n     /// Returns 2 raised to the power of the number, `2^(self)`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn exp2(self) -> Self;\n     /// Returns the natural logarithm of the number.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ln(self) -> Self;\n     /// Returns the logarithm of the number with respect to an arbitrary base.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn log(self, base: Self) -> Self;\n     /// Returns the base 2 logarithm of the number.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn log2(self) -> Self;\n     /// Returns the base 10 logarithm of the number.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn log10(self) -> Self;\n \n     /// Convert radians to degrees.\n@@ -264,10 +264,10 @@ pub trait Float\n     fn next_after(self, other: Self) -> Self;\n \n     /// Returns the maximum of the two numbers.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self, other: Self) -> Self;\n     /// Returns the minimum of the two numbers.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self, other: Self) -> Self;\n \n     /// The positive difference of two numbers. Returns `0.0` if the number is\n@@ -286,36 +286,36 @@ pub trait Float\n     fn hypot(self, other: Self) -> Self;\n \n     /// Computes the sine of a number (in radians).\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sin(self) -> Self;\n     /// Computes the cosine of a number (in radians).\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cos(self) -> Self;\n     /// Computes the tangent of a number (in radians).\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn tan(self) -> Self;\n \n     /// Computes the arcsine of a number. Return value is in radians in\n     /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n     /// [-1, 1].\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn asin(self) -> Self;\n     /// Computes the arccosine of a number. Return value is in radians in\n     /// the range [0, pi] or NaN if the number is outside the range\n     /// [-1, 1].\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn acos(self) -> Self;\n     /// Computes the arctangent of a number. Return value is in radians in the\n     /// range [-pi/2, pi/2];\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn atan(self) -> Self;\n     /// Computes the four quadrant arctangent of a number, `y`, and another\n     /// number `x`. Return value is in radians in the range [-pi, pi].\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn atan2(self, other: Self) -> Self;\n     /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n     /// `(sin(x), cos(x))`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sin_cos(self) -> (Self, Self);\n \n     /// Returns the exponential of the number, minus 1, in a way that is\n@@ -328,22 +328,22 @@ pub trait Float\n     fn ln_1p(self) -> Self;\n \n     /// Hyperbolic sine function.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sinh(self) -> Self;\n     /// Hyperbolic cosine function.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cosh(self) -> Self;\n     /// Hyperbolic tangent function.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn tanh(self) -> Self;\n     /// Inverse hyperbolic sine function.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn asinh(self) -> Self;\n     /// Inverse hyperbolic cosine function.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn acosh(self) -> Self;\n     /// Inverse hyperbolic tangent function.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn atanh(self) -> Self;\n }\n "}, {"sha": "3fda77fb69c402ecd739b28811687f1517006bbc", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u16\")]\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};"}, {"sha": "8610f0c01473f8887d0938ed68d39243991b310b", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u32\")]\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};"}, {"sha": "3587b06965624930b38cf0976a19b3e5e2c481e0", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u64\")]\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};"}, {"sha": "6a285e8299c1eccbb437558866da2881c2a5b7b2", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u8\")]\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};"}, {"sha": "19964c306a79bbcc08bdf8047ae23e96be9e8a89", "filename": "src/libstd/num/usize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fusize.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -14,7 +14,7 @@\n //! new type will gradually take place over the alpha cycle along with\n //! the development of clearer conventions around integer types.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"usize\")]\n \n pub use core::usize::{BITS, BYTES, MIN, MAX};"}, {"sha": "09fa10dacf98c2807a7186165d6692415dbc2074", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -35,6 +35,6 @@\n //! pervasive that it would be obnoxious to import for every use, particularly\n //! those that define methods on primitive types.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub mod v1;"}, {"sha": "51cf173ca94d02c8cc00501db318e3a5a25e22e1", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -10,53 +10,53 @@\n \n //! The first version of the prelude of the standard library.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Reexported core operators\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use marker::{Copy, Send, Sized, Sync};\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // TEMPORARY\n #[unstable(feature = \"std_misc\")]\n #[doc(no_inline)] pub use ops::FullRange;\n \n // Reexported functions\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use mem::drop;\n \n // Reexported types and traits\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use boxed::Box;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use char::CharExt;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use clone::Clone;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use iter::DoubleEndedIterator;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use iter::ExactSizeIterator;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use iter::{Iterator, IteratorExt, Extend};\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use option::Option::{self, Some, None};\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use slice::AsSlice;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt};\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use str::{Str, StrExt};\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use string::{String, ToString};\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use vec::Vec;\n \n // NB: remove when path reform lands"}, {"sha": "40710d627c0ec3df6f4562d7d1b29a1f591f5a17", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -29,7 +29,7 @@ use sync::{Mutex, Condvar};\n ///     });\n /// }\n /// ```\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Barrier {\n     lock: Mutex<BarrierState>,\n     cvar: Condvar,\n@@ -54,7 +54,7 @@ impl Barrier {\n     ///\n     /// A barrier will block `n`-1 threads which call `wait` and then wake up\n     /// all threads at once when the `n`th thread calls `wait`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(n: uint) -> Barrier {\n         Barrier {\n             lock: Mutex::new(BarrierState {\n@@ -75,7 +75,7 @@ impl Barrier {\n     /// returns `true` from `is_leader` when returning from this function, and\n     /// all other threads will receive a result that will return `false` from\n     /// `is_leader`\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn wait(&self) -> BarrierWaitResult {\n         let mut lock = self.lock.lock().unwrap();\n         let local_gen = lock.generation_id;\n@@ -102,7 +102,7 @@ impl BarrierWaitResult {\n     ///\n     /// Only one thread will have `true` returned from their result, all other\n     /// threads will have `false` returned.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_leader(&self) -> bool { self.0 }\n }\n "}, {"sha": "a7a5b084582caafa6df03953be83e079dbdf0051", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -58,7 +58,7 @@ use sync::{mutex, MutexGuard};\n ///     started = cvar.wait(started).unwrap();\n /// }\n /// ```\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Condvar { inner: Box<StaticCondvar> }\n \n unsafe impl Send for Condvar {}\n@@ -97,7 +97,7 @@ pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n     /// notified.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Condvar {\n         Condvar {\n             inner: box StaticCondvar {\n@@ -133,7 +133,7 @@ impl Condvar {\n     /// over time. Each condition variable is dynamically bound to exactly one\n     /// mutex to ensure defined behavior across platforms. If this functionality\n     /// is not desired, then unsafe primitives in `sys` are provided.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n         unsafe {\n@@ -191,7 +191,7 @@ impl Condvar {\n     /// `notify_one` are not buffered in any way.\n     ///\n     /// To wake up all threads, see `notify_all()`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }\n \n     /// Wake up all blocked threads on this condvar.\n@@ -201,11 +201,11 @@ impl Condvar {\n     /// way.\n     ///\n     /// To wake up only one thread, see `notify_one()`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Drop for Condvar {\n     fn drop(&mut self) {\n         unsafe { self.inner.inner.destroy() }"}, {"sha": "f3b721438d807a2872f2fa706e441ebc2df3a3f2", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -15,7 +15,7 @@\n //! and/or blocking at all, but rather provide the necessary tools to build\n //! other types of concurrent primitives.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use alloc::arc::{Arc, Weak};\n pub use core::atomic;"}, {"sha": "8fce8cbabccd9452753a7b3c5099b8ea3b491e9b", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -163,7 +163,7 @@\n //! }\n //! ```\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // A description of how Rust's channel implementation works\n //\n@@ -339,7 +339,7 @@ mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -351,14 +351,14 @@ unsafe impl<T:Send> Send for Receiver<T> { }\n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     rx: &'a Receiver<T>\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -370,7 +370,7 @@ unsafe impl<T:Send> Send for Sender<T> { }\n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n     inner: Arc<RacyCell<sync::Packet<T>>>,\n     // can't share in an arc\n@@ -379,7 +379,7 @@ pub struct SyncSender<T> {\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct SyncSender<T> {\n     inner: Arc<RacyCell<sync::Packet<T>>>,\n@@ -394,50 +394,50 @@ impl<T> !marker::Sync for SyncSender<T> {}\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n #[derive(PartialEq, Eq)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SendError<T>(pub T);\n \n /// An error returned from the `recv` function on a `Receiver`.\n ///\n /// The `recv` operation can only fail if the sending half of a channel is\n /// disconnected, implying that no further messages will ever be received.\n #[derive(PartialEq, Eq, Clone, Copy)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RecvError;\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n #[derive(PartialEq, Clone, Copy)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n     /// disconnected, so data may yet become available.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Empty,\n \n     /// This channel's sending half has become disconnected, and there will\n     /// never be any more data received on this channel\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Disconnected,\n }\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n #[derive(PartialEq, Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data.\n     ///\n     /// If this is a buffered channel, then the buffer is full at this time. If\n     /// this is not a buffered channel, then there is no receiver available to\n     /// acquire the data.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Full(T),\n \n     /// This channel's receiving half has disconnected, so the data could not be\n     /// sent. The data is returned back to the callee in this case.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Disconnected(T),\n }\n \n@@ -495,7 +495,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// // Let's see what that answer was\n /// println!(\"{:?}\", rx.recv().unwrap());\n /// ```\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n     (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n@@ -535,7 +535,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// assert_eq!(rx.recv().unwrap(), 1i);\n /// assert_eq!(rx.recv().unwrap(), 2i);\n /// ```\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n@@ -579,7 +579,7 @@ impl<T: Send> Sender<T> {\n     /// drop(rx);\n     /// assert_eq!(tx.send(1i).err().unwrap().0, 1);\n     /// ```\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n@@ -626,7 +626,7 @@ impl<T: Send> Sender<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n@@ -672,7 +672,7 @@ impl<T: Send> Clone for Sender<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n@@ -713,7 +713,7 @@ impl<T: Send> SyncSender<T> {\n     /// This function will never panic, but it may return `Err` if the\n     /// `Receiver` has disconnected and is no longer able to receive\n     /// information.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         unsafe { (*self.inner.get()).send(t).map_err(SendError) }\n     }\n@@ -727,13 +727,13 @@ impl<T: Send> SyncSender<T> {\n     ///\n     /// See `SyncSender::send` for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         unsafe { (*self.inner.get()).try_send(t) }\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n         unsafe { (*self.inner.get()).clone_chan(); }\n@@ -742,7 +742,7 @@ impl<T: Send> Clone for SyncSender<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n         unsafe { (*self.inner.get()).drop_chan(); }\n@@ -766,7 +766,7 @@ impl<T: Send> Receiver<T> {\n     ///\n     /// This is useful for a flavor of \"optimistic check\" before deciding to\n     /// block on a receiver.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n@@ -827,7 +827,7 @@ impl<T: Send> Receiver<T> {\n     /// If the corresponding `Sender` has disconnected, or it disconnects while\n     /// this call is blocking, this call will wake up and return `Err` to\n     /// indicate that no more messages can ever be received on this channel.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn recv(&self) -> Result<T, RecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n@@ -866,7 +866,7 @@ impl<T: Send> Receiver<T> {\n \n     /// Returns an iterator that will block waiting for messages, but never\n     /// `panic!`. It will return `None` when the channel has hung up.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { rx: self }\n     }\n@@ -958,15 +958,15 @@ impl<T: Send> select::Packet for Receiver<T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Send> Iterator for Iter<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {"}, {"sha": "92aec5cde07e80e3498711dd50ac502ad7024693", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -138,7 +138,7 @@ impl<T: Send> Queue<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "d74e030a018c17ca1851d8a0cddd915b062da11d", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -109,7 +109,7 @@ use sys_common::mutex as sys;\n ///\n /// *guard += 1;\n /// ```\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Mutex<T> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n@@ -161,7 +161,7 @@ unsafe impl Sync for StaticMutex {}\n /// Deref and DerefMut implementations\n #[must_use]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n@@ -177,7 +177,7 @@ pub struct MutexGuard<'a, T: 'a> {\n /// The data protected by the mutex can be access through this guard via its\n /// Deref and DerefMut implementations\n #[must_use]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n@@ -201,7 +201,7 @@ pub const MUTEX_INIT: StaticMutex = StaticMutex {\n \n impl<T: Send> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n         Mutex {\n             inner: box MUTEX_INIT,\n@@ -220,7 +220,7 @@ impl<T: Send> Mutex<T> {\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return an error once the mutex is acquired.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n         unsafe { self.inner.lock.lock() }\n         MutexGuard::new(&*self.inner, &self.data)\n@@ -239,7 +239,7 @@ impl<T: Send> Mutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n         if unsafe { self.inner.lock.try_lock() } {\n             Ok(try!(MutexGuard::new(&*self.inner, &self.data)))\n@@ -250,7 +250,7 @@ impl<T: Send> Mutex<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> Drop for Mutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n@@ -330,23 +330,23 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'mutex, T> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.__data.get() }\n     }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for MutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {"}, {"sha": "1c489540581824aeb4ce66dd1c3d7845d2de4830", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -36,7 +36,7 @@ use sync::{StaticMutex, MUTEX_INIT};\n ///     // run initialization here\n /// });\n /// ```\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Once {\n     mutex: StaticMutex,\n     cnt: AtomicIsize,\n@@ -46,7 +46,7 @@ pub struct Once {\n unsafe impl Sync for Once {}\n \n /// Initialization value for static `Once` values.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,\n     cnt: ATOMIC_ISIZE_INIT,\n@@ -63,7 +63,7 @@ impl Once {\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified).\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n         // Optimize common path: load is much cheaper than fetch_add.\n         if self.cnt.load(Ordering::SeqCst) < 0 {"}, {"sha": "6c5cb302ab115808a3c19e3d6d634843fa102b6a", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -53,22 +53,22 @@ pub struct Guard {\n /// is held. The precise semantics for when a lock is poisoned is documented on\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PoisonError<T> {\n     guard: T,\n }\n \n /// An enumeration of possible errors which can occur while calling the\n /// `try_lock` method.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryLockError<T> {\n     /// The lock could not be acquired because another task failed while holding\n     /// the lock.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Poisoned(PoisonError<T>),\n     /// The lock could not be acquired at this time because the operation would\n     /// otherwise block.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     WouldBlock,\n }\n \n@@ -79,15 +79,15 @@ pub enum TryLockError<T> {\n /// that the primitive was poisoned. Note that the `Err` variant *also* carries\n /// the associated guard, and it can be acquired through the `into_inner`\n /// method.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n \n /// A type alias for the result of a nonblocking locking method.\n ///\n /// For more information, see `LockResult`. A `TryLockResult` doesn't\n /// necessarily hold the associated guard in the `Err` type as the lock may not\n /// have been acquired for other reasons.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n \n impl<T> fmt::Show for PoisonError<T> {"}, {"sha": "01389047df60b2b6aa60e92a7d82fc5267359785", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -58,7 +58,7 @@ use sys_common::rwlock as sys;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLock<T> {\n     inner: Box<StaticRwLock>,\n     data: UnsafeCell<T>,\n@@ -111,7 +111,7 @@ pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct RwLockReadGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n@@ -123,7 +123,7 @@ pub struct RwLockReadGuard<'a, T: 'a> {\n /// dropped.\n #[must_use]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockReadGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n@@ -136,7 +136,7 @@ impl<'a, T> !marker::Send for RwLockReadGuard<'a, T> {}\n /// dropped.\n #[must_use]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockWriteGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n@@ -147,7 +147,7 @@ pub struct RwLockWriteGuard<'a, T: 'a> {\n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct RwLockWriteGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n@@ -160,7 +160,7 @@ impl<'a, T> !marker::Send for RwLockWriteGuard<'a, T> {}\n \n impl<T: Send + Sync> RwLock<T> {\n     /// Creates a new instance of an RwLock which is unlocked and read to go.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> RwLock<T> {\n         RwLock { inner: box RW_LOCK_INIT, data: UnsafeCell::new(t) }\n     }\n@@ -183,7 +183,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// The failure will occur immediately after the lock has been acquired.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n         unsafe { self.inner.lock.read() }\n         RwLockReadGuard::new(&*self.inner, &self.data)\n@@ -205,7 +205,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n             Ok(try!(RwLockReadGuard::new(&*self.inner, &self.data)))\n@@ -229,7 +229,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// An error will be returned when the lock is acquired.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n         unsafe { self.inner.lock.write() }\n         RwLockWriteGuard::new(&*self.inner, &self.data)\n@@ -248,7 +248,7 @@ impl<T: Send + Sync> RwLock<T> {\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n             Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n@@ -259,7 +259,7 @@ impl<T: Send + Sync> RwLock<T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for RwLock<T> {\n     fn drop(&mut self) {\n         unsafe { self.inner.lock.destroy() }\n@@ -389,35 +389,35 @@ impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n     }\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n         self.__lock.poison.done(&self.__poison);"}, {"sha": "0304b898884ccb2e47cfa0d11faf0484dac82c25", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -100,7 +100,7 @@ impl Semaphore {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Drop for SemaphoreGuard<'a> {\n     fn drop(&mut self) {\n         self.sem.release();"}, {"sha": "ec2718bef692460acbcbef140f0f197d31e5ed97", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -144,7 +144,7 @@\n //!\n //! * It can be implemented highly efficiently on many platforms.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use any::Any;\n use boxed::Box;\n@@ -166,7 +166,7 @@ use sys_common::{stack, thread_info};\n \n /// Thread configuration. Provides detailed control over the properties\n /// and behavior of new threads.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Builder {\n     // A name for the thread-to-be, for identification in panic messages\n     name: Option<String>,\n@@ -181,7 +181,7 @@ pub struct Builder {\n impl Builder {\n     /// Generate the base configuration for spawning a thread, from which\n     /// configuration methods can be chained.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Builder {\n         Builder {\n             name: None,\n@@ -193,14 +193,14 @@ impl Builder {\n \n     /// Name the thread-to-be. Currently the name is used for identification\n     /// only in panic messages.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn name(mut self, name: String) -> Builder {\n         self.name = Some(name);\n         self\n     }\n \n     /// Set the size of the stack for the new thread.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn stack_size(mut self, size: uint) -> Builder {\n         self.stack_size = Some(size);\n         self\n@@ -330,7 +330,7 @@ struct Inner {\n unsafe impl Sync for Inner {}\n \n #[derive(Clone)]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n /// A handle to a thread.\n pub struct Thread {\n     inner: Arc<Inner>,\n@@ -377,7 +377,7 @@ impl Thread {\n     }\n \n     /// Gets a handle to the thread that invokes it.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn current() -> Thread {\n         thread_info::current_thread()\n     }\n@@ -390,7 +390,7 @@ impl Thread {\n \n     /// Determines whether the current thread is panicking.\n     #[inline]\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn panicking() -> bool {\n         unwind::panicking()\n     }\n@@ -427,7 +427,7 @@ impl Thread {\n     }\n \n     /// Get the thread's name.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn name(&self) -> Option<&str> {\n         self.inner.name.as_ref().map(|s| s.as_slice())\n     }\n@@ -441,7 +441,7 @@ impl thread_info::NewThread for Thread {\n /// Indicates the manner in which a thread exited.\n ///\n /// A thread that completes without panicking is considered to exit successfully.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = ::result::Result<T, Box<Any + Send>>;\n \n struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n@@ -462,12 +462,12 @@ pub struct JoinGuard<'a, T: 'a> {\n     packet: Packet<T>,\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<'a, T: Send + 'a> Sync for JoinGuard<'a, T> {}\n \n impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     /// Extract a handle to the thread this guard will join on.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn thread(&self) -> &Thread {\n         &self.thread\n     }\n@@ -477,7 +477,7 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     ///\n     /// If the child thread panics, `Err` is returned with the parameter given\n     /// to `panic`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn join(mut self) -> Result<T> {\n         assert!(!self.joined);\n         unsafe { imp::join(self.native) };\n@@ -499,7 +499,7 @@ impl<T: Send> JoinGuard<'static, T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     fn drop(&mut self) {\n         if !self.joined {"}, {"sha": "f7be63212aba967c33b92cdf0018836b3cfec5a9", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -34,7 +34,7 @@\n //! will want to make use of some form of **interior mutability** through the\n //! `Cell` or `RefCell` types.\n \n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use prelude::v1::*;\n \n@@ -93,7 +93,7 @@ pub mod __impl {\n ///     assert_eq!(*f.borrow(), 2);\n /// });\n /// ```\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Key<T> {\n     // The key itself may be tagged with #[thread_local], and this `Key` is\n     // stored as a `static`, and it's not valid for a static to reference the\n@@ -113,7 +113,7 @@ pub struct Key<T> {\n \n /// Declare a new thread local storage key of type `std::thread_local::Key`.\n #[macro_export]\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n         static $name: ::std::thread_local::Key<$t> = {\n@@ -259,7 +259,7 @@ impl<T: 'static> Key<T> {\n     /// This function will `panic!()` if the key currently has its\n     /// destructor running, and it **may** panic if the destructor has\n     /// previously been run for this thread.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with<F, R>(&'static self, f: F) -> R\n                       where F: FnOnce(&T) -> R {\n         let slot = (self.inner)();"}, {"sha": "2a911557765b5b9949f0bda1831e4fd98882af17", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -57,4 +57,4 @@\n //! ```\n \n #![doc(primitive = \"tuple\")]\n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "2c3ddcd9d4947188f937401a07ff3a01801fc8e0", "filename": "src/libstd/unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funit.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![doc(primitive = \"unit\")]\n-#![stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n //! The `()` type, sometimes called \"unit\" or \"nil\".\n //!"}, {"sha": "e19c1dc7ed626688f26ccba638bceb7034f15e5f", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -60,7 +60,7 @@ mod u_str;\n /// (inclusive) are allowed. A `char` can always be safely cast to a `u32`;\n /// however the converse is not always true due to the above range limits\n /// and, as such, should be performed via the `from_u32` function..\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod char {\n     pub use core::char::{MAX, from_u32, from_digit};\n "}, {"sha": "467fed5d246706ede73c6b98a6e0398311bb2c6d", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -19,7 +19,7 @@ use core::option::Option;\n use tables::{derived_property, property, general_category, conversions, charwidth};\n \n /// Functionality for manipulating `char`.\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait CharExt {\n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n@@ -59,7 +59,7 @@ pub trait CharExt {\n     /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n     /// where `NNNN` is the shortest hexadecimal representation of the code\n     /// point.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> char::EscapeUnicode;\n \n     /// Returns an iterator that yields the 'default' ASCII and\n@@ -74,17 +74,17 @@ pub trait CharExt {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> char::EscapeDefault;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-16.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n@@ -107,7 +107,7 @@ pub trait CharExt {\n \n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_alphabetic(self) -> bool;\n \n     /// Returns whether the specified character satisfies the 'XID_Start'\n@@ -134,38 +134,38 @@ pub trait CharExt {\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_lowercase(self) -> bool;\n \n     /// Indicates whether a character is in uppercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_uppercase(self) -> bool;\n \n     /// Indicates whether a character is whitespace.\n     ///\n     /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_whitespace(self) -> bool;\n \n     /// Indicates whether a character is alphanumeric.\n     ///\n     /// Alphanumericness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_alphanumeric(self) -> bool;\n \n     /// Indicates whether a character is a control code point.\n     ///\n     /// Control code points are defined in terms of the Unicode General\n     /// Category `Cc`.\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_control(self) -> bool;\n \n     /// Indicates whether the character is numeric (Nd, Nl, or No).\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_numeric(self) -> bool;\n \n     /// Converts a character to its lowercase equivalent.\n@@ -219,21 +219,21 @@ pub trait CharExt {\n     fn width(self, is_cjk: bool) -> Option<uint>;\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool { C::is_digit(self, radix) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint> { C::to_digit(self, radix) }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> char::EscapeUnicode { C::escape_unicode(self) }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> char::EscapeDefault { C::escape_default(self) }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> uint { C::len_utf8(self) }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint { C::len_utf16(self) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n@@ -242,7 +242,7 @@ impl CharExt for char {\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> { C::encode_utf16(self, dst) }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_alphabetic(self) -> bool {\n         match self {\n             'a' ... 'z' | 'A' ... 'Z' => true,\n@@ -259,7 +259,7 @@ impl CharExt for char {\n                reason = \"mainly needed for compiler internals\")]\n     fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_lowercase(self) -> bool {\n         match self {\n             'a' ... 'z' => true,\n@@ -268,7 +268,7 @@ impl CharExt for char {\n         }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_uppercase(self) -> bool {\n         match self {\n             'A' ... 'Z' => true,\n@@ -277,7 +277,7 @@ impl CharExt for char {\n         }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_whitespace(self) -> bool {\n         match self {\n             ' ' | '\\x09' ... '\\x0d' => true,\n@@ -286,15 +286,15 @@ impl CharExt for char {\n         }\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_alphanumeric(self) -> bool {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_control(self) -> bool { general_category::Cc(self) }\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_numeric(self) -> bool {\n         match self {\n             '0' ... '9' => true,"}, {"sha": "1cdbb6c835607a9f09cefb382387c61382f100ae", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -30,7 +30,7 @@ use u_char::CharExt as UCharExt; // conflicts with core::prelude::CharExt\n use tables::grapheme::GraphemeCat;\n \n /// An iterator over the words of a string, separated by a sequence of whitespace\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Words<'a> {\n     inner: Filter<&'a str, Split<'a, fn(char) -> bool>, fn(&&str) -> bool>,\n }"}, {"sha": "77eb82f80228649965299a2e1be76ffe26a84a03", "filename": "src/test/auxiliary/inherited_stability.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherited_stability.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -15,14 +15,14 @@\n \n pub fn unstable() {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stable() {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod stable_mod {\n     pub fn unstable() {}\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn stable() {}\n }\n \n@@ -35,11 +35,11 @@ pub mod unstable_mod {\n     pub fn unstable() {}\n }\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Stable {\n     fn unstable(&self);\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn stable(&self);\n }\n \n@@ -50,6 +50,6 @@ impl Stable for uint {\n \n pub enum Unstable {\n     UnstableVariant,\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     StableVariant\n }"}, {"sha": "3679557d06bb761b7f69424b0dc9e5c715163197", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -33,12 +33,12 @@ pub fn unstable_text() {}\n \n pub fn unmarked() {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stable() {}\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n pub fn stable_text() {}\n \n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct MethodTester;\n \n impl MethodTester {\n@@ -63,9 +63,9 @@ impl MethodTester {\n \n     pub fn method_unmarked(&self) {}\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn method_stable(&self) {}\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n     pub fn method_stable_text(&self) {}\n \n     #[locked]\n@@ -101,9 +101,9 @@ pub trait Trait {\n \n     fn trait_unmarked(&self) {}\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trait_stable(&self) {}\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n     fn trait_stable_text(&self) {}\n \n     #[locked]\n@@ -131,7 +131,7 @@ pub struct DeprecatedUnstableStruct { pub i: int }\n #[unstable(feature = \"test_feature\")]\n pub struct UnstableStruct { pub i: int }\n pub struct UnmarkedStruct { pub i: int }\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StableStruct { pub i: int }\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n@@ -143,7 +143,7 @@ pub struct DeprecatedUnstableUnitStruct;\n #[unstable(feature = \"test_feature\")]\n pub struct UnstableUnitStruct;\n pub struct UnmarkedUnitStruct;\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StableUnitStruct;\n \n pub enum Enum {\n@@ -157,7 +157,7 @@ pub enum Enum {\n     UnstableVariant,\n \n     UnmarkedVariant,\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     StableVariant,\n }\n \n@@ -170,7 +170,7 @@ pub struct DeprecatedUnstableTupleStruct(pub int);\n #[unstable(feature = \"test_feature\")]\n pub struct UnstableTupleStruct(pub int);\n pub struct UnmarkedTupleStruct(pub int);\n-#[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StableTupleStruct(pub int);\n \n #[macro_export]"}, {"sha": "9f0e81a662f55c38a0190140a8a623ceb498c89b", "filename": "src/test/compile-fail/issue-20711-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20711-2.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -13,7 +13,7 @@ struct Foo;\n impl Foo {\n     fn foo() {}\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n } //~ ERROR expected `fn`, found `}`\n \n fn main() {}"}, {"sha": "5f0f0fc05a929372e32b797533f81630d35a64ef", "filename": "src/test/compile-fail/issue-20711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20711.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -11,7 +11,7 @@\n struct Foo;\n \n impl Foo {\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n } //~ ERROR expected `fn`, found `}`\n \n fn main() {}"}, {"sha": "5b093a8556cdd112f16300bf7dd4d099ca11440f", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -185,12 +185,12 @@ mod this_crate {\n \n     pub fn unmarked() {}\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn stable() {}\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n     pub fn stable_text() {}\n \n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub struct MethodTester;\n \n     impl MethodTester {\n@@ -208,9 +208,9 @@ mod this_crate {\n \n         pub fn method_unmarked(&self) {}\n \n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn method_stable(&self) {}\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n         pub fn method_stable_text(&self) {}\n     }\n \n@@ -229,9 +229,9 @@ mod this_crate {\n \n         fn trait_unmarked(&self) {}\n \n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         fn trait_stable(&self) {}\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\", reason = \"text\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n         fn trait_stable_text(&self) {}\n     }\n \n@@ -243,7 +243,7 @@ mod this_crate {\n     #[unstable(feature = \"test_feature\")]\n     pub struct UnstableStruct { i: isize }\n     pub struct UnmarkedStruct { i: isize }\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub struct StableStruct { i: isize }\n \n     #[unstable(feature = \"test_feature\")]\n@@ -252,7 +252,7 @@ mod this_crate {\n     #[unstable(feature = \"test_feature\")]\n     pub struct UnstableUnitStruct;\n     pub struct UnmarkedUnitStruct;\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub struct StableUnitStruct;\n \n     pub enum Enum {\n@@ -263,7 +263,7 @@ mod this_crate {\n         UnstableVariant,\n \n         UnmarkedVariant,\n-        #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         StableVariant,\n     }\n \n@@ -273,7 +273,7 @@ mod this_crate {\n     #[unstable(feature = \"test_feature\")]\n     pub struct UnstableTupleStruct(isize);\n     pub struct UnmarkedTupleStruct(isize);\n-    #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub struct StableTupleStruct(isize);\n \n     fn test() {"}]}