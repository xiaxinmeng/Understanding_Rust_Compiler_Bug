{"sha": "7884eb8e2ff8f0796a95aa0216e69241934ce14f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ODRlYjhlMmZmOGYwNzk2YTk1YWEwMjE2ZTY5MjQxOTM0Y2UxNGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-06T17:45:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-06T17:45:19Z"}, "message": "Auto merge of #21860 - mdinger:enum_rewording, r=steveklabnik\n\nSecond try to address https://github.com/rust-lang/rust/issues/21196 . A lot that was removed at the end basically seemed repetitive showing simple variations on the same type. It seems more effective to just show more variants at the beginning instead.\r\n\r\nIf you want to pack values into an example, better to use `i32` or some digit than `String` because you don't need the `to_string()` method.\r\n\r\nI didn't mention `derive` because:\r\n* I can't explain it (only use it)\r\n* I don't have a link to a good description (maybe rustbyexample but you probably want links internal)\r\n* Giving more detail especially stating that `==` won't work and why should help quite a bit\r\n\r\nI didn't `make test` or check links but I will if this will be merged.\r\n\r\n@steveklabnik", "tree": {"sha": "27cc7ee347ee0a8c278152b0f26d4154fecff32e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27cc7ee347ee0a8c278152b0f26d4154fecff32e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7884eb8e2ff8f0796a95aa0216e69241934ce14f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7884eb8e2ff8f0796a95aa0216e69241934ce14f", "html_url": "https://github.com/rust-lang/rust/commit/7884eb8e2ff8f0796a95aa0216e69241934ce14f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7884eb8e2ff8f0796a95aa0216e69241934ce14f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b56e9b1cb2fc00d7d9bc044e2a78b8fb12f2f1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b56e9b1cb2fc00d7d9bc044e2a78b8fb12f2f1b", "html_url": "https://github.com/rust-lang/rust/commit/0b56e9b1cb2fc00d7d9bc044e2a78b8fb12f2f1b"}, {"sha": "a9583d62365c144e55f6c8ae49e30193c41c4268", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9583d62365c144e55f6c8ae49e30193c41c4268", "html_url": "https://github.com/rust-lang/rust/commit/a9583d62365c144e55f6c8ae49e30193c41c4268"}], "stats": {"total": 183, "additions": 90, "deletions": 93}, "files": [{"sha": "8b99278acb1f67e3d917b5421b03662a10c7350a", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 90, "deletions": 93, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/7884eb8e2ff8f0796a95aa0216e69241934ce14f/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/7884eb8e2ff8f0796a95aa0216e69241934ce14f/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=7884eb8e2ff8f0796a95aa0216e69241934ce14f", "patch": "@@ -200,8 +200,62 @@ destructuring `let`, as we discussed previously in 'tuples.' In this case, the\n ## Enums\n \n Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n-feature of Rust, and are used throughout the standard library. This is an enum\n-that is provided by the Rust standard library:\n+feature of Rust, and are used throughout the standard library. An `enum` is\n+a type which ties a set of alternates to a specific name. For example, below\n+we define `Character` to be either a `Digit` or something else. These\n+can be used via their fully scoped names: `Character::Other` (more about `::`\n+below).\n+\n+```rust\n+enum Character {\n+    Digit(i32),\n+    Other,\n+}\n+```\n+\n+An `enum` variant can be defined as most normal types. Below are some example\n+types have been listed which also would be allowed in an `enum`.\n+\n+```rust\n+struct Empty;\n+struct Color(i32, i32, i32);\n+struct Length(i32);\n+struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n+struct HeightDatabase(Vec<i32>);\n+```\n+\n+So you see that depending on the sub-datastructure, the `enum` variant, same as\n+a struct, may or may not hold data. That is, in `Character`, `Digit` is a name\n+tied to an `i32` where `Other` is just a name. However, the fact that they are\n+distinct makes this very useful.\n+\n+As with structures, enums don't by default have access to operators such as\n+compare ( `==` and `!=`), binary operations (`*` and `+`), and order\n+(`<` and `>=`). As such, using the previous `Character` type, the\n+following code is invalid:\n+\n+```{rust,ignore}\n+// These assignments both succeed\n+let ten  = Character::Digit(10);\n+let four = Character::Digit(4);\n+\n+// Error: `*` is not implemented for type `Character`\n+let forty = ten * four;\n+\n+// Error: `<=` is not implemented for type `Character`\n+let four_is_smaller = four <= ten;\n+\n+// Error: `==` is not implemented for type `Character`\n+let four_equals_ten = four == ten;\n+```\n+\n+This may seem rather limiting, particularly equality being invalid; in\n+many cases however, it's unnecessary. Rust provides the [`match`][match]\n+keyword, which will be examined in more detail in the next section, which\n+often allows better and easier branch control than a series of `if`/`else`\n+statements would. However, for our [game][game] we need the comparisons\n+to work so we will utilize the `Ordering` `enum` provided by the standard\n+library which supports such comparisons. It has this form:\n \n ```{rust}\n enum Ordering {\n@@ -211,14 +265,9 @@ enum Ordering {\n }\n ```\n \n-An `Ordering` can only be _one_ of `Less`, `Equal`, or `Greater` at any given\n-time.\n-\n-Because `Ordering` is provided by the standard library, we can use the `use`\n-keyword to use it in our code. We'll learn more about `use` later, but it's\n-used to bring names into scope.\n-\n-Here's an example of how to use `Ordering`:\n+Because we did not define `Ordering`, we must import it (from the std\n+library) with the `use` keyword. Here's an example of how `Ordering` is\n+used:\n \n ```{rust}\n use std::cmp::Ordering;\n@@ -245,11 +294,10 @@ fn main() {\n }\n ```\n \n-There's a symbol here we haven't seen before: the double colon (`::`).\n-This is used to indicate a namespace. In this case, `Ordering` lives in\n-the `cmp` submodule of the `std` module. We'll talk more about modules\n-later in the guide. For now, all you need to know is that you can `use`\n-things from the standard library if you need them.\n+The `::` symbol is used to indicate a namespace. In this case, `Ordering` lives\n+in the `cmp` submodule of the `std` module. We'll talk more about modules later\n+in the guide. For now, all you need to know is that you can `use` things from\n+the standard library if you need them.\n \n Okay, let's talk about the actual code in the example. `cmp` is a function that\n compares two things, and returns an `Ordering`. We return either\n@@ -259,95 +307,44 @@ the two values are less, greater, or equal. Note that each variant of the\n `Greater`.\n \n The `ordering` variable has the type `Ordering`, and so contains one of the\n-three values. We can then do a bunch of `if`/`else` comparisons to check which\n-one it is. However, repeated `if`/`else` comparisons get quite tedious. Rust\n-has a feature that not only makes them nicer to read, but also makes sure that\n-you never miss a case. Before we get to that, though, let's talk about another\n-kind of enum: one with values.\n+three values. We then do a bunch of `if`/`else` comparisons to check which\n+one it is.\n \n-This enum has two variants, one of which has a value:\n+This `Ordering::Greater` notation is too long. Lets use `use` to import can\n+the `enum` variants instead. This will avoid full scoping:\n \n ```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-```\n-\n-This enum represents an `i32` that we may or may not have. In the `Missing`\n-case, we have no value, but in the `Value` case, we do. This enum is specific\n-to `i32`s, though. We can make it usable by any type, but we haven't quite\n-gotten there yet!\n-\n-You can also have any number of values in an enum:\n+use std::cmp::Ordering::{self, Equal, Less, Greater};\n \n-```{rust}\n-enum OptionalColor {\n-    Color(i32, i32, i32),\n-    Missing,\n-}\n-```\n-\n-And you can also have something like this:\n-\n-```{rust}\n-enum StringResult {\n-    StringOK(String),\n-    ErrorReason(String),\n+fn cmp(a: i32, b: i32) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n }\n-```\n-Where a `StringResult` is either a `StringResult::StringOK`, with the result of\n-a computation, or a `StringResult::ErrorReason` with a `String` explaining\n-what caused the computation to fail. These kinds of `enum`s are actually very\n-useful and are even part of the standard library.\n \n-Here is an example of using our `StringResult`:\n+fn main() {\n+    let x = 5;\n+    let y = 10;\n \n-```rust\n-enum StringResult {\n-    StringOK(String),\n-    ErrorReason(String),\n-}\n+    let ordering = cmp(x, y); // ordering: Ordering\n \n-fn respond(greeting: &str) -> StringResult {\n-    if greeting == \"Hello\" {\n-        StringResult::StringOK(\"Good morning!\".to_string())\n-    } else {\n-        StringResult::ErrorReason(\"I didn't understand you!\".to_string())\n-    }\n+    if ordering == Less { println!(\"less\"); }\n+    else if ordering == Greater { println!(\"greater\"); }\n+    else if ordering == Equal { println!(\"equal\"); }\n }\n ```\n \n-That's a lot of typing! We can use the `use` keyword to make it shorter:\n+Importing variants is convenient and compact, but can also cause name conflicts,\n+so do this with caution. It's considered good style to rarely import variants\n+for this reason.\n \n-```rust\n-use StringResult::StringOK;\n-use StringResult::ErrorReason;\n+As you can see, `enum`s are quite a powerful tool for data representation, and are\n+even more useful when they're [generic][generics] across types. Before we\n+get to generics, though, let's talk about how to use them with pattern matching, a\n+tool that will let us deconstruct this sum type (the type theory term for enums)\n+in a very elegant way and avoid all these messy `if`/`else`s.\n \n-enum StringResult {\n-    StringOK(String),\n-    ErrorReason(String),\n-}\n-\n-# fn main() {}\n-\n-fn respond(greeting: &str) -> StringResult {\n-    if greeting == \"Hello\" {\n-        StringOK(\"Good morning!\".to_string())\n-    } else {\n-        ErrorReason(\"I didn't understand you!\".to_string())\n-    }\n-}\n-```\n \n-`use` declarations must come before anything else, which looks a little strange in this example,\n-since we `use` the variants before we define them. Anyway, in the body of `respond`, we can just\n-say `StringOK` now, rather than the full `StringResult::StringOK`. Importing variants can be\n-convenient, but can also cause name conflicts, so do this with caution. It's considered good style\n-to rarely import variants for this reason.\n-\n-As you can see, `enum`s with values are quite a powerful tool for data representation,\n-and can be even more useful when they're generic across types. Before we get to generics,\n-though, let's talk about how to use them with pattern matching, a tool that will\n-let us deconstruct this sum type (the type theory term for enums) in a very elegant\n-way and avoid all these messy `if`/`else`s.\n+[match]: ./match.html\n+[game]: ./guessing-game.html#comparing-guesses\n+[generics]: ./generics.html"}]}