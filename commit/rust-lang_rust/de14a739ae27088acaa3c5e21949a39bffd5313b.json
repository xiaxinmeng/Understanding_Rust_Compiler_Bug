{"sha": "de14a739ae27088acaa3c5e21949a39bffd5313b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMTRhNzM5YWUyNzA4OGFjYWEzYzVlMjE5NDlhMzliZmZkNTMxM2I=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-29T14:05:59Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-29T14:55:20Z"}, "message": "regex: remove the use of ~[] & some unnecessary ~'s.\n\nThe AST doesn't need ~s everywhere, so we can save allocations this way\n& the enum isn't particularly large (~4 words) nor are regexes\nlong (normally), so the space saved in the `Cat` vector is unlikely to\nbe very much.", "tree": {"sha": "3e72491c501790b6569cb96c7e2f903e80fe2425", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e72491c501790b6569cb96c7e2f903e80fe2425"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de14a739ae27088acaa3c5e21949a39bffd5313b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de14a739ae27088acaa3c5e21949a39bffd5313b", "html_url": "https://github.com/rust-lang/rust/commit/de14a739ae27088acaa3c5e21949a39bffd5313b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de14a739ae27088acaa3c5e21949a39bffd5313b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a19a82d119ca51ed872ed207bed396cdf4a3283", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a19a82d119ca51ed872ed207bed396cdf4a3283", "html_url": "https://github.com/rust-lang/rust/commit/7a19a82d119ca51ed872ed207bed396cdf4a3283"}], "stats": {"total": 179, "additions": 89, "deletions": 90}, "files": [{"sha": "e5166c6c17cb469955347a4ab04374b8bb462b8a", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=de14a739ae27088acaa3c5e21949a39bffd5313b", "patch": "@@ -13,7 +13,6 @@\n #![allow(visible_private_types)]\n \n use std::cmp;\n-use std::iter;\n use parse;\n use parse::{\n     Flags, FLAG_EMPTY,\n@@ -89,7 +88,7 @@ pub struct Program {\n \n impl Program {\n     /// Compiles a Regex given its AST.\n-    pub fn new(ast: ~parse::Ast) -> (Program, ~[Option<~str>]) {\n+    pub fn new(ast: parse::Ast) -> (Program, Vec<Option<~str>>) {\n         let mut c = Compiler {\n             insts: Vec::with_capacity(100),\n             names: Vec::with_capacity(10),\n@@ -104,16 +103,16 @@ impl Program {\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n         let mut pre = StrBuf::with_capacity(5);\n-        for i in iter::range(1, c.insts.len()) {\n-            match *c.insts.get(i) {\n+        for inst in c.insts.slice_from(1).iter() {\n+            match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push_char(c),\n                 _ => break\n             }\n         }\n \n-        let names = c.names.as_slice().into_owned();\n+        let Compiler { insts, names } = c;\n         let prog = Program {\n-            insts: c.insts,\n+            insts: insts,\n             prefix: pre.into_owned(),\n         };\n         (prog, names)\n@@ -144,48 +143,48 @@ struct Compiler<'r> {\n // The only tricky thing here is patching jump/split instructions to point to\n // the right instruction.\n impl<'r> Compiler<'r> {\n-    fn compile(&mut self, ast: ~parse::Ast) {\n+    fn compile(&mut self, ast: parse::Ast) {\n         match ast {\n-            ~Nothing => {},\n-            ~Literal(c, flags) => self.push(OneChar(c, flags)),\n-            ~Dot(nl) => self.push(Any(nl)),\n-            ~Class(ranges, flags) =>\n+            Nothing => {},\n+            Literal(c, flags) => self.push(OneChar(c, flags)),\n+            Dot(nl) => self.push(Any(nl)),\n+            Class(ranges, flags) =>\n                 self.push(CharClass(ranges, flags)),\n-            ~Begin(flags) => self.push(EmptyBegin(flags)),\n-            ~End(flags) => self.push(EmptyEnd(flags)),\n-            ~WordBoundary(flags) => self.push(EmptyWordBoundary(flags)),\n-            ~Capture(cap, name, x) => {\n+            Begin(flags) => self.push(EmptyBegin(flags)),\n+            End(flags) => self.push(EmptyEnd(flags)),\n+            WordBoundary(flags) => self.push(EmptyWordBoundary(flags)),\n+            Capture(cap, name, x) => {\n                 let len = self.names.len();\n                 if cap >= len {\n                     self.names.grow(10 + cap - len, &None)\n                 }\n                 *self.names.get_mut(cap) = name;\n \n                 self.push(Save(2 * cap));\n-                self.compile(x);\n+                self.compile(*x);\n                 self.push(Save(2 * cap + 1));\n             }\n-            ~Cat(xs) => {\n+            Cat(xs) => {\n                 for x in xs.move_iter() {\n                     self.compile(x)\n                 }\n             }\n-            ~Alt(x, y) => {\n+            Alt(x, y) => {\n                 let split = self.empty_split(); // push: split 0, 0\n                 let j1 = self.insts.len();\n-                self.compile(x);                // push: insts for x\n+                self.compile(*x);                // push: insts for x\n                 let jmp = self.empty_jump();    // push: jmp 0\n                 let j2 = self.insts.len();\n-                self.compile(y);                // push: insts for y\n+                self.compile(*y);                // push: insts for y\n                 let j3 = self.insts.len();\n \n                 self.set_split(split, j1, j2);  // split 0, 0 -> split j1, j2\n                 self.set_jump(jmp, j3);         // jmp 0      -> jmp j3\n             }\n-            ~Rep(x, ZeroOne, g) => {\n+            Rep(x, ZeroOne, g) => {\n                 let split = self.empty_split();\n                 let j1 = self.insts.len();\n-                self.compile(x);\n+                self.compile(*x);\n                 let j2 = self.insts.len();\n \n                 if g.is_greedy() {\n@@ -194,11 +193,11 @@ impl<'r> Compiler<'r> {\n                     self.set_split(split, j2, j1);\n                 }\n             }\n-            ~Rep(x, ZeroMore, g) => {\n+            Rep(x, ZeroMore, g) => {\n                 let j1 = self.insts.len();\n                 let split = self.empty_split();\n                 let j2 = self.insts.len();\n-                self.compile(x);\n+                self.compile(*x);\n                 let jmp = self.empty_jump();\n                 let j3 = self.insts.len();\n \n@@ -209,9 +208,9 @@ impl<'r> Compiler<'r> {\n                     self.set_split(split, j3, j2);\n                 }\n             }\n-            ~Rep(x, OneMore, g) => {\n+            Rep(x, OneMore, g) => {\n                 let j1 = self.insts.len();\n-                self.compile(x);\n+                self.compile(*x);\n                 let split = self.empty_split();\n                 let j2 = self.insts.len();\n "}, {"sha": "b94271622d7e9014d95c1020037f26a2e8286a0f", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=de14a739ae27088acaa3c5e21949a39bffd5313b", "patch": "@@ -362,7 +362,7 @@\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n \n #![feature(macro_rules, phase)]\n-#![deny(missing_doc)]\n+#![deny(missing_doc, deprecated_owned_vector)]\n \n extern crate collections;\n #[cfg(test)]"}, {"sha": "094da4ae269b50239053628315ca3cb77294f4e9", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=de14a739ae27088acaa3c5e21949a39bffd5313b", "patch": "@@ -62,7 +62,7 @@ pub enum Ast {\n     Capture(uint, Option<~str>, ~Ast),\n     // Represent concatenation as a flat vector to avoid blowing the\n     // stack in the compiler.\n-    Cat(Vec<~Ast>),\n+    Cat(Vec<Ast>),\n     Alt(~Ast, ~Ast),\n     Rep(~Ast, Repeater, Greed),\n }\n@@ -103,7 +103,7 @@ impl Greed {\n /// state.\n #[deriving(Show)]\n enum BuildAst {\n-    Ast(~Ast),\n+    Ast(Ast),\n     Paren(Flags, uint, ~str), // '('\n     Bar, // '|'\n }\n@@ -152,7 +152,7 @@ impl BuildAst {\n         }\n     }\n \n-    fn unwrap(self) -> Result<~Ast, Error> {\n+    fn unwrap(self) -> Result<Ast, Error> {\n         match self {\n             Ast(x) => Ok(x),\n             _ => fail!(\"Tried to unwrap non-AST item: {}\", self),\n@@ -188,7 +188,7 @@ struct Parser<'a> {\n     names: Vec<~str>,\n }\n \n-pub fn parse(s: &str) -> Result<~Ast, Error> {\n+pub fn parse(s: &str) -> Result<Ast, Error> {\n     Parser {\n         chars: s.chars().collect(),\n         chari: 0,\n@@ -200,7 +200,7 @@ pub fn parse(s: &str) -> Result<~Ast, Error> {\n }\n \n impl<'a> Parser<'a> {\n-    fn parse(&mut self) -> Result<~Ast, Error> {\n+    fn parse(&mut self) -> Result<Ast, Error> {\n         loop {\n             let c = self.cur();\n             match c {\n@@ -243,7 +243,7 @@ impl<'a> Parser<'a> {\n                     // alternate and make it a capture.\n                     if cap.is_some() {\n                         let ast = try!(self.pop_ast());\n-                        self.push(~Capture(cap.unwrap(), cap_name, ast));\n+                        self.push(Capture(cap.unwrap(), cap_name, ~ast));\n                     }\n                 }\n                 '|' => {\n@@ -294,14 +294,14 @@ impl<'a> Parser<'a> {\n         self.chari < self.chars.len()\n     }\n \n-    fn pop_ast(&mut self) -> Result<~Ast, Error> {\n+    fn pop_ast(&mut self) -> Result<Ast, Error> {\n         match self.stack.pop().unwrap().unwrap() {\n             Err(e) => Err(e),\n             Ok(ast) => Ok(ast),\n         }\n     }\n \n-    fn push(&mut self, ast: ~Ast) {\n+    fn push(&mut self, ast: Ast) {\n         self.stack.push(Ast(ast))\n     }\n \n@@ -323,29 +323,29 @@ impl<'a> Parser<'a> {\n         }\n         let ast = try!(self.pop_ast());\n         match ast {\n-            ~Begin(_) | ~End(_) | ~WordBoundary(_) =>\n+            Begin(_) | End(_) | WordBoundary(_) =>\n                 return self.err(\n                     \"Repeat arguments cannot be empty width assertions.\"),\n             _ => {}\n         }\n         let greed = try!(self.get_next_greedy());\n-        self.push(~Rep(ast, rep, greed));\n+        self.push(Rep(~ast, rep, greed));\n         Ok(())\n     }\n \n     fn push_literal(&mut self, c: char) -> Result<(), Error> {\n         match c {\n             '.' => {\n-                self.push(~Dot(self.flags))\n+                self.push(Dot(self.flags))\n             }\n             '^' => {\n-                self.push(~Begin(self.flags))\n+                self.push(Begin(self.flags))\n             }\n             '$' => {\n-                self.push(~End(self.flags))\n+                self.push(End(self.flags))\n             }\n             _ => {\n-                self.push(~Literal(c, self.flags))\n+                self.push(Literal(c, self.flags))\n             }\n         }\n         Ok(())\n@@ -362,7 +362,7 @@ impl<'a> Parser<'a> {\n                 FLAG_EMPTY\n             };\n         let mut ranges: Vec<(char, char)> = vec!();\n-        let mut alts: Vec<~Ast> = vec!();\n+        let mut alts: Vec<Ast> = vec!();\n \n         if self.peek_is(1, ']') {\n             try!(self.expect(']'))\n@@ -378,8 +378,8 @@ impl<'a> Parser<'a> {\n             match c {\n                 '[' =>\n                     match self.try_parse_ascii() {\n-                        Some(~Class(asciis, flags)) => {\n-                            alts.push(~Class(asciis, flags ^ negated));\n+                        Some(Class(asciis, flags)) => {\n+                            alts.push(Class(asciis, flags ^ negated));\n                             continue\n                         }\n                         Some(ast) =>\n@@ -389,12 +389,12 @@ impl<'a> Parser<'a> {\n                     },\n                 '\\\\' => {\n                     match try!(self.parse_escape()) {\n-                        ~Class(asciis, flags) => {\n-                            alts.push(~Class(asciis, flags ^ negated));\n+                        Class(asciis, flags) => {\n+                            alts.push(Class(asciis, flags ^ negated));\n                             continue\n                         }\n-                        ~Literal(c2, _) => c = c2, // process below\n-                        ~Begin(_) | ~End(_) | ~WordBoundary(_) =>\n+                        Literal(c2, _) => c = c2, // process below\n+                        Begin(_) | End(_) | WordBoundary(_) =>\n                             return self.err(\n                                 \"\\\\A, \\\\z, \\\\b and \\\\B are not valid escape \\\n                                  sequences inside a character class.\"),\n@@ -407,15 +407,15 @@ impl<'a> Parser<'a> {\n                 ']' => {\n                     if ranges.len() > 0 {\n                         let flags = negated | (self.flags & FLAG_NOCASE);\n-                        let mut ast = ~Class(combine_ranges(ranges), flags);\n+                        let mut ast = Class(combine_ranges(ranges), flags);\n                         for alt in alts.move_iter() {\n-                            ast = ~Alt(alt, ast)\n+                            ast = Alt(~alt, ~ast)\n                         }\n                         self.push(ast);\n                     } else if alts.len() > 0 {\n                         let mut ast = alts.pop().unwrap();\n                         for alt in alts.move_iter() {\n-                            ast = ~Alt(alt, ast)\n+                            ast = Alt(~alt, ~ast)\n                         }\n                         self.push(ast);\n                     }\n@@ -444,7 +444,7 @@ impl<'a> Parser<'a> {\n     // and moves the parser to the final ']' character.\n     // If unsuccessful, no state is changed and None is returned.\n     // Assumes that '[' is the current character.\n-    fn try_parse_ascii(&mut self) -> Option<~Ast> {\n+    fn try_parse_ascii(&mut self) -> Option<Ast> {\n         if !self.peek_is(1, ':') {\n             return None\n         }\n@@ -473,7 +473,7 @@ impl<'a> Parser<'a> {\n             Some(ranges) => {\n                 self.chari = closer;\n                 let flags = negated | (self.flags & FLAG_NOCASE);\n-                Some(~Class(combine_ranges(ranges), flags))\n+                Some(Class(combine_ranges(ranges), flags))\n             }\n         }\n     }\n@@ -546,7 +546,7 @@ impl<'a> Parser<'a> {\n             for _ in iter::range(0, min) {\n                 self.push(ast.clone())\n             }\n-            self.push(~Rep(ast, ZeroMore, greed));\n+            self.push(Rep(~ast, ZeroMore, greed));\n         } else {\n             // Require N copies of what's on the stack and then repeat it\n             // up to M times optionally.\n@@ -556,47 +556,47 @@ impl<'a> Parser<'a> {\n             }\n             if max.is_some() {\n                 for _ in iter::range(min, max.unwrap()) {\n-                    self.push(~Rep(ast.clone(), ZeroOne, greed))\n+                    self.push(Rep(~ast.clone(), ZeroOne, greed))\n                 }\n             }\n             // It's possible that we popped something off the stack but\n             // never put anything back on it. To keep things simple, add\n             // a no-op expression.\n             if min == 0 && (max.is_none() || max == Some(0)) {\n-                self.push(~Nothing)\n+                self.push(Nothing)\n             }\n         }\n         Ok(())\n     }\n \n     // Parses all escape sequences.\n     // Assumes that '\\' is the current character.\n-    fn parse_escape(&mut self) -> Result<~Ast, Error> {\n+    fn parse_escape(&mut self) -> Result<Ast, Error> {\n         try!(self.noteof(\"an escape sequence following a '\\\\'\"))\n \n         let c = self.cur();\n         if is_punct(c) {\n-            return Ok(~Literal(c, FLAG_EMPTY))\n+            return Ok(Literal(c, FLAG_EMPTY))\n         }\n         match c {\n-            'a' => Ok(~Literal('\\x07', FLAG_EMPTY)),\n-            'f' => Ok(~Literal('\\x0C', FLAG_EMPTY)),\n-            't' => Ok(~Literal('\\t', FLAG_EMPTY)),\n-            'n' => Ok(~Literal('\\n', FLAG_EMPTY)),\n-            'r' => Ok(~Literal('\\r', FLAG_EMPTY)),\n-            'v' => Ok(~Literal('\\x0B', FLAG_EMPTY)),\n-            'A' => Ok(~Begin(FLAG_EMPTY)),\n-            'z' => Ok(~End(FLAG_EMPTY)),\n-            'b' => Ok(~WordBoundary(FLAG_EMPTY)),\n-            'B' => Ok(~WordBoundary(FLAG_NEGATED)),\n+            'a' => Ok(Literal('\\x07', FLAG_EMPTY)),\n+            'f' => Ok(Literal('\\x0C', FLAG_EMPTY)),\n+            't' => Ok(Literal('\\t', FLAG_EMPTY)),\n+            'n' => Ok(Literal('\\n', FLAG_EMPTY)),\n+            'r' => Ok(Literal('\\r', FLAG_EMPTY)),\n+            'v' => Ok(Literal('\\x0B', FLAG_EMPTY)),\n+            'A' => Ok(Begin(FLAG_EMPTY)),\n+            'z' => Ok(End(FLAG_EMPTY)),\n+            'b' => Ok(WordBoundary(FLAG_EMPTY)),\n+            'B' => Ok(WordBoundary(FLAG_NEGATED)),\n             '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7' => Ok(try!(self.parse_octal())),\n             'x' => Ok(try!(self.parse_hex())),\n             'p' | 'P' => Ok(try!(self.parse_unicode_name())),\n             'd' | 'D' | 's' | 'S' | 'w' | 'W' => {\n                 let ranges = perl_unicode_class(c);\n                 let mut flags = self.flags & FLAG_NOCASE;\n                 if c.is_uppercase() { flags |= FLAG_NEGATED }\n-                Ok(~Class(ranges, flags))\n+                Ok(Class(ranges, flags))\n             }\n             _ => self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c)),\n         }\n@@ -607,7 +607,7 @@ impl<'a> Parser<'a> {\n     // name is the unicode class name.\n     // Assumes that \\p or \\P has been read (and 'p' or 'P' is the current\n     // character).\n-    fn parse_unicode_name(&mut self) -> Result<~Ast, Error> {\n+    fn parse_unicode_name(&mut self) -> Result<Ast, Error> {\n         let negated = if self.cur() == 'P' { FLAG_NEGATED } else { FLAG_EMPTY };\n         let mut name: ~str;\n         if self.peek_is(1, '{') {\n@@ -635,14 +635,14 @@ impl<'a> Parser<'a> {\n             None => return self.err(format!(\n                 \"Could not find Unicode class '{}'\", name)),\n             Some(ranges) => {\n-                Ok(~Class(ranges, negated | (self.flags & FLAG_NOCASE)))\n+                Ok(Class(ranges, negated | (self.flags & FLAG_NOCASE)))\n             }\n         }\n     }\n \n     // Parses an octal number, up to 3 digits.\n     // Assumes that \\n has been read, where n is the first digit.\n-    fn parse_octal(&mut self) -> Result<~Ast, Error> {\n+    fn parse_octal(&mut self) -> Result<Ast, Error> {\n         let start = self.chari;\n         let mut end = start + 1;\n         let (d2, d3) = (self.peek(1), self.peek(2));\n@@ -656,15 +656,15 @@ impl<'a> Parser<'a> {\n         }\n         let s = self.slice(start, end);\n         match num::from_str_radix::<u32>(s, 8) {\n-            Some(n) => Ok(~Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n+            Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => self.err(format!(\n                 \"Could not parse '{}' as octal number.\", s)),\n         }\n     }\n \n     // Parse a hex number. Either exactly two digits or anything in {}.\n     // Assumes that \\x has been read.\n-    fn parse_hex(&mut self) -> Result<~Ast, Error> {\n+    fn parse_hex(&mut self) -> Result<Ast, Error> {\n         if !self.peek_is(1, '{') {\n             try!(self.expect('{'))\n             return self.parse_hex_two()\n@@ -684,17 +684,17 @@ impl<'a> Parser<'a> {\n     // Assumes that \\xn has been read, where n is the first digit and is the\n     // current character.\n     // After return, parser will point at the second digit.\n-    fn parse_hex_two(&mut self) -> Result<~Ast, Error> {\n+    fn parse_hex_two(&mut self) -> Result<Ast, Error> {\n         let (start, end) = (self.chari, self.chari + 2);\n         let bad = self.slice(start - 2, self.chars.len());\n         try!(self.noteof(format!(\"Invalid hex escape sequence '{}'\", bad)))\n         self.parse_hex_digits(self.slice(start, end))\n     }\n \n     // Parses `s` as a hexadecimal number.\n-    fn parse_hex_digits(&self, s: &str) -> Result<~Ast, Error> {\n+    fn parse_hex_digits(&self, s: &str) -> Result<Ast, Error> {\n         match num::from_str_radix::<u32>(s, 16) {\n-            Some(n) => Ok(~Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n+            Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => self.err(format!(\n                 \"Could not parse '{}' as hex number.\", s)),\n         }\n@@ -840,16 +840,16 @@ impl<'a> Parser<'a> {\n         // thrown away). But be careful with overflow---we can't count on the\n         // open paren to be there.\n         if from > 0 { from = from - 1}\n-        let ast = try!(self.build_from(from, Alt));\n+        let ast = try!(self.build_from(from, |l,r| Alt(~l, ~r)));\n         self.push(ast);\n         Ok(())\n     }\n \n     // build_from combines all AST elements starting at 'from' in the\n     // parser's stack using 'mk' to combine them. If any such element is not an\n     // AST then it is popped off the stack and ignored.\n-    fn build_from(&mut self, from: uint, mk: |~Ast, ~Ast| -> Ast)\n-                 -> Result<~Ast, Error> {\n+    fn build_from(&mut self, from: uint, mk: |Ast, Ast| -> Ast)\n+                 -> Result<Ast, Error> {\n         if from >= self.stack.len() {\n             return self.err(\"Empty group or alternate not allowed.\")\n         }\n@@ -859,7 +859,7 @@ impl<'a> Parser<'a> {\n         while i > from {\n             i = i - 1;\n             match self.stack.pop().unwrap() {\n-                Ast(x) => combined = ~mk(x, combined),\n+                Ast(x) => combined = mk(x, combined),\n                 _ => {},\n             }\n         }\n@@ -961,11 +961,11 @@ fn perl_unicode_class(which: char) -> Vec<(char, char)> {\n \n // Returns a concatenation of two expressions. This also guarantees that a\n // `Cat` expression will never be a direct child of another `Cat` expression.\n-fn concat_flatten(x: ~Ast, y: ~Ast) -> Ast {\n+fn concat_flatten(x: Ast, y: Ast) -> Ast {\n     match (x, y) {\n-        (~Cat(mut xs), ~Cat(ys)) => { xs.push_all_move(ys); Cat(xs) }\n-        (~Cat(mut xs), ast) => { xs.push(ast); Cat(xs) }\n-        (ast, ~Cat(mut xs)) => { xs.unshift(ast); Cat(xs) }\n+        (Cat(mut xs), Cat(ys)) => { xs.push_all_move(ys); Cat(xs) }\n+        (Cat(mut xs), ast) => { xs.push(ast); Cat(xs) }\n+        (ast, Cat(mut xs)) => { xs.unshift(ast); Cat(xs) }\n         (ast1, ast2) => Cat(vec!(ast1, ast2)),\n     }\n }"}, {"sha": "6569f047abae868d952e8e31040df6f5667b5e25", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=de14a739ae27088acaa3c5e21949a39bffd5313b", "patch": "@@ -109,7 +109,7 @@ pub struct Regex {\n     #[doc(hidden)]\n     pub original: ~str,\n     #[doc(hidden)]\n-    pub names: ~[Option<~str>],\n+    pub names: Vec<Option<~str>>,\n     #[doc(hidden)]\n     pub p: MaybeNative,\n }"}, {"sha": "17c66bc670a92cd55b07ae0619597bd7de9bdbce", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=de14a739ae27088acaa3c5e21949a39bffd5313b", "patch": "@@ -150,6 +150,7 @@ fn easy1() -> Regex { regex!(\"A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$\")\n fn medium() -> Regex { regex!(\"[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n fn hard() -> Regex { regex!(\"[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n \n+#[allow(deprecated_owned_vector)]\n fn gen_text(n: uint) -> ~str {\n     let mut rng = task_rng();\n     let mut bytes = rng.gen_ascii_str(n).into_bytes();\n@@ -176,4 +177,3 @@ throughput!(medium_32K,medium(), 32<<10)\n throughput!(hard_32, hard(), 32)\n throughput!(hard_1K, hard(), 1<<10)\n throughput!(hard_32K,hard(), 32<<10)\n-"}, {"sha": "5445c5f6761738b43d1844e214c191f6219985ad", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de14a739ae27088acaa3c5e21949a39bffd5313b/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=de14a739ae27088acaa3c5e21949a39bffd5313b", "patch": "@@ -102,7 +102,7 @@ struct NfaGen<'a> {\n     cx: &'a ExtCtxt<'a>,\n     sp: codemap::Span,\n     prog: Program,\n-    names: ~[Option<~str>],\n+    names: Vec<Option<~str>>,\n     original: ~str,\n }\n \n@@ -112,7 +112,7 @@ impl<'a> NfaGen<'a> {\n         // expression returned.\n         let num_cap_locs = 2 * self.prog.num_captures();\n         let num_insts = self.prog.insts.len();\n-        let cap_names = self.vec_expr(self.names,\n+        let cap_names = self.vec_expr(self.names.as_slice(),\n             |cx, name| match name {\n                 &Some(ref name) => {\n                     let name = name.as_slice();\n@@ -309,7 +309,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n ::regex::Regex {\n     original: ~$regex,\n-    names: ~$cap_names,\n+    names: vec!$cap_names,\n     p: ::regex::native::Native(exec),\n }\n         })"}]}