{"sha": "840f3f64dc399021a35e4248e767e174f4852dc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MGYzZjY0ZGMzOTkwMjFhMzVlNDI0OGU3NjdlMTc0ZjQ4NTJkYzQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-14T23:45:39Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-14T23:45:39Z"}, "message": "typeck/expr.rs: extract out check_expr_unary.", "tree": {"sha": "c4810179f4e8939ba26200a25805c0aba68c71a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4810179f4e8939ba26200a25805c0aba68c71a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/840f3f64dc399021a35e4248e767e174f4852dc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/840f3f64dc399021a35e4248e767e174f4852dc4", "html_url": "https://github.com/rust-lang/rust/commit/840f3f64dc399021a35e4248e767e174f4852dc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/840f3f64dc399021a35e4248e767e174f4852dc4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7227a386a55a2239c46c7eb655f240934e25dd26", "url": "https://api.github.com/repos/rust-lang/rust/commits/7227a386a55a2239c46c7eb655f240934e25dd26", "html_url": "https://github.com/rust-lang/rust/commit/7227a386a55a2239c46c7eb655f240934e25dd26"}], "stats": {"total": 170, "additions": 88, "deletions": 82}, "files": [{"sha": "5244edebc387cbcca9d06603ab2214d09be9b1ba", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 88, "deletions": 82, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/840f3f64dc399021a35e4248e767e174f4852dc4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/840f3f64dc399021a35e4248e767e174f4852dc4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=840f3f64dc399021a35e4248e767e174f4852dc4", "patch": "@@ -62,88 +62,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_binop_assign(expr, op, lhs, rhs)\n             }\n             ExprKind::Unary(unop, ref oprnd) => {\n-                let expected_inner = match unop {\n-                    hir::UnNot | hir::UnNeg => {\n-                        expected\n-                    }\n-                    hir::UnDeref => {\n-                        NoExpectation\n-                    }\n-                };\n-                let needs = match unop {\n-                    hir::UnDeref => needs,\n-                    _ => Needs::None\n-                };\n-                let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n-                                                                             expected_inner,\n-                                                                             needs);\n-\n-                if !oprnd_t.references_error() {\n-                    oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n-                    match unop {\n-                        hir::UnDeref => {\n-                            if let Some(mt) = oprnd_t.builtin_deref(true) {\n-                                oprnd_t = mt.ty;\n-                            } else if let Some(ok) = self.try_overloaded_deref(\n-                                    expr.span, oprnd_t, needs) {\n-                                let method = self.register_infer_ok_obligations(ok);\n-                                if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n-                                    let mutbl = match mutbl {\n-                                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                                        hir::MutMutable => AutoBorrowMutability::Mutable {\n-                                            // (It shouldn't actually matter for unary ops whether\n-                                            // we enable two-phase borrows or not, since a unary\n-                                            // op has no additional operands.)\n-                                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                                        }\n-                                    };\n-                                    self.apply_adjustments(oprnd, vec![Adjustment {\n-                                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                        target: method.sig.inputs()[0]\n-                                    }]);\n-                                }\n-                                oprnd_t = self.make_overloaded_place_return_type(method).ty;\n-                                self.write_method_call(expr.hir_id, method);\n-                            } else {\n-                                let mut err = type_error_struct!(\n-                                    tcx.sess,\n-                                    expr.span,\n-                                    oprnd_t,\n-                                    E0614,\n-                                    \"type `{}` cannot be dereferenced\",\n-                                    oprnd_t,\n-                                );\n-                                let sp = tcx.sess.source_map().start_point(expr.span);\n-                                if let Some(sp) = tcx.sess.parse_sess.ambiguous_block_expr_parse\n-                                    .borrow().get(&sp)\n-                                {\n-                                    tcx.sess.parse_sess.expr_parentheses_needed(\n-                                        &mut err,\n-                                        *sp,\n-                                        None,\n-                                    );\n-                                }\n-                                err.emit();\n-                                oprnd_t = tcx.types.err;\n-                            }\n-                        }\n-                        hir::UnNot => {\n-                            let result = self.check_user_unop(expr, oprnd_t, unop);\n-                            // If it's builtin, we can reuse the type, this helps inference.\n-                            if !(oprnd_t.is_integral() || oprnd_t.sty == ty::Bool) {\n-                                oprnd_t = result;\n-                            }\n-                        }\n-                        hir::UnNeg => {\n-                            let result = self.check_user_unop(expr, oprnd_t, unop);\n-                            // If it's builtin, we can reuse the type, this helps inference.\n-                            if !oprnd_t.is_numeric() {\n-                                oprnd_t = result;\n-                            }\n-                        }\n-                    }\n-                }\n-                oprnd_t\n+                self.check_expr_unary(unop, oprnd, expected, needs, expr)\n             }\n             ExprKind::AddrOf(mutbl, ref oprnd) => {\n                 let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n@@ -706,4 +625,91 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let referent_ty = self.check_expr_with_expectation(expr, expected_inner);\n         self.tcx.mk_box(referent_ty)\n     }\n+\n+    fn check_expr_unary(\n+        &self,\n+        unop: hir::UnOp,\n+        oprnd: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        needs: Needs,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let expected_inner = match unop {\n+            hir::UnNot | hir::UnNeg => expected,\n+            hir::UnDeref => NoExpectation,\n+        };\n+        let needs = match unop {\n+            hir::UnDeref => needs,\n+            _ => Needs::None\n+        };\n+        let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd, expected_inner, needs);\n+\n+        if !oprnd_t.references_error() {\n+            oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n+            match unop {\n+                hir::UnDeref => {\n+                    if let Some(mt) = oprnd_t.builtin_deref(true) {\n+                        oprnd_t = mt.ty;\n+                    } else if let Some(ok) = self.try_overloaded_deref(\n+                            expr.span, oprnd_t, needs) {\n+                        let method = self.register_infer_ok_obligations(ok);\n+                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                            let mutbl = match mutbl {\n+                                hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                                hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                    // (It shouldn't actually matter for unary ops whether\n+                                    // we enable two-phase borrows or not, since a unary\n+                                    // op has no additional operands.)\n+                                    allow_two_phase_borrow: AllowTwoPhase::No,\n+                                }\n+                            };\n+                            self.apply_adjustments(oprnd, vec![Adjustment {\n+                                kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                                target: method.sig.inputs()[0]\n+                            }]);\n+                        }\n+                        oprnd_t = self.make_overloaded_place_return_type(method).ty;\n+                        self.write_method_call(expr.hir_id, method);\n+                    } else {\n+                        let mut err = type_error_struct!(\n+                            tcx.sess,\n+                            expr.span,\n+                            oprnd_t,\n+                            E0614,\n+                            \"type `{}` cannot be dereferenced\",\n+                            oprnd_t,\n+                        );\n+                        let sp = tcx.sess.source_map().start_point(expr.span);\n+                        if let Some(sp) = tcx.sess.parse_sess.ambiguous_block_expr_parse\n+                            .borrow().get(&sp)\n+                        {\n+                            tcx.sess.parse_sess.expr_parentheses_needed(\n+                                &mut err,\n+                                *sp,\n+                                None,\n+                            );\n+                        }\n+                        err.emit();\n+                        oprnd_t = tcx.types.err;\n+                    }\n+                }\n+                hir::UnNot => {\n+                    let result = self.check_user_unop(expr, oprnd_t, unop);\n+                    // If it's builtin, we can reuse the type, this helps inference.\n+                    if !(oprnd_t.is_integral() || oprnd_t.sty == ty::Bool) {\n+                        oprnd_t = result;\n+                    }\n+                }\n+                hir::UnNeg => {\n+                    let result = self.check_user_unop(expr, oprnd_t, unop);\n+                    // If it's builtin, we can reuse the type, this helps inference.\n+                    if !oprnd_t.is_numeric() {\n+                        oprnd_t = result;\n+                    }\n+                }\n+            }\n+        }\n+        oprnd_t\n+    }\n }"}]}