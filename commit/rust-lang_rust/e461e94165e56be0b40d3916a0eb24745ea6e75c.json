{"sha": "e461e94165e56be0b40d3916a0eb24745ea6e75c", "node_id": "C_kwDOAAsO6NoAKGU0NjFlOTQxNjVlNTZiZTBiNDBkMzkxNmEwZWIyNDc0NWVhNmU3NWM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-07T16:35:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-07T16:35:30Z"}, "message": "Rollup merge of #102475 - RalfJung:unsafe, r=dtolnay\n\nunsafe keyword: trait examples and unsafe_op_in_unsafe_fn update\n\nHaving a safe `fn` in an `unsafe trait` vs an `unsafe fn` in a safe `trait` are pretty different situations, but the distinction is subtle and can confuse even seasoned Rust developers. So let's have explicit examples of both. I also removed the existing `unsafe trait` example since it was rather strange.\n\nAlso the `unsafe_op_in_unsafe_fn` lint can help disentangle the two sides of `unsafe`, so update the docs to account for that.", "tree": {"sha": "1c3a8fff4e5b62e519346ccd2ce6c057b4cce8c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c3a8fff4e5b62e519346ccd2ce6c057b4cce8c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e461e94165e56be0b40d3916a0eb24745ea6e75c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjQFVSCRBK7hj4Ov3rIwAAqB8IAJkCBbysqajRcn2dX5n5zFKS\nkaaoMvDCpiMA3Sq3vyqSEjLqIj4ihCd1QxKtf+tAvXDw7fGAPsckZ+WdvCBXjZ/k\nviVpll1AuPRog4q5pOigMbw4UQQ863Hv2NAQlcRn0uRuH/RrSwIcM4iYx2pjqNca\n0WqwT9gZZ4Qw1tp3FG3zDZ2mMX3Gql1R+BvwN/Wo7MaoJ4WkVo4BgGgmlm1R706A\nP6Y53T+SOK9+PVJBxBO1iPrGn9B/lIhi6CM9edG/+60QBReCXj2oGm6HipcAPioo\nfn7gTc4liQm+sl/wyZB3haPntVe9OruSth8DMRuZSKK5cPd3ClEg9C1s3XIbxL8=\n=ftAi\n-----END PGP SIGNATURE-----\n", "payload": "tree 1c3a8fff4e5b62e519346ccd2ce6c057b4cce8c7\nparent 25926095749ddc92b8b457383f8e129d267457e4\nparent c30dcff97a43292b729f384f847febe777daf629\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1665160530 +0530\ncommitter GitHub <noreply@github.com> 1665160530 +0530\n\nRollup merge of #102475 - RalfJung:unsafe, r=dtolnay\n\nunsafe keyword: trait examples and unsafe_op_in_unsafe_fn update\n\nHaving a safe `fn` in an `unsafe trait` vs an `unsafe fn` in a safe `trait` are pretty different situations, but the distinction is subtle and can confuse even seasoned Rust developers. So let's have explicit examples of both. I also removed the existing `unsafe trait` example since it was rather strange.\n\nAlso the `unsafe_op_in_unsafe_fn` lint can help disentangle the two sides of `unsafe`, so update the docs to account for that.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e461e94165e56be0b40d3916a0eb24745ea6e75c", "html_url": "https://github.com/rust-lang/rust/commit/e461e94165e56be0b40d3916a0eb24745ea6e75c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e461e94165e56be0b40d3916a0eb24745ea6e75c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25926095749ddc92b8b457383f8e129d267457e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/25926095749ddc92b8b457383f8e129d267457e4", "html_url": "https://github.com/rust-lang/rust/commit/25926095749ddc92b8b457383f8e129d267457e4"}, {"sha": "c30dcff97a43292b729f384f847febe777daf629", "url": "https://api.github.com/repos/rust-lang/rust/commits/c30dcff97a43292b729f384f847febe777daf629", "html_url": "https://github.com/rust-lang/rust/commit/c30dcff97a43292b729f384f847febe777daf629"}], "stats": {"total": 151, "additions": 120, "deletions": 31}, "files": [{"sha": "e35145c4ade48dc6538aca96c46deb126edaea48", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 120, "deletions": 31, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/e461e94165e56be0b40d3916a0eb24745ea6e75c/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e461e94165e56be0b40d3916a0eb24745ea6e75c/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=e461e94165e56be0b40d3916a0eb24745ea6e75c", "patch": "@@ -1867,11 +1867,15 @@ mod type_keyword {}\n /// Code or interfaces whose [memory safety] cannot be verified by the type\n /// system.\n ///\n-/// The `unsafe` keyword has two uses: to declare the existence of contracts the\n-/// compiler can't check (`unsafe fn` and `unsafe trait`), and to declare that a\n-/// programmer has checked that these contracts have been upheld (`unsafe {}`\n-/// and `unsafe impl`, but also `unsafe fn` -- see below). They are not mutually\n-/// exclusive, as can be seen in `unsafe fn`.\n+/// The `unsafe` keyword has two uses:\n+/// - to declare the existence of contracts the compiler can't check (`unsafe fn` and `unsafe\n+/// trait`),\n+/// - and to declare that a programmer has checked that these contracts have been upheld (`unsafe\n+/// {}` and `unsafe impl`, but also `unsafe fn` -- see below).\n+///\n+/// They are not mutually exclusive, as can be seen in `unsafe fn`: the body of an `unsafe fn` is,\n+/// by default, treated like an unsafe block. The `unsafe_op_in_unsafe_fn` lint can be enabled to\n+/// change that.\n ///\n /// # Unsafe abilities\n ///\n@@ -1914,12 +1918,12 @@ mod type_keyword {}\n /// - `unsafe impl`: the contract necessary to implement the trait has been\n /// checked by the programmer and is guaranteed to be respected.\n ///\n-/// `unsafe fn` also acts like an `unsafe {}` block\n+/// By default, `unsafe fn` also acts like an `unsafe {}` block\n /// around the code inside the function. This means it is not just a signal to\n /// the caller, but also promises that the preconditions for the operations\n-/// inside the function are upheld. Mixing these two meanings can be confusing\n-/// and [proposal]s exist to use `unsafe {}` blocks inside such functions when\n-/// making `unsafe` operations.\n+/// inside the function are upheld. Mixing these two meanings can be confusing, so the\n+/// `unsafe_op_in_unsafe_fn` lint can be enabled to warn against that and require explicit unsafe\n+/// blocks even inside `unsafe fn`.\n ///\n /// See the [Rustnomicon] and the [Reference] for more information.\n ///\n@@ -1987,13 +1991,16 @@ mod type_keyword {}\n ///\n /// ```rust\n /// # #![allow(dead_code)]\n+/// #![deny(unsafe_op_in_unsafe_fn)]\n+///\n /// /// Dereference the given pointer.\n /// ///\n /// /// # Safety\n /// ///\n /// /// `ptr` must be aligned and must not be dangling.\n /// unsafe fn deref_unchecked(ptr: *const i32) -> i32 {\n-///     *ptr\n+///     // SAFETY: the caller is required to ensure that `ptr` is aligned and dereferenceable.\n+///     unsafe { *ptr }\n /// }\n ///\n /// let a = 3;\n@@ -2003,35 +2010,118 @@ mod type_keyword {}\n /// unsafe { assert_eq!(*b, deref_unchecked(b)); };\n /// ```\n ///\n-/// Traits marked as `unsafe` must be [`impl`]emented using `unsafe impl`. This\n-/// makes a guarantee to other `unsafe` code that the implementation satisfies\n-/// the trait's safety contract. The [Send] and [Sync] traits are examples of\n-/// this behaviour in the standard library.\n+/// ## `unsafe` and traits\n+///\n+/// The interactions of `unsafe` and traits can be surprising, so let us contrast the\n+/// two combinations of safe `fn` in `unsafe trait` and `unsafe fn` in safe trait using two\n+/// examples:\n+///\n+/// ```rust\n+/// /// # Safety\n+/// ///\n+/// /// `make_even` must return an even number.\n+/// unsafe trait MakeEven {\n+///     fn make_even(&self) -> i32;\n+/// }\n+///\n+/// // SAFETY: Our `make_even` always returns something even.\n+/// unsafe impl MakeEven for i32 {\n+///     fn make_even(&self) -> i32 {\n+///         self << 1\n+///     }\n+/// }\n+///\n+/// fn use_make_even(x: impl MakeEven) {\n+///     if x.make_even() % 2 == 1 {\n+///         // SAFETY: this can never happen, because all `MakeEven` implementations\n+///         // ensure that `make_even` returns something even.\n+///         unsafe { std::hint::unreachable_unchecked() };\n+///     }\n+/// }\n+/// ```\n+///\n+/// Note how the safety contract of the trait is upheld by the implementation, and is itself used to\n+/// uphold the safety contract of the unsafe function `unreachable_unchecked` called by\n+/// `use_make_even`. `make_even` itself is a safe function because its *callers* do not have to\n+/// worry about any contract, only the *implementation* of `MakeEven` is required to uphold a\n+/// certain contract. `use_make_even` is safe because it can use the promise made by `MakeEven`\n+/// implementations to uphold the safety contract of the `unsafe fn unreachable_unchecked` it calls.\n+///\n+/// It is also possible to have `unsafe fn` in a regular safe `trait`:\n ///\n /// ```rust\n-/// /// Implementors of this trait must guarantee an element is always\n-/// /// accessible with index 3.\n-/// unsafe trait ThreeIndexable<T> {\n-///     /// Returns a reference to the element with index 3 in `&self`.\n-///     fn three(&self) -> &T;\n+/// # #![feature(never_type)]\n+/// #![deny(unsafe_op_in_unsafe_fn)]\n+///\n+/// trait Indexable {\n+///     const LEN: usize;\n+///\n+///     /// # Safety\n+///     ///\n+///     /// The caller must ensure that `idx < LEN`.\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32;\n /// }\n ///\n-/// // The implementation of `ThreeIndexable` for `[T; 4]` is `unsafe`\n-/// // because the implementor must abide by a contract the compiler cannot\n-/// // check but as a programmer we know there will always be a valid element\n-/// // at index 3 to access.\n-/// unsafe impl<T> ThreeIndexable<T> for [T; 4] {\n-///     fn three(&self) -> &T {\n-///         // SAFETY: implementing the trait means there always is an element\n-///         // with index 3 accessible.\n-///         unsafe { self.get_unchecked(3) }\n+/// // The implementation for `i32` doesn't need to do any contract reasoning.\n+/// impl Indexable for i32 {\n+///     const LEN: usize = 1;\n+///\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///         debug_assert_eq!(idx, 0);\n+///         *self\n ///     }\n /// }\n ///\n-/// let a = [1, 2, 4, 8];\n-/// assert_eq!(a.three(), &8);\n+/// // The implementation for arrays exploits the function contract to\n+/// // make use of `get_unchecked` on slices and avoid a run-time check.\n+/// impl Indexable for [i32; 42] {\n+///     const LEN: usize = 42;\n+///\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///         // SAFETY: As per this trait's documentation, the caller ensures\n+///         // that `idx < 42`.\n+///         unsafe { *self.get_unchecked(idx) }\n+///     }\n+/// }\n+///\n+/// // The implementation for the never type declares a length of 0,\n+/// // which means `idx_unchecked` can never be called.\n+/// impl Indexable for ! {\n+///     const LEN: usize = 0;\n+///\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///         // SAFETY: As per this trait's documentation, the caller ensures\n+///         // that `idx < 0`, which is impossible, so this is dead code.\n+///         unsafe { std::hint::unreachable_unchecked() }\n+///     }\n+/// }\n+///\n+/// fn use_indexable<I: Indexable>(x: I, idx: usize) -> i32 {\n+///     if idx < I::LEN {\n+///         // SAFETY: We have checked that `idx < I::LEN`.\n+///         unsafe { x.idx_unchecked(idx) }\n+///     } else {\n+///         panic!(\"index out-of-bounds\")\n+///     }\n+/// }\n /// ```\n ///\n+/// This time, `use_indexable` is safe because it uses a run-time check to discharge the safety\n+/// contract of `idx_unchecked`. Implementing `Indexable` is safe because when writing\n+/// `idx_unchecked`, we don't have to worry: our *callers* need to discharge a proof obligation\n+/// (like `use_indexable` does), but the *implementation* of `get_unchecked` has no proof obligation\n+/// to contend with. Of course, the implementation of `Indexable` may choose to call other unsafe\n+/// operations, and then it needs an `unsafe` *block* to indicate it discharged the proof\n+/// obligations of its callees. (We enabled `unsafe_op_in_unsafe_fn`, so the body of `idx_unchecked`\n+/// is not implicitly an unsafe block.) For that purpose it can make use of the contract that all\n+/// its callers must uphold -- the fact that `idx < LEN`.\n+///\n+/// Formally speaking, an `unsafe fn` in a trait is a function with *preconditions* that go beyond\n+/// those encoded by the argument types (such as `idx < LEN`), whereas an `unsafe trait` can declare\n+/// that some of its functions have *postconditions* that go beyond those encoded in the return type\n+/// (such as returning an even integer). If a trait needs a function with both extra precondition\n+/// and extra postcondition, then it needs an `unsafe fn` in an `unsafe trait`.\n+///\n /// [`extern`]: keyword.extern.html\n /// [`trait`]: keyword.trait.html\n /// [`static`]: keyword.static.html\n@@ -2043,7 +2133,6 @@ mod type_keyword {}\n /// [nomicon-soundness]: ../nomicon/safe-unsafe-meaning.html\n /// [soundness]: https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library\n /// [Reference]: ../reference/unsafety.html\n-/// [proposal]: https://github.com/rust-lang/rfcs/pull/2585\n /// [discussion on Rust Internals]: https://internals.rust-lang.org/t/what-does-unsafe-mean/6696\n mod unsafe_keyword {}\n "}]}