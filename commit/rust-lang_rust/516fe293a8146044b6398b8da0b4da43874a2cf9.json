{"sha": "516fe293a8146044b6398b8da0b4da43874a2cf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNmZlMjkzYTgxNDYwNDRiNjM5OGI4ZGEwYjRkYTQzODc0YTJjZjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-19T16:53:31Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-19T16:53:31Z"}, "message": "More direct CargoWorkspace", "tree": {"sha": "1a3512d79dd2f6cce21ad5f03b487391a25545e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a3512d79dd2f6cce21ad5f03b487391a25545e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/516fe293a8146044b6398b8da0b4da43874a2cf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/516fe293a8146044b6398b8da0b4da43874a2cf9", "html_url": "https://github.com/rust-lang/rust/commit/516fe293a8146044b6398b8da0b4da43874a2cf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/516fe293a8146044b6398b8da0b4da43874a2cf9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d013a05fee5bcf1dfff7bc3a273dd064b61bab91", "url": "https://api.github.com/repos/rust-lang/rust/commits/d013a05fee5bcf1dfff7bc3a273dd064b61bab91", "html_url": "https://github.com/rust-lang/rust/commit/d013a05fee5bcf1dfff7bc3a273dd064b61bab91"}], "stats": {"total": 151, "additions": 64, "deletions": 87}, "files": [{"sha": "43dbd096a33f7e9487d04dd22a07b32b73ead093", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 41, "deletions": 64, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/516fe293a8146044b6398b8da0b4da43874a2cf9/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/516fe293a8146044b6398b8da0b4da43874a2cf9/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=516fe293a8146044b6398b8da0b4da43874a2cf9", "patch": "@@ -1,6 +1,9 @@\n //! FIXME: write short doc here\n \n-use std::path::{Path, PathBuf};\n+use std::{\n+    ops,\n+    path::{Path, PathBuf},\n+};\n \n use anyhow::{Context, Result};\n use cargo_metadata::{CargoOpt, Message, MetadataCommand, PackageId};\n@@ -24,6 +27,20 @@ pub struct CargoWorkspace {\n     workspace_root: PathBuf,\n }\n \n+impl ops::Index<Package> for CargoWorkspace {\n+    type Output = PackageData;\n+    fn index(&self, index: Package) -> &PackageData {\n+        &self.packages[index]\n+    }\n+}\n+\n+impl ops::Index<Target> for CargoWorkspace {\n+    type Output = TargetData;\n+    fn index(&self, index: Target) -> &TargetData {\n+        &self.targets[index]\n+    }\n+}\n+\n #[derive(Deserialize, Clone, Debug, PartialEq, Eq)]\n #[serde(rename_all = \"camelCase\", default)]\n pub struct CargoFeatures {\n@@ -61,15 +78,15 @@ pub struct Target(RawId);\n impl_arena_id!(Target);\n \n #[derive(Debug, Clone)]\n-struct PackageData {\n-    name: String,\n-    manifest: PathBuf,\n-    targets: Vec<Target>,\n-    is_member: bool,\n-    dependencies: Vec<PackageDependency>,\n-    edition: Edition,\n-    features: Vec<String>,\n-    out_dir: Option<PathBuf>,\n+pub struct PackageData {\n+    pub name: String,\n+    pub manifest: PathBuf,\n+    pub targets: Vec<Target>,\n+    pub is_member: bool,\n+    pub dependencies: Vec<PackageDependency>,\n+    pub edition: Edition,\n+    pub features: Vec<String>,\n+    pub out_dir: Option<PathBuf>,\n }\n \n #[derive(Debug, Clone)]\n@@ -79,12 +96,12 @@ pub struct PackageDependency {\n }\n \n #[derive(Debug, Clone)]\n-struct TargetData {\n-    pkg: Package,\n-    name: String,\n-    root: PathBuf,\n-    kind: TargetKind,\n-    is_proc_macro: bool,\n+pub struct TargetData {\n+    pub package: Package,\n+    pub name: String,\n+    pub root: PathBuf,\n+    pub kind: TargetKind,\n+    pub is_proc_macro: bool,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -115,52 +132,9 @@ impl TargetKind {\n     }\n }\n \n-impl Package {\n-    pub fn name(self, ws: &CargoWorkspace) -> &str {\n-        ws.packages[self].name.as_str()\n-    }\n-    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n-        ws.packages[self].manifest.parent().unwrap()\n-    }\n-    pub fn edition(self, ws: &CargoWorkspace) -> Edition {\n-        ws.packages[self].edition\n-    }\n-    pub fn features(self, ws: &CargoWorkspace) -> &[String] {\n-        &ws.packages[self].features\n-    }\n-    pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item = Target> + 'a {\n-        ws.packages[self].targets.iter().cloned()\n-    }\n-    #[allow(unused)]\n-    pub fn is_member(self, ws: &CargoWorkspace) -> bool {\n-        ws.packages[self].is_member\n-    }\n-    pub fn dependencies<'a>(\n-        self,\n-        ws: &'a CargoWorkspace,\n-    ) -> impl Iterator<Item = &'a PackageDependency> + 'a {\n-        ws.packages[self].dependencies.iter()\n-    }\n-    pub fn out_dir(self, ws: &CargoWorkspace) -> Option<&Path> {\n-        ws.packages[self].out_dir.as_ref().map(PathBuf::as_path)\n-    }\n-}\n-\n-impl Target {\n-    pub fn package(self, ws: &CargoWorkspace) -> Package {\n-        ws.targets[self].pkg\n-    }\n-    pub fn name(self, ws: &CargoWorkspace) -> &str {\n-        ws.targets[self].name.as_str()\n-    }\n-    pub fn root(self, ws: &CargoWorkspace) -> &Path {\n-        ws.targets[self].root.as_path()\n-    }\n-    pub fn kind(self, ws: &CargoWorkspace) -> TargetKind {\n-        ws.targets[self].kind\n-    }\n-    pub fn is_proc_macro(self, ws: &CargoWorkspace) -> bool {\n-        ws.targets[self].is_proc_macro\n+impl PackageData {\n+    pub fn root(&self) -> &Path {\n+        self.manifest.parent().unwrap()\n     }\n }\n \n@@ -219,7 +193,7 @@ impl CargoWorkspace {\n             for meta_tgt in meta_pkg.targets {\n                 let is_proc_macro = meta_tgt.kind.as_slice() == [\"proc-macro\"];\n                 let tgt = targets.alloc(TargetData {\n-                    pkg,\n+                    package: pkg,\n                     name: meta_tgt.name,\n                     root: meta_tgt.src_path.clone(),\n                     kind: TargetKind::new(meta_tgt.kind.as_slice()),\n@@ -265,7 +239,10 @@ impl CargoWorkspace {\n     }\n \n     pub fn target_by_root(&self, root: &Path) -> Option<Target> {\n-        self.packages().filter_map(|pkg| pkg.targets(self).find(|it| it.root(self) == root)).next()\n+        self.packages()\n+            .filter_map(|pkg| self[pkg].targets.iter().find(|&&it| self[it].root == root))\n+            .next()\n+            .copied()\n     }\n \n     pub fn workspace_root(&self) -> &Path {"}, {"sha": "3c294e065b4e35a3ff4307ec7d522faf69684955", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/516fe293a8146044b6398b8da0b4da43874a2cf9/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/516fe293a8146044b6398b8da0b4da43874a2cf9/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=516fe293a8146044b6398b8da0b4da43874a2cf9", "patch": "@@ -138,8 +138,8 @@ impl ProjectWorkspace {\n             ProjectWorkspace::Cargo { cargo, sysroot } => {\n                 let mut roots = Vec::with_capacity(cargo.packages().len() + sysroot.crates().len());\n                 for pkg in cargo.packages() {\n-                    let root = pkg.root(&cargo).to_path_buf();\n-                    let member = pkg.is_member(&cargo);\n+                    let root = cargo[pkg].root().to_path_buf();\n+                    let member = cargo[pkg].is_member;\n                     roots.push(PackageRoot::new(root, member));\n                 }\n                 for krate in sysroot.crates() {\n@@ -164,7 +164,7 @@ impl ProjectWorkspace {\n             ProjectWorkspace::Cargo { cargo, sysroot: _sysroot } => {\n                 let mut out_dirs = Vec::with_capacity(cargo.packages().len());\n                 for pkg in cargo.packages() {\n-                    if let Some(out_dir) = pkg.out_dir(&cargo) {\n+                    if let Some(out_dir) = &cargo[pkg].out_dir {\n                         out_dirs.push(out_dir.to_path_buf());\n                     }\n                 }\n@@ -309,18 +309,18 @@ impl ProjectWorkspace {\n                 // Next, create crates for each package, target pair\n                 for pkg in cargo.packages() {\n                     let mut lib_tgt = None;\n-                    for tgt in pkg.targets(&cargo) {\n-                        let root = tgt.root(&cargo);\n+                    for &tgt in cargo[pkg].targets.iter() {\n+                        let root = cargo[tgt].root.as_path();\n                         if let Some(file_id) = load(root) {\n-                            let edition = pkg.edition(&cargo);\n+                            let edition = cargo[pkg].edition;\n                             let cfg_options = {\n                                 let mut opts = default_cfg_options.clone();\n-                                opts.insert_features(pkg.features(&cargo).iter().map(Into::into));\n+                                opts.insert_features(cargo[pkg].features.iter().map(Into::into));\n                                 opts\n                             };\n                             let mut env = Env::default();\n                             let mut extern_source = ExternSource::default();\n-                            if let Some(out_dir) = pkg.out_dir(cargo) {\n+                            if let Some(out_dir) = &cargo[pkg].out_dir {\n                                 // FIXME: We probably mangle non UTF-8 paths here, figure out a better solution\n                                 env.set(\"OUT_DIR\", out_dir.to_string_lossy().to_string());\n                                 if let Some(&extern_source_id) = extern_source_roots.get(out_dir) {\n@@ -330,16 +330,16 @@ impl ProjectWorkspace {\n                             let crate_id = crate_graph.add_crate_root(\n                                 file_id,\n                                 edition,\n-                                Some(CrateName::normalize_dashes(pkg.name(&cargo))),\n+                                Some(CrateName::normalize_dashes(&cargo[pkg].name)),\n                                 cfg_options,\n                                 env,\n                                 extern_source,\n                             );\n-                            if tgt.kind(&cargo) == TargetKind::Lib {\n+                            if cargo[tgt].kind == TargetKind::Lib {\n                                 lib_tgt = Some(crate_id);\n                                 pkg_to_lib_crate.insert(pkg, crate_id);\n                             }\n-                            if tgt.is_proc_macro(&cargo) {\n+                            if cargo[tgt].is_proc_macro {\n                                 if let Some(proc_macro) = libproc_macro {\n                                     if crate_graph\n                                         .add_dep(\n@@ -351,7 +351,7 @@ impl ProjectWorkspace {\n                                     {\n                                         log::error!(\n                                             \"cyclic dependency on proc_macro for {}\",\n-                                            pkg.name(&cargo)\n+                                            &cargo[pkg].name\n                                         )\n                                     }\n                                 }\n@@ -371,15 +371,15 @@ impl ProjectWorkspace {\n                                         // For root projects with dashes in their name,\n                                         // cargo metadata does not do any normalization,\n                                         // so we do it ourselves currently\n-                                        CrateName::normalize_dashes(pkg.name(&cargo)),\n+                                        CrateName::normalize_dashes(&cargo[pkg].name),\n                                         to,\n                                     )\n                                     .is_err()\n                             {\n                                 {\n                                     log::error!(\n                                         \"cyclic dependency between targets of {}\",\n-                                        pkg.name(&cargo)\n+                                        &cargo[pkg].name\n                                     )\n                                 }\n                             }\n@@ -391,23 +391,23 @@ impl ProjectWorkspace {\n                                 .add_dep(from, CrateName::new(\"core\").unwrap(), core)\n                                 .is_err()\n                             {\n-                                log::error!(\"cyclic dependency on core for {}\", pkg.name(&cargo))\n+                                log::error!(\"cyclic dependency on core for {}\", &cargo[pkg].name)\n                             }\n                         }\n                         if let Some(alloc) = liballoc {\n                             if crate_graph\n                                 .add_dep(from, CrateName::new(\"alloc\").unwrap(), alloc)\n                                 .is_err()\n                             {\n-                                log::error!(\"cyclic dependency on alloc for {}\", pkg.name(&cargo))\n+                                log::error!(\"cyclic dependency on alloc for {}\", &cargo[pkg].name)\n                             }\n                         }\n                         if let Some(std) = libstd {\n                             if crate_graph\n                                 .add_dep(from, CrateName::new(\"std\").unwrap(), std)\n                                 .is_err()\n                             {\n-                                log::error!(\"cyclic dependency on std for {}\", pkg.name(&cargo))\n+                                log::error!(\"cyclic dependency on std for {}\", &cargo[pkg].name)\n                             }\n                         }\n                     }\n@@ -416,7 +416,7 @@ impl ProjectWorkspace {\n                 // Now add a dep edge from all targets of upstream to the lib\n                 // target of downstream.\n                 for pkg in cargo.packages() {\n-                    for dep in pkg.dependencies(&cargo) {\n+                    for dep in cargo[pkg].dependencies.iter() {\n                         if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n                             for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n                                 if crate_graph\n@@ -425,8 +425,8 @@ impl ProjectWorkspace {\n                                 {\n                                     log::error!(\n                                         \"cyclic dependency {} -> {}\",\n-                                        pkg.name(&cargo),\n-                                        dep.pkg.name(&cargo)\n+                                        &cargo[pkg].name,\n+                                        &cargo[dep.pkg].name\n                                     )\n                                 }\n                             }"}, {"sha": "f87bdcec5c4a371df73e7105397c3fde61bc7c61", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/516fe293a8146044b6398b8da0b4da43874a2cf9/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/516fe293a8146044b6398b8da0b4da43874a2cf9/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=516fe293a8146044b6398b8da0b4da43874a2cf9", "patch": "@@ -77,9 +77,9 @@ impl CargoTargetSpec {\n             ProjectWorkspace::Cargo { cargo, .. } => {\n                 let tgt = cargo.target_by_root(&path)?;\n                 Some(CargoTargetSpec {\n-                    package: tgt.package(&cargo).name(&cargo).to_string(),\n-                    target: tgt.name(&cargo).to_string(),\n-                    target_kind: tgt.kind(&cargo),\n+                    package: cargo[cargo[tgt].package].name.clone(),\n+                    target: cargo[tgt].name.clone(),\n+                    target_kind: cargo[tgt].kind,\n                 })\n             }\n             ProjectWorkspace::Json { .. } => None,"}]}