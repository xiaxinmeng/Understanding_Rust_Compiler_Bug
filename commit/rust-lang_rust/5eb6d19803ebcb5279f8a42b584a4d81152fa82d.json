{"sha": "5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYjZkMTk4MDNlYmNiNTI3OWY4YTQyYjU4NGE0ZDgxMTUyZmE4MmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-02T22:33:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-10T06:46:18Z"}, "message": "syntax: Use the new `for` protocol", "tree": {"sha": "f64e9e944ccaaf83b8a993c0ce1c404f22c9cd41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f64e9e944ccaaf83b8a993c0ce1c404f22c9cd41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "html_url": "https://github.com/rust-lang/rust/commit/5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ce9dba6775c7e1dbfb510626c073a8f926b6880", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ce9dba6775c7e1dbfb510626c073a8f926b6880", "html_url": "https://github.com/rust-lang/rust/commit/3ce9dba6775c7e1dbfb510626c073a8f926b6880"}], "stats": {"total": 194, "additions": 182, "deletions": 12}, "files": [{"sha": "f266b8871a225189d6aafca75e8a638d4a3873b7", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "patch": "@@ -81,6 +81,7 @@ static AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\", abi_arch: RustArch},\n ];\n \n+#[cfg(stage0)]\n fn each_abi(op: &fn(abi: Abi) -> bool) {\n     /*!\n      *\n@@ -93,6 +94,15 @@ fn each_abi(op: &fn(abi: Abi) -> bool) {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+fn each_abi(op: &fn(abi: Abi) -> bool) -> bool {\n+    /*!\n+     *\n+     * Iterates through each of the defined ABIs.\n+     */\n+\n+    AbiDatas.each(|abi_data| op(abi_data.abi))\n+}\n \n pub fn lookup(name: &str) -> Option<Abi> {\n     /*!\n@@ -189,6 +199,7 @@ pub impl AbiSet {\n         self.bits |= (1 << abi.index());\n     }\n \n+    #[cfg(stage0)]\n     fn each(&self, op: &fn(abi: Abi) -> bool) {\n         for each_abi |abi| {\n             if self.contains(abi) {\n@@ -198,6 +209,10 @@ pub impl AbiSet {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each(&self, op: &fn(abi: Abi) -> bool) -> bool {\n+        each_abi(|abi| !self.contains(abi) || op(abi))\n+    }\n \n     fn is_empty(&self) -> bool {\n         self.bits == 0\n@@ -252,17 +267,31 @@ pub impl AbiSet {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for Abi {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.index().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Abi {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.index().iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for AbiSet {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.bits.iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for AbiSet {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.bits.iter_bytes(lsb0, f)\n+    }\n+}\n \n impl ToStr for Abi {\n     fn to_str(&self) -> ~str {"}, {"sha": "c516ebc402f0ca072edcc26eaae7fa0fb25bdb26", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "patch": "@@ -97,11 +97,18 @@ impl<D:Decoder> Decodable<D> for ident {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for ident {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for ident {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.repr.iter_bytes(lsb0, f)\n+    }\n+}\n \n // Functions may or may not have names.\n pub type fn_ident = Option<ident>;\n@@ -284,6 +291,7 @@ pub enum binding_mode {\n     bind_infer\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for binding_mode {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -297,6 +305,18 @@ impl to_bytes::IterBytes for binding_mode {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for binding_mode {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+          bind_by_copy => 0u8.iter_bytes(lsb0, f),\n+\n+          bind_by_ref(ref m) => to_bytes::iter_bytes_2(&1u8, m, lsb0, f),\n+\n+          bind_infer => 2u8.iter_bytes(lsb0, f),\n+        }\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -330,11 +350,18 @@ pub enum pat_ {\n #[deriving(Eq)]\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for mutability {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for mutability {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -345,11 +372,18 @@ pub enum Sigil {\n     ManagedSigil\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for Sigil {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Sigil {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n impl ToStr for Sigil {\n     fn to_str(&self) -> ~str {\n@@ -744,11 +778,18 @@ impl ToStr for int_ty {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for int_ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for int_ty {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -761,11 +802,18 @@ impl ToStr for uint_ty {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for uint_ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for uint_ty {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -778,11 +826,18 @@ impl ToStr for float_ty {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for float_ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for float_ty {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n // NB Eq method appears below.\n #[auto_encode]\n@@ -823,11 +878,18 @@ impl ToStr for Onceness {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for Onceness {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Onceness {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -874,11 +936,18 @@ pub enum ty_ {\n     ty_infer,\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for Ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Ty {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -941,11 +1010,18 @@ impl ToStr for purity {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for purity {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for purity {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -956,11 +1032,18 @@ pub enum ret_style {\n     return_val, // everything else\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for ret_style {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for ret_style {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]"}, {"sha": "ceff868d11f21b5688d0287a22c199ab8d9dd335", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "patch": "@@ -191,12 +191,21 @@ pub fn is_call_expr(e: @expr) -> bool {\n }\n \n // This makes def_id hashable\n+#[cfg(stage0)]\n impl to_bytes::IterBytes for def_id {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n     }\n }\n+// This makes def_id hashable\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for def_id {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f)\n+    }\n+}\n \n pub fn block_from_expr(e: @expr) -> blk {\n     let blk_ = default_block(~[], option::Some::<@expr>(e), e.id);"}, {"sha": "053ed76d66b2a911a6a3fe3c90c8c9dd4153a6d9", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "patch": "@@ -65,11 +65,18 @@ impl Sub<BytePos, BytePos> for BytePos {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for BytePos {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for BytePos {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n impl Pos for CharPos {\n     fn from_uint(n: uint) -> CharPos { CharPos(n) }\n@@ -83,11 +90,18 @@ impl cmp::Ord for CharPos {\n     fn gt(&self, other: &CharPos) -> bool { **self > **other }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for CharPos {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for CharPos {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n impl Add<CharPos,CharPos> for CharPos {\n     fn add(&self, rhs: &CharPos) -> CharPos {"}, {"sha": "5129fa6ebd2aa06b950b31514c1d372a53c39c08", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "patch": "@@ -195,18 +195,8 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n }\n \n // does this attribute list contain \"macro_escape\" ?\n-pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool{\n-    let mut accum = false;\n-    do attrs.each |attr| {\n-        let mname = attr::get_attr_name(attr);\n-        if (mname == @~\"macro_escape\") {\n-            accum = true;\n-            false\n-        } else {\n-            true\n-        }\n-    }\n-    accum\n+pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool {\n+    attrs.any(|attr| \"macro_escape\" == *attr::get_attr_name(attr))\n }\n \n // this macro disables (one layer of) macro"}, {"sha": "7c78ec066d03188090af5e2010191da8abfbae5d", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "patch": "@@ -100,6 +100,7 @@ pub impl state_ {\n \n     /// Iterate over the states that can be reached in one message\n     /// from this state.\n+    #[cfg(stage0)]\n     fn reachable(&self, f: &fn(state) -> bool) {\n         for self.messages.each |m| {\n             match *m {\n@@ -111,6 +112,21 @@ pub impl state_ {\n             }\n         }\n     }\n+    /// Iterate over the states that can be reached in one message\n+    /// from this state.\n+    #[cfg(not(stage0))]\n+    fn reachable(&self, f: &fn(state) -> bool) -> bool {\n+        for self.messages.each |m| {\n+            match *m {\n+              message(_, _, _, _, Some(next_state { state: ref id, _ })) => {\n+                let state = self.proto.get_state((*id));\n+                if !f(state) { return false; }\n+              }\n+              _ => ()\n+            }\n+        }\n+        return true;\n+    }\n }\n \n pub type protocol = @mut protocol_;"}, {"sha": "6110579863dbfe3c9c9ea9c21880a356c38fc1ec", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "patch": "@@ -132,12 +132,20 @@ impl<A:Eq> Eq for OptVec<A> {\n }\n \n impl<A> BaseIter<A> for OptVec<A> {\n+    #[cfg(stage0)]\n     fn each(&self, blk: &fn(v: &A) -> bool) {\n         match *self {\n             Empty => {}\n             Vec(ref v) => v.each(blk)\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each(&self, blk: &fn(v: &A) -> bool) -> bool {\n+        match *self {\n+            Empty => true,\n+            Vec(ref v) => v.each(blk)\n+        }\n+    }\n \n     fn size_hint(&self) -> Option<uint> {\n         Some(self.len())\n@@ -146,10 +154,16 @@ impl<A> BaseIter<A> for OptVec<A> {\n \n impl<A> old_iter::ExtendedIter<A> for OptVec<A> {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) {\n         old_iter::eachi(self, blk)\n     }\n     #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) -> bool {\n+        old_iter::eachi(self, blk)\n+    }\n+    #[inline(always)]\n     fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }"}, {"sha": "a4ac038cf466f442d05f05500bb50426e98aba48", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "patch": "@@ -62,12 +62,20 @@ pub enum ObsoleteSyntax {\n     ObsoleteFixedLengthVectorType,\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for ObsoleteSyntax {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for ObsoleteSyntax {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n pub impl Parser {\n     /// Reports an obsolete syntax non-fatal error."}, {"sha": "15441b6fcfc57cf3e79eac92e419c8d5827a4089", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb6d19803ebcb5279f8a42b584a4d81152fa82d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "patch": "@@ -355,11 +355,18 @@ impl<'self> Equiv<@~str> for StringRef<'self> {\n     fn equiv(&self, other: &@~str) -> bool { str::eq_slice(**self, **other) }\n }\n \n+#[cfg(stage0)]\n impl<'self> to_bytes::IterBytes for StringRef<'self> {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'self> to_bytes::IterBytes for StringRef<'self> {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n /**\n  * Maps a token to a record specifying the corresponding binary"}]}