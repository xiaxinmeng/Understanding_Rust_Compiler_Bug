{"sha": "d425f8d2266f481bab447f30816fc9a1b4907868", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MjVmOGQyMjY2ZjQ4MWJhYjQ0N2YzMDgxNmZjOWExYjQ5MDc4Njg=", "commit": {"author": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2017-09-28T15:04:38Z"}, "committer": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2017-11-03T20:27:40Z"}, "message": "Copy `AsciiExt` methods to `char` directly\n\nThis is done in order to deprecate AsciiExt eventually.", "tree": {"sha": "a32ccc8a0c1c197119ed13a5a3b2df0336d8f43a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a32ccc8a0c1c197119ed13a5a3b2df0336d8f43a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d425f8d2266f481bab447f30816fc9a1b4907868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d425f8d2266f481bab447f30816fc9a1b4907868", "html_url": "https://github.com/rust-lang/rust/commit/d425f8d2266f481bab447f30816fc9a1b4907868", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d425f8d2266f481bab447f30816fc9a1b4907868/comments", "author": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5061c9fecb995bf1920bcb546cd522fe9a84dd3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5061c9fecb995bf1920bcb546cd522fe9a84dd3e", "html_url": "https://github.com/rust-lang/rust/commit/5061c9fecb995bf1920bcb546cd522fe9a84dd3e"}], "stats": {"total": 504, "additions": 501, "deletions": 3}, "files": [{"sha": "c132cf75e40a416499dac9a65e7625a089cab6cb", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d425f8d2266f481bab447f30816fc9a1b4907868/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d425f8d2266f481bab447f30816fc9a1b4907868/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=d425f8d2266f481bab447f30816fc9a1b4907868", "patch": "@@ -30,7 +30,6 @@\n use libc;\n use std::slice;\n \n-use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::collections::{HashMap, VecDeque};\n use std::default::Default;"}, {"sha": "500d0931708ab76fddc699d48b60cdf730c930a7", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d425f8d2266f481bab447f30816fc9a1b4907868/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d425f8d2266f481bab447f30816fc9a1b4907868/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d425f8d2266f481bab447f30816fc9a1b4907868", "patch": "@@ -23,7 +23,6 @@\n #![feature(test)]\n #![feature(unicode)]\n #![feature(vec_remove_item)]\n-#![feature(ascii_ctype)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "270878dc029c3d52fec5fb70a17b5e1e43fc4a15", "filename": "src/libstd/path.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d425f8d2266f481bab447f30816fc9a1b4907868/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d425f8d2266f481bab447f30816fc9a1b4907868/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=d425f8d2266f481bab447f30816fc9a1b4907868", "patch": "@@ -77,7 +77,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use ascii::*;\n use borrow::{Borrow, Cow};\n use cmp;\n use error::Error;"}, {"sha": "9c8dd538b22a31255ca2abf8b02e9a31db24aeb3", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/d425f8d2266f481bab447f30816fc9a1b4907868/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d425f8d2266f481bab447f30816fc9a1b4907868/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=d425f8d2266f481bab447f30816fc9a1b4907868", "patch": "@@ -923,6 +923,507 @@ impl char {\n     pub fn to_uppercase(self) -> ToUppercase {\n         ToUppercase(CaseMappingIter::new(conversions::to_upper(self)))\n     }\n+\n+    /// Checks if the value is within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = 'a';\n+    /// let non_ascii = '\u2764';\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        *self as u32 <= 0x7F\n+    }\n+\n+    /// Makes a copy of the value in its ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// To uppercase ASCII characters in addition to non-ASCII characters, use\n+    /// [`to_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = 'a';\n+    /// let non_ascii = '\u2764';\n+    ///\n+    /// assert_eq!('A', ascii.to_ascii_uppercase());\n+    /// assert_eq!('\u2764', non_ascii.to_ascii_uppercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// [`to_uppercase`]: #method.to_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> char {\n+        if self.is_ascii() {\n+            (*self as u8).to_ascii_uppercase() as char\n+        } else {\n+            *self\n+        }\n+    }\n+\n+    /// Makes a copy of the value in its ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// To lowercase ASCII characters in addition to non-ASCII characters, use\n+    /// [`to_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = 'A';\n+    /// let non_ascii = '\u2764';\n+    ///\n+    /// assert_eq!('a', ascii.to_ascii_lowercase());\n+    /// assert_eq!('\u2764', non_ascii.to_ascii_lowercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// [`to_lowercase`]: #method.to_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> char {\n+        if self.is_ascii() {\n+            (*self as u8).to_ascii_lowercase() as char\n+        } else {\n+            *self\n+        }\n+    }\n+\n+    /// Checks that two values are an ASCII case-insensitive match.\n+    ///\n+    /// Equivalent to `to_ascii_lowercase(a) == to_ascii_lowercase(b)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let upper_a = 'A';\n+    /// let lower_a = 'a';\n+    /// let lower_z = 'z';\n+    ///\n+    /// assert!(upper_a.eq_ignore_ascii_case(&lower_a));\n+    /// assert!(upper_a.eq_ignore_ascii_case(&upper_a));\n+    /// assert!(!upper_a.eq_ignore_ascii_case(&lower_z));\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &char) -> bool {\n+        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n+    }\n+\n+    /// Converts this type to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut ascii = 'a';\n+    ///\n+    /// ascii.make_ascii_uppercase();\n+    ///\n+    /// assert_eq!('A', ascii);\n+    /// ```\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        *self = self.to_ascii_uppercase();\n+    }\n+\n+    /// Converts this type to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut ascii = 'A';\n+    ///\n+    /// ascii.make_ascii_lowercase();\n+    ///\n+    /// assert_eq!('a', ascii);\n+    /// ```\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        *self = self.to_ascii_lowercase();\n+    }\n+\n+    /// Checks if the value is an ASCII alphabetic character:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(uppercase_a.is_ascii_alphabetic());\n+    /// assert!(uppercase_g.is_ascii_alphabetic());\n+    /// assert!(a.is_ascii_alphabetic());\n+    /// assert!(g.is_ascii_alphabetic());\n+    /// assert!(!zero.is_ascii_alphabetic());\n+    /// assert!(!percent.is_ascii_alphabetic());\n+    /// assert!(!space.is_ascii_alphabetic());\n+    /// assert!(!lf.is_ascii_alphabetic());\n+    /// assert!(!esc.is_ascii_alphabetic());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_alphabetic(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_alphabetic()\n+    }\n+\n+    /// Checks if the value is an ASCII uppercase character:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(uppercase_a.is_ascii_uppercase());\n+    /// assert!(uppercase_g.is_ascii_uppercase());\n+    /// assert!(!a.is_ascii_uppercase());\n+    /// assert!(!g.is_ascii_uppercase());\n+    /// assert!(!zero.is_ascii_uppercase());\n+    /// assert!(!percent.is_ascii_uppercase());\n+    /// assert!(!space.is_ascii_uppercase());\n+    /// assert!(!lf.is_ascii_uppercase());\n+    /// assert!(!esc.is_ascii_uppercase());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_uppercase(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_uppercase()\n+    }\n+\n+    /// Checks if the value is an ASCII lowercase character:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_lowercase());\n+    /// assert!(!uppercase_g.is_ascii_lowercase());\n+    /// assert!(a.is_ascii_lowercase());\n+    /// assert!(g.is_ascii_lowercase());\n+    /// assert!(!zero.is_ascii_lowercase());\n+    /// assert!(!percent.is_ascii_lowercase());\n+    /// assert!(!space.is_ascii_lowercase());\n+    /// assert!(!lf.is_ascii_lowercase());\n+    /// assert!(!esc.is_ascii_lowercase());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_lowercase(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_lowercase()\n+    }\n+\n+    /// Checks if the value is an ASCII alphanumeric character:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', U+0061 'a' ... U+007A 'z', or\n+    /// - U+0030 '0' ... U+0039 '9'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(uppercase_a.is_ascii_alphanumeric());\n+    /// assert!(uppercase_g.is_ascii_alphanumeric());\n+    /// assert!(a.is_ascii_alphanumeric());\n+    /// assert!(g.is_ascii_alphanumeric());\n+    /// assert!(zero.is_ascii_alphanumeric());\n+    /// assert!(!percent.is_ascii_alphanumeric());\n+    /// assert!(!space.is_ascii_alphanumeric());\n+    /// assert!(!lf.is_ascii_alphanumeric());\n+    /// assert!(!esc.is_ascii_alphanumeric());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_alphanumeric(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_alphanumeric()\n+    }\n+\n+    /// Checks if the value is an ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_digit());\n+    /// assert!(!uppercase_g.is_ascii_digit());\n+    /// assert!(!a.is_ascii_digit());\n+    /// assert!(!g.is_ascii_digit());\n+    /// assert!(zero.is_ascii_digit());\n+    /// assert!(!percent.is_ascii_digit());\n+    /// assert!(!space.is_ascii_digit());\n+    /// assert!(!lf.is_ascii_digit());\n+    /// assert!(!esc.is_ascii_digit());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_digit(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_digit()\n+    }\n+\n+    /// Checks if the value is an ASCII hexadecimal digit:\n+    ///\n+    /// - U+0030 '0' ... U+0039 '9', U+0041 'A' ... U+0046 'F', or\n+    /// - U+0061 'a' ... U+0066 'f'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(uppercase_a.is_ascii_hexdigit());\n+    /// assert!(!uppercase_g.is_ascii_hexdigit());\n+    /// assert!(a.is_ascii_hexdigit());\n+    /// assert!(!g.is_ascii_hexdigit());\n+    /// assert!(zero.is_ascii_hexdigit());\n+    /// assert!(!percent.is_ascii_hexdigit());\n+    /// assert!(!space.is_ascii_hexdigit());\n+    /// assert!(!lf.is_ascii_hexdigit());\n+    /// assert!(!esc.is_ascii_hexdigit());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_hexdigit(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_hexdigit()\n+    }\n+\n+    /// Checks if the value is an ASCII punctuation character:\n+    ///\n+    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n+    /// - U+007B ... U+007E `{ | } ~`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_punctuation());\n+    /// assert!(!uppercase_g.is_ascii_punctuation());\n+    /// assert!(!a.is_ascii_punctuation());\n+    /// assert!(!g.is_ascii_punctuation());\n+    /// assert!(!zero.is_ascii_punctuation());\n+    /// assert!(percent.is_ascii_punctuation());\n+    /// assert!(!space.is_ascii_punctuation());\n+    /// assert!(!lf.is_ascii_punctuation());\n+    /// assert!(!esc.is_ascii_punctuation());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_punctuation(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_punctuation()\n+    }\n+\n+    /// Checks if the value is an ASCII graphic character:\n+    /// U+0021 '@' ... U+007E '~'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(uppercase_a.is_ascii_graphic());\n+    /// assert!(uppercase_g.is_ascii_graphic());\n+    /// assert!(a.is_ascii_graphic());\n+    /// assert!(g.is_ascii_graphic());\n+    /// assert!(zero.is_ascii_graphic());\n+    /// assert!(percent.is_ascii_graphic());\n+    /// assert!(!space.is_ascii_graphic());\n+    /// assert!(!lf.is_ascii_graphic());\n+    /// assert!(!esc.is_ascii_graphic());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_graphic(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_graphic()\n+    }\n+\n+    /// Checks if the value is an ASCII whitespace character:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw]. There are several other definitions in\n+    /// wide use. For instance, [the POSIX locale][pct] includes\n+    /// U+000B VERTICAL TAB as well as all the above characters,\n+    /// but\u2014from the very same specification\u2014[the default rule for\n+    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n+    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_whitespace());\n+    /// assert!(!uppercase_g.is_ascii_whitespace());\n+    /// assert!(!a.is_ascii_whitespace());\n+    /// assert!(!g.is_ascii_whitespace());\n+    /// assert!(!zero.is_ascii_whitespace());\n+    /// assert!(!percent.is_ascii_whitespace());\n+    /// assert!(space.is_ascii_whitespace());\n+    /// assert!(lf.is_ascii_whitespace());\n+    /// assert!(!esc.is_ascii_whitespace());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_whitespace(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_whitespace()\n+    }\n+\n+    /// Checks if the value is an ASCII control character:\n+    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_control());\n+    /// assert!(!uppercase_g.is_ascii_control());\n+    /// assert!(!a.is_ascii_control());\n+    /// assert!(!g.is_ascii_control());\n+    /// assert!(!zero.is_ascii_control());\n+    /// assert!(!percent.is_ascii_control());\n+    /// assert!(!space.is_ascii_control());\n+    /// assert!(lf.is_ascii_control());\n+    /// assert!(esc.is_ascii_control());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_control(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_control()\n+    }\n }\n \n /// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s."}]}