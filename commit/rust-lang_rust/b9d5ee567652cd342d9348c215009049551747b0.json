{"sha": "b9d5ee567652cd342d9348c215009049551747b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZDVlZTU2NzY1MmNkMzQyZDkzNDhjMjE1MDA5MDQ5NTUxNzQ3YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-28T11:13:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-28T11:13:09Z"}, "message": "Auto merge of #70261 - Centril:angle-args-partition, r=varkor\n\nMove arg/constraint partition check to validation & improve recovery\n\n- In the first commit, we move the check rejecting e.g., `<'a, Item = u8, String>` from the parser into AST validation.\n- We then use this to improve the code for parsing generic arguments.\n- And we add recovery for e.g., `<Item = >` (missing), `<Item = 42>` (constant), and `<Item = 'a>` (lifetime).\n\nThis is also preparatory work for supporting https://github.com/rust-lang/rust/issues/70256.\n\nr? @varkor", "tree": {"sha": "820b045d697c1263c497f442274d1a9aac952189", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/820b045d697c1263c497f442274d1a9aac952189"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9d5ee567652cd342d9348c215009049551747b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9d5ee567652cd342d9348c215009049551747b0", "html_url": "https://github.com/rust-lang/rust/commit/b9d5ee567652cd342d9348c215009049551747b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9d5ee567652cd342d9348c215009049551747b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b76238a3ee5ebffbad8a3aefd36012f3bceb7069", "url": "https://api.github.com/repos/rust-lang/rust/commits/b76238a3ee5ebffbad8a3aefd36012f3bceb7069", "html_url": "https://github.com/rust-lang/rust/commit/b76238a3ee5ebffbad8a3aefd36012f3bceb7069"}, {"sha": "42c5cfdfda24529f424a6175fa1a48e5542cb824", "url": "https://api.github.com/repos/rust-lang/rust/commits/42c5cfdfda24529f424a6175fa1a48e5542cb824", "html_url": "https://github.com/rust-lang/rust/commit/42c5cfdfda24529f424a6175fa1a48e5542cb824"}], "stats": {"total": 651, "additions": 404, "deletions": 247}, "files": [{"sha": "6586280d21454aa63aa5e2a8fcbfdc46cf5235d5", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -214,11 +214,18 @@ impl GenericArg {\n pub struct AngleBracketedArgs {\n     /// The overall span.\n     pub span: Span,\n-    /// The arguments for this path segment.\n-    pub args: Vec<GenericArg>,\n-    /// Constraints on associated types, if any.\n-    /// E.g., `Foo<A = Bar, B: Baz>`.\n-    pub constraints: Vec<AssocTyConstraint>,\n+    /// The comma separated parts in the `<...>`.\n+    pub args: Vec<AngleBracketedArg>,\n+}\n+\n+/// Either an argument for a parameter e.g., `'a`, `Vec<u8>`, `0`,\n+/// or a constraint on an associated item, e.g., `Item = String` or `Item: Bound`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum AngleBracketedArg {\n+    /// Argument for a generic parameter.\n+    Arg(GenericArg),\n+    /// Constraint for an associated item.\n+    Constraint(AssocTyConstraint),\n }\n \n impl Into<Option<P<GenericArgs>>> for AngleBracketedArgs {\n@@ -248,11 +255,13 @@ pub struct ParenthesizedArgs {\n \n impl ParenthesizedArgs {\n     pub fn as_angle_bracketed_args(&self) -> AngleBracketedArgs {\n-        AngleBracketedArgs {\n-            span: self.span,\n-            args: self.inputs.iter().cloned().map(GenericArg::Type).collect(),\n-            constraints: vec![],\n-        }\n+        let args = self\n+            .inputs\n+            .iter()\n+            .cloned()\n+            .map(|input| AngleBracketedArg::Arg(GenericArg::Type(input)))\n+            .collect();\n+        AngleBracketedArgs { span: self.span, args }\n     }\n }\n "}, {"sha": "a72a60c30b28a049dec4f28b47cb42368534cecd", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -546,9 +546,11 @@ pub fn noop_visit_angle_bracketed_parameter_data<T: MutVisitor>(\n     data: &mut AngleBracketedArgs,\n     vis: &mut T,\n ) {\n-    let AngleBracketedArgs { args, constraints, span } = data;\n-    visit_vec(args, |arg| vis.visit_generic_arg(arg));\n-    visit_vec(constraints, |constraint| vis.visit_ty_constraint(constraint));\n+    let AngleBracketedArgs { args, span } = data;\n+    visit_vec(args, |arg| match arg {\n+        AngleBracketedArg::Arg(arg) => vis.visit_generic_arg(arg),\n+        AngleBracketedArg::Constraint(constraint) => vis.visit_ty_constraint(constraint),\n+    });\n     vis.visit_span(span);\n }\n "}, {"sha": "51863350a8cf38f3508a1ede7e9616741a41d3f7", "filename": "src/librustc_ast/visit.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fvisit.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -464,8 +464,12 @@ where\n {\n     match *generic_args {\n         GenericArgs::AngleBracketed(ref data) => {\n-            walk_list!(visitor, visit_generic_arg, &data.args);\n-            walk_list!(visitor, visit_assoc_ty_constraint, &data.constraints);\n+            for arg in &data.args {\n+                match arg {\n+                    AngleBracketedArg::Arg(a) => visitor.visit_generic_arg(a),\n+                    AngleBracketedArg::Constraint(c) => visitor.visit_assoc_ty_constraint(c),\n+                }\n+            }\n         }\n         GenericArgs::Parenthesized(ref data) => {\n             walk_list!(visitor, visit_ty, &data.inputs);"}, {"sha": "45ee7265c15fcb2b6124bb21dad05fb7ee0391db", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -34,6 +34,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(marker_trait_attr)]\n #![feature(specialization)]\n+#![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n use rustc_ast::ast;"}, {"sha": "dde734756517c099fcc94bb843ba64b8d5795ca7", "filename": "src/librustc_ast_lowering/path.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -366,22 +366,27 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         param_mode: ParamMode,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> (GenericArgsCtor<'hir>, bool) {\n-        let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n-        let has_non_lt_args = args.iter().any(|arg| match arg {\n-            ast::GenericArg::Lifetime(_) => false,\n-            ast::GenericArg::Type(_) => true,\n-            ast::GenericArg::Const(_) => true,\n+        let has_non_lt_args = data.args.iter().any(|arg| match arg {\n+            AngleBracketedArg::Arg(ast::GenericArg::Lifetime(_))\n+            | AngleBracketedArg::Constraint(_) => false,\n+            AngleBracketedArg::Arg(ast::GenericArg::Type(_) | ast::GenericArg::Const(_)) => true,\n         });\n-        (\n-            GenericArgsCtor {\n-                args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-                bindings: self.arena.alloc_from_iter(\n-                    constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n-                ),\n-                parenthesized: false,\n-            },\n-            !has_non_lt_args && param_mode == ParamMode::Optional,\n-        )\n+        let args = data\n+            .args\n+            .iter()\n+            .filter_map(|arg| match arg {\n+                AngleBracketedArg::Arg(arg) => Some(self.lower_generic_arg(arg, itctx.reborrow())),\n+                AngleBracketedArg::Constraint(_) => None,\n+            })\n+            .collect();\n+        let bindings = self.arena.alloc_from_iter(data.args.iter().filter_map(|arg| match arg {\n+            AngleBracketedArg::Constraint(c) => {\n+                Some(self.lower_assoc_ty_constraint(c, itctx.reborrow()))\n+            }\n+            AngleBracketedArg::Arg(_) => None,\n+        }));\n+        let ctor = GenericArgsCtor { args, bindings, parenthesized: false };\n+        (ctor, !has_non_lt_args && param_mode == ParamMode::Optional)\n     }\n \n     fn lower_parenthesized_parameter_data("}, {"sha": "de7ae10723f4de482e993e1a9ee05aacf58fdb5d", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -639,6 +639,34 @@ impl<'a> AstValidator<'a> {\n             .emit();\n         }\n     }\n+\n+    /// Enforce generic args coming before constraints in `<...>` of a path segment.\n+    fn check_generic_args_before_constraints(&self, data: &AngleBracketedArgs) {\n+        // Early exit in case it's partitioned as it should be.\n+        if data.args.iter().is_partitioned(|arg| matches!(arg, AngleBracketedArg::Arg(_))) {\n+            return;\n+        }\n+        // Find all generic argument coming after the first constraint...\n+        let mut misplaced_args = Vec::new();\n+        let mut first = None;\n+        for arg in &data.args {\n+            match (arg, first) {\n+                (AngleBracketedArg::Arg(a), Some(_)) => misplaced_args.push(a.span()),\n+                (AngleBracketedArg::Constraint(c), None) => first = Some(c.span),\n+                (AngleBracketedArg::Arg(_), None) | (AngleBracketedArg::Constraint(_), Some(_)) => {\n+                }\n+            }\n+        }\n+        // ...and then error:\n+        self.err_handler()\n+            .struct_span_err(\n+                misplaced_args.clone(),\n+                \"generic arguments must come before the first constraint\",\n+            )\n+            .span_label(first.unwrap(), \"the first constraint is provided here\")\n+            .span_labels(misplaced_args, \"generic argument\")\n+            .emit();\n+    }\n }\n \n /// Checks that generic parameters are in the correct order,\n@@ -1008,17 +1036,20 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_generic_args(&mut self, _: Span, generic_args: &'a GenericArgs) {\n         match *generic_args {\n             GenericArgs::AngleBracketed(ref data) => {\n-                walk_list!(self, visit_generic_arg, &data.args);\n-\n-                // Type bindings such as `Item = impl Debug` in `Iterator<Item = Debug>`\n-                // are allowed to contain nested `impl Trait`.\n-                self.with_impl_trait(None, |this| {\n-                    walk_list!(\n-                        this,\n-                        visit_assoc_ty_constraint_from_generic_args,\n-                        &data.constraints\n-                    );\n-                });\n+                self.check_generic_args_before_constraints(data);\n+\n+                for arg in &data.args {\n+                    match arg {\n+                        AngleBracketedArg::Arg(arg) => self.visit_generic_arg(arg),\n+                        // Type bindings such as `Item = impl Debug` in `Iterator<Item = Debug>`\n+                        // are allowed to contain nested `impl Trait`.\n+                        AngleBracketedArg::Constraint(constraint) => {\n+                            self.with_impl_trait(None, |this| {\n+                                this.visit_assoc_ty_constraint_from_generic_args(constraint);\n+                            });\n+                        }\n+                    }\n+                }\n             }\n             GenericArgs::Parenthesized(ref data) => {\n                 walk_list!(self, visit_ty, &data.inputs);"}, {"sha": "bfe304419801d5f2c7833170ceb6eaa5012ce23b", "filename": "src/librustc_ast_passes/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Flib.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -1,10 +1,12 @@\n-#![feature(bindings_after_at)]\n //! The `rustc_ast_passes` crate contains passes which validate the AST in `syntax`\n //! parsed by `rustc_parse` and then lowered, after the passes in this crate,\n //! by `rustc_ast_lowering`.\n //!\n //! The crate also contains other misc AST visitors, e.g. `node_count` and `show_span`.\n \n+#![feature(bindings_after_at)]\n+#![feature(iter_is_partitioned)]\n+\n pub mod ast_validation;\n pub mod feature_gate;\n pub mod node_count;"}, {"sha": "4aabbe7efbef456866710ed954d93109d96d219d", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -796,31 +796,10 @@ impl<'a> PrintState<'a> for State<'a> {\n         match *args {\n             ast::GenericArgs::AngleBracketed(ref data) => {\n                 self.s.word(\"<\");\n-\n-                self.commasep(Inconsistent, &data.args, |s, generic_arg| {\n-                    s.print_generic_arg(generic_arg)\n+                self.commasep(Inconsistent, &data.args, |s, arg| match arg {\n+                    ast::AngleBracketedArg::Arg(a) => s.print_generic_arg(a),\n+                    ast::AngleBracketedArg::Constraint(c) => s.print_assoc_constraint(c),\n                 });\n-\n-                let mut comma = !data.args.is_empty();\n-\n-                for constraint in data.constraints.iter() {\n-                    if comma {\n-                        self.word_space(\",\")\n-                    }\n-                    self.print_ident(constraint.ident);\n-                    self.s.space();\n-                    match constraint.kind {\n-                        ast::AssocTyConstraintKind::Equality { ref ty } => {\n-                            self.word_space(\"=\");\n-                            self.print_type(ty);\n-                        }\n-                        ast::AssocTyConstraintKind::Bound { ref bounds } => {\n-                            self.print_type_bounds(\":\", &*bounds);\n-                        }\n-                    }\n-                    comma = true;\n-                }\n-\n                 self.s.word(\">\")\n             }\n \n@@ -891,6 +870,20 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    fn print_assoc_constraint(&mut self, constraint: &ast::AssocTyConstraint) {\n+        self.print_ident(constraint.ident);\n+        self.s.space();\n+        match &constraint.kind {\n+            ast::AssocTyConstraintKind::Equality { ty } => {\n+                self.word_space(\"=\");\n+                self.print_type(ty);\n+            }\n+            ast::AssocTyConstraintKind::Bound { bounds } => {\n+                self.print_type_bounds(\":\", &*bounds);\n+            }\n+        }\n+    }\n+\n     crate fn print_generic_arg(&mut self, generic_arg: &GenericArg) {\n         match generic_arg {\n             GenericArg::Lifetime(lt) => self.print_lifetime(*lt),"}, {"sha": "4d89bf79e7c67e16d2171ee3796cda2e3f31a707", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -36,7 +36,8 @@ impl<'a> ExtCtxt<'a> {\n             idents.into_iter().map(|ident| ast::PathSegment::from_ident(ident.with_span_pos(span))),\n         );\n         let args = if !args.is_empty() {\n-            ast::AngleBracketedArgs { args, constraints: Vec::new(), span }.into()\n+            let args = args.into_iter().map(ast::AngleBracketedArg::Arg).collect();\n+            ast::AngleBracketedArgs { args, span }.into()\n         } else {\n             None\n         };"}, {"sha": "eff7dacef7953f21b0ae753d51d8990b27f51985", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -634,17 +634,19 @@ impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n                         match seg.args.as_ref().map(|generic_arg| &**generic_arg) {\n                             None => false,\n                             Some(&ast::GenericArgs::AngleBracketed(ref data)) => {\n-                                let types = data.args.iter().filter_map(|arg| match arg {\n-                                    ast::GenericArg::Type(ty) => Some(ty),\n-                                    _ => None,\n-                                });\n-                                any_involves_impl_trait(types)\n-                                    || data.constraints.iter().any(|c| match c.kind {\n+                                data.args.iter().any(|arg| match arg {\n+                                    ast::AngleBracketedArg::Arg(arg) => match arg {\n+                                        ast::GenericArg::Type(ty) => involves_impl_trait(ty),\n+                                        ast::GenericArg::Lifetime(_)\n+                                        | ast::GenericArg::Const(_) => false,\n+                                    },\n+                                    ast::AngleBracketedArg::Constraint(c) => match c.kind {\n                                         ast::AssocTyConstraintKind::Bound { .. } => true,\n                                         ast::AssocTyConstraintKind::Equality { ref ty } => {\n                                             involves_impl_trait(ty)\n                                         }\n-                                    })\n+                                    },\n+                                })\n                             }\n                             Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n                                 any_involves_impl_trait(data.inputs.iter())"}, {"sha": "9fa7bc027b87800379b3a0cad54b3dba6a897603", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 126, "deletions": 102, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -1,12 +1,10 @@\n use super::ty::{AllowPlus, RecoverQPath};\n use super::{Parser, TokenType};\n use crate::maybe_whole;\n-use rustc_ast::ast::{\n-    self, AngleBracketedArgs, Ident, ParenthesizedArgs, Path, PathSegment, QSelf,\n-};\n-use rustc_ast::ast::{\n-    AnonConst, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode, GenericArg,\n-};\n+use rustc_ast::ast::{self, AngleBracketedArg, AngleBracketedArgs, GenericArg, ParenthesizedArgs};\n+use rustc_ast::ast::{AnonConst, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n+use rustc_ast::ast::{Ident, Path, PathSegment, QSelf};\n+use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n use rustc_errors::{pluralize, Applicability, PResult};\n use rustc_span::source_map::{BytePos, Span};\n@@ -218,11 +216,11 @@ impl<'a> Parser<'a> {\n                 let lo = self.token.span;\n                 let args = if self.eat_lt() {\n                     // `<'a, T, A = U>`\n-                    let (args, constraints) =\n-                        self.parse_generic_args_with_leading_angle_bracket_recovery(style, lo)?;\n+                    let args =\n+                        self.parse_angle_args_with_leading_angle_bracket_recovery(style, lo)?;\n                     self.expect_gt()?;\n                     let span = lo.to(self.prev_token.span);\n-                    AngleBracketedArgs { args, constraints, span }.into()\n+                    AngleBracketedArgs { args, span }.into()\n                 } else {\n                     // `(T, U) -> R`\n                     let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n@@ -251,18 +249,18 @@ impl<'a> Parser<'a> {\n \n     /// Parses generic args (within a path segment) with recovery for extra leading angle brackets.\n     /// For the purposes of understanding the parsing logic of generic arguments, this function\n-    /// can be thought of being the same as just calling `self.parse_generic_args()` if the source\n+    /// can be thought of being the same as just calling `self.parse_angle_args()` if the source\n     /// had the correct amount of leading angle brackets.\n     ///\n     /// ```ignore (diagnostics)\n     /// bar::<<<<T as Foo>::Output>();\n     ///      ^^ help: remove extra angle brackets\n     /// ```\n-    fn parse_generic_args_with_leading_angle_bracket_recovery(\n+    fn parse_angle_args_with_leading_angle_bracket_recovery(\n         &mut self,\n         style: PathStyle,\n         lo: Span,\n-    ) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n+    ) -> PResult<'a, Vec<AngleBracketedArg>> {\n         // We need to detect whether there are extra leading left angle brackets and produce an\n         // appropriate error and suggestion. This cannot be implemented by looking ahead at\n         // upcoming tokens for a matching `>` character - if there are unmatched `<` tokens\n@@ -337,8 +335,8 @@ impl<'a> Parser<'a> {\n         let snapshot = if is_first_invocation { Some(self.clone()) } else { None };\n \n         debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n-        match self.parse_generic_args() {\n-            Ok(value) => Ok(value),\n+        match self.parse_angle_args() {\n+            Ok(args) => Ok(args),\n             Err(ref mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n                 // Cancel error from being unable to find `>`. We know the error\n                 // must have been this due to a non-zero unmatched angle bracket\n@@ -381,110 +379,136 @@ impl<'a> Parser<'a> {\n                 .emit();\n \n                 // Try again without unmatched angle bracket characters.\n-                self.parse_generic_args()\n+                self.parse_angle_args()\n             }\n             Err(e) => Err(e),\n         }\n     }\n \n-    /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n+    /// Parses (possibly empty) list of generic arguments / associated item constraints,\n     /// possibly including trailing comma.\n-    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n+    fn parse_angle_args(&mut self) -> PResult<'a, Vec<AngleBracketedArg>> {\n         let mut args = Vec::new();\n-        let mut constraints = Vec::new();\n-        let mut misplaced_assoc_ty_constraints: Vec<Span> = Vec::new();\n-        let mut assoc_ty_constraints: Vec<Span> = Vec::new();\n-\n-        let args_lo = self.token.span;\n-\n-        loop {\n-            if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n-                // Parse lifetime argument.\n-                args.push(GenericArg::Lifetime(self.expect_lifetime()));\n-                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n-            } else if self.check_ident()\n-                && self.look_ahead(1, |t| t == &token::Eq || t == &token::Colon)\n-            {\n-                // Parse associated type constraint.\n-                let lo = self.token.span;\n-                let ident = self.parse_ident()?;\n-                let kind = if self.eat(&token::Eq) {\n-                    AssocTyConstraintKind::Equality { ty: self.parse_ty()? }\n-                } else if self.eat(&token::Colon) {\n-                    AssocTyConstraintKind::Bound {\n-                        bounds: self.parse_generic_bounds(Some(self.prev_token.span))?,\n-                    }\n-                } else {\n-                    unreachable!();\n-                };\n+        while let Some(arg) = self.parse_angle_arg()? {\n+            args.push(arg);\n+            if !self.eat(&token::Comma) {\n+                break;\n+            }\n+        }\n+        Ok(args)\n+    }\n \n-                let span = lo.to(self.prev_token.span);\n+    /// Parses a single argument in the angle arguments `<...>` of a path segment.\n+    fn parse_angle_arg(&mut self) -> PResult<'a, Option<AngleBracketedArg>> {\n+        if self.check_ident() && self.look_ahead(1, |t| matches!(t.kind, token::Eq | token::Colon))\n+        {\n+            // Parse associated type constraint.\n+            let lo = self.token.span;\n+            let ident = self.parse_ident()?;\n+            let kind = if self.eat(&token::Eq) {\n+                let ty = self.parse_assoc_equality_term(ident, self.prev_token.span)?;\n+                AssocTyConstraintKind::Equality { ty }\n+            } else if self.eat(&token::Colon) {\n+                let bounds = self.parse_generic_bounds(Some(self.prev_token.span))?;\n+                AssocTyConstraintKind::Bound { bounds }\n+            } else {\n+                unreachable!();\n+            };\n \n-                // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n-                if let AssocTyConstraintKind::Bound { .. } = kind {\n-                    self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n-                }\n+            let span = lo.to(self.prev_token.span);\n \n-                constraints.push(AssocTyConstraint { id: ast::DUMMY_NODE_ID, ident, kind, span });\n-                assoc_ty_constraints.push(span);\n-            } else if self.check_const_arg() {\n-                // Parse const argument.\n-                let expr = if let token::OpenDelim(token::Brace) = self.token.kind {\n-                    self.parse_block_expr(\n-                        None,\n-                        self.token.span,\n-                        BlockCheckMode::Default,\n-                        ast::AttrVec::new(),\n-                    )?\n-                } else if self.token.is_ident() {\n-                    // FIXME(const_generics): to distinguish between idents for types and consts,\n-                    // we should introduce a GenericArg::Ident in the AST and distinguish when\n-                    // lowering to the HIR. For now, idents for const args are not permitted.\n-                    if self.token.is_bool_lit() {\n-                        self.parse_literal_maybe_minus()?\n-                    } else {\n-                        let span = self.token.span;\n-                        let msg = \"identifiers may currently not be used for const generics\";\n-                        self.struct_span_err(span, msg).emit();\n-                        let block = self.mk_block_err(span);\n-                        self.mk_expr(span, ast::ExprKind::Block(block, None), ast::AttrVec::new())\n-                    }\n-                } else {\n-                    self.parse_literal_maybe_minus()?\n-                };\n-                let value = AnonConst { id: ast::DUMMY_NODE_ID, value: expr };\n-                args.push(GenericArg::Const(value));\n-                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n-            } else if self.check_type() {\n-                // Parse type argument.\n-                args.push(GenericArg::Type(self.parse_ty()?));\n-                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n-            } else {\n-                break;\n+            // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n+            if let AssocTyConstraintKind::Bound { .. } = kind {\n+                self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n             }\n \n-            if !self.eat(&token::Comma) {\n-                break;\n-            }\n+            let constraint = AssocTyConstraint { id: ast::DUMMY_NODE_ID, ident, kind, span };\n+            Ok(Some(AngleBracketedArg::Constraint(constraint)))\n+        } else {\n+            Ok(self.parse_generic_arg()?.map(AngleBracketedArg::Arg))\n         }\n+    }\n \n-        // FIXME: we would like to report this in ast_validation instead, but we currently do not\n-        // preserve ordering of generic parameters with respect to associated type binding, so we\n-        // lose that information after parsing.\n-        if !misplaced_assoc_ty_constraints.is_empty() {\n-            let mut err = self.struct_span_err(\n-                args_lo.to(self.prev_token.span),\n-                \"associated type bindings must be declared after generic parameters\",\n-            );\n-            for span in misplaced_assoc_ty_constraints {\n-                err.span_label(\n-                    span,\n-                    \"this associated type binding should be moved after the generic parameters\",\n-                );\n+    /// Parse the term to the right of an associated item equality constraint.\n+    /// That is, parse `<term>` in `Item = <term>`.\n+    /// Right now, this only admits types in `<term>`.\n+    fn parse_assoc_equality_term(&mut self, ident: Ident, eq: Span) -> PResult<'a, P<ast::Ty>> {\n+        let arg = self.parse_generic_arg()?;\n+        let span = ident.span.to(self.prev_token.span);\n+        match arg {\n+            Some(GenericArg::Type(ty)) => return Ok(ty),\n+            Some(GenericArg::Const(expr)) => {\n+                self.struct_span_err(span, \"cannot constrain an associated constant to a value\")\n+                    .span_label(ident.span, \"this associated constant...\")\n+                    .span_label(expr.value.span, \"...cannot be constrained to this value\")\n+                    .emit();\n+            }\n+            Some(GenericArg::Lifetime(lt)) => {\n+                self.struct_span_err(span, \"associated lifetimes are not supported\")\n+                    .span_label(lt.ident.span, \"the lifetime is given here\")\n+                    .help(\"if you meant to specify a trait object, write `dyn Trait + 'lifetime`\")\n+                    .emit();\n+            }\n+            None => {\n+                let after_eq = eq.shrink_to_hi();\n+                let before_next = self.token.span.shrink_to_lo();\n+                self.struct_span_err(after_eq.to(before_next), \"missing type to the right of `=`\")\n+                    .span_suggestion(\n+                        self.sess.source_map().next_point(eq).to(before_next),\n+                        \"to constrain the associated type, add a type after `=`\",\n+                        \" TheType\".to_string(),\n+                        Applicability::HasPlaceholders,\n+                    )\n+                    .span_suggestion(\n+                        eq.to(before_next),\n+                        &format!(\"remove the `=` if `{}` is a type\", ident),\n+                        String::new(),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n             }\n-            err.emit();\n         }\n+        Ok(self.mk_ty(span, ast::TyKind::Err))\n+    }\n \n-        Ok((args, constraints))\n+    /// Parse a generic argument in a path segment.\n+    /// This does not include constraints, e.g., `Item = u8`, which is handled in `parse_angle_arg`.\n+    fn parse_generic_arg(&mut self) -> PResult<'a, Option<GenericArg>> {\n+        let arg = if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n+            // Parse lifetime argument.\n+            GenericArg::Lifetime(self.expect_lifetime())\n+        } else if self.check_const_arg() {\n+            // Parse const argument.\n+            let expr = if let token::OpenDelim(token::Brace) = self.token.kind {\n+                self.parse_block_expr(\n+                    None,\n+                    self.token.span,\n+                    BlockCheckMode::Default,\n+                    ast::AttrVec::new(),\n+                )?\n+            } else if self.token.is_ident() {\n+                // FIXME(const_generics): to distinguish between idents for types and consts,\n+                // we should introduce a GenericArg::Ident in the AST and distinguish when\n+                // lowering to the HIR. For now, idents for const args are not permitted.\n+                if self.token.is_bool_lit() {\n+                    self.parse_literal_maybe_minus()?\n+                } else {\n+                    let span = self.token.span;\n+                    let msg = \"identifiers may currently not be used for const generics\";\n+                    self.struct_span_err(span, msg).emit();\n+                    let block = self.mk_block_err(span);\n+                    self.mk_expr(span, ast::ExprKind::Block(block, None), ast::AttrVec::new())\n+                }\n+            } else {\n+                self.parse_literal_maybe_minus()?\n+            };\n+            GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value: expr })\n+        } else if self.check_type() {\n+            // Parse type argument.\n+            GenericArg::Type(self.parse_ty()?)\n+        } else {\n+            return Ok(None);\n+        };\n+        Ok(Some(arg))\n     }\n }"}, {"sha": "e5637e4e6e694f3ef624904eaba7d840d964dfc1", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -783,7 +783,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 match **generic_args {\n                     ast::GenericArgs::AngleBracketed(ref data) => {\n                         for arg in &data.args {\n-                            if let ast::GenericArg::Type(ty) = arg {\n+                            if let ast::AngleBracketedArg::Arg(ast::GenericArg::Type(ty)) = arg {\n                                 self.visit_ty(ty);\n                             }\n                         }\n@@ -849,7 +849,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n                 for arg in &data.args {\n                     match arg {\n-                        ast::GenericArg::Type(ty) => self.visit_ty(ty),\n+                        ast::AngleBracketedArg::Arg(ast::GenericArg::Type(ty)) => self.visit_ty(ty),\n                         _ => {}\n                     }\n                 }"}, {"sha": "afbd13e6fd9a8103bbf27b13a9eb372303b4120b", "filename": "src/test/ui/parser/constraints-before-generic-args-syntactic-pass.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+#[cfg(FALSE)]\n+fn syntax() {\n+    foo::<T = u8, T: Ord, String>();\n+    foo::<T = u8, 'a, T: Ord>();\n+}\n+\n+fn main() {}"}, {"sha": "1379eeb58e6e861c87fc0c175c415739ad097d9d", "filename": "src/test/ui/parser/issue-32214.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Fissue-32214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Fissue-32214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32214.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -1,6 +1,6 @@\n trait Trait<T> { type Item; }\n \n pub fn test<W, I: Trait<Item=(), W> >() {}\n-//~^ ERROR associated type bindings must be declared after generic parameters\n+//~^ ERROR generic arguments must come before the first constraint\n \n fn main() { }"}, {"sha": "742f4fdc38bbdd40ccb659c6ea1524b9c77f6624", "filename": "src/test/ui/parser/issue-32214.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Fissue-32214.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Fissue-32214.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32214.stderr?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -1,10 +1,10 @@\n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/issue-32214.rs:3:25\n+error: generic arguments must come before the first constraint\n+  --> $DIR/issue-32214.rs:3:34\n    |\n LL | pub fn test<W, I: Trait<Item=(), W> >() {}\n-   |                         -------^^^\n+   |                         -------  ^ generic argument\n    |                         |\n-   |                         this associated type binding should be moved after the generic parameters\n+   |                         the first constraint is provided here\n \n error: aborting due to previous error\n "}, {"sha": "06be3cdcc1a9528dd58d472dcedb5a477f5e7dc7", "filename": "src/test/ui/parser/recover-assoc-const-constraint.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -0,0 +1,7 @@\n+#[cfg(FALSE)]\n+fn syntax() {\n+    bar::<Item = 42>(); //~ ERROR cannot constrain an associated constant to a value\n+    bar::<Item = { 42 }>(); //~ ERROR cannot constrain an associated constant to a value\n+}\n+\n+fn main() {}"}, {"sha": "c6733b33faa58072d1cff7a65dba2549687aec34", "filename": "src/test/ui/parser/recover-assoc-const-constraint.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-const-constraint.stderr?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -0,0 +1,20 @@\n+error: cannot constrain an associated constant to a value\n+  --> $DIR/recover-assoc-const-constraint.rs:3:11\n+   |\n+LL |     bar::<Item = 42>();\n+   |           ----^^^--\n+   |           |      |\n+   |           |      ...cannot be constrained to this value\n+   |           this associated constant...\n+\n+error: cannot constrain an associated constant to a value\n+  --> $DIR/recover-assoc-const-constraint.rs:4:11\n+   |\n+LL |     bar::<Item = { 42 }>();\n+   |           ----^^^------\n+   |           |      |\n+   |           |      ...cannot be constrained to this value\n+   |           this associated constant...\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4b42c44dc64e57d80ead836170bcec9b3b20b0d7", "filename": "src/test/ui/parser/recover-assoc-eq-missing-term.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-eq-missing-term.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-eq-missing-term.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-eq-missing-term.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -0,0 +1,6 @@\n+#[cfg(FALSE)]\n+fn syntax() {\n+    bar::<Item =   >(); //~ ERROR missing type to the right of `=`\n+}\n+\n+fn main() {}"}, {"sha": "6e41e139220aeb058a5150a1f3b77e417cb7e367", "filename": "src/test/ui/parser/recover-assoc-eq-missing-term.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-eq-missing-term.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-eq-missing-term.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-eq-missing-term.stderr?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -0,0 +1,17 @@\n+error: missing type to the right of `=`\n+  --> $DIR/recover-assoc-eq-missing-term.rs:3:17\n+   |\n+LL |     bar::<Item =   >();\n+   |                 ^^^\n+   |\n+help: to constrain the associated type, add a type after `=`\n+   |\n+LL |     bar::<Item = TheType>();\n+   |                  ^^^^^^^\n+help: remove the `=` if `Item` is a type\n+   |\n+LL |     bar::<Item >();\n+   |               --\n+\n+error: aborting due to previous error\n+"}, {"sha": "558fcdfe1776f9358074caa1ff9191401f35de1c", "filename": "src/test/ui/parser/recover-assoc-lifetime-constraint.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-lifetime-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-lifetime-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-lifetime-constraint.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -0,0 +1,6 @@\n+#[cfg(FALSE)]\n+fn syntax() {\n+    bar::<Item = 'a>(); //~ ERROR associated lifetimes are not supported\n+}\n+\n+fn main() {}"}, {"sha": "79437533d7c0b497415f9281d18be2fa89a94401", "filename": "src/test/ui/parser/recover-assoc-lifetime-constraint.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-lifetime-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-lifetime-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-assoc-lifetime-constraint.stderr?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -0,0 +1,12 @@\n+error: associated lifetimes are not supported\n+  --> $DIR/recover-assoc-lifetime-constraint.rs:3:11\n+   |\n+LL |     bar::<Item = 'a>();\n+   |           ^^^^^^^--\n+   |                  |\n+   |                  the lifetime is given here\n+   |\n+   = help: if you meant to specify a trait object, write `dyn Trait + 'lifetime`\n+\n+error: aborting due to previous error\n+"}, {"sha": "27930626a6209c52f601e5b316d65229a8bbb5bb", "filename": "src/test/ui/suggestions/suggest-move-types.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.rs?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-linelength\n-\n #![allow(warnings)]\n \n // This test verifies that the suggestion to move types before associated type bindings\n@@ -25,60 +23,64 @@ trait ThreeWithLifetime<'a, 'b, 'c, T, U, V> {\n   type C;\n }\n \n-struct A<T, M: One<A=(), T>> { //~ ERROR associated type bindings must be declared after generic parameters\n+struct A<T, M: One<A=(), T>> {\n+//~^ ERROR generic arguments must come before the first constraint\n     m: M,\n     t: T,\n }\n \n \n struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n-//~^ ERROR associated type bindings must be declared after generic parameters\n+//~^ ERROR generic arguments must come before the first constraint\n //~^^ ERROR type provided when a lifetime was expected\n     m: M,\n     t: &'a T,\n }\n \n-struct B<T, U, V, M: Three<A=(), B=(), C=(), T, U, V>> { //~ ERROR associated type bindings must be declared after generic parameters\n+struct B<T, U, V, M: Three<A=(), B=(), C=(), T, U, V>> {\n+//~^ ERROR generic arguments must come before the first constraint\n     m: M,\n     t: T,\n     u: U,\n     v: V,\n }\n \n struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U, V, 'a, 'b, 'c>> {\n-//~^ ERROR associated type bindings must be declared after generic parameters\n+//~^ ERROR generic arguments must come before the first constraint\n //~^^ ERROR type provided when a lifetime was expected\n     m: M,\n     t: &'a T,\n     u: &'b U,\n     v: &'c V,\n }\n \n-struct C<T, U, V, M: Three<T, A=(), B=(), C=(), U, V>> { //~ ERROR associated type bindings must be declared after generic parameters\n+struct C<T, U, V, M: Three<T, A=(), B=(), C=(), U, V>> {\n+//~^ ERROR generic arguments must come before the first constraint\n     m: M,\n     t: T,\n     u: U,\n     v: V,\n }\n \n struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=(), U, 'b, V, 'c>> {\n-//~^ ERROR associated type bindings must be declared after generic parameters\n+//~^ ERROR generic arguments must come before the first constraint\n //~^^ ERROR lifetime provided when a type was expected\n     m: M,\n     t: &'a T,\n     u: &'b U,\n     v: &'c V,\n }\n \n-struct D<T, U, V, M: Three<T, A=(), B=(), U, C=(), V>> { //~ ERROR associated type bindings must be declared after generic parameters\n+struct D<T, U, V, M: Three<T, A=(), B=(), U, C=(), V>> {\n+//~^ ERROR generic arguments must come before the first constraint\n     m: M,\n     t: T,\n     u: U,\n     v: V,\n }\n \n struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, 'b, C=(), V, 'c>> {\n-//~^ ERROR associated type bindings must be declared after generic parameters\n+//~^ ERROR generic arguments must come before the first constraint\n //~^^ ERROR lifetime provided when a type was expected\n     m: M,\n     t: &'a T,"}, {"sha": "4dd0613757a959bddbf352dea2aaf352abd826f5", "filename": "src/test/ui/suggestions/suggest-move-types.stderr", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9d5ee567652cd342d9348c215009049551747b0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-move-types.stderr?ref=b9d5ee567652cd342d9348c215009049551747b0", "patch": "@@ -1,81 +1,85 @@\n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:28:20\n+error: generic arguments must come before the first constraint\n+  --> $DIR/suggest-move-types.rs:26:26\n    |\n LL | struct A<T, M: One<A=(), T>> {\n-   |                    ----^^^\n+   |                    ----  ^ generic argument\n    |                    |\n-   |                    this associated type binding should be moved after the generic parameters\n+   |                    the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:34:37\n+error: generic arguments must come before the first constraint\n+  --> $DIR/suggest-move-types.rs:33:43\n    |\n LL | struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n-   |                                     ----^^^^^^^\n-   |                                     |\n-   |                                     this associated type binding should be moved after the generic parameters\n+   |                                     ----  ^  ^^ generic argument\n+   |                                     |     |\n+   |                                     |     generic argument\n+   |                                     the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:41:28\n+error: generic arguments must come before the first constraint\n+  --> $DIR/suggest-move-types.rs:40:46\n    |\n LL | struct B<T, U, V, M: Three<A=(), B=(), C=(), T, U, V>> {\n-   |                            ----^^----^^----^^^^^^^^^\n-   |                            |     |     |\n-   |                            |     |     this associated type binding should be moved after the generic parameters\n-   |                            |     this associated type binding should be moved after the generic parameters\n-   |                            this associated type binding should be moved after the generic parameters\n+   |                            ----              ^  ^  ^ generic argument\n+   |                            |                 |  |\n+   |                            |                 |  generic argument\n+   |                            |                 generic argument\n+   |                            the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:48:53\n+error: generic arguments must come before the first constraint\n+  --> $DIR/suggest-move-types.rs:48:71\n    |\n LL | struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U, V, 'a, 'b, 'c>> {\n-   |                                                     ----^^----^^----^^^^^^^^^^^^^^^^^^^^^\n-   |                                                     |     |     |\n-   |                                                     |     |     this associated type binding should be moved after the generic parameters\n-   |                                                     |     this associated type binding should be moved after the generic parameters\n-   |                                                     this associated type binding should be moved after the generic parameters\n+   |                                                     ----              ^  ^  ^  ^^  ^^  ^^ generic argument\n+   |                                                     |                 |  |  |  |   |\n+   |                                                     |                 |  |  |  |   generic argument\n+   |                                                     |                 |  |  |  generic argument\n+   |                                                     |                 |  |  generic argument\n+   |                                                     |                 |  generic argument\n+   |                                                     |                 generic argument\n+   |                                                     the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:57:28\n+error: generic arguments must come before the first constraint\n+  --> $DIR/suggest-move-types.rs:57:49\n    |\n LL | struct C<T, U, V, M: Three<T, A=(), B=(), C=(), U, V>> {\n-   |                            ^^^----^^----^^----^^^^^^\n-   |                               |     |     |\n-   |                               |     |     this associated type binding should be moved after the generic parameters\n-   |                               |     this associated type binding should be moved after the generic parameters\n-   |                               this associated type binding should be moved after the generic parameters\n+   |                               ----              ^  ^ generic argument\n+   |                               |                 |\n+   |                               |                 generic argument\n+   |                               the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:64:53\n+error: generic arguments must come before the first constraint\n+  --> $DIR/suggest-move-types.rs:65:78\n    |\n LL | struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=(), U, 'b, V, 'c>> {\n-   |                                                     ^^^^^^^----^^----^^----^^^^^^^^^^^^^^\n-   |                                                            |     |     |\n-   |                                                            |     |     this associated type binding should be moved after the generic parameters\n-   |                                                            |     this associated type binding should be moved after the generic parameters\n-   |                                                            this associated type binding should be moved after the generic parameters\n+   |                                                            ----              ^  ^^  ^  ^^ generic argument\n+   |                                                            |                 |  |   |\n+   |                                                            |                 |  |   generic argument\n+   |                                                            |                 |  generic argument\n+   |                                                            |                 generic argument\n+   |                                                            the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:73:28\n+error: generic arguments must come before the first constraint\n+  --> $DIR/suggest-move-types.rs:74:43\n    |\n LL | struct D<T, U, V, M: Three<T, A=(), B=(), U, C=(), V>> {\n-   |                            ^^^----^^----^^^^^----^^^\n-   |                               |     |        |\n-   |                               |     |        this associated type binding should be moved after the generic parameters\n-   |                               |     this associated type binding should be moved after the generic parameters\n-   |                               this associated type binding should be moved after the generic parameters\n+   |                               ----        ^        ^ generic argument\n+   |                               |           |\n+   |                               |           generic argument\n+   |                               the first constraint is provided here\n \n-error: associated type bindings must be declared after generic parameters\n-  --> $DIR/suggest-move-types.rs:80:53\n+error: generic arguments must come before the first constraint\n+  --> $DIR/suggest-move-types.rs:82:72\n    |\n LL | struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, 'b, C=(), V, 'c>> {\n-   |                                                     ^^^^^^^----^^----^^^^^^^^^----^^^^^^^\n-   |                                                            |     |            |\n-   |                                                            |     |            this associated type binding should be moved after the generic parameters\n-   |                                                            |     this associated type binding should be moved after the generic parameters\n-   |                                                            this associated type binding should be moved after the generic parameters\n+   |                                                            ----        ^  ^^        ^  ^^ generic argument\n+   |                                                            |           |  |         |\n+   |                                                            |           |  |         generic argument\n+   |                                                            |           |  generic argument\n+   |                                                            |           generic argument\n+   |                                                            the first constraint is provided here\n \n error[E0747]: type provided when a lifetime was expected\n-  --> $DIR/suggest-move-types.rs:34:43\n+  --> $DIR/suggest-move-types.rs:33:43\n    |\n LL | struct Al<'a, T, M: OneWithLifetime<A=(), T, 'a>> {\n    |                                           ^\n@@ -91,15 +95,15 @@ LL | struct Bl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<A=(), B=(), C=(), T, U,\n    = note: lifetime arguments must be provided before type arguments\n \n error[E0747]: lifetime provided when a type was expected\n-  --> $DIR/suggest-move-types.rs:64:56\n+  --> $DIR/suggest-move-types.rs:65:56\n    |\n LL | struct Cl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), C=(), U, 'b, V, 'c>> {\n    |                                                        ^^\n    |\n    = note: type arguments must be provided before lifetime arguments\n \n error[E0747]: lifetime provided when a type was expected\n-  --> $DIR/suggest-move-types.rs:80:56\n+  --> $DIR/suggest-move-types.rs:82:56\n    |\n LL | struct Dl<'a, 'b, 'c, T, U, V, M: ThreeWithLifetime<T, 'a, A=(), B=(), U, 'b, C=(), V, 'c>> {\n    |                                                        ^^"}]}