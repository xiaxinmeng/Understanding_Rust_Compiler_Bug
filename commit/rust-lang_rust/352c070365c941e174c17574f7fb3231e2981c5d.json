{"sha": "352c070365c941e174c17574f7fb3231e2981c5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MmMwNzAzNjVjOTQxZTE3NGMxNzU3NGY3ZmIzMjMxZTI5ODFjNWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-14T18:22:51Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-19T00:21:14Z"}, "message": "librustc: Convert all uses of old lifetime notation to new lifetime notation. rs=delifetiming", "tree": {"sha": "1621d3e503e0112d7dd11d76baf6f61de77e8717", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1621d3e503e0112d7dd11d76baf6f61de77e8717"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/352c070365c941e174c17574f7fb3231e2981c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/352c070365c941e174c17574f7fb3231e2981c5d", "html_url": "https://github.com/rust-lang/rust/commit/352c070365c941e174c17574f7fb3231e2981c5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/352c070365c941e174c17574f7fb3231e2981c5d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7352d919f62350bd24aefe0f188203ebef833fd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7352d919f62350bd24aefe0f188203ebef833fd5", "html_url": "https://github.com/rust-lang/rust/commit/7352d919f62350bd24aefe0f188203ebef833fd5"}], "stats": {"total": 1024, "additions": 523, "deletions": 501}, "files": [{"sha": "8d3c8561957b0b3571f6b73508755d4544d1b244", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -174,9 +174,9 @@ pub mod traits {\n     use kinds::Copy;\n     use ops::Add;\n \n-    impl<T:Copy> Add<&self/[const T],@[T]> for @[T] {\n+    impl<T:Copy> Add<&'self [const T],@[T]> for @[T] {\n         #[inline(always)]\n-        pure fn add(&self, rhs: & &self/[const T]) -> @[T] {\n+        pure fn add(&self, rhs: & &'self [const T]) -> @[T] {\n             append(*self, (*rhs))\n         }\n     }"}, {"sha": "f752f52ce539247669acce1bca2528a75a018bc5", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -59,17 +59,17 @@ pub unsafe fn transmute<L, G>(thing: L) -> G {\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n-pub unsafe fn transmute_mut<T>(ptr: &a/T) -> &a/mut T { transmute(ptr) }\n+pub unsafe fn transmute_mut<T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }\n \n /// Coerce a mutable reference to be immutable.\n #[inline(always)]\n-pub unsafe fn transmute_immut<T>(ptr: &a/mut T) -> &a/T {\n+pub unsafe fn transmute_immut<T>(ptr: &'a mut T) -> &'a T {\n     transmute(ptr)\n }\n \n /// Coerce a borrowed pointer to have an arbitrary associated region.\n #[inline(always)]\n-pub unsafe fn transmute_region<T>(ptr: &a/T) -> &b/T { transmute(ptr) }\n+pub unsafe fn transmute_region<T>(ptr: &'a T) -> &'b T { transmute(ptr) }\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n@@ -85,19 +85,19 @@ pub unsafe fn transmute_immut_unsafe<T>(ptr: *const T) -> *T {\n \n /// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n #[inline(always)]\n-pub unsafe fn transmute_mut_region<T>(ptr: &a/mut T) -> &b/mut T {\n+pub unsafe fn transmute_mut_region<T>(ptr: &'a mut T) -> &'b mut T {\n     transmute(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n #[inline(always)]\n-pub unsafe fn copy_lifetime<S,T>(_ptr: &a/S, ptr: &T) -> &a/T {\n+pub unsafe fn copy_lifetime<S,T>(_ptr: &'a S, ptr: &T) -> &'a T {\n     transmute_region(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n #[inline(always)]\n-pub unsafe fn copy_lifetime_vec<S,T>(_ptr: &a/[S], ptr: &T) -> &a/T {\n+pub unsafe fn copy_lifetime_vec<S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n     transmute_region(ptr)\n }\n "}, {"sha": "66eeb339700e897cf65c3c325da3a18824315a29", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -22,8 +22,8 @@ use cast::transmute;\n  * NB: These must match the representation in the C++ runtime.\n  */\n \n-type DropGlue = &self/fn(**TypeDesc, *c_void);\n-type FreeGlue = &self/fn(**TypeDesc, *c_void);\n+type DropGlue = &'self fn(**TypeDesc, *c_void);\n+type FreeGlue = &'self fn(**TypeDesc, *c_void);\n \n type TaskID = uintptr_t;\n "}, {"sha": "56b690ca8afd807511f6da82268b4e2595f597b7", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -21,12 +21,12 @@ pub struct Handler<T, U> {\n }\n \n pub struct Condition<T, U> {\n-    name: &static/str,\n+    name: &'static str,\n     key: task::local_data::LocalDataKey/&self<Handler<T, U>>\n }\n \n pub impl<T, U> Condition/&self<T, U> {\n-    fn trap(&self, h: &self/fn(T) -> U) -> Trap/&self<T, U> {\n+    fn trap(&self, h: &'self fn(T) -> U) -> Trap/&self<T, U> {\n         unsafe {\n             let p : *RustClosure = ::cast::transmute(&h);\n             let prev = task::local_data::local_data_get(self.key);\n@@ -65,12 +65,12 @@ pub impl<T, U> Condition/&self<T, U> {\n }\n \n struct Trap<T, U> {\n-    cond: &self/Condition/&self<T, U>,\n+    cond: &'self Condition/&self<T, U>,\n     handler: @Handler<T, U>\n }\n \n pub impl<T, U> Trap/&self<T, U> {\n-    fn in<V>(&self, inner: &self/fn() -> V) -> V {\n+    fn in<V>(&self, inner: &'self fn() -> V) -> V {\n         unsafe {\n             let _g = Guard { cond: self.cond };\n             debug!(\"Trap: pushing handler to TLS\");\n@@ -81,7 +81,7 @@ pub impl<T, U> Trap/&self<T, U> {\n }\n \n struct Guard<T, U> {\n-    cond: &self/Condition/&self<T, U>\n+    cond: &'self Condition/&self<T, U>\n }\n \n impl<T, U> Drop for Guard/&self<T, U> {"}, {"sha": "efcf1e26534c218e7621c14dd634e336b593b94b", "filename": "src/libcore/container.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -39,7 +39,7 @@ pub trait Map<K, V>: Mutable {\n     fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n \n     /// Return the value corresponding to the key in the map\n-    pure fn find(&self, key: &K) -> Option<&self/V>;\n+    pure fn find(&self, key: &K) -> Option<&'self V>;\n \n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did"}, {"sha": "3449c5ff4ba4504d63167a03d48cccfe0db498f6", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -122,7 +122,7 @@ unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n     return None;\n }\n \n-type Visitor = &self/fn(root: **Word, tydesc: *Word) -> bool;\n+type Visitor = &'self fn(root: **Word, tydesc: *Word) -> bool;\n \n // Walks the list of roots for the given safe point, and calls visitor\n // on each root."}, {"sha": "20d207e9302b52da914521a91638be449f501f99", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -185,7 +185,7 @@ pub mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn value_for_bucket(&self, idx: uint) -> &self/V {\n+        pure fn value_for_bucket(&self, idx: uint) -> &'self V {\n             match self.buckets[idx] {\n                 Some(ref bkt) => &bkt.value,\n                 None => fail!(~\"LinearMap::find: internal logic error\"),\n@@ -270,10 +270,10 @@ pub mod linear {\n     }\n \n     impl<K:Hash + IterBytes + Eq,V>\n-        BaseIter<(&self/K, &self/V)> for LinearMap<K, V>\n+        BaseIter<(&'self K, &'self V)> for LinearMap<K, V>\n     {\n         /// Visit all key-value pairs\n-        pure fn each(&self, blk: &fn(&(&self/K, &self/V)) -> bool) {\n+        pure fn each(&self, blk: &fn(&(&'self K, &'self V)) -> bool) {\n             for uint::range(0, self.buckets.len()) |i| {\n                 let mut broke = false;\n                 do self.buckets[i].map |bucket| {\n@@ -339,7 +339,7 @@ pub mod linear {\n         }\n \n         /// Return the value corresponding to the key in the map\n-        pure fn find(&self, k: &K) -> Option<&self/V> {\n+        pure fn find(&self, k: &K) -> Option<&'self V> {\n             match self.bucket_for_key(k) {\n                 FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n                 TableFull | FoundHole(_) => None,\n@@ -412,7 +412,7 @@ pub mod linear {\n \n         /// Return the value corresponding to the key in the map, or insert\n         /// and return the value if it doesn't exist.\n-        fn find_or_insert(&mut self, k: K, v: V) -> &self/V {\n+        fn find_or_insert(&mut self, k: K, v: V) -> &'self V {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n                 // that we do not resize if this call to insert is\n@@ -442,7 +442,7 @@ pub mod linear {\n \n         /// Return the value corresponding to the key in the map, or create,\n         /// insert, and return a new value if it doesn't exist.\n-        fn find_or_insert_with(&mut self, k: K, f: &fn(&K) -> V) -> &self/V {\n+        fn find_or_insert_with(&mut self, k: K, f: &fn(&K) -> V) -> &'self V {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n                 // that we do not resize if this call to insert is\n@@ -487,7 +487,7 @@ pub mod linear {\n             }\n         }\n \n-        pure fn get(&self, k: &K) -> &self/V {\n+        pure fn get(&self, k: &K) -> &'self V {\n             match self.find(k) {\n                 Some(v) => v,\n                 None => fail!(fmt!(\"No entry found for key: %?\", k)),\n@@ -509,7 +509,7 @@ pub mod linear {\n         /// Return the value corresponding to the key in the map, using\n         /// equivalence\n         pure fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n-                                                       -> Option<&self/V> {\n+                                                       -> Option<&'self V> {\n             match self.bucket_for_key_equiv(k) {\n                 FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n                 TableFull | FoundHole(_) => None,"}, {"sha": "dcb9e23b45b29f6c0667ab81793ee954969e8741", "filename": "src/libcore/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -589,7 +589,7 @@ pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n \n // Byte readers\n pub struct BytesReader {\n-    bytes: &self/[u8],\n+    bytes: &'self [u8],\n     mut pos: uint\n }\n "}, {"sha": "816dc6d22554f1f8a51970d95425cc5564c0c570", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -20,7 +20,7 @@ use option::{None, Option, Some};\n use vec;\n \n /// A function used to initialize the elements of a sequence\n-pub type InitOp<T> = &self/fn(uint) -> T;\n+pub type InitOp<T> = &'self fn(uint) -> T;\n \n pub trait BaseIter<A> {\n     pure fn each(&self, blk: &fn(v: &A) -> bool);"}, {"sha": "237fc762b3c5340af799c3c85e138d2a33a3ed8a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -122,7 +122,7 @@ pub pure fn get<T:Copy>(opt: Option<T>) -> T {\n }\n \n #[inline(always)]\n-pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n+pub pure fn get_ref<T>(opt: &'r Option<T>) -> &'r T {\n     /*!\n     Gets an immutable reference to the value inside an option.\n \n@@ -143,7 +143,7 @@ pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     }\n }\n \n-pub pure fn get_mut_ref<T>(opt: &r/mut Option<T>) -> &r/mut T {\n+pub pure fn get_mut_ref<T>(opt: &'r mut Option<T>) -> &'r mut T {\n     /*!\n     Gets a mutable reference to the value inside an option.\n \n@@ -165,7 +165,7 @@ pub pure fn get_mut_ref<T>(opt: &r/mut Option<T>) -> &r/mut T {\n }\n \n #[inline(always)]\n-pub pure fn map<T, U>(opt: &r/Option<T>, f: &fn(x: &r/T) -> U) -> Option<U> {\n+pub pure fn map<T, U>(opt: &'r Option<T>, f: &fn(x: &'r T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n     match *opt { Some(ref x) => Some(f(x)), None => None }\n@@ -256,8 +256,8 @@ pub pure fn get_or_default<T:Copy>(opt: Option<T>, def: T) -> T {\n }\n \n #[inline(always)]\n-pub pure fn map_default<T, U>(opt: &r/Option<T>, def: U,\n-                              f: &fn(&r/T) -> U) -> U {\n+pub pure fn map_default<T, U>(opt: &'r Option<T>, def: U,\n+                              f: &fn(&'r T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n     match *opt { None => def, Some(ref t) => f(t) }\n@@ -313,7 +313,7 @@ pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n     #[inline(always)]\n-    pure fn each(&self, f: &fn(x: &self/T) -> bool) {\n+    pure fn each(&self, f: &fn(x: &'self T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n     }\n \n@@ -350,7 +350,7 @@ pub impl<T> Option<T> {\n \n     /// Maps a `some` value from one type to another by reference\n     #[inline(always)]\n-    pure fn map<U>(&self, f: &fn(&self/T) -> U) -> Option<U> { map(self, f) }\n+    pure fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> { map(self, f) }\n \n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n@@ -361,7 +361,7 @@ pub impl<T> Option<T> {\n \n     /// Applies a function to the contained value or returns a default\n     #[inline(always)]\n-    pure fn map_default<U>(&self, def: U, f: &fn(&self/T) -> U) -> U {\n+    pure fn map_default<U>(&self, def: U, f: &fn(&'self T) -> U) -> U {\n         map_default(self, def, f)\n     }\n \n@@ -403,7 +403,7 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    pure fn get_ref(&self) -> &self/T { get_ref(self) }\n+    pure fn get_ref(&self) -> &'self T { get_ref(self) }\n \n     /**\n     Gets a mutable reference to the value inside an option.\n@@ -420,7 +420,7 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    pure fn get_mut_ref(&mut self) -> &self/mut T { get_mut_ref(self) }\n+    pure fn get_mut_ref(&mut self) -> &'self mut T { get_mut_ref(self) }\n \n     /**\n      * Gets the value out of an option without copying."}, {"sha": "17ec9df9d5690f0f69dab344dcefa351ea183b29", "filename": "src/libcore/os.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -1170,11 +1170,11 @@ pub mod consts {\n     pub use os::consts::windows::*;\n \n     pub mod unix {\n-        pub const FAMILY: &static/str = \"unix\";\n+        pub const FAMILY: &'static str = \"unix\";\n     }\n \n     pub mod windows {\n-        pub const FAMILY: &static/str = \"windows\";\n+        pub const FAMILY: &'static str = \"windows\";\n     }\n \n     #[cfg(target_os = \"macos\")]\n@@ -1193,38 +1193,38 @@ pub mod consts {\n     pub use os::consts::win32::*;\n \n     pub mod macos {\n-        pub const SYSNAME: &static/str = \"macos\";\n-        pub const DLL_PREFIX: &static/str = \"lib\";\n-        pub const DLL_SUFFIX: &static/str = \".dylib\";\n-        pub const EXE_SUFFIX: &static/str = \"\";\n+        pub const SYSNAME: &'static str = \"macos\";\n+        pub const DLL_PREFIX: &'static str = \"lib\";\n+        pub const DLL_SUFFIX: &'static str = \".dylib\";\n+        pub const EXE_SUFFIX: &'static str = \"\";\n     }\n \n     pub mod freebsd {\n-        pub const SYSNAME: &static/str = \"freebsd\";\n-        pub const DLL_PREFIX: &static/str = \"lib\";\n-        pub const DLL_SUFFIX: &static/str = \".so\";\n-        pub const EXE_SUFFIX: &static/str = \"\";\n+        pub const SYSNAME: &'static str = \"freebsd\";\n+        pub const DLL_PREFIX: &'static str = \"lib\";\n+        pub const DLL_SUFFIX: &'static str = \".so\";\n+        pub const EXE_SUFFIX: &'static str = \"\";\n     }\n \n     pub mod linux {\n-        pub const SYSNAME: &static/str = \"linux\";\n-        pub const DLL_PREFIX: &static/str = \"lib\";\n-        pub const DLL_SUFFIX: &static/str = \".so\";\n-        pub const EXE_SUFFIX: &static/str = \"\";\n+        pub const SYSNAME: &'static str = \"linux\";\n+        pub const DLL_PREFIX: &'static str = \"lib\";\n+        pub const DLL_SUFFIX: &'static str = \".so\";\n+        pub const EXE_SUFFIX: &'static str = \"\";\n     }\n \n     pub mod android {\n-        pub const SYSNAME: &static/str = \"android\";\n-        pub const DLL_PREFIX: &static/str = \"lib\";\n-        pub const DLL_SUFFIX: &static/str = \".so\";\n-        pub const EXE_SUFFIX: &static/str = \"\";\n+        pub const SYSNAME: &'static str = \"android\";\n+        pub const DLL_PREFIX: &'static str = \"lib\";\n+        pub const DLL_SUFFIX: &'static str = \".so\";\n+        pub const EXE_SUFFIX: &'static str = \"\";\n     }\n \n     pub mod win32 {\n-        pub const SYSNAME: &static/str = \"win32\";\n-        pub const DLL_PREFIX: &static/str = \"\";\n-        pub const DLL_SUFFIX: &static/str = \".dll\";\n-        pub const EXE_SUFFIX: &static/str = \".exe\";\n+        pub const SYSNAME: &'static str = \"win32\";\n+        pub const DLL_PREFIX: &'static str = \"\";\n+        pub const DLL_SUFFIX: &'static str = \".dll\";\n+        pub const EXE_SUFFIX: &'static str = \".exe\";\n     }\n \n "}, {"sha": "eb385d9035450455c81bd3b1f4e47eab0d92576e", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -446,7 +446,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     let p = unsafe { &*p_ };\n \n     struct DropState {\n-        p: &self/PacketHeader,\n+        p: &'self PacketHeader,\n \n         drop {\n             if task::failing() {"}, {"sha": "481a61f4ab71d54ec1265f6c564cc332cc511533", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -178,7 +178,7 @@ pub pure fn to_uint<T>(thing: &T) -> uint {\n \n /// Determine if two borrowed pointers point to the same thing.\n #[inline(always)]\n-pub pure fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n+pub pure fn ref_eq<T>(thing: &'a T, other: &'b T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n \n@@ -312,34 +312,34 @@ impl<T> Ord for *const T {\n \n // Equality for region pointers\n #[cfg(notest)]\n-impl<T:Eq> Eq for &self/const T {\n+impl<T:Eq> Eq for &'self const T {\n     #[inline(always)]\n-    pure fn eq(&self, other: & &self/const T) -> bool {\n+    pure fn eq(&self, other: & &'self const T) -> bool {\n         return *(*self) == *(*other);\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: & &self/const T) -> bool {\n+    pure fn ne(&self, other: & &'self const T) -> bool {\n         return *(*self) != *(*other);\n     }\n }\n \n // Comparison for region pointers\n #[cfg(notest)]\n-impl<T:Ord> Ord for &self/const T {\n+impl<T:Ord> Ord for &'self const T {\n     #[inline(always)]\n-    pure fn lt(&self, other: & &self/const T) -> bool {\n+    pure fn lt(&self, other: & &'self const T) -> bool {\n         *(*self) < *(*other)\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: & &self/const T) -> bool {\n+    pure fn le(&self, other: & &'self const T) -> bool {\n         *(*self) <= *(*other)\n     }\n     #[inline(always)]\n-    pure fn ge(&self, other: & &self/const T) -> bool {\n+    pure fn ge(&self, other: & &'self const T) -> bool {\n         *(*self) >= *(*other)\n     }\n     #[inline(always)]\n-    pure fn gt(&self, other: & &self/const T) -> bool {\n+    pure fn gt(&self, other: & &'self const T) -> bool {\n         *(*self) > *(*other)\n     }\n }"}, {"sha": "a0f9fa7e08e4ae95fc50cc89307d16d0e01cae9a", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -214,9 +214,9 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_estr_slice(&self) -> bool {\n-        self.align_to::<&static/str>();\n+        self.align_to::<&'static str>();\n         if ! self.inner.visit_estr_slice() { return false; }\n-        self.bump_past::<&static/str>();\n+        self.bump_past::<&'static str>();\n         true\n     }\n \n@@ -251,9 +251,9 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&static/u8>();\n+        self.align_to::<&'static u8>();\n         if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n-        self.bump_past::<&static/u8>();\n+        self.bump_past::<&'static u8>();\n         true\n     }\n \n@@ -285,9 +285,9 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&static/[u8]>();\n+        self.align_to::<&'static [u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n-        self.bump_past::<&static/[u8]>();\n+        self.bump_past::<&'static [u8]>();\n         true\n     }\n \n@@ -465,9 +465,9 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_self(&self) -> bool {\n-        self.align_to::<&static/u8>();\n+        self.align_to::<&'static u8>();\n         if ! self.inner.visit_self() { return false; }\n-        self.align_to::<&static/u8>();\n+        self.align_to::<&'static u8>();\n         true\n     }\n "}, {"sha": "832071a0ba81b086c949ce9a427d03ecbbc9b022", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -53,7 +53,7 @@ pub pure fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n  * If the result is an error\n  */\n #[inline(always)]\n-pub pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n+pub pure fn get_ref<T, U>(res: &'a Result<T, U>) -> &'a T {\n     match *res {\n         Ok(ref t) => t,\n         Err(ref the_err) => unsafe {\n@@ -229,7 +229,7 @@ pub pure fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n \n pub impl<T, E> Result<T, E> {\n     #[inline(always)]\n-    pure fn get_ref(&self) -> &self/T { get_ref(self) }\n+    pure fn get_ref(&self) -> &'self T { get_ref(self) }\n \n     #[inline(always)]\n     pure fn is_ok(&self) -> bool { is_ok(self) }"}, {"sha": "55e062de85b06054783f6104a14d538e5c662e77", "filename": "src/libcore/rt/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Frt%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Frt%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -22,7 +22,7 @@ pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n     /// The asynchronous I/O services. Not all event loops may provide one\n-    fn io(&mut self) -> Option<&self/mut IoFactoryObject>;\n+    fn io(&mut self) -> Option<&'self mut IoFactoryObject>;\n }\n \n pub trait IoFactory {"}, {"sha": "69cbbdd2ad438c453bb46046de691de73d0c163d", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -265,12 +265,12 @@ pub impl Scheduler {\n         }\n     }\n \n-    // XXX: Hack. This should return &self/mut but I don't know how to\n+    // XXX: Hack. This should return &'self mut but I don't know how to\n     // make the borrowcheck happy\n     fn task_from_last_cleanup_job(&mut self) -> &mut Task {\n         fail_unless!(!self.cleanup_jobs.is_empty());\n-        let last_job: &self/mut CleanupJob = &mut self.cleanup_jobs[0];\n-        let last_task: &self/Task = match last_job {\n+        let last_job: &'self mut CleanupJob = &mut self.cleanup_jobs[0];\n+        let last_task: &'self Task = match last_job {\n             &RescheduleTask(~ref task) => task,\n             &RecycleTask(~ref task) => task,\n             &GiveTask(~ref task, _) => task,\n@@ -356,7 +356,7 @@ impl ThreadLocalScheduler {\n         }\n     }\n \n-    fn get_scheduler(&mut self) -> &self/mut Scheduler {\n+    fn get_scheduler(&mut self) -> &'self mut Scheduler {\n         unsafe {\n             let key = match self { &ThreadLocalScheduler(key) => key };\n             let mut value: *mut c_void = tls::get(key);"}, {"sha": "80224fa523a9eacc623a8937da84b32ee1ea1951", "filename": "src/libcore/rt/uv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Frt%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Frt%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -659,7 +659,7 @@ fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n }\n \n fn get_watcher_data<H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &r/mut W) -> &r/mut WatcherData {\n+    watcher: &'r mut W) -> &'r mut WatcherData {\n \n     unsafe {\n         let data = uvll::get_data_for_uv_handle(watcher.native_handle());"}, {"sha": "a971ed92b7ebc87c3346e4aa01b46433ee8f3adb", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -69,7 +69,7 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n-    fn io(&mut self) -> Option<&self/mut IoFactoryObject> {\n+    fn io(&mut self) -> Option<&'self mut IoFactoryObject> {\n         Some(&mut self.uvio)\n     }\n }\n@@ -91,7 +91,7 @@ fn test_callback_run_once() {\n pub struct UvIoFactory(Loop);\n \n pub impl UvIoFactory {\n-    fn uv_loop(&mut self) -> &self/mut Loop {\n+    fn uv_loop(&mut self) -> &'self mut Loop {\n         match self { &UvIoFactory(ref mut ptr) => ptr }\n     }\n }"}, {"sha": "3d591af6d3c43647fa67ce7e67ec1bedce4cd73f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -279,7 +279,7 @@ pub fn shift_char(s: &mut ~str) -> char {\n  * If the string does not contain any characters\n  */\n #[inline]\n-pub fn view_shift_char(s: &a/str) -> (char, &a/str) {\n+pub fn view_shift_char(s: &'a str) -> (char, &'a str) {\n     let CharRange {ch, next} = char_range_at(s, 0u);\n     let next_s = unsafe { raw::view_bytes(s, next, len(s)) };\n     return (ch, next_s);\n@@ -429,7 +429,7 @@ pub pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n  * Fails when `begin` and `end` do not point to valid characters or beyond\n  * the last character of the string\n  */\n-pub pure fn view(s: &a/str, begin: uint, end: uint) -> &a/str {\n+pub pure fn view(s: &'a str, begin: uint, end: uint) -> &'a str {\n     fail_unless!(is_char_boundary(s, begin));\n     fail_unless!(is_char_boundary(s, end));\n     unsafe { raw::view_bytes(s, begin, end) }\n@@ -530,7 +530,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-pure fn iter_matches(s: &a/str, sep: &b/str, f: &fn(uint, uint)) {\n+pure fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     fail_unless!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -557,7 +557,7 @@ pure fn iter_matches(s: &a/str, sep: &b/str, f: &fn(uint, uint)) {\n     }\n }\n \n-pure fn iter_between_matches(s: &a/str, sep: &b/str, f: &fn(uint, uint)) {\n+pure fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n     let mut last_end = 0u;\n     do iter_matches(s, sep) |from, to| {\n         f(last_end, from);\n@@ -575,15 +575,15 @@ pure fn iter_between_matches(s: &a/str, sep: &b/str, f: &fn(uint, uint)) {\n  * fail_unless!([\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\"))\n  * ~~~\n  */\n-pub pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n+pub pure fn split_str(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         unsafe { result.push(raw::slice_bytes(s, from, to)); }\n     }\n     result\n }\n \n-pub pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n+pub pure fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n@@ -792,7 +792,7 @@ pure fn cmp(a: &str, b: &str) -> Ordering {\n \n #[cfg(notest)]\n impl TotalOrd for &'self str {\n-    pure fn cmp(&self, other: & &self/str) -> Ordering { cmp(*self, *other) }\n+    pure fn cmp(&self, other: & &'self str) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n@@ -837,13 +837,13 @@ pure fn gt(a: &str, b: &str) -> bool {\n }\n \n #[cfg(notest)]\n-impl Eq for &self/str {\n+impl Eq for &'self str {\n     #[inline(always)]\n-    pure fn eq(&self, other: & &self/str) -> bool {\n+    pure fn eq(&self, other: & &'self str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    pure fn ne(&self, other: & &self/str) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n@@ -879,15 +879,15 @@ impl Ord for ~str {\n }\n \n #[cfg(notest)]\n-impl Ord for &self/str {\n+impl Ord for &'self str {\n     #[inline(always)]\n-    pure fn lt(&self, other: & &self/str) -> bool { lt((*self), (*other)) }\n+    pure fn lt(&self, other: & &'self str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: & &self/str) -> bool { le((*self), (*other)) }\n+    pure fn le(&self, other: & &'self str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: & &self/str) -> bool { ge((*self), (*other)) }\n+    pure fn ge(&self, other: & &'self str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: & &self/str) -> bool { gt((*self), (*other)) }\n+    pure fn gt(&self, other: & &'self str) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n@@ -1348,7 +1348,7 @@ pub pure fn rfind_between(s: &str, start: uint, end: uint,\n }\n \n // Utility used by various searching functions\n-pure fn match_at(haystack: &a/str, needle: &b/str, at: uint) -> bool {\n+pure fn match_at(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     let mut i = at;\n     for each(needle) |c| { if haystack[i] != c { return false; } i += 1u; }\n     return true;\n@@ -1367,7 +1367,7 @@ pure fn match_at(haystack: &a/str, needle: &b/str, at: uint) -> bool {\n  * An `option` containing the byte index of the first matching substring\n  * or `none` if there is no match\n  */\n-pub pure fn find_str(haystack: &a/str, needle: &b/str) -> Option<uint> {\n+pub pure fn find_str(haystack: &'a str, needle: &'b str) -> Option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1390,7 +1390,7 @@ pub pure fn find_str(haystack: &a/str, needle: &b/str) -> Option<uint> {\n  *\n  * `start` must be less than or equal to `len(s)`\n  */\n-pub pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n+pub pure fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n   -> Option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n@@ -1415,7 +1415,7 @@ pub pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n  * `start` must be less than or equal to `end` and `end` must be less than\n  * or equal to `len(s)`.\n  */\n-pub pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n+pub pure fn find_str_between(haystack: &'a str, needle: &'b str, start: uint,\n                          end:uint)\n   -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n@@ -1441,7 +1441,7 @@ pub pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pub pure fn contains(haystack: &a/str, needle: &b/str) -> bool {\n+pub pure fn contains(haystack: &'a str, needle: &'b str) -> bool {\n     find_str(haystack, needle).is_some()\n }\n \n@@ -1465,7 +1465,7 @@ pub pure fn contains_char(haystack: &str, needle: char) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pub pure fn starts_with(haystack: &a/str, needle: &b/str) -> bool {\n+pub pure fn starts_with(haystack: &'a str, needle: &'b str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1480,7 +1480,7 @@ pub pure fn starts_with(haystack: &a/str, needle: &b/str) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pub pure fn ends_with(haystack: &a/str, needle: &b/str) -> bool {\n+pub pure fn ends_with(haystack: &'a str, needle: &'b str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1662,7 +1662,7 @@ pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n }\n \n /// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n-pub pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n+pub pure fn count_bytes(s: &'b str, start: uint, n: uint) -> uint {\n     fail_unless!(is_char_boundary(s, start));\n     let mut end = start, cnt = n;\n     let l = len(s);\n@@ -1905,7 +1905,7 @@ pub pure fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n  *\n  * The byte slice does not include the null terminator.\n  */\n-pub pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n+pub pure fn as_bytes_slice(s: &'a str) -> &'a [u8] {\n     unsafe {\n         let (ptr, len): (*u8, uint) = ::cast::reinterpret_cast(&s);\n         let outgoing_tuple: (*u8, uint) = (ptr, len - 1);\n@@ -2233,9 +2233,9 @@ pub mod traits {\n     use ops::Add;\n     use str::append;\n \n-    impl Add<&self/str,~str> for ~str {\n+    impl Add<&'self str,~str> for ~str {\n         #[inline(always)]\n-        pure fn add(&self, rhs: & &self/str) -> ~str {\n+        pure fn add(&self, rhs: & &'self str) -> ~str {\n             append(copy *self, (*rhs))\n         }\n     }\n@@ -2247,7 +2247,7 @@ pub mod traits {}\n pub trait StrSlice {\n     pure fn all(&self, it: &fn(char) -> bool) -> bool;\n     pure fn any(&self, it: &fn(char) -> bool) -> bool;\n-    pure fn contains(&self, needle: &a/str) -> bool;\n+    pure fn contains(&self, needle: &'a str) -> bool;\n     pure fn contains_char(&self, needle: char) -> bool;\n     pure fn each(&self, it: &fn(u8) -> bool);\n     pure fn eachi(&self, it: &fn(uint, u8) -> bool);\n@@ -2261,8 +2261,8 @@ pub trait StrSlice {\n     pure fn slice(&self, begin: uint, end: uint) -> ~str;\n     pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n     pure fn split_char(&self, sep: char) -> ~[~str];\n-    pure fn split_str(&self, sep: &a/str) -> ~[~str];\n-    pure fn starts_with(&self, needle: &a/str) -> bool;\n+    pure fn split_str(&self, sep: &'a str) -> ~[~str];\n+    pure fn starts_with(&self, needle: &'a str) -> bool;\n     pure fn substr(&self, begin: uint, n: uint) -> ~str;\n     pure fn to_lower(&self) -> ~str;\n     pure fn to_upper(&self) -> ~str;\n@@ -2278,7 +2278,7 @@ pub trait StrSlice {\n }\n \n /// Extension methods for strings\n-impl StrSlice for &self/str {\n+impl StrSlice for &'self str {\n     /**\n      * Return true if a predicate matches all characters or if the string\n      * contains no characters\n@@ -2293,7 +2293,7 @@ impl StrSlice for &self/str {\n     pure fn any(&self, it: &fn(char) -> bool) -> bool { any(*self, it) }\n     /// Returns true if one string contains another\n     #[inline]\n-    pure fn contains(&self, needle: &a/str) -> bool {\n+    pure fn contains(&self, needle: &'a str) -> bool {\n         contains(*self, needle)\n     }\n     /// Returns true if a string contains a char\n@@ -2366,10 +2366,10 @@ impl StrSlice for &self/str {\n      * string\n      */\n     #[inline]\n-    pure fn split_str(&self, sep: &a/str) -> ~[~str] { split_str(*self, sep) }\n+    pure fn split_str(&self, sep: &'a str) -> ~[~str] { split_str(*self, sep) }\n     /// Returns true if one string starts with another\n     #[inline]\n-    pure fn starts_with(&self, needle: &a/str) -> bool {\n+    pure fn starts_with(&self, needle: &'a str) -> bool {\n         starts_with(*self, needle)\n     }\n     /**\n@@ -2612,8 +2612,8 @@ mod tests {\n \n     #[test]\n     fn test_split_str() {\n-        fn t(s: &str, sep: &a/str, i: int, k: &str) {\n-            fn borrow(x: &a/str) -> &a/str { x }\n+        fn t(s: &str, sep: &'a str, i: int, k: &str) {\n+            fn borrow(x: &'a str) -> &'a str { x }\n             let v = split_str(s, sep);\n             fail_unless!(borrow(v[i]) == k);\n         }"}, {"sha": "f7eceeebc1e6242c40add18309ccb8480bf0483b", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -19,7 +19,7 @@ use libc::{c_void, c_char, size_t};\n use repr;\n use str;\n \n-pub type FreeGlue = &self/fn(*TypeDesc, *c_void);\n+pub type FreeGlue = &'self fn(*TypeDesc, *c_void);\n \n // Corresponds to runtime type_desc type\n pub struct TypeDesc {"}, {"sha": "ccd9170947989e4653e579ed1371dadfdf645ca3", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -44,7 +44,7 @@ use task::rt;\n  *\n  * These two cases aside, the interface is safe.\n  */\n-pub type LocalDataKey<T> = &self/fn(v: @T);\n+pub type LocalDataKey<T> = &'self fn(v: @T);\n \n /**\n  * Remove a task-local data value from the table, returning the"}, {"sha": "0fd373b803fb5db012c8552b29a70b0be032b1af", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -123,7 +123,7 @@ struct TaskGroupData {\n }\n type TaskGroupArc = unstable::Exclusive<Option<TaskGroupData>>;\n \n-type TaskGroupInner = &self/mut Option<TaskGroupData>;\n+type TaskGroupInner = &'self mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {"}, {"sha": "e5fbad16717a17fd3c803dfae09961458f3f6684", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -19,7 +19,7 @@ use io::Writer;\n use option::{None, Option, Some};\n use str;\n \n-pub type Cb = &self/fn(buf: &[const u8]) -> bool;\n+pub type Cb = &'self fn(buf: &[const u8]) -> bool;\n \n /**\n  * A trait to implement in order to make a type hashable;\n@@ -197,7 +197,7 @@ impl IterBytes for int {\n     }\n }\n \n-impl<A:IterBytes> IterBytes for &self/[A] {\n+impl<A:IterBytes> IterBytes for &'self [A] {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         for (*self).each |elt| {\n@@ -231,7 +231,7 @@ impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n }\n \n // Move this to vec, probably.\n-pure fn borrow<A>(a: &x/[A]) -> &x/[A] {\n+pure fn borrow<A>(a: &'x [A]) -> &'x [A] {\n     a\n }\n \n@@ -352,7 +352,7 @@ pub pure fn iter_bytes_7<A: IterBytes,\n     g.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-impl IterBytes for &self/str {\n+impl IterBytes for &'self str {\n     #[inline(always)]\n     pure fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n         do str::byte_slice(*self) |bytes| {\n@@ -389,7 +389,7 @@ impl<A:IterBytes> IterBytes for Option<A> {\n     }\n }\n \n-impl<A:IterBytes> IterBytes for &self/A {\n+impl<A:IterBytes> IterBytes for &'self A {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);"}, {"sha": "0f2fd6996044245332e9940c33461dc205a9a2d6", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -32,7 +32,7 @@ impl ToStr for ~str {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str { copy *self }\n }\n-impl ToStr for &self/str {\n+impl ToStr for &'self str {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n }\n@@ -72,7 +72,7 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n     }\n }\n \n-impl<A:ToStr> ToStr for &self/[A] {\n+impl<A:ToStr> ToStr for &'self [A] {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str {\n         unsafe {"}, {"sha": "26532c1a4ff70668e00563ebf946bf8c59b92855", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -32,7 +32,7 @@ pub struct TrieMap<T> {\n impl<T> BaseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in order\n     #[inline(always)]\n-    pure fn each(&self, f: &fn(&(uint, &self/T)) -> bool) {\n+    pure fn each(&self, f: &fn(&(uint, &'self T)) -> bool) {\n         self.root.each(f);\n     }\n     #[inline(always)]\n@@ -42,7 +42,7 @@ impl<T> BaseIter<(uint, &'self T)> for TrieMap<T> {\n impl<T> ReverseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n-    pure fn each_reverse(&self, f: &fn(&(uint, &self/T)) -> bool) {\n+    pure fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) {\n         self.root.each_reverse(f);\n     }\n }\n@@ -93,8 +93,8 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Return the value corresponding to the key in the map\n     #[inline(hint)]\n-    pure fn find(&self, key: &uint) -> Option<&self/T> {\n-        let mut node: &self/TrieNode<T> = &self.root;\n+    pure fn find(&self, key: &uint) -> Option<&'self T> {\n+        let mut node: &'self TrieNode<T> = &self.root;\n         let mut idx = 0;\n         loop {\n             match node.children[chunk(*key, idx)] {\n@@ -233,7 +233,7 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    pure fn each(&self, f: &fn(&(uint, &self/T)) -> bool) -> bool {\n+    pure fn each(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n                 Internal(ref x) => if !x.each(f) { return false },\n@@ -244,7 +244,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    pure fn each_reverse(&self, f: &fn(&(uint, &self/T)) -> bool) -> bool {\n+    pure fn each_reverse(&self, f: &fn(&(uint, &'self T)) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {\n                 Internal(ref x) => if !x.each_reverse(f) { return false },"}, {"sha": "b4f68466c27543f5f23f4392c03109a7c1473be9", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -47,19 +47,19 @@ impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n }\n \n pub trait ImmutableTuple<T, U> {\n-    pure fn first_ref(&self) -> &self/T;\n-    pure fn second_ref(&self) -> &self/U;\n+    pure fn first_ref(&self) -> &'self T;\n+    pure fn second_ref(&self) -> &'self U;\n }\n \n impl<T, U> ImmutableTuple<T, U> for (T, U) {\n     #[inline(always)]\n-    pure fn first_ref(&self) -> &self/T {\n+    pure fn first_ref(&self) -> &'self T {\n         match *self {\n             (ref t, _) => t,\n         }\n     }\n     #[inline(always)]\n-    pure fn second_ref(&self) -> &self/U {\n+    pure fn second_ref(&self) -> &'self U {\n         match *self {\n             (_, ref u) => u,\n         }\n@@ -71,7 +71,7 @@ pub trait ExtendedTupleOps<A,B> {\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C];\n }\n \n-impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&self/[A], &self/[B]) {\n+impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n     #[inline(always)]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {"}, {"sha": "899d01cd9963c665360446c8235141deb141a5d2", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -173,7 +173,7 @@ pub unsafe fn get_shared_mutable_state<T:Owned>(\n }\n #[inline(always)]\n pub unsafe fn get_shared_immutable_state<T:Owned>(\n-        rc: &a/SharedMutableState<T>) -> &a/T {\n+        rc: &'a SharedMutableState<T>) -> &'a T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         fail_unless!(ptr.count > 0);"}, {"sha": "e8c27ff7d92d2ac7f34d00940612f1a545f1583d", "filename": "src/libcore/unstable/finally.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Ffinally.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -31,7 +31,7 @@ pub trait Finally<T> {\n     fn finally(&self, dtor: &fn()) -> T;\n }\n \n-impl<T> Finally<T> for &self/fn() -> T {\n+impl<T> Finally<T> for &'self fn() -> T {\n     fn finally(&self, dtor: &fn()) -> T {\n         let _d = Finallyalizer {\n             dtor: dtor\n@@ -42,7 +42,7 @@ impl<T> Finally<T> for &self/fn() -> T {\n }\n \n struct Finallyalizer {\n-    dtor: &self/fn()\n+    dtor: &'self fn()\n }\n \n impl Drop for Finallyalizer/&self {"}, {"sha": "660336055590e66801bfe2d35c5ef904c8a8db44", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -42,7 +42,7 @@ use sys::Closure;\n #[cfg(test)] use task::spawn;\n #[cfg(test)] use uint;\n \n-pub type GlobalDataKey<T> = &self/fn(v: T);\n+pub type GlobalDataKey<T> = &'self fn(v: T);\n \n pub unsafe fn global_data_clone_create<T:Owned + Clone>(\n     key: GlobalDataKey<T>, create: &fn() -> ~T) -> T {"}, {"sha": "34d3c022dcac5f6d4205f840af850ef7abed94fd", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -217,46 +217,46 @@ pub pure fn build_sized_opt<A>(size: Option<uint>,\n // Accessors\n \n /// Returns the first element of a vector\n-pub pure fn head<T>(v: &r/[T]) -> &r/T {\n+pub pure fn head<T>(v: &'r [T]) -> &'r T {\n     if v.len() == 0 { fail!(~\"head: empty vector\") }\n     &v[0]\n }\n \n /// Returns `Some(x)` where `x` is the first element of the slice `v`,\n /// or `None` if the vector is empty.\n-pub pure fn head_opt<T>(v: &r/[T]) -> Option<&r/T> {\n+pub pure fn head_opt<T>(v: &'r [T]) -> Option<&'r T> {\n     if v.len() == 0 { None } else { Some(&v[0]) }\n }\n \n /// Returns a vector containing all but the first element of a slice\n-pub pure fn tail<T>(v: &r/[T]) -> &r/[T] { slice(v, 1, v.len()) }\n+pub pure fn tail<T>(v: &'r [T]) -> &'r [T] { slice(v, 1, v.len()) }\n \n /// Returns a vector containing all but the first `n` elements of a slice\n-pub pure fn tailn<T>(v: &r/[T], n: uint) -> &r/[T] { slice(v, n, v.len()) }\n+pub pure fn tailn<T>(v: &'r [T], n: uint) -> &'r [T] { slice(v, n, v.len()) }\n \n /// Returns a vector containing all but the last element of a slice\n-pub pure fn init<T>(v: &r/[T]) -> &r/[T] { slice(v, 0, v.len() - 1) }\n+pub pure fn init<T>(v: &'r [T]) -> &'r [T] { slice(v, 0, v.len() - 1) }\n \n /// Returns a vector containing all but the last `n' elements of a slice\n-pub pure fn initn<T>(v: &r/[T], n: uint) -> &r/[T] {\n+pub pure fn initn<T>(v: &'r [T], n: uint) -> &'r [T] {\n     slice(v, 0, v.len() - n)\n }\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n-pub pure fn last<T>(v: &r/[T]) -> &r/T {\n+pub pure fn last<T>(v: &'r [T]) -> &'r T {\n     if v.len() == 0 { fail!(~\"last: empty vector\") }\n     &v[v.len() - 1]\n }\n \n /// Returns `Some(x)` where `x` is the last element of the slice `v`, or\n /// `None` if the vector is empty.\n-pub pure fn last_opt<T>(v: &r/[T]) -> Option<&r/T> {\n+pub pure fn last_opt<T>(v: &'r [T]) -> Option<&'r T> {\n     if v.len() == 0 { None } else { Some(&v[v.len() - 1]) }\n }\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn slice<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n+pub pure fn slice<T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n@@ -270,10 +270,10 @@ pub pure fn slice<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn mut_slice<T>(v: &r/mut [T],\n+pub pure fn mut_slice<T>(v: &'r mut [T],\n                          start: uint,\n                          end: uint)\n-                      -> &r/mut [T] {\n+                      -> &'r mut [T] {\n     fail_unless!(start <= end);\n     fail_unless!(end <= v.len());\n     do as_mut_buf(v) |p, _len| {\n@@ -287,10 +287,10 @@ pub pure fn mut_slice<T>(v: &r/mut [T],\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn const_slice<T>(v: &r/[const T],\n+pub pure fn const_slice<T>(v: &'r [const T],\n                            start: uint,\n                            end: uint)\n-                        -> &r/[const T] {\n+                        -> &'r [const T] {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     do as_const_buf(v) |p, _len| {\n@@ -1334,7 +1334,7 @@ pub pure fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n  * ~~~\n  */\n #[inline(always)]\n-pub pure fn each<T>(v: &r/[T], f: &fn(&r/T) -> bool) {\n+pub pure fn each<T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n     //             ^^^^\n     // NB---this CANNOT be &[const T]!  The reason\n     // is that you are passing it to `f()` using\n@@ -1389,7 +1389,7 @@ pub pure fn each_const<T>(v: &[const T], f: &fn(elem: &const T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn eachi<T>(v: &r/[T], f: &fn(uint, v: &r/T) -> bool) {\n+pub pure fn eachi<T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n     let mut i = 0;\n     for each(v) |p| {\n         if !f(i, p) { return; }\n@@ -1403,7 +1403,7 @@ pub pure fn eachi<T>(v: &r/[T], f: &fn(uint, v: &r/T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn rev_each<T>(v: &r/[T], blk: &fn(v: &r/T) -> bool) {\n+pub pure fn rev_each<T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n     rev_eachi(v, |_i, v| blk(v))\n }\n \n@@ -1413,7 +1413,7 @@ pub pure fn rev_each<T>(v: &r/[T], blk: &fn(v: &r/T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn rev_eachi<T>(v: &r/[T], blk: &fn(i: uint, v: &r/T) -> bool) {\n+pub pure fn rev_eachi<T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n     let mut i = v.len();\n     while i > 0 {\n         i -= 1;\n@@ -1555,11 +1555,11 @@ pure fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n }\n \n #[cfg(notest)]\n-impl<T:Eq> Eq for &self/[T] {\n+impl<T:Eq> Eq for &'self [T] {\n     #[inline(always)]\n-    pure fn eq(&self, other: & &self/[T]) -> bool { eq((*self), (*other)) }\n+    pure fn eq(&self, other: & &'self [T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ne(&self, other: & &self/[T]) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: & &'self [T]) -> bool { !(*self).eq(other) }\n }\n \n \n@@ -1604,7 +1604,7 @@ pure fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n #[cfg(notest)]\n impl<T: TotalOrd> TotalOrd for &'self [T] {\n     #[inline(always)]\n-    pure fn cmp(&self, other: & &self/[T]) -> Ordering { cmp(*self, *other) }\n+    pure fn cmp(&self, other: & &'self [T]) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n@@ -1639,15 +1639,15 @@ pure fn ge<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n pure fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n #[cfg(notest)]\n-impl<T:Ord> Ord for &self/[T] {\n+impl<T:Ord> Ord for &'self [T] {\n     #[inline(always)]\n-    pure fn lt(&self, other: & &self/[T]) -> bool { lt((*self), (*other)) }\n+    pure fn lt(&self, other: & &'self [T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    pure fn le(&self, other: & &self/[T]) -> bool { le((*self), (*other)) }\n+    pure fn le(&self, other: & &'self [T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    pure fn ge(&self, other: & &self/[T]) -> bool { ge((*self), (*other)) }\n+    pure fn ge(&self, other: & &'self [T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    pure fn gt(&self, other: & &self/[T]) -> bool { gt((*self), (*other)) }\n+    pure fn gt(&self, other: & &'self [T]) -> bool { gt((*self), (*other)) }\n }\n \n #[cfg(notest)]\n@@ -1680,15 +1680,15 @@ pub mod traits {\n     use ops::Add;\n     use vec::append;\n \n-    impl<T:Copy> Add<&self/[const T],~[T]> for ~[T] {\n+    impl<T:Copy> Add<&'self [const T],~[T]> for ~[T] {\n         #[inline(always)]\n-        pure fn add(&self, rhs: & &self/[const T]) -> ~[T] {\n+        pure fn add(&self, rhs: & &'self [const T]) -> ~[T] {\n             append(copy *self, (*rhs))\n         }\n     }\n }\n \n-impl<T> Container for &self/[const T] {\n+impl<T> Container for &'self [const T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     pure fn is_empty(&self) -> bool { is_empty(*self) }\n@@ -1712,15 +1712,15 @@ impl<T: Copy> CopyableVector<T> for &'self [const T] {\n }\n \n pub trait ImmutableVector<T> {\n-    pure fn view(&self, start: uint, end: uint) -> &self/[T];\n-    pure fn head(&self) -> &self/T;\n-    pure fn head_opt(&self) -> Option<&self/T>;\n-    pure fn tail(&self) -> &self/[T];\n-    pure fn tailn(&self, n: uint) -> &self/[T];\n-    pure fn init(&self) -> &self/[T];\n-    pure fn initn(&self, n: uint) -> &self/[T];\n-    pure fn last(&self) -> &self/T;\n-    pure fn last_opt(&self) -> Option<&self/T>;\n+    pure fn view(&self, start: uint, end: uint) -> &'self [T];\n+    pure fn head(&self) -> &'self T;\n+    pure fn head_opt(&self) -> Option<&'self T>;\n+    pure fn tail(&self) -> &'self [T];\n+    pure fn tailn(&self, n: uint) -> &'self [T];\n+    pure fn init(&self) -> &'self [T];\n+    pure fn initn(&self, n: uint) -> &'self [T];\n+    pure fn last(&self) -> &'self T;\n+    pure fn last_opt(&self) -> Option<&'self T>;\n     pure fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n     pure fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n     pure fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n@@ -1731,44 +1731,44 @@ pub trait ImmutableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T> ImmutableVector<T> for &self/[T] {\n+impl<T> ImmutableVector<T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n-    pure fn view(&self, start: uint, end: uint) -> &self/[T] {\n+    pure fn view(&self, start: uint, end: uint) -> &'self [T] {\n         slice(*self, start, end)\n     }\n \n     /// Returns the first element of a vector, failing if the vector is empty.\n     #[inline]\n-    pure fn head(&self) -> &self/T { head(*self) }\n+    pure fn head(&self) -> &'self T { head(*self) }\n \n     /// Returns the first element of a vector\n     #[inline]\n-    pure fn head_opt(&self) -> Option<&self/T> { head_opt(*self) }\n+    pure fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n \n     /// Returns all but the first element of a vector\n     #[inline]\n-    pure fn tail(&self) -> &self/[T] { tail(*self) }\n+    pure fn tail(&self) -> &'self [T] { tail(*self) }\n \n     /// Returns all but the first `n' elements of a vector\n     #[inline]\n-    pure fn tailn(&self, n: uint) -> &self/[T] { tailn(*self, n) }\n+    pure fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n \n     /// Returns all but the last elemnt of a vector\n     #[inline]\n-    pure fn init(&self) -> &self/[T] { init(*self) }\n+    pure fn init(&self) -> &'self [T] { init(*self) }\n \n     /// Returns all but the last `n' elemnts of a vector\n     #[inline]\n-    pure fn initn(&self, n: uint) -> &self/[T] { initn(*self, n) }\n+    pure fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n \n     /// Returns the last element of a `v`, failing if the vector is empty.\n     #[inline]\n-    pure fn last(&self) -> &self/T { last(*self) }\n+    pure fn last(&self) -> &'self T { last(*self) }\n \n     /// Returns the last element of a `v`, failing if the vector is empty.\n     #[inline]\n-    pure fn last_opt(&self) -> Option<&self/T> { last_opt(*self) }\n+    pure fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n \n     /// Reduce a vector from right to left\n     #[inline]\n@@ -1834,7 +1834,7 @@ pub trait ImmutableEqVector<T:Eq> {\n     pure fn rposition_elem(&self, t: &T) -> Option<uint>;\n }\n \n-impl<T:Eq> ImmutableEqVector<T> for &self/[T] {\n+impl<T:Eq> ImmutableEqVector<T> for &'self [T] {\n     /**\n      * Find the first index matching some predicate\n      *\n@@ -1879,7 +1879,7 @@ pub trait ImmutableCopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T:Copy> ImmutableCopyableVector<T> for &self/[T] {\n+impl<T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n     /**\n      * Construct a new vector from the elements of a vector for which some\n      * predicate holds.\n@@ -2139,7 +2139,7 @@ pub mod raw {\n                                     len: uint,\n                                     f: &fn(v: &[T]) -> U) -> U {\n         let pair = (p, len * sys::nonzero_size_of::<T>());\n-        let v : *(&blk/[T]) =\n+        let v : *(&'blk [T]) =\n             ::cast::reinterpret_cast(&addr_of(&pair));\n         f(*v)\n     }\n@@ -2153,7 +2153,7 @@ pub mod raw {\n                                         len: uint,\n                                         f: &fn(v: &mut [T]) -> U) -> U {\n         let pair = (p, len * sys::nonzero_size_of::<T>());\n-        let v : *(&blk/mut [T]) =\n+        let v : *(&'blk mut [T]) =\n             ::cast::reinterpret_cast(&addr_of(&pair));\n         f(*v)\n     }\n@@ -2327,7 +2327,7 @@ impl<A> iter::MutableIter<A> for @mut [A] {\n     }\n }\n \n-impl<A> iter::ExtendedIter<A> for &self/[A] {\n+impl<A> iter::ExtendedIter<A> for &'self [A] {\n     pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n@@ -2404,7 +2404,7 @@ impl<A> iter::ExtendedIter<A> for @[A] {\n     }\n }\n \n-impl<A:Eq> iter::EqIter<A> for &self/[A] {\n+impl<A:Eq> iter::EqIter<A> for &'self [A] {\n     pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n     pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n@@ -2421,7 +2421,7 @@ impl<A:Eq> iter::EqIter<A> for @[A] {\n     pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n-impl<A:Copy> iter::CopyableIter<A> for &self/[A] {\n+impl<A:Copy> iter::CopyableIter<A> for &'self [A] {\n     pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n@@ -2453,7 +2453,7 @@ impl<A:Copy> iter::CopyableIter<A> for @[A] {\n     }\n }\n \n-impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for &self/[A] {\n+impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for &'self [A] {\n     pure fn min(&self) -> A { iter::min(self) }\n     pure fn max(&self) -> A { iter::max(self) }\n }\n@@ -2470,7 +2470,7 @@ impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for @[A] {\n     pure fn max(&self) -> A { iter::max(self) }\n }\n \n-impl<A:Copy> iter::CopyableNonstrictIter<A> for &self/[A] {\n+impl<A:Copy> iter::CopyableNonstrictIter<A> for &'self [A] {\n     pure fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {"}, {"sha": "3ca4ef5efbd9532bba7594de8ecbadb2934a3f8d", "filename": "src/librust/rust.rc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -38,23 +38,23 @@ impl ValidUsage {\n }\n \n enum Action {\n-    Exec(&self/str),\n-    Call(&self/fn(args: &[~str]) -> ValidUsage)\n+    Exec(&'self str),\n+    Call(&'self fn(args: &[~str]) -> ValidUsage)\n }\n \n enum UsageSource {\n-    UsgExec(&self/str),\n-    UsgStr(&self/str)\n+    UsgExec(&'self str),\n+    UsgStr(&'self str)\n }\n \n struct Command {\n-    cmd: &self/str,\n+    cmd: &'self str,\n     action: Action/&self,\n-    usage_line: &self/str,\n+    usage_line: &'self str,\n     usage_full: UsageSource/&self\n }\n \n-const commands: &static/[Command/&static] = &[\n+const commands: &'static [Command/&static] = &[\n     Command{\n         cmd: \"build\",\n         action: Exec(\"rustc\"),"}, {"sha": "0766dcd24508618bc9e7681d569947a67e48df86", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -19,7 +19,7 @@ use syntax::codemap;\n use syntax::codemap::dummy_sp;\n use syntax::fold;\n \n-const CORE_VERSION: &static/str = \"0.6\";\n+const CORE_VERSION: &'static str = \"0.6\";\n \n pub fn maybe_inject_libcore_ref(sess: Session,\n                                 crate: @ast::crate) -> @ast::crate {"}, {"sha": "ddbac4085a7d7ed7b78ddc58037c4192f94b4e24", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -257,7 +257,7 @@ mod __test {\n     std::test::test_main_static(::os::args(), tests)\n   }\n \n-  const tests : &static/[std::test::TestDescAndFn] = &[\n+  const tests : &'static [std::test::TestDescAndFn] = &[\n     ... the list of tests in the crate ...\n   ];\n }\n@@ -352,7 +352,7 @@ fn path_node_global(+ids: ~[ast::ident]) -> @ast::path {\n                  types: ~[] }\n }\n \n-\n+#[cfg(stage0)]\n fn mk_tests(cx: &TestCtxt) -> @ast::item {\n \n     let ext_cx = cx.ext_cx;\n@@ -367,6 +367,22 @@ fn mk_tests(cx: &TestCtxt) -> @ast::item {\n     )).get()\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+fn mk_tests(cx: &TestCtxt) -> @ast::item {\n+\n+    let ext_cx = cx.ext_cx;\n+\n+    // The vector of test_descs for this crate\n+    let test_descs = mk_test_descs(cx);\n+\n+    (quote_item!(\n+        pub const tests : &'static [self::std::test::TestDescAndFn] =\n+            $test_descs\n+        ;\n+    )).get()\n+}\n+\n fn is_std(cx: &TestCtxt) -> bool {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);"}, {"sha": "1864e1c06ae77025e8a99189ad01df7e60c4e86e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -66,7 +66,7 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: uint) ->\n     None\n }\n \n-pub type GetCrateDataCb = &self/fn(ast::crate_num) -> cmd;\n+pub type GetCrateDataCb = &'self fn(ast::crate_num) -> cmd;\n \n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n@@ -544,7 +544,7 @@ pub fn get_item_path(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n     item_path(intr, lookup_item(id, cdata.data))\n }\n \n-pub type decode_inlined_item = &self/fn(\n+pub type decode_inlined_item = &'self fn(\n     cdata: @cstore::crate_metadata,\n     tcx: ty::ctxt,\n     path: ast_map::path,"}, {"sha": "efbde04d68e66b111a3bad58b806dab907bbb100", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -1291,7 +1291,7 @@ fn encode_hash(ebml_w: writer::Encoder, hash: &str) {\n }\n \n // NB: Increment this as you change the metadata encoding version.\n-pub const metadata_encoding_version : &static/[u8] =\n+pub const metadata_encoding_version : &'static [u8] =\n     &[0x72, //'r' as u8,\n       0x75, //'u' as u8,\n       0x73, //'s' as u8,"}, {"sha": "ad5b0274c0d5dac36926ba9b5e7dfac735889b8c", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -21,7 +21,7 @@ use core::result::Result;\n use core::result;\n use core::str;\n \n-pub type pick<T> = &self/fn(path: &Path) -> Option<T>;\n+pub type pick<T> = &'self fn(path: &Path) -> Option<T>;\n \n pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n     if path.file_path() == file { option::Some(copy *path) }"}, {"sha": "c87b09cde0856faa8475d7e075f473e7c7895343", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -49,7 +49,7 @@ pub enum DefIdSource {\n     // Identifies a type parameter (`fn foo<X>() { ... }`).\n     TypeParameter\n }\n-type conv_did = &self/fn(source: DefIdSource, ast::def_id) -> ast::def_id;\n+type conv_did = &'self fn(source: DefIdSource, ast::def_id) -> ast::def_id;\n \n pub struct PState {\n     data: @~[u8],"}, {"sha": "2893c460fe26225f93008559b6419a48796e2c2d", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -514,7 +514,7 @@ pub impl GatherLoanCtxt {\n         // consumes one mut pointer and returns a narrower one:\n         //\n         //     struct Foo { f: int }\n-        //     fn foo(p: &v/mut Foo) -> &v/mut int { &mut p.f }\n+        //     fn foo(p: &'v mut Foo) -> &'v mut int { &mut p.f }\n         //\n         // I think this should work fine but there is more subtlety to it than\n         // I at first imagined. Unfortunately it's a very important use case,"}, {"sha": "962af48a70c8f3570a6a806b9955348e686658ee", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -64,7 +64,7 @@ pub impl BorrowckCtxt {\n }\n \n struct PreserveCtxt {\n-    bccx: &self/BorrowckCtxt,\n+    bccx: &'self BorrowckCtxt,\n \n     // the region scope for which we must preserve the memory\n     scope_region: ty::Region,"}, {"sha": "4b1b0d0200f6a7fb1bc157a3dad4d90524ff1827", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -55,7 +55,7 @@ use syntax::{visit, ast_util};\n // primitives in the stdlib are explicitly annotated to only take sendable\n // types.\n \n-pub const try_adding: &static/str = \"Try adding a move\";\n+pub const try_adding: &'static str = \"Try adding a move\";\n \n pub type rval_map = HashMap<node_id, ()>;\n "}, {"sha": "f88be89ad00807aff3a5d422040d26f4423b59e7", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -96,7 +96,7 @@ pub impl LanguageItems {\n         }\n     }\n \n-    static pub fn item_name(&self, index: uint) -> &static/str {\n+    static pub fn item_name(&self, index: uint) -> &'static str {\n         match index {\n             0  => \"const\",\n             1  => \"copy\",\n@@ -257,7 +257,7 @@ pub impl LanguageItems {\n \n fn LanguageItemCollector(crate: @crate,\n                          session: Session,\n-                         items: &r/mut LanguageItems)\n+                         items: &'r mut LanguageItems)\n                       -> LanguageItemCollector/&r {\n     let item_refs = HashMap();\n \n@@ -312,7 +312,7 @@ fn LanguageItemCollector(crate: @crate,\n }\n \n struct LanguageItemCollector {\n-    items: &self/mut LanguageItems,\n+    items: &'self mut LanguageItems,\n \n     crate: @crate,\n     session: Session,"}, {"sha": "f2e736ac86d170e78fb7c9541156e1aca4c20903", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -90,7 +90,7 @@ pub enum lint {\n     // dead_assignment\n }\n \n-pub fn level_to_str(lv: level) -> &static/str {\n+pub fn level_to_str(lv: level) -> &'static str {\n     match lv {\n       allow => \"allow\",\n       warn => \"warn\",\n@@ -106,7 +106,7 @@ pub enum level {\n \n struct LintSpec {\n     lint: lint,\n-    desc: &static/str,\n+    desc: &'static str,\n     default: level\n }\n \n@@ -881,14 +881,14 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n             !ident.contains_char('_')\n     }\n \n-    fn ident_without_trailing_underscores(ident: &r/str) -> &r/str {\n+    fn ident_without_trailing_underscores(ident: &'r str) -> &'r str {\n         match str::rfind(ident, |c| c != '_') {\n             Some(idx) => str::view(ident, 0, idx + 1),\n             None => ident, // all underscores\n         }\n     }\n \n-    fn ident_without_leading_underscores(ident: &r/str) -> &r/str {\n+    fn ident_without_leading_underscores(ident: &'r str) -> &'r str {\n         match str::find(ident, |c| c != '_') {\n             Some(idx) => str::view(ident, idx, ident.len()),\n             None => ident // all underscores"}, {"sha": "05a697194c8b54752ba7bc858ba5618beecc173e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -438,7 +438,7 @@ pub fn join_variance(++variance1: region_variance,\n /// particular site to yield the final variance of the reference.\n ///\n /// Example: if we are checking function arguments then the ambient\n-/// variance is contravariant.  If we then find a `&r/T` pointer, `r`\n+/// variance is contravariant.  If we then find a `&'r T` pointer, `r`\n /// appears in a co-variant position.  This implies that this\n /// occurrence of `r` is contra-variant with respect to the current\n /// item, and hence the function returns `rv_contravariant`.\n@@ -517,9 +517,9 @@ pub impl DetermineRpCtxt {\n     // concrete.\n     //\n     // 1. impl foo for &int { ... }\n-    // 2. impl foo for &self/int { ... }\n-    // 3. impl foo for bar { fn m(@self) -> &self/int { ... } }\n-    // 4. impl foo for bar { fn m(&self) -> &self/int { ... } }\n+    // 2. impl foo for &'self int { ... }\n+    // 3. impl foo for bar { fn m(@self) -> &'self int { ... } }\n+    // 4. impl foo for bar { fn m(&self) -> &'self int { ... } }\n     // 5. impl foo for bar { fn m(&self) -> &int { ... } }\n     //\n     // In case 1, the anonymous region is being referenced,\n@@ -644,9 +644,9 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     // impl etc.  So we can ignore it and its components.\n     if cx.item_id == 0 { return; }\n \n-    // if this type directly references a region pointer like &r/ty,\n-    // add to the worklist/set.  Note that &r/ty is contravariant with\n-    // respect to &r, because &r/ty can be used whereever a *smaller*\n+    // if this type directly references a region pointer like &'r ty,\n+    // add to the worklist/set.  Note that &'r ty is contravariant with\n+    // respect to &r, because &'r ty can be used whereever a *smaller*\n     // region is expected (and hence is a supertype of those\n     // locations)\n     let sess = cx.sess;"}, {"sha": "45d64cd864fb0da544940b314fd069a52489ddaf", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -212,7 +212,7 @@ pub impl<T> ResolveResult<T> {\n \n pub enum TypeParameters/& {\n     NoTypeParameters,                  //< No type parameters.\n-    HasTypeParameters(&self/Generics,  //< Type parameters.\n+    HasTypeParameters(&'self Generics,  //< Type parameters.\n                       node_id,         //< ID of the enclosing item\n \n                       // The index to start numbering the type parameters at."}, {"sha": "8f0d9eb953f971834d96dc1fb7fa2fca02475a10", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -327,7 +327,7 @@ pub type BindingsMap = HashMap<ident, BindingInfo>;\n \n pub struct ArmData {\n     bodycx: block,\n-    arm: &self/ast::arm,\n+    arm: &'self ast::arm,\n     bindings_map: BindingsMap\n }\n \n@@ -391,7 +391,7 @@ pub fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n     }\n }\n \n-pub type enter_pat = &self/fn(@ast::pat) -> Option<~[@ast::pat]>;\n+pub type enter_pat = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n \n pub fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {"}, {"sha": "81d85773ccb5c53f04f9a065ce2b1ee9c0dab8b0", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -550,8 +550,8 @@ pub fn trans_call_inner(\n \n \n pub enum CallArgs {\n-    ArgExprs(&self/[@ast::expr]),\n-    ArgVals(&self/[ValueRef])\n+    ArgExprs(&'self [@ast::expr]),\n+    ArgVals(&'self [ValueRef])\n }\n \n pub struct Args {"}, {"sha": "9b3ec5ef842e69347f5797f090ff28b6431b17e3", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -617,7 +617,7 @@ pub impl Datum {\n         // using `to_ref_llval()`).\n \n         // Convert to ref, yielding lltype *T.  Then create a Rust\n-        // type &static/T (which translates to *T).  Construct new\n+        // type &'static T (which translates to *T).  Construct new\n         // result (which will be by-value).  Note that it is not\n         // significant *which* region we pick here.\n         let llval = self.to_ref_llval(bcx);"}, {"sha": "9f66bb5b4688c67c3d687e7ac592dd86759cb671", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -520,7 +520,7 @@ pub fn get_base_and_len(bcx: block,\n \n pub type val_and_ty_fn = @fn(block, ValueRef, ty::t) -> Result;\n \n-pub type iter_vec_block = &self/fn(block, ValueRef, ty::t) -> block;\n+pub type iter_vec_block = &'self fn(block, ValueRef, ty::t) -> block;\n \n pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n                     fill: ValueRef, f: iter_vec_block) -> block {"}, {"sha": "fcebcaf501ee16d1f262c3e0e0e2160467b118fa", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -448,13 +448,13 @@ pub enum Region {\n #[auto_encode]\n #[auto_decode]\n pub enum bound_region {\n-    /// The self region for structs, impls (&T in a type defn or &self/T)\n+    /// The self region for structs, impls (&T in a type defn or &'self T)\n     br_self,\n \n     /// An anonymous region parameter for a given fn (&T)\n     br_anon(uint),\n \n-    /// Named region parameters for functions (a in &a/T)\n+    /// Named region parameters for functions (a in &'a T)\n     br_named(ast::ident),\n \n     /// Fresh bound identifiers created during GLB computations."}, {"sha": "0186ab3046417cc408ae714a1a539d00021c8838", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -46,7 +46,7 @@\n  *   type foo/& = ...;\n  *   type bar = fn(&foo, &a.foo)\n  * The fully expanded version of type bar is:\n- *   type bar = fn(&foo/&, &a.foo/&a)\n+ *   type bar = fn(&'foo &, &a.foo/&a)\n  * Note that the self region for the `foo` defaulted to `&` in the first\n  * case but `&a` in the second.  Basically, defaults that appear inside\n  * an rptr (`&r.T`) use the region `r` that appears in the rptr."}, {"sha": "929555e3148008ea6faff0e797531efe53910355", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -157,7 +157,7 @@ pub struct LookupContext {\n     self_expr: @ast::expr,\n     callee_id: node_id,\n     m_name: ast::ident,\n-    supplied_tps: &self/[ty::t],\n+    supplied_tps: &'self [ty::t],\n     impl_dups: HashMap<def_id, ()>,\n     inherent_candidates: @mut ~[Candidate],\n     extension_candidates: @mut ~[Candidate],"}, {"sha": "6871496a805caee56c3edd3e8166736fb21fd0fc", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -18,7 +18,7 @@ know whether a given type will be a region pointer or not until this\n phase.\n \n In particular, we ensure that, if the type of an expression or\n-variable is `&r/T`, then the expression or variable must occur within\n+variable is `&'r T`, then the expression or variable must occur within\n the region scope `r`.  Note that in some cases `r` may still be a\n region variable, so this gives us a chance to influence the value for\n `r` that we infer to ensure we choose a value large enough to enclose\n@@ -500,7 +500,7 @@ pub mod guarantor {\n      *\n      *     struct Foo { i: int }\n      *     struct Bar { foo: Foo  }\n-     *     fn get_i(x: &a/Bar) -> &a/int {\n+     *     fn get_i(x: &'a Bar) -> &'a int {\n      *        let foo = &x.foo; // Lifetime L1\n      *        &foo.i            // Lifetime L2\n      *     }"}, {"sha": "3d2ed867de1f2c08d92d0ac6e2dc949a447a41b1", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -550,8 +550,8 @@ pub impl CoherenceChecker {\n     }\n \n     fn can_unify_universally_quantified(&self,\n-                                        a: &a/UniversalQuantificationResult,\n-                                        b: &a/UniversalQuantificationResult)\n+                                        a: &'a UniversalQuantificationResult,\n+                                        b: &'a UniversalQuantificationResult)\n                                      -> bool {\n         let mut might_unify = true;\n         let _ = do self.inference_context.probe {"}, {"sha": "b9aac4b19ed924253b129d24f4d29e5584206102", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -438,7 +438,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n \n     // Replace any references to the self region in the self type with\n     // a free region.  So, for example, if the impl type is\n-    // \"&self/str\", then this would replace the self type with a free\n+    // \"&'self str\", then this would replace the self type with a free\n     // region `self`.\n     let dummy_self_r = ty::re_free(cm.body_id, ty::br_self);\n     let self_ty = replace_bound_self(tcx, self_ty, dummy_self_r);\n@@ -601,7 +601,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  span: span,\n                                  generics: &ast::Generics,\n-                                 thing: &static/str) {\n+                                 thing: &'static str) {\n     for generics.ty_params.each |ty_param| {\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err("}, {"sha": "1ce590647653e0ed929839c3e606d925232925cb", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -58,7 +58,7 @@ pub trait LatticeValue {\n                  -> cres<Self>;\n }\n \n-pub type LatticeOp<T> = &self/fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n+pub type LatticeOp<T> = &'self fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n \n impl LatticeValue for ty::t {\n     static fn sub(&self, cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n@@ -378,7 +378,7 @@ pub fn super_lattice_tys<L:LatticeDir + TyLatticeDir + Combine>(\n     }\n }\n \n-pub type LatticeDirOp<T> = &self/fn(a: &T, b: &T) -> cres<T>;\n+pub type LatticeDirOp<T> = &'self fn(a: &T, b: &T) -> cres<T>;\n \n pub enum LatticeVarResult<V,T> {\n     VarResult(V),"}, {"sha": "534e50e115f7871013d672da11558e3ce8841ee4", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -153,7 +153,7 @@ The problem we are addressing is that there is a kind of subtyping\n between functions with bound region parameters.  Consider, for\n example, whether the following relation holds:\n \n-    fn(&a/int) <: &fn(&b/int)? (Yes, a => b)\n+    fn(&'a int) <: &fn(&'b int)? (Yes, a => b)\n \n The answer is that of course it does.  These two types are basically\n the same, except that in one we used the name `a` and one we used\n@@ -163,14 +163,14 @@ In the examples that follow, it becomes very important to know whether\n a lifetime is bound in a function type (that is, is a lifetime\n parameter) or appears free (is defined in some outer scope).\n Therefore, from now on I will write the bindings explicitly, using a\n-notation like `fn<a>(&a/int)` to indicate that `a` is a lifetime\n+notation like `fn<a>(&'a int)` to indicate that `a` is a lifetime\n parameter.\n \n Now let's consider two more function types.  Here, we assume that the\n `self` lifetime is defined somewhere outside and hence is not a\n lifetime parameter bound by the function type (it \"appears free\"):\n \n-    fn<a>(&a/int) <: &fn(&self/int)? (Yes, a => self)\n+    fn<a>(&'a int) <: &fn(&'self int)? (Yes, a => self)\n \n This subtyping relation does in fact hold.  To see why, you have to\n consider what subtyping means.  One way to look at `T1 <: T2` is to\n@@ -187,7 +187,7 @@ to the same thing: a function that accepts pointers with any lifetime\n \n So, what if we reverse the order of the two function types, like this:\n \n-    fn(&self/int) <: &fn<a>(&a/int)? (No)\n+    fn(&'self int) <: &fn<a>(&'a int)? (No)\n \n Does the subtyping relationship still hold?  The answer of course is\n no.  In this case, the function accepts *only the lifetime `&self`*,\n@@ -196,8 +196,8 @@ accepted any lifetime.\n \n What about these two examples:\n \n-    fn<a,b>(&a/int, &b/int) <: &fn<a>(&a/int, &a/int)? (Yes)\n-    fn<a>(&a/int, &a/int) <: &fn<a,b>(&a/int, &b/int)? (No)\n+    fn<a,b>(&'a int, &'b int) <: &fn<a>(&'a int, &'a int)? (Yes)\n+    fn<a>(&'a int, &'a int) <: &fn<a,b>(&'a int, &'b int)? (No)\n \n Here, it is true that functions which take two pointers with any two\n lifetimes can be treated as if they only accepted two pointers with\n@@ -221,12 +221,12 @@ Let's walk through some examples and see how this algorithm plays out.\n \n We'll start with the first example, which was:\n \n-    1. fn<a>(&a/T) <: &fn<b>(&b/T)?        Yes: a -> b\n+    1. fn<a>(&'a T) <: &fn<b>(&'b T)?        Yes: a -> b\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    1. fn(&A/T) <: &fn(&x/T)?\n+    1. fn(&'A T) <: &fn(&'x T)?\n \n Here the upper case `&A` indicates a *region variable*, that is, a\n region whose value is being inferred by the system.  I also replaced\n@@ -238,7 +238,7 @@ region names anymore (as indicated by the absence of `<` and `>`).\n The next step is to check that the parameter types match.  Because\n parameters are contravariant, this means that we check whether:\n \n-    &x/T <: &A/T\n+    &'x T <: &'A T\n \n Region pointers are contravariant so this implies that\n \n@@ -255,12 +255,12 @@ So far we have encountered no error, so the subtype check succeeds.\n \n Now let's look first at the third example, which was:\n \n-    3. fn(&self/T)    <: &fn<b>(&b/T)?        No!\n+    3. fn(&'self T)    <: &fn<b>(&'b T)?        No!\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    3. fn(&self/T) <: &fn(&x/T)?\n+    3. fn(&'self T) <: &fn(&'x T)?\n \n This looks pretty much the same as before, except that on the LHS\n `&self` was not bound, and hence was left as-is and not replaced with\n@@ -275,33 +275,33 @@ You may be wondering about that mysterious last step in the algorithm.\n So far it has not been relevant.  The purpose of that last step is to\n catch something like *this*:\n \n-    fn<a>() -> fn(&a/T) <: &fn() -> fn<b>(&b/T)?   No.\n+    fn<a>() -> fn(&'a T) <: &fn() -> fn<b>(&'b T)?   No.\n \n Here the function types are the same but for where the binding occurs.\n The subtype returns a function that expects a value in precisely one\n region.  The supertype returns a function that expects a value in any\n region.  If we allow an instance of the subtype to be used where the\n supertype is expected, then, someone could call the fn and think that\n-the return value has type `fn<b>(&b/T)` when it really has type\n-`fn(&a/T)` (this is case #3, above).  Bad.\n+the return value has type `fn<b>(&'b T)` when it really has type\n+`fn(&'a T)` (this is case #3, above).  Bad.\n \n So let's step through what happens when we perform this subtype check.\n We first replace the bound regions in the subtype (the supertype has\n no bound regions).  This gives us:\n \n-    fn() -> fn(&A/T) <: &fn() -> fn<b>(&b/T)?\n+    fn() -> fn(&'A T) <: &fn() -> fn<b>(&'b T)?\n \n Now we compare the return types, which are covariant, and hence we have:\n \n-    fn(&A/T) <: &fn<b>(&b/T)?\n+    fn(&'A T) <: &fn<b>(&'b T)?\n \n Here we skolemize the bound region in the supertype to yield:\n \n-    fn(&A/T) <: &fn(&x/T)?\n+    fn(&'A T) <: &fn(&'x T)?\n \n And then proceed to compare the argument types:\n \n-    &x/T <: &A/T\n+    &'x T <: &'A T\n     &A <= &x\n \n Finally, this is where it gets interesting!  This is where an error\n@@ -314,7 +314,7 @@ The difference between this example and the first one is that the variable\n `A` already existed at the point where the skolemization occurred.  In\n the first example, you had two functions:\n \n-    fn<a>(&a/T) <: &fn<b>(&b/T)\n+    fn<a>(&'a T) <: &fn<b>(&'b T)\n \n and hence `&A` and `&x` were created \"together\".  In general, the\n intention of the skolemized names is that they are supposed to be"}, {"sha": "fe77b62de43763bd5a92ff2254819b7cacc3ed2f", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -35,8 +35,8 @@ pub struct Node<V, T> {\n }\n \n pub trait UnifyVid<T> {\n-    static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n-        -> &v/mut ValsAndBindings<Self, T>;\n+    static fn appropriate_vals_and_bindings(&self, infcx: &'v mut InferCtxt)\n+        -> &'v mut ValsAndBindings<Self, T>;\n }\n \n pub impl InferCtxt {\n@@ -235,15 +235,15 @@ pub impl InferCtxt {\n // ______________________________________________________________________\n \n impl UnifyVid<Bounds<ty::t>> for ty::TyVid {\n-    static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n-        -> &v/mut ValsAndBindings<ty::TyVid, Bounds<ty::t>> {\n+    static fn appropriate_vals_and_bindings(&self, infcx: &'v mut InferCtxt)\n+        -> &'v mut ValsAndBindings<ty::TyVid, Bounds<ty::t>> {\n         return &mut infcx.ty_var_bindings;\n     }\n }\n \n impl UnifyVid<Option<IntVarValue>> for ty::IntVid {\n-    static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n-        -> &v/mut ValsAndBindings<ty::IntVid, Option<IntVarValue>> {\n+    static fn appropriate_vals_and_bindings(&self, infcx: &'v mut InferCtxt)\n+        -> &'v mut ValsAndBindings<ty::IntVid, Option<IntVarValue>> {\n         return &mut infcx.int_var_bindings;\n     }\n }\n@@ -256,8 +256,8 @@ impl SimplyUnifiable for IntVarValue {\n }\n \n impl UnifyVid<Option<ast::float_ty>> for ty::FloatVid {\n-    static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n-        -> &v/mut ValsAndBindings<ty::FloatVid, Option<ast::float_ty>> {\n+    static fn appropriate_vals_and_bindings(&self, infcx: &'v mut InferCtxt)\n+        -> &'v mut ValsAndBindings<ty::FloatVid, Option<ast::float_ty>> {\n         return &mut infcx.float_var_bindings;\n     }\n }"}, {"sha": "5a08884777c182a6cd6d83de8b1d320168ec23aa", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -27,8 +27,8 @@ use core::task;\n /// As sync::condvar, a mechanism for unlock-and-descheduling and signalling.\n pub struct Condvar {\n     is_mutex: bool,\n-    failed: &self/mut bool,\n-    cond: &self/sync::Condvar/&self\n+    failed: &'self mut bool,\n+    cond: &'self sync::Condvar/&self\n }\n \n pub impl Condvar/&self {\n@@ -95,7 +95,7 @@ pub fn ARC<T:Const + Owned>(data: T) -> ARC<T> {\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-pub fn get<T:Const + Owned>(rc: &a/ARC<T>) -> &a/T {\n+pub fn get<T:Const + Owned>(rc: &'a ARC<T>) -> &'a T {\n     unsafe { get_shared_immutable_state(&rc.x) }\n }\n \n@@ -193,7 +193,7 @@ pub impl<T:Owned> MutexARC<T> {\n     #[inline(always)]\n     unsafe fn access_cond<U>(\n         &self,\n-        blk: &fn(x: &x/mut T, c: &c/Condvar) -> U) -> U\n+        blk: &fn(x: &'x mut T, c: &'c Condvar) -> U) -> U\n     {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n@@ -239,7 +239,7 @@ impl Drop for PoisonOnFail {\n     }\n }\n \n-fn PoisonOnFail(failed: &r/mut bool) -> PoisonOnFail {\n+fn PoisonOnFail(failed: &'r mut bool) -> PoisonOnFail {\n     PoisonOnFail {\n         failed: ptr::to_mut_unsafe_ptr(failed)\n     }\n@@ -313,7 +313,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n     }\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline(always)]\n-    fn write_cond<U>(&self, blk: &fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: &fn(x: &'x mut T, c: &'c Condvar) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (*borrow_rwlock(state)).write_cond |cond| {\n@@ -436,7 +436,7 @@ pub impl<T:Const + Owned> RWWriteMode/&self<T> {\n         }\n     }\n     /// Access the pre-downgrade RWARC in write mode with a condvar.\n-    fn write_cond<U>(&self, blk: &fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: &fn(x: &'x mut T, c: &'c Condvar) -> U) -> U {\n         match *self {\n             RWWriteMode {\n                 data: ref data,"}, {"sha": "68132a1c08d0282ed4dda00ce2f3b46c99173a88", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -201,7 +201,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_pod<T>(&self, op: &fn() -> T) -> &self/T {\n+    fn alloc_pod<T>(&self, op: &fn() -> T) -> &'self T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -246,7 +246,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_nonpod<T>(&self, op: &fn() -> T) -> &self/T {\n+    fn alloc_nonpod<T>(&self, op: &fn() -> T) -> &'self T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -268,7 +268,7 @@ pub impl Arena {\n \n     // The external interface\n     #[inline(always)]\n-    fn alloc<T>(&self, op: &fn() -> T) -> &self/T {\n+    fn alloc<T>(&self, op: &fn() -> T) -> &'self T {\n         unsafe {\n             if !rusti::needs_drop::<T>() {\n                 self.alloc_pod(op)"}, {"sha": "56ce54be44e0127700d1b4d11fcafd287d5f52e6", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -16,7 +16,7 @@ pub trait ToBase64 {\n     pure fn to_base64(&self) -> ~str;\n }\n \n-impl ToBase64 for &self/[u8] {\n+impl ToBase64 for &'self [u8] {\n     pure fn to_base64(&self) -> ~str {\n         let chars = str::chars(\n           ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n@@ -69,7 +69,7 @@ impl ToBase64 for &self/[u8] {\n     }\n }\n \n-impl ToBase64 for &self/str {\n+impl ToBase64 for &'self str {\n     pure fn to_base64(&self) -> ~str {\n         str::to_bytes(*self).to_base64()\n     }"}, {"sha": "e128859bb7dde4e73c4713b72b7750676081d510", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -1045,9 +1045,9 @@ mod biguint_tests {\n         fail_unless!(BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value);\n     }\n \n-    const sum_triples: &static/[(&static/[BigDigit],\n-                                 &static/[BigDigit],\n-                                 &static/[BigDigit])] = &[\n+    const sum_triples: &'static [(&'static [BigDigit],\n+                                 &'static [BigDigit],\n+                                 &'static [BigDigit])] = &[\n         (&[],          &[],       &[]),\n         (&[],          &[ 1],     &[ 1]),\n         (&[ 1],        &[ 1],     &[ 2]),\n@@ -1085,9 +1085,9 @@ mod biguint_tests {\n         }\n     }\n \n-    const mul_triples: &static/[(&static/[BigDigit],\n-                                 &static/[BigDigit],\n-                                 &static/[BigDigit])] = &[\n+    const mul_triples: &'static [(&'static [BigDigit],\n+                                 &'static [BigDigit],\n+                                 &'static [BigDigit])] = &[\n         (&[],               &[],               &[]),\n         (&[],               &[ 1],             &[]),\n         (&[ 2],             &[],               &[]),\n@@ -1111,10 +1111,10 @@ mod biguint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    const divmod_quadruples: &static/[(&static/[BigDigit],\n-                                       &static/[BigDigit],\n-                                       &static/[BigDigit],\n-                                       &static/[BigDigit])]\n+    const divmod_quadruples: &'static [(&'static [BigDigit],\n+                                       &'static [BigDigit],\n+                                       &'static [BigDigit],\n+                                       &'static [BigDigit])]\n         = &[\n             (&[ 1],        &[ 2], &[],               &[1]),\n             (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n@@ -1399,9 +1399,9 @@ mod bigint_tests {\n         ).to_uint() == 0);\n     }\n \n-    const sum_triples: &static/[(&static/[BigDigit],\n-                                 &static/[BigDigit],\n-                                 &static/[BigDigit])] = &[\n+    const sum_triples: &'static [(&'static [BigDigit],\n+                                 &'static [BigDigit],\n+                                 &'static [BigDigit])] = &[\n         (&[],          &[],       &[]),\n         (&[],          &[ 1],     &[ 1]),\n         (&[ 1],        &[ 1],     &[ 2]),\n@@ -1451,9 +1451,9 @@ mod bigint_tests {\n         }\n     }\n \n-    const mul_triples: &static/[(&static/[BigDigit],\n-                                 &static/[BigDigit],\n-                                 &static/[BigDigit])] = &[\n+    const mul_triples: &'static [(&'static [BigDigit],\n+                                 &'static [BigDigit],\n+                                 &'static [BigDigit])] = &[\n         (&[],               &[],               &[]),\n         (&[],               &[ 1],             &[]),\n         (&[ 2],             &[],               &[]),\n@@ -1477,10 +1477,10 @@ mod bigint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    const divmod_quadruples: &static/[(&static/[BigDigit],\n-                                       &static/[BigDigit],\n-                                       &static/[BigDigit],\n-                                       &static/[BigDigit])]\n+    const divmod_quadruples: &'static [(&'static [BigDigit],\n+                                       &'static [BigDigit],\n+                                       &'static [BigDigit],\n+                                       &'static [BigDigit])]\n         = &[\n             (&[ 1],        &[ 2], &[],               &[1]),\n             (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),"}, {"sha": "90269e28b8a42a7d01caadacfdc3cd8d49e884dc", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -49,17 +49,17 @@ pub impl<T> Deque<T> {\n     /// Return a reference to the first element in the deque\n     ///\n     /// Fails if the deque is empty\n-    fn peek_front(&self) -> &self/T { get(self.elts, self.lo) }\n+    fn peek_front(&self) -> &'self T { get(self.elts, self.lo) }\n \n     /// Return a reference to the last element in the deque\n     ///\n     /// Fails if the deque is empty\n-    fn peek_back(&self) -> &self/T { get(self.elts, self.hi - 1u) }\n+    fn peek_back(&self) -> &'self T { get(self.elts, self.hi - 1u) }\n \n     /// Retrieve an element in the deque by index\n     ///\n     /// Fails if there is no element with the given index\n-    fn get(&self, i: int) -> &self/T {\n+    fn get(&self, i: int) -> &'self T {\n         let idx = (self.lo + (i as uint)) % self.elts.len();\n         get(self.elts, idx)\n     }\n@@ -130,7 +130,7 @@ fn grow<T>(nelts: uint, lo: uint, elts: &mut [Option<T>]) -> ~[Option<T>] {\n     rv\n }\n \n-fn get<T>(elts: &r/[Option<T>], i: uint) -> &r/T {\n+fn get<T>(elts: &'r [Option<T>], i: uint) -> &'r T {\n     match elts[i] { Some(ref t) => t, _ => fail!() }\n }\n "}, {"sha": "4867204ea39aa58feccb0d4c7034bf645b752f4d", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -55,7 +55,7 @@ pub impl<A:Copy> Future<A> {\n \n pub impl<A> Future<A> {\n \n-    pure fn get_ref(&self) -> &self/A {\n+    pure fn get_ref(&self) -> &'self A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n         * pointer to the result.  The borrowed pointer lasts as long as"}, {"sha": "e52d08c40fe3353b6f5aa11fe5b14906f05a35a8", "filename": "src/libstd/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -748,20 +748,20 @@ pub fn from_str(s: &str) -> Result<Json, Error> {\n \n pub struct Decoder {\n     priv json: Json,\n-    priv mut stack: ~[&self/Json],\n+    priv mut stack: ~[&'self Json],\n }\n \n pub fn Decoder(json: Json) -> Decoder {\n     Decoder { json: json, stack: ~[] }\n }\n \n priv impl Decoder/&self {\n-    fn peek(&self) -> &self/Json {\n+    fn peek(&self) -> &'self Json {\n         if self.stack.len() == 0 { self.stack.push(&self.json); }\n         self.stack[self.stack.len() - 1]\n     }\n \n-    fn pop(&self) -> &self/Json {\n+    fn pop(&self) -> &'self Json {\n         if self.stack.len() == 0 { self.stack.push(&self.json); }\n         self.stack.pop()\n     }"}, {"sha": "b9b5075c4349803c7f54178e88b5b012a3358e02", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -50,10 +50,10 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n \n pub impl <T:Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n-    pure fn top(&self) -> &self/T { &self.data[0] }\n+    pure fn top(&self) -> &'self T { &self.data[0] }\n \n     /// Returns the greatest item in the queue - None if empty\n-    pure fn maybe_top(&self) -> Option<&self/T> {\n+    pure fn maybe_top(&self) -> Option<&'self T> {\n         if self.is_empty() { None } else { Some(self.top()) }\n     }\n "}, {"sha": "2c927b5db16cfab55c50ea43d35326519ae4d0ff", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -213,7 +213,7 @@ impl<D:Decoder> Decodable<D> for i64 {\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for &self/str {\n+impl<S:Encoder> Encodable<S> for &'self str {\n     fn encode(&self, s: &S) { s.emit_borrowed_str(*self) }\n }\n \n@@ -286,7 +286,7 @@ impl<D:Decoder> Decodable<D> for () {\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for &self/T {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for &'self T {\n     fn encode(&self, s: &S) {\n         s.emit_borrowed(|| (**self).encode(s))\n     }\n@@ -316,7 +316,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for &self/[T] {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     fn encode(&self, s: &S) {\n         do s.emit_borrowed_vec(self.len()) {\n             for self.eachi |i, e| {"}, {"sha": "c63ef9b72584bd3c5987d28e0939cc8f9c6267a5", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -22,9 +22,9 @@ pub struct SmallIntMap<T> {\n     priv v: ~[Option<T>],\n }\n \n-impl<V> BaseIter<(uint, &self/V)> for SmallIntMap<V> {\n+impl<V> BaseIter<(uint, &'self V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in order\n-    pure fn each(&self, it: &fn(&(uint, &self/V)) -> bool) {\n+    pure fn each(&self, it: &fn(&(uint, &'self V)) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n               Some(ref elt) => if !it(&(i, elt)) { break },\n@@ -36,9 +36,9 @@ impl<V> BaseIter<(uint, &self/V)> for SmallIntMap<V> {\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<V> ReverseIter<(uint, &self/V)> for SmallIntMap<V> {\n+impl<V> ReverseIter<(uint, &'self V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, it: &fn(&(uint, &self/V)) -> bool) {\n+    pure fn each_reverse(&self, it: &fn(&(uint, &'self V)) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n               Some(ref elt) => if !it(&(i - 1, elt)) { break },\n@@ -96,7 +96,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Iterate over the map and mutate the contained values\n-    pure fn find(&self, key: &uint) -> Option<&self/V> {\n+    pure fn find(&self, key: &uint) -> Option<&'self V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n               Some(ref value) => Some(value),\n@@ -136,7 +136,7 @@ pub impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n     static pure fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n-    pure fn get(&self, key: &uint) -> &self/V {\n+    pure fn get(&self, key: &uint) -> &'self V {\n         self.find(key).expect(\"key not present\")\n     }\n }"}, {"sha": "43c68196eb826840422719f094d033e1ec1c1d48", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -16,7 +16,7 @@ use core::util;\n use core::vec::{len, push};\n use core::vec;\n \n-type Le<T> = &self/pure fn(v1: &T, v2: &T) -> bool;\n+type Le<T> = &'self pure fn(v1: &T, v2: &T) -> bool;\n \n /**\n  * Merge sort. Returns a new vector containing the sorted list.\n@@ -168,7 +168,7 @@ pub trait Sort {\n     fn qsort(self);\n }\n \n-impl<T:Copy + Ord + Eq> Sort for &self/mut [T] {\n+impl<T:Copy + Ord + Eq> Sort for &'self mut [T] {\n     fn qsort(self) { quick_sort3(self); }\n }\n \n@@ -868,7 +868,7 @@ mod tests {\n     #[test]\n     pub fn test_merge_sort_stability() {\n         // tjc: funny that we have to use parens\n-        pure fn ile(x: &(&static/str), y: &(&static/str)) -> bool\n+        pure fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n         {\n             unsafe // to_lower is not pure...\n             {\n@@ -1172,7 +1172,7 @@ mod big_tests {\n \n     struct LVal {\n         val: uint,\n-        key: &self/fn(@uint),\n+        key: &'self fn(@uint),\n     }\n \n     impl Drop for LVal/&self {\n@@ -1190,16 +1190,16 @@ mod big_tests {\n     }\n \n     impl Ord for LVal/&self {\n-        pure fn lt(&self, other: &a/LVal/&self) -> bool {\n+        pure fn lt(&self, other: &'a LVal/&self) -> bool {\n             (*self).val < other.val\n         }\n-        pure fn le(&self, other: &a/LVal/&self) -> bool {\n+        pure fn le(&self, other: &'a LVal/&self) -> bool {\n             (*self).val <= other.val\n         }\n-        pure fn gt(&self, other: &a/LVal/&self) -> bool {\n+        pure fn gt(&self, other: &'a LVal/&self) -> bool {\n             (*self).val > other.val\n         }\n-        pure fn ge(&self, other: &a/LVal/&self) -> bool {\n+        pure fn ge(&self, other: &'a LVal/&self) -> bool {\n             (*self).val >= other.val\n         }\n     }"}, {"sha": "cecf9686327d1aba329956572cd50acb97856433", "filename": "src/libstd/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstats.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -30,7 +30,7 @@ pub trait Stats {\n     fn median_abs_dev_pct(self) -> f64;\n }\n \n-impl Stats for &self/[f64] {\n+impl Stats for &'self [f64] {\n     fn sum(self) -> f64 {\n         vec::foldl(0.0, self, |p,q| p + *q)\n     }"}, {"sha": "d556be6b85bd9ec8088c5ed40810be6791756560", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -165,29 +165,29 @@ pub impl Sem<~[Waitqueue]> {\n #[doc(hidden)]\n type SemRelease = SemReleaseGeneric/&self<()>;\n type SemAndSignalRelease = SemReleaseGeneric/&self<~[Waitqueue]>;\n-struct SemReleaseGeneric<Q> { sem: &self/Sem<Q> }\n+struct SemReleaseGeneric<Q> { sem: &'self Sem<Q> }\n \n impl<Q:Owned> Drop for SemReleaseGeneric/&self<Q> {\n     fn finalize(&self) {\n         self.sem.release();\n     }\n }\n \n-fn SemRelease(sem: &r/Sem<()>) -> SemRelease/&r {\n+fn SemRelease(sem: &'r Sem<()>) -> SemRelease/&r {\n     SemReleaseGeneric {\n         sem: sem\n     }\n }\n \n-fn SemAndSignalRelease(sem: &r/Sem<~[Waitqueue]>)\n+fn SemAndSignalRelease(sem: &'r Sem<~[Waitqueue]>)\n     -> SemAndSignalRelease/&r {\n     SemReleaseGeneric {\n         sem: sem\n     }\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-pub struct Condvar { priv sem: &self/Sem<~[Waitqueue]> }\n+pub struct Condvar { priv sem: &'self Sem<~[Waitqueue]> }\n \n impl Drop for Condvar/&self { fn finalize(&self) {} }\n \n@@ -258,7 +258,7 @@ pub impl Condvar/&self {\n         // mutex during unwinding. As long as the wrapper (mutex, etc) is\n         // bounded in when it gets released, this shouldn't hang forever.\n         struct SemAndSignalReacquire {\n-            sem: &self/Sem<~[Waitqueue]>,\n+            sem: &'self Sem<~[Waitqueue]>,\n         }\n \n         impl Drop for SemAndSignalReacquire/&self {\n@@ -272,7 +272,7 @@ pub impl Condvar/&self {\n             }\n         }\n \n-        fn SemAndSignalReacquire(sem: &r/Sem<~[Waitqueue]>)\n+        fn SemAndSignalReacquire(sem: &'r Sem<~[Waitqueue]>)\n             -> SemAndSignalReacquire/&r {\n             SemAndSignalReacquire {\n                 sem: sem\n@@ -610,7 +610,7 @@ pub impl RWlock {\n // FIXME(#3588) should go inside of read()\n #[doc(hidden)]\n struct RWlockReleaseRead {\n-    lock: &self/RWlock,\n+    lock: &'self RWlock,\n }\n \n impl Drop for RWlockReleaseRead/&self {\n@@ -635,7 +635,7 @@ impl Drop for RWlockReleaseRead/&self {\n     }\n }\n \n-fn RWlockReleaseRead(lock: &r/RWlock) -> RWlockReleaseRead/&r {\n+fn RWlockReleaseRead(lock: &'r RWlock) -> RWlockReleaseRead/&r {\n     RWlockReleaseRead {\n         lock: lock\n     }\n@@ -644,7 +644,7 @@ fn RWlockReleaseRead(lock: &r/RWlock) -> RWlockReleaseRead/&r {\n // FIXME(#3588) should go inside of downgrade()\n #[doc(hidden)]\n struct RWlockReleaseDowngrade {\n-    lock: &self/RWlock,\n+    lock: &'self RWlock,\n }\n \n impl Drop for RWlockReleaseDowngrade/&self {\n@@ -677,18 +677,18 @@ impl Drop for RWlockReleaseDowngrade/&self {\n     }\n }\n \n-fn RWlockReleaseDowngrade(lock: &r/RWlock) -> RWlockReleaseDowngrade/&r {\n+fn RWlockReleaseDowngrade(lock: &'r RWlock) -> RWlockReleaseDowngrade/&r {\n     RWlockReleaseDowngrade {\n         lock: lock\n     }\n }\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n-pub struct RWlockWriteMode { priv lock: &self/RWlock }\n+pub struct RWlockWriteMode { priv lock: &'self RWlock }\n impl Drop for RWlockWriteMode/&self { fn finalize(&self) {} }\n \n /// The \"read permission\" token used for rwlock.write_downgrade().\n-pub struct RWlockReadMode  { priv lock: &self/RWlock }\n+pub struct RWlockReadMode  { priv lock: &'self RWlock }\n impl Drop for RWlockReadMode/&self { fn finalize(&self) {} }\n \n pub impl RWlockWriteMode/&self {"}, {"sha": "63cf4c998df7f212e21f1c5133441da816510457", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -49,7 +49,7 @@ pub mod rustrt {\n // hierarchically it may.\n \n pub enum TestName {\n-    StaticTestName(&static/str),\n+    StaticTestName(&'static str),\n     DynTestName(~str)\n }\n impl ToStr for TestName {"}, {"sha": "7192da7b88e1f6f383261495bb10539420cebecc", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -88,7 +88,7 @@ impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n \n impl<'self, K: TotalOrd, V> BaseIter<(&'self K, &'self V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in order\n-    pure fn each(&self, f: &fn(&(&self/K, &self/V)) -> bool) {\n+    pure fn each(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n         each(&self.root, f)\n     }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n@@ -99,7 +99,7 @@ impl<'self, K: TotalOrd, V>\n     for TreeMap<K, V>\n {\n     /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, f: &fn(&(&self/K, &self/V)) -> bool) {\n+    pure fn each_reverse(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n         each_reverse(&self.root, f);\n     }\n }\n@@ -140,8 +140,8 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Return the value corresponding to the key in the map\n-    pure fn find(&self, key: &K) -> Option<&self/V> {\n-        let mut current: &self/Option<~TreeNode<K, V>> = &self.root;\n+    pure fn find(&self, key: &K) -> Option<&'self V> {\n+        let mut current: &'self Option<~TreeNode<K, V>> = &self.root;\n         loop {\n             match *current {\n               Some(ref r) => {\n@@ -197,15 +197,15 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<K, V> {\n-    priv stack: ~[&self/~TreeNode<K, V>],\n-    priv node: &self/Option<~TreeNode<K, V>>\n+    priv stack: ~[&'self ~TreeNode<K, V>],\n+    priv node: &'self Option<~TreeNode<K, V>>\n }\n \n /// Advance the iterator to the next node (in order) and return a\n /// tuple with a reference to the key and value. If there are no\n /// more nodes, return `None`.\n pub fn map_next<K, V>(iter: &mut TreeMapIterator/&r<K, V>)\n-                        -> Option<(&r/K, &r/V)> {\n+                        -> Option<(&'r K, &'r V)> {\n     while !iter.stack.is_empty() || iter.node.is_some() {\n         match *iter.node {\n           Some(ref x) => {\n@@ -224,7 +224,7 @@ pub fn map_next<K, V>(iter: &mut TreeMapIterator/&r<K, V>)\n \n /// Advance the iterator through the map\n pub fn map_advance<K, V>(iter: &mut TreeMapIterator/&r<K, V>,\n-                         f: &fn((&r/K, &r/V)) -> bool) {\n+                         f: &fn((&'r K, &'r V)) -> bool) {\n     loop {\n         match map_next(iter) {\n           Some(x) => {\n@@ -519,14 +519,14 @@ pub struct TreeSetIterator<T> {\n /// Advance the iterator to the next node (in order). If this iterator is\n /// finished, does nothing.\n #[inline(always)]\n-pub fn set_next<T>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n+pub fn set_next<T>(iter: &mut TreeSetIterator/&r<T>) -> Option<&'r T> {\n     do map_next(&mut iter.iter).map |&(value, _)| { value }\n }\n \n /// Advance the iterator through the set\n #[inline(always)]\n pub fn set_advance<T>(iter: &mut TreeSetIterator/&r<T>,\n-                      f: &fn(&r/T) -> bool) {\n+                      f: &fn(&'r T) -> bool) {\n     do map_advance(&mut iter.iter) |(k, _)| { f(k) }\n }\n \n@@ -547,16 +547,16 @@ pub impl<K: TotalOrd, V> TreeNode<K, V> {\n     }\n }\n \n-pure fn each<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n-                             f: &fn(&(&r/K, &r/V)) -> bool) {\n+pure fn each<K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n+                             f: &fn(&(&'r K, &'r V)) -> bool) {\n     for node.each |x| {\n         each(&x.left, f);\n         if f(&(&x.key, &x.value)) { each(&x.right, f) }\n     }\n }\n \n-pure fn each_reverse<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n-                                     f: &fn(&(&r/K, &r/V)) -> bool) {\n+pure fn each_reverse<K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n+                                     f: &fn(&(&'r K, &'r V)) -> bool) {\n     for node.each |x| {\n         each_reverse(&x.right, f);\n         if f(&(&x.key, &x.value)) { each_reverse(&x.left, f) }"}, {"sha": "652bc541a1f2e31f2cd059aa3ad2394086a78c7f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -421,7 +421,7 @@ pub fn get_exprs_from_tts(cx: @ext_ctxt, tts: &[ast::token_tree])\n // use a top-level managed pointer by some difficulties\n // with pushing and popping functionally, and the ownership\n // issues.  As a result, the values returned by the table\n-// also need to be managed; the &self/... type that Maps\n+// also need to be managed; the &'self ... type that Maps\n // return won't work for things that need to get outside\n // of that managed pointer.  The easiest way to do this\n // is just to insist that the values in the tables are\n@@ -454,7 +454,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // ugh: can't get this to compile with mut because of the\n     // lack of flow sensitivity.\n-    fn get_map(&self) -> &self/LinearMap<K,@V> {\n+    fn get_map(&self) -> &'self LinearMap<K,@V> {\n         match *self {\n             BaseMapChain (~ref map) => map,\n             ConsMapChain (~ref map,_) => map"}, {"sha": "54b123bff2ff9c631240cf2b1d91e1e8ee9656f0", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -45,12 +45,12 @@ pub impl Junction {\n     }\n }\n \n-type ExpandDerivingStructDefFn = &self/fn(@ext_ctxt,\n+type ExpandDerivingStructDefFn = &'self fn(@ext_ctxt,\n                                           span,\n                                           x: &struct_def,\n                                           ident,\n                                           y: &Generics) -> @item;\n-type ExpandDerivingEnumDefFn = &self/fn(@ext_ctxt,\n+type ExpandDerivingEnumDefFn = &'self fn(@ext_ctxt,\n                                         span,\n                                         x: &enum_def,\n                                         ident,"}, {"sha": "2cf52c47959b3000317d6232994c0d4a16d0a086", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -392,6 +392,12 @@ fn mk_token(cx: @ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n                                     build::mk_lit(cx, sp, ast::lit_bool(b))]);\n         }\n \n+        LIFETIME(ident) => {\n+            return build::mk_call(cx, sp,\n+                                  ids_ext(cx, ~[~\"LIFETIME\"]),\n+                                  ~[mk_ident(cx, sp, ident)]);\n+        }\n+\n         DOC_COMMENT(ident) => {\n             return build::mk_call(cx, sp,\n                                   ids_ext(cx, ~[~\"DOC_COMMENT\"]),"}, {"sha": "dbabca55a11f40bdaadb41955f241a447cf5d988", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -61,7 +61,7 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    pure fn get(&self, i: uint) -> &self/T {\n+    pure fn get(&self, i: uint) -> &'self T {\n         match *self {\n             Empty => fail!(fmt!(\"Invalid index %u\", i)),\n             Vec(ref v) => &v[i]"}, {"sha": "7b7d246c324d7d86fe281d90cb96290e70eb28d2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -708,7 +708,7 @@ pub impl Parser {\n     }\n \n     fn parse_borrowed_pointee(&self) -> ty_ {\n-        // look for `&'lt` or `&foo/` and interpret `foo` as the region name:\n+        // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = self.parse_opt_lifetime();\n \n         if self.token_is_closure_keyword(&copy *self.token) {"}, {"sha": "945004ede6de84518702b6e889d6027d3f2258a6", "filename": "src/test/auxiliary/cci_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fauxiliary%2Fcci_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fauxiliary%2Fcci_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_const.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -11,6 +11,6 @@\n pub extern fn bar() {\n }\n \n-pub const foopy: &static/str = \"hi there\";\n+pub const foopy: &'static str = \"hi there\";\n pub const uint_val: uint = 12;\n pub const uint_expr: uint = (1 << uint_val) - 1;"}, {"sha": "640bc887731f90912cf40251015fea8c58a18a82", "filename": "src/test/compile-fail/borrowck-addr-of-upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(x: @int) -> @fn() -> &static/int {\n-    let result: @fn() -> &static/int = || &*x;  //~ ERROR illegal borrow\n+fn foo(x: @int) -> @fn() -> &'static int {\n+    let result: @fn() -> &'static int = || &*x;  //~ ERROR illegal borrow\n     result\n }\n "}, {"sha": "45e39b47d23718ed6fe3b8883094086d4971063b", "filename": "src/test/compile-fail/const-cast-different-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const a: &static/str = &\"foo\";\n+const a: &'static str = &\"foo\";\n const b: *u8 = a as *u8; //~ ERROR non-scalar cast\n const c: *u8 = &a as *u8; //~ ERROR mismatched types\n "}, {"sha": "da3728ff3ae121414b76640ec4483c5adb1dd5e7", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -22,6 +22,6 @@ impl<A> vec_monad<A> for ~[A] {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR type `[&static/str * 1]` does not implement any method in scope named `bind`\n+    //~^ ERROR type `[&'static str * 1]` does not implement any method in scope named `bind`\n     //~^^ ERROR Unconstrained region variable\n }"}, {"sha": "2b52cab7fe79ac28cc646424b22f0c817dc6830c", "filename": "src/test/compile-fail/issue-2478.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-2478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-2478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2478.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // xfail-test\n-fn foo() -> &a/int {\n+fn foo() -> &'a int {\n     return &x;\n }\n const x: int = 5;"}, {"sha": "f235c4bc97c41e5c3f8a31ac2f344b8139541aea", "filename": "src/test/compile-fail/issue-3243.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-test\n fn function() -> &mut [int] {\n-    let mut x: &static/mut [int] = &[1,2,3];\n+    let mut x: &'static mut [int] = &[1,2,3];\n     x[0] = 12345;\n     x //~ ERROR bad\n }"}, {"sha": "1b83cefbf33988fd9fb13d634531ddac756b4d53", "filename": "src/test/compile-fail/issue-3311.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -15,7 +15,7 @@ struct Foo {\n }\n \n pub impl Foo<'self> {\n-    fn get_s(&self) -> &self/str {\n+    fn get_s(&self) -> &'self str {\n         self.s\n     }\n }"}, {"sha": "0388f0fd29083aefcea8a70d8d01b1edfc7f8476", "filename": "src/test/compile-fail/issue-3563.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -10,7 +10,7 @@\n \n trait A {\n   fn a(&self) {\n-      || self.b() //~ ERROR type `&self/self` does not implement any method in scope named `b`\n+      || self.b() //~ ERROR type `&'self self` does not implement any method in scope named `b`\n   }\n }\n fn main() {}"}, {"sha": "482d1e9fe8a4b8af5d9c22d598ee12c6148f802f", "filename": "src/test/compile-fail/issue-3888.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -10,7 +10,7 @@\n \n // n.b. This should be a run-pass test, but for now I'm testing\n // that we don't see an \"unknown scope\" error.\n-fn vec_peek<T>(v: &r/[T]) -> Option< (&r/T, &r/[T]) > {\n+fn vec_peek<T>(v: &'r [T]) -> Option< (&'r T, &'r [T]) > {\n     if v.len() == 0 {\n         None\n     } else {"}, {"sha": "ae147e628e43649d71f2af125c64b6852f2f5602", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -11,7 +11,7 @@\n // xfail-test\n fn id<T>(t: T) -> T { t }\n \n-fn f<T>(v: &r/T) -> &r/fn()->T { id::<&r/fn()->T>(|| *v) } //~ ERROR ???\n+fn f<T>(v: &'r T) -> &'r fn()->T { id::<&'r fn()->T>(|| *v) } //~ ERROR ???\n \n fn main() {\n     let v = &5;"}, {"sha": "e8e2702937110f064456365b4e6472386e4e65b5", "filename": "src/test/compile-fail/issue-4523.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -10,7 +10,7 @@\n \n fn foopy() {}\n \n-const f: &'static fn() = foopy; //~ ERROR mismatched types: expected `&static/fn()`\n+const f: &'static fn() = foopy; //~ ERROR mismatched types: expected `&'static fn()`\n \n fn main () {\n     f();"}, {"sha": "dadc66b5029c784a389a2651e127187c9c5ecbbd", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -21,10 +21,10 @@ fn repeater<A:Copy>(v: @A) -> @repeat<A> {\n \n fn main() {\n     // Error results because the type of is inferred to be\n-    // @repeat<&blk/int> where blk is the lifetime of the block below.\n+    // @repeat<&'blk int> where blk is the lifetime of the block below.\n \n     let y = { //~ ERROR reference is not valid\n-        let x: &blk/int = &3;\n+        let x: &'blk int = &3;\n         repeater(@x)\n     };\n     fail_unless!(3 == *(y.get())); //~ ERROR reference is not valid"}, {"sha": "63690f030934f260a0af2c749cb9940097e8ec2b", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -12,7 +12,7 @@\n // except according to those terms.\n \n // A dummy trait/impl that work close over any type.  The trait will\n-// be parameterized by a region due to the &self/int constraint.\n+// be parameterized by a region due to the &'self int constraint.\n \n trait foo {\n     fn foo(&self, i: &'self int) -> int;"}, {"sha": "732d946bf9ee534cfc577571045c490dcac12751", "filename": "src/test/compile-fail/regions-addr-of-self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -14,12 +14,12 @@ struct dog {\n \n pub impl dog {\n     fn chase_cat(&mut self) {\n-        let p: &static/mut uint = &mut self.cats_chased; //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+        let p: &'static mut uint = &mut self.cats_chased; //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n         *p += 1u;\n     }\n \n     fn chase_cat_2(&mut self) {\n-        let p: &blk/mut uint = &mut self.cats_chased;\n+        let p: &'blk mut uint = &mut self.cats_chased;\n         *p += 1u;\n     }\n }"}, {"sha": "893e4c411780b8a0ee69733b4c0dba7b20c3d758", "filename": "src/test/compile-fail/regions-blk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-blk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-blk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-blk.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -10,13 +10,13 @@\n \n fn foo(cond: bool) {\n     let x = 5;\n-    let mut y: &blk/int = &x;\n+    let mut y: &'blk int = &x;\n \n-    let mut z: &blk/int;\n+    let mut z: &'blk int;\n     if cond {\n         z = &x; //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n     } else {\n-        let w: &blk/int = &x;\n+        let w: &'blk int = &x;\n         z = w;\n     }\n }"}, {"sha": "df078bbb54b6d83d7a92a9ed039149696e22eb29", "filename": "src/test/compile-fail/regions-fn-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-fn-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-fn-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-bound.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -11,7 +11,7 @@\n fn of<T>() -> @fn(T) { fail!(); }\n fn subtype<T>(x: @fn(T)) { fail!(); }\n \n-fn test_fn<T>(_x: &x/T, _y: &y/T, _z: &z/T) {\n+fn test_fn<T>(_x: &'x T, _y: &'y T, _z: &'z T) {\n     // Here, x, y, and z are free.  Other letters\n     // are bound.  Note that the arrangement\n     // subtype::<T1>(of::<T2>()) will typecheck"}, {"sha": "a90b3d0f42970450df9197ba54f8ecdbc0564dee", "filename": "src/test/compile-fail/regions-fn-subtyping.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -11,47 +11,47 @@\n fn of<T>() -> @fn(T) { fail!(); }\n fn subtype<T>(x: @fn(T)) { fail!(); }\n \n-fn test_fn<T>(_x: &x/T, _y: &y/T, _z: &z/T) {\n+fn test_fn<T>(_x: &'x T, _y: &'y T, _z: &'z T) {\n     // Here, x, y, and z are free.  Other letters\n     // are bound.  Note that the arrangement\n     // subtype::<T1>(of::<T2>()) will typecheck\n     // iff T1 <: T2.\n \n-    subtype::<&fn(&a/T)>(\n-        of::<&fn(&a/T)>());\n+    subtype::<&fn(&'a T)>(\n+        of::<&fn(&'a T)>());\n \n-    subtype::<&fn(&a/T)>(\n-        of::<&fn(&b/T)>());\n+    subtype::<&fn(&'a T)>(\n+        of::<&fn(&'b T)>());\n \n-    subtype::<&fn(&b/T)>(\n-        of::<&fn(&x/T)>());\n+    subtype::<&fn(&'b T)>(\n+        of::<&fn(&'x T)>());\n \n-    subtype::<&fn(&x/T)>(\n-        of::<&fn(&b/T)>());  //~ ERROR mismatched types\n+    subtype::<&fn(&'x T)>(\n+        of::<&fn(&'b T)>());  //~ ERROR mismatched types\n \n-    subtype::<&fn(&a/T, &b/T)>(\n-        of::<&fn(&a/T, &a/T)>());\n+    subtype::<&fn(&'a T, &'b T)>(\n+        of::<&fn(&'a T, &'a T)>());\n \n-    subtype::<&fn(&a/T, &a/T)>(\n-        of::<&fn(&a/T, &b/T)>()); //~ ERROR mismatched types\n+    subtype::<&fn(&'a T, &'a T)>(\n+        of::<&fn(&'a T, &'b T)>()); //~ ERROR mismatched types\n \n-    subtype::<&fn(&a/T, &b/T)>(\n-        of::<&fn(&x/T, &y/T)>());\n+    subtype::<&fn(&'a T, &'b T)>(\n+        of::<&fn(&'x T, &'y T)>());\n \n-    subtype::<&fn(&x/T, &y/T)>(\n-        of::<&fn(&a/T, &b/T)>()); //~ ERROR mismatched types\n+    subtype::<&fn(&'x T, &'y T)>(\n+        of::<&fn(&'a T, &'b T)>()); //~ ERROR mismatched types\n \n-    subtype::<&fn(&x/T) -> @fn(&a/T)>(\n-        of::<&fn(&x/T) -> @fn(&a/T)>());\n+    subtype::<&fn(&'x T) -> @fn(&'a T)>(\n+        of::<&fn(&'x T) -> @fn(&'a T)>());\n \n-    subtype::<&fn(&a/T) -> @fn(&a/T)>(\n-        of::<&fn(&a/T) -> @fn(&b/T)>()); //~ ERROR mismatched types\n+    subtype::<&fn(&'a T) -> @fn(&'a T)>(\n+        of::<&fn(&'a T) -> @fn(&'b T)>()); //~ ERROR mismatched types\n \n-    subtype::<&fn(&a/T) -> @fn(&a/T)>(\n-        of::<&fn(&x/T) -> @fn(&b/T)>()); //~ ERROR mismatched types\n+    subtype::<&fn(&'a T) -> @fn(&'a T)>(\n+        of::<&fn(&'x T) -> @fn(&'b T)>()); //~ ERROR mismatched types\n \n-    subtype::<&fn(&a/T) -> @fn(&b/T)>(\n-        of::<&fn(&a/T) -> @fn(&a/T)>());\n+    subtype::<&fn(&'a T) -> @fn(&'b T)>(\n+        of::<&fn(&'a T) -> @fn(&'a T)>());\n }\n \n fn main() {}"}, {"sha": "50eba71ac564795b719150a6bc1d34f6b64ade5d", "filename": "src/test/compile-fail/regions-fns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fns.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -11,8 +11,8 @@\n // Before fn subtyping was properly implemented,\n // we reported errors in this case:\n \n-fn not_ok(a: &uint, b: &b/uint) {\n-    let mut g: @fn(x: &uint) = |x: &b/uint| {};\n+fn not_ok(a: &uint, b: &'b uint) {\n+    let mut g: @fn(x: &uint) = |x: &'b uint| {};\n     //~^ ERROR mismatched types\n     g(a);\n }"}, {"sha": "f89c5eaa9c1f67308211f4cd3682432ab3d658a5", "filename": "src/test/compile-fail/regions-freevar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn wants_static_fn(_x: &static/fn()) {}\n+fn wants_static_fn(_x: &'static fn()) {}\n \n fn main() {\n     let i = 3;"}, {"sha": "6402982a9e1541ff14454c51c23e5de1a200a9c3", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -13,7 +13,7 @@ struct point {\n     y: int,\n }\n \n-fn x_coord(p: &r/point) -> &r/int {\n+fn x_coord(p: &'r point) -> &'r int {\n     return &p.x;\n }\n "}, {"sha": "c873e2519bd020f7db6041384067a58f5157e748", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn borrow<T>(x: &r/T) -> &r/T {x}\n+fn borrow<T>(x: &'r T) -> &'r T {x}\n \n fn foo(cond: &fn() -> bool, box: &fn() -> @int) {\n     let mut y: &int;"}, {"sha": "a3bc55228d853cba082b917e4b0fd9e72a27843f", "filename": "src/test/compile-fail/regions-infer-call-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn select(x: &r/int, y: &r/int) -> &r/int { x }\n+fn select(x: &'r int, y: &'r int) -> &'r int { x }\n \n fn with<T>(f: &fn(x: &int) -> T) -> T {\n     f(&20)\n }\n \n-fn manip(x: &a/int) -> int {\n+fn manip(x: &'a int) -> int {\n     let z = do with |y| { select(x, y) };\n     //~^ ERROR cannot infer an appropriate lifetime\n     *z"}, {"sha": "d93713f3f233519918f7e91100a0b8f9dc042c98", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -14,7 +14,7 @@\n // the normal case.\n \n struct contravariant {\n-    f: @fn() -> &self/int\n+    f: @fn() -> &'self int\n }\n \n fn to_same_lifetime(bi: contravariant/&r) {"}, {"sha": "c527cdf233d6c2b5442a015703d56ed3afc78393", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -13,7 +13,7 @@\n // You can upcast to a *larger region* but not a smaller one.\n \n struct covariant {\n-    f: @fn(x: &self/int) -> int\n+    f: @fn(x: &'self int) -> int\n }\n \n fn to_same_lifetime(bi: covariant/&r) {"}, {"sha": "15b39d772f08b9a90d9c21ef17cb95336f0c6924", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct invariant {\n-    f: @fn(x: @mut &self/int)\n+    f: @fn(x: @mut &'self int)\n }\n \n fn to_same_lifetime(bi: invariant/&r) {"}, {"sha": "ff2b4246f01b83d64aab4ef33160d7f9c6ed176f", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct invariant {\n-    f: @fn() -> @mut &self/int\n+    f: @fn() -> @mut &'self int\n }\n \n fn to_same_lifetime(bi: invariant/&r) {"}, {"sha": "e4ad93bde17e6bd301a8b0634964a538e44c27ea", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -29,7 +29,7 @@ impl<'self> set_f for c<'self> {\n     }\n \n     fn set_f_bad(&self, b: @b) {\n-        self.f = b; //~ ERROR mismatched types: expected `@@&self/int` but found `@@&int`\n+        self.f = b; //~ ERROR mismatched types: expected `@@&'self int` but found `@@&int`\n     }\n }\n "}, {"sha": "26d6bbd5303142bc368758c3410f59eb7c0577fd", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -12,7 +12,7 @@ fn ignore<T>(_t: T) {}\n \n fn nested() {\n     let y = 3;\n-    ignore(|z: &z/int| -> &z/int {\n+    ignore(|z: &'z int| -> &'z int {\n         if false { &y } else { z } //~ ERROR illegal borrow\n     });\n }"}, {"sha": "6ef37efeb418e1ef5a2d42e9416626cc33b3078d", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -10,17 +10,17 @@\n \n fn ignore<T>(t: T) {}\n \n-fn nested(x: &x/int) {\n+fn nested(x: &'x int) {\n     let y = 3;\n     let mut ay = &y; //~ ERROR cannot infer an appropriate lifetime\n \n-    ignore(|z: &z/int| {\n+    ignore(|z: &'z int| {\n         ay = x;\n         ay = &y;  //~ ERROR cannot infer an appropriate lifetime\n         ay = z;\n     });\n \n-    ignore(|z: &z/int| -> &z/int {\n+    ignore(|z: &'z int| -> &'z int {\n         if false { return x; }  //~ ERROR mismatched types\n         if false { return ay; }\n         return z;"}, {"sha": "b3db225700aa26489484c45c55470413565baac6", "filename": "src/test/compile-fail/regions-out-of-scope-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-out-of-scope-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-out-of-scope-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-out-of-scope-slice.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -15,7 +15,7 @@ fn foo(cond: bool) {\n     let mut x; //~ ERROR foo\n \n     if cond {\n-        x = &blk/[1,2,3];\n+        x = &'blk [1,2,3];\n     }\n }\n "}, {"sha": "7218dcf379b95e48ac52db33e077bf025c82dfac", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -12,11 +12,11 @@\n // some point regions-ret-borrowed reported an error but this file did\n // not, due to special hardcoding around the anonymous region.\n \n-fn with<R>(f: &fn(x: &a/int) -> R) -> R {\n+fn with<R>(f: &fn(x: &'a int) -> R) -> R {\n     f(&3)\n }\n \n-fn return_it() -> &a/int {\n+fn return_it() -> &'a int {\n     with(|o| o) //~ ERROR mismatched types\n         //~^ ERROR reference is not valid outside of its lifetime\n }"}, {"sha": "cecd847843ca54d936f48066e594ef1b78e707b1", "filename": "src/test/compile-fail/regions-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(_x : &a/int) -> &a/int {\n+fn f(_x : &'a int) -> &'a int {\n     return &3; //~ ERROR illegal borrow\n }\n "}, {"sha": "f0c81d16b03c7ed1aa8d549bad6f282efd890568", "filename": "src/test/compile-fail/regions-scoping.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -17,7 +17,7 @@ fn nested<'x>(x: &'x int) {  // (1)\n          z: &fn<'z>(x: &'x int, // Refers to `x` at (1)\n                     y: &'y int, // Refers to `y` at (2)\n                     z: &'z int) -> &'z int| // A fresh region `z` (3)\n-                 -> &x/int {\n+                 -> &'x int {\n             if false { return z(x, y, x); }\n \n             if false { return z(x, y, y); }\n@@ -40,9 +40,9 @@ fn nested<'x>(x: &'x int) {  // (1)\n         // anymore but rather borrowck. Therefore, it doesn't end up\n         // getting printed out since compilation fails after typeck.\n         //\n-        // let f: &x/int = foo(&z, &z, |_x, _y, z| z ); // ERROR mismatched types: expected `&x/int` but found\n+        // let f: &'x int = foo(&z, &z, |_x, _y, z| z ); // ERROR mismatched types: expected `&'x int` but found\n \n-        foo(x, &z, |x, _y, _z| x); //~ ERROR mismatched types: expected `&z/int` but found `&x/int`\n+        foo(x, &z, |x, _y, _z| x); //~ ERROR mismatched types: expected `&'z int` but found `&'x int`\n \n         // Note: originally I had foo(x, &z, ...) here, but in that\n         // case the region inferencer deduced that this was valid if"}, {"sha": "5811496cab4519cddeb62650d0eda508c7d23cb3", "filename": "src/test/compile-fail/regions-trait-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -17,7 +17,7 @@ trait get_ctxt {\n struct has_ctxt<'self> { c: &'self ctxt }\n \n impl<'self> get_ctxt for has_ctxt<'self> {\n-    fn get_ctxt(&self) -> &self/ctxt { self.c }\n+    fn get_ctxt(&self) -> &'self ctxt { self.c }\n }\n \n fn make_gc() -> @get_ctxt  {"}, {"sha": "e947dbf93083ad308bfe1a14d85742300cd55346", "filename": "src/test/compile-fail/regions-trait-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -12,7 +12,7 @@\n // except according to those terms.\n \n trait get_ctxt {\n-    fn get_ctxt(self) -> &self/uint;\n+    fn get_ctxt(self) -> &'self uint;\n }\n \n fn make_gc1(gc: @get_ctxt/&a) -> @get_ctxt/&b  {"}, {"sha": "78bdee1430c690139ae40fe7dcd32d2a9784c64d", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -16,7 +16,7 @@ trait iterable<A> {\n     fn iterate(&self, blk: &fn(x: &A) -> bool);\n }\n \n-impl<A> iterable<A> for &self/[A] {\n+impl<A> iterable<A> for &'self [A] {\n     fn iterate(&self, f: &fn(x: &A) -> bool) {\n         for vec::each(*self) |e| {\n             if !f(e) { break; }"}, {"sha": "d8015f0b92c7ed5661f7d2c01bb1beae260aeeda", "filename": "src/test/run-pass/bare-static-string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fbare-static-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fbare-static-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbare-static-string.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x: &static/str = \"foo\";\n+    let x: &'static str = \"foo\";\n     io::println(x);\n }\n "}, {"sha": "a8823c477aa3cef316b6e3943450be31e9aafac6", "filename": "src/test/run-pass/borrowck-root-while-cond.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn borrow<T>(x: &r/T) -> &r/T {x}\n+fn borrow<T>(x: &'r T) -> &'r T {x}\n \n struct Rec { f: @int }\n "}, {"sha": "0699df703c6a3b23b34f9d1d23d75a8fb56102f0", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -1,5 +1,5 @@\n struct Wizard {\n-    spells: ~[&static/str]\n+    spells: ~[&'static str]\n }\n \n pub impl Wizard {"}, {"sha": "1e9175ac1963c1ee46273ef117e9ba9e49d19399", "filename": "src/test/run-pass/borrowed-ptr-pattern-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-3.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(s: &r/uint) -> bool {\n+fn foo(s: &'r uint) -> bool {\n     match s {\n         &3 => true,\n         _ => false"}, {"sha": "42c0795b3dd2995c3aad4a996dbea1c699b50b69", "filename": "src/test/run-pass/borrowed-ptr-pattern-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn select(x: &r/Option<int>, y: &r/Option<int>) -> &r/Option<int> {\n+fn select(x: &'r Option<int>, y: &'r Option<int>) -> &'r Option<int> {\n     match (x, y) {\n         (&None, &None) => x,\n         (&Some(_), _) => x,"}, {"sha": "64c6f368f2bfbd2d61f144f5e9a546ebc9ab0389", "filename": "src/test/run-pass/const-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -12,7 +12,7 @@ extern fn foo() {}\n \n const x: *u8 = foo;\n const y: *libc::c_void = x as *libc::c_void;\n-const a: &static/int = &10;\n+const a: &'static int = &10;\n const b: *int = a as *int;\n \n fn main() {"}, {"sha": "e01519ae8a5479659f8aa270c433f5a3d7100d47", "filename": "src/test/run-pass/const-cross-crate-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fconst-cross-crate-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fconst-cross-crate-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cross-crate-const.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -12,7 +12,7 @@\n // aux-build:cci_const.rs\n \n extern mod cci_const;\n-const foo: &static/str = cci_const::foopy;\n+const foo: &'static str = cci_const::foopy;\n const a: uint = cci_const::uint_val;\n const b: uint = cci_const::uint_expr + 5;\n "}, {"sha": "594350d29885c9b2b7969d17b19c986b0e98e5f4", "filename": "src/test/run-pass/const-enum-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fconst-enum-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fconst-enum-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-ptr.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n enum E { V0, V1(int) }\n-const C: &static/E = &V0;\n+const C: &'static E = &V0;\n \n pub fn main() {\n     match *C {"}, {"sha": "b398bfbf0d5c1ca117823fa2b7a169871977f322", "filename": "src/test/run-pass/const-enum-vec-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fconst-enum-vec-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fconst-enum-vec-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-ptr.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n enum E { V1(int), V0 }\n-const C: &static/[E] = &[V0, V1(0xDEADBEE), V0];\n+const C: &'static [E] = &[V0, V1(0xDEADBEE), V0];\n \n pub fn main() {\n     match C[1] {"}, {"sha": "a1637f6ebb831e3adbc0143fdb879300d861d9a9", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n const a: [u8 * 3] = ['h' as u8, 'i' as u8, 0 as u8];\n-const c: &static/[u8 * 3] = &a;\n+const c: &'static [u8 * 3] = &a;\n const b: *u8 = c as *u8;\n \n fn main() {"}, {"sha": "1a21fa0a5d75987351faa2177495dc426e97cb99", "filename": "src/test/run-pass/explicit-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -29,13 +29,13 @@ fn compute_area(shape: &shape) -> float {\n pub impl shape {\n     // self is in the implicit self region\n     fn select<T>(&self, threshold: float,\n-                 a: &r/T, b: &r/T) -> &r/T {\n+                 a: &'r T, b: &'r T) -> &'r T {\n         if compute_area(self) > threshold {a} else {b}\n     }\n }\n \n fn select_based_on_unit_circle<T>(\n-    threshold: float, a: &r/T, b: &r/T) -> &r/T {\n+    threshold: float, a: &'r T, b: &'r T) -> &'r T {\n \n     let shape = &circle(Point{x: 0.0, y: 0.0}, 1.0);\n     shape.select(threshold, a, b)\n@@ -58,7 +58,7 @@ pub impl thing {\n     fn foo(@self) -> int { *self.x.a }\n     fn bar(~self) -> int { *self.x.a }\n     fn quux(&self) -> int { *self.x.a }\n-    fn baz(&self) -> &self/A { &self.x }\n+    fn baz(&self) -> &'self A { &self.x }\n     fn spam(self) -> int { *self.x.a }\n }\n "}, {"sha": "cfae757aee82efd2f6af4780e8f55b826df0c686", "filename": "src/test/run-pass/issue-2502.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2502.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -13,12 +13,12 @@ struct font {\n }\n \n pub impl font/&self {\n-    fn buf(&self) -> &self/~[u8] {\n+    fn buf(&self) -> &'self ~[u8] {\n         self.fontbuf\n     }\n }\n \n-fn font(fontbuf: &r/~[u8]) -> font/&r {\n+fn font(fontbuf: &'r ~[u8]) -> font/&r {\n     font {\n         fontbuf: fontbuf\n     }"}, {"sha": "62016abf74b35c7f693191c93cfb2821c726f3e6", "filename": "src/test/run-pass/issue-2748-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fissue-2748-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fissue-2748-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2748-b.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn thing(x: &r/[int]) -> &r/[int] { x }\n+fn thing(x: &'r [int]) -> &'r [int] { x }\n pub fn main() {\n     let x = &[1,2,3];\n     let y = x;"}, {"sha": "18839fa3c7fc46f21d3d5b43d45483e1bb8bc632", "filename": "src/test/run-pass/issue-3860.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fissue-3860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fissue-3860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3860.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -11,7 +11,7 @@\n struct Foo { x: int }\n \n pub impl Foo {\n-    fn stuff(&mut self) -> &self/mut Foo {\n+    fn stuff(&mut self) -> &'self mut Foo {\n         return self;\n     }\n }"}, {"sha": "38aeab0888c603ce6f1bcbc38e770ca45de0afde", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn vec_peek<T>(v: &r/[T]) -> &r/[T] {\n+fn vec_peek<T>(v: &'r [T]) -> &'r [T] {\n // This doesn't work, and should.\n //    v.slice(1, 5)\n     vec::slice(v, 1, 5)"}, {"sha": "0a9c731e9b82a1b5c76687b766f177e11de4612d", "filename": "src/test/run-pass/issue-4448.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4448.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let (port, chan) = comm::stream::<&static/str>();\n+    let (port, chan) = comm::stream::<&'static str>();\n \n     do task::spawn {\n         fail_unless!(port.recv() == \"hello, world\");"}, {"sha": "8e363c3d5db53f52c615c1b46bb3e5c0135490d1", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -201,9 +201,9 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_estr_slice(&self) -> bool {\n-        self.align_to::<&static/str>();\n+        self.align_to::<&'static str>();\n         if ! self.inner.visit_estr_slice() { return false; }\n-        self.bump_past::<&static/str>();\n+        self.bump_past::<&'static str>();\n         true\n     }\n \n@@ -238,9 +238,9 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&static/u8>();\n+        self.align_to::<&'static u8>();\n         if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n-        self.bump_past::<&static/u8>();\n+        self.bump_past::<&'static u8>();\n         true\n     }\n \n@@ -276,9 +276,9 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&static/[u8]>();\n+        self.align_to::<&'static [u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n-        self.bump_past::<&static/[u8]>();\n+        self.bump_past::<&'static [u8]>();\n         true\n     }\n \n@@ -439,9 +439,9 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_self(&self) -> bool {\n-        self.align_to::<&static/u8>();\n+        self.align_to::<&'static u8>();\n         if ! self.inner.visit_self() { return false; }\n-        self.align_to::<&static/u8>();\n+        self.align_to::<&'static u8>();\n         true\n     }\n "}, {"sha": "6cad8c74592e44bc5e657408cfe78faa0c5e7908", "filename": "src/test/run-pass/region-dependent-addr-of.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -25,54 +25,54 @@ struct C {\n     f: int\n }\n \n-fn get_v1(a: &v/A) -> &v/int {\n+fn get_v1(a: &'v A) -> &'v int {\n     // Region inferencer must deduce that &v < L2 < L1\n     let foo = &a.value; // L1\n     &foo.v1             // L2\n }\n \n-fn get_v2(a: &v/A, i: uint) -> &v/int {\n+fn get_v2(a: &'v A, i: uint) -> &'v int {\n     let foo = &a.value;\n     &foo.v2[i]\n }\n \n-fn get_v3(a: &v/A, i: uint) -> &v/int {\n+fn get_v3(a: &'v A, i: uint) -> &'v int {\n     let foo = &a.value;\n     &foo.v3[i]\n }\n \n-fn get_v4(a: &v/A, i: uint) -> &v/int {\n+fn get_v4(a: &'v A, i: uint) -> &'v int {\n     let foo = &a.value;\n     &foo.v4.f\n }\n \n-fn get_v5(a: &v/A, i: uint) -> &v/int {\n+fn get_v5(a: &'v A, i: uint) -> &'v int {\n     let foo = &a.value;\n     &foo.v5.f\n }\n \n-fn get_v6_a(a: &v/A, i: uint) -> &v/int {\n+fn get_v6_a(a: &'v A, i: uint) -> &'v int {\n     match a.value.v6 {\n         Some(ref v) => &v.f,\n         None => fail!()\n     }\n }\n \n-fn get_v6_b(a: &v/A, i: uint) -> &v/int {\n+fn get_v6_b(a: &'v A, i: uint) -> &'v int {\n     match *a {\n         A { value: B { v6: Some(ref v), _ } } => &v.f,\n         _ => fail!()\n     }\n }\n \n-fn get_v6_c(a: &v/A, i: uint) -> &v/int {\n+fn get_v6_c(a: &'v A, i: uint) -> &'v int {\n     match a {\n         &A { value: B { v6: Some(ref v), _ } } => &v.f,\n         _ => fail!()\n     }\n }\n \n-fn get_v5_ref(a: &v/A, i: uint) -> &v/int {\n+fn get_v5_ref(a: &'v A, i: uint) -> &'v int {\n     match &a.value {\n         &B {v5: ~C {f: ref v}, _} => v\n     }"}, {"sha": "ced2948545f4a1e022bb4d499329975079d61339", "filename": "src/test/run-pass/region-return-interior-of-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregion-return-interior-of-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregion-return-interior-of-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregion-return-interior-of-option.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn get<T>(opt: &r/Option<T>) -> &r/T {\n+fn get<T>(opt: &'r Option<T>) -> &'r T {\n     match *opt {\n       Some(ref v) => v,\n       None => fail!(~\"none\")"}, {"sha": "622a1eb9954cf5e7bee36f4fa268ee790a769c45", "filename": "src/test/run-pass/regions-addr-of-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(x : &a/int) -> &a/int {\n+fn f(x : &'a int) -> &'a int {\n     return &*x;\n }\n "}, {"sha": "96ae71f0ff3eea2ab0dd81733e1a411c0539c497", "filename": "src/test/run-pass/regions-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-bot.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -10,7 +10,7 @@\n \n // A very limited test of the \"bottom\" region\n \n-fn produce_static<T>() -> &static/T { fail!(); }\n+fn produce_static<T>() -> &'static T { fail!(); }\n \n fn foo<T>(x: &T) -> &uint { produce_static() }\n "}, {"sha": "86b997a6008a7595a12918deba75b530f56e0f33", "filename": "src/test/run-pass/regions-equiv-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-equiv-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-equiv-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-equiv-fns.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -13,7 +13,7 @@\n \n fn ok(a: &uint) {\n     // Here &r is an alias for &:\n-    let mut g: @fn(x: &uint) = |x: &r/uint| {};\n+    let mut g: @fn(x: &uint) = |x: &'r uint| {};\n     g(a);\n }\n "}, {"sha": "e38bd64da64fa1ba09ee3750c327af827e762e87", "filename": "src/test/run-pass/regions-escape-into-other-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-escape-into-other-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-escape-into-other-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-escape-into-other-fn.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(x: &r/uint) -> &r/uint { x }\n+fn foo(x: &'r uint) -> &'r uint { x }\n fn bar(x: &uint) -> uint { *x }\n \n pub fn main() {"}, {"sha": "981eace6754981ef03bcf24509373da8ed98ccd9", "filename": "src/test/run-pass/regions-fn-subtyping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -18,14 +18,14 @@ fn ok(f: @fn(x: &uint)) {\n     // f's type should be a subtype of g's type), because f can be\n     // used in any context that expects g's type.  But this currently\n     // fails.\n-    let mut g: @fn(y: &r/uint) = |x: &r/uint| { };\n+    let mut g: @fn(y: &'r uint) = |x: &'r uint| { };\n     g = f;\n }\n \n // This version is the same as above, except that here, g's type is\n // inferred.\n fn ok_inferred(f: @fn(x: &uint)) {\n-    let mut g: @fn(x: &r/uint) = |_| {};\n+    let mut g: @fn(x: &'r uint) = |_| {};\n     g = f;\n }\n "}, {"sha": "5aff0274dc47ce1938af4fd62244916e0cc26e63", "filename": "src/test/run-pass/regions-infer-borrow-scope-view.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn view<T>(x: &r/[T]) -> &r/[T] {x}\n+fn view<T>(x: &'r [T]) -> &'r [T] {x}\n \n pub fn main() {\n     let v = ~[1, 2, 3];"}, {"sha": "fd48402dd10ab1b716a89a250ac8e0f66076b16a", "filename": "src/test/run-pass/regions-infer-borrow-scope-within-loop-ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-within-loop-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-within-loop-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-within-loop-ok.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn borrow<T>(x: &r/T) -> &r/T {x}\n+fn borrow<T>(x: &'r T) -> &'r T {x}\n \n pub fn main() {\n     let x = @3;"}, {"sha": "b5dbf0fde5cdf19f99f7220f03038888b8964cf9", "filename": "src/test/run-pass/regions-infer-borrow-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -10,7 +10,7 @@\n \n struct Point {x: int, y: int}\n \n-fn x_coord(p: &r/Point) -> &r/int {\n+fn x_coord(p: &'r Point) -> &'r int {\n     return &p.x;\n }\n "}, {"sha": "74c4c4260fc1acc2dba4bece8502122413891f12", "filename": "src/test/run-pass/regions-infer-call-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-call-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-call-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-call-2.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -14,7 +14,7 @@ fn with<T>(f: &fn(x: &int) -> T) -> T {\n     f(&20)\n }\n \n-fn has_one(x: &a/int) -> int {\n+fn has_one(x: &'a int) -> int {\n     do with |y| { takes_two(x, y) }\n }\n "}, {"sha": "66baaf401089501384bd5c794180c0ff87b77dbb", "filename": "src/test/run-pass/regions-infer-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-call.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -10,7 +10,7 @@\n \n fn takes_two(x: &int, y: &int) -> int { *x + *y }\n \n-fn has_two(x: &a/int, y: &b/int) -> int {\n+fn has_two(x: &'a int, y: &'b int) -> int {\n     takes_two(x, y)\n }\n "}, {"sha": "c45212eaa6264fb752056e8a6f30e939dbdbbeda", "filename": "src/test/run-pass/regions-infer-contravariance-due-to-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -12,7 +12,7 @@ struct boxed_int {\n     f: &'self int,\n }\n \n-fn max(bi: &r/boxed_int, f: &r/int) -> int {\n+fn max(bi: &'r boxed_int, f: &'r int) -> int {\n     if *bi.f > *f {*bi.f} else {*f}\n }\n "}, {"sha": "7d966b06e3532c934330173a926b3c4e11636522", "filename": "src/test/run-pass/regions-infer-contravariance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -16,11 +16,11 @@ fn get(bi: &'r boxed_int<'r>) -> &'r int {\n     bi.f\n }\n \n-fn with(bi: &r/boxed_int) {\n+fn with(bi: &'r boxed_int) {\n     // Here, the upcast is allowed because the `boxed_int` type is\n     // contravariant with respect to `&r`.  See also\n     // compile-fail/regions-infer-invariance-due-to-mutability.rs\n-    let bi: &blk/boxed_int/&blk = bi;\n+    let bi: &'blk boxed_int/&blk = bi;\n     fail_unless!(*get(bi) == 22);\n }\n "}, {"sha": "1066c5fd4ca70759b2ab49787ce132ac1e8de281", "filename": "src/test/run-pass/regions-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-params.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn region_identity(x: &r/uint) -> &r/uint { x }\n+fn region_identity(x: &'r uint) -> &'r uint { x }\n \n fn apply<T>(t: T, f: &fn(T) -> T) -> T { f(t) }\n "}, {"sha": "481f25745cd4dc8831fbe283e479bff6a4b8f572", "filename": "src/test/run-pass/regions-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/352c070365c941e174c17574f7fb3231e2981c5d/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-trait.rs?ref=352c070365c941e174c17574f7fb3231e2981c5d", "patch": "@@ -11,13 +11,13 @@\n struct Ctxt { v: uint }\n \n trait get_ctxt {\n-    fn get_ctxt(&self) -> &self/Ctxt;\n+    fn get_ctxt(&self) -> &'self Ctxt;\n }\n \n struct HasCtxt { c: &'self Ctxt }\n \n impl get_ctxt for HasCtxt<'self> {\n-    fn get_ctxt(&self) -> &self/Ctxt {\n+    fn get_ctxt(&self) -> &'self Ctxt {\n         self.c\n     }\n }"}]}