{"sha": "124bb03b15d439a2749a0bec0aca008cd3f0664c", "node_id": "C_kwDOAAsO6NoAKDEyNGJiMDNiMTVkNDM5YTI3NDlhMGJlYzBhY2EwMDhjZDNmMDY2NGM", "commit": {"author": {"name": "Jaeyong Sung", "email": "jaeyong0201@gmail.com", "date": "2022-02-12T19:35:36Z"}, "committer": {"name": "Jaeyong Sung", "email": "jaeyong0201@gmail.com", "date": "2022-02-12T19:35:36Z"}, "message": "changed algorithm", "tree": {"sha": "53f8c8f7edc7db5cbc0caef013bde4ffdc0c9842", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53f8c8f7edc7db5cbc0caef013bde4ffdc0c9842"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/124bb03b15d439a2749a0bec0aca008cd3f0664c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEErNAvdl6JhsmcOZwWK4aJjMsqVIYFAmIIDAgACgkQK4aJjMsq\nVIaoxw//UHaJ6TVp1yA5Kgp3c/B3pgHVBOpv0ySmXcUXPAqin7GDFIHZxqG/LR1H\n+hvh3Se02Oc6V5Hc0hbLetLeXRj1muMbJdtgZwJQikuw1DP53vkgZW4+W5tlaisI\n4tVfF+ZQrKQQWknZiBq0ydhyGI6oMzi6g3LG3xDVWcXm0LGUZYYJScc2JCVXhYz6\nMsPuhAW7oS/wTvkku996nzsPFUGvfN+0UmlvmkRhoaf34D4avJPXqUOEp4DSQWao\nREKperc0zELLn0a0K22hbguTmF9c7iHvm5NQ38vP/8S+ay0w33sDIk37PxZfHjrg\nubzV8pPUDbyveNnrB1KbVahWEtTqbx+Kvv74/+53A8ICe6DiORQVnGXIcc7l2k3e\nB7qOVEXTLVsqDEEK40HL7SJ2MgZ7Y+6QBrHSnNzNpFgeC1HEARZ4rOBOLJB7Y9vk\ngArimxoV838O8mYHZwusVw7D4TDF4RP6kiFXucDLcSTKnq/DpPw9Y9oHjAUe07tL\nhL28UvKZ7acCGQJ6FdOJKg+Wdwk/yf2YVourZ+i4BCrbYVOzElau2zLc6sJ6ZrNW\n+iKQdZCt1/xreNqvixQGYf7FGF82e70bNDmtizHNNEpxntI6p5x0gq39yBVQ6AUZ\n4uPEJYePX/FMjoZ1t4QL+hmEAdAogEKAOYfbxW8FaFagFOFQWBk=\n=fI9B\n-----END PGP SIGNATURE-----", "payload": "tree 53f8c8f7edc7db5cbc0caef013bde4ffdc0c9842\nparent 8faa938a604895ddb7138e017ac4dcbe354eefba\nauthor Jaeyong Sung <jaeyong0201@gmail.com> 1644694536 +0900\ncommitter Jaeyong Sung <jaeyong0201@gmail.com> 1644694536 +0900\n\nchanged algorithm\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/124bb03b15d439a2749a0bec0aca008cd3f0664c", "html_url": "https://github.com/rust-lang/rust/commit/124bb03b15d439a2749a0bec0aca008cd3f0664c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/124bb03b15d439a2749a0bec0aca008cd3f0664c/comments", "author": {"login": "buttercrab", "id": 34997549, "node_id": "MDQ6VXNlcjM0OTk3NTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/34997549?v=4", "gravatar_id": "", "url": "https://api.github.com/users/buttercrab", "html_url": "https://github.com/buttercrab", "followers_url": "https://api.github.com/users/buttercrab/followers", "following_url": "https://api.github.com/users/buttercrab/following{/other_user}", "gists_url": "https://api.github.com/users/buttercrab/gists{/gist_id}", "starred_url": "https://api.github.com/users/buttercrab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/buttercrab/subscriptions", "organizations_url": "https://api.github.com/users/buttercrab/orgs", "repos_url": "https://api.github.com/users/buttercrab/repos", "events_url": "https://api.github.com/users/buttercrab/events{/privacy}", "received_events_url": "https://api.github.com/users/buttercrab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "buttercrab", "id": 34997549, "node_id": "MDQ6VXNlcjM0OTk3NTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/34997549?v=4", "gravatar_id": "", "url": "https://api.github.com/users/buttercrab", "html_url": "https://github.com/buttercrab", "followers_url": "https://api.github.com/users/buttercrab/followers", "following_url": "https://api.github.com/users/buttercrab/following{/other_user}", "gists_url": "https://api.github.com/users/buttercrab/gists{/gist_id}", "starred_url": "https://api.github.com/users/buttercrab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/buttercrab/subscriptions", "organizations_url": "https://api.github.com/users/buttercrab/orgs", "repos_url": "https://api.github.com/users/buttercrab/repos", "events_url": "https://api.github.com/users/buttercrab/events{/privacy}", "received_events_url": "https://api.github.com/users/buttercrab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8faa938a604895ddb7138e017ac4dcbe354eefba", "url": "https://api.github.com/repos/rust-lang/rust/commits/8faa938a604895ddb7138e017ac4dcbe354eefba", "html_url": "https://github.com/rust-lang/rust/commit/8faa938a604895ddb7138e017ac4dcbe354eefba"}], "stats": {"total": 87, "additions": 49, "deletions": 38}, "files": [{"sha": "d89a86c9ad1e2b51ed060b1d431eae8efab2eb07", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/124bb03b15d439a2749a0bec0aca008cd3f0664c/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124bb03b15d439a2749a0bec0aca008cd3f0664c/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=124bb03b15d439a2749a0bec0aca008cd3f0664c", "patch": "@@ -126,29 +126,36 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n                 }\n             }\n \n-            let mut pre_order = FxHashMap::default();\n-\n-            visitor.graph.iter().for_each(|(_, next)| {\n-                next.iter().for_each(|i| {\n-                    *pre_order.entry(*i).or_insert(0) += 1;\n-                });\n-            });\n-\n             for (id, span, ident) in param_span {\n                 // if the variable is not used in recursion, it would be marked as unused\n-                if !visitor.has_side_effect.contains(&id)\n-                    && *pre_order.get(&id).unwrap_or(&0) > 0\n-                    && visitor.graph.contains_key(&id)\n-                {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        ONLY_USED_IN_RECURSION,\n-                        span,\n-                        \"parameter is only used in recursion with no side-effects\",\n-                        \"if this is intentional, prefix with an underscore\",\n-                        format!(\"_{}\", ident.name.as_str()),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                if !visitor.has_side_effect.contains(&id) {\n+                    let mut queue = VecDeque::new();\n+                    let mut visited = FxHashSet::default();\n+\n+                    queue.push_back(id);\n+\n+                    while let Some(id) = queue.pop_front() {\n+                        if let Some(next) = visitor.graph.get(&id) {\n+                            for i in next {\n+                                if !visited.contains(i) {\n+                                    visited.insert(id);\n+                                    queue.push_back(*i);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    if visited.contains(&id) {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            ONLY_USED_IN_RECURSION,\n+                            span,\n+                            \"parameter is only used in recursion with no side-effects\",\n+                            \"if this is intentional, prefix with an underscore\",\n+                            format!(\"_{}\", ident.name.as_str()),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n                 }\n             }\n         }\n@@ -200,7 +207,7 @@ impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n             StmtKind::Local(Local {\n                 pat, init: Some(init), ..\n             }) => {\n-                self.visit_pat_expr(pat, init);\n+                self.visit_pat_expr(pat, init, false);\n             },\n             StmtKind::Item(i) => {\n                 let item = self.ty_ctx.hir().item(i);\n@@ -229,7 +236,7 @@ impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n                 self.visit_bin_op(lhs, rhs);\n             },\n             ExprKind::Unary(op, expr) => self.visit_un_op(op, expr),\n-            ExprKind::Let(Let { pat, init, .. }) => self.visit_pat_expr(pat, init),\n+            ExprKind::Let(Let { pat, init, .. }) => self.visit_pat_expr(pat, init, false),\n             ExprKind::If(bind, then_expr, else_expr) => {\n                 self.visit_if(bind, then_expr, else_expr);\n             },\n@@ -333,7 +340,7 @@ impl<'tcx> SideEffectVisit<'tcx> {\n                 let lhs_vars = std::mem::take(&mut self.ret_vars);\n                 self.visit_expr(rhs);\n                 let rhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.connect_assign(&lhs_vars, &rhs_vars);\n+                self.connect_assign(&lhs_vars, &rhs_vars, false);\n             },\n         }\n     }\n@@ -373,26 +380,26 @@ impl<'tcx> SideEffectVisit<'tcx> {\n         }\n     }\n \n-    fn visit_pat_expr(&mut self, pat: &'tcx Pat<'tcx>, expr: &'tcx Expr<'tcx>) {\n+    fn visit_pat_expr(&mut self, pat: &'tcx Pat<'tcx>, expr: &'tcx Expr<'tcx>, connect_self: bool) {\n         match (&pat.kind, &expr.kind) {\n             (PatKind::Tuple(pats, _), ExprKind::Tup(exprs)) => {\n                 self.ret_vars = izip!(*pats, *exprs)\n                     .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr);\n+                        self.visit_pat_expr(pat, expr, connect_self);\n                         std::mem::take(&mut self.ret_vars)\n                     })\n                     .collect();\n             },\n             (PatKind::Slice(front_exprs, _, back_exprs), ExprKind::Array(exprs)) => {\n                 let mut vars = izip!(*front_exprs, *exprs)\n                     .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr);\n+                        self.visit_pat_expr(pat, expr, connect_self);\n                         std::mem::take(&mut self.ret_vars)\n                     })\n                     .collect();\n                 self.ret_vars = izip!(back_exprs.iter().rev(), exprs.iter().rev())\n                     .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr);\n+                        self.visit_pat_expr(pat, expr, connect_self);\n                         std::mem::take(&mut self.ret_vars)\n                     })\n                     .collect();\n@@ -403,7 +410,7 @@ impl<'tcx> SideEffectVisit<'tcx> {\n                 pat.each_binding(|_, id, _, _| lhs_vars.push((id, false)));\n                 self.visit_expr(expr);\n                 let rhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.connect_assign(&lhs_vars, &rhs_vars);\n+                self.connect_assign(&lhs_vars, &rhs_vars, connect_self);\n                 self.ret_vars = rhs_vars;\n             },\n         }\n@@ -424,7 +431,7 @@ impl<'tcx> SideEffectVisit<'tcx> {\n             then {\n                 izip!(self.params.clone(), args)\n                     .for_each(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr);\n+                        self.visit_pat_expr(pat, expr, true);\n                         self.ret_vars.clear();\n                     });\n             } else {\n@@ -463,7 +470,7 @@ impl<'tcx> SideEffectVisit<'tcx> {\n             then {\n                 izip!(self.params.clone(), args.iter())\n                     .for_each(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr);\n+                        self.visit_pat_expr(pat, expr, true);\n                         self.ret_vars.clear();\n                     });\n             } else {\n@@ -511,7 +518,7 @@ impl<'tcx> SideEffectVisit<'tcx> {\n                 self.contains_side_effect = false;\n                 // this would visit `expr` multiple times\n                 // but couldn't think of a better way\n-                self.visit_pat_expr(arm.pat, expr);\n+                self.visit_pat_expr(arm.pat, expr, false);\n                 let mut vars = std::mem::take(&mut self.ret_vars);\n                 let _ = arm.guard.as_ref().map(|guard| {\n                     self.visit_expr(match guard {\n@@ -532,7 +539,7 @@ impl<'tcx> SideEffectVisit<'tcx> {\n         self.ret_vars.append(&mut expr_vars);\n     }\n \n-    fn connect_assign(&mut self, lhs: &[(HirId, bool)], rhs: &[(HirId, bool)]) {\n+    fn connect_assign(&mut self, lhs: &[(HirId, bool)], rhs: &[(HirId, bool)], connect_self: bool) {\n         // if mutable dereference is on assignment it can have side-effect\n         // (this can lead to parameter mutable dereference and change the original value)\n         // too hard to detect whether this value is from parameter, so this would all\n@@ -554,15 +561,19 @@ impl<'tcx> SideEffectVisit<'tcx> {\n         // unwrap is possible since rhs is not empty\n         let rhs_first = rhs.first().unwrap();\n         for (id, _) in lhs.iter() {\n-            self.graph\n-                .entry(*id)\n-                .or_insert_with(FxHashSet::default)\n-                .insert(rhs_first.0);\n+            if connect_self || *id != rhs_first.0 {\n+                self.graph\n+                    .entry(*id)\n+                    .or_insert_with(FxHashSet::default)\n+                    .insert(rhs_first.0);\n+            }\n         }\n \n         let rhs = rhs.iter();\n         izip!(rhs.clone().cycle().skip(1), rhs).for_each(|(from, to)| {\n-            self.graph.entry(from.0).or_insert_with(FxHashSet::default).insert(to.0);\n+            if connect_self || from.0 != to.0 {\n+                self.graph.entry(from.0).or_insert_with(FxHashSet::default).insert(to.0);\n+            }\n         });\n     }\n "}]}