{"sha": "c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYmYxNzRlOWMzZjk5NGQ4M2U3ZTcyYjZlMTVjOWIyNmM1YjMxYTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T17:25:29Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T17:25:29Z"}, "message": "Start splitting completion into components", "tree": {"sha": "7bd3920e5139b8fef6cf0b4e07d671f022d58b65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bd3920e5139b8fef6cf0b4e07d671f022d58b65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2", "html_url": "https://github.com/rust-lang/rust/commit/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12810b93c5141b9ae31f4af17dcc61b0166314b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/12810b93c5141b9ae31f4af17dcc61b0166314b0", "html_url": "https://github.com/rust-lang/rust/commit/12810b93c5141b9ae31f4af17dcc61b0166314b0"}], "stats": {"total": 763, "additions": 424, "deletions": 339}, "files": [{"sha": "39066d51f698eba0614415bcd5a52ebd30709a89", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 108, "deletions": 117, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2", "patch": "@@ -1,18 +1,23 @@\n mod completion_item;\n mod reference_completion;\n \n+mod complete_fn_param;\n+mod complete_keywords;\n+\n use ra_editor::find_node_at_offset;\n use ra_text_edit::AtomTextEdit;\n use ra_syntax::{\n-    algo::visit::{visitor_ctx, VisitorCtx},\n+    algo::{\n+        find_leaf_at_offset,\n+    },\n     ast,\n     AstNode,\n     SyntaxNodeRef,\n     SourceFileNode,\n     TextUnit,\n+    SyntaxKind::*,\n };\n use ra_db::SyntaxDatabase;\n-use rustc_hash::{FxHashMap};\n use hir::source_binder;\n \n use crate::{\n@@ -29,99 +34,133 @@ pub(crate) fn completions(\n ) -> Cancelable<Option<Completions>> {\n     let original_file = db.source_file(position.file_id);\n     // Insert a fake ident to get a valid parse tree\n+    let file = {\n+        let edit = AtomTextEdit::insert(position.offset, \"intellijRulezz\".to_string());\n+        original_file.reparse(&edit)\n+    };\n     let module = ctry!(source_binder::module_from_position(db, position)?);\n \n     let mut acc = Completions::default();\n-    let mut has_completions = false;\n+\n     // First, let's try to complete a reference to some declaration.\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n-        has_completions = true;\n         reference_completion::completions(&mut acc, db, &module, &file, name_ref)?;\n-        // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n-        if is_node::<ast::Param>(name_ref.syntax()) {\n-            param_completions(&mut acc, name_ref.syntax());\n-        }\n     }\n \n-    // Otherwise, if this is a declaration, use heuristics to suggest a name.\n-    if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), position.offset) {\n-        if is_node::<ast::Param>(name.syntax()) {\n-            has_completions = true;\n-            param_completions(&mut acc, name.syntax());\n-        }\n-    }\n-    if !has_completions {\n-        return Ok(None);\n-    }\n+    let ctx = ctry!(SyntaxContext::new(&original_file, position.offset));\n+    complete_fn_param::complete_fn_param(&mut acc, &ctx);\n+    complete_keywords::complete_expr_keyword(&mut acc, &ctx);\n+\n     Ok(Some(acc))\n }\n \n /// `SyntaxContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n #[derive(Debug)]\n-pub(super) enum SyntaxContext<'a> {\n-    ParameterName(SyntaxNodeRef<'a>),\n-    Other,\n+pub(super) struct SyntaxContext<'a> {\n+    leaf: SyntaxNodeRef<'a>,\n+    enclosing_fn: Option<ast::FnDef<'a>>,\n+    is_param: bool,\n+    /// a single-indent path, like `foo`.\n+    is_trivial_path: bool,\n+    after_if: bool,\n+    is_stmt: bool,\n }\n \n-impl SyntaxContext {\n-    pub(super) fn new(original_file: &SourceFileNode, offset: TextUnit) -> SyntaxContext {\n+impl SyntaxContext<'_> {\n+    pub(super) fn new(original_file: &SourceFileNode, offset: TextUnit) -> Option<SyntaxContext> {\n+        let leaf = find_leaf_at_offset(original_file.syntax(), offset).left_biased()?;\n+        let mut ctx = SyntaxContext {\n+            leaf,\n+            enclosing_fn: None,\n+            is_param: false,\n+            is_trivial_path: false,\n+            after_if: false,\n+            is_stmt: false,\n+        };\n+        ctx.fill(original_file, offset);\n+        Some(ctx)\n+    }\n+\n+    fn fill(&mut self, original_file: &SourceFileNode, offset: TextUnit) {\n+        // Insert a fake ident to get a valid parse tree. We will use this file\n+        // to determine context, though the original_file will be used for\n+        // actual completion.\n         let file = {\n             let edit = AtomTextEdit::insert(offset, \"intellijRulezz\".to_string());\n             original_file.reparse(&edit)\n         };\n+\n+        // First, let's try to complete a reference to some declaration.\n+        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), offset) {\n+            // Special case, `trait T { fn foo(i_am_a_name_ref) {} }`.\n+            // See RFC#1685.\n+            if is_node::<ast::Param>(name_ref.syntax()) {\n+                self.is_param = true;\n+                return;\n+            }\n+            self.classify_name_ref(&file, name_ref);\n+        }\n+\n+        // Otherwise, see if this is a declaration. We can use heuristics to\n+        // suggest declaration names, see `CompletionKind::Magic`.\n         if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), offset) {\n             if is_node::<ast::Param>(name.syntax()) {\n-                if let Some(node) = find_leaf_at_offset(original_file, offset).left_biased() {\n-                    return SyntaxContext::ParameterName(node);\n-                }\n+                self.is_param = true;\n+                return;\n             }\n         }\n-\n-        SyntaxContext::Other\n     }\n-}\n-\n-/// Complete repeated parametes, both name and type. For example, if all\n-/// functions in a file have a `spam: &mut Spam` parameter, a completion with\n-/// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n-/// suggested.\n-fn param_completions(acc: &mut Completions, ctx: SyntaxNodeRef) {\n-    let mut params = FxHashMap::default();\n-    for node in ctx.ancestors() {\n-        let _ = visitor_ctx(&mut params)\n-            .visit::<ast::SourceFile, _>(process)\n-            .visit::<ast::ItemList, _>(process)\n-            .accept(node);\n-    }\n-    params\n-        .into_iter()\n-        .filter_map(|(label, (count, param))| {\n-            let lookup = param.pat()?.syntax().text().to_string();\n-            if count < 2 {\n-                None\n-            } else {\n-                Some((label, lookup))\n+    fn classify_name_ref(&mut self, file: &SourceFileNode, name_ref: ast::NameRef) {\n+        // let name_range = name_ref.syntax().range();\n+        // let top_node = name_ref\n+        //     .syntax()\n+        //     .ancestors()\n+        //     .take_while(|it| it.range() == name_range)\n+        //     .last()\n+        //     .unwrap();\n+        // match top_node.parent().map(|it| it.kind()) {\n+        //     Some(SOURCE_FILE) | Some(ITEM_LIST) => return Some(NameRefKind::BareIdentInMod),\n+        //     _ => (),\n+        // }\n+        let parent = match name_ref.syntax().parent() {\n+            Some(it) => it,\n+            None => return,\n+        };\n+        if let Some(segment) = ast::PathSegment::cast(parent) {\n+            let path = segment.parent_path();\n+            // if let Some(path) = Path::from_ast(path) {\n+            //     if !path.is_ident() {\n+            //         return Some(NameRefKind::Path(path));\n+            //     }\n+            // }\n+            if path.qualifier().is_none() {\n+                self.is_trivial_path = true;\n+                self.enclosing_fn = self\n+                    .leaf\n+                    .ancestors()\n+                    .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n+                    .find_map(ast::FnDef::cast);\n+\n+                self.is_stmt = match name_ref\n+                    .syntax()\n+                    .ancestors()\n+                    .filter_map(ast::ExprStmt::cast)\n+                    .next()\n+                {\n+                    None => false,\n+                    Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n+                };\n+\n+                if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n+                    if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n+                        if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n+                            self.after_if = true;\n+                        }\n+                    }\n+                }\n             }\n-        })\n-        .for_each(|(label, lookup)| {\n-            CompletionItem::new(label)\n-                .lookup_by(lookup)\n-                .kind(CompletionKind::Magic)\n-                .add_to(acc)\n-        });\n-\n-    fn process<'a, N: ast::FnDefOwner<'a>>(\n-        node: N,\n-        params: &mut FxHashMap<String, (u32, ast::Param<'a>)>,\n-    ) {\n-        node.functions()\n-            .filter_map(|it| it.param_list())\n-            .flat_map(|it| it.params())\n-            .for_each(|param| {\n-                let text = param.syntax().text().to_string();\n-                params.entry(text).or_insert((0, param)).0 += 1;\n-            })\n+        }\n     }\n }\n \n@@ -143,51 +182,3 @@ fn check_completion(code: &str, expected_completions: &str, kind: CompletionKind\n     let completions = completions(&analysis.imp.db, position).unwrap().unwrap();\n     completions.assert_match(expected_completions, kind);\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    fn check_magic_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Magic);\n-    }\n-\n-    #[test]\n-    fn test_param_completion_last_param() {\n-        check_magic_completion(\n-            r\"\n-            fn foo(file_id: FileId) {}\n-            fn bar(file_id: FileId) {}\n-            fn baz(file<|>) {}\n-            \",\n-            r#\"file_id \"file_id: FileId\"\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_param_completion_nth_param() {\n-        check_magic_completion(\n-            r\"\n-            fn foo(file_id: FileId) {}\n-            fn bar(file_id: FileId) {}\n-            fn baz(file<|>, x: i32) {}\n-            \",\n-            r#\"file_id \"file_id: FileId\"\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_param_completion_trait_param() {\n-        check_magic_completion(\n-            r\"\n-            pub(crate) trait SourceRoot {\n-                pub fn contains(&self, file_id: FileId) -> bool;\n-                pub fn module_map(&self) -> &ModuleMap;\n-                pub fn lines(&self, file_id: FileId) -> &LineIndex;\n-                pub fn syntax(&self, file<|>)\n-            }\n-            \",\n-            r#\"file_id \"file_id: FileId\"\"#,\n-        );\n-    }\n-}"}, {"sha": "d05a5e3cf5c03e765e4d1cf8b7013f17c180bc11", "filename": "crates/ra_analysis/src/completion/complete_fn_param.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2", "patch": "@@ -0,0 +1,107 @@\n+use ra_syntax::{\n+    algo::{\n+        visit::{visitor_ctx, VisitorCtx}\n+    },\n+    ast,\n+    AstNode,\n+};\n+use rustc_hash::{FxHashMap};\n+\n+use crate::{\n+    completion::{SyntaxContext, Completions, CompletionKind, CompletionItem},\n+};\n+\n+/// Complete repeated parametes, both name and type. For example, if all\n+/// functions in a file have a `spam: &mut Spam` parameter, a completion with\n+/// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n+/// suggested.\n+pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &SyntaxContext) {\n+    if !ctx.is_param {\n+        return;\n+    }\n+\n+    let mut params = FxHashMap::default();\n+    for node in ctx.leaf.ancestors() {\n+        let _ = visitor_ctx(&mut params)\n+            .visit::<ast::SourceFile, _>(process)\n+            .visit::<ast::ItemList, _>(process)\n+            .accept(node);\n+    }\n+    params\n+        .into_iter()\n+        .filter_map(|(label, (count, param))| {\n+            let lookup = param.pat()?.syntax().text().to_string();\n+            if count < 2 {\n+                None\n+            } else {\n+                Some((label, lookup))\n+            }\n+        })\n+        .for_each(|(label, lookup)| {\n+            CompletionItem::new(label)\n+                .lookup_by(lookup)\n+                .kind(CompletionKind::Magic)\n+                .add_to(acc)\n+        });\n+\n+    fn process<'a, N: ast::FnDefOwner<'a>>(\n+        node: N,\n+        params: &mut FxHashMap<String, (u32, ast::Param<'a>)>,\n+    ) {\n+        node.functions()\n+            .filter_map(|it| it.param_list())\n+            .flat_map(|it| it.params())\n+            .for_each(|param| {\n+                let text = param.syntax().text().to_string();\n+                params.entry(text).or_insert((0, param)).0 += 1;\n+            })\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::*;\n+\n+    fn check_magic_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Magic);\n+    }\n+\n+    #[test]\n+    fn test_param_completion_last_param() {\n+        check_magic_completion(\n+            r\"\n+            fn foo(file_id: FileId) {}\n+            fn bar(file_id: FileId) {}\n+            fn baz(file<|>) {}\n+            \",\n+            r#\"file_id \"file_id: FileId\"\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_param_completion_nth_param() {\n+        check_magic_completion(\n+            r\"\n+            fn foo(file_id: FileId) {}\n+            fn bar(file_id: FileId) {}\n+            fn baz(file<|>, x: i32) {}\n+            \",\n+            r#\"file_id \"file_id: FileId\"\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_param_completion_trait_param() {\n+        check_magic_completion(\n+            r\"\n+            pub(crate) trait SourceRoot {\n+                pub fn contains(&self, file_id: FileId) -> bool;\n+                pub fn module_map(&self) -> &ModuleMap;\n+                pub fn lines(&self, file_id: FileId) -> &LineIndex;\n+                pub fn syntax(&self, file<|>)\n+            }\n+            \",\n+            r#\"file_id \"file_id: FileId\"\"#,\n+        );\n+    }\n+}"}, {"sha": "d0a6ec19e3c3a5350168756bb818c4650b3d258d", "filename": "crates/ra_analysis/src/completion/complete_keywords.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keywords.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keywords.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keywords.rs?ref=c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2", "patch": "@@ -0,0 +1,206 @@\n+use ra_syntax::{\n+    algo::visit::{visitor, Visitor},\n+    AstNode,\n+    ast::{self, LoopBodyOwner},\n+    SyntaxKind::*, SyntaxNodeRef,\n+};\n+\n+use crate::{\n+    completion::{SyntaxContext, CompletionItem, Completions, CompletionKind::*},\n+};\n+\n+pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &SyntaxContext) {\n+    if !ctx.is_trivial_path {\n+        return;\n+    }\n+    let fn_def = match ctx.enclosing_fn {\n+        Some(it) => it,\n+        None => return,\n+    };\n+    acc.add(keyword(\"if\", \"if $0 {}\"));\n+    acc.add(keyword(\"match\", \"match $0 {}\"));\n+    acc.add(keyword(\"while\", \"while $0 {}\"));\n+    acc.add(keyword(\"loop\", \"loop {$0}\"));\n+\n+    if ctx.after_if {\n+        acc.add(keyword(\"else\", \"else {$0}\"));\n+        acc.add(keyword(\"else if\", \"else if $0 {}\"));\n+    }\n+    if is_in_loop_body(ctx.leaf) {\n+        acc.add(keyword(\"continue\", \"continue\"));\n+        acc.add(keyword(\"break\", \"break\"));\n+    }\n+    acc.add_all(complete_return(fn_def, ctx.is_stmt));\n+}\n+\n+fn is_in_loop_body(leaf: SyntaxNodeRef) -> bool {\n+    for node in leaf.ancestors() {\n+        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n+            break;\n+        }\n+        let loop_body = visitor()\n+            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n+            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n+            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n+            .accept(node);\n+        if let Some(Some(body)) = loop_body {\n+            if leaf.range().is_subrange(&body.syntax().range()) {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn complete_return(fn_def: ast::FnDef, is_stmt: bool) -> Option<CompletionItem> {\n+    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n+        (true, true) => \"return $0;\",\n+        (true, false) => \"return;\",\n+        (false, true) => \"return $0\",\n+        (false, false) => \"return\",\n+    };\n+    Some(keyword(\"return\", snip))\n+}\n+\n+fn keyword(kw: &str, snippet: &str) -> CompletionItem {\n+    CompletionItem::new(kw)\n+        .kind(Keyword)\n+        .snippet(snippet)\n+        .build()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{CompletionKind, check_completion};\n+    fn check_keyword_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Keyword);\n+    }\n+\n+    #[test]\n+    fn test_completion_kewords() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                <|>\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_else() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                if true {\n+                    ()\n+                } <|>\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            else \"else {$0}\"\n+            else if \"else if $0 {}\"\n+            return \"return\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_return_value() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                <|>\n+                92\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0;\"\n+            \"#,\n+        );\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                <|>\n+                92\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return;\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_return_no_stmt() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                match () {\n+                    () => <|>\n+                }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_continue_break_completion() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                loop { <|> }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            continue \"continue\"\n+            break \"break\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                loop { || { <|> } }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+    }\n+}"}, {"sha": "15ff4c5dd438276bd3468656a7aa6b611f957bcf", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 3, "deletions": 222, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=c2bf174e9c3f994d83e7e72b6e15c9b26c5b31a2", "patch": "@@ -1,9 +1,7 @@\n use rustc_hash::{FxHashSet};\n-use ra_editor::find_node_at_offset;\n use ra_syntax::{\n-    algo::visit::{visitor, Visitor},\n     SourceFileNode, AstNode,\n-    ast::{self, LoopBodyOwner},\n+    ast,\n     SyntaxKind::*,\n };\n use hir::{\n@@ -21,7 +19,7 @@ pub(super) fn completions(\n     acc: &mut Completions,\n     db: &RootDatabase,\n     module: &hir::Module,\n-    file: &SourceFileNode,\n+    _file: &SourceFileNode,\n     name_ref: ast::NameRef,\n ) -> Cancelable<()> {\n     let kind = match classify_name_ref(name_ref) {\n@@ -34,7 +32,7 @@ pub(super) fn completions(\n             if let Some(fn_def) = enclosing_fn {\n                 let scopes = FnScopes::new(fn_def);\n                 complete_fn(name_ref, &scopes, acc);\n-                complete_expr_keywords(&file, fn_def, name_ref, acc);\n+                // complete_expr_keywords(&file, fn_def, name_ref, acc);\n                 complete_expr_snippets(acc);\n             }\n \n@@ -182,91 +180,6 @@ fn ${1:feature}() {\n         .add_to(acc);\n }\n \n-fn complete_expr_keywords(\n-    file: &SourceFileNode,\n-    fn_def: ast::FnDef,\n-    name_ref: ast::NameRef,\n-    acc: &mut Completions,\n-) {\n-    acc.add(keyword(\"if\", \"if $0 {}\"));\n-    acc.add(keyword(\"match\", \"match $0 {}\"));\n-    acc.add(keyword(\"while\", \"while $0 {}\"));\n-    acc.add(keyword(\"loop\", \"loop {$0}\"));\n-\n-    if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n-        if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n-            if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n-                acc.add(keyword(\"else\", \"else {$0}\"));\n-                acc.add(keyword(\"else if\", \"else if $0 {}\"));\n-            }\n-        }\n-    }\n-    if is_in_loop_body(name_ref) {\n-        acc.add(keyword(\"continue\", \"continue\"));\n-        acc.add(keyword(\"break\", \"break\"));\n-    }\n-    acc.add_all(complete_return(fn_def, name_ref));\n-}\n-\n-fn is_in_loop_body(name_ref: ast::NameRef) -> bool {\n-    for node in name_ref.syntax().ancestors() {\n-        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n-            break;\n-        }\n-        let loop_body = visitor()\n-            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n-            .accept(node);\n-        if let Some(Some(body)) = loop_body {\n-            if name_ref\n-                .syntax()\n-                .range()\n-                .is_subrange(&body.syntax().range())\n-            {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<CompletionItem> {\n-    // let is_last_in_block = name_ref.syntax().ancestors().filter_map(ast::Expr::cast)\n-    //     .next()\n-    //     .and_then(|it| it.syntax().parent())\n-    //     .and_then(ast::Block::cast)\n-    //     .is_some();\n-\n-    // if is_last_in_block {\n-    //     return None;\n-    // }\n-\n-    let is_stmt = match name_ref\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::ExprStmt::cast)\n-        .next()\n-    {\n-        None => false,\n-        Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n-    };\n-    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n-        (true, true) => \"return $0;\",\n-        (true, false) => \"return;\",\n-        (false, true) => \"return $0\",\n-        (false, false) => \"return\",\n-    };\n-    Some(keyword(\"return\", snip))\n-}\n-\n-fn keyword(kw: &str, snippet: &str) -> CompletionItem {\n-    CompletionItem::new(kw)\n-        .kind(Keyword)\n-        .snippet(snippet)\n-        .build()\n-}\n-\n fn complete_expr_snippets(acc: &mut Completions) {\n     CompletionItem::new(\"pd\")\n         .snippet(\"eprintln!(\\\"$0 = {:?}\\\", $0);\")\n@@ -286,10 +199,6 @@ mod tests {\n         check_completion(code, expected_completions, CompletionKind::Reference);\n     }\n \n-    fn check_keyword_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Keyword);\n-    }\n-\n     fn check_snippet_completion(code: &str, expected_completions: &str) {\n         check_completion(code, expected_completions, CompletionKind::Snippet);\n     }\n@@ -470,134 +379,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn test_completion_kewords() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() {\n-                <|>\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_else() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() {\n-                if true {\n-                    ()\n-                } <|>\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            else \"else {$0}\"\n-            else if \"else if $0 {}\"\n-            return \"return\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_return_value() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                <|>\n-                92\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0;\"\n-            \"#,\n-        );\n-        check_keyword_completion(\n-            r\"\n-            fn quux() {\n-                <|>\n-                92\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return;\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_return_no_stmt() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                match () {\n-                    () => <|>\n-                }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_continue_break_completion() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                loop { <|> }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            continue \"continue\"\n-            break \"break\"\n-            return \"return $0\"\n-            \"#,\n-        );\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                loop { || { <|> } }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0\"\n-            \"#,\n-        );\n-    }\n-\n     #[test]\n     fn completes_snippets_in_expressions() {\n         check_snippet_completion("}]}