{"sha": "d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YmExYjliMDIxYzQwOGZjYWQ2MGVlNTJhY2Y4YWY1ZTFiMmViMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-16T00:06:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-16T00:06:10Z"}, "message": "Auto merge of #49719 - mark-i-m:no_sep, r=petrochenkov\n\nUpdate `?` repetition disambiguation.\n\n**Do not merge** (yet)\n\nThis is a test implementation of some ideas from discussion in https://github.com/rust-lang/rust/issues/48075 . This PR\n- disallows `?` repetition from taking a separator, since the separator is never used.\n- disallows the use of `?` as a separator. This allows patterns like `$(a)?+` to match `+` and `a+` rather than `a?a?a`. This is a _breaking change_, but maybe that's ok? Perhaps a crater run is the right approach?\n\ncc @durka @alexreg @nikomatsakis", "tree": {"sha": "f8cce3b0e523366776bad6b968000deeae8b0eb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8cce3b0e523366776bad6b968000deeae8b0eb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00", "html_url": "https://github.com/rust-lang/rust/commit/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8de5353f75dcde04abe947e0560dc5edd861cf3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8de5353f75dcde04abe947e0560dc5edd861cf3a", "html_url": "https://github.com/rust-lang/rust/commit/8de5353f75dcde04abe947e0560dc5edd861cf3a"}, {"sha": "54bba4c45648b02b92dcec74f4230bfa02846d5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/54bba4c45648b02b92dcec74f4230bfa02846d5e", "html_url": "https://github.com/rust-lang/rust/commit/54bba4c45648b02b92dcec74f4230bfa02846d5e"}], "stats": {"total": 228, "additions": 72, "deletions": 156}, "files": [{"sha": "77c6afa1c64a60883af2be338312117888fc1a6b", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 22, "deletions": 67, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00", "patch": "@@ -386,72 +386,26 @@ where\n {\n     // We basically look at two token trees here, denoted as #1 and #2 below\n     let span = match parse_kleene_op(input, span) {\n-        // #1 is a `+` or `*` KleeneOp\n-        //\n-        // `?` is ambiguous: it could be a separator or a Kleene::ZeroOrOne, so we need to look\n-        // ahead one more token to be sure.\n-        Ok(Ok(op)) if op != KleeneOp::ZeroOrOne => return (None, op),\n-\n-        // #1 is `?` token, but it could be a Kleene::ZeroOrOne without a separator or it could\n-        // be a `?` separator followed by any Kleene operator. We need to look ahead 1 token to\n-        // find out which.\n-        Ok(Ok(op)) => {\n-            assert_eq!(op, KleeneOp::ZeroOrOne);\n-\n-            // Lookahead at #2. If it is a KleenOp, then #1 is a separator.\n-            let is_1_sep = if let Some(&tokenstream::TokenTree::Token(_, ref tok2)) = input.peek() {\n-                kleene_op(tok2).is_some()\n-            } else {\n-                false\n-            };\n-\n-            if is_1_sep {\n-                // #1 is a separator and #2 should be a KleepeOp::*\n-                // (N.B. We need to advance the input iterator.)\n-                match parse_kleene_op(input, span) {\n-                    // #2 is a KleeneOp (this is the only valid option) :)\n-                    Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n-                        if !features.macro_at_most_once_rep\n-                            && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-                        {\n-                            let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n-                            emit_feature_err(\n-                                sess,\n-                                \"macro_at_most_once_rep\",\n-                                span,\n-                                GateIssue::Language,\n-                                explain,\n-                            );\n-                        }\n-                        return (Some(token::Question), op);\n-                    }\n-                    Ok(Ok(op)) => return (Some(token::Question), op),\n-\n-                    // #2 is a random token (this is an error) :(\n-                    Ok(Err((_, span))) => span,\n-\n-                    // #2 is not even a token at all :(\n-                    Err(span) => span,\n-                }\n-            } else {\n-                if !features.macro_at_most_once_rep\n-                    && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-                {\n-                    let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n-                    emit_feature_err(\n-                        sess,\n-                        \"macro_at_most_once_rep\",\n-                        span,\n-                        GateIssue::Language,\n-                        explain,\n-                    );\n-                }\n-\n-                // #2 is a random tree and #1 is KleeneOp::ZeroOrOne\n-                return (None, op);\n+        // #1 is any KleeneOp (`?`)\n+        Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n+            if !features.macro_at_most_once_rep\n+                && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+            {\n+                let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n+                emit_feature_err(\n+                    sess,\n+                    \"macro_at_most_once_rep\",\n+                    span,\n+                    GateIssue::Language,\n+                    explain,\n+                );\n             }\n+            return (None, op);\n         }\n \n+        // #1 is any KleeneOp (`+`, `*`)\n+        Ok(Ok(op)) => return (None, op),\n+\n         // #1 is a separator followed by #2, a KleeneOp\n         Ok(Err((tok, span))) => match parse_kleene_op(input, span) {\n             // #2 is a KleeneOp :D\n@@ -467,8 +421,11 @@ where\n                         GateIssue::Language,\n                         explain,\n                     );\n+                } else {\n+                    sess.span_diagnostic\n+                        .span_err(span, \"`?` macro repetition does not allow a separator\");\n                 }\n-                return (Some(tok), op);\n+                return (None, op);\n             }\n             Ok(Ok(op)) => return (Some(tok), op),\n \n@@ -483,9 +440,7 @@ where\n         Err(span) => span,\n     };\n \n-    if !features.macro_at_most_once_rep\n-        && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-    {\n+    if !features.macro_at_most_once_rep && !attr::contains_name(attrs, \"allow_internal_unstable\") {\n         sess.span_diagnostic\n             .span_err(span, \"expected one of: `*`, `+`, or `?`\");\n     } else {"}, {"sha": "c08effe549328705ae5843475b2c4f54c5032033", "filename": "src/test/run-pass/macro-at-most-once-rep.rs", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs?ref=d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00", "patch": "@@ -32,25 +32,13 @@ macro_rules! foo {\n     } }\n }\n \n-macro_rules! baz {\n-    ($($a:ident),? ; $num:expr) => { { // comma separator is meaningless for `?`\n-        let mut x = 0;\n-\n-        $(\n-            x += $a;\n-         )?\n-\n-        assert_eq!(x, $num);\n-    } }\n-}\n-\n macro_rules! barplus {\n     ($($a:ident)?+ ; $num:expr) => { {\n         let mut x = 0;\n \n         $(\n             x += $a;\n-         )+\n+         )?\n \n         assert_eq!(x, $num);\n     } }\n@@ -62,7 +50,7 @@ macro_rules! barstar {\n \n         $(\n             x += $a;\n-         )*\n+         )?\n \n         assert_eq!(x, $num);\n     } }\n@@ -74,15 +62,10 @@ pub fn main() {\n     // accept 0 or 1 repetitions\n     foo!( ; 0);\n     foo!(a ; 1);\n-    baz!( ; 0);\n-    baz!(a ; 1);\n \n     // Make sure using ? as a separator works as before\n-    barplus!(a ; 1);\n-    barplus!(a?a ; 2);\n-    barplus!(a?a?a ; 3);\n-    barstar!( ; 0);\n-    barstar!(a ; 1);\n-    barstar!(a?a ; 2);\n-    barstar!(a?a?a ; 3);\n+    barplus!(+ ; 0);\n+    barplus!(a + ; 1);\n+    barstar!(* ; 0);\n+    barstar!(a * ; 1);\n }"}, {"sha": "e25c3ccfcd980d36b67d63a0e7cb885ef5332792", "filename": "src/test/ui/macros/macro-at-most-once-rep-ambig.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs?ref=d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00", "patch": "@@ -8,30 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// The logic for parsing Kleene operators in macros has a special case to disambiguate `?`.\n-// Specifically, `$(pat)?` is the ZeroOrOne operator whereas `$(pat)?+` or `$(pat)?*` are the\n-// ZeroOrMore and OneOrMore operators using `?` as a separator. These tests are intended to\n-// exercise that logic in the macro parser.\n-//\n-// Moreover, we also throw in some tests for using a separator with `?`, which is meaningless but\n-// included for consistency with `+` and `*`.\n-//\n-// This test focuses on error cases.\n+// Tests the behavior of various Kleene operators in macros with respect to `?` terminals. In\n+// particular, `?` in the position of a separator and of a Kleene operator is tested.\n \n #![feature(macro_at_most_once_rep)]\n \n+// should match `` and `a`\n macro_rules! foo {\n     ($(a)?) => {}\n }\n \n macro_rules! baz {\n-    ($(a),?) => {} // comma separator is meaningless for `?`\n+    ($(a),?) => {} //~ ERROR `?` macro repetition does not allow a separator\n }\n \n+// should match `+` and `a+`\n macro_rules! barplus {\n     ($(a)?+) => {}\n }\n \n+// should match `*` and `a*`\n macro_rules! barstar {\n     ($(a)?*) => {}\n }\n@@ -40,14 +36,14 @@ pub fn main() {\n     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n     foo!(a?a); //~ ERROR no rules expected the token `?`\n     foo!(a?); //~ ERROR no rules expected the token `?`\n-    baz!(a?a?a); //~ ERROR no rules expected the token `?`\n-    baz!(a?a); //~ ERROR no rules expected the token `?`\n-    baz!(a?); //~ ERROR no rules expected the token `?`\n-    baz!(a,); //~ ERROR unexpected end of macro invocation\n-    baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n-    baz!(a?a,); //~ ERROR no rules expected the token `?`\n-    baz!(a?,); //~ ERROR no rules expected the token `?`\n     barplus!(); //~ ERROR unexpected end of macro invocation\n-    barplus!(a?); //~ ERROR unexpected end of macro invocation\n-    barstar!(a?); //~ ERROR unexpected end of macro invocation\n+    barstar!(); //~ ERROR unexpected end of macro invocation\n+    barplus!(a?); //~ ERROR no rules expected the token `?`\n+    barplus!(a); //~ ERROR unexpected end of macro invocation\n+    barstar!(a?); //~ ERROR no rules expected the token `?`\n+    barstar!(a); //~ ERROR unexpected end of macro invocation\n+    barplus!(+); // ok\n+    barstar!(*); // ok\n+    barplus!(a+); // ok\n+    barstar!(a*); // ok\n }"}, {"sha": "cb1e360471cc8671969a0cb274f3dd67b721f64d", "filename": "src/test/ui/macros/macro-at-most-once-rep-ambig.stderr", "status": "modified", "additions": 29, "deletions": 47, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr?ref=d6ba1b9b021c408fcad60ee52acf8af5e1b2eb00", "patch": "@@ -1,80 +1,62 @@\n+error: `?` macro repetition does not allow a separator\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:22:10\n+   |\n+LL |     ($(a),?) => {} //~ ERROR `?` macro repetition does not allow a separator\n+   |          ^\n+\n error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:40:11\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:36:11\n    |\n LL |     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n    |           ^\n \n error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:41:11\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:37:11\n    |\n LL |     foo!(a?a); //~ ERROR no rules expected the token `?`\n    |           ^\n \n error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:42:11\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:38:11\n    |\n LL |     foo!(a?); //~ ERROR no rules expected the token `?`\n    |           ^\n \n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:43:11\n-   |\n-LL |     baz!(a?a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:44:11\n-   |\n-LL |     baz!(a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:45:11\n-   |\n-LL |     baz!(a?); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:46:11\n-   |\n-LL |     baz!(a,); //~ ERROR unexpected end of macro invocation\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:47:11\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:39:5\n    |\n-LL |     baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n-   |           ^\n+LL |     barplus!(); //~ ERROR unexpected end of macro invocation\n+   |     ^^^^^^^^^^^\n \n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:48:11\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:40:5\n    |\n-LL |     baz!(a?a,); //~ ERROR no rules expected the token `?`\n-   |           ^\n+LL |     barstar!(); //~ ERROR unexpected end of macro invocation\n+   |     ^^^^^^^^^^^\n \n error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:49:11\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:41:15\n    |\n-LL |     baz!(a?,); //~ ERROR no rules expected the token `?`\n-   |           ^\n+LL |     barplus!(a?); //~ ERROR no rules expected the token `?`\n+   |               ^\n \n error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:50:5\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:42:14\n    |\n-LL |     barplus!(); //~ ERROR unexpected end of macro invocation\n-   |     ^^^^^^^^^^^\n+LL |     barplus!(a); //~ ERROR unexpected end of macro invocation\n+   |              ^\n \n-error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:51:15\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:43:15\n    |\n-LL |     barplus!(a?); //~ ERROR unexpected end of macro invocation\n+LL |     barstar!(a?); //~ ERROR no rules expected the token `?`\n    |               ^\n \n error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:52:15\n+  --> $DIR/macro-at-most-once-rep-ambig.rs:44:14\n    |\n-LL |     barstar!(a?); //~ ERROR unexpected end of macro invocation\n-   |               ^\n+LL |     barstar!(a); //~ ERROR unexpected end of macro invocation\n+   |              ^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 10 previous errors\n "}]}