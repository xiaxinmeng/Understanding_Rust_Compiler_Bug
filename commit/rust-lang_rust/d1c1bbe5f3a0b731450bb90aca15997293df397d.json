{"sha": "d1c1bbe5f3a0b731450bb90aca15997293df397d", "node_id": "C_kwDOAAsO6NoAKGQxYzFiYmU1ZjNhMGI3MzE0NTBiYjkwYWNhMTU5OTcyOTNkZjM5N2Q", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-08T20:51:55Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-12T17:53:22Z"}, "message": "Move path resolution error to rustc_resolve::diagnostics.", "tree": {"sha": "1fec1e8bb5fcf4b69a91e9ab1b61c063248eb9cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fec1e8bb5fcf4b69a91e9ab1b61c063248eb9cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1c1bbe5f3a0b731450bb90aca15997293df397d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1c1bbe5f3a0b731450bb90aca15997293df397d", "html_url": "https://github.com/rust-lang/rust/commit/d1c1bbe5f3a0b731450bb90aca15997293df397d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1c1bbe5f3a0b731450bb90aca15997293df397d/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "886613c91627606c885733d5f44da88597004a0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/886613c91627606c885733d5f44da88597004a0c", "html_url": "https://github.com/rust-lang/rust/commit/886613c91627606c885733d5f44da88597004a0c"}], "stats": {"total": 371, "additions": 207, "deletions": 164}, "files": [{"sha": "bf4611f3870bbaf535f21aa20faab518fa8dd19f", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 195, "deletions": 3, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/d1c1bbe5f3a0b731450bb90aca15997293df397d/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1c1bbe5f3a0b731450bb90aca15997293df397d/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=d1c1bbe5f3a0b731450bb90aca15997293df397d", "patch": "@@ -8,12 +8,13 @@ use rustc_errors::{\n };\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n-use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind};\n+use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n use rustc_middle::ty::DefIdTree;\n use rustc_session::Session;\n+use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::SourceMap;\n@@ -22,10 +23,11 @@ use rustc_span::{BytePos, Span};\n use tracing::debug;\n \n use crate::imports::{Import, ImportKind, ImportResolver};\n+use crate::late::Rib;\n use crate::path_names_to_string;\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Finalize};\n use crate::{BindingError, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot};\n-use crate::{NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n+use crate::{LexicalScopeBinding, NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n@@ -1377,6 +1379,196 @@ impl<'a> Resolver<'a> {\n             sugg => sugg,\n         }\n     }\n+\n+    crate fn report_path_resolution_error(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+        finalize_full: Finalize,\n+        ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+        module: Option<ModuleOrUniformRoot<'a>>,\n+        i: usize,\n+        ident: Ident,\n+    ) -> (String, Option<Suggestion>) {\n+        let finalize = finalize_full.path_span();\n+        let is_last = i == path.len() - 1;\n+        let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+        let module_res = match module {\n+            Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n+            _ => None,\n+        };\n+        if module_res == self.graph_root.res() {\n+            let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n+            let mut candidates = self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n+            candidates\n+                .sort_by_cached_key(|c| (c.path.segments.len(), pprust::path_to_string(&c.path)));\n+            if let Some(candidate) = candidates.get(0) {\n+                (\n+                    String::from(\"unresolved import\"),\n+                    Some((\n+                        vec![(ident.span, pprust::path_to_string(&candidate.path))],\n+                        String::from(\"a similar path exists\"),\n+                        Applicability::MaybeIncorrect,\n+                    )),\n+                )\n+            } else if self.session.edition() == Edition::Edition2015 {\n+                (format!(\"maybe a missing crate `{}`?\", ident), None)\n+            } else {\n+                (format!(\"could not find `{}` in the crate root\", ident), None)\n+            }\n+        } else if i == 0 {\n+            if ident.name.as_str().chars().next().map_or(false, |c| c.is_ascii_uppercase()) {\n+                // Check whether the name refers to an item in the value namespace.\n+                let suggestion = if ribs.is_some() {\n+                    let match_span = match self.resolve_ident_in_lexical_scope(\n+                        ident,\n+                        ValueNS,\n+                        parent_scope,\n+                        Finalize::No,\n+                        &ribs.unwrap()[ValueNS],\n+                        unusable_binding,\n+                    ) {\n+                        // Name matches a local variable. For example:\n+                        // ```\n+                        // fn f() {\n+                        //     let Foo: &str = \"\";\n+                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                        //                               // variable `Foo`.\n+                        // }\n+                        // ```\n+                        Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n+                            Some(*self.pat_span_map.get(&id).unwrap())\n+                        }\n+\n+                        // Name matches item from a local name binding\n+                        // created by `use` declaration. For example:\n+                        // ```\n+                        // pub Foo: &str = \"\";\n+                        //\n+                        // mod submod {\n+                        //     use super::Foo;\n+                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                        //                               // binding `Foo`.\n+                        // }\n+                        // ```\n+                        Some(LexicalScopeBinding::Item(name_binding)) => Some(name_binding.span),\n+                        _ => None,\n+                    };\n+\n+                    if let Some(span) = match_span {\n+                        Some((\n+                            vec![(span, String::from(\"\"))],\n+                            format!(\"`{}` is defined here, but is not a type\", ident),\n+                            Applicability::MaybeIncorrect,\n+                        ))\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    None\n+                };\n+\n+                (format!(\"use of undeclared type `{}`\", ident), suggestion)\n+            } else {\n+                (\n+                    format!(\"use of undeclared crate or module `{}`\", ident),\n+                    if ident.name == sym::alloc {\n+                        Some((\n+                            vec![],\n+                            String::from(\"add `extern crate alloc` to use the `alloc` crate\"),\n+                            Applicability::MaybeIncorrect,\n+                        ))\n+                    } else {\n+                        self.find_similarly_named_module_or_crate(ident.name, &parent_scope.module)\n+                            .map(|sugg| {\n+                                (\n+                                    vec![(ident.span, sugg.to_string())],\n+                                    String::from(\"there is a crate or module with a similar name\"),\n+                                    Applicability::MaybeIncorrect,\n+                                )\n+                            })\n+                    },\n+                )\n+            }\n+        } else {\n+            let parent = path[i - 1].ident.name;\n+            let parent = match parent {\n+                // ::foo is mounted at the crate root for 2015, and is the extern\n+                // prelude for 2018+\n+                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n+                    \"the list of imported crates\".to_owned()\n+                }\n+                kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n+                _ => {\n+                    format!(\"`{}`\", parent)\n+                }\n+            };\n+\n+            let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n+            if ns == TypeNS || ns == ValueNS {\n+                let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n+                let binding = if let Some(module) = module {\n+                    self.resolve_ident_in_module(\n+                        module,\n+                        ident,\n+                        ns_to_try,\n+                        parent_scope,\n+                        finalize,\n+                        false,\n+                        unusable_binding,\n+                    ).ok()\n+                } else if let Some(ribs) = ribs\n+                    && let Some(TypeNS | ValueNS) = opt_ns\n+                {\n+                    match self.resolve_ident_in_lexical_scope(\n+                        ident,\n+                        ns_to_try,\n+                        parent_scope,\n+                        finalize_full,\n+                        &ribs[ns_to_try],\n+                        unusable_binding,\n+                    ) {\n+                        // we found a locally-imported or available item/module\n+                        Some(LexicalScopeBinding::Item(binding)) => Some(binding),\n+                        _ => None,\n+                    }\n+                } else {\n+                    let scopes = ScopeSet::All(ns_to_try, opt_ns.is_none());\n+                    self.early_resolve_ident_in_lexical_scope(\n+                        ident,\n+                        scopes,\n+                        parent_scope,\n+                        finalize,\n+                        finalize.is_some(),\n+                        false,\n+                        unusable_binding,\n+                    ).ok()\n+                };\n+                if let Some(binding) = binding {\n+                    let mut found = |what| {\n+                        msg = format!(\n+                            \"expected {}, found {} `{}` in {}\",\n+                            ns.descr(),\n+                            what,\n+                            ident,\n+                            parent\n+                        )\n+                    };\n+                    if binding.module().is_some() {\n+                        found(\"module\")\n+                    } else {\n+                        match binding.res() {\n+                            Res::Def(kind, id) => found(kind.descr(id)),\n+                            _ => found(ns_to_try.descr()),\n+                        }\n+                    }\n+                };\n+            }\n+            (msg, None)\n+        }\n+    }\n }\n \n impl<'a, 'b> ImportResolver<'a, 'b> {"}, {"sha": "7f6832a4ec427cacbb1769f59136e8a4e49bb229", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 12, "deletions": 161, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/d1c1bbe5f3a0b731450bb90aca15997293df397d/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1c1bbe5f3a0b731450bb90aca15997293df397d/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=d1c1bbe5f3a0b731450bb90aca15997293df397d", "patch": "@@ -1,6 +1,4 @@\n use rustc_ast::{self as ast, NodeId};\n-use rustc_ast_pretty::pprust;\n-use rustc_errors::Applicability;\n use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{DefKind, Namespace, NonMacroAttrKind, PartialRes, PerNS};\n use rustc_hir::PrimTy;\n@@ -10,7 +8,7 @@ use rustc_session::lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext};\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::{Span, DUMMY_SP};\n \n use std::ptr;\n@@ -1566,164 +1564,17 @@ impl<'a> Resolver<'a> {\n                     }\n \n                     return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n-                        let module_res = match module {\n-                            Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n-                            _ => None,\n-                        };\n-                        if module_res == self.graph_root.res() {\n-                            let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n-                            let mut candidates =\n-                                self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n-                            candidates.sort_by_cached_key(|c| {\n-                                (c.path.segments.len(), pprust::path_to_string(&c.path))\n-                            });\n-                            if let Some(candidate) = candidates.get(0) {\n-                                (\n-                                    String::from(\"unresolved import\"),\n-                                    Some((\n-                                        vec![(ident.span, pprust::path_to_string(&candidate.path))],\n-                                        String::from(\"a similar path exists\"),\n-                                        Applicability::MaybeIncorrect,\n-                                    )),\n-                                )\n-                            } else if self.session.edition() == Edition::Edition2015 {\n-                                (format!(\"maybe a missing crate `{}`?\", ident), None)\n-                            } else {\n-                                (format!(\"could not find `{}` in the crate root\", ident), None)\n-                            }\n-                        } else if i == 0 {\n-                            if ident\n-                                .name\n-                                .as_str()\n-                                .chars()\n-                                .next()\n-                                .map_or(false, |c| c.is_ascii_uppercase())\n-                            {\n-                                // Check whether the name refers to an item in the value namespace.\n-                                let suggestion = if ribs.is_some() {\n-                                    let match_span = match self.resolve_ident_in_lexical_scope(\n-                                        ident,\n-                                        ValueNS,\n-                                        parent_scope,\n-                                        Finalize::No,\n-                                        &ribs.unwrap()[ValueNS],\n-                                        unusable_binding,\n-                                    ) {\n-                                        // Name matches a local variable. For example:\n-                                        // ```\n-                                        // fn f() {\n-                                        //     let Foo: &str = \"\";\n-                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                        //                               // variable `Foo`.\n-                                        // }\n-                                        // ```\n-                                        Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n-                                            Some(*self.pat_span_map.get(&id).unwrap())\n-                                        }\n-\n-                                        // Name matches item from a local name binding\n-                                        // created by `use` declaration. For example:\n-                                        // ```\n-                                        // pub Foo: &str = \"\";\n-                                        //\n-                                        // mod submod {\n-                                        //     use super::Foo;\n-                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                        //                               // binding `Foo`.\n-                                        // }\n-                                        // ```\n-                                        Some(LexicalScopeBinding::Item(name_binding)) => {\n-                                            Some(name_binding.span)\n-                                        }\n-                                        _ => None,\n-                                    };\n-\n-                                    if let Some(span) = match_span {\n-                                        Some((\n-                                            vec![(span, String::from(\"\"))],\n-                                            format!(\n-                                                \"`{}` is defined here, but is not a type\",\n-                                                ident\n-                                            ),\n-                                            Applicability::MaybeIncorrect,\n-                                        ))\n-                                    } else {\n-                                        None\n-                                    }\n-                                } else {\n-                                    None\n-                                };\n-\n-                                (format!(\"use of undeclared type `{}`\", ident), suggestion)\n-                            } else {\n-                                (\n-                                    format!(\"use of undeclared crate or module `{}`\", ident),\n-                                    if ident.name == sym::alloc {\n-                                        Some((\n-                                            vec![],\n-                                            String::from(\n-                                                \"add `extern crate alloc` to use the `alloc` crate\",\n-                                            ),\n-                                            Applicability::MaybeIncorrect,\n-                                        ))\n-                                    } else {\n-                                        self.find_similarly_named_module_or_crate(\n-                                            ident.name,\n-                                            &parent_scope.module,\n-                                        )\n-                                        .map(|sugg| {\n-                                            (\n-                                                vec![(ident.span, sugg.to_string())],\n-                                                String::from(\n-                                                    \"there is a crate or module with a similar name\",\n-                                                ),\n-                                                Applicability::MaybeIncorrect,\n-                                            )\n-                                        })\n-                                    },\n-                                )\n-                            }\n-                        } else {\n-                            let parent = path[i - 1].ident.name;\n-                            let parent = match parent {\n-                                // ::foo is mounted at the crate root for 2015, and is the extern\n-                                // prelude for 2018+\n-                                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n-                                    \"the list of imported crates\".to_owned()\n-                                }\n-                                kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n-                                _ => {\n-                                    format!(\"`{}`\", parent)\n-                                }\n-                            };\n-\n-                            let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n-                            if ns == TypeNS || ns == ValueNS {\n-                                let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n-                                if let FindBindingResult::Binding(Ok(binding)) =\n-                                    find_binding_in_ns(self, ns_to_try)\n-                                {\n-                                    let mut found = |what| {\n-                                        msg = format!(\n-                                            \"expected {}, found {} `{}` in {}\",\n-                                            ns.descr(),\n-                                            what,\n-                                            ident,\n-                                            parent\n-                                        )\n-                                    };\n-                                    if binding.module().is_some() {\n-                                        found(\"module\")\n-                                    } else {\n-                                        match binding.res() {\n-                                            Res::Def(kind, id) => found(kind.descr(id)),\n-                                            _ => found(ns_to_try.descr()),\n-                                        }\n-                                    }\n-                                };\n-                            }\n-                            (msg, None)\n-                        }\n+                        self.report_path_resolution_error(\n+                            path,\n+                            opt_ns,\n+                            parent_scope,\n+                            finalize_full,\n+                            ribs,\n+                            unusable_binding,\n+                            module,\n+                            i,\n+                            ident,\n+                        )\n                     });\n                 }\n             }"}]}