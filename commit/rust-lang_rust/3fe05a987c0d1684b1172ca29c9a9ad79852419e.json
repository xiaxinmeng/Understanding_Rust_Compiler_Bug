{"sha": "3fe05a987c0d1684b1172ca29c9a9ad79852419e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZTA1YTk4N2MwZDE2ODRiMTE3MmNhMjljOWE5YWQ3OTg1MjQxOWU=", "commit": {"author": {"name": "Jordi Boggiano", "email": "j.boggiano@seld.be", "date": "2013-06-29T02:09:58Z"}, "committer": {"name": "Jordi Boggiano", "email": "j.boggiano@seld.be", "date": "2013-06-30T23:50:40Z"}, "message": "Move most iter functionality to extra, fixes #7343", "tree": {"sha": "a149e83646c2ecca7729e377b70566683ea210be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a149e83646c2ecca7729e377b70566683ea210be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fe05a987c0d1684b1172ca29c9a9ad79852419e", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe05a987c0d1684b1172ca29c9a9ad79852419e", "html_url": "https://github.com/rust-lang/rust/commit/3fe05a987c0d1684b1172ca29c9a9ad79852419e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fe05a987c0d1684b1172ca29c9a9ad79852419e/comments", "author": {"login": "Seldaek", "id": 183678, "node_id": "MDQ6VXNlcjE4MzY3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/183678?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Seldaek", "html_url": "https://github.com/Seldaek", "followers_url": "https://api.github.com/users/Seldaek/followers", "following_url": "https://api.github.com/users/Seldaek/following{/other_user}", "gists_url": "https://api.github.com/users/Seldaek/gists{/gist_id}", "starred_url": "https://api.github.com/users/Seldaek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Seldaek/subscriptions", "organizations_url": "https://api.github.com/users/Seldaek/orgs", "repos_url": "https://api.github.com/users/Seldaek/repos", "events_url": "https://api.github.com/users/Seldaek/events{/privacy}", "received_events_url": "https://api.github.com/users/Seldaek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Seldaek", "id": 183678, "node_id": "MDQ6VXNlcjE4MzY3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/183678?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Seldaek", "html_url": "https://github.com/Seldaek", "followers_url": "https://api.github.com/users/Seldaek/followers", "following_url": "https://api.github.com/users/Seldaek/following{/other_user}", "gists_url": "https://api.github.com/users/Seldaek/gists{/gist_id}", "starred_url": "https://api.github.com/users/Seldaek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Seldaek/subscriptions", "organizations_url": "https://api.github.com/users/Seldaek/orgs", "repos_url": "https://api.github.com/users/Seldaek/repos", "events_url": "https://api.github.com/users/Seldaek/events{/privacy}", "received_events_url": "https://api.github.com/users/Seldaek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fc99f1997be9323bb75826c478094e74797ddf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc99f1997be9323bb75826c478094e74797ddf9", "html_url": "https://github.com/rust-lang/rust/commit/0fc99f1997be9323bb75826c478094e74797ddf9"}], "stats": {"total": 671, "additions": 345, "deletions": 326}, "files": [{"sha": "ad8dcf98317a45dcec1b6cf4b60dec65178d709d", "filename": "src/libextra/iter.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibextra%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibextra%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fiter.rs?ref=3fe05a987c0d1684b1172ca29c9a9ad79852419e", "patch": "@@ -0,0 +1,328 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! Composable internal iterators\n+\n+Internal iterators are functions implementing the protocol used by the `for` loop.\n+\n+An internal iterator takes `fn(...) -> bool` as a parameter, with returning `false` used to signal\n+breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n+tied to specific traits. For example:\n+\n+~~~ {.rust}\n+println(iter::to_vec(|f| uint::range(0, 20, f)).to_str());\n+~~~\n+\n+An external iterator object implementing the interface in the `iterator` module can be used as an\n+internal iterator by calling the `advance` method. For example:\n+\n+~~~ {.rust}\n+let xs = [0u, 1, 2, 3, 4, 5];\n+let ys = [30, 40, 50, 60];\n+let mut it = xs.iter().chain(ys.iter());\n+for it.advance |&x: &uint| {\n+    println(x.to_str());\n+}\n+~~~\n+\n+Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n+to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n+much easier to implement.\n+\n+*/\n+\n+use std::vec;\n+use std::cmp::Ord;\n+use std::option::{Option, Some, None};\n+use std::num::{One, Zero};\n+use std::ops::{Add, Mul};\n+\n+#[allow(missing_doc)]\n+pub trait FromIter<T> {\n+    /// Build a container with elements from an internal iterator.\n+    ///\n+    /// # Example:\n+    ///\n+    /// ~~~ {.rust}\n+    /// let xs = ~[1, 2, 3];\n+    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n+    /// assert_eq!(xs, ys);\n+    /// ~~~\n+    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> Self;\n+}\n+\n+/**\n+ * Return true if `predicate` is true for any values yielded by an internal iterator.\n+ *\n+ * Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[1u, 2, 3, 4, 5];\n+ * assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n+ * assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n+ * ~~~\n+ */\n+#[inline]\n+pub fn any<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n+    for iter |x| {\n+        if predicate(x) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+/**\n+ * Return true if `predicate` is true for all values yielded by an internal iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n+ * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n+ * ~~~\n+ */\n+#[inline]\n+pub fn all<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n+    // If we ever break, iter will return false, so this will only return true\n+    // if predicate returns true for everything.\n+    iter(|x| predicate(x))\n+}\n+\n+/**\n+ * Return the first element where `predicate` returns `true`. Return `None` if no element is found.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[1u, 2, 3, 4, 5, 6];\n+ * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn find<T>(predicate: &fn(&T) -> bool,\n+               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n+    for iter |x| {\n+        if predicate(&x) {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+/**\n+ * Return the largest item yielded by an iterator. Return `None` if the iterator is empty.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+ * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n+    let mut result = None;\n+    for iter |x| {\n+        match result {\n+            Some(ref mut y) => {\n+                if x > *y {\n+                    *y = x;\n+                }\n+            }\n+            None => result = Some(x)\n+        }\n+    }\n+    result\n+}\n+\n+/**\n+ * Return the smallest item yielded by an iterator. Return `None` if the iterator is empty.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+ * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &-5);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n+    let mut result = None;\n+    for iter |x| {\n+        match result {\n+            Some(ref mut y) => {\n+                if x < *y {\n+                    *y = x;\n+                }\n+            }\n+            None => result = Some(x)\n+        }\n+    }\n+    result\n+}\n+\n+/**\n+ * Reduce an iterator to an accumulated value.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n+    let mut result = start;\n+    for iter |x| {\n+        f(&mut result, x);\n+    }\n+    result\n+}\n+\n+/**\n+ * Reduce an iterator to an accumulated value.\n+ *\n+ * `fold_ref` is usable in some generic functions where `fold` is too lenient to type-check, but it\n+ * forces the iterator to yield borrowed pointers.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+ *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n+ * }\n+ * ~~~\n+ */\n+#[inline]\n+pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n+    let mut result = start;\n+    for iter |x| {\n+        f(&mut result, x);\n+    }\n+    result\n+}\n+\n+/**\n+ * Return the sum of the items yielding by an iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs: ~[int] = ~[1, 2, 3, 4];\n+ * assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+    fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n+}\n+\n+/**\n+ * Return the product of the items yielded by an iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~ {.rust}\n+ * let xs: ~[int] = ~[1, 2, 3, 4];\n+ * assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n+ * ~~~\n+ */\n+#[inline]\n+pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+    fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n+}\n+\n+impl<T> FromIter<T> for ~[T]{\n+    #[inline]\n+    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n+        let mut v = ~[];\n+        for iter |x| { v.push(x) }\n+        v\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n+\n+    use int;\n+    use uint;\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = ~[1, 2, 3];\n+        let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n+        assert_eq!(xs, ys);\n+    }\n+\n+    #[test]\n+    fn test_any() {\n+        let xs = ~[1u, 2, 3, 4, 5];\n+        assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n+        assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n+    }\n+\n+    #[test]\n+    fn test_all() {\n+        assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n+        assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n+    }\n+\n+    #[test]\n+    fn test_find() {\n+        let xs = ~[1u, 2, 3, 4, 5, 6];\n+        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n+    }\n+\n+    #[test]\n+    fn test_max() {\n+        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+        assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n+    }\n+\n+    #[test]\n+    fn test_min() {\n+        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+        assert_eq!(min(|f| xs.iter().advance(f)).unwrap(), &-5);\n+    }\n+\n+    #[test]\n+    fn test_fold() {\n+        assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n+    }\n+\n+    #[test]\n+    fn test_sum() {\n+        let xs: ~[int] = ~[1, 2, 3, 4];\n+        assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n+    }\n+\n+    #[test]\n+    fn test_empty_sum() {\n+        let xs: ~[int] = ~[];\n+        assert_eq!(do sum |f| { xs.iter().advance(f) }, 0);\n+    }\n+\n+    #[test]\n+    fn test_product() {\n+        let xs: ~[int] = ~[1, 2, 3, 4];\n+        assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n+    }\n+\n+    #[test]\n+    fn test_empty_product() {\n+        let xs: ~[int] = ~[];\n+        assert_eq!(do product |f| { xs.iter().advance(f) }, 1);\n+    }\n+}"}, {"sha": "a78143c33cdfb33f27665aa0e15473459816b0f5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3fe05a987c0d1684b1172ca29c9a9ad79852419e", "patch": "@@ -29,7 +29,6 @@ use util::enum_set::{EnumSet, CLike};\n use std::cast;\n use std::cmp;\n use std::hashmap::{HashMap, HashSet};\n-use std::iter;\n use std::ops;\n use std::ptr::to_unsafe_ptr;\n use std::to_bytes;\n@@ -1752,7 +1751,7 @@ pub struct TypeContents {\n \n impl TypeContents {\n     pub fn meets_bounds(&self, cx: ctxt, bbs: BuiltinBounds) -> bool {\n-        iter::all(|bb| self.meets_bound(cx, bb), |f| bbs.each(f))\n+        bbs.iter().all(|bb| self.meets_bound(cx, bb))\n     }\n \n     pub fn meets_bound(&self, cx: ctxt, bb: BuiltinBound) -> bool {"}, {"sha": "f9bd7a3508edbe09b52665d7ab9c9ff28a66b4e3", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=3fe05a987c0d1684b1172ca29c9a9ad79852419e", "patch": "@@ -135,7 +135,6 @@ impl<E:CLike> Iterator<E> for EnumSetIterator<E> {\n mod test {\n \n     use std::cast;\n-    use std::iter;\n \n     use util::enum_set::*;\n \n@@ -237,7 +236,7 @@ mod test {\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n-    // iterator\n+    // iter / each\n \n     #[test]\n     fn test_iterator() {\n@@ -263,15 +262,6 @@ mod test {\n         assert_eq!(~[A,B,C], elems)\n     }\n \n-    fn collect(e: EnumSet<Foo>) -> ~[Foo] {\n-        let mut elems = ~[];\n-        e.each(|elem| {\n-           elems.push(elem);\n-           true\n-        });\n-        elems\n-    }\n-\n     #[test]\n     fn test_each() {\n         let mut e1: EnumSet<Foo> = EnumSet::empty();\n@@ -291,6 +281,15 @@ mod test {\n         assert_eq!(~[A,B,C], collect(e1))\n     }\n \n+    fn collect(e: EnumSet<Foo>) -> ~[Foo] {\n+        let mut elems = ~[];\n+        e.each(|elem| {\n+           elems.push(elem);\n+           true\n+        });\n+        elems\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // operators\n "}, {"sha": "2092ae588d01db64436ea01643c2da91198bba83", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 5, "deletions": 302, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=3fe05a987c0d1684b1172ca29c9a9ad79852419e", "patch": "@@ -8,316 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! Composable internal iterators\n-\n-Internal iterators are functions implementing the protocol used by the `for` loop.\n-\n-An internal iterator takes `fn(...) -> bool` as a parameter, with returning `false` used to signal\n-breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n-tied to specific traits. For example:\n+/*! Times trait\n \n ~~~ {.rust}\n-println(iter::to_vec(|f| uint::range(0, 20, f)).to_str());\n+use iter::Times;\n+let ten = 10 as uint;\n+let mut accum = 0;\n+for ten.times { accum += 1; }\n ~~~\n \n-An external iterator object implementing the interface in the `iterator` module can be used as an\n-internal iterator by calling the `advance` method. For example:\n-\n-~~~ {.rust}\n-let xs = [0u, 1, 2, 3, 4, 5];\n-let ys = [30, 40, 50, 60];\n-let mut it = xs.iter().chain(ys.iter());\n-for it.advance |&x: &uint| {\n-    println(x.to_str());\n-}\n-~~~\n-\n-Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n-to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n-much easier to implement.\n-\n */\n \n-use cmp::Ord;\n-use option::{Option, Some, None};\n-use num::{One, Zero};\n-use ops::{Add, Mul};\n-\n #[allow(missing_doc)]\n pub trait Times {\n     fn times(&self, it: &fn() -> bool) -> bool;\n }\n \n-#[allow(missing_doc)]\n-pub trait FromIter<T> {\n-    /// Build a container with elements from an internal iterator.\n-    ///\n-    /// # Example:\n-    ///\n-    /// ~~~ {.rust}\n-    /// let xs = ~[1, 2, 3];\n-    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-    /// assert_eq!(xs, ys);\n-    /// ~~~\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> Self;\n-}\n-\n-/**\n- * Return true if `predicate` is true for any values yielded by an internal iterator.\n- *\n- * Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5];\n- * assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n- * assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn any<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    for iter |x| {\n-        if predicate(x) {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-/**\n- * Return true if `predicate` is true for all values yielded by an internal iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n- * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn all<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    // If we ever break, iter will return false, so this will only return true\n-    // if predicate returns true for everything.\n-    iter(|x| predicate(x))\n-}\n-\n-/**\n- * Return the first element where `predicate` returns `true`. Return `None` if no element is found.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5, 6];\n- * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n- * ~~~\n- */\n-#[inline]\n-pub fn find<T>(predicate: &fn(&T) -> bool,\n-               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    for iter |x| {\n-        if predicate(&x) {\n-            return Some(x);\n-        }\n-    }\n-    None\n-}\n-\n-/**\n- * Return the largest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n- * ~~~\n- */\n-#[inline]\n-pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    for iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x > *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-    }\n-    result\n-}\n-\n-/**\n- * Return the smallest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &-5);\n- * ~~~\n- */\n-#[inline]\n-pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    for iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x < *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-    }\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n-    let mut result = start;\n-    for iter |x| {\n-        f(&mut result, x);\n-    }\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * `fold_ref` is usable in some generic functions where `fold` is too lenient to type-check, but it\n- * forces the iterator to yield borrowed pointers.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n- *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n- * }\n- * ~~~\n- */\n-#[inline]\n-pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n-    let mut result = start;\n-    for iter |x| {\n-        f(&mut result, x);\n-    }\n-    result\n-}\n-\n-/**\n- * Return the sum of the items yielding by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n-}\n-\n-/**\n- * Return the product of the items yielded by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n- * ~~~\n- */\n-#[inline]\n-pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::*;\n-\n-    use int;\n-    use uint;\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = ~[1, 2, 3];\n-        let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-        assert_eq!(xs, ys);\n-    }\n-\n-    #[test]\n-    fn test_any() {\n-        let xs = ~[1u, 2, 3, 4, 5];\n-        assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n-        assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n-    }\n-\n-    #[test]\n-    fn test_all() {\n-        assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n-        assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let xs = ~[1u, 2, 3, 4, 5, 6];\n-        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n-    }\n-\n-    #[test]\n-    fn test_max() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n-    }\n-\n-    #[test]\n-    fn test_min() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(min(|f| xs.iter().advance(f)).unwrap(), &-5);\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n-    }\n-\n-    #[test]\n-    fn test_sum() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n-    }\n-\n-    #[test]\n-    fn test_empty_sum() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 0);\n-    }\n-\n-    #[test]\n-    fn test_product() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n-    }\n-\n-    #[test]\n-    fn test_empty_product() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 1);\n-    }\n-}"}, {"sha": "58db740167f32b83c6551595f0cca902863837f0", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=3fe05a987c0d1684b1172ca29c9a9ad79852419e", "patch": "@@ -47,7 +47,7 @@ pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Great\n pub use char::Char;\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n-pub use iter::{Times, FromIter};\n+pub use iter::{Times};\n pub use iterator::{Iterator, IteratorUtil, OrdIterator};\n pub use num::{Num, NumCast};\n pub use num::{Orderable, Signed, Unsigned, Round};"}, {"sha": "bbb7de69c404206b5a09cfbc6fe72c6e3676af3d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe05a987c0d1684b1172ca29c9a9ad79852419e/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=3fe05a987c0d1684b1172ca29c9a9ad79852419e", "patch": "@@ -19,7 +19,6 @@ use cmp;\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use iterator::{FromIterator, Iterator, IteratorUtil};\n-use iter::FromIter;\n use kinds::Copy;\n use libc;\n use num::Zero;\n@@ -2311,15 +2310,6 @@ pub struct VecMutRevIterator<'self, T> {\n }\n iterator!{impl VecMutRevIterator -> &'self mut T, -1}\n \n-impl<T> FromIter<T> for ~[T]{\n-    #[inline]\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n-        let mut v = ~[];\n-        for iter |x| { v.push(x) }\n-        v\n-    }\n-}\n-\n #[cfg(stage0)]\n impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\n     pub fn from_iterator(iterator: &mut T) -> ~[A] {"}]}