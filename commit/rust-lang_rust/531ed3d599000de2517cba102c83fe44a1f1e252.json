{"sha": "531ed3d599000de2517cba102c83fe44a1f1e252", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMWVkM2Q1OTkwMDBkZTI1MTdjYmExMDJjODNmZTQ0YTFmMWUyNTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-16T01:18:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-11T16:11:40Z"}, "message": "rustc: Update how Gc<T> is recognized\n\nThis commit uses the same trick as ~/Box to map Gc<T> to @T internally inside\nthe compiler. This moves a number of implementations of traits to the `gc`\nmodule in the standard library.\n\nThis removes functions such as `Gc::new`, `Gc::borrow`, and `Gc::ptr_eq` in\nfavor of the more modern equivalents, `box(GC)`, `Deref`, and pointer equality.\n\nThe Gc pointer itself should be much more useful now, and subsequent commits\nwill move the compiler away from @T towards Gc<T>\n\n[breaking-change]", "tree": {"sha": "f6da0ce70539e996d6a533f78e699ab1434a9ede", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6da0ce70539e996d6a533f78e699ab1434a9ede"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/531ed3d599000de2517cba102c83fe44a1f1e252", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/531ed3d599000de2517cba102c83fe44a1f1e252", "html_url": "https://github.com/rust-lang/rust/commit/531ed3d599000de2517cba102c83fe44a1f1e252", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/531ed3d599000de2517cba102c83fe44a1f1e252/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea41101b3522f2a7d121758be489404cbb0fde5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea41101b3522f2a7d121758be489404cbb0fde5a", "html_url": "https://github.com/rust-lang/rust/commit/ea41101b3522f2a7d121758be489404cbb0fde5a"}], "stats": {"total": 328, "additions": 155, "deletions": 173}, "files": [{"sha": "8b28ab917b35f1e576f0a1647545475804c36495", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -320,8 +320,8 @@ mod tests {\n     #[test]\n     fn gc_inside() {\n         // see issue #11532\n-        use std::gc::Gc;\n-        let a = Rc::new(RefCell::new(Gc::new(1)));\n+        use realstd::gc::Gc;\n+        let a = Rc::new(RefCell::new(box(GC) 1));\n         assert!(a.try_borrow_mut().is_some());\n     }\n "}, {"sha": "b484b2c8128f13f7b903ace57837b8d3a55e3aef", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -248,13 +248,6 @@ impl<S: Writer, T: Hash<S>> Hash<S> for Box<T> {\n     }\n }\n \n-impl<S: Writer, T: Hash<S>> Hash<S> for @T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-\n impl<S: Writer, T: Hash<S>> Hash<S> for Rc<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "b552cb511305fcf1dc362532e772d4c8600c082f", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -39,12 +39,6 @@ pub trait Clone {\n     }\n }\n \n-impl<T> Clone for @T {\n-    /// Return a shallow copy of the managed box.\n-    #[inline]\n-    fn clone(&self) -> @T { *self }\n-}\n-\n impl<'a, T> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]"}, {"sha": "d7a3edccfd822115c5f9ec55f8466061fb5ab285", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -326,29 +326,6 @@ mod impls {\n         fn cmp(&self, other: &&'a mut T) -> Ordering { (**self).cmp(*other) }\n     }\n     impl<'a, T: Eq> Eq for &'a mut T {}\n-\n-    // @ pointers\n-    impl<T:PartialEq> PartialEq for @T {\n-        #[inline]\n-        fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n-        #[inline]\n-        fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n-    }\n-    impl<T:PartialOrd> PartialOrd for @T {\n-        #[inline]\n-        fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n-        #[inline]\n-        fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }\n-        #[inline]\n-        fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }\n-        #[inline]\n-        fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n-    }\n-    impl<T: Ord> Ord for @T {\n-        #[inline]\n-        fn cmp(&self, other: &@T) -> Ordering { (**self).cmp(*other) }\n-    }\n-    impl<T: Eq> Eq for @T {}\n }\n \n #[cfg(test)]"}, {"sha": "0fcc02aae0d2b31619294a81749bda2b7e6be261", "filename": "src/libcore/default.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -43,7 +43,3 @@ default_impl!(i64, 0i64)\n \n default_impl!(f32, 0.0f32)\n default_impl!(f64, 0.0f64)\n-\n-impl<T: Default + 'static> Default for @T {\n-    fn default() -> @T { @Default::default() }\n-}"}, {"sha": "0e6a0d1c6f5770c24ea44aab36f716ca236f1198", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -628,9 +628,6 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n \n // Implementations of the core formatting traits\n \n-impl<T: Show> Show for @T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n-}\n impl<'a, T: Show> Show for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n }"}, {"sha": "56db4ee8059fab8596cda3a784f6e1489e8f6dae", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -79,7 +79,6 @@ pub trait Repr<T> {\n \n impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n impl<'a> Repr<Slice<u8>> for &'a str {}\n-impl<T> Repr<*Box<T>> for @T {}\n impl<T> Repr<*Vec<T>> for ~[T] {}\n \n #[cfg(test)]"}, {"sha": "19ce88d3d856f1983ae783ad17735da1aa06ca76", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -399,12 +399,20 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n             DatumBlock::new(bcx, datum)\n         }\n-        ast::ExprBox(_, contents) => {\n-            // Special case for `box T`. (The other case, for GC, is handled\n-            // in `trans_rvalue_dps_unadjusted`.)\n+        ast::ExprBox(_, ref contents) => {\n+            // Special case for `Box<T>` and `Gc<T>`\n             let box_ty = expr_ty(bcx, expr);\n-            let contents_ty = expr_ty(bcx, contents);\n-            trans_uniq_expr(bcx, box_ty, contents, contents_ty)\n+            let contents_ty = expr_ty(bcx, &**contents);\n+            match ty::get(box_ty).sty {\n+                ty::ty_uniq(..) => {\n+                    trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n+                }\n+                ty::ty_box(..) => {\n+                    trans_managed_expr(bcx, box_ty, &**contents, contents_ty)\n+                }\n+                _ => bcx.sess().span_bug(expr.span,\n+                                         \"expected unique or managed box\")\n+            }\n         }\n         ast::ExprLit(lit) => trans_immediate_lit(bcx, expr, (*lit).clone()),\n         ast::ExprBinary(op, lhs, rhs) => {\n@@ -773,11 +781,6 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprAssignOp(op, dst, src) => {\n             trans_assign_op(bcx, expr, op, dst, src)\n         }\n-        ast::ExprBox(_, contents) => {\n-            // Special case for `Gc<T>` for now. The other case, for unique\n-            // pointers, is handled in `trans_rvalue_datum_unadjusted`.\n-            trans_gc(bcx, expr, contents, dest)\n-        }\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n@@ -1242,31 +1245,6 @@ fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n     return immediate_rvalue_bcx(bcx, sub_datum.val, ty).to_expr_datumblock();\n }\n \n-fn trans_gc<'a>(mut bcx: &'a Block<'a>,\n-                expr: &ast::Expr,\n-                contents: &ast::Expr,\n-                dest: Dest)\n-                -> &'a Block<'a> {\n-    let contents_ty = expr_ty(bcx, contents);\n-    let box_ty = ty::mk_box(bcx.tcx(), contents_ty);\n-\n-    let contents_datum = unpack_datum!(bcx, trans_managed_expr(bcx,\n-                                                               box_ty,\n-                                                               contents,\n-                                                               contents_ty));\n-\n-    match dest {\n-        Ignore => bcx,\n-        SaveIn(addr) => {\n-            let expr_ty = expr_ty(bcx, expr);\n-            let repr = adt::represent_type(bcx.ccx(), expr_ty);\n-            adt::trans_start_init(bcx, &*repr, addr, 0);\n-            let field_dest = adt::trans_field_ptr(bcx, &*repr, addr, 0, 0);\n-            contents_datum.store_to(bcx, field_dest)\n-        }\n-    }\n-}\n-\n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n fn trans_eager_binop<'a>("}, {"sha": "e905e4f4cb3b7c00123d3eb63d48ad884e6e16d1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -18,7 +18,7 @@ use middle::lint;\n use middle::const_eval;\n use middle::def;\n use middle::dependency_format;\n-use middle::lang_items::{ExchangeHeapLangItem, OpaqueStructLangItem};\n+use middle::lang_items::OpaqueStructLangItem;\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n use middle::freevars;\n use middle::resolve;\n@@ -3108,17 +3108,17 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         }\n \n         ast::ExprBox(place, _) => {\n-            // Special case `Box<T>` for now:\n+            // Special case `Box<T>`/`Gc<T>` for now:\n             let definition = match tcx.def_map.borrow().find(&place.id) {\n                 Some(&def) => def,\n                 None => fail!(\"no def for place\"),\n             };\n             let def_id = definition.def_id();\n-            match tcx.lang_items.items.get(ExchangeHeapLangItem as uint) {\n-                &Some(item_def_id) if def_id == item_def_id => {\n-                    RvalueDatumExpr\n-                }\n-                &Some(_) | &None => RvalueDpsExpr,\n+            if tcx.lang_items.exchange_heap() == Some(def_id) ||\n+               tcx.lang_items.managed_heap() == Some(def_id) {\n+                RvalueDatumExpr\n+            } else {\n+                RvalueDpsExpr\n             }\n         }\n "}, {"sha": "f2b94771a7f462d3ab3b5e20115240ffc5341d35", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -451,6 +451,53 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                                               supplied to `Box<T>`\");\n                     Some(ty::mk_err())\n                 }\n+                ast::DefTy(did) | ast::DefStruct(did)\n+                        if Some(did) == this.tcx().lang_items.gc() => {\n+                    if path.segments\n+                           .iter()\n+                           .flat_map(|s| s.types.iter())\n+                           .len() > 1 {\n+                        this.tcx()\n+                            .sess\n+                            .span_err(path.span,\n+                                      \"`Gc` has only one type parameter\")\n+                    }\n+\n+                    for inner_ast_type in path.segments\n+                                              .iter()\n+                                              .flat_map(|s| s.types.iter()) {\n+                        let mt = ast::MutTy {\n+                            ty: *inner_ast_type,\n+                            mutbl: ast::MutImmutable,\n+                        };\n+                        return Some(mk_pointer(this,\n+                                               rscope,\n+                                               &mt,\n+                                               Box,\n+                                               |typ| {\n+                            match ty::get(typ).sty {\n+                                ty::ty_str => {\n+                                    this.tcx()\n+                                        .sess\n+                                        .span_err(path.span,\n+                                                  \"`Gc<str>` is not a type\");\n+                                    ty::mk_err()\n+                                }\n+                                ty::ty_vec(_, None) => {\n+                                    this.tcx()\n+                                        .sess\n+                                        .span_err(path.span,\n+                                                  \"`Gc<[T]>` is not a type\");\n+                                    ty::mk_err()\n+                                }\n+                                _ => ty::mk_box(this.tcx(), typ),\n+                            }\n+                        }))\n+                    }\n+                    this.tcx().sess.span_bug(path.span,\n+                                             \"not enough type parameters \\\n+                                              supplied to `Gc<T>`\")\n+                }\n                 _ => None\n             }\n         }"}, {"sha": "8398b46437d26d020a15f268b6c953ab6740791d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 46, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -2862,52 +2862,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                   // places: the exchange heap and the managed heap.\n                   let definition = lookup_def(fcx, path.span, place.id);\n                   let def_id = definition.def_id();\n-                  match tcx.lang_items\n-                           .items\n-                           .get(ExchangeHeapLangItem as uint) {\n-                      &Some(item_def_id) if def_id == item_def_id => {\n-                          fcx.write_ty(id, ty::mk_uniq(tcx,\n-                                                       fcx.expr_ty(subexpr)));\n-                          checked = true\n-                      }\n-                      &Some(_) | &None => {}\n-                  }\n-                  if !checked {\n-                      match tcx.lang_items\n-                               .items\n-                               .get(ManagedHeapLangItem as uint) {\n-                          &Some(item_def_id) if def_id == item_def_id => {\n-                              // Assign the magic `Gc<T>` struct.\n-                              let gc_struct_id =\n-                                  match tcx.lang_items\n-                                           .require(GcLangItem) {\n-                                      Ok(id) => id,\n-                                      Err(msg) => {\n-                                          tcx.sess.span_err(expr.span,\n-                                                            msg.as_slice());\n-                                          ast::DefId {\n-                                              krate: ast::CRATE_NODE_ID,\n-                                              node: ast::DUMMY_NODE_ID,\n-                                          }\n-                                      }\n-                                  };\n-                              let regions =\n-                                  subst::NonerasedRegions(Vec::new());\n-                              let sty = ty::mk_struct(tcx,\n-                                                      gc_struct_id,\n-                                                      subst::Substs {\n-                                                        self_ty: None,\n-                                                        tps: vec!(\n-                                                            fcx.expr_ty(\n-                                                                subexpr)\n-                                                        ),\n-                                                        regions: regions,\n-                                                      });\n-                              fcx.write_ty(id, sty);\n-                              checked = true\n-                          }\n-                          &Some(_) | &None => {}\n-                      }\n+                  if tcx.lang_items.exchange_heap() == Some(def_id) {\n+                      fcx.write_ty(id, ty::mk_uniq(tcx,\n+                                                   fcx.expr_ty(&**subexpr)));\n+                      checked = true\n+                  } else if tcx.lang_items.managed_heap() == Some(def_id) {\n+                      fcx.write_ty(id, ty::mk_box(tcx,\n+                                                  fcx.expr_ty(&**subexpr)));\n+                      checked = true\n                   }\n               }\n               _ => {}"}, {"sha": "fdc279394e4b949ea38b6bec5a12385fc994cc39", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -129,6 +129,14 @@ fn type_is_defined_in_local_crate(tcx: &ty::ctxt, original_type: t) -> bool {\n                     _ => {}\n                 }\n             }\n+            ty_box(..) => {\n+                match tcx.lang_items.gc() {\n+                    Some(did) if did.krate == ast::LOCAL_CRATE => {\n+                        found_nominal = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n \n             _ => { }\n         }"}, {"sha": "fcf4d21a96233db9b57fbdf87da7008e5a23d1b6", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -510,7 +510,7 @@ impl<T:Repr> Repr for Rc<T> {\n     }\n }\n \n-impl<T:Repr> Repr for @T {\n+impl<T:Repr + 'static> Repr for Gc<T> {\n     fn repr(&self, tcx: &ctxt) -> String {\n         (&**self).repr(tcx)\n     }"}, {"sha": "d4987bd0afe0bb362911c9b31ee8c6efe8a8fb8c", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -16,6 +16,7 @@ Core encoding and decoding interfaces.\n \n use std::path;\n use std::rc::Rc;\n+use std::gc::Gc;\n \n pub trait Encoder<E> {\n     // Primitive types:\n@@ -387,7 +388,7 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Box<T> {\n     }\n }\n \n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for @T {\n+impl<E, S:Encoder<E>,T:'static + Encodable<S, E>> Encodable<S, E> for Gc<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n@@ -407,9 +408,9 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Rc<T> {\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E> + 'static> Decodable<D, E> for @T {\n-    fn decode(d: &mut D) -> Result<@T, E> {\n-        Ok(@try!(Decodable::decode(d)))\n+impl<E, D:Decoder<E>,T:Decodable<D, E> + 'static> Decodable<D, E> for Gc<T> {\n+    fn decode(d: &mut D) -> Result<Gc<T>, E> {\n+        Ok(box(GC) try!(Decodable::decode(d)))\n     }\n }\n "}, {"sha": "7988735e80fdff3b648b76e926ee2ccd877ee512", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 61, "deletions": 34, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -18,52 +18,33 @@ collector is task-local so `Gc<T>` is not sendable.\n \n #![allow(experimental)]\n \n-use kinds::marker;\n use clone::Clone;\n+use cmp::{TotalOrd, Ord, Ordering, TotalEq, Eq};\n+use default::Default;\n+use fmt;\n+use hash::Hash;\n+use io::Writer;\n+use kinds::marker;\n+use ops::Deref;\n+use raw;\n \n /// Immutable garbage-collected pointer type\n #[lang=\"gc\"]\n-#[cfg(not(test))]\n #[experimental = \"Gc is currently based on reference-counting and will not collect cycles until \\\n                   task annihilation. For now, cycles need to be broken manually by using `Rc<T>` \\\n                   with a non-owning `Weak<T>` pointer. A tracing garbage collector is planned.\"]\n pub struct Gc<T> {\n+    #[cfg(stage0)]\n     ptr: @T,\n+    #[cfg(not(stage0))]\n+    ptr: *T,\n     marker: marker::NoSend,\n }\n \n-#[cfg(test)]\n-pub struct Gc<T> {\n-    ptr: @T,\n-    marker: marker::NoSend,\n-}\n-\n-impl<T: 'static> Gc<T> {\n-    /// Construct a new garbage-collected box\n-    #[inline]\n-    pub fn new(value: T) -> Gc<T> {\n-        Gc { ptr: @value, marker: marker::NoSend }\n-    }\n-\n-    /// Borrow the value contained in the garbage-collected box\n-    #[inline]\n-    pub fn borrow<'r>(&'r self) -> &'r T {\n-        &*self.ptr\n-    }\n-\n-    /// Determine if two garbage-collected boxes point to the same object\n-    #[inline]\n-    pub fn ptr_eq(&self, other: &Gc<T>) -> bool {\n-        self.borrow() as *T == other.borrow() as *T\n-    }\n-}\n-\n-impl<T> Clone for Gc<T> {\n+impl<T: 'static> Clone for Gc<T> {\n     /// Clone the pointer only\n     #[inline]\n-    fn clone(&self) -> Gc<T> {\n-        Gc{ ptr: self.ptr, marker: marker::NoSend }\n-    }\n+    fn clone(&self) -> Gc<T> { *self }\n }\n \n /// An value that represents the task-local managed heap.\n@@ -73,8 +54,54 @@ impl<T> Clone for Gc<T> {\n #[cfg(not(test))]\n pub static GC: () = ();\n \n-#[cfg(test)]\n-pub static GC: () = ();\n+impl<T: Eq + 'static> Eq for Gc<T> {\n+    #[inline]\n+    fn eq(&self, other: &Gc<T>) -> bool { *(*self) == *(*other) }\n+    #[inline]\n+    fn ne(&self, other: &Gc<T>) -> bool { *(*self) != *(*other) }\n+}\n+impl<T: Ord + 'static> Ord for Gc<T> {\n+    #[inline]\n+    fn lt(&self, other: &Gc<T>) -> bool { *(*self) < *(*other) }\n+    #[inline]\n+    fn le(&self, other: &Gc<T>) -> bool { *(*self) <= *(*other) }\n+    #[inline]\n+    fn ge(&self, other: &Gc<T>) -> bool { *(*self) >= *(*other) }\n+    #[inline]\n+    fn gt(&self, other: &Gc<T>) -> bool { *(*self) > *(*other) }\n+}\n+impl<T: TotalOrd + 'static> TotalOrd for Gc<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Gc<T>) -> Ordering { (**self).cmp(&**other) }\n+}\n+impl<T: TotalEq + 'static> TotalEq for Gc<T> {}\n+\n+impl<T: 'static> Deref<T> for Gc<T> {\n+    #[cfg(stage0)]\n+    fn deref<'a>(&'a self) -> &'a T { &*self.ptr }\n+    #[cfg(not(stage0))]\n+    fn deref<'a>(&'a self) -> &'a T { &**self }\n+}\n+\n+impl<T: Default + 'static> Default for Gc<T> {\n+    fn default() -> Gc<T> {\n+        box(GC) Default::default()\n+    }\n+}\n+\n+impl<T: 'static> raw::Repr<*raw::Box<T>> for Gc<T> {}\n+\n+impl<S: Writer, T: Hash<S> + 'static> Hash<S> for Gc<T> {\n+    fn hash(&self, s: &mut S) {\n+        (**self).hash(s)\n+    }\n+}\n+\n+impl<T: 'static + fmt::Show> fmt::Show for Gc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "318410c45c1fe9902db72da2cbb29b65e5b3c3ee", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531ed3d599000de2517cba102c83fe44a1f1e252/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=531ed3d599000de2517cba102c83fe44a1f1e252", "patch": "@@ -135,6 +135,8 @@ extern crate rustrt;\n #[cfg(test)] pub use realstd::ops;\n #[cfg(test)] pub use realstd::cmp;\n #[cfg(test)] pub use realstd::ty;\n+#[cfg(test)] pub use realstd::owned;\n+#[cfg(test)] pub use realstd::gc;\n \n \n // NB: These reexports are in the order they should be listed in rustdoc\n@@ -219,6 +221,7 @@ pub mod rand;\n \n pub mod ascii;\n \n+#[cfg(not(test))]\n pub mod gc;\n \n /* Common traits */"}]}