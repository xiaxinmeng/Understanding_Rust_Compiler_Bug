{"sha": "e8bb153b19ffa0ad815eb8934d40cd89ce550b99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4YmIxNTNiMTlmZmEwYWQ4MTVlYjg5MzRkNDBjZDg5Y2U1NTBiOTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-08T20:37:35Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-08T20:37:35Z"}, "message": "Add Markup type", "tree": {"sha": "8cce4ee9334c39c1acf78198cf842089de9d1963", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cce4ee9334c39c1acf78198cf842089de9d1963"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8bb153b19ffa0ad815eb8934d40cd89ce550b99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8bb153b19ffa0ad815eb8934d40cd89ce550b99", "html_url": "https://github.com/rust-lang/rust/commit/e8bb153b19ffa0ad815eb8934d40cd89ce550b99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7db795e747a5d5062d3b1317bb34b04bcf6866a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7db795e747a5d5062d3b1317bb34b04bcf6866a9", "html_url": "https://github.com/rust-lang/rust/commit/7db795e747a5d5062d3b1317bb34b04bcf6866a9"}], "stats": {"total": 138, "additions": 79, "deletions": 59}, "files": [{"sha": "e469f41662c42c2a523996f126204d3ba74336c6", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 27, "deletions": 48, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=e8bb153b19ffa0ad815eb8934d40cd89ce550b99", "patch": "@@ -16,6 +16,7 @@ use crate::{\n     display::{\n         macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel, ToNav, TryToNav,\n     },\n+    markup::Markup,\n     runnables::runnable,\n     FileId, FilePosition, NavigationTarget, RangeInfo, Runnable,\n };\n@@ -68,8 +69,8 @@ pub struct HoverGotoTypeData {\n /// Contains the results when hovering over an item\n #[derive(Debug, Default)]\n pub struct HoverResult {\n-    results: Vec<String>,\n-    actions: Vec<HoverAction>,\n+    pub markup: Markup,\n+    pub actions: Vec<HoverAction>,\n }\n \n impl HoverResult {\n@@ -78,22 +79,7 @@ impl HoverResult {\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        self.results.is_empty()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.results.len()\n-    }\n-\n-    pub fn actions(&self) -> &[HoverAction] {\n-        &self.actions\n-    }\n-    /// Returns the results converted into markup\n-    /// for displaying in a UI\n-    ///\n-    /// Does not process actions!\n-    pub fn to_markup(&self) -> String {\n-        self.results.join(\"\\n\\n___\\n\")\n+        self.markup.is_empty()\n     }\n \n     fn push_action(&mut self, action: HoverAction) {\n@@ -128,7 +114,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     if let Some(definition) = definition {\n         let range = sema.original_range(&node).range;\n         if let Some(text) = hover_text_from_name_kind(db, definition) {\n-            res.results.push(text);\n+            res.markup.push_section(&text);\n         }\n         if !res.is_empty() {\n             if let Some(action) = show_implementations_action(db, definition) {\n@@ -168,7 +154,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         }\n     }?;\n \n-    res.results.push(rust_code_markup(&ty.display(db)));\n+    res.markup.push_section(&rust_code_markup(&ty.display(db)));\n     let range = sema.original_range(&node).range;\n     Some(RangeInfo::new(range, res))\n }\n@@ -406,19 +392,12 @@ mod tests {\n     fn check_hover_result(ra_fixture: &str, expected: &[&str]) -> (String, Vec<HoverAction>) {\n         let (analysis, position) = analysis_and_position(ra_fixture);\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        let mut results = hover.info.results.clone();\n-        results.sort();\n-\n-        for (markup, expected) in\n-            results.iter().zip(expected.iter().chain(std::iter::repeat(&\"<missing>\")))\n-        {\n-            assert_eq!(trim_markup(&markup), *expected);\n-        }\n-\n-        assert_eq!(hover.info.len(), expected.len());\n+        let expected = expected.join(\"\\n\\n___\\n\");\n+        let actual = trim_markup(hover.info.markup.as_str());\n+        assert_eq!(expected, actual);\n \n         let content = analysis.db.file_text(position.file_id);\n-        (content[hover.range].to_string(), hover.info.actions().to_vec())\n+        (content[hover.range].to_string(), hover.info.actions.clone())\n     }\n \n     fn check_hover_no_result(ra_fixture: &str) {\n@@ -439,7 +418,7 @@ fn main() {\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n         assert_eq!(hover.range, TextRange::new(58.into(), 63.into()));\n-        assert_eq!(trim_markup(&hover.info.results[0]), (\"u32\"));\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), (\"u32\"));\n     }\n \n     #[test]\n@@ -638,7 +617,7 @@ fn main() {\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), (\"Option\\n```\\n\\n```rust\\nSome\"));\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), (\"Option\\n```\\n\\n```rust\\nSome\"));\n \n         let (analysis, position) = analysis_and_position(\n             \"\n@@ -651,7 +630,7 @@ fn main() {\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), (\"Option<i32>\"));\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), (\"Option<i32>\"));\n     }\n \n     #[test]\n@@ -708,14 +687,14 @@ The Some variant\n     fn hover_for_local_variable() {\n         let (analysis, position) = analysis_and_position(\"fn func(foo: i32) { fo<|>o; }\");\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), \"i32\");\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), \"i32\");\n     }\n \n     #[test]\n     fn hover_for_local_variable_pat() {\n         let (analysis, position) = analysis_and_position(\"fn func(fo<|>o: i32) {}\");\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), \"i32\");\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), \"i32\");\n     }\n \n     #[test]\n@@ -726,14 +705,14 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), \"i32\");\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), \"i32\");\n     }\n \n     #[test]\n     fn hover_for_param_edge() {\n         let (analysis, position) = analysis_and_position(\"fn func(<|>foo: i32) {}\");\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), \"i32\");\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), \"i32\");\n     }\n \n     #[test]\n@@ -754,7 +733,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), (\"Thing\"));\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), (\"Thing\"));\n     }\n \n     #[test]\n@@ -778,7 +757,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n         assert_eq!(\n-            trim_markup(&hover.info.results[0]),\n+            trim_markup(&hover.info.markup.as_str()),\n             (\"wrapper::Thing\\n```\\n\\n```rust\\nfn new() -> Thing\")\n         );\n     }\n@@ -802,7 +781,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), (\"const C: u32\"));\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), (\"const C: u32\"));\n     }\n \n     #[test]\n@@ -818,7 +797,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), (\"Thing\"));\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), (\"Thing\"));\n \n         /* FIXME: revive these tests\n                 let (analysis, position) = analysis_and_position(\n@@ -833,7 +812,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n                 );\n \n                 let hover = analysis.hover(position).unwrap().unwrap();\n-                assert_eq!(trim_markup(&hover.info.results[0]), (\"Thing\"));\n+                assert_eq!(trim_markup(&hover.info.markup.as_str()), (\"Thing\"));\n \n                 let (analysis, position) = analysis_and_position(\n                     \"\n@@ -846,7 +825,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n                     \",\n                 );\n                 let hover = analysis.hover(position).unwrap().unwrap();\n-                assert_eq!(trim_markup(&hover.info.results[0]), (\"enum Thing\"));\n+                assert_eq!(trim_markup(&hover.info.markup.as_str()), (\"enum Thing\"));\n \n                 let (analysis, position) = analysis_and_position(\n                     \"\n@@ -858,7 +837,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n                     \",\n                 );\n                 let hover = analysis.hover(position).unwrap().unwrap();\n-                assert_eq!(trim_markup(&hover.info.results[0]), (\"enum Thing\"));\n+                assert_eq!(trim_markup(&hover.info.markup.as_str()), (\"enum Thing\"));\n         */\n     }\n \n@@ -875,7 +854,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), \"i32\");\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), \"i32\");\n     }\n \n     #[test]\n@@ -892,7 +871,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), (\"macro_rules! foo\"));\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), (\"macro_rules! foo\"));\n     }\n \n     #[test]\n@@ -903,7 +882,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup(&hover.info.results[0]), \"i32\");\n+        assert_eq!(trim_markup(&hover.info.markup.as_str()), \"i32\");\n     }\n \n     #[test]"}, {"sha": "6a4f5cb3db16bdf87d01ad87a13cd6f2ecedc763", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=e8bb153b19ffa0ad815eb8934d40cd89ce550b99", "patch": "@@ -17,6 +17,7 @@ macro_rules! eprintln {\n \n pub mod mock_analysis;\n \n+mod markup;\n mod prime_caches;\n mod status;\n mod completion;\n@@ -68,6 +69,7 @@ pub use crate::{\n     folding_ranges::{Fold, FoldKind},\n     hover::{HoverAction, HoverConfig, HoverGotoTypeData, HoverResult},\n     inlay_hints::{InlayHint, InlayHintsConfig, InlayKind},\n+    markup::Markup,\n     references::{Declaration, Reference, ReferenceAccess, ReferenceKind, ReferenceSearchResult},\n     runnables::{Runnable, RunnableKind, TestId},\n     syntax_highlighting::{"}, {"sha": "2f2b3cc25a3b2ebf894a759bdeb35f896c9d026a", "filename": "crates/ra_ide/src/markup.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/crates%2Fra_ide%2Fsrc%2Fmarkup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/crates%2Fra_ide%2Fsrc%2Fmarkup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarkup.rs?ref=e8bb153b19ffa0ad815eb8934d40cd89ce550b99", "patch": "@@ -0,0 +1,38 @@\n+//! Markdown formatting.\n+//!\n+//! Sometimes, we want to display a \"rich text\" in the UI. At the moment, we use\n+//! markdown for this purpose. It doesn't feel like a right option, but that's\n+//! what is used by LSP, so let's keep it simple.\n+use std::fmt;\n+\n+#[derive(Default, Debug)]\n+pub struct Markup {\n+    text: String,\n+}\n+\n+impl From<Markup> for String {\n+    fn from(markup: Markup) -> Self {\n+        markup.text\n+    }\n+}\n+\n+impl fmt::Display for Markup {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.text, f)\n+    }\n+}\n+\n+impl Markup {\n+    pub fn as_str(&self) -> &str {\n+        self.text.as_str()\n+    }\n+    pub fn is_empty(&self) -> bool {\n+        self.text.is_empty()\n+    }\n+    pub fn push_section(&mut self, section: &str) {\n+        if !self.text.is_empty() {\n+            self.text.push_str(\"\\n\\n___\\n\");\n+        }\n+        self.text.push_str(section);\n+    }\n+}"}, {"sha": "8ce6e1c711a63614c5c08bd2cbe537ed4da13fc3", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=e8bb153b19ffa0ad815eb8934d40cd89ce550b99", "patch": "@@ -12,10 +12,10 @@ use lsp_types::{\n     CallHierarchyIncomingCall, CallHierarchyIncomingCallsParams, CallHierarchyItem,\n     CallHierarchyOutgoingCall, CallHierarchyOutgoingCallsParams, CallHierarchyPrepareParams,\n     CodeLens, Command, CompletionItem, Diagnostic, DocumentFormattingParams, DocumentHighlight,\n-    DocumentSymbol, FoldingRange, FoldingRangeParams, HoverContents, Location, MarkupContent,\n-    MarkupKind, Position, PrepareRenameResponse, Range, RenameParams, SemanticTokensParams,\n-    SemanticTokensRangeParams, SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation,\n-    TextDocumentIdentifier, Url, WorkspaceEdit,\n+    DocumentSymbol, FoldingRange, FoldingRangeParams, HoverContents, Location, Position,\n+    PrepareRenameResponse, Range, RenameParams, SemanticTokensParams, SemanticTokensRangeParams,\n+    SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation, TextDocumentIdentifier,\n+    Url, WorkspaceEdit,\n };\n use ra_ide::{\n     FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, NavigationTarget, Query,\n@@ -584,13 +584,10 @@ pub(crate) fn handle_hover(\n     let range = to_proto::range(&line_index, info.range);\n     let hover = lsp_ext::Hover {\n         hover: lsp_types::Hover {\n-            contents: HoverContents::Markup(MarkupContent {\n-                kind: MarkupKind::Markdown,\n-                value: crate::markdown::format_docs(&info.info.to_markup()),\n-            }),\n+            contents: HoverContents::Markup(to_proto::markup_content(info.info.markup)),\n             range: Some(range),\n         },\n-        actions: prepare_hover_actions(&snap, position.file_id, info.info.actions()),\n+        actions: prepare_hover_actions(&snap, position.file_id, &info.info.actions),\n     };\n \n     Ok(Some(hover))"}, {"sha": "263f58a00e52cbdf8532e0e0dbf9f5f4d6dc0903", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb153b19ffa0ad815eb8934d40cd89ce550b99/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=e8bb153b19ffa0ad815eb8934d40cd89ce550b99", "patch": "@@ -6,8 +6,8 @@ use ra_db::{FileId, FileRange};\n use ra_ide::{\n     Assist, AssistKind, CompletionItem, CompletionItemKind, Documentation, FileSystemEdit, Fold,\n     FoldKind, FunctionSignature, Highlight, HighlightModifier, HighlightTag, HighlightedRange,\n-    Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex, NavigationTarget, ReferenceAccess,\n-    ResolvedAssist, Runnable, Severity, SourceChange, SourceFileEdit, TextEdit,\n+    Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup, NavigationTarget,\n+    ReferenceAccess, ResolvedAssist, Runnable, Severity, SourceChange, SourceFileEdit, TextEdit,\n };\n use ra_syntax::{SyntaxKind, TextRange, TextSize};\n \n@@ -696,6 +696,10 @@ pub(crate) fn runnable(\n     })\n }\n \n+pub(crate) fn markup_content(markup: Markup) -> lsp_types::MarkupContent {\n+    lsp_types::MarkupContent { kind: lsp_types::MarkupKind::Markdown, value: markup.into() }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use ra_ide::Analysis;"}]}