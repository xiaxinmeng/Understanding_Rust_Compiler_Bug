{"sha": "edb925a91f4fafb9056d181dd620937992ad6c1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYjkyNWE5MWY0ZmFmYjkwNTZkMTgxZGQ2MjA5Mzc5OTJhZDZjMWI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-06T20:21:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-10T18:32:48Z"}, "message": "syntax: Use `MultiItemModifier` for built-in derives", "tree": {"sha": "66f09e56fb4e8dc3749927ef8b21e98b3a601ade", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66f09e56fb4e8dc3749927ef8b21e98b3a601ade"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edb925a91f4fafb9056d181dd620937992ad6c1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edb925a91f4fafb9056d181dd620937992ad6c1b", "html_url": "https://github.com/rust-lang/rust/commit/edb925a91f4fafb9056d181dd620937992ad6c1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edb925a91f4fafb9056d181dd620937992ad6c1b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a6ebec0185c9fb0d1cb319b8f640c14a3c71d7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a6ebec0185c9fb0d1cb319b8f640c14a3c71d7d", "html_url": "https://github.com/rust-lang/rust/commit/5a6ebec0185c9fb0d1cb319b8f640c14a3c71d7d"}], "stats": {"total": 71, "additions": 42, "deletions": 29}, "files": [{"sha": "4a357b0f3121a0d80616d36969f39f3b53533994", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/edb925a91f4fafb9056d181dd620937992ad6c1b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb925a91f4fafb9056d181dd620937992ad6c1b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=edb925a91f4fafb9056d181dd620937992ad6c1b", "patch": "@@ -1,6 +1,6 @@\n pub use SyntaxExtension::*;\n \n-use crate::ast::{self, Attribute, Name, PatKind, MetaItem};\n+use crate::ast::{self, Attribute, Name, PatKind};\n use crate::attr::HasAttrs;\n use crate::source_map::{SourceMap, Spanned, respan};\n use crate::edition::Edition;\n@@ -519,9 +519,6 @@ impl MacResult for DummyResult {\n     }\n }\n \n-pub type BuiltinDeriveFn =\n-    for<'cx> fn(&'cx mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable));\n-\n /// Represents different kinds of macro invocations that can be resolved.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MacroKind {\n@@ -607,7 +604,7 @@ pub enum SyntaxExtension {\n                     Vec<Symbol> /* inert attribute names */, Edition),\n \n     /// An attribute-like procedural macro that derives a builtin trait.\n-    BuiltinDerive(BuiltinDeriveFn),\n+    BuiltinDerive(Box<dyn MultiItemModifier + sync::Sync + sync::Send>),\n \n     /// A declarative macro, e.g., `macro m() {}`.\n     DeclMacro {"}, {"sha": "892c59bbc044681b3c3a017f702caad03ba6d3b4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/edb925a91f4fafb9056d181dd620937992ad6c1b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb925a91f4fafb9056d181dd620937992ad6c1b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=edb925a91f4fafb9056d181dd620937992ad6c1b", "patch": "@@ -893,29 +893,29 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             edition: ext.edition(self.cx.parse_sess.edition),\n         };\n \n-        match *ext {\n-            ProcMacroDerive(ref ext, ..) => {\n-                invoc.expansion_data.mark.set_expn_info(expn_info);\n-                let span = span.with_ctxt(self.cx.backtrace());\n-                let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n-                    path: Path::from_ident(Ident::invalid()),\n-                    span: DUMMY_SP,\n-                    node: ast::MetaItemKind::Word,\n+        match ext {\n+            ProcMacroDerive(expander, ..) | BuiltinDerive(expander) => {\n+                let meta = match ext {\n+                    ProcMacroDerive(..) => ast::MetaItem { // FIXME(jseyfried) avoid this\n+                        path: Path::from_ident(Ident::invalid()),\n+                        span: DUMMY_SP,\n+                        node: ast::MetaItemKind::Word,\n+                    },\n+                    _ => {\n+                        expn_info.allow_internal_unstable = Some(vec![\n+                            sym::rustc_attrs,\n+                            Symbol::intern(\"derive_clone_copy\"),\n+                            Symbol::intern(\"derive_eq\"),\n+                            // RustcDeserialize and RustcSerialize\n+                            Symbol::intern(\"libstd_sys_internals\"),\n+                        ].into());\n+                        attr.meta()?\n+                    }\n                 };\n-                let items = ext.expand(self.cx, span, &dummy, item);\n-                Some(invoc.fragment_kind.expect_from_annotatables(items))\n-            }\n-            BuiltinDerive(func) => {\n-                expn_info.allow_internal_unstable = Some(vec![\n-                    sym::rustc_attrs,\n-                    Symbol::intern(\"derive_clone_copy\"),\n-                    Symbol::intern(\"derive_eq\"),\n-                    Symbol::intern(\"libstd_sys_internals\"), // RustcDeserialize and RustcSerialize\n-                ].into());\n+\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n-                let mut items = Vec::new();\n-                func(self.cx, span, &attr.meta()?, &item, &mut |a| items.push(a));\n+                let items = expander.expand(self.cx, span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             _ => {"}, {"sha": "2f09ab2087e41da605b4b564cd368a051544f101", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/edb925a91f4fafb9056d181dd620937992ad6c1b/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb925a91f4fafb9056d181dd620937992ad6c1b/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=edb925a91f4fafb9056d181dd620937992ad6c1b", "patch": "@@ -1,8 +1,8 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n use rustc_data_structures::sync::Lrc;\n-use syntax::ast;\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n+use syntax::ast::{self, MetaItem};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver, MultiItemModifier};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n@@ -39,9 +39,25 @@ pub mod partial_ord;\n #[path=\"cmp/ord.rs\"]\n pub mod ord;\n \n-\n pub mod generic;\n \n+struct BuiltinDerive(\n+    fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n+);\n+\n+impl MultiItemModifier for BuiltinDerive {\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt<'_>,\n+              span: Span,\n+              meta_item: &MetaItem,\n+              item: Annotatable)\n+              -> Vec<Annotatable> {\n+        let mut items = Vec::new();\n+        (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n+        items\n+    }\n+}\n+\n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n         pub fn is_builtin_trait(name: ast::Name) -> bool {\n@@ -55,7 +71,7 @@ macro_rules! derive_traits {\n             $(\n                 resolver.add_builtin(\n                     ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n-                    Lrc::new(SyntaxExtension::BuiltinDerive($func))\n+                    Lrc::new(SyntaxExtension::BuiltinDerive(Box::new(BuiltinDerive($func))))\n                 );\n             )*\n         }"}]}