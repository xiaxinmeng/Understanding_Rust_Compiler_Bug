{"sha": "14af25797f99cb70379669fe17092fabcae6fabc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0YWYyNTc5N2Y5OWNiNzAzNzk2NjlmZTE3MDkyZmFiY2FlNmZhYmM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-18T21:37:49Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-20T13:44:21Z"}, "message": "TRPL edits: generics", "tree": {"sha": "0d38f4c63305fe854ff27c344400148ca86b0df6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d38f4c63305fe854ff27c344400148ca86b0df6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14af25797f99cb70379669fe17092fabcae6fabc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14af25797f99cb70379669fe17092fabcae6fabc", "html_url": "https://github.com/rust-lang/rust/commit/14af25797f99cb70379669fe17092fabcae6fabc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14af25797f99cb70379669fe17092fabcae6fabc/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c48227b3c94a374c47fd5110bb76d48d7d5ada3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c48227b3c94a374c47fd5110bb76d48d7d5ada3", "html_url": "https://github.com/rust-lang/rust/commit/1c48227b3c94a374c47fd5110bb76d48d7d5ada3"}], "stats": {"total": 112, "additions": 72, "deletions": 40}, "files": [{"sha": "517a6e6064253295a6292e1a6b2a3e0147f5b2bd", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 72, "deletions": 40, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/14af25797f99cb70379669fe17092fabcae6fabc/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/14af25797f99cb70379669fe17092fabcae6fabc/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=14af25797f99cb70379669fe17092fabcae6fabc", "patch": "@@ -1,31 +1,13 @@\n % Generics\n \n Sometimes, when writing a function or data type, we may want it to work for\n-multiple types of arguments. For example, remember our `OptionalInt` type?\n+multiple types of arguments. Luckily, Rust has a feature that gives us a better\n+way: generics. Generics are called \u2018parametric polymorphism\u2019 in type theory,\n+which means that they are types or functions that have multiple forms (\u2018poly\u2019\n+is multiple, \u2018morph\u2019 is form) over a given parameter (\u2018parametric\u2019).\n \n-```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-```\n-\n-If we wanted to also have an `OptionalFloat64`, we would need a new enum:\n-\n-```{rust}\n-enum OptionalFloat64 {\n-    Valuef64(f64),\n-    Missingf64,\n-}\n-```\n-\n-This is really unfortunate. Luckily, Rust has a feature that gives us a better\n-way: generics. Generics are called *parametric polymorphism* in type theory,\n-which means that they are types or functions that have multiple forms (*poly*\n-is multiple, *morph* is form) over a given parameter (*parametric*).\n-\n-Anyway, enough with type theory declarations, let's check out the generic form\n-of `OptionalInt`. It is actually provided by Rust itself, and looks like this:\n+Anyway, enough with type theory, let\u2019s check out some generic code. Rust\u2019s\n+standard library provides a type, `Option<T>`, that\u2019s generic:\n \n ```rust\n enum Option<T> {\n@@ -34,59 +16,109 @@ enum Option<T> {\n }\n ```\n \n-The `<T>` part, which you've seen a few times before, indicates that this is\n+The `<T>` part, which you\u2019ve seen a few times before, indicates that this is\n a generic data type. Inside the declaration of our enum, wherever we see a `T`,\n-we substitute that type for the same type used in the generic. Here's an\n+we substitute that type for the same type used in the generic. Here\u2019s an\n example of using `Option<T>`, with some extra type annotations:\n \n-```{rust}\n+```rust\n let x: Option<i32> = Some(5);\n ```\n \n In the type declaration, we say `Option<i32>`. Note how similar this looks to\n `Option<T>`. So, in this particular `Option`, `T` has the value of `i32`. On\n the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5`.\n-Since that's an `i32`, the two sides match, and Rust is happy. If they didn't\n-match, we'd get an error:\n+Since that\u2019s an `i32`, the two sides match, and Rust is happy. If they didn\u2019t\n+match, we\u2019d get an error:\n \n-```{rust,ignore}\n+```rust,ignore\n let x: Option<f64> = Some(5);\n // error: mismatched types: expected `core::option::Option<f64>`,\n // found `core::option::Option<_>` (expected f64 but found integral variable)\n ```\n \n-That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n-match up:\n+That doesn\u2019t mean we can\u2019t make `Option<T>`s that hold an `f64`! They just have\n+to match up:\n \n-```{rust}\n+```rust\n let x: Option<i32> = Some(5);\n let y: Option<f64> = Some(5.0f64);\n ```\n \n This is just fine. One definition, multiple uses.\n \n-Generics don't have to only be generic over one type. Consider Rust's built-in\n-`Result<T, E>` type:\n+Generics don\u2019t have to only be generic over one type. Consider another type from Rust\u2019s standard library that\u2019s similar, `Result<T, E>`:\n \n-```{rust}\n+```rust\n enum Result<T, E> {\n     Ok(T),\n     Err(E),\n }\n ```\n \n This type is generic over _two_ types: `T` and `E`. By the way, the capital letters\n-can be any letter you'd like. We could define `Result<T, E>` as:\n+can be any letter you\u2019d like. We could define `Result<T, E>` as:\n \n-```{rust}\n+```rust\n enum Result<A, Z> {\n     Ok(A),\n     Err(Z),\n }\n ```\n \n if we wanted to. Convention says that the first generic parameter should be\n-`T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n+`T`, for \u2018type\u2019, and that we use `E` for \u2018error\u2019. Rust doesn\u2019t care, however.\n \n The `Result<T, E>` type is intended to be used to return the result of a\n-computation, and to have the ability to return an error if it didn't work out.\n+computation, and to have the ability to return an error if it didn\u2019t work out.\n+\n+## Generic functions\n+\n+We can write functions that take generic types with a similar syntax:\n+\n+```rust\n+fn takes_anything<T>(x: T) {\n+    // do something with x\n+}\n+```\n+\n+The syntax has two parts: the `<T>` says \u201cthis function is generic over one\n+type, `T`\u201d, and the `x: T` says \u201cx has the type `T`.\u201d\n+\n+Multiple arguments can have the same generic type:\n+\n+```rust\n+fn takes_two_of_the_same_things<T>(x: T, y: T) {\n+    // ...\n+}\n+```\n+\n+We could write a version that takes multiple types:\n+\n+```rust\n+fn takes_two_things<T, U>(x: T, y: U) {\n+    // ...\n+}\n+```\n+\n+Generic functions are most useful with \u2018trait bounds\u2019, which we\u2019ll cover in the\n+[section on traits][traits].\n+\n+[traits]: traits.html\n+\n+## Generic structs\n+\n+You can store a generic type in a `struct` as well:\n+\n+```\n+struct Point<T> {\n+    x: T,\n+    y: T,\n+}\n+\n+let int_origin = Point { x: 0, y: 0 };\n+let float_origin = Point { x: 0.0, y: 0.0 };\n+```\n+\n+Similarly to functions, the `<T>` is where we declare the generic parameters,\n+and we then use `x: T` in the type declaration, too."}]}