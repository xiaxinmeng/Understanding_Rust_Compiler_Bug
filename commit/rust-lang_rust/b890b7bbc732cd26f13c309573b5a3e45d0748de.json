{"sha": "b890b7bbc732cd26f13c309573b5a3e45d0748de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4OTBiN2JiYzczMmNkMjZmMTNjMzA5NTczYjVhM2U0NWQwNzQ4ZGU=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-06-14T21:17:17Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-06-21T17:58:50Z"}, "message": "StrSearcher: Update substring search to use the Two Way algorithm\n\nTo improve our substring search performance, revive the two way searcher\nand adapt it to the Pattern API.\n\nFixes #25483, a performance bug: that particular case now completes faster\nin optimized rust than in ruby (but they share the same order of magnitude).\n\nMuch thanks to @gereeter who helped me understand the reverse case\nbetter and wrote the comment explaining `next_back` in the code.\n\nI had quickcheck to fuzz test forward and reverse searching thoroughly.\n\nThe two way searcher implements both forward and reverse search,\nbut not double ended search. The forward and reverse parts of the two\nway searcher are completely independent.\n\nThe two way searcher algorithm has very small, constant space overhead,\nrequiring no dynamic allocation. Our implementation is relatively fast,\nespecially due to the `byteset` addition to the algorithm, which speeds\nup many no-match cases.\n\nA bad case for the two way algorithm is:\n\n```\nlet haystack = (0..10_000).map(|_| \"dac\").collect::<String>();\nlet needle = (0..100).map(|_| \"bac\").collect::<String>());\n```\n\nFor this particular case, two way is not much faster than the naive\nimplementation it replaces.", "tree": {"sha": "36ab25e39ee5872b37b703aa1a8815006deb783a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36ab25e39ee5872b37b703aa1a8815006deb783a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b890b7bbc732cd26f13c309573b5a3e45d0748de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b890b7bbc732cd26f13c309573b5a3e45d0748de", "html_url": "https://github.com/rust-lang/rust/commit/b890b7bbc732cd26f13c309573b5a3e45d0748de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b890b7bbc732cd26f13c309573b5a3e45d0748de/comments", "author": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "committer": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "html_url": "https://github.com/rust-lang/rust/commit/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6"}], "stats": {"total": 901, "additions": 475, "deletions": 426}, "files": [{"sha": "87a018ced195accee2164df7b341a5c85d1913a3", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b890b7bbc732cd26f13c309573b5a3e45d0748de/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b890b7bbc732cd26f13c309573b5a3e45d0748de/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=b890b7bbc732cd26f13c309573b5a3e45d0748de", "patch": "@@ -705,7 +705,7 @@ fn test_split_at() {\n #[should_panic]\n fn test_split_at_boundscheck() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-    let (a, b) = s.split_at(1);\n+    s.split_at(1);\n }\n \n #[test]\n@@ -1820,6 +1820,14 @@ mod pattern {\n         Match (4, 6),\n         Reject(6, 7),\n     ]);\n+    make_test!(str_searcher_ascii_haystack_seq, \"bb\", \"abbcbbbbd\", [\n+        Reject(0, 1),\n+        Match (1, 3),\n+        Reject(3, 4),\n+        Match (4, 6),\n+        Match (6, 8),\n+        Reject(8, 9),\n+    ]);\n     make_test!(str_searcher_empty_needle_ascii_haystack, \"\", \"abbcbbd\", [\n         Match (0, 0),\n         Reject(0, 1),"}, {"sha": "bd6e1a4063abda86a8ab293dbdaed054b62c21b0", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 298, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/b890b7bbc732cd26f13c309573b5a3e45d0748de/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b890b7bbc732cd26f13c309573b5a3e45d0748de/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b890b7bbc732cd26f13c309573b5a3e45d0748de", "patch": "@@ -15,13 +15,12 @@\n #![doc(primitive = \"str\")]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use self::OldSearcher::{TwoWay, TwoWayLong};\n use self::pattern::Pattern;\n use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char::CharExt;\n use clone::Clone;\n-use cmp::{self, Eq};\n+use cmp::Eq;\n use convert::AsRef;\n use default::Default;\n use fmt;\n@@ -33,7 +32,6 @@ use option::Option::{self, None, Some};\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n-use usize;\n \n pub mod pattern;\n \n@@ -870,301 +868,6 @@ impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     }\n }\n \n-/// The internal state of an iterator that searches for matches of a substring\n-/// within a larger string using two-way search\n-#[derive(Clone)]\n-struct TwoWaySearcher {\n-    // constants\n-    crit_pos: usize,\n-    period: usize,\n-    byteset: u64,\n-\n-    // variables\n-    position: usize,\n-    memory: usize\n-}\n-\n-/*\n-    This is the Two-Way search algorithm, which was introduced in the paper:\n-    Crochemore, M., Perrin, D., 1991, Two-way string-matching, Journal of the ACM 38(3):651-675.\n-\n-    Here's some background information.\n-\n-    A *word* is a string of symbols. The *length* of a word should be a familiar\n-    notion, and here we denote it for any word x by |x|.\n-    (We also allow for the possibility of the *empty word*, a word of length zero).\n-\n-    If x is any non-empty word, then an integer p with 0 < p <= |x| is said to be a\n-    *period* for x iff for all i with 0 <= i <= |x| - p - 1, we have x[i] == x[i+p].\n-    For example, both 1 and 2 are periods for the string \"aa\". As another example,\n-    the only period of the string \"abcd\" is 4.\n-\n-    We denote by period(x) the *smallest* period of x (provided that x is non-empty).\n-    This is always well-defined since every non-empty word x has at least one period,\n-    |x|. We sometimes call this *the period* of x.\n-\n-    If u, v and x are words such that x = uv, where uv is the concatenation of u and\n-    v, then we say that (u, v) is a *factorization* of x.\n-\n-    Let (u, v) be a factorization for a word x. Then if w is a non-empty word such\n-    that both of the following hold\n-\n-      - either w is a suffix of u or u is a suffix of w\n-      - either w is a prefix of v or v is a prefix of w\n-\n-    then w is said to be a *repetition* for the factorization (u, v).\n-\n-    Just to unpack this, there are four possibilities here. Let w = \"abc\". Then we\n-    might have:\n-\n-      - w is a suffix of u and w is a prefix of v. ex: (\"lolabc\", \"abcde\")\n-      - w is a suffix of u and v is a prefix of w. ex: (\"lolabc\", \"ab\")\n-      - u is a suffix of w and w is a prefix of v. ex: (\"bc\", \"abchi\")\n-      - u is a suffix of w and v is a prefix of w. ex: (\"bc\", \"a\")\n-\n-    Note that the word vu is a repetition for any factorization (u,v) of x = uv,\n-    so every factorization has at least one repetition.\n-\n-    If x is a string and (u, v) is a factorization for x, then a *local period* for\n-    (u, v) is an integer r such that there is some word w such that |w| = r and w is\n-    a repetition for (u, v).\n-\n-    We denote by local_period(u, v) the smallest local period of (u, v). We sometimes\n-    call this *the local period* of (u, v). Provided that x = uv is non-empty, this\n-    is well-defined (because each non-empty word has at least one factorization, as\n-    noted above).\n-\n-    It can be proven that the following is an equivalent definition of a local period\n-    for a factorization (u, v): any positive integer r such that x[i] == x[i+r] for\n-    all i such that |u| - r <= i <= |u| - 1 and such that both x[i] and x[i+r] are\n-    defined. (i.e. i > 0 and i + r < |x|).\n-\n-    Using the above reformulation, it is easy to prove that\n-\n-        1 <= local_period(u, v) <= period(uv)\n-\n-    A factorization (u, v) of x such that local_period(u,v) = period(x) is called a\n-    *critical factorization*.\n-\n-    The algorithm hinges on the following theorem, which is stated without proof:\n-\n-    **Critical Factorization Theorem** Any word x has at least one critical\n-    factorization (u, v) such that |u| < period(x).\n-\n-    The purpose of maximal_suffix is to find such a critical factorization.\n-\n-*/\n-impl TwoWaySearcher {\n-    #[allow(dead_code)]\n-    fn new(needle: &[u8]) -> TwoWaySearcher {\n-        let (crit_pos_false, period_false) = TwoWaySearcher::maximal_suffix(needle, false);\n-        let (crit_pos_true, period_true) = TwoWaySearcher::maximal_suffix(needle, true);\n-\n-        let (crit_pos, period) =\n-            if crit_pos_false > crit_pos_true {\n-                (crit_pos_false, period_false)\n-            } else {\n-                (crit_pos_true, period_true)\n-            };\n-\n-        // This isn't in the original algorithm, as far as I'm aware.\n-        let byteset = needle.iter()\n-                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n-\n-        // A particularly readable explanation of what's going on here can be found\n-        // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n-        // see the code for \"Algorithm CP\" on p. 323.\n-        //\n-        // What's going on is we have some critical factorization (u, v) of the\n-        // needle, and we want to determine whether u is a suffix of\n-        // &v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n-        // \"Algorithm CP2\", which is optimized for when the period of the needle\n-        // is large.\n-        if &needle[..crit_pos] == &needle[period.. period + crit_pos] {\n-            TwoWaySearcher {\n-                crit_pos: crit_pos,\n-                period: period,\n-                byteset: byteset,\n-\n-                position: 0,\n-                memory: 0\n-            }\n-        } else {\n-            TwoWaySearcher {\n-                crit_pos: crit_pos,\n-                period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,\n-                byteset: byteset,\n-\n-                position: 0,\n-                memory: usize::MAX // Dummy value to signify that the period is long\n-            }\n-        }\n-    }\n-\n-    // One of the main ideas of Two-Way is that we factorize the needle into\n-    // two halves, (u, v), and begin trying to find v in the haystack by scanning\n-    // left to right. If v matches, we try to match u by scanning right to left.\n-    // How far we can jump when we encounter a mismatch is all based on the fact\n-    // that (u, v) is a critical factorization for the needle.\n-    #[inline]\n-    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n-            -> Option<(usize, usize)> {\n-        'search: loop {\n-            // Check that we have room to search in\n-            if self.position + needle.len() > haystack.len() {\n-                return None;\n-            }\n-\n-            // Quickly skip by large portions unrelated to our substring\n-            if (self.byteset >>\n-                    ((haystack[self.position + needle.len() - 1] & 0x3f)\n-                     as usize)) & 1 == 0 {\n-                self.position += needle.len();\n-                if !long_period {\n-                    self.memory = 0;\n-                }\n-                continue 'search;\n-            }\n-\n-            // See if the right part of the needle matches\n-            let start = if long_period { self.crit_pos }\n-                        else { cmp::max(self.crit_pos, self.memory) };\n-            for i in start..needle.len() {\n-                if needle[i] != haystack[self.position + i] {\n-                    self.position += i - self.crit_pos + 1;\n-                    if !long_period {\n-                        self.memory = 0;\n-                    }\n-                    continue 'search;\n-                }\n-            }\n-\n-            // See if the left part of the needle matches\n-            let start = if long_period { 0 } else { self.memory };\n-            for i in (start..self.crit_pos).rev() {\n-                if needle[i] != haystack[self.position + i] {\n-                    self.position += self.period;\n-                    if !long_period {\n-                        self.memory = needle.len() - self.period;\n-                    }\n-                    continue 'search;\n-                }\n-            }\n-\n-            // We have found a match!\n-            let match_pos = self.position;\n-            self.position += needle.len(); // add self.period for all matches\n-            if !long_period {\n-                self.memory = 0; // set to needle.len() - self.period for all matches\n-            }\n-            return Some((match_pos, match_pos + needle.len()));\n-        }\n-    }\n-\n-    // Computes a critical factorization (u, v) of `arr`.\n-    // Specifically, returns (i, p), where i is the starting index of v in some\n-    // critical factorization (u, v) and p = period(v)\n-    #[inline]\n-    #[allow(dead_code)]\n-    #[allow(deprecated)]\n-    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n-        let mut left: usize = !0; // Corresponds to i in the paper\n-        let mut right = 0; // Corresponds to j in the paper\n-        let mut offset = 1; // Corresponds to k in the paper\n-        let mut period = 1; // Corresponds to p in the paper\n-\n-        while right + offset < arr.len() {\n-            let a;\n-            let b;\n-            if reversed {\n-                a = arr[left.wrapping_add(offset)];\n-                b = arr[right + offset];\n-            } else {\n-                a = arr[right + offset];\n-                b = arr[left.wrapping_add(offset)];\n-            }\n-            if a < b {\n-                // Suffix is smaller, period is entire prefix so far.\n-                right += offset;\n-                offset = 1;\n-                period = right.wrapping_sub(left);\n-            } else if a == b {\n-                // Advance through repetition of the current period.\n-                if offset == period {\n-                    right += offset;\n-                    offset = 1;\n-                } else {\n-                    offset += 1;\n-                }\n-            } else {\n-                // Suffix is larger, start over from current location.\n-                left = right;\n-                right += 1;\n-                offset = 1;\n-                period = 1;\n-            }\n-        }\n-        (left.wrapping_add(1), period)\n-    }\n-}\n-\n-/// The internal state of an iterator that searches for matches of a substring\n-/// within a larger string using a dynamically chosen search algorithm\n-#[derive(Clone)]\n-// NB: This is kept around for convenience because\n-// it is planned to be used again in the future\n-enum OldSearcher {\n-    TwoWay(TwoWaySearcher),\n-    TwoWayLong(TwoWaySearcher),\n-}\n-\n-impl OldSearcher {\n-    #[allow(dead_code)]\n-    fn new(haystack: &[u8], needle: &[u8]) -> OldSearcher {\n-        if needle.is_empty() {\n-            // Handle specially\n-            unimplemented!()\n-        // FIXME: Tune this.\n-        // FIXME(#16715): This unsigned integer addition will probably not\n-        // overflow because that would mean that the memory almost solely\n-        // consists of the needle. Needs #16715 to be formally fixed.\n-        } else if needle.len() + 20 > haystack.len() {\n-            // Use naive searcher\n-            unimplemented!()\n-        } else {\n-            let searcher = TwoWaySearcher::new(needle);\n-            if searcher.memory == usize::MAX { // If the period is long\n-                TwoWayLong(searcher)\n-            } else {\n-                TwoWay(searcher)\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-// NB: This is kept around for convenience because\n-// it is planned to be used again in the future\n-struct OldMatchIndices<'a, 'b> {\n-    // constants\n-    haystack: &'a str,\n-    needle: &'b str,\n-    searcher: OldSearcher\n-}\n-\n-impl<'a, 'b>  OldMatchIndices<'a, 'b> {\n-    #[inline]\n-    #[allow(dead_code)]\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        match self.searcher {\n-            TwoWay(ref mut searcher)\n-                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), false),\n-            TwoWayLong(ref mut searcher)\n-                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), true),\n-        }\n-    }\n-}\n-\n /*\n Section: Comparing strings\n */"}, {"sha": "de40a57fe9c17b2f6ba8e553f3b0d43aa14d1aad", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 465, "deletions": 127, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/b890b7bbc732cd26f13c309573b5a3e45d0748de/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b890b7bbc732cd26f13c309573b5a3e45d0748de/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=b890b7bbc732cd26f13c309573b5a3e45d0748de", "patch": "@@ -17,6 +17,8 @@\n             reason = \"API not fully fleshed out and ready to be stabilized\")]\n \n use prelude::*;\n+use core::cmp;\n+use usize;\n \n // Pattern\n \n@@ -345,141 +347,16 @@ impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}\n // Impl for &str\n /////////////////////////////////////////////////////////////////////////////\n \n-// Todo: Optimize the naive implementation here\n-\n-/// Associated type for `<&str as Pattern<'a>>::Searcher`.\n-#[derive(Clone)]\n-pub struct StrSearcher<'a, 'b> {\n-    haystack: &'a str,\n-    needle: &'b str,\n-    start: usize,\n-    end: usize,\n-    state: State,\n-}\n-\n-#[derive(Clone, PartialEq)]\n-enum State { Done, NotDone, Reject(usize, usize) }\n-impl State {\n-    #[inline] fn done(&self) -> bool { *self == State::Done }\n-    #[inline] fn take(&mut self) -> State { ::mem::replace(self, State::NotDone) }\n-}\n-\n /// Non-allocating substring search.\n ///\n-/// Will handle the pattern `\"\"` as returning empty matches at each utf8\n+/// Will handle the pattern `\"\"` as returning empty matches at each character\n /// boundary.\n impl<'a, 'b> Pattern<'a> for &'b str {\n     type Searcher = StrSearcher<'a, 'b>;\n \n     #[inline]\n     fn into_searcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> {\n-        StrSearcher {\n-            haystack: haystack,\n-            needle: self,\n-            start: 0,\n-            end: haystack.len(),\n-            state: State::NotDone,\n-        }\n-    }\n-}\n-\n-unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b>  {\n-    #[inline]\n-    fn haystack(&self) -> &'a str {\n-        self.haystack\n-    }\n-\n-    #[inline]\n-    fn next(&mut self) -> SearchStep {\n-        str_search_step(self,\n-        |m: &mut StrSearcher| {\n-            // Forward step for empty needle\n-            let current_start = m.start;\n-            if !m.state.done() {\n-                m.start = m.haystack.char_range_at(current_start).next;\n-                m.state = State::Reject(current_start, m.start);\n-            }\n-            SearchStep::Match(current_start, current_start)\n-        },\n-        |m: &mut StrSearcher| {\n-            // Forward step for nonempty needle\n-            let current_start = m.start;\n-            // Compare byte window because this might break utf8 boundaries\n-            let possible_match = &m.haystack.as_bytes()[m.start .. m.start + m.needle.len()];\n-            if possible_match == m.needle.as_bytes() {\n-                m.start += m.needle.len();\n-                SearchStep::Match(current_start, m.start)\n-            } else {\n-                // Skip a char\n-                let haystack_suffix = &m.haystack[m.start..];\n-                m.start += haystack_suffix.chars().next().unwrap().len_utf8();\n-                SearchStep::Reject(current_start, m.start)\n-            }\n-        })\n-    }\n-}\n-\n-unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b>  {\n-    #[inline]\n-    fn next_back(&mut self) -> SearchStep {\n-        str_search_step(self,\n-        |m: &mut StrSearcher| {\n-            // Backward step for empty needle\n-            let current_end = m.end;\n-            if !m.state.done() {\n-                m.end = m.haystack.char_range_at_reverse(current_end).next;\n-                m.state = State::Reject(m.end, current_end);\n-            }\n-            SearchStep::Match(current_end, current_end)\n-        },\n-        |m: &mut StrSearcher| {\n-            // Backward step for nonempty needle\n-            let current_end = m.end;\n-            // Compare byte window because this might break utf8 boundaries\n-            let possible_match = &m.haystack.as_bytes()[m.end - m.needle.len() .. m.end];\n-            if possible_match == m.needle.as_bytes() {\n-                m.end -= m.needle.len();\n-                SearchStep::Match(m.end, current_end)\n-            } else {\n-                // Skip a char\n-                let haystack_prefix = &m.haystack[..m.end];\n-                m.end -= haystack_prefix.chars().rev().next().unwrap().len_utf8();\n-                SearchStep::Reject(m.end, current_end)\n-            }\n-        })\n-    }\n-}\n-\n-// Helper function for encapsulating the common control flow\n-// of doing a search step from the front or doing a search step from the back\n-fn str_search_step<F, G>(mut m: &mut StrSearcher,\n-                         empty_needle_step: F,\n-                         nonempty_needle_step: G) -> SearchStep\n-    where F: FnOnce(&mut StrSearcher) -> SearchStep,\n-          G: FnOnce(&mut StrSearcher) -> SearchStep\n-{\n-    if m.state.done() {\n-        SearchStep::Done\n-    } else if m.needle.is_empty() && m.start <= m.end {\n-        // Case for needle == \"\"\n-        if let State::Reject(a, b) = m.state.take() {\n-            SearchStep::Reject(a, b)\n-        } else {\n-            if m.start == m.end {\n-                m.state = State::Done;\n-            }\n-            empty_needle_step(&mut m)\n-        }\n-    } else if m.start + m.needle.len() <= m.end {\n-        // Case for needle != \"\"\n-        nonempty_needle_step(&mut m)\n-    } else if m.start < m.end {\n-        // Remaining slice shorter than needle, reject it\n-        m.state = State::Done;\n-        SearchStep::Reject(m.start, m.end)\n-    } else {\n-        m.state = State::Done;\n-        SearchStep::Done\n+        StrSearcher::new(haystack, self)\n     }\n }\n \n@@ -633,3 +510,464 @@ impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n impl<'a, 'b> Pattern<'a> for &'b &'b str {\n     pattern_methods!(StrSearcher<'a, 'b>, |&s| s, |s| s);\n }\n+\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Two Way substring searcher\n+/////////////////////////////////////////////////////////////////////////////\n+\n+#[derive(Clone, Debug)]\n+/// Associated type for `<&str as Pattern<'a>>::Searcher`.\n+pub struct StrSearcher<'a, 'b> {\n+    haystack: &'a str,\n+    needle: &'b str,\n+\n+    searcher: StrSearcherImpl,\n+}\n+\n+#[derive(Clone, Debug)]\n+enum StrSearcherImpl {\n+    Empty(EmptyNeedle),\n+    TwoWay {\n+        last_match_fw: Option<(usize, usize)>,\n+        last_match_bw: Option<(usize, usize)>,\n+        searcher: TwoWaySearcher,\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+struct EmptyNeedle {\n+    position: usize,\n+    end: usize,\n+    is_match_fw: bool,\n+    is_match_bw: bool,\n+}\n+\n+impl<'a, 'b> StrSearcher<'a, 'b> {\n+    fn new(haystack: &'a str, needle: &'b str) -> StrSearcher<'a, 'b> {\n+        if needle.is_empty() {\n+            StrSearcher {\n+                haystack: haystack,\n+                needle: needle,\n+                searcher: StrSearcherImpl::Empty(EmptyNeedle {\n+                    position: 0,\n+                    end: haystack.len(),\n+                    is_match_fw: true,\n+                    is_match_bw: true,\n+                }),\n+            }\n+        } else {\n+            StrSearcher {\n+                haystack: haystack,\n+                needle: needle,\n+                searcher: StrSearcherImpl::TwoWay {\n+                    last_match_fw: None,\n+                    last_match_bw: None,\n+                    searcher: TwoWaySearcher::new(needle.as_bytes(), haystack.len())\n+                },\n+            }\n+        }\n+    }\n+}\n+\n+unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n+    fn haystack(&self) -> &'a str { self.haystack }\n+\n+    #[inline]\n+    fn next(&mut self) -> SearchStep {\n+        match self.searcher {\n+            StrSearcherImpl::Empty(ref mut searcher) => {\n+                // empty needle rejects every char and matches every empty string between them\n+                let is_match = searcher.is_match_fw;\n+                searcher.is_match_fw = !searcher.is_match_fw;\n+                let pos = searcher.position;\n+                match self.haystack[pos..].chars().next() {\n+                    _ if is_match => SearchStep::Match(pos, pos),\n+                    None => SearchStep::Done,\n+                    Some(ch) => {\n+                        searcher.position += ch.len_utf8();\n+                        SearchStep::Reject(pos, searcher.position)\n+                    }\n+                }\n+            }\n+            StrSearcherImpl::TwoWay { ref mut last_match_fw, ref mut searcher, .. } => {\n+                // TwoWaySearcher produces valid *Match* indices that split at char boundaries\n+                // as long as it does correct matching and that haystack and needle are\n+                // valid UTF-8\n+                // *Rejects* fall on the same indices (the intervals between matches)\n+                // so they are always on character boundaries.\n+                if let Some((a, b)) = last_match_fw.take() {\n+                    return SearchStep::Match(a, b);\n+                }\n+                let last_pos = searcher.position;\n+                let is_long = searcher.memory == usize::MAX;\n+                let next_match = searcher.next(self.haystack.as_bytes(),\n+                                               self.needle.as_bytes(),\n+                                               is_long);\n+                match next_match {\n+                    None => if last_pos != self.haystack.len() {\n+                        SearchStep::Reject(last_pos, self.haystack.len())\n+                    } else {\n+                        SearchStep::Done\n+                    },\n+                    Some((a, b)) => {\n+                        if a == last_pos {\n+                            SearchStep::Match(a, b)\n+                        } else {\n+                            *last_match_fw = Some((a, b));\n+                            SearchStep::Reject(last_pos, a)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+}\n+unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep {\n+        match self.searcher {\n+            StrSearcherImpl::Empty(ref mut searcher) => {\n+                let is_match = searcher.is_match_bw;\n+                searcher.is_match_bw = !searcher.is_match_bw;\n+                let end = searcher.end;\n+                match self.haystack[..end].chars().next_back() {\n+                    _ if is_match => SearchStep::Match(end, end),\n+                    None => SearchStep::Done,\n+                    Some(ch) => {\n+                        searcher.end -= ch.len_utf8();\n+                        SearchStep::Reject(searcher.end, end)\n+                    }\n+                }\n+            }\n+            StrSearcherImpl::TwoWay { ref mut last_match_bw, ref mut searcher, .. } => {\n+                if let Some((a, b)) = last_match_bw.take() {\n+                    return SearchStep::Match(a, b);\n+                }\n+                let last_end = searcher.end;\n+                let next_match = searcher.next_back(self.haystack.as_bytes(),\n+                                                    self.needle.as_bytes());\n+                match next_match {\n+                    None => if last_end != 0 {\n+                        SearchStep::Reject(0, last_end)\n+                    } else {\n+                        SearchStep::Done\n+                    },\n+                    Some((a, b)) => {\n+                        if b == last_end {\n+                            SearchStep::Match(a, b)\n+                        } else {\n+                            *last_match_bw = Some((a, b));\n+                            SearchStep::Reject(b, last_end)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// The internal state of an iterator that searches for matches of a substring\n+/// within a larger string using two-way search\n+#[derive(Clone, Debug)]\n+struct TwoWaySearcher {\n+    // constants\n+    crit_pos: usize,\n+    period: usize,\n+    byteset: u64,\n+\n+    // variables\n+    position: usize,\n+    end: usize,\n+    memory: usize\n+}\n+\n+/*\n+    This is the Two-Way search algorithm, which was introduced in the paper:\n+    Crochemore, M., Perrin, D., 1991, Two-way string-matching, Journal of the ACM 38(3):651-675.\n+\n+    Here's some background information.\n+\n+    A *word* is a string of symbols. The *length* of a word should be a familiar\n+    notion, and here we denote it for any word x by |x|.\n+    (We also allow for the possibility of the *empty word*, a word of length zero).\n+\n+    If x is any non-empty word, then an integer p with 0 < p <= |x| is said to be a\n+    *period* for x iff for all i with 0 <= i <= |x| - p - 1, we have x[i] == x[i+p].\n+    For example, both 1 and 2 are periods for the string \"aa\". As another example,\n+    the only period of the string \"abcd\" is 4.\n+\n+    We denote by period(x) the *smallest* period of x (provided that x is non-empty).\n+    This is always well-defined since every non-empty word x has at least one period,\n+    |x|. We sometimes call this *the period* of x.\n+\n+    If u, v and x are words such that x = uv, where uv is the concatenation of u and\n+    v, then we say that (u, v) is a *factorization* of x.\n+\n+    Let (u, v) be a factorization for a word x. Then if w is a non-empty word such\n+    that both of the following hold\n+\n+      - either w is a suffix of u or u is a suffix of w\n+      - either w is a prefix of v or v is a prefix of w\n+\n+    then w is said to be a *repetition* for the factorization (u, v).\n+\n+    Just to unpack this, there are four possibilities here. Let w = \"abc\". Then we\n+    might have:\n+\n+      - w is a suffix of u and w is a prefix of v. ex: (\"lolabc\", \"abcde\")\n+      - w is a suffix of u and v is a prefix of w. ex: (\"lolabc\", \"ab\")\n+      - u is a suffix of w and w is a prefix of v. ex: (\"bc\", \"abchi\")\n+      - u is a suffix of w and v is a prefix of w. ex: (\"bc\", \"a\")\n+\n+    Note that the word vu is a repetition for any factorization (u,v) of x = uv,\n+    so every factorization has at least one repetition.\n+\n+    If x is a string and (u, v) is a factorization for x, then a *local period* for\n+    (u, v) is an integer r such that there is some word w such that |w| = r and w is\n+    a repetition for (u, v).\n+\n+    We denote by local_period(u, v) the smallest local period of (u, v). We sometimes\n+    call this *the local period* of (u, v). Provided that x = uv is non-empty, this\n+    is well-defined (because each non-empty word has at least one factorization, as\n+    noted above).\n+\n+    It can be proven that the following is an equivalent definition of a local period\n+    for a factorization (u, v): any positive integer r such that x[i] == x[i+r] for\n+    all i such that |u| - r <= i <= |u| - 1 and such that both x[i] and x[i+r] are\n+    defined. (i.e. i > 0 and i + r < |x|).\n+\n+    Using the above reformulation, it is easy to prove that\n+\n+        1 <= local_period(u, v) <= period(uv)\n+\n+    A factorization (u, v) of x such that local_period(u,v) = period(x) is called a\n+    *critical factorization*.\n+\n+    The algorithm hinges on the following theorem, which is stated without proof:\n+\n+    **Critical Factorization Theorem** Any word x has at least one critical\n+    factorization (u, v) such that |u| < period(x).\n+\n+    The purpose of maximal_suffix is to find such a critical factorization.\n+\n+*/\n+impl TwoWaySearcher {\n+    fn new(needle: &[u8], end: usize) -> TwoWaySearcher {\n+        let (crit_pos_false, period_false) = TwoWaySearcher::maximal_suffix(needle, false);\n+        let (crit_pos_true, period_true) = TwoWaySearcher::maximal_suffix(needle, true);\n+\n+        let (crit_pos, period) =\n+            if crit_pos_false > crit_pos_true {\n+                (crit_pos_false, period_false)\n+            } else {\n+                (crit_pos_true, period_true)\n+            };\n+\n+        // This isn't in the original algorithm, as far as I'm aware.\n+        let byteset = needle.iter()\n+                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n+\n+        // A particularly readable explanation of what's going on here can be found\n+        // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n+        // see the code for \"Algorithm CP\" on p. 323.\n+        //\n+        // What's going on is we have some critical factorization (u, v) of the\n+        // needle, and we want to determine whether u is a suffix of\n+        // &v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // \"Algorithm CP2\", which is optimized for when the period of the needle\n+        // is large.\n+        if &needle[..crit_pos] == &needle[period.. period + crit_pos] {\n+            // short period case\n+            TwoWaySearcher {\n+                crit_pos: crit_pos,\n+                period: period,\n+                byteset: byteset,\n+\n+                position: 0,\n+                end: end,\n+                memory: 0\n+            }\n+        } else {\n+            // long period case\n+            // we have an approximation to the actual period, and don't use memory.\n+            TwoWaySearcher {\n+                crit_pos: crit_pos,\n+                period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,\n+                byteset: byteset,\n+\n+                position: 0,\n+                end: end,\n+                memory: usize::MAX // Dummy value to signify that the period is long\n+            }\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn byteset_contains(&self, byte: u8) -> bool {\n+        (self.byteset >> ((byte & 0x3f) as usize)) & 1 != 0\n+    }\n+\n+    // One of the main ideas of Two-Way is that we factorize the needle into\n+    // two halves, (u, v), and begin trying to find v in the haystack by scanning\n+    // left to right. If v matches, we try to match u by scanning right to left.\n+    // How far we can jump when we encounter a mismatch is all based on the fact\n+    // that (u, v) is a critical factorization for the needle.\n+    #[inline]\n+    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n+            -> Option<(usize, usize)> {\n+        // `next()` uses `self.position` as its cursor\n+        'search: loop {\n+            // Check that we have room to search in\n+            if self.position + needle.len() > haystack.len() {\n+                self.position = haystack.len();\n+                return None;\n+            }\n+\n+            // Quickly skip by large portions unrelated to our substring\n+            if !self.byteset_contains(haystack[self.position + needle.len() - 1]) {\n+                self.position += needle.len();\n+                if !long_period {\n+                    self.memory = 0;\n+                }\n+                continue 'search;\n+            }\n+\n+            // See if the right part of the needle matches\n+            let start = if long_period { self.crit_pos }\n+                        else { cmp::max(self.crit_pos, self.memory) };\n+            for i in start..needle.len() {\n+                if needle[i] != haystack[self.position + i] {\n+                    self.position += i - self.crit_pos + 1;\n+                    if !long_period {\n+                        self.memory = 0;\n+                    }\n+                    continue 'search;\n+                }\n+            }\n+\n+            // See if the left part of the needle matches\n+            let start = if long_period { 0 } else { self.memory };\n+            for i in (start..self.crit_pos).rev() {\n+                if needle[i] != haystack[self.position + i] {\n+                    self.position += self.period;\n+                    if !long_period {\n+                        self.memory = needle.len() - self.period;\n+                    }\n+                    continue 'search;\n+                }\n+            }\n+\n+            // We have found a match!\n+            let match_pos = self.position;\n+\n+            // Note: add self.period instead of needle.len() to have overlapping matches\n+            self.position += needle.len();\n+            if !long_period {\n+                self.memory = 0; // set to needle.len() - self.period for overlapping matches\n+            }\n+\n+            return Some((match_pos, match_pos + needle.len()));\n+        }\n+    }\n+\n+    // Follows the ideas in `next()`.\n+    //\n+    // All the definitions are completely symmetrical, with period(x) = period(reverse(x))\n+    // and local_period(u, v) = local_period(reverse(v), reverse(u)), so if (u, v)\n+    // is a critical factorization, so is (reverse(v), reverse(u)). Similarly,\n+    // the \"period\" stored in self.period is the real period if long_period is\n+    // false, and so is still valid for a reversed needle, and if long_period is\n+    // true, all the algorithm requires is that self.period is less than or\n+    // equal to the real period, which must be true for the forward case anyway.\n+    //\n+    // To search in reverse through the haystack, we search forward through\n+    // a reversed haystack with a reversed needle, and the above paragraph shows\n+    // that the precomputed parameters can be left alone.\n+    #[inline]\n+    fn next_back(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(usize, usize)> {\n+        // `next_back()` uses `self.end` as its cursor -- so that `next()` and `next_back()`\n+        // are independent.\n+        'search: loop {\n+            // Check that we have room to search in\n+            if needle.len() > self.end {\n+                self.end = 0;\n+                return None;\n+            }\n+\n+            // Quickly skip by large portions unrelated to our substring\n+            if !self.byteset_contains(haystack[self.end - needle.len()]) {\n+                self.end -= needle.len();\n+                continue 'search;\n+            }\n+\n+            // See if the left part of the needle matches\n+            for i in (0..self.crit_pos).rev() {\n+                if needle[i] != haystack[self.end - needle.len() + i] {\n+                    self.end -= self.crit_pos - i;\n+                    continue 'search;\n+                }\n+            }\n+\n+            // See if the right part of the needle matches\n+            for i in self.crit_pos..needle.len() {\n+                if needle[i] != haystack[self.end - needle.len() + i] {\n+                    self.end -= self.period;\n+                    continue 'search;\n+                }\n+            }\n+\n+            // We have found a match!\n+            let match_pos = self.end - needle.len();\n+            // Note: sub self.period instead of needle.len() to have overlapping matches\n+            self.end -= needle.len();\n+\n+            return Some((match_pos, match_pos + needle.len()));\n+        }\n+    }\n+\n+    // Computes a critical factorization (u, v) of `arr`.\n+    // Specifically, returns (i, p), where i is the starting index of v in some\n+    // critical factorization (u, v) and p = period(v)\n+    #[inline]\n+    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n+        let mut left: usize = !0; // Corresponds to i in the paper\n+        let mut right = 0; // Corresponds to j in the paper\n+        let mut offset = 1; // Corresponds to k in the paper\n+        let mut period = 1; // Corresponds to p in the paper\n+\n+        while right + offset < arr.len() {\n+            let a;\n+            let b;\n+            if reversed {\n+                a = arr[left.wrapping_add(offset)];\n+                b = arr[right + offset];\n+            } else {\n+                a = arr[right + offset];\n+                b = arr[left.wrapping_add(offset)];\n+            }\n+            if a < b {\n+                // Suffix is smaller, period is entire prefix so far.\n+                right += offset;\n+                offset = 1;\n+                period = right.wrapping_sub(left);\n+            } else if a == b {\n+                // Advance through repetition of the current period.\n+                if offset == period {\n+                    right += offset;\n+                    offset = 1;\n+                } else {\n+                    offset += 1;\n+                }\n+            } else {\n+                // Suffix is larger, start over from current location.\n+                left = right;\n+                right += 1;\n+                offset = 1;\n+                period = 1;\n+            }\n+        }\n+        (left.wrapping_add(1), period)\n+    }\n+}"}]}