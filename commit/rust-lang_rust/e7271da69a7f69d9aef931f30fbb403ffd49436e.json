{"sha": "e7271da69a7f69d9aef931f30fbb403ffd49436e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MjcxZGE2OWE3ZjY5ZDlhZWY5MzFmMzBmYmI0MDNmZmQ0OTQzNmU=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2020-08-16T13:59:43Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2020-08-16T18:31:48Z"}, "message": "Improve `align_offset` at opt-level <= 1\n\nAt opt-level <= 1, the methods such as `wrapping_mul` are not being\ninlined, causing significant bloating and slowdowns of the\nimplementation at these optimisation levels.\n\nWith use of these intrinsics, the codegen of this function at\n-Copt_level=1 is the same as it is at -Copt_level=3.", "tree": {"sha": "ed780327bc49fe148c440bbd328fd14f55e39398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed780327bc49fe148c440bbd328fd14f55e39398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7271da69a7f69d9aef931f30fbb403ffd49436e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7271da69a7f69d9aef931f30fbb403ffd49436e", "html_url": "https://github.com/rust-lang/rust/commit/e7271da69a7f69d9aef931f30fbb403ffd49436e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7271da69a7f69d9aef931f30fbb403ffd49436e/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97ba0c7171c4d2d9b899a2bd8e40a8974c47b86d", "url": "https://api.github.com/repos/rust-lang/rust/commits/97ba0c7171c4d2d9b899a2bd8e40a8974c47b86d", "html_url": "https://github.com/rust-lang/rust/commit/97ba0c7171c4d2d9b899a2bd8e40a8974c47b86d"}], "stats": {"total": 55, "additions": 38, "deletions": 17}, "files": [{"sha": "78308f97461c1ad617b8c24946959dd6e277af0d", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e7271da69a7f69d9aef931f30fbb403ffd49436e/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7271da69a7f69d9aef931f30fbb403ffd49436e/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=e7271da69a7f69d9aef931f30fbb403ffd49436e", "patch": "@@ -1166,6 +1166,10 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n /// Any questions go to @nagisa.\n #[lang = \"align_offset\"]\n pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n+    // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n+    // 1, where the method versions of these operations are not inlined.\n+    use intrinsics::{unchecked_shl, unchecked_shr, unchecked_sub, wrapping_mul, wrapping_sub};\n+\n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n     ///\n     /// This implementation is tailored for align_offset and has following preconditions:\n@@ -1175,7 +1179,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     ///\n     /// Implementation of this function shall not panic. Ever.\n     #[inline]\n-    fn mod_inv(x: usize, m: usize) -> usize {\n+    unsafe fn mod_inv(x: usize, m: usize) -> usize {\n         /// Multiplicative modular inverse table modulo 2\u2074 = 16.\n         ///\n         /// Note, that this table does not contain values where inverse does not exist (i.e., for\n@@ -1187,8 +1191,10 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         const INV_TABLE_MOD_SQUARED: usize = INV_TABLE_MOD * INV_TABLE_MOD;\n \n         let table_inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n+        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n+        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n         if m <= INV_TABLE_MOD {\n-            table_inverse & (m - 1)\n+            table_inverse & m_minus_one\n         } else {\n             // We iterate \"up\" using the following formula:\n             //\n@@ -1204,17 +1210,18 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n                 // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n                 // usize::MAX` instead, because we take the result `mod n` at the end\n                 // anyway.\n-                inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)));\n+                inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n                 if going_mod >= m {\n-                    return inverse & (m - 1);\n+                    return inverse & m_minus_one;\n                 }\n-                going_mod = going_mod.wrapping_mul(going_mod);\n+                going_mod = wrapping_mul(going_mod, going_mod);\n             }\n         }\n     }\n \n     let stride = mem::size_of::<T>();\n-    let a_minus_one = a.wrapping_sub(1);\n+    // SAFETY: `a` is a power-of-two, hence non-zero.\n+    let a_minus_one = unsafe { unchecked_sub(a, 1) };\n     let pmoda = p as usize & a_minus_one;\n \n     if pmoda == 0 {\n@@ -1228,25 +1235,27 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n             // elements will ever align the pointer.\n             !0\n         } else {\n-            a.wrapping_sub(pmoda)\n+            wrapping_sub(a, pmoda)\n         };\n     }\n \n     let smoda = stride & a_minus_one;\n-    // SAFETY: a is power-of-two so cannot be 0. stride = 0 is handled above.\n+    // SAFETY: a is power-of-two hence non-zero. stride == 0 case is handled above.\n     let gcdpow = unsafe { intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a)) };\n-    let gcd = 1usize << gcdpow;\n+    // SAFETY: gcdpow has an upper-bound that\u2019s at most the number of bits in an usize.\n+    let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n \n-    if p as usize & (gcd.wrapping_sub(1)) == 0 {\n+    // SAFETY: gcd is always greater or equal to 1.\n+    if p as usize & unsafe { unchecked_sub(gcd, 1) } == 0 {\n         // This branch solves for the following linear congruence equation:\n         //\n         // ` p + so = 0 mod a `\n         //\n         // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n         // requested alignment.\n         //\n-        // With `g = gcd(a, s)`, and the above asserting that `p` is also divisible by `g`, we can\n-        // denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n+        // With `g = gcd(a, s)`, and the above condition asserting that `p` is also divisible by\n+        // `g`, we can denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n         //\n         // ` p' + s'o = 0 mod a' `\n         // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n@@ -1259,11 +1268,23 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         //\n         // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n         // to take the result `o mod lcm(s, a)`. We can replace `lcm(s, a)` with just a `a'`.\n-        let a2 = a >> gcdpow;\n-        let a2minus1 = a2.wrapping_sub(1);\n-        let s2 = smoda >> gcdpow;\n-        let minusp2 = a2.wrapping_sub(pmoda >> gcdpow);\n-        return (minusp2.wrapping_mul(mod_inv(s2, a2))) & a2minus1;\n+\n+        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n+        // `a`.\n+        let a2 = unsafe { unchecked_shr(a, gcdpow) };\n+        // SAFETY: `a2` is non-zero. Shifting `a` by `gcdpow` cannot shift out any of the set bits\n+        // in `a` (of which it has exactly one).\n+        let a2minus1 = unsafe { unchecked_sub(a2, 1) };\n+        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n+        // `a`.\n+        let s2 = unsafe { unchecked_shr(smoda, gcdpow) };\n+        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n+        // `a`. Furthermore, the subtraction cannot overflow, because `a2 = a >> gcdpow` will\n+        // always be strictly greater than `(p % a) >> gcdpow`.\n+        let minusp2 = unsafe { unchecked_sub(a2, unchecked_shr(pmoda, gcdpow)) };\n+        // SAFETY: `a2` is a power-of-two, as proven above. `s2` is strictly less than `a2`\n+        // because `(s % a) >> gcdpow` is strictly less than `a >> gcdpow`.\n+        return wrapping_mul(minusp2, unsafe { mod_inv(s2, a2) }) & a2minus1;\n     }\n \n     // Cannot be aligned at all."}]}