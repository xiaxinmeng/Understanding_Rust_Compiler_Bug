{"sha": "949b978ec9d63b0eea23d89bad16c6f022ac34a3", "node_id": "C_kwDOAAsO6NoAKDk0OWI5NzhlYzlkNjNiMGVlYTIzZDg5YmFkMTZjNmYwMjJhYzM0YTM", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-04-26T14:58:21Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-04-26T15:31:27Z"}, "message": "Windows: Make stdin pipes synchronous\n\nStdin pipes do not need to be used asynchronously within the standard library.", "tree": {"sha": "76b186dac9c0b78b22ef6fc20a8b56e01c424a24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76b186dac9c0b78b22ef6fc20a8b56e01c424a24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/949b978ec9d63b0eea23d89bad16c6f022ac34a3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmJoEFAACgkQcTRy8vRW\nJ95OLBAAt32D8pYsp+THnqovNNfnsL0SdLrlxL4xPAe7Jg9FB9yxdAcPN1VuLP1f\nrEM6zdPe8C+RpGZ/45DHOzXRRl4Tf7Y5rLE1lwHDHjQnj1MvAQZ1pxaad6Vl1f14\nJdDAF45eP7vy2T+6hg8sPzIf7GW2aU2f6cIZ/umhU+tvR+g7iK4FX+svbYnZu0JV\nOXfoYRWevFNJ946OMkvgCuQG9mBY5Id1ZUesD+0Lt5v7lh5fUYftZmm1Uj9dMeZV\nqDctWedhgVKBFJoriqUR7NqVlfM9jbC8VNXgSNCy1puOSln1lXOWT/8NYZygFtbV\npPltW7QR2vhpMr1tFI2UYukYlmjea+eEEUDw5FLszuDtxdY951RJB7r8JJgQLT7g\n4l6B1GITrpMcgxAXOXnvzYevX1LwNzKDpVm0CAk0XFrd2xsnlXHdKTewP4hyZEQM\n6gLmxmGR0lv6K8RDWgzehizeXPv1Tw1XzJpmtZivMhHZvHCnBKtUP3DRRNUF2Ztq\npOhV/QOjgv4bKvgeYK3vf89NE6582IbeB0NFWE+BGbk40U8sMFS7ZBXxWyCWP6yZ\nTx9v2YS4HJLiijScx5gNI3UFPmOGE7q8zNTZdw3BrGLQjoCAqy0cqO6R+wCdHfC3\noqhUSmUSQlyrV+U+CDFxaTTfBNlEuA1CbFxcGU6XNkYxPtW1D7Q=\n=/wOR\n-----END PGP SIGNATURE-----", "payload": "tree 76b186dac9c0b78b22ef6fc20a8b56e01c424a24\nparent b89b0567427932fe37851a314610d795258f1834\nauthor Chris Denton <christophersdenton@gmail.com> 1650985101 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1650987087 +0100\n\nWindows: Make stdin pipes synchronous\n\nStdin pipes do not need to be used asynchronously within the standard library.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/949b978ec9d63b0eea23d89bad16c6f022ac34a3", "html_url": "https://github.com/rust-lang/rust/commit/949b978ec9d63b0eea23d89bad16c6f022ac34a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/949b978ec9d63b0eea23d89bad16c6f022ac34a3/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b89b0567427932fe37851a314610d795258f1834", "url": "https://api.github.com/repos/rust-lang/rust/commits/b89b0567427932fe37851a314610d795258f1834", "html_url": "https://github.com/rust-lang/rust/commit/b89b0567427932fe37851a314610d795258f1834"}], "stats": {"total": 116, "additions": 85, "deletions": 31}, "files": [{"sha": "0692da1d795192d0e5358e7f2c5dc291293e7545", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949b978ec9d63b0eea23d89bad16c6f022ac34a3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949b978ec9d63b0eea23d89bad16c6f022ac34a3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=949b978ec9d63b0eea23d89bad16c6f022ac34a3", "patch": "@@ -1022,6 +1022,12 @@ extern \"system\" {\n         bWaitAll: BOOL,\n         dwMilliseconds: DWORD,\n     ) -> DWORD;\n+    pub fn CreatePipe(\n+        hReadPipe: *mut HANDLE,\n+        hWritePipe: *mut HANDLE,\n+        lpPipeAttributes: *const SECURITY_ATTRIBUTES,\n+        nSize: DWORD,\n+    ) -> BOOL;\n     pub fn CreateNamedPipeW(\n         lpName: LPCWSTR,\n         dwOpenMode: DWORD,"}, {"sha": "928bf2439c3e1e1ac6f99b90046dc0f31557a7d8", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 65, "deletions": 25, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/949b978ec9d63b0eea23d89bad16c6f022ac34a3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949b978ec9d63b0eea23d89bad16c6f022ac34a3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=949b978ec9d63b0eea23d89bad16c6f022ac34a3", "patch": "@@ -18,20 +18,56 @@ use crate::sys_common::IntoInner;\n // Anonymous pipes\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct AnonPipe {\n-    inner: Handle,\n+// A 64kb pipe capacity is the same as a typical Linux default.\n+const PIPE_BUFFER_CAPACITY: u32 = 64 * 1024;\n+\n+pub enum AnonPipe {\n+    Sync(Handle),\n+    Async(Handle),\n }\n \n impl IntoInner<Handle> for AnonPipe {\n     fn into_inner(self) -> Handle {\n-        self.inner\n+        match self {\n+            Self::Sync(handle) => handle,\n+            Self::Async(handle) => handle,\n+        }\n     }\n }\n \n pub struct Pipes {\n     pub ours: AnonPipe,\n     pub theirs: AnonPipe,\n }\n+impl Pipes {\n+    /// Create a new pair of pipes where both pipes are synchronous.\n+    ///\n+    /// These must not be used asynchronously.\n+    pub fn new_synchronous(\n+        ours_readable: bool,\n+        their_handle_inheritable: bool,\n+    ) -> io::Result<Self> {\n+        unsafe {\n+            // If `CreatePipe` succeeds, these will be our pipes.\n+            let mut read = ptr::null_mut();\n+            let mut write = ptr::null_mut();\n+\n+            if c::CreatePipe(&mut read, &mut write, ptr::null(), PIPE_BUFFER_CAPACITY) == 0 {\n+                Err(io::Error::last_os_error())\n+            } else {\n+                let (ours, theirs) = if ours_readable { (read, write) } else { (write, read) };\n+                let ours = Handle::from_raw_handle(ours);\n+                let theirs = Handle::from_raw_handle(theirs);\n+\n+                if their_handle_inheritable {\n+                    theirs.set_inheritable()?;\n+                }\n+\n+                Ok(Pipes { ours: AnonPipe::Sync(ours), theirs: AnonPipe::Sync(theirs) })\n+            }\n+        }\n+    }\n+}\n \n /// Although this looks similar to `anon_pipe` in the Unix module it's actually\n /// subtly different. Here we'll return two pipes in the `Pipes` return value,\n@@ -53,9 +89,6 @@ pub struct Pipes {\n /// with `OVERLAPPED` instances, but also works out ok if it's only ever used\n /// once at a time (which we do indeed guarantee).\n pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Result<Pipes> {\n-    // A 64kb pipe capacity is the same as a typical Linux default.\n-    const PIPE_BUFFER_CAPACITY: u32 = 64 * 1024;\n-\n     // Note that we specifically do *not* use `CreatePipe` here because\n     // unfortunately the anonymous pipes returned do not support overlapped\n     // operations. Instead, we create a \"hopefully unique\" name and create a\n@@ -156,12 +189,9 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n         };\n         opts.security_attributes(&mut sa);\n         let theirs = File::open(Path::new(&name), &opts)?;\n-        let theirs = AnonPipe { inner: theirs.into_inner() };\n+        let theirs = AnonPipe::Sync(theirs.into_inner());\n \n-        Ok(Pipes {\n-            ours: AnonPipe { inner: ours },\n-            theirs: AnonPipe { inner: theirs.into_inner() },\n-        })\n+        Ok(Pipes { ours: AnonPipe::Async(ours), theirs })\n     }\n }\n \n@@ -171,12 +201,12 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n /// This is achieved by creating a new set of pipes and spawning a thread that\n /// relays messages between the source and the synchronous pipe.\n pub fn spawn_pipe_relay(\n-    source: &AnonPipe,\n+    source: &Handle,\n     ours_readable: bool,\n     their_handle_inheritable: bool,\n ) -> io::Result<AnonPipe> {\n     // We need this handle to live for the lifetime of the thread spawned below.\n-    let source = source.duplicate()?;\n+    let source = AnonPipe::Async(source.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)?);\n \n     // create a new pair of anon pipes.\n     let Pipes { theirs, ours } = anon_pipe(ours_readable, their_handle_inheritable)?;\n@@ -227,19 +257,24 @@ type AlertableIoFn = unsafe extern \"system\" fn(\n \n impl AnonPipe {\n     pub fn handle(&self) -> &Handle {\n-        &self.inner\n+        match self {\n+            Self::Async(ref handle) => handle,\n+            Self::Sync(ref handle) => handle,\n+        }\n     }\n     pub fn into_handle(self) -> Handle {\n-        self.inner\n-    }\n-    fn duplicate(&self) -> io::Result<Self> {\n-        self.inner.duplicate(0, false, c::DUPLICATE_SAME_ACCESS).map(|inner| AnonPipe { inner })\n+        self.into_inner()\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let result = unsafe {\n             let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n-            self.alertable_io_internal(c::ReadFileEx, buf.as_mut_ptr() as _, len)\n+            match self {\n+                Self::Sync(ref handle) => handle.read(buf),\n+                Self::Async(_) => {\n+                    self.alertable_io_internal(c::ReadFileEx, buf.as_mut_ptr() as _, len)\n+                }\n+            }\n         };\n \n         match result {\n@@ -253,28 +288,33 @@ impl AnonPipe {\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.inner.read_vectored(bufs)\n+        io::default_read_vectored(|buf| self.read(buf), bufs)\n     }\n \n     #[inline]\n     pub fn is_read_vectored(&self) -> bool {\n-        self.inner.is_read_vectored()\n+        false\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         unsafe {\n             let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n-            self.alertable_io_internal(c::WriteFileEx, buf.as_ptr() as _, len)\n+            match self {\n+                Self::Sync(ref handle) => handle.write(buf),\n+                Self::Async(_) => {\n+                    self.alertable_io_internal(c::WriteFileEx, buf.as_ptr() as _, len)\n+                }\n+            }\n         }\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.inner.write_vectored(bufs)\n+        io::default_write_vectored(|buf| self.write(buf), bufs)\n     }\n \n     #[inline]\n     pub fn is_write_vectored(&self) -> bool {\n-        self.inner.is_write_vectored()\n+        false\n     }\n \n     /// Synchronizes asynchronous reads or writes using our anonymous pipe.\n@@ -346,7 +386,7 @@ impl AnonPipe {\n \n         // Asynchronous read of the pipe.\n         // If successful, `callback` will be called once it completes.\n-        let result = io(self.inner.as_handle(), buf, len, &mut overlapped, callback);\n+        let result = io(self.handle().as_handle(), buf, len, &mut overlapped, callback);\n         if result == c::FALSE {\n             // We can return here because the call failed.\n             // After this we must not return until the I/O completes."}, {"sha": "aff1b1c15ca73329db299109cd608c2ccd2a2a55", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/949b978ec9d63b0eea23d89bad16c6f022ac34a3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949b978ec9d63b0eea23d89bad16c6f022ac34a3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=949b978ec9d63b0eea23d89bad16c6f022ac34a3", "patch": "@@ -24,7 +24,7 @@ use crate::sys::cvt;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n use crate::sys::path;\n-use crate::sys::pipe::{self, AnonPipe};\n+use crate::sys::pipe::{self, AnonPipe, Pipes};\n use crate::sys::stdio;\n use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n@@ -173,7 +173,7 @@ pub enum Stdio {\n     Inherit,\n     Null,\n     MakePipe,\n-    Pipe(AnonPipe),\n+    AsyncPipe(Handle),\n     Handle(Handle),\n }\n \n@@ -527,13 +527,18 @@ impl Stdio {\n             },\n \n             Stdio::MakePipe => {\n-                let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n-                let pipes = pipe::anon_pipe(ours_readable, true)?;\n+                // If stdin then make synchronous\n+                let pipes = if stdio_id == c::STD_INPUT_HANDLE {\n+                    Pipes::new_synchronous(false, true)?\n+                } else {\n+                    pipe::anon_pipe(true, true)?\n+                };\n                 *pipe = Some(pipes.ours);\n                 Ok(pipes.theirs.into_handle())\n             }\n \n-            Stdio::Pipe(ref source) => {\n+            Stdio::AsyncPipe(ref source) => {\n+                // We need to synchronize asynchronous pipes by using a pipe relay.\n                 let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n                 pipe::spawn_pipe_relay(source, ours_readable, true).map(AnonPipe::into_handle)\n             }\n@@ -562,7 +567,10 @@ impl Stdio {\n \n impl From<AnonPipe> for Stdio {\n     fn from(pipe: AnonPipe) -> Stdio {\n-        Stdio::Pipe(pipe)\n+        match pipe {\n+            AnonPipe::Sync(handle) => Stdio::Handle(handle),\n+            AnonPipe::Async(handle) => Stdio::AsyncPipe(handle),\n+        }\n     }\n }\n "}]}