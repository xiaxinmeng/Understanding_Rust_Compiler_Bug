{"sha": "8e6d126b7d69281072f16dcc3cfff140e8947c58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNmQxMjZiN2Q2OTI4MTA3MmYxNmRjYzNjZmZmMTQwZTg5NDdjNTg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-25T15:05:10Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-29T21:44:09Z"}, "message": "rustc_target: `TyAndLayout::field` should never error.", "tree": {"sha": "293ebfbe26edb8e4baf22cec93eb517f2f1c6714", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/293ebfbe26edb8e4baf22cec93eb517f2f1c6714"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e6d126b7d69281072f16dcc3cfff140e8947c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6d126b7d69281072f16dcc3cfff140e8947c58", "html_url": "https://github.com/rust-lang/rust/commit/8e6d126b7d69281072f16dcc3cfff140e8947c58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e6d126b7d69281072f16dcc3cfff140e8947c58/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87d1fb747f8ed3dde3cd36c17d1ef735872a7bf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/87d1fb747f8ed3dde3cd36c17d1ef735872a7bf9", "html_url": "https://github.com/rust-lang/rust/commit/87d1fb747f8ed3dde3cd36c17d1ef735872a7bf9"}], "stats": {"total": 154, "additions": 77, "deletions": 77}, "files": [{"sha": "95216f1c3d7872fe2237fbc9cd77fe6d39309d09", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=8e6d126b7d69281072f16dcc3cfff140e8947c58", "patch": "@@ -160,12 +160,10 @@ impl<'tcx> DebugContext<'tcx> {\n \n                 for (field_idx, field_def) in variant.fields.iter().enumerate() {\n                     let field_offset = layout.fields.offset(field_idx);\n-                    let field_layout = layout\n-                        .field(\n-                            &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n-                            field_idx,\n-                        )\n-                        .unwrap();\n+                    let field_layout = layout.field(\n+                        &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n+                        field_idx,\n+                    );\n \n                     let field_type = self.dwarf_ty(field_layout.ty);\n "}, {"sha": "12f61e0c564aab39944b735e7d4f34057a8df842", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=8e6d126b7d69281072f16dcc3cfff140e8947c58", "patch": "@@ -789,7 +789,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true).unwrap() {\n+            if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true) {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n                     &format!(\"attempted to zero-initialize type `{}`, which is invalid\", T),\n@@ -798,7 +798,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false).unwrap() {\n+            if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false) {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n                     &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", T),"}, {"sha": "2a76ad0fb1356ebb1b244e19ba413444a1fcb6b5", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=8e6d126b7d69281072f16dcc3cfff140e8947c58", "patch": "@@ -472,10 +472,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let layout = bx.layout_of(ty);\n             let do_panic = match intrinsic {\n                 Inhabited => layout.abi.is_uninhabited(),\n-                // We unwrap as the error type is `!`.\n-                ZeroValid => !layout.might_permit_raw_init(bx, /*zero:*/ true).unwrap(),\n-                // We unwrap as the error type is `!`.\n-                UninitValid => !layout.might_permit_raw_init(bx, /*zero:*/ false).unwrap(),\n+                ZeroValid => !layout.might_permit_raw_init(bx, /*zero:*/ true),\n+                UninitValid => !layout.might_permit_raw_init(bx, /*zero:*/ false),\n             };\n             if do_panic {\n                 let msg_str = with_no_trimmed_paths(|| {"}, {"sha": "6822df0e50d6b7687742df2006e439dd6d9b0477", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=8e6d126b7d69281072f16dcc3cfff140e8947c58", "patch": "@@ -1788,22 +1788,18 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             let field_info: Vec<_> = flds\n                 .iter()\n                 .enumerate()\n-                .map(|(i, &name)| match layout.field(self, i) {\n-                    Err(err) => {\n-                        bug!(\"no layout found for field {}: `{:?}`\", name, err);\n+                .map(|(i, &name)| {\n+                    let field_layout = layout.field(self, i);\n+                    let offset = layout.fields.offset(i);\n+                    let field_end = offset + field_layout.size;\n+                    if min_size < field_end {\n+                        min_size = field_end;\n                     }\n-                    Ok(field_layout) => {\n-                        let offset = layout.fields.offset(i);\n-                        let field_end = offset + field_layout.size;\n-                        if min_size < field_end {\n-                            min_size = field_end;\n-                        }\n-                        FieldInfo {\n-                            name: name.to_string(),\n-                            offset: offset.bytes(),\n-                            size: field_layout.size.bytes(),\n-                            align: field_layout.align.abi.bytes(),\n-                        }\n+                    FieldInfo {\n+                        name: name.to_string(),\n+                        offset: offset.bytes(),\n+                        size: field_layout.size.bytes(),\n+                        align: field_layout.align.abi.bytes(),\n                     }\n                 })\n                 .collect();\n@@ -2146,30 +2142,24 @@ where\n         TyAndLayout { ty: this.ty, layout }\n     }\n \n-    fn ty_and_layout_field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> C::TyAndLayout {\n-        enum TyMaybeWithLayout<'tcx, C: LayoutOf<'tcx>> {\n-            Ty(C::Ty),\n-            TyAndLayout(C::TyAndLayout),\n+    fn ty_and_layout_field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> TyAndLayout<'tcx> {\n+        enum TyMaybeWithLayout<'tcx> {\n+            Ty(Ty<'tcx>),\n+            TyAndLayout(TyAndLayout<'tcx>),\n         }\n \n-        fn ty_and_layout_kind<\n-            C: LayoutOf<'tcx, Ty = Ty<'tcx>> + HasTyCtxt<'tcx> + HasParamEnv<'tcx>,\n-        >(\n+        fn field_ty_or_layout(\n             this: TyAndLayout<'tcx>,\n-            cx: &C,\n+            cx: &(impl HasTyCtxt<'tcx> + HasParamEnv<'tcx>),\n             i: usize,\n-            ty: C::Ty,\n-        ) -> TyMaybeWithLayout<'tcx, C> {\n+        ) -> TyMaybeWithLayout<'tcx> {\n             let tcx = cx.tcx();\n-            let tag_layout = |tag: &Scalar| -> C::TyAndLayout {\n+            let tag_layout = |tag: &Scalar| -> TyAndLayout<'tcx> {\n                 let layout = Layout::scalar(cx, tag.clone());\n-                MaybeResult::from(Ok(TyAndLayout {\n-                    layout: tcx.intern_layout(layout),\n-                    ty: tag.value.to_ty(tcx),\n-                }))\n+                TyAndLayout { layout: tcx.intern_layout(layout), ty: tag.value.to_ty(tcx) }\n             };\n \n-            match *ty.kind() {\n+            match *this.ty.kind() {\n                 ty::Bool\n                 | ty::Char\n                 | ty::Int(_)\n@@ -2180,7 +2170,7 @@ where\n                 | ty::FnDef(..)\n                 | ty::GeneratorWitness(..)\n                 | ty::Foreign(..)\n-                | ty::Dynamic(..) => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n+                | ty::Dynamic(..) => bug!(\"TyAndLayout::field({:?}): not applicable\", this),\n \n                 // Potentially-fat pointers.\n                 ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n@@ -2192,17 +2182,19 @@ where\n                     // as the `Abi` or `FieldsShape` is checked by users.\n                     if i == 0 {\n                         let nil = tcx.mk_unit();\n-                        let ptr_ty = if ty.is_unsafe_ptr() {\n+                        let unit_ptr_ty = if this.ty.is_unsafe_ptr() {\n                             tcx.mk_mut_ptr(nil)\n                         } else {\n                             tcx.mk_mut_ref(tcx.lifetimes.re_static, nil)\n                         };\n-                        return TyMaybeWithLayout::TyAndLayout(MaybeResult::from(\n-                            cx.layout_of(ptr_ty).to_result().map(|mut ptr_layout| {\n-                                ptr_layout.ty = ty;\n-                                ptr_layout\n-                            }),\n-                        ));\n+\n+                        // NOTE(eddyb) using an empty `ParamEnv`, and `unwrap`-ing\n+                        // the `Result` should always work because the type is\n+                        // always either `*mut ()` or `&'static mut ()`.\n+                        return TyMaybeWithLayout::TyAndLayout(TyAndLayout {\n+                            ty: this.ty,\n+                            ..tcx.layout_of(ty::ParamEnv::reveal_all().and(unit_ptr_ty)).unwrap()\n+                        });\n                     }\n \n                     match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind() {\n@@ -2226,7 +2218,7 @@ where\n                             ])\n                             */\n                         }\n-                        _ => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n+                        _ => bug!(\"TyAndLayout::field({:?}): not applicable\", this),\n                     }\n                 }\n \n@@ -2235,9 +2227,11 @@ where\n                 ty::Str => TyMaybeWithLayout::Ty(tcx.types.u8),\n \n                 // Tuples, generators and closures.\n-                ty::Closure(_, ref substs) => {\n-                    ty_and_layout_kind(this, cx, i, substs.as_closure().tupled_upvars_ty())\n-                }\n+                ty::Closure(_, ref substs) => field_ty_or_layout(\n+                    TyAndLayout { ty: substs.as_closure().tupled_upvars_ty(), ..this },\n+                    cx,\n+                    i,\n+                ),\n \n                 ty::Generator(def_id, ref substs, _) => match this.variants {\n                     Variants::Single { index } => TyMaybeWithLayout::Ty(\n@@ -2280,14 +2274,25 @@ where\n                 | ty::Opaque(..)\n                 | ty::Param(_)\n                 | ty::Infer(_)\n-                | ty::Error(_) => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n+                | ty::Error(_) => bug!(\"TyAndLayout::field: unexpected type `{}`\", this.ty),\n             }\n         }\n \n-        cx.layout_of(match ty_and_layout_kind(this, cx, i, this.ty) {\n-            TyMaybeWithLayout::Ty(result) => result,\n-            TyMaybeWithLayout::TyAndLayout(result) => return result,\n-        })\n+        match field_ty_or_layout(this, cx, i) {\n+            TyMaybeWithLayout::Ty(field_ty) => {\n+                cx.tcx().layout_of(cx.param_env().and(field_ty)).unwrap_or_else(|e| {\n+                    bug!(\n+                        \"failed to get layout for `{}`: {},\\n\\\n+                         despite it being a field (#{}) of an existing layout: {:#?}\",\n+                        field_ty,\n+                        e,\n+                        i,\n+                        this\n+                    )\n+                })\n+            }\n+            TyMaybeWithLayout::TyAndLayout(field_layout) => field_layout,\n+        }\n     }\n \n     fn ty_and_layout_pointee_info_at("}, {"sha": "6f18009cf47304c5d615f4cbe57e8e25df094e3d", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=8e6d126b7d69281072f16dcc3cfff140e8947c58", "patch": "@@ -340,7 +340,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n                 for i in 0..src.layout.fields.count() {\n-                    let cast_ty_field = cast_ty.field(self, i)?;\n+                    let cast_ty_field = cast_ty.field(self, i);\n                     if cast_ty_field.is_zst() {\n                         continue;\n                     }"}, {"sha": "bfb3de04c59fbd518ff4575faf71709a6b1ff7d1", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=8e6d126b7d69281072f16dcc3cfff140e8947c58", "patch": "@@ -592,7 +592,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Recurse to get the size of the dynamically sized field (must be\n                 // the last field).  Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n-                let field = layout.field(self, layout.fields.count() - 1)?;\n+                let field = layout.field(self, layout.fields.count() - 1);\n                 let (unsized_size, unsized_align) =\n                     match self.size_and_align_of(metadata, &field)? {\n                         Some(size_and_align) => size_and_align,\n@@ -645,7 +645,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             ty::Slice(_) | ty::Str => {\n                 let len = metadata.unwrap_meta().to_machine_usize(self)?;\n-                let elem = layout.field(self, 0)?;\n+                let elem = layout.field(self, 0);\n \n                 // Make sure the slice is not too big.\n                 let size = elem.size.checked_mul(len, self).ok_or_else(|| {"}, {"sha": "4afce2b6b80f2477f82b5eb46cb4011c0cf58523", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=8e6d126b7d69281072f16dcc3cfff140e8947c58", "patch": "@@ -364,7 +364,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Err(value) => value,\n         };\n \n-        let field_layout = op.layout.field(self, field)?;\n+        let field_layout = op.layout.field(self, field);\n         if field_layout.is_zst() {\n             let immediate = Scalar::ZST.into();\n             return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });"}, {"sha": "afad9716b3fe1ca712fcff8d2ca13a066072cdb6", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=8e6d126b7d69281072f16dcc3cfff140e8947c58", "patch": "@@ -355,7 +355,7 @@ where\n         field: usize,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let offset = base.layout.fields.offset(field);\n-        let field_layout = base.layout.field(self, field)?;\n+        let field_layout = base.layout.field(self, field);\n \n         // Offset may need adjustment for unsized fields.\n         let (meta, offset) = if field_layout.is_unsized() {\n@@ -405,7 +405,7 @@ where\n                 }\n                 let offset = stride * index; // `Size` multiplication\n                 // All fields have the same layout.\n-                let field_layout = base.layout.field(self, 0)?;\n+                let field_layout = base.layout.field(self, 0);\n \n                 assert!(!field_layout.is_unsized());\n                 base.offset(offset, MemPlaceMeta::None, field_layout, self)\n@@ -430,7 +430,7 @@ where\n             FieldsShape::Array { stride, .. } => stride,\n             _ => span_bug!(self.cur_span(), \"mplace_array_fields: expected an array layout\"),\n         };\n-        let layout = base.layout.field(self, 0)?;\n+        let layout = base.layout.field(self, 0);\n         let dl = &self.tcx.data_layout;\n         // `Size` multiplication\n         Ok((0..len).map(move |i| base.offset(stride * i, MemPlaceMeta::None, layout, dl)))"}, {"sha": "63496045e0d73cf69f826e823986a94a971eed8d", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=8e6d126b7d69281072f16dcc3cfff140e8947c58", "patch": "@@ -461,7 +461,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // a thin pointer.\n                 assert!(receiver_place.layout.is_unsized());\n                 let receiver_ptr_ty = self.tcx.mk_mut_ptr(receiver_place.layout.ty);\n-                let this_receiver_ptr = self.layout_of(receiver_ptr_ty)?.field(self, 0)?;\n+                let this_receiver_ptr = self.layout_of(receiver_ptr_ty)?.field(self, 0);\n                 // Adjust receiver argument.\n                 args[0] = OpTy::from(ImmTy::from_immediate(\n                     Scalar::from_maybe_pointer(receiver_place.ptr, self).into(),"}, {"sha": "19673ef32725380bd14a428f9855f5b7366be12c", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d126b7d69281072f16dcc3cfff140e8947c58/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=8e6d126b7d69281072f16dcc3cfff140e8947c58", "patch": "@@ -1244,7 +1244,7 @@ pub trait TyAbiInterface<'a, C: LayoutOf<'a, Ty = Self>>: Sized {\n         cx: &C,\n         variant_index: VariantIdx,\n     ) -> TyAndLayout<'a, Self>;\n-    fn ty_and_layout_field(this: TyAndLayout<'a, Self>, cx: &C, i: usize) -> C::TyAndLayout;\n+    fn ty_and_layout_field(this: TyAndLayout<'a, Self>, cx: &C, i: usize) -> TyAndLayout<'a, Self>;\n     fn ty_and_layout_pointee_info_at(\n         this: TyAndLayout<'a, Self>,\n         cx: &C,\n@@ -1261,7 +1261,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         Ty::ty_and_layout_for_variant(self, cx, variant_index)\n     }\n \n-    pub fn field<C>(self, cx: &C, i: usize) -> C::TyAndLayout\n+    pub fn field<C>(self, cx: &C, i: usize) -> Self\n     where\n         Ty: TyAbiInterface<'a, C>,\n         C: LayoutOf<'a, Ty = Ty>,\n@@ -1302,11 +1302,11 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     /// FIXME: Once we removed all the conservatism, we could alternatively\n     /// create an all-0/all-undef constant and run the const value validator to see if\n     /// this is a valid value for the given type.\n-    pub fn might_permit_raw_init<C, E>(self, cx: &C, zero: bool) -> Result<bool, E>\n+    pub fn might_permit_raw_init<C>(self, cx: &C, zero: bool) -> bool\n     where\n         Self: Copy,\n         Ty: TyAbiInterface<'a, C>,\n-        C: LayoutOf<'a, Ty = Ty, TyAndLayout: MaybeResult<Self, Error = E>> + HasDataLayout,\n+        C: LayoutOf<'a, Ty = Ty> + HasDataLayout,\n     {\n         let scalar_allows_raw_init = move |s: &Scalar| -> bool {\n             if zero {\n@@ -1331,7 +1331,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         };\n         if !valid {\n             // This is definitely not okay.\n-            return Ok(false);\n+            return false;\n         }\n \n         // If we have not found an error yet, we need to recursively descend into fields.\n@@ -1342,16 +1342,15 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n             }\n             FieldsShape::Arbitrary { offsets, .. } => {\n                 for idx in 0..offsets.len() {\n-                    let field = self.field(cx, idx).to_result()?;\n-                    if !field.might_permit_raw_init(cx, zero)? {\n+                    if !self.field(cx, idx).might_permit_raw_init(cx, zero) {\n                         // We found a field that is unhappy with this kind of initialization.\n-                        return Ok(false);\n+                        return false;\n                     }\n                 }\n             }\n         }\n \n         // FIXME(#66151): For now, we are conservative and do not check `self.variants`.\n-        Ok(true)\n+        true\n     }\n }"}]}