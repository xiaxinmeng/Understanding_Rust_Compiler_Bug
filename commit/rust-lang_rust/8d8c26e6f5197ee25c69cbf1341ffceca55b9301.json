{"sha": "8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkOGMyNmU2ZjUxOTdlZTI1YzY5Y2JmMTM0MWZmY2VjYTU1YjkzMDE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-07-17T14:40:13Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-07-17T15:13:35Z"}, "message": "internal: a bit more of cwd safety for flycheck", "tree": {"sha": "39f2170a054b7973255eb25944436b4af07688fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39f2170a054b7973255eb25944436b4af07688fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "html_url": "https://github.com/rust-lang/rust/commit/8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8df38aa7971a82061f5c22a64712f43ca2f2f9ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/8df38aa7971a82061f5c22a64712f43ca2f2f9ed", "html_url": "https://github.com/rust-lang/rust/commit/8df38aa7971a82061f5c22a64712f43ca2f2f9ed"}], "stats": {"total": 122, "additions": 71, "deletions": 51}, "files": [{"sha": "82c7c143ffa6f887dd47b69b7a90898ea94eebd6", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -381,6 +381,7 @@ dependencies = [\n  \"crossbeam-channel\",\n  \"jod-thread\",\n  \"log\",\n+ \"paths\",\n  \"serde\",\n  \"serde_json\",\n  \"stdx\",\n@@ -1131,6 +1132,7 @@ dependencies = [\n  \"mbe\",\n  \"memmap2\",\n  \"object\",\n+ \"paths\",\n  \"proc_macro_api\",\n  \"proc_macro_test\",\n  \"test_utils\","}, {"sha": "8e0ef8f6d6416a9113616a82da013022f4376e55", "filename": "crates/flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2FCargo.toml?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -18,3 +18,4 @@ jod-thread = \"0.1.1\"\n \n toolchain = { path = \"../toolchain\", version = \"0.0.0\" }\n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n+paths = { path = \"../paths\", version = \"0.0.0\" }"}, {"sha": "6a3b4a45a64ea89a66360c3ddc1936a09822b964", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -5,12 +5,12 @@\n use std::{\n     fmt,\n     io::{self, BufRead, BufReader},\n-    path::PathBuf,\n     process::{self, Command, Stdio},\n     time::Duration,\n };\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n+use paths::AbsPathBuf;\n use serde::Deserialize;\n use stdx::JodChild;\n \n@@ -63,7 +63,7 @@ impl FlycheckHandle {\n         id: usize,\n         sender: Box<dyn Fn(Message) + Send>,\n         config: FlycheckConfig,\n-        workspace_root: PathBuf,\n+        workspace_root: AbsPathBuf,\n     ) -> FlycheckHandle {\n         let actor = FlycheckActor::new(id, sender, config, workspace_root);\n         let (sender, receiver) = unbounded::<Restart>();\n@@ -82,7 +82,7 @@ impl FlycheckHandle {\n \n pub enum Message {\n     /// Request adding a diagnostic with fixes included to a file\n-    AddDiagnostic { workspace_root: PathBuf, diagnostic: Diagnostic },\n+    AddDiagnostic { workspace_root: AbsPathBuf, diagnostic: Diagnostic },\n \n     /// Request check progress notification to client\n     Progress {\n@@ -121,7 +121,7 @@ struct FlycheckActor {\n     id: usize,\n     sender: Box<dyn Fn(Message) + Send>,\n     config: FlycheckConfig,\n-    workspace_root: PathBuf,\n+    workspace_root: AbsPathBuf,\n     /// WatchThread exists to wrap around the communication needed to be able to\n     /// run `cargo check` without blocking. Currently the Rust standard library\n     /// doesn't provide a way to read sub-process output without blocking, so we\n@@ -140,7 +140,7 @@ impl FlycheckActor {\n         id: usize,\n         sender: Box<dyn Fn(Message) + Send>,\n         config: FlycheckConfig,\n-        workspace_root: PathBuf,\n+        workspace_root: AbsPathBuf,\n     ) -> FlycheckActor {\n         FlycheckActor { id, sender, config, workspace_root, cargo_handle: None }\n     }\n@@ -220,7 +220,7 @@ impl FlycheckActor {\n                 cmd.arg(command);\n                 cmd.current_dir(&self.workspace_root);\n                 cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n-                    .arg(self.workspace_root.join(\"Cargo.toml\"));\n+                    .arg(self.workspace_root.join(\"Cargo.toml\").as_os_str());\n \n                 if let Some(target) = target_triple {\n                     cmd.args(&[\"--target\", target.as_str()]);"}, {"sha": "f976783dea2995eb82f2532646bfbfaacd0ba7e1", "filename": "crates/paths/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fpaths%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fpaths%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fpaths%2Fsrc%2Flib.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -186,6 +186,9 @@ impl AbsPath {\n     pub fn starts_with(&self, base: &AbsPath) -> bool {\n         self.0.starts_with(&base.0)\n     }\n+    pub fn ends_with(&self, suffix: &RelPath) -> bool {\n+        self.0.starts_with(&suffix.0)\n+    }\n \n     // region:delegate-methods\n "}, {"sha": "d56136196e96b2e7313b64847714566fe8178f66", "filename": "crates/proc_macro_api/src/rpc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -271,7 +271,7 @@ mod tests {\n             macro_body: tt.clone(),\n             macro_name: Default::default(),\n             attributes: None,\n-            lib: Default::default(),\n+            lib: AbsPathBuf::assert(std::env::current_dir().unwrap()),\n             env: Default::default(),\n         };\n "}, {"sha": "df4680c6efa1a1fc0661425e068462c5fe360241", "filename": "crates/proc_macro_srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2FCargo.toml?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -15,6 +15,7 @@ memmap2 = \"0.3.0\"\n \n tt = { path = \"../tt\", version = \"0.0.0\" }\n mbe = { path = \"../mbe\", version = \"0.0.0\" }\n+paths = { path = \"../paths\", version = \"0.0.0\" }\n proc_macro_api = { path = \"../proc_macro_api\", version = \"0.0.0\" }\n \n [dev-dependencies]"}, {"sha": "ab13e66fb8156224809364724aeb06dfb6f62540", "filename": "crates/proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -1,6 +1,7 @@\n //! Handles dynamic library loading for proc macro\n \n use std::{\n+    convert::TryInto,\n     fmt,\n     fs::File,\n     io,\n@@ -10,6 +11,7 @@ use std::{\n use libloading::Library;\n use memmap2::Mmap;\n use object::Object;\n+use paths::AbsPath;\n use proc_macro_api::{read_dylib_info, ProcMacroKind};\n \n use super::abis::Abi;\n@@ -116,7 +118,10 @@ impl ProcMacroLibraryLibloading {\n             invalid_data_err(format!(\"Cannot find registrar symbol in file {}\", file.display()))\n         })?;\n \n-        let version_info = read_dylib_info(file)?;\n+        let abs_file: &AbsPath = file.try_into().map_err(|_| {\n+            invalid_data_err(format!(\"expected an absolute path, got {}\", file.display()))\n+        })?;\n+        let version_info = read_dylib_info(&abs_file)?;\n \n         let lib = load_library(file).map_err(invalid_data_err)?;\n         let abi = Abi::from_lib(&lib, symbol_name, version_info)?;\n@@ -136,7 +141,7 @@ impl Expander {\n \n         let lib = ensure_file_with_lock_free_access(&lib)?;\n \n-        let library = ProcMacroLibraryLibloading::open(&lib)?;\n+        let library = ProcMacroLibraryLibloading::open(lib.as_ref())?;\n \n         Ok(Expander { inner: library })\n     }"}, {"sha": "1c39455112c36f4ac9cb033b0d0b7e90c3ff4bed", "filename": "crates/proc_macro_srv/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -30,7 +30,7 @@ pub(crate) struct ProcMacroSrv {\n \n impl ProcMacroSrv {\n     pub fn expand(&mut self, task: &ExpansionTask) -> Result<ExpansionResult, String> {\n-        let expander = self.expander(&task.lib)?;\n+        let expander = self.expander(task.lib.as_ref())?;\n \n         let mut prev_env = HashMap::new();\n         for (k, v) in &task.env {\n@@ -54,7 +54,7 @@ impl ProcMacroSrv {\n     }\n \n     pub fn list_macros(&mut self, task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n-        let expander = self.expander(&task.lib)?;\n+        let expander = self.expander(task.lib.as_ref())?;\n         Ok(ListMacrosResult { macros: expander.list_macros() })\n     }\n "}, {"sha": "9356e6dcb012ac07ec78425aeb6a5799b89e4416", "filename": "crates/proc_macro_srv/src/tests/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Fmod.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -3,6 +3,7 @@\n #[macro_use]\n mod utils;\n use expect_test::expect;\n+use paths::AbsPathBuf;\n use utils::*;\n \n #[test]\n@@ -95,7 +96,7 @@ fn list_test_macros() {\n \n #[test]\n fn test_version_check() {\n-    let path = fixtures::proc_macro_test_dylib_path();\n+    let path = AbsPathBuf::assert(fixtures::proc_macro_test_dylib_path());\n     let info = proc_macro_api::read_dylib_info(&path).unwrap();\n     assert!(info.version.1 >= 50);\n }"}, {"sha": "d78e14a2dda5a2a311d8f33ac3c995ba28dfebd9", "filename": "crates/proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -3,6 +3,7 @@\n use crate::dylib;\n use crate::ProcMacroSrv;\n use expect_test::Expect;\n+use paths::AbsPathBuf;\n use proc_macro_api::ListMacrosTask;\n use std::str::FromStr;\n \n@@ -41,7 +42,7 @@ fn assert_expand_impl(macro_name: &str, input: &str, attr: Option<&str>, expect:\n }\n \n pub fn list() -> Vec<String> {\n-    let path = fixtures::proc_macro_test_dylib_path();\n+    let path = AbsPathBuf::assert(fixtures::proc_macro_test_dylib_path());\n     let task = ListMacrosTask { lib: path };\n     let mut srv = ProcMacroSrv::default();\n     let res = srv.list_macros(&task).unwrap();"}, {"sha": "b8f47f2b985ce145b70a90405f4cc8b3fc87ae54", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -28,7 +28,9 @@ pub(crate) fn load_workspace_at(\n     progress: &dyn Fn(String),\n ) -> Result<(AnalysisHost, vfs::Vfs, Option<ProcMacroClient>)> {\n     let root = AbsPathBuf::assert(std::env::current_dir()?.join(root));\n+    eprintln!(\"root = {:?}\", root);\n     let root = ProjectManifest::discover_single(&root)?;\n+    eprintln!(\"root = {:?}\", root);\n     let workspace = ProjectWorkspace::load(root, cargo_config, progress)?;\n \n     load_workspace(workspace, load_config, progress)\n@@ -48,7 +50,7 @@ fn load_workspace(\n     };\n \n     let proc_macro_client = if config.with_proc_macro {\n-        let path = std::env::current_exe()?;\n+        let path = AbsPathBuf::assert(std::env::current_exe()?);\n         Some(ProcMacroClient::extern_process(path, &[\"proc-macro\"]).unwrap())\n     } else {\n         None\n@@ -142,7 +144,7 @@ mod tests {\n     use hir::Crate;\n \n     #[test]\n-    fn test_loading_rust_analyzer() -> Result<()> {\n+    fn test_loading_rust_analyzer() {\n         let path = Path::new(env!(\"CARGO_MANIFEST_DIR\")).parent().unwrap().parent().unwrap();\n         let cargo_config = Default::default();\n         let load_cargo_config = LoadCargoConfig {\n@@ -152,12 +154,10 @@ mod tests {\n             prefill_caches: false,\n         };\n         let (host, _vfs, _proc_macro) =\n-            load_workspace_at(path, &cargo_config, &load_cargo_config, &|_| {})?;\n+            load_workspace_at(path, &cargo_config, &load_cargo_config, &|_| {}).unwrap();\n \n         let n_crates = Crate::all(host.raw_database()).len();\n         // RA has quite a few crates, but the exact count doesn't matter\n         assert!(n_crates > 20);\n-\n-        Ok(())\n     }\n }"}, {"sha": "7df60229648d36bb4a7057b969f4eaf01f7835d0", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -597,12 +597,14 @@ impl Config {\n     pub fn lru_capacity(&self) -> Option<usize> {\n         self.data.lruCapacity\n     }\n-    pub fn proc_macro_srv(&self) -> Option<(PathBuf, Vec<OsString>)> {\n+    pub fn proc_macro_srv(&self) -> Option<(AbsPathBuf, Vec<OsString>)> {\n         if !self.data.procMacro_enable {\n             return None;\n         }\n-\n-        let path = self.data.procMacro_server.clone().or_else(|| std::env::current_exe().ok())?;\n+        let path = match &self.data.procMacro_server {\n+            Some(it) => self.root_path.join(it),\n+            None => AbsPathBuf::assert(std::env::current_exe().ok()?),\n+        };\n         Some((path, vec![\"proc-macro\".into()]))\n     }\n     pub fn expand_proc_attr_macros(&self) -> bool {"}, {"sha": "d64909add38c9ea113472ebd2956753b6581f26d", "filename": "crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -1,12 +1,10 @@\n //! This module provides the functionality needed to convert diagnostics from\n //! `cargo check` json format to the LSP diagnostic format.\n-use std::{\n-    collections::HashMap,\n-    path::{Path, PathBuf},\n-};\n+use std::collections::HashMap;\n \n use flycheck::{DiagnosticLevel, DiagnosticSpan};\n use stdx::format_to;\n+use vfs::{AbsPath, AbsPathBuf};\n \n use crate::{lsp_ext, to_proto::url_from_abs_path};\n \n@@ -46,7 +44,7 @@ fn is_dummy_macro_file(file_name: &str) -> bool {\n /// Converts a Rust span to a LSP location\n fn location(\n     config: &DiagnosticsMapConfig,\n-    workspace_root: &Path,\n+    workspace_root: &AbsPath,\n     span: &DiagnosticSpan,\n ) -> lsp_types::Location {\n     let file_name = resolve_path(config, workspace_root, &span.file_name);\n@@ -67,7 +65,7 @@ fn location(\n /// workspace into account and tries to avoid those, in case macros are involved.\n fn primary_location(\n     config: &DiagnosticsMapConfig,\n-    workspace_root: &Path,\n+    workspace_root: &AbsPath,\n     span: &DiagnosticSpan,\n ) -> lsp_types::Location {\n     let span_stack = std::iter::successors(Some(span), |span| Some(&span.expansion.as_ref()?.span));\n@@ -88,7 +86,7 @@ fn primary_location(\n /// If the span is unlabelled this will return `None`.\n fn diagnostic_related_information(\n     config: &DiagnosticsMapConfig,\n-    workspace_root: &Path,\n+    workspace_root: &AbsPath,\n     span: &DiagnosticSpan,\n ) -> Option<lsp_types::DiagnosticRelatedInformation> {\n     let message = span.label.clone()?;\n@@ -98,7 +96,11 @@ fn diagnostic_related_information(\n \n /// Resolves paths applying any matching path prefix remappings, and then\n /// joining the path to the workspace root.\n-fn resolve_path(config: &DiagnosticsMapConfig, workspace_root: &Path, file_name: &str) -> PathBuf {\n+fn resolve_path(\n+    config: &DiagnosticsMapConfig,\n+    workspace_root: &AbsPath,\n+    file_name: &str,\n+) -> AbsPathBuf {\n     match config\n         .remap_prefix\n         .iter()\n@@ -121,7 +123,7 @@ enum MappedRustChildDiagnostic {\n \n fn map_rust_child_diagnostic(\n     config: &DiagnosticsMapConfig,\n-    workspace_root: &Path,\n+    workspace_root: &AbsPath,\n     rd: &flycheck::Diagnostic,\n ) -> MappedRustChildDiagnostic {\n     let spans: Vec<&DiagnosticSpan> = rd.spans.iter().filter(|s| s.is_primary).collect();\n@@ -191,7 +193,7 @@ pub(crate) struct MappedRustDiagnostic {\n pub(crate) fn map_rust_diagnostic_to_lsp(\n     config: &DiagnosticsMapConfig,\n     rd: &flycheck::Diagnostic,\n-    workspace_root: &Path,\n+    workspace_root: &AbsPath,\n ) -> Vec<MappedRustDiagnostic> {\n     let primary_spans: Vec<&DiagnosticSpan> = rd.spans.iter().filter(|s| s.is_primary).collect();\n     if primary_spans.is_empty() {\n@@ -426,6 +428,8 @@ fn clippy_code_description(code: Option<&str>) -> Option<lsp_types::CodeDescript\n #[cfg(test)]\n #[cfg(not(windows))]\n mod tests {\n+    use std::{convert::TryInto, path::Path};\n+\n     use super::*;\n \n     use expect_test::{expect_file, ExpectFile};\n@@ -436,7 +440,7 @@ mod tests {\n \n     fn check_with_config(config: DiagnosticsMapConfig, diagnostics_json: &str, expect: ExpectFile) {\n         let diagnostic: flycheck::Diagnostic = serde_json::from_str(diagnostics_json).unwrap();\n-        let workspace_root = Path::new(\"/test/\");\n+        let workspace_root: &AbsPath = Path::new(\"/test/\").try_into().unwrap();\n         let actual = map_rust_diagnostic_to_lsp(&config, &diagnostic, workspace_root);\n         expect.assert_debug_eq(&actual)\n     }"}, {"sha": "95751cae6db38116abb3d8b04ac9ef165b40057f", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -73,8 +73,9 @@ impl GlobalState {\n         fn is_interesting(path: &AbsPath, change_kind: ChangeKind) -> bool {\n             const IMPLICIT_TARGET_FILES: &[&str] = &[\"build.rs\", \"src/main.rs\", \"src/lib.rs\"];\n             const IMPLICIT_TARGET_DIRS: &[&str] = &[\"src/bin\", \"examples\", \"tests\", \"benches\"];\n+            let file_name = path.file_name().unwrap_or_default();\n \n-            if path.ends_with(\"Cargo.toml\") || path.ends_with(\"Cargo.lock\") {\n+            if file_name == \"Cargo.toml\" || file_name == \"Cargo.lock\" {\n                 return true;\n             }\n             if change_kind == ChangeKind::Modify {\n@@ -83,22 +84,22 @@ impl GlobalState {\n             if path.extension().unwrap_or_default() != \"rs\" {\n                 return false;\n             }\n-            if IMPLICIT_TARGET_FILES.iter().any(|it| path.ends_with(it)) {\n+            if IMPLICIT_TARGET_FILES.iter().any(|it| path.as_ref().ends_with(it)) {\n                 return true;\n             }\n             let parent = match path.parent() {\n                 Some(it) => it,\n                 None => return false,\n             };\n-            if IMPLICIT_TARGET_DIRS.iter().any(|it| parent.ends_with(it)) {\n+            if IMPLICIT_TARGET_DIRS.iter().any(|it| parent.as_ref().ends_with(it)) {\n                 return true;\n             }\n-            if path.ends_with(\"main.rs\") {\n+            if file_name == \"main.rs\" {\n                 let grand_parent = match parent.parent() {\n                     Some(it) => it,\n                     None => return false,\n                 };\n-                if IMPLICIT_TARGET_DIRS.iter().any(|it| grand_parent.ends_with(it)) {\n+                if IMPLICIT_TARGET_DIRS.iter().any(|it| grand_parent.as_ref().ends_with(it)) {\n                     return true;\n                 }\n             }"}, {"sha": "8bd3f7a9eb217db3e84390a3a6d11064a63b326d", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -1,7 +1,7 @@\n //! Conversion of rust-analyzer specific types to lsp_types equivalents.\n use std::{\n     iter::once,\n-    path::{self, Path},\n+    path,\n     sync::atomic::{AtomicU32, Ordering},\n };\n \n@@ -14,6 +14,7 @@ use ide::{\n };\n use itertools::Itertools;\n use serde_json::to_value;\n+use vfs::AbsPath;\n \n use crate::{\n     cargo_target_spec::CargoTargetSpec,\n@@ -622,10 +623,9 @@ pub(crate) fn url(snap: &GlobalStateSnapshot, file_id: FileId) -> lsp_types::Url\n /// This will only happen when processing windows paths.\n ///\n /// When processing non-windows path, this is essentially the same as `Url::from_file_path`.\n-pub(crate) fn url_from_abs_path(path: &Path) -> lsp_types::Url {\n-    assert!(path.is_absolute());\n+pub(crate) fn url_from_abs_path(path: &AbsPath) -> lsp_types::Url {\n     let url = lsp_types::Url::from_file_path(path).unwrap();\n-    match path.components().next() {\n+    match path.as_ref().components().next() {\n         Some(path::Component::Prefix(prefix))\n             if matches!(prefix.kind(), path::Prefix::Disk(_) | path::Prefix::VerbatimDisk(_)) =>\n         {\n@@ -1328,15 +1328,13 @@ fn main() {\n     // `Url` is not able to parse windows paths on unix machines.\n     #[test]\n     #[cfg(target_os = \"windows\")]\n-    fn test_lowercase_drive_letter_with_drive() {\n-        let url = url_from_abs_path(Path::new(\"C:\\\\Test\"));\n+    fn test_lowercase_drive_letter() {\n+        use std::{convert::TryInto, path::Path};\n+\n+        let url = url_from_abs_path(Path::new(\"C:\\\\Test\").try_into().unwrap());\n         assert_eq!(url.to_string(), \"file:///c:/Test\");\n-    }\n \n-    #[test]\n-    #[cfg(target_os = \"windows\")]\n-    fn test_drive_without_colon_passthrough() {\n-        let url = url_from_abs_path(Path::new(r#\"\\\\localhost\\C$\\my_dir\"#));\n+        let url = url_from_abs_path(Path::new(r#\"\\\\localhost\\C$\\my_dir\"#).try_into().unwrap());\n         assert_eq!(url.to_string(), \"file://localhost/C$/my_dir\");\n     }\n }"}, {"sha": "d330fba331d3ebdd1871aafd84188d45e508ea29", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8c26e6f5197ee25c69cbf1341ffceca55b9301/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=8d8c26e6f5197ee25c69cbf1341ffceca55b9301", "patch": "@@ -6,7 +6,7 @@\n //!\n //! Hopefully, one day a reliable file watching/walking crate appears on\n //! crates.io, and we can reduce this to trivial glue code.\n-use std::convert::TryFrom;\n+use std::{convert::TryFrom, fs};\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n use notify::{RecommendedWatcher, RecursiveMode, Watcher};\n@@ -123,7 +123,8 @@ impl NotifyActor {\n                             .into_iter()\n                             .map(|path| AbsPathBuf::try_from(path).unwrap())\n                             .filter_map(|path| {\n-                                if path.is_dir()\n+                                let meta = fs::metadata(&path).ok()?;\n+                                if meta.file_type().is_dir()\n                                     && self\n                                         .watched_entries\n                                         .iter()\n@@ -133,7 +134,7 @@ impl NotifyActor {\n                                     return None;\n                                 }\n \n-                                if !path.is_file() {\n+                                if !meta.file_type().is_file() {\n                                     return None;\n                                 }\n                                 if !self"}]}