{"sha": "ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a", "node_id": "C_kwDOAAsO6NoAKGVkZTVhYzI1MWNlNDE4OWU1ODBlNzU0YzRhOGJjMmE5ZDRiN2NiM2E", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-04T14:37:15Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-06-03T16:46:20Z"}, "message": "Remove json support from rustc_serialize", "tree": {"sha": "0ffbf3e4257c97bf19be81fd1c0b2eab27c3912d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ffbf3e4257c97bf19be81fd1c0b2eab27c3912d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a", "html_url": "https://github.com/rust-lang/rust/commit/ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15e0d8bdb1f81be314114e78e4ff507a97e8ce33", "url": "https://api.github.com/repos/rust-lang/rust/commits/15e0d8bdb1f81be314114e78e4ff507a97e8ce33", "html_url": "https://github.com/rust-lang/rust/commit/15e0d8bdb1f81be314114e78e4ff507a97e8ce33"}], "stats": {"total": 3495, "additions": 0, "deletions": 3495}, "files": [{"sha": "c915dd5bbf65c261dc7878409f94252e7e9b6482", "filename": "compiler/rustc_serialize/src/json.rs", "status": "removed", "additions": 0, "deletions": 2368, "changes": 2368, "blob_url": "https://github.com/rust-lang/rust/blob/15e0d8bdb1f81be314114e78e4ff507a97e8ce33/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e0d8bdb1f81be314114e78e4ff507a97e8ce33/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=15e0d8bdb1f81be314114e78e4ff507a97e8ce33", "patch": "@@ -1,2368 +0,0 @@\n-// Rust JSON serialization library.\n-// Copyright (c) 2011 Google Inc.\n-\n-#![forbid(non_camel_case_types)]\n-#![allow(missing_docs)]\n-\n-//! JSON parsing and serialization\n-//!\n-//! # What is JSON?\n-//!\n-//! JSON (JavaScript Object Notation) is a way to write data in Javascript.\n-//! Like XML, it allows to encode structured data in a text format that can be easily read by humans\n-//! Its simple syntax and native compatibility with JavaScript have made it a widely used format.\n-//!\n-//! Data types that can be encoded are JavaScript types (see the `Json` enum for more details):\n-//!\n-//! * `Boolean`: equivalent to rust's `bool`\n-//! * `Number`: equivalent to rust's `f64`\n-//! * `String`: equivalent to rust's `String`\n-//! * `Array`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the\n-//!   same array\n-//! * `Object`: equivalent to rust's `BTreeMap<String, json::Json>`\n-//! * `Null`\n-//!\n-//! An object is a series of string keys mapping to values, in `\"key\": value` format.\n-//! Arrays are enclosed in square brackets ([ ... ]) and objects in curly brackets ({ ... }).\n-//! A simple JSON document encoding a person, their age, address and phone numbers could look like\n-//!\n-//! ```json\n-//! {\n-//!     \"FirstName\": \"John\",\n-//!     \"LastName\": \"Doe\",\n-//!     \"Age\": 43,\n-//!     \"Address\": {\n-//!         \"Street\": \"Downing Street 10\",\n-//!         \"City\": \"London\",\n-//!         \"Country\": \"Great Britain\"\n-//!     },\n-//!     \"PhoneNumbers\": [\n-//!         \"+44 1234567\",\n-//!         \"+44 2345678\"\n-//!     ]\n-//! }\n-//! ```\n-//!\n-//! # Rust Type-based Encoding and Decoding\n-//!\n-//! To be able to encode a piece of data, it must implement the\n-//! `serialize::Encodable` trait.  The `rustc_macros` crate provides an\n-//! annotation to automatically generate the code for this trait: `#[derive(Encodable)]`.\n-//!\n-//! The JSON API provides an enum `json::Json` and a trait `ToJson` to encode objects.\n-//! The `ToJson` trait provides a `to_json` method to convert an object into a `json::Json` value.\n-//! A `json::Json` value can be encoded as a string or buffer using the functions described above.\n-//! You can also use the `json::Encoder` object, which implements the `Encoder` trait.\n-//!\n-//! When using `ToJson` the `Encodable` trait implementation is not mandatory.\n-//!\n-//! # Examples of use\n-//!\n-//! ## Using Autoserialization\n-//!\n-//! Create a struct called `TestStruct` and serialize and deserialize it to and from JSON using the\n-//! serialization API, using the derived serialization code.\n-//!\n-//! ```rust\n-//! # #![feature(rustc_private)]\n-//! use rustc_macros::{Encodable};\n-//! use rustc_serialize::json;\n-//!\n-//! // Automatically generate `Encodable` trait implementations\n-//! #[derive(Encodable)]\n-//! pub struct TestStruct  {\n-//!     data_int: u8,\n-//!     data_str: String,\n-//!     data_vector: Vec<u8>,\n-//! }\n-//!\n-//! let object = TestStruct {\n-//!     data_int: 1,\n-//!     data_str: \"homura\".to_string(),\n-//!     data_vector: vec![2,3,4,5],\n-//! };\n-//!\n-//! // Serialize using `json::encode`\n-//! let encoded = json::encode(&object).unwrap();\n-//! ```\n-//!\n-//! ## Using the `ToJson` trait\n-//!\n-//! The examples above use the `ToJson` trait to generate the JSON string, which is required\n-//! for custom mappings.\n-//!\n-//! ### Simple example of `ToJson` usage\n-//!\n-//! ```rust\n-//! # #![feature(rustc_private)]\n-//! use rustc_macros::Encodable;\n-//! use rustc_serialize::json::{self, ToJson, Json};\n-//!\n-//! // A custom data structure\n-//! struct ComplexNum {\n-//!     a: f64,\n-//!     b: f64,\n-//! }\n-//!\n-//! // JSON value representation\n-//! impl ToJson for ComplexNum {\n-//!     fn to_json(&self) -> Json {\n-//!         Json::String(format!(\"{}+{}i\", self.a, self.b))\n-//!     }\n-//! }\n-//!\n-//! // Only generate `Encodable` trait implementation\n-//! #[derive(Encodable)]\n-//! pub struct ComplexNumRecord {\n-//!     uid: u8,\n-//!     dsc: String,\n-//!     val: Json,\n-//! }\n-//!\n-//! let num = ComplexNum { a: 0.0001, b: 12.539 };\n-//! let data: String = json::encode(&ComplexNumRecord{\n-//!     uid: 1,\n-//!     dsc: \"test\".to_string(),\n-//!     val: num.to_json(),\n-//! }).unwrap();\n-//! println!(\"data: {}\", data);\n-//! // data: {\"uid\":1,\"dsc\":\"test\",\"val\":\"0.0001+12.539i\"};\n-//! ```\n-//!\n-//! ### Verbose example of `ToJson` usage\n-//!\n-//! ```rust\n-//! # #![feature(rustc_private)]\n-//! use std::collections::BTreeMap;\n-//! use rustc_serialize::json::{Json, ToJson};\n-//!\n-//! pub struct TestStruct {\n-//!     data_int: u8,\n-//!     data_str: String,\n-//!     data_vector: Vec<u8>,\n-//! }\n-//!\n-//! // Specify encoding method manually\n-//! impl ToJson for TestStruct {\n-//!     fn to_json(&self) -> Json {\n-//!         let mut d = BTreeMap::new();\n-//!         // All standard types implement `to_json()`, so use it\n-//!         d.insert(\"data_int\".to_string(), self.data_int.to_json());\n-//!         d.insert(\"data_str\".to_string(), self.data_str.to_json());\n-//!         d.insert(\"data_vector\".to_string(), self.data_vector.to_json());\n-//!         Json::Object(d)\n-//!     }\n-//! }\n-//!\n-//! // Serialize using `ToJson`\n-//! let input_data = TestStruct {\n-//!     data_int: 1,\n-//!     data_str: \"madoka\".to_string(),\n-//!     data_vector: vec![2,3,4,5],\n-//! };\n-//! let json_obj: Json = input_data.to_json();\n-//! let json_str: String = json_obj.to_string();\n-//! ```\n-\n-use self::ErrorCode::*;\n-use self::InternalStackElement::*;\n-use self::JsonEvent::*;\n-use self::ParserError::*;\n-use self::ParserState::*;\n-\n-use std::borrow::Cow;\n-use std::collections::{BTreeMap, HashMap};\n-use std::mem::swap;\n-use std::num::FpCategory as Fp;\n-use std::ops::Index;\n-use std::str::FromStr;\n-use std::string;\n-use std::{char, fmt, str};\n-\n-use crate::Encodable;\n-\n-/// Represents a json value\n-#[derive(Clone, PartialEq, PartialOrd, Debug)]\n-pub enum Json {\n-    I64(i64),\n-    U64(u64),\n-    F64(f64),\n-    String(string::String),\n-    Boolean(bool),\n-    Array(self::Array),\n-    Object(self::Object),\n-    Null,\n-}\n-\n-pub type Array = Vec<Json>;\n-pub type Object = BTreeMap<string::String, Json>;\n-\n-pub struct PrettyJson<'a> {\n-    inner: &'a Json,\n-}\n-\n-pub struct AsJson<'a, T> {\n-    inner: &'a T,\n-}\n-pub struct AsPrettyJson<'a, T> {\n-    inner: &'a T,\n-    indent: Option<usize>,\n-}\n-\n-/// The errors that can arise while parsing a JSON stream.\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-pub enum ErrorCode {\n-    InvalidSyntax,\n-    InvalidNumber,\n-    EOFWhileParsingObject,\n-    EOFWhileParsingArray,\n-    EOFWhileParsingValue,\n-    EOFWhileParsingString,\n-    KeyMustBeAString,\n-    ExpectedColon,\n-    TrailingCharacters,\n-    TrailingComma,\n-    InvalidEscape,\n-    InvalidUnicodeCodePoint,\n-    LoneLeadingSurrogateInHexEscape,\n-    UnexpectedEndOfHexEscape,\n-    UnrecognizedHex,\n-    NotFourDigit,\n-    NotUtf8,\n-}\n-\n-#[derive(Clone, PartialEq, Debug)]\n-pub enum ParserError {\n-    /// msg, line, col\n-    SyntaxError(ErrorCode, usize, usize),\n-}\n-\n-// Builder and Parser have the same errors.\n-pub type BuilderError = ParserError;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum EncoderError {\n-    FmtError(fmt::Error),\n-    BadHashmapKey,\n-}\n-\n-/// Returns a readable error string for a given error code.\n-pub fn error_str(error: ErrorCode) -> &'static str {\n-    match error {\n-        InvalidSyntax => \"invalid syntax\",\n-        InvalidNumber => \"invalid number\",\n-        EOFWhileParsingObject => \"EOF While parsing object\",\n-        EOFWhileParsingArray => \"EOF While parsing array\",\n-        EOFWhileParsingValue => \"EOF While parsing value\",\n-        EOFWhileParsingString => \"EOF While parsing string\",\n-        KeyMustBeAString => \"key must be a string\",\n-        ExpectedColon => \"expected `:`\",\n-        TrailingCharacters => \"trailing characters\",\n-        TrailingComma => \"trailing comma\",\n-        InvalidEscape => \"invalid escape\",\n-        UnrecognizedHex => \"invalid \\\\u{ esc}ape (unrecognized hex)\",\n-        NotFourDigit => \"invalid \\\\u{ esc}ape (not four digits)\",\n-        NotUtf8 => \"contents not utf-8\",\n-        InvalidUnicodeCodePoint => \"invalid Unicode code point\",\n-        LoneLeadingSurrogateInHexEscape => \"lone leading surrogate in hex escape\",\n-        UnexpectedEndOfHexEscape => \"unexpected end of hex escape\",\n-    }\n-}\n-\n-/// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<T: for<'r> crate::Encodable<Encoder<'r>>>(\n-    object: &T,\n-) -> Result<string::String, EncoderError> {\n-    let mut s = String::new();\n-    {\n-        let mut encoder = Encoder::new(&mut s);\n-        object.encode(&mut encoder)?;\n-    }\n-    Ok(s)\n-}\n-\n-impl fmt::Display for ErrorCode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        error_str(*self).fmt(f)\n-    }\n-}\n-\n-impl fmt::Display for ParserError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // FIXME this should be a nicer error\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for EncoderError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // FIXME this should be a nicer error\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n-\n-impl std::error::Error for EncoderError {}\n-\n-impl From<fmt::Error> for EncoderError {\n-    /// Converts a [`fmt::Error`] into `EncoderError`\n-    ///\n-    /// This conversion does not allocate memory.\n-    fn from(err: fmt::Error) -> EncoderError {\n-        EncoderError::FmtError(err)\n-    }\n-}\n-\n-pub type EncodeResult = Result<(), EncoderError>;\n-\n-fn escape_str(wr: &mut dyn fmt::Write, v: &str) -> EncodeResult {\n-    wr.write_str(\"\\\"\")?;\n-\n-    let mut start = 0;\n-\n-    for (i, byte) in v.bytes().enumerate() {\n-        let escaped = match byte {\n-            b'\"' => \"\\\\\\\"\",\n-            b'\\\\' => \"\\\\\\\\\",\n-            b'\\x00' => \"\\\\u0000\",\n-            b'\\x01' => \"\\\\u0001\",\n-            b'\\x02' => \"\\\\u0002\",\n-            b'\\x03' => \"\\\\u0003\",\n-            b'\\x04' => \"\\\\u0004\",\n-            b'\\x05' => \"\\\\u0005\",\n-            b'\\x06' => \"\\\\u0006\",\n-            b'\\x07' => \"\\\\u0007\",\n-            b'\\x08' => \"\\\\b\",\n-            b'\\t' => \"\\\\t\",\n-            b'\\n' => \"\\\\n\",\n-            b'\\x0b' => \"\\\\u000b\",\n-            b'\\x0c' => \"\\\\f\",\n-            b'\\r' => \"\\\\r\",\n-            b'\\x0e' => \"\\\\u000e\",\n-            b'\\x0f' => \"\\\\u000f\",\n-            b'\\x10' => \"\\\\u0010\",\n-            b'\\x11' => \"\\\\u0011\",\n-            b'\\x12' => \"\\\\u0012\",\n-            b'\\x13' => \"\\\\u0013\",\n-            b'\\x14' => \"\\\\u0014\",\n-            b'\\x15' => \"\\\\u0015\",\n-            b'\\x16' => \"\\\\u0016\",\n-            b'\\x17' => \"\\\\u0017\",\n-            b'\\x18' => \"\\\\u0018\",\n-            b'\\x19' => \"\\\\u0019\",\n-            b'\\x1a' => \"\\\\u001a\",\n-            b'\\x1b' => \"\\\\u001b\",\n-            b'\\x1c' => \"\\\\u001c\",\n-            b'\\x1d' => \"\\\\u001d\",\n-            b'\\x1e' => \"\\\\u001e\",\n-            b'\\x1f' => \"\\\\u001f\",\n-            b'\\x7f' => \"\\\\u007f\",\n-            _ => {\n-                continue;\n-            }\n-        };\n-\n-        if start < i {\n-            wr.write_str(&v[start..i])?;\n-        }\n-\n-        wr.write_str(escaped)?;\n-\n-        start = i + 1;\n-    }\n-\n-    if start != v.len() {\n-        wr.write_str(&v[start..])?;\n-    }\n-\n-    wr.write_str(\"\\\"\")?;\n-    Ok(())\n-}\n-\n-fn escape_char(writer: &mut dyn fmt::Write, v: char) -> EncodeResult {\n-    escape_str(writer, v.encode_utf8(&mut [0; 4]))\n-}\n-\n-fn spaces(wr: &mut dyn fmt::Write, mut n: usize) -> EncodeResult {\n-    const BUF: &str = \"                \";\n-\n-    while n >= BUF.len() {\n-        wr.write_str(BUF)?;\n-        n -= BUF.len();\n-    }\n-\n-    if n > 0 {\n-        wr.write_str(&BUF[..n])?;\n-    }\n-    Ok(())\n-}\n-\n-fn fmt_number_or_null(v: f64) -> string::String {\n-    match v.classify() {\n-        Fp::Nan | Fp::Infinite => string::String::from(\"null\"),\n-        _ if v.fract() != 0f64 => v.to_string(),\n-        _ => v.to_string() + \".0\",\n-    }\n-}\n-\n-/// A structure for implementing serialization to JSON.\n-pub struct Encoder<'a> {\n-    writer: &'a mut (dyn fmt::Write + 'a),\n-    is_emitting_map_key: bool,\n-}\n-\n-impl<'a> Encoder<'a> {\n-    /// Creates a new JSON encoder whose output will be written to the writer\n-    /// specified.\n-    pub fn new(writer: &'a mut dyn fmt::Write) -> Encoder<'a> {\n-        Encoder { writer, is_emitting_map_key: false }\n-    }\n-}\n-\n-macro_rules! emit_enquoted_if_mapkey {\n-    ($enc:ident,$e:expr) => {{\n-        if $enc.is_emitting_map_key {\n-            write!($enc.writer, \"\\\"{}\\\"\", $e)?;\n-        } else {\n-            write!($enc.writer, \"{}\", $e)?;\n-        }\n-        Ok(())\n-    }};\n-}\n-\n-impl<'a> crate::Encoder for Encoder<'a> {\n-    type Error = EncoderError;\n-\n-    fn emit_unit(&mut self) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \"null\")?;\n-        Ok(())\n-    }\n-\n-    fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u128(&mut self, v: u128) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-\n-    fn emit_isize(&mut self, v: isize) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i128(&mut self, v: i128) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-\n-    fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if v {\n-            write!(self.writer, \"true\")?;\n-        } else {\n-            write!(self.writer, \"false\")?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, fmt_number_or_null(v))\n-    }\n-    fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-        self.emit_f64(f64::from(v))\n-    }\n-\n-    fn emit_char(&mut self, v: char) -> EncodeResult {\n-        escape_char(self.writer, v)\n-    }\n-    fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        escape_str(self.writer, v)\n-    }\n-    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error> {\n-        for &c in s.iter() {\n-            self.emit_u8(c)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_enum<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant<F>(&mut self, name: &str, _id: usize, cnt: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        // enums are encoded as strings or objects\n-        // Bunny => \"Bunny\"\n-        // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n-        if cnt == 0 {\n-            escape_str(self.writer, name)\n-        } else {\n-            if self.is_emitting_map_key {\n-                return Err(EncoderError::BadHashmapKey);\n-            }\n-            write!(self.writer, \"{{\\\"variant\\\":\")?;\n-            escape_str(self.writer, name)?;\n-            write!(self.writer, \",\\\"fields\\\":[\")?;\n-            f(self)?;\n-            write!(self.writer, \"]}}\")?;\n-            Ok(())\n-        }\n-    }\n-\n-    fn emit_fieldless_enum_variant<const ID: usize>(\n-        &mut self,\n-        name: &str,\n-    ) -> Result<(), Self::Error> {\n-        escape_str(self.writer, name)\n-    }\n-\n-    fn emit_enum_variant_arg<F>(&mut self, first: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if !first {\n-            write!(self.writer, \",\")?;\n-        }\n-        f(self)\n-    }\n-\n-    fn emit_struct<F>(&mut self, _: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \"{{\")?;\n-        f(self)?;\n-        write!(self.writer, \"}}\")?;\n-        Ok(())\n-    }\n-\n-    fn emit_struct_field<F>(&mut self, name: &str, first: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if !first {\n-            write!(self.writer, \",\")?;\n-        }\n-        escape_str(self.writer, name)?;\n-        write!(self.writer, \":\")?;\n-        f(self)\n-    }\n-\n-    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        f(self)\n-    }\n-    fn emit_option_none(&mut self) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_unit()\n-    }\n-    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        f(self)\n-    }\n-\n-    fn emit_seq<F>(&mut self, _len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \"[\")?;\n-        f(self)?;\n-        write!(self.writer, \"]\")?;\n-        Ok(())\n-    }\n-\n-    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if idx != 0 {\n-            write!(self.writer, \",\")?;\n-        }\n-        f(self)\n-    }\n-\n-    fn emit_map<F>(&mut self, _len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \"{{\")?;\n-        f(self)?;\n-        write!(self.writer, \"}}\")?;\n-        Ok(())\n-    }\n-\n-    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if idx != 0 {\n-            write!(self.writer, \",\")?\n-        }\n-        self.is_emitting_map_key = true;\n-        f(self)?;\n-        self.is_emitting_map_key = false;\n-        Ok(())\n-    }\n-\n-    fn emit_map_elt_val<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \":\")?;\n-        f(self)\n-    }\n-}\n-\n-/// Another encoder for JSON, but prints out human-readable JSON instead of\n-/// compact data\n-pub struct PrettyEncoder<'a> {\n-    writer: &'a mut (dyn fmt::Write + 'a),\n-    curr_indent: usize,\n-    indent: usize,\n-    is_emitting_map_key: bool,\n-}\n-\n-impl<'a> PrettyEncoder<'a> {\n-    /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn new(writer: &'a mut dyn fmt::Write) -> PrettyEncoder<'a> {\n-        PrettyEncoder { writer, curr_indent: 0, indent: 2, is_emitting_map_key: false }\n-    }\n-\n-    /// Sets the number of spaces to indent for each level.\n-    /// This is safe to set during encoding.\n-    pub fn set_indent(&mut self, indent: usize) {\n-        // self.indent very well could be 0 so we need to use checked division.\n-        let level = self.curr_indent.checked_div(self.indent).unwrap_or(0);\n-        self.indent = indent;\n-        self.curr_indent = level * self.indent;\n-    }\n-}\n-\n-impl<'a> crate::Encoder for PrettyEncoder<'a> {\n-    type Error = EncoderError;\n-\n-    fn emit_unit(&mut self) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \"null\")?;\n-        Ok(())\n-    }\n-\n-    fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u128(&mut self, v: u128) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-\n-    fn emit_isize(&mut self, v: isize) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i128(&mut self, v: i128) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, v)\n-    }\n-\n-    fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if v {\n-            write!(self.writer, \"true\")?;\n-        } else {\n-            write!(self.writer, \"false\")?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-        emit_enquoted_if_mapkey!(self, fmt_number_or_null(v))\n-    }\n-    fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-        self.emit_f64(f64::from(v))\n-    }\n-\n-    fn emit_char(&mut self, v: char) -> EncodeResult {\n-        escape_char(self.writer, v)\n-    }\n-    fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        escape_str(self.writer, v)\n-    }\n-    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error> {\n-        for &c in s.iter() {\n-            self.emit_u8(c)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_enum<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant<F>(&mut self, name: &str, _id: usize, cnt: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if cnt == 0 {\n-            escape_str(self.writer, name)\n-        } else {\n-            if self.is_emitting_map_key {\n-                return Err(EncoderError::BadHashmapKey);\n-            }\n-            writeln!(self.writer, \"{{\")?;\n-            self.curr_indent += self.indent;\n-            spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"\\\"variant\\\": \")?;\n-            escape_str(self.writer, name)?;\n-            writeln!(self.writer, \",\")?;\n-            spaces(self.writer, self.curr_indent)?;\n-            writeln!(self.writer, \"\\\"fields\\\": [\")?;\n-            self.curr_indent += self.indent;\n-            f(self)?;\n-            self.curr_indent -= self.indent;\n-            writeln!(self.writer)?;\n-            spaces(self.writer, self.curr_indent)?;\n-            self.curr_indent -= self.indent;\n-            writeln!(self.writer, \"]\")?;\n-            spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"}}\")?;\n-            Ok(())\n-        }\n-    }\n-\n-    fn emit_fieldless_enum_variant<const ID: usize>(\n-        &mut self,\n-        name: &str,\n-    ) -> Result<(), Self::Error> {\n-        escape_str(self.writer, name)\n-    }\n-\n-    fn emit_enum_variant_arg<F>(&mut self, first: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if !first {\n-            writeln!(self.writer, \",\")?;\n-        }\n-        spaces(self.writer, self.curr_indent)?;\n-        f(self)\n-    }\n-\n-    fn emit_struct<F>(&mut self, no_fields: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if no_fields {\n-            write!(self.writer, \"{{}}\")?;\n-        } else {\n-            write!(self.writer, \"{{\")?;\n-            self.curr_indent += self.indent;\n-            f(self)?;\n-            self.curr_indent -= self.indent;\n-            writeln!(self.writer)?;\n-            spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"}}\")?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_struct_field<F>(&mut self, name: &str, first: bool, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if first {\n-            writeln!(self.writer)?;\n-        } else {\n-            writeln!(self.writer, \",\")?;\n-        }\n-        spaces(self.writer, self.curr_indent)?;\n-        escape_str(self.writer, name)?;\n-        write!(self.writer, \": \")?;\n-        f(self)\n-    }\n-\n-    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        f(self)\n-    }\n-    fn emit_option_none(&mut self) -> EncodeResult {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_unit()\n-    }\n-    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        f(self)\n-    }\n-\n-    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if len == 0 {\n-            write!(self.writer, \"[]\")?;\n-        } else {\n-            write!(self.writer, \"[\")?;\n-            self.curr_indent += self.indent;\n-            f(self)?;\n-            self.curr_indent -= self.indent;\n-            writeln!(self.writer)?;\n-            spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"]\")?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if idx == 0 {\n-            writeln!(self.writer)?;\n-        } else {\n-            writeln!(self.writer, \",\")?;\n-        }\n-        spaces(self.writer, self.curr_indent)?;\n-        f(self)\n-    }\n-\n-    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if len == 0 {\n-            write!(self.writer, \"{{}}\")?;\n-        } else {\n-            write!(self.writer, \"{{\")?;\n-            self.curr_indent += self.indent;\n-            f(self)?;\n-            self.curr_indent -= self.indent;\n-            writeln!(self.writer)?;\n-            spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"}}\")?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if idx == 0 {\n-            writeln!(self.writer)?;\n-        } else {\n-            writeln!(self.writer, \",\")?;\n-        }\n-        spaces(self.writer, self.curr_indent)?;\n-        self.is_emitting_map_key = true;\n-        f(self)?;\n-        self.is_emitting_map_key = false;\n-        Ok(())\n-    }\n-\n-    fn emit_map_elt_val<F>(&mut self, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        write!(self.writer, \": \")?;\n-        f(self)\n-    }\n-}\n-\n-impl<E: crate::Encoder> Encodable<E> for Json {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        match *self {\n-            Json::I64(v) => v.encode(e),\n-            Json::U64(v) => v.encode(e),\n-            Json::F64(v) => v.encode(e),\n-            Json::String(ref v) => v.encode(e),\n-            Json::Boolean(v) => v.encode(e),\n-            Json::Array(ref v) => v.encode(e),\n-            Json::Object(ref v) => v.encode(e),\n-            Json::Null => e.emit_unit(),\n-        }\n-    }\n-}\n-\n-/// Creates an `AsJson` wrapper which can be used to print a value as JSON\n-/// on-the-fly via `write!`\n-pub fn as_json<T>(t: &T) -> AsJson<'_, T> {\n-    AsJson { inner: t }\n-}\n-\n-/// Creates an `AsPrettyJson` wrapper which can be used to print a value as JSON\n-/// on-the-fly via `write!`\n-pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<'_, T> {\n-    AsPrettyJson { inner: t, indent: None }\n-}\n-\n-impl Json {\n-    /// Borrow this json object as a pretty object to generate a pretty\n-    /// representation for it via `Display`.\n-    pub fn pretty(&self) -> PrettyJson<'_> {\n-        PrettyJson { inner: self }\n-    }\n-\n-    /// If the Json value is an Object, returns the value associated with the provided key.\n-    /// Otherwise, returns None.\n-    pub fn find(&self, key: &str) -> Option<&Json> {\n-        match *self {\n-            Json::Object(ref map) => map.get(key),\n-            _ => None,\n-        }\n-    }\n-\n-    /// If the Json value is an Object, deletes the value associated with the\n-    /// provided key from the Object and returns it. Otherwise, returns None.\n-    pub fn remove_key(&mut self, key: &str) -> Option<Json> {\n-        match *self {\n-            Json::Object(ref mut map) => map.remove(key),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Attempts to get a nested Json Object for each key in `keys`.\n-    /// If any key is found not to exist, `find_path` will return `None`.\n-    /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&str]) -> Option<&'a Json> {\n-        let mut target = self;\n-        for key in keys {\n-            target = target.find(*key)?;\n-        }\n-        Some(target)\n-    }\n-\n-    /// If the Json value is an Object, performs a depth-first search until\n-    /// a value associated with the provided key is found. If no value is found\n-    /// or the Json value is not an Object, returns `None`.\n-    pub fn search(&self, key: &str) -> Option<&Json> {\n-        match *self {\n-            Json::Object(ref map) => match map.get(key) {\n-                Some(json_value) => Some(json_value),\n-                None => {\n-                    for v in map.values() {\n-                        match v.search(key) {\n-                            x if x.is_some() => return x,\n-                            _ => (),\n-                        }\n-                    }\n-                    None\n-                }\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is an `Object`.\n-    pub fn is_object(&self) -> bool {\n-        self.as_object().is_some()\n-    }\n-\n-    /// If the Json value is an `Object`, returns the associated `BTreeMap`;\n-    /// returns `None` otherwise.\n-    pub fn as_object(&self) -> Option<&Object> {\n-        match *self {\n-            Json::Object(ref map) => Some(map),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is an `Array`.\n-    pub fn is_array(&self) -> bool {\n-        self.as_array().is_some()\n-    }\n-\n-    /// If the Json value is an `Array`, returns the associated vector;\n-    /// returns `None` otherwise.\n-    pub fn as_array(&self) -> Option<&Array> {\n-        match *self {\n-            Json::Array(ref array) => Some(&*array),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is a `String`.\n-    pub fn is_string(&self) -> bool {\n-        self.as_string().is_some()\n-    }\n-\n-    /// If the Json value is a `String`, returns the associated `str`;\n-    /// returns `None` otherwise.\n-    pub fn as_string(&self) -> Option<&str> {\n-        match *self {\n-            Json::String(ref s) => Some(&s[..]),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is a `Number`.\n-    pub fn is_number(&self) -> bool {\n-        matches!(*self, Json::I64(_) | Json::U64(_) | Json::F64(_))\n-    }\n-\n-    /// Returns `true` if the Json value is an `i64`.\n-    pub fn is_i64(&self) -> bool {\n-        matches!(*self, Json::I64(_))\n-    }\n-\n-    /// Returns `true` if the Json value is a `u64`.\n-    pub fn is_u64(&self) -> bool {\n-        matches!(*self, Json::U64(_))\n-    }\n-\n-    /// Returns `true` if the Json value is a `f64`.\n-    pub fn is_f64(&self) -> bool {\n-        matches!(*self, Json::F64(_))\n-    }\n-\n-    /// If the Json value is a number, returns or cast it to an `i64`;\n-    /// returns `None` otherwise.\n-    pub fn as_i64(&self) -> Option<i64> {\n-        match *self {\n-            Json::I64(n) => Some(n),\n-            Json::U64(n) => Some(n as i64),\n-            _ => None,\n-        }\n-    }\n-\n-    /// If the Json value is a number, returns or cast it to a `u64`;\n-    /// returns `None` otherwise.\n-    pub fn as_u64(&self) -> Option<u64> {\n-        match *self {\n-            Json::I64(n) => Some(n as u64),\n-            Json::U64(n) => Some(n),\n-            _ => None,\n-        }\n-    }\n-\n-    /// If the Json value is a number, returns or cast it to a `f64`;\n-    /// returns `None` otherwise.\n-    pub fn as_f64(&self) -> Option<f64> {\n-        match *self {\n-            Json::I64(n) => Some(n as f64),\n-            Json::U64(n) => Some(n as f64),\n-            Json::F64(n) => Some(n),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is a `Boolean`.\n-    pub fn is_boolean(&self) -> bool {\n-        self.as_boolean().is_some()\n-    }\n-\n-    /// If the Json value is a `Boolean`, returns the associated `bool`;\n-    /// returns `None` otherwise.\n-    pub fn as_boolean(&self) -> Option<bool> {\n-        match *self {\n-            Json::Boolean(b) => Some(b),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the Json value is a `Null`.\n-    pub fn is_null(&self) -> bool {\n-        self.as_null().is_some()\n-    }\n-\n-    /// If the Json value is a `Null`, returns `()`;\n-    /// returns `None` otherwise.\n-    pub fn as_null(&self) -> Option<()> {\n-        match *self {\n-            Json::Null => Some(()),\n-            _ => None,\n-        }\n-    }\n-}\n-\n-impl<'a> Index<&'a str> for Json {\n-    type Output = Json;\n-\n-    fn index(&self, idx: &'a str) -> &Json {\n-        self.find(idx).unwrap()\n-    }\n-}\n-\n-impl Index<usize> for Json {\n-    type Output = Json;\n-\n-    fn index(&self, idx: usize) -> &Json {\n-        match *self {\n-            Json::Array(ref v) => &v[idx],\n-            _ => panic!(\"can only index Json with usize if it is an array\"),\n-        }\n-    }\n-}\n-\n-/// The output of the streaming parser.\n-#[derive(PartialEq, Clone, Debug)]\n-pub enum JsonEvent {\n-    ObjectStart,\n-    ObjectEnd,\n-    ArrayStart,\n-    ArrayEnd,\n-    BooleanValue(bool),\n-    I64Value(i64),\n-    U64Value(u64),\n-    F64Value(f64),\n-    StringValue(string::String),\n-    NullValue,\n-    Error(ParserError),\n-}\n-\n-#[derive(PartialEq, Debug)]\n-enum ParserState {\n-    // Parse a value in an array, true means first element.\n-    ParseArray(bool),\n-    // Parse ',' or ']' after an element in an array.\n-    ParseArrayComma,\n-    // Parse a key:value in an object, true means first element.\n-    ParseObject(bool),\n-    // Parse ',' or ']' after an element in an object.\n-    ParseObjectComma,\n-    // Initial state.\n-    ParseStart,\n-    // Expecting the stream to end.\n-    ParseBeforeFinish,\n-    // Parsing can't continue.\n-    ParseFinished,\n-}\n-\n-/// A Stack represents the current position of the parser in the logical\n-/// structure of the JSON stream.\n-///\n-/// An example is `foo.bar[3].x`.\n-#[derive(Default)]\n-pub struct Stack {\n-    stack: Vec<InternalStackElement>,\n-    str_buffer: Vec<u8>,\n-}\n-\n-/// StackElements compose a Stack.\n-///\n-/// As an example, `StackElement::Key(\"foo\")`, `StackElement::Key(\"bar\")`,\n-/// `StackElement::Index(3)`, and `StackElement::Key(\"x\")` are the\n-/// StackElements composing the stack that represents `foo.bar[3].x`.\n-#[derive(PartialEq, Clone, Debug)]\n-pub enum StackElement<'l> {\n-    Index(u32),\n-    Key(&'l str),\n-}\n-\n-// Internally, Key elements are stored as indices in a buffer to avoid\n-// allocating a string for every member of an object.\n-#[derive(PartialEq, Clone, Debug)]\n-enum InternalStackElement {\n-    InternalIndex(u32),\n-    InternalKey(u16, u16), // start, size\n-}\n-\n-impl Stack {\n-    pub fn new() -> Stack {\n-        Self::default()\n-    }\n-\n-    /// Returns The number of elements in the Stack.\n-    pub fn len(&self) -> usize {\n-        self.stack.len()\n-    }\n-\n-    /// Returns `true` if the stack is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.stack.is_empty()\n-    }\n-\n-    /// Provides access to the StackElement at a given index.\n-    /// lower indices are at the bottom of the stack while higher indices are\n-    /// at the top.\n-    pub fn get(&self, idx: usize) -> StackElement<'_> {\n-        match self.stack[idx] {\n-            InternalIndex(i) => StackElement::Index(i),\n-            InternalKey(start, size) => StackElement::Key(\n-                str::from_utf8(&self.str_buffer[start as usize..start as usize + size as usize])\n-                    .unwrap(),\n-            ),\n-        }\n-    }\n-\n-    /// Compares this stack with an array of StackElement<'_>s.\n-    pub fn is_equal_to(&self, rhs: &[StackElement<'_>]) -> bool {\n-        if self.stack.len() != rhs.len() {\n-            return false;\n-        }\n-        for (i, r) in rhs.iter().enumerate() {\n-            if self.get(i) != *r {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Returns `true` if the bottom-most elements of this stack are the same as\n-    /// the ones passed as parameter.\n-    pub fn starts_with(&self, rhs: &[StackElement<'_>]) -> bool {\n-        if self.stack.len() < rhs.len() {\n-            return false;\n-        }\n-        for (i, r) in rhs.iter().enumerate() {\n-            if self.get(i) != *r {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Returns `true` if the top-most elements of this stack are the same as\n-    /// the ones passed as parameter.\n-    pub fn ends_with(&self, rhs: &[StackElement<'_>]) -> bool {\n-        if self.stack.len() < rhs.len() {\n-            return false;\n-        }\n-        let offset = self.stack.len() - rhs.len();\n-        for (i, r) in rhs.iter().enumerate() {\n-            if self.get(i + offset) != *r {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Returns the top-most element (if any).\n-    pub fn top(&self) -> Option<StackElement<'_>> {\n-        match self.stack.last() {\n-            None => None,\n-            Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n-            Some(&InternalKey(start, size)) => Some(StackElement::Key(\n-                str::from_utf8(&self.str_buffer[start as usize..(start + size) as usize]).unwrap(),\n-            )),\n-        }\n-    }\n-\n-    // Used by Parser to insert StackElement::Key elements at the top of the stack.\n-    fn push_key(&mut self, key: string::String) {\n-        self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n-        self.str_buffer.extend(key.as_bytes());\n-    }\n-\n-    // Used by Parser to insert StackElement::Index elements at the top of the stack.\n-    fn push_index(&mut self, index: u32) {\n-        self.stack.push(InternalIndex(index));\n-    }\n-\n-    // Used by Parser to remove the top-most element of the stack.\n-    fn pop(&mut self) {\n-        assert!(!self.is_empty());\n-        match *self.stack.last().unwrap() {\n-            InternalKey(_, sz) => {\n-                let new_size = self.str_buffer.len() - sz as usize;\n-                self.str_buffer.truncate(new_size);\n-            }\n-            InternalIndex(_) => {}\n-        }\n-        self.stack.pop();\n-    }\n-\n-    // Used by Parser to test whether the top-most element is an index.\n-    fn last_is_index(&self) -> bool {\n-        matches!(self.stack.last(), Some(InternalIndex(_)))\n-    }\n-\n-    // Used by Parser to increment the index of the top-most element.\n-    fn bump_index(&mut self) {\n-        let len = self.stack.len();\n-        let idx = match *self.stack.last().unwrap() {\n-            InternalIndex(i) => i + 1,\n-            _ => {\n-                panic!();\n-            }\n-        };\n-        self.stack[len - 1] = InternalIndex(idx);\n-    }\n-}\n-\n-/// A streaming JSON parser implemented as an iterator of JsonEvent, consuming\n-/// an iterator of char.\n-pub struct Parser<T> {\n-    rdr: T,\n-    ch: Option<char>,\n-    line: usize,\n-    col: usize,\n-    // We maintain a stack representing where we are in the logical structure\n-    // of the JSON stream.\n-    stack: Stack,\n-    // A state machine is kept to make it possible to interrupt and resume parsing.\n-    state: ParserState,\n-}\n-\n-impl<T: Iterator<Item = char>> Iterator for Parser<T> {\n-    type Item = JsonEvent;\n-\n-    fn next(&mut self) -> Option<JsonEvent> {\n-        if self.state == ParseFinished {\n-            return None;\n-        }\n-\n-        if self.state == ParseBeforeFinish {\n-            self.parse_whitespace();\n-            // Make sure there is no trailing characters.\n-            if self.eof() {\n-                self.state = ParseFinished;\n-                return None;\n-            } else {\n-                return Some(self.error_event(TrailingCharacters));\n-            }\n-        }\n-\n-        Some(self.parse())\n-    }\n-}\n-\n-impl<T: Iterator<Item = char>> Parser<T> {\n-    /// Creates the JSON parser.\n-    pub fn new(rdr: T) -> Parser<T> {\n-        let mut p = Parser {\n-            rdr,\n-            ch: Some('\\x00'),\n-            line: 1,\n-            col: 0,\n-            stack: Stack::new(),\n-            state: ParseStart,\n-        };\n-        p.bump();\n-        p\n-    }\n-\n-    /// Provides access to the current position in the logical structure of the\n-    /// JSON stream.\n-    pub fn stack(&self) -> &Stack {\n-        &self.stack\n-    }\n-\n-    fn eof(&self) -> bool {\n-        self.ch.is_none()\n-    }\n-    fn ch_or_null(&self) -> char {\n-        self.ch.unwrap_or('\\x00')\n-    }\n-    fn bump(&mut self) {\n-        self.ch = self.rdr.next();\n-\n-        if self.ch_is('\\n') {\n-            self.line += 1;\n-            self.col = 1;\n-        } else {\n-            self.col += 1;\n-        }\n-    }\n-\n-    fn next_char(&mut self) -> Option<char> {\n-        self.bump();\n-        self.ch\n-    }\n-    fn ch_is(&self, c: char) -> bool {\n-        self.ch == Some(c)\n-    }\n-\n-    fn error<U>(&self, reason: ErrorCode) -> Result<U, ParserError> {\n-        Err(SyntaxError(reason, self.line, self.col))\n-    }\n-\n-    fn parse_whitespace(&mut self) {\n-        while self.ch_is(' ') || self.ch_is('\\n') || self.ch_is('\\t') || self.ch_is('\\r') {\n-            self.bump();\n-        }\n-    }\n-\n-    fn parse_number(&mut self) -> JsonEvent {\n-        let neg = if self.ch_is('-') {\n-            self.bump();\n-            true\n-        } else {\n-            false\n-        };\n-\n-        let res = match self.parse_u64() {\n-            Ok(res) => res,\n-            Err(e) => {\n-                return Error(e);\n-            }\n-        };\n-\n-        if self.ch_is('.') || self.ch_is('e') || self.ch_is('E') {\n-            let mut res = res as f64;\n-\n-            if self.ch_is('.') {\n-                res = match self.parse_decimal(res) {\n-                    Ok(res) => res,\n-                    Err(e) => {\n-                        return Error(e);\n-                    }\n-                };\n-            }\n-\n-            if self.ch_is('e') || self.ch_is('E') {\n-                res = match self.parse_exponent(res) {\n-                    Ok(res) => res,\n-                    Err(e) => {\n-                        return Error(e);\n-                    }\n-                };\n-            }\n-\n-            if neg {\n-                res *= -1.0;\n-            }\n-\n-            F64Value(res)\n-        } else if neg {\n-            let res = (res as i64).wrapping_neg();\n-\n-            // Make sure we didn't underflow.\n-            if res > 0 {\n-                Error(SyntaxError(InvalidNumber, self.line, self.col))\n-            } else {\n-                I64Value(res)\n-            }\n-        } else {\n-            U64Value(res)\n-        }\n-    }\n-\n-    fn parse_u64(&mut self) -> Result<u64, ParserError> {\n-        let mut accum = 0u64;\n-        let last_accum = 0; // necessary to detect overflow.\n-\n-        match self.ch_or_null() {\n-            '0' => {\n-                self.bump();\n-\n-                // A leading '0' must be the only digit before the decimal point.\n-                if let '0'..='9' = self.ch_or_null() {\n-                    return self.error(InvalidNumber);\n-                }\n-            }\n-            '1'..='9' => {\n-                while !self.eof() {\n-                    match self.ch_or_null() {\n-                        c @ '0'..='9' => {\n-                            accum = accum.wrapping_mul(10);\n-                            accum = accum.wrapping_add((c as u64) - ('0' as u64));\n-\n-                            // Detect overflow by comparing to the last value.\n-                            if accum <= last_accum {\n-                                return self.error(InvalidNumber);\n-                            }\n-\n-                            self.bump();\n-                        }\n-                        _ => break,\n-                    }\n-                }\n-            }\n-            _ => return self.error(InvalidNumber),\n-        }\n-\n-        Ok(accum)\n-    }\n-\n-    fn parse_decimal(&mut self, mut res: f64) -> Result<f64, ParserError> {\n-        self.bump();\n-\n-        // Make sure a digit follows the decimal place.\n-        match self.ch_or_null() {\n-            '0'..='9' => (),\n-            _ => return self.error(InvalidNumber),\n-        }\n-\n-        let mut dec = 1.0;\n-        while !self.eof() {\n-            match self.ch_or_null() {\n-                c @ '0'..='9' => {\n-                    dec /= 10.0;\n-                    res += (((c as isize) - ('0' as isize)) as f64) * dec;\n-                    self.bump();\n-                }\n-                _ => break,\n-            }\n-        }\n-\n-        Ok(res)\n-    }\n-\n-    fn parse_exponent(&mut self, mut res: f64) -> Result<f64, ParserError> {\n-        self.bump();\n-\n-        let mut exp = 0;\n-        let mut neg_exp = false;\n-\n-        if self.ch_is('+') {\n-            self.bump();\n-        } else if self.ch_is('-') {\n-            self.bump();\n-            neg_exp = true;\n-        }\n-\n-        // Make sure a digit follows the exponent place.\n-        match self.ch_or_null() {\n-            '0'..='9' => (),\n-            _ => return self.error(InvalidNumber),\n-        }\n-        while !self.eof() {\n-            match self.ch_or_null() {\n-                c @ '0'..='9' => {\n-                    exp *= 10;\n-                    exp += (c as usize) - ('0' as usize);\n-\n-                    self.bump();\n-                }\n-                _ => break,\n-            }\n-        }\n-\n-        let exp = 10_f64.powi(exp as i32);\n-        if neg_exp {\n-            res /= exp;\n-        } else {\n-            res *= exp;\n-        }\n-\n-        Ok(res)\n-    }\n-\n-    fn decode_hex_escape(&mut self) -> Result<u16, ParserError> {\n-        let mut i = 0;\n-        let mut n = 0;\n-        while i < 4 && !self.eof() {\n-            self.bump();\n-            n = match self.ch_or_null() {\n-                c @ '0'..='9' => n * 16 + ((c as u16) - ('0' as u16)),\n-                'a' | 'A' => n * 16 + 10,\n-                'b' | 'B' => n * 16 + 11,\n-                'c' | 'C' => n * 16 + 12,\n-                'd' | 'D' => n * 16 + 13,\n-                'e' | 'E' => n * 16 + 14,\n-                'f' | 'F' => n * 16 + 15,\n-                _ => return self.error(InvalidEscape),\n-            };\n-\n-            i += 1;\n-        }\n-\n-        // Error out if we didn't parse 4 digits.\n-        if i != 4 {\n-            return self.error(InvalidEscape);\n-        }\n-\n-        Ok(n)\n-    }\n-\n-    fn parse_str(&mut self) -> Result<string::String, ParserError> {\n-        let mut escape = false;\n-        let mut res = string::String::new();\n-\n-        loop {\n-            self.bump();\n-            if self.eof() {\n-                return self.error(EOFWhileParsingString);\n-            }\n-\n-            if escape {\n-                match self.ch_or_null() {\n-                    '\"' => res.push('\"'),\n-                    '\\\\' => res.push('\\\\'),\n-                    '/' => res.push('/'),\n-                    'b' => res.push('\\x08'),\n-                    'f' => res.push('\\x0c'),\n-                    'n' => res.push('\\n'),\n-                    'r' => res.push('\\r'),\n-                    't' => res.push('\\t'),\n-                    'u' => match self.decode_hex_escape()? {\n-                        0xDC00..=0xDFFF => return self.error(LoneLeadingSurrogateInHexEscape),\n-\n-                        // Non-BMP characters are encoded as a sequence of\n-                        // two hex escapes, representing UTF-16 surrogates.\n-                        n1 @ 0xD800..=0xDBFF => {\n-                            match (self.next_char(), self.next_char()) {\n-                                (Some('\\\\'), Some('u')) => (),\n-                                _ => return self.error(UnexpectedEndOfHexEscape),\n-                            }\n-\n-                            let n2 = self.decode_hex_escape()?;\n-                            if !(0xDC00..=0xDFFF).contains(&n2) {\n-                                return self.error(LoneLeadingSurrogateInHexEscape);\n-                            }\n-                            let c =\n-                                (u32::from(n1 - 0xD800) << 10 | u32::from(n2 - 0xDC00)) + 0x1_0000;\n-                            res.push(char::from_u32(c).unwrap());\n-                        }\n-\n-                        n => match char::from_u32(u32::from(n)) {\n-                            Some(c) => res.push(c),\n-                            None => return self.error(InvalidUnicodeCodePoint),\n-                        },\n-                    },\n-                    _ => return self.error(InvalidEscape),\n-                }\n-                escape = false;\n-            } else if self.ch_is('\\\\') {\n-                escape = true;\n-            } else {\n-                match self.ch {\n-                    Some('\"') => {\n-                        self.bump();\n-                        return Ok(res);\n-                    }\n-                    Some(c) => res.push(c),\n-                    None => unreachable!(),\n-                }\n-            }\n-        }\n-    }\n-\n-    // Invoked at each iteration, consumes the stream until it has enough\n-    // information to return a JsonEvent.\n-    // Manages an internal state so that parsing can be interrupted and resumed.\n-    // Also keeps track of the position in the logical structure of the json\n-    // stream isize the form of a stack that can be queried by the user using the\n-    // stack() method.\n-    fn parse(&mut self) -> JsonEvent {\n-        loop {\n-            // The only paths where the loop can spin a new iteration\n-            // are in the cases ParseArrayComma and ParseObjectComma if ','\n-            // is parsed. In these cases the state is set to (respectively)\n-            // ParseArray(false) and ParseObject(false), which always return,\n-            // so there is no risk of getting stuck in an infinite loop.\n-            // All other paths return before the end of the loop's iteration.\n-            self.parse_whitespace();\n-\n-            match self.state {\n-                ParseStart => {\n-                    return self.parse_start();\n-                }\n-                ParseArray(first) => {\n-                    return self.parse_array(first);\n-                }\n-                ParseArrayComma => {\n-                    if let Some(evt) = self.parse_array_comma_or_end() {\n-                        return evt;\n-                    }\n-                }\n-                ParseObject(first) => {\n-                    return self.parse_object(first);\n-                }\n-                ParseObjectComma => {\n-                    self.stack.pop();\n-                    if self.ch_is(',') {\n-                        self.state = ParseObject(false);\n-                        self.bump();\n-                    } else {\n-                        return self.parse_object_end();\n-                    }\n-                }\n-                _ => {\n-                    return self.error_event(InvalidSyntax);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn parse_start(&mut self) -> JsonEvent {\n-        let val = self.parse_value();\n-        self.state = match val {\n-            Error(_) => ParseFinished,\n-            ArrayStart => ParseArray(true),\n-            ObjectStart => ParseObject(true),\n-            _ => ParseBeforeFinish,\n-        };\n-        val\n-    }\n-\n-    fn parse_array(&mut self, first: bool) -> JsonEvent {\n-        if self.ch_is(']') {\n-            if !first {\n-                self.error_event(InvalidSyntax)\n-            } else {\n-                self.state = if self.stack.is_empty() {\n-                    ParseBeforeFinish\n-                } else if self.stack.last_is_index() {\n-                    ParseArrayComma\n-                } else {\n-                    ParseObjectComma\n-                };\n-                self.bump();\n-                ArrayEnd\n-            }\n-        } else {\n-            if first {\n-                self.stack.push_index(0);\n-            }\n-            let val = self.parse_value();\n-            self.state = match val {\n-                Error(_) => ParseFinished,\n-                ArrayStart => ParseArray(true),\n-                ObjectStart => ParseObject(true),\n-                _ => ParseArrayComma,\n-            };\n-            val\n-        }\n-    }\n-\n-    fn parse_array_comma_or_end(&mut self) -> Option<JsonEvent> {\n-        if self.ch_is(',') {\n-            self.stack.bump_index();\n-            self.state = ParseArray(false);\n-            self.bump();\n-            None\n-        } else if self.ch_is(']') {\n-            self.stack.pop();\n-            self.state = if self.stack.is_empty() {\n-                ParseBeforeFinish\n-            } else if self.stack.last_is_index() {\n-                ParseArrayComma\n-            } else {\n-                ParseObjectComma\n-            };\n-            self.bump();\n-            Some(ArrayEnd)\n-        } else if self.eof() {\n-            Some(self.error_event(EOFWhileParsingArray))\n-        } else {\n-            Some(self.error_event(InvalidSyntax))\n-        }\n-    }\n-\n-    fn parse_object(&mut self, first: bool) -> JsonEvent {\n-        if self.ch_is('}') {\n-            if !first {\n-                if self.stack.is_empty() {\n-                    return self.error_event(TrailingComma);\n-                } else {\n-                    self.stack.pop();\n-                }\n-            }\n-            self.state = if self.stack.is_empty() {\n-                ParseBeforeFinish\n-            } else if self.stack.last_is_index() {\n-                ParseArrayComma\n-            } else {\n-                ParseObjectComma\n-            };\n-            self.bump();\n-            return ObjectEnd;\n-        }\n-        if self.eof() {\n-            return self.error_event(EOFWhileParsingObject);\n-        }\n-        if !self.ch_is('\"') {\n-            return self.error_event(KeyMustBeAString);\n-        }\n-        let s = match self.parse_str() {\n-            Ok(s) => s,\n-            Err(e) => {\n-                self.state = ParseFinished;\n-                return Error(e);\n-            }\n-        };\n-        self.parse_whitespace();\n-        if self.eof() {\n-            return self.error_event(EOFWhileParsingObject);\n-        } else if self.ch_or_null() != ':' {\n-            return self.error_event(ExpectedColon);\n-        }\n-        self.stack.push_key(s);\n-        self.bump();\n-        self.parse_whitespace();\n-\n-        let val = self.parse_value();\n-\n-        self.state = match val {\n-            Error(_) => ParseFinished,\n-            ArrayStart => ParseArray(true),\n-            ObjectStart => ParseObject(true),\n-            _ => ParseObjectComma,\n-        };\n-        val\n-    }\n-\n-    fn parse_object_end(&mut self) -> JsonEvent {\n-        if self.ch_is('}') {\n-            self.state = if self.stack.is_empty() {\n-                ParseBeforeFinish\n-            } else if self.stack.last_is_index() {\n-                ParseArrayComma\n-            } else {\n-                ParseObjectComma\n-            };\n-            self.bump();\n-            ObjectEnd\n-        } else if self.eof() {\n-            self.error_event(EOFWhileParsingObject)\n-        } else {\n-            self.error_event(InvalidSyntax)\n-        }\n-    }\n-\n-    fn parse_value(&mut self) -> JsonEvent {\n-        if self.eof() {\n-            return self.error_event(EOFWhileParsingValue);\n-        }\n-        match self.ch_or_null() {\n-            'n' => self.parse_ident(\"ull\", NullValue),\n-            't' => self.parse_ident(\"rue\", BooleanValue(true)),\n-            'f' => self.parse_ident(\"alse\", BooleanValue(false)),\n-            '0'..='9' | '-' => self.parse_number(),\n-            '\"' => match self.parse_str() {\n-                Ok(s) => StringValue(s),\n-                Err(e) => Error(e),\n-            },\n-            '[' => {\n-                self.bump();\n-                ArrayStart\n-            }\n-            '{' => {\n-                self.bump();\n-                ObjectStart\n-            }\n-            _ => self.error_event(InvalidSyntax),\n-        }\n-    }\n-\n-    fn parse_ident(&mut self, ident: &str, value: JsonEvent) -> JsonEvent {\n-        if ident.chars().all(|c| Some(c) == self.next_char()) {\n-            self.bump();\n-            value\n-        } else {\n-            Error(SyntaxError(InvalidSyntax, self.line, self.col))\n-        }\n-    }\n-\n-    fn error_event(&mut self, reason: ErrorCode) -> JsonEvent {\n-        self.state = ParseFinished;\n-        Error(SyntaxError(reason, self.line, self.col))\n-    }\n-}\n-\n-/// A Builder consumes a json::Parser to create a generic Json structure.\n-pub struct Builder<T> {\n-    parser: Parser<T>,\n-    token: Option<JsonEvent>,\n-}\n-\n-impl<T: Iterator<Item = char>> Builder<T> {\n-    /// Creates a JSON Builder.\n-    pub fn new(src: T) -> Builder<T> {\n-        Builder { parser: Parser::new(src), token: None }\n-    }\n-\n-    // Decode a Json value from a Parser.\n-    pub fn build(&mut self) -> Result<Json, BuilderError> {\n-        self.bump();\n-        let result = self.build_value();\n-        self.bump();\n-        match self.token {\n-            None => {}\n-            Some(Error(ref e)) => {\n-                return Err(e.clone());\n-            }\n-            ref tok => {\n-                panic!(\"unexpected token {:?}\", tok.clone());\n-            }\n-        }\n-        result\n-    }\n-\n-    fn bump(&mut self) {\n-        self.token = self.parser.next();\n-    }\n-\n-    fn build_value(&mut self) -> Result<Json, BuilderError> {\n-        match self.token {\n-            Some(NullValue) => Ok(Json::Null),\n-            Some(I64Value(n)) => Ok(Json::I64(n)),\n-            Some(U64Value(n)) => Ok(Json::U64(n)),\n-            Some(F64Value(n)) => Ok(Json::F64(n)),\n-            Some(BooleanValue(b)) => Ok(Json::Boolean(b)),\n-            Some(StringValue(ref mut s)) => {\n-                let mut temp = string::String::new();\n-                swap(s, &mut temp);\n-                Ok(Json::String(temp))\n-            }\n-            Some(Error(ref e)) => Err(e.clone()),\n-            Some(ArrayStart) => self.build_array(),\n-            Some(ObjectStart) => self.build_object(),\n-            Some(ObjectEnd) => self.parser.error(InvalidSyntax),\n-            Some(ArrayEnd) => self.parser.error(InvalidSyntax),\n-            None => self.parser.error(EOFWhileParsingValue),\n-        }\n-    }\n-\n-    fn build_array(&mut self) -> Result<Json, BuilderError> {\n-        self.bump();\n-        let mut values = Vec::new();\n-\n-        loop {\n-            if self.token == Some(ArrayEnd) {\n-                return Ok(Json::Array(values.into_iter().collect()));\n-            }\n-            match self.build_value() {\n-                Ok(v) => values.push(v),\n-                Err(e) => return Err(e),\n-            }\n-            self.bump();\n-        }\n-    }\n-\n-    fn build_object(&mut self) -> Result<Json, BuilderError> {\n-        self.bump();\n-\n-        let mut values = BTreeMap::new();\n-\n-        loop {\n-            match self.token {\n-                Some(ObjectEnd) => {\n-                    return Ok(Json::Object(values));\n-                }\n-                Some(Error(ref e)) => {\n-                    return Err(e.clone());\n-                }\n-                None => {\n-                    break;\n-                }\n-                _ => {}\n-            }\n-            let key = match self.parser.stack().top() {\n-                Some(StackElement::Key(k)) => k.to_owned(),\n-                _ => {\n-                    panic!(\"invalid state\");\n-                }\n-            };\n-            match self.build_value() {\n-                Ok(value) => {\n-                    values.insert(key, value);\n-                }\n-                Err(e) => {\n-                    return Err(e);\n-                }\n-            }\n-            self.bump();\n-        }\n-        self.parser.error(EOFWhileParsingObject)\n-    }\n-}\n-\n-/// Decodes a json value from a string\n-pub fn from_str(s: &str) -> Result<Json, BuilderError> {\n-    let mut builder = Builder::new(s.chars());\n-    builder.build()\n-}\n-\n-/// A trait for converting values to JSON\n-pub trait ToJson {\n-    /// Converts the value of `self` to an instance of JSON\n-    fn to_json(&self) -> Json;\n-}\n-\n-macro_rules! to_json_impl_i64 {\n-    ($($t:ty), +) => (\n-        $(impl ToJson for $t {\n-            fn to_json(&self) -> Json {\n-                Json::I64(*self as i64)\n-            }\n-        })+\n-    )\n-}\n-\n-to_json_impl_i64! { isize, i8, i16, i32, i64 }\n-\n-macro_rules! to_json_impl_u64 {\n-    ($($t:ty), +) => (\n-        $(impl ToJson for $t {\n-            fn to_json(&self) -> Json {\n-                Json::U64(*self as u64)\n-            }\n-        })+\n-    )\n-}\n-\n-to_json_impl_u64! { usize, u8, u16, u32, u64 }\n-\n-impl ToJson for Json {\n-    fn to_json(&self) -> Json {\n-        self.clone()\n-    }\n-}\n-\n-impl ToJson for f32 {\n-    fn to_json(&self) -> Json {\n-        f64::from(*self).to_json()\n-    }\n-}\n-\n-impl ToJson for f64 {\n-    fn to_json(&self) -> Json {\n-        match self.classify() {\n-            Fp::Nan | Fp::Infinite => Json::Null,\n-            _ => Json::F64(*self),\n-        }\n-    }\n-}\n-\n-impl ToJson for () {\n-    fn to_json(&self) -> Json {\n-        Json::Null\n-    }\n-}\n-\n-impl ToJson for bool {\n-    fn to_json(&self) -> Json {\n-        Json::Boolean(*self)\n-    }\n-}\n-\n-impl ToJson for str {\n-    fn to_json(&self) -> Json {\n-        Json::String(self.to_string())\n-    }\n-}\n-\n-impl ToJson for string::String {\n-    fn to_json(&self) -> Json {\n-        Json::String((*self).clone())\n-    }\n-}\n-\n-impl<'a> ToJson for Cow<'a, str> {\n-    fn to_json(&self) -> Json {\n-        Json::String(self.to_string())\n-    }\n-}\n-\n-macro_rules! tuple_impl {\n-    // use variables to indicate the arity of the tuple\n-    ($($tyvar:ident),* ) => {\n-        // the trailing commas are for the 1 tuple\n-        impl<\n-            $( $tyvar : ToJson ),*\n-            > ToJson for ( $( $tyvar ),* , ) {\n-\n-            #[inline]\n-            #[allow(non_snake_case)]\n-            fn to_json(&self) -> Json {\n-                match *self {\n-                    ($(ref $tyvar),*,) => Json::Array(vec![$($tyvar.to_json()),*])\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-tuple_impl! {A}\n-tuple_impl! {A, B}\n-tuple_impl! {A, B, C}\n-tuple_impl! {A, B, C, D}\n-tuple_impl! {A, B, C, D, E}\n-tuple_impl! {A, B, C, D, E, F}\n-tuple_impl! {A, B, C, D, E, F, G}\n-tuple_impl! {A, B, C, D, E, F, G, H}\n-tuple_impl! {A, B, C, D, E, F, G, H, I}\n-tuple_impl! {A, B, C, D, E, F, G, H, I, J}\n-tuple_impl! {A, B, C, D, E, F, G, H, I, J, K}\n-tuple_impl! {A, B, C, D, E, F, G, H, I, J, K, L}\n-\n-impl<A: ToJson> ToJson for [A] {\n-    fn to_json(&self) -> Json {\n-        Json::Array(self.iter().map(|elt| elt.to_json()).collect())\n-    }\n-}\n-\n-impl<A: ToJson> ToJson for Vec<A> {\n-    fn to_json(&self) -> Json {\n-        Json::Array(self.iter().map(|elt| elt.to_json()).collect())\n-    }\n-}\n-\n-impl<'a, A: ToJson> ToJson for Cow<'a, [A]>\n-where\n-    [A]: ToOwned,\n-{\n-    fn to_json(&self) -> Json {\n-        Json::Array(self.iter().map(|elt| elt.to_json()).collect())\n-    }\n-}\n-\n-impl<T: ToString, A: ToJson> ToJson for BTreeMap<T, A> {\n-    fn to_json(&self) -> Json {\n-        let mut d = BTreeMap::new();\n-        for (key, value) in self {\n-            d.insert(key.to_string(), value.to_json());\n-        }\n-        Json::Object(d)\n-    }\n-}\n-\n-impl<A: ToJson> ToJson for HashMap<string::String, A> {\n-    fn to_json(&self) -> Json {\n-        let mut d = BTreeMap::new();\n-        for (key, value) in self {\n-            d.insert((*key).clone(), value.to_json());\n-        }\n-        Json::Object(d)\n-    }\n-}\n-\n-impl<A: ToJson> ToJson for Option<A> {\n-    fn to_json(&self) -> Json {\n-        match *self {\n-            None => Json::Null,\n-            Some(ref value) => value.to_json(),\n-        }\n-    }\n-}\n-\n-struct FormatShim<'a, 'b> {\n-    inner: &'a mut fmt::Formatter<'b>,\n-}\n-\n-impl<'a, 'b> fmt::Write for FormatShim<'a, 'b> {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        match self.inner.write_str(s) {\n-            Ok(_) => Ok(()),\n-            Err(_) => Err(fmt::Error),\n-        }\n-    }\n-}\n-\n-impl fmt::Display for Json {\n-    /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut shim = FormatShim { inner: f };\n-        let mut encoder = Encoder::new(&mut shim);\n-        match self.encode(&mut encoder) {\n-            Ok(_) => Ok(()),\n-            Err(_) => Err(fmt::Error),\n-        }\n-    }\n-}\n-\n-impl<'a> fmt::Display for PrettyJson<'a> {\n-    /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut shim = FormatShim { inner: f };\n-        let mut encoder = PrettyEncoder::new(&mut shim);\n-        match self.inner.encode(&mut encoder) {\n-            Ok(_) => Ok(()),\n-            Err(_) => Err(fmt::Error),\n-        }\n-    }\n-}\n-\n-impl<'a, T: for<'r> Encodable<Encoder<'r>>> fmt::Display for AsJson<'a, T> {\n-    /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut shim = FormatShim { inner: f };\n-        let mut encoder = Encoder::new(&mut shim);\n-        match self.inner.encode(&mut encoder) {\n-            Ok(_) => Ok(()),\n-            Err(_) => Err(fmt::Error),\n-        }\n-    }\n-}\n-\n-impl<'a, T> AsPrettyJson<'a, T> {\n-    /// Sets the indentation level for the emitted JSON\n-    pub fn indent(mut self, indent: usize) -> AsPrettyJson<'a, T> {\n-        self.indent = Some(indent);\n-        self\n-    }\n-}\n-\n-impl<'a, T: for<'x> Encodable<PrettyEncoder<'x>>> fmt::Display for AsPrettyJson<'a, T> {\n-    /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut shim = FormatShim { inner: f };\n-        let mut encoder = PrettyEncoder::new(&mut shim);\n-        if let Some(n) = self.indent {\n-            encoder.set_indent(n);\n-        }\n-        match self.inner.encode(&mut encoder) {\n-            Ok(_) => Ok(()),\n-            Err(_) => Err(fmt::Error),\n-        }\n-    }\n-}\n-\n-impl FromStr for Json {\n-    type Err = BuilderError;\n-    fn from_str(s: &str) -> Result<Json, BuilderError> {\n-        from_str(s)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "01678fbf0b79e9fcde6751ce0d7accd474b60fc5", "filename": "compiler/rustc_serialize/src/json/tests.rs", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/15e0d8bdb1f81be314114e78e4ff507a97e8ce33/compiler%2Frustc_serialize%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e0d8bdb1f81be314114e78e4ff507a97e8ce33/compiler%2Frustc_serialize%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson%2Ftests.rs?ref=15e0d8bdb1f81be314114e78e4ff507a97e8ce33", "patch": "@@ -1,147 +0,0 @@\n-// Benchmarks and tests that require private items\n-\n-extern crate test;\n-use super::{from_str, Parser, Stack, StackElement};\n-use std::string;\n-use test::Bencher;\n-\n-#[test]\n-fn test_stack() {\n-    let mut stack = Stack::new();\n-\n-    assert!(stack.is_empty());\n-    assert!(stack.is_empty());\n-    assert!(!stack.last_is_index());\n-\n-    stack.push_index(0);\n-    stack.bump_index();\n-\n-    assert!(stack.len() == 1);\n-    assert!(stack.is_equal_to(&[StackElement::Index(1)]));\n-    assert!(stack.starts_with(&[StackElement::Index(1)]));\n-    assert!(stack.ends_with(&[StackElement::Index(1)]));\n-    assert!(stack.last_is_index());\n-    assert!(stack.get(0) == StackElement::Index(1));\n-\n-    stack.push_key(\"foo\".to_string());\n-\n-    assert!(stack.len() == 2);\n-    assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.starts_with(&[StackElement::Index(1)]));\n-    assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n-    assert!(!stack.last_is_index());\n-    assert!(stack.get(0) == StackElement::Index(1));\n-    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-\n-    stack.push_key(\"bar\".to_string());\n-\n-    assert!(stack.len() == 3);\n-    assert!(stack.is_equal_to(&[\n-        StackElement::Index(1),\n-        StackElement::Key(\"foo\"),\n-        StackElement::Key(\"bar\")\n-    ]));\n-    assert!(stack.starts_with(&[StackElement::Index(1)]));\n-    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.starts_with(&[\n-        StackElement::Index(1),\n-        StackElement::Key(\"foo\"),\n-        StackElement::Key(\"bar\")\n-    ]));\n-    assert!(stack.ends_with(&[StackElement::Key(\"bar\")]));\n-    assert!(stack.ends_with(&[StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n-    assert!(stack.ends_with(&[\n-        StackElement::Index(1),\n-        StackElement::Key(\"foo\"),\n-        StackElement::Key(\"bar\")\n-    ]));\n-    assert!(!stack.last_is_index());\n-    assert!(stack.get(0) == StackElement::Index(1));\n-    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-    assert!(stack.get(2) == StackElement::Key(\"bar\"));\n-\n-    stack.pop();\n-\n-    assert!(stack.len() == 2);\n-    assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.starts_with(&[StackElement::Index(1)]));\n-    assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-    assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n-    assert!(!stack.last_is_index());\n-    assert!(stack.get(0) == StackElement::Index(1));\n-    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-}\n-\n-#[bench]\n-fn bench_streaming_small(b: &mut Bencher) {\n-    b.iter(|| {\n-        let mut parser = Parser::new(\n-            r#\"{\n-                \"a\": 1.0,\n-                \"b\": [\n-                    true,\n-                    \"foo\\nbar\",\n-                    { \"c\": {\"d\": null} }\n-                ]\n-            }\"#\n-            .chars(),\n-        );\n-        loop {\n-            match parser.next() {\n-                None => return,\n-                _ => {}\n-            }\n-        }\n-    });\n-}\n-#[bench]\n-fn bench_small(b: &mut Bencher) {\n-    b.iter(|| {\n-        let _ = from_str(\n-            r#\"{\n-            \"a\": 1.0,\n-            \"b\": [\n-                true,\n-                \"foo\\nbar\",\n-                { \"c\": {\"d\": null} }\n-            ]\n-        }\"#,\n-        );\n-    });\n-}\n-\n-fn big_json() -> string::String {\n-    let mut src = \"[\\n\".to_string();\n-    for _ in 0..500 {\n-        src.push_str(\n-            r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n-                        [1,2,3]},\"#,\n-        );\n-    }\n-    src.push_str(\"{}]\");\n-    return src;\n-}\n-\n-#[bench]\n-fn bench_streaming_large(b: &mut Bencher) {\n-    let src = big_json();\n-    b.iter(|| {\n-        let mut parser = Parser::new(src.chars());\n-        loop {\n-            match parser.next() {\n-                None => return,\n-                _ => {}\n-            }\n-        }\n-    });\n-}\n-#[bench]\n-fn bench_large(b: &mut Bencher) {\n-    let src = big_json();\n-    b.iter(|| {\n-        let _ = from_str(&src);\n-    });\n-}"}, {"sha": "b3a0bcf0e1134f0b9e6a4e227a9c9821f2b31ef1", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a", "patch": "@@ -25,7 +25,5 @@ pub use self::serialize::{Decodable, Decoder, Encodable, Encoder};\n mod collection_impls;\n mod serialize;\n \n-pub mod json;\n-\n pub mod leb128;\n pub mod opaque;"}, {"sha": "944fe460632199db4a9cd1108a08a5a89e2e9118", "filename": "compiler/rustc_serialize/tests/json.rs", "status": "removed", "additions": 0, "deletions": 978, "changes": 978, "blob_url": "https://github.com/rust-lang/rust/blob/15e0d8bdb1f81be314114e78e4ff507a97e8ce33/compiler%2Frustc_serialize%2Ftests%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e0d8bdb1f81be314114e78e4ff507a97e8ce33/compiler%2Frustc_serialize%2Ftests%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fjson.rs?ref=15e0d8bdb1f81be314114e78e4ff507a97e8ce33", "patch": "@@ -1,978 +0,0 @@\n-#![allow(rustc::internal)]\n-\n-use json::ErrorCode::*;\n-use json::Json::*;\n-use json::JsonEvent::*;\n-use json::ParserError::*;\n-use json::{from_str, Encoder, EncoderError, Json, JsonEvent, Parser, StackElement};\n-use rustc_macros::Encodable;\n-use rustc_serialize::json;\n-use rustc_serialize::Encodable;\n-\n-use std::collections::BTreeMap;\n-use std::io::prelude::*;\n-use std::string;\n-use Animal::*;\n-\n-#[derive(Eq, PartialEq, Debug)]\n-struct OptionData {\n-    opt: Option<usize>,\n-}\n-\n-#[derive(PartialEq, Encodable, Debug)]\n-enum Animal {\n-    Dog,\n-    Frog(string::String, isize),\n-}\n-\n-#[derive(PartialEq, Encodable, Debug)]\n-struct Inner {\n-    a: (),\n-    b: usize,\n-    c: Vec<string::String>,\n-}\n-\n-#[derive(PartialEq, Encodable, Debug)]\n-struct Outer {\n-    inner: Vec<Inner>,\n-}\n-\n-fn mk_object(items: &[(string::String, Json)]) -> Json {\n-    let mut d = BTreeMap::new();\n-\n-    for item in items {\n-        match *item {\n-            (ref key, ref value) => {\n-                d.insert((*key).clone(), (*value).clone());\n-            }\n-        }\n-    }\n-\n-    Object(d)\n-}\n-\n-#[test]\n-fn test_from_str_trait() {\n-    let s = \"null\";\n-    assert!(s.parse::<Json>().unwrap() == s.parse().unwrap());\n-}\n-\n-#[test]\n-fn test_write_null() {\n-    assert_eq!(Null.to_string(), \"null\");\n-    assert_eq!(Null.pretty().to_string(), \"null\");\n-}\n-\n-#[test]\n-fn test_write_i64() {\n-    assert_eq!(U64(0).to_string(), \"0\");\n-    assert_eq!(U64(0).pretty().to_string(), \"0\");\n-\n-    assert_eq!(U64(1234).to_string(), \"1234\");\n-    assert_eq!(U64(1234).pretty().to_string(), \"1234\");\n-\n-    assert_eq!(I64(-5678).to_string(), \"-5678\");\n-    assert_eq!(I64(-5678).pretty().to_string(), \"-5678\");\n-\n-    assert_eq!(U64(7650007200025252000).to_string(), \"7650007200025252000\");\n-    assert_eq!(U64(7650007200025252000).pretty().to_string(), \"7650007200025252000\");\n-}\n-\n-#[test]\n-fn test_write_f64() {\n-    assert_eq!(F64(3.0).to_string(), \"3.0\");\n-    assert_eq!(F64(3.0).pretty().to_string(), \"3.0\");\n-\n-    assert_eq!(F64(3.1).to_string(), \"3.1\");\n-    assert_eq!(F64(3.1).pretty().to_string(), \"3.1\");\n-\n-    assert_eq!(F64(-1.5).to_string(), \"-1.5\");\n-    assert_eq!(F64(-1.5).pretty().to_string(), \"-1.5\");\n-\n-    assert_eq!(F64(0.5).to_string(), \"0.5\");\n-    assert_eq!(F64(0.5).pretty().to_string(), \"0.5\");\n-\n-    assert_eq!(F64(f64::NAN).to_string(), \"null\");\n-    assert_eq!(F64(f64::NAN).pretty().to_string(), \"null\");\n-\n-    assert_eq!(F64(f64::INFINITY).to_string(), \"null\");\n-    assert_eq!(F64(f64::INFINITY).pretty().to_string(), \"null\");\n-\n-    assert_eq!(F64(f64::NEG_INFINITY).to_string(), \"null\");\n-    assert_eq!(F64(f64::NEG_INFINITY).pretty().to_string(), \"null\");\n-}\n-\n-#[test]\n-fn test_write_str() {\n-    assert_eq!(String(\"\".to_string()).to_string(), \"\\\"\\\"\");\n-    assert_eq!(String(\"\".to_string()).pretty().to_string(), \"\\\"\\\"\");\n-\n-    assert_eq!(String(\"homura\".to_string()).to_string(), \"\\\"homura\\\"\");\n-    assert_eq!(String(\"madoka\".to_string()).pretty().to_string(), \"\\\"madoka\\\"\");\n-}\n-\n-#[test]\n-fn test_write_bool() {\n-    assert_eq!(Boolean(true).to_string(), \"true\");\n-    assert_eq!(Boolean(true).pretty().to_string(), \"true\");\n-\n-    assert_eq!(Boolean(false).to_string(), \"false\");\n-    assert_eq!(Boolean(false).pretty().to_string(), \"false\");\n-}\n-\n-#[test]\n-fn test_write_array() {\n-    assert_eq!(Array(vec![]).to_string(), \"[]\");\n-    assert_eq!(Array(vec![]).pretty().to_string(), \"[]\");\n-\n-    assert_eq!(Array(vec![Boolean(true)]).to_string(), \"[true]\");\n-    assert_eq!(\n-        Array(vec![Boolean(true)]).pretty().to_string(),\n-        \"\\\n-        [\\n  \\\n-            true\\n\\\n-        ]\"\n-    );\n-\n-    let long_test_array =\n-        Array(vec![Boolean(false), Null, Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n-\n-    assert_eq!(long_test_array.to_string(), \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n-    assert_eq!(\n-        long_test_array.pretty().to_string(),\n-        \"\\\n-        [\\n  \\\n-            false,\\n  \\\n-            null,\\n  \\\n-            [\\n    \\\n-                \\\"foo\\\\nbar\\\",\\n    \\\n-                3.5\\n  \\\n-            ]\\n\\\n-        ]\"\n-    );\n-}\n-\n-#[test]\n-fn test_write_object() {\n-    assert_eq!(mk_object(&[]).to_string(), \"{}\");\n-    assert_eq!(mk_object(&[]).pretty().to_string(), \"{}\");\n-\n-    assert_eq!(mk_object(&[(\"a\".to_string(), Boolean(true))]).to_string(), \"{\\\"a\\\":true}\");\n-    assert_eq!(\n-        mk_object(&[(\"a\".to_string(), Boolean(true))]).pretty().to_string(),\n-        \"\\\n-        {\\n  \\\n-            \\\"a\\\": true\\n\\\n-        }\"\n-    );\n-\n-    let complex_obj = mk_object(&[(\n-        \"b\".to_string(),\n-        Array(vec![\n-            mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-            mk_object(&[(\"d\".to_string(), String(\"\".to_string()))]),\n-        ]),\n-    )]);\n-\n-    assert_eq!(\n-        complex_obj.to_string(),\n-        \"{\\\n-            \\\"b\\\":[\\\n-                {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n-                {\\\"d\\\":\\\"\\\"}\\\n-            ]\\\n-        }\"\n-    );\n-    assert_eq!(\n-        complex_obj.pretty().to_string(),\n-        \"\\\n-        {\\n  \\\n-            \\\"b\\\": [\\n    \\\n-                {\\n      \\\n-                    \\\"c\\\": \\\"\\\\f\\\\r\\\"\\n    \\\n-                },\\n    \\\n-                {\\n      \\\n-                    \\\"d\\\": \\\"\\\"\\n    \\\n-                }\\n  \\\n-            ]\\n\\\n-        }\"\n-    );\n-\n-    let a = mk_object(&[\n-        (\"a\".to_string(), Boolean(true)),\n-        (\n-            \"b\".to_string(),\n-            Array(vec![\n-                mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                mk_object(&[(\"d\".to_string(), String(\"\".to_string()))]),\n-            ]),\n-        ),\n-    ]);\n-\n-    // We can't compare the strings directly because the object fields be\n-    // printed in a different order.\n-    assert_eq!(a.clone(), a.to_string().parse().unwrap());\n-    assert_eq!(a.clone(), a.pretty().to_string().parse().unwrap());\n-}\n-\n-#[test]\n-fn test_write_enum() {\n-    let animal = Dog;\n-    assert_eq!(json::as_json(&animal).to_string(), \"\\\"Dog\\\"\");\n-    assert_eq!(json::as_pretty_json(&animal).to_string(), \"\\\"Dog\\\"\");\n-\n-    let animal = Frog(\"Henry\".to_string(), 349);\n-    assert_eq!(\n-        json::as_json(&animal).to_string(),\n-        \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n-    );\n-    assert_eq!(\n-        json::as_pretty_json(&animal).to_string(),\n-        \"{\\n  \\\n-           \\\"variant\\\": \\\"Frog\\\",\\n  \\\n-           \\\"fields\\\": [\\n    \\\n-             \\\"Henry\\\",\\n    \\\n-             349\\n  \\\n-           ]\\n\\\n-         }\"\n-    );\n-}\n-\n-macro_rules! check_encoder_for_simple {\n-    ($value:expr, $expected:expr) => {{\n-        let s = json::as_json(&$value).to_string();\n-        assert_eq!(s, $expected);\n-\n-        let s = json::as_pretty_json(&$value).to_string();\n-        assert_eq!(s, $expected);\n-    }};\n-}\n-\n-#[test]\n-fn test_write_some() {\n-    check_encoder_for_simple!(Some(\"jodhpurs\".to_string()), \"\\\"jodhpurs\\\"\");\n-}\n-\n-#[test]\n-fn test_write_none() {\n-    check_encoder_for_simple!(None::<string::String>, \"null\");\n-}\n-\n-#[test]\n-fn test_write_char() {\n-    check_encoder_for_simple!('a', \"\\\"a\\\"\");\n-    check_encoder_for_simple!('\\t', \"\\\"\\\\t\\\"\");\n-    check_encoder_for_simple!('\\u{0000}', \"\\\"\\\\u0000\\\"\");\n-    check_encoder_for_simple!('\\u{001b}', \"\\\"\\\\u001b\\\"\");\n-    check_encoder_for_simple!('\\u{007f}', \"\\\"\\\\u007f\\\"\");\n-    check_encoder_for_simple!('\\u{00a0}', \"\\\"\\u{00a0}\\\"\");\n-    check_encoder_for_simple!('\\u{abcd}', \"\\\"\\u{abcd}\\\"\");\n-    check_encoder_for_simple!('\\u{10ffff}', \"\\\"\\u{10ffff}\\\"\");\n-}\n-\n-#[test]\n-fn test_trailing_characters() {\n-    assert_eq!(from_str(\"nulla\"), Err(SyntaxError(TrailingCharacters, 1, 5)));\n-    assert_eq!(from_str(\"truea\"), Err(SyntaxError(TrailingCharacters, 1, 5)));\n-    assert_eq!(from_str(\"falsea\"), Err(SyntaxError(TrailingCharacters, 1, 6)));\n-    assert_eq!(from_str(\"1a\"), Err(SyntaxError(TrailingCharacters, 1, 2)));\n-    assert_eq!(from_str(\"[]a\"), Err(SyntaxError(TrailingCharacters, 1, 3)));\n-    assert_eq!(from_str(\"{}a\"), Err(SyntaxError(TrailingCharacters, 1, 3)));\n-}\n-\n-#[test]\n-fn test_read_identifiers() {\n-    assert_eq!(from_str(\"n\"), Err(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(from_str(\"nul\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(from_str(\"t\"), Err(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(from_str(\"truz\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(from_str(\"f\"), Err(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(from_str(\"faz\"), Err(SyntaxError(InvalidSyntax, 1, 3)));\n-\n-    assert_eq!(from_str(\"null\"), Ok(Null));\n-    assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n-    assert_eq!(from_str(\"false\"), Ok(Boolean(false)));\n-    assert_eq!(from_str(\" null \"), Ok(Null));\n-    assert_eq!(from_str(\" true \"), Ok(Boolean(true)));\n-    assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n-}\n-\n-#[test]\n-fn test_read_number() {\n-    assert_eq!(from_str(\"+\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n-    assert_eq!(from_str(\".\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n-    assert_eq!(from_str(\"NaN\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n-    assert_eq!(from_str(\"-\"), Err(SyntaxError(InvalidNumber, 1, 2)));\n-    assert_eq!(from_str(\"00\"), Err(SyntaxError(InvalidNumber, 1, 2)));\n-    assert_eq!(from_str(\"1.\"), Err(SyntaxError(InvalidNumber, 1, 3)));\n-    assert_eq!(from_str(\"1e\"), Err(SyntaxError(InvalidNumber, 1, 3)));\n-    assert_eq!(from_str(\"1e+\"), Err(SyntaxError(InvalidNumber, 1, 4)));\n-\n-    assert_eq!(from_str(\"18446744073709551616\"), Err(SyntaxError(InvalidNumber, 1, 20)));\n-    assert_eq!(from_str(\"-9223372036854775809\"), Err(SyntaxError(InvalidNumber, 1, 21)));\n-\n-    assert_eq!(from_str(\"3\"), Ok(U64(3)));\n-    assert_eq!(from_str(\"3.1\"), Ok(F64(3.1)));\n-    assert_eq!(from_str(\"-1.2\"), Ok(F64(-1.2)));\n-    assert_eq!(from_str(\"0.4\"), Ok(F64(0.4)));\n-    assert_eq!(from_str(\"0.4e5\"), Ok(F64(0.4e5)));\n-    assert_eq!(from_str(\"0.4e+15\"), Ok(F64(0.4e15)));\n-    assert_eq!(from_str(\"0.4e-01\"), Ok(F64(0.4e-01)));\n-    assert_eq!(from_str(\" 3 \"), Ok(U64(3)));\n-\n-    assert_eq!(from_str(\"-9223372036854775808\"), Ok(I64(i64::MIN)));\n-    assert_eq!(from_str(\"9223372036854775807\"), Ok(U64(i64::MAX as u64)));\n-    assert_eq!(from_str(\"18446744073709551615\"), Ok(U64(u64::MAX)));\n-}\n-\n-#[test]\n-fn test_read_str() {\n-    assert_eq!(from_str(\"\\\"\"), Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n-    assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n-\n-    assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_string())));\n-    assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_string())));\n-    assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u{12ab}\".to_string())));\n-    assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\u{AB12}\".to_string())));\n-}\n-\n-#[test]\n-fn test_read_array() {\n-    assert_eq!(from_str(\"[\"), Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-    assert_eq!(from_str(\"[1\"), Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n-    assert_eq!(from_str(\"[1,\"), Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n-    assert_eq!(from_str(\"[1,]\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-\n-    assert_eq!(from_str(\"[]\"), Ok(Array(vec![])));\n-    assert_eq!(from_str(\"[ ]\"), Ok(Array(vec![])));\n-    assert_eq!(from_str(\"[true]\"), Ok(Array(vec![Boolean(true)])));\n-    assert_eq!(from_str(\"[ false ]\"), Ok(Array(vec![Boolean(false)])));\n-    assert_eq!(from_str(\"[null]\"), Ok(Array(vec![Null])));\n-    assert_eq!(from_str(\"[3, 1]\"), Ok(Array(vec![U64(3), U64(1)])));\n-    assert_eq!(from_str(\"\\n[3, 2]\\n\"), Ok(Array(vec![U64(3), U64(2)])));\n-    assert_eq!(from_str(\"[2, [4, 1]]\"), Ok(Array(vec![U64(2), Array(vec![U64(4), U64(1)])])));\n-}\n-\n-#[test]\n-fn test_read_object() {\n-    assert_eq!(from_str(\"{\"), Err(SyntaxError(EOFWhileParsingObject, 1, 2)));\n-    assert_eq!(from_str(\"{ \"), Err(SyntaxError(EOFWhileParsingObject, 1, 3)));\n-    assert_eq!(from_str(\"{1\"), Err(SyntaxError(KeyMustBeAString, 1, 2)));\n-    assert_eq!(from_str(\"{ \\\"a\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-    assert_eq!(from_str(\"{\\\"a\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 1, 5)));\n-    assert_eq!(from_str(\"{\\\"a\\\" \"), Err(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-\n-    assert_eq!(from_str(\"{\\\"a\\\" 1\"), Err(SyntaxError(ExpectedColon, 1, 6)));\n-    assert_eq!(from_str(\"{\\\"a\\\":\"), Err(SyntaxError(EOFWhileParsingValue, 1, 6)));\n-    assert_eq!(from_str(\"{\\\"a\\\":1\"), Err(SyntaxError(EOFWhileParsingObject, 1, 7)));\n-    assert_eq!(from_str(\"{\\\"a\\\":1 1\"), Err(SyntaxError(InvalidSyntax, 1, 8)));\n-    assert_eq!(from_str(\"{\\\"a\\\":1,\"), Err(SyntaxError(EOFWhileParsingObject, 1, 8)));\n-\n-    assert_eq!(from_str(\"{}\").unwrap(), mk_object(&[]));\n-    assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(), mk_object(&[(\"a\".to_string(), U64(3))]));\n-\n-    assert_eq!(\n-        from_str(\"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n-        mk_object(&[(\"a\".to_string(), Null), (\"b\".to_string(), Boolean(true))])\n-    );\n-    assert_eq!(\n-        from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n-        mk_object(&[(\"a\".to_string(), Null), (\"b\".to_string(), Boolean(true))])\n-    );\n-    assert_eq!(\n-        from_str(\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n-        mk_object(&[(\"a\".to_string(), F64(1.0)), (\"b\".to_string(), Array(vec![Boolean(true)]))])\n-    );\n-    assert_eq!(\n-        from_str(\n-            \"{\\\n-                        \\\"a\\\": 1.0, \\\n-                        \\\"b\\\": [\\\n-                            true,\\\n-                            \\\"foo\\\\nbar\\\", \\\n-                            { \\\"c\\\": {\\\"d\\\": null} } \\\n-                        ]\\\n-                    }\"\n-        )\n-        .unwrap(),\n-        mk_object(&[\n-            (\"a\".to_string(), F64(1.0)),\n-            (\n-                \"b\".to_string(),\n-                Array(vec![\n-                    Boolean(true),\n-                    String(\"foo\\nbar\".to_string()),\n-                    mk_object(&[(\"c\".to_string(), mk_object(&[(\"d\".to_string(), Null)]))])\n-                ])\n-            )\n-        ])\n-    );\n-}\n-\n-#[test]\n-fn test_multiline_errors() {\n-    assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 3, 8)));\n-}\n-\n-#[test]\n-fn test_find() {\n-    let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-    let found_str = json_value.find(\"dog\");\n-    assert!(found_str.unwrap().as_string().unwrap() == \"cat\");\n-}\n-\n-#[test]\n-fn test_find_path() {\n-    let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-    let found_str = json_value.find_path(&[\"dog\", \"cat\", \"mouse\"]);\n-    assert!(found_str.unwrap().as_string().unwrap() == \"cheese\");\n-}\n-\n-#[test]\n-fn test_search() {\n-    let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-    let found_str = json_value.search(\"mouse\").and_then(|j| j.as_string());\n-    assert!(found_str.unwrap() == \"cheese\");\n-}\n-\n-#[test]\n-fn test_index() {\n-    let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n-    let ref array = json_value[\"animals\"];\n-    assert_eq!(array[0].as_string().unwrap(), \"dog\");\n-    assert_eq!(array[1].as_string().unwrap(), \"cat\");\n-    assert_eq!(array[2].as_string().unwrap(), \"mouse\");\n-}\n-\n-#[test]\n-fn test_is_object() {\n-    let json_value = from_str(\"{}\").unwrap();\n-    assert!(json_value.is_object());\n-}\n-\n-#[test]\n-fn test_as_object() {\n-    let json_value = from_str(\"{}\").unwrap();\n-    let json_object = json_value.as_object();\n-    assert!(json_object.is_some());\n-}\n-\n-#[test]\n-fn test_is_array() {\n-    let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-    assert!(json_value.is_array());\n-}\n-\n-#[test]\n-fn test_as_array() {\n-    let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-    let json_array = json_value.as_array();\n-    let expected_length = 3;\n-    assert!(json_array.is_some() && json_array.unwrap().len() == expected_length);\n-}\n-\n-#[test]\n-fn test_is_string() {\n-    let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n-    assert!(json_value.is_string());\n-}\n-\n-#[test]\n-fn test_as_string() {\n-    let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n-    let json_str = json_value.as_string();\n-    let expected_str = \"dog\";\n-    assert_eq!(json_str, Some(expected_str));\n-}\n-\n-#[test]\n-fn test_is_number() {\n-    let json_value = from_str(\"12\").unwrap();\n-    assert!(json_value.is_number());\n-}\n-\n-#[test]\n-fn test_is_i64() {\n-    let json_value = from_str(\"-12\").unwrap();\n-    assert!(json_value.is_i64());\n-\n-    let json_value = from_str(\"12\").unwrap();\n-    assert!(!json_value.is_i64());\n-\n-    let json_value = from_str(\"12.0\").unwrap();\n-    assert!(!json_value.is_i64());\n-}\n-\n-#[test]\n-fn test_is_u64() {\n-    let json_value = from_str(\"12\").unwrap();\n-    assert!(json_value.is_u64());\n-\n-    let json_value = from_str(\"-12\").unwrap();\n-    assert!(!json_value.is_u64());\n-\n-    let json_value = from_str(\"12.0\").unwrap();\n-    assert!(!json_value.is_u64());\n-}\n-\n-#[test]\n-fn test_is_f64() {\n-    let json_value = from_str(\"12\").unwrap();\n-    assert!(!json_value.is_f64());\n-\n-    let json_value = from_str(\"-12\").unwrap();\n-    assert!(!json_value.is_f64());\n-\n-    let json_value = from_str(\"12.0\").unwrap();\n-    assert!(json_value.is_f64());\n-\n-    let json_value = from_str(\"-12.0\").unwrap();\n-    assert!(json_value.is_f64());\n-}\n-\n-#[test]\n-fn test_as_i64() {\n-    let json_value = from_str(\"-12\").unwrap();\n-    let json_num = json_value.as_i64();\n-    assert_eq!(json_num, Some(-12));\n-}\n-\n-#[test]\n-fn test_as_u64() {\n-    let json_value = from_str(\"12\").unwrap();\n-    let json_num = json_value.as_u64();\n-    assert_eq!(json_num, Some(12));\n-}\n-\n-#[test]\n-fn test_as_f64() {\n-    let json_value = from_str(\"12.0\").unwrap();\n-    let json_num = json_value.as_f64();\n-    assert_eq!(json_num, Some(12f64));\n-}\n-\n-#[test]\n-fn test_is_boolean() {\n-    let json_value = from_str(\"false\").unwrap();\n-    assert!(json_value.is_boolean());\n-}\n-\n-#[test]\n-fn test_as_boolean() {\n-    let json_value = from_str(\"false\").unwrap();\n-    let json_bool = json_value.as_boolean();\n-    let expected_bool = false;\n-    assert!(json_bool.is_some() && json_bool.unwrap() == expected_bool);\n-}\n-\n-#[test]\n-fn test_is_null() {\n-    let json_value = from_str(\"null\").unwrap();\n-    assert!(json_value.is_null());\n-}\n-\n-#[test]\n-fn test_as_null() {\n-    let json_value = from_str(\"null\").unwrap();\n-    let json_null = json_value.as_null();\n-    let expected_null = ();\n-    assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n-}\n-\n-#[test]\n-fn test_encode_hashmap_with_numeric_key() {\n-    use std::collections::HashMap;\n-    use std::str::from_utf8;\n-    let mut hm: HashMap<usize, bool> = HashMap::new();\n-    hm.insert(1, true);\n-    let mut mem_buf = Vec::new();\n-    write!(&mut mem_buf, \"{}\", json::as_pretty_json(&hm)).unwrap();\n-    let json_str = from_utf8(&mem_buf[..]).unwrap();\n-    match from_str(json_str) {\n-        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-        _ => {} // it parsed and we are good to go\n-    }\n-}\n-\n-#[test]\n-fn test_prettyencode_hashmap_with_numeric_key() {\n-    use std::collections::HashMap;\n-    use std::str::from_utf8;\n-    let mut hm: HashMap<usize, bool> = HashMap::new();\n-    hm.insert(1, true);\n-    let mut mem_buf = Vec::new();\n-    write!(&mut mem_buf, \"{}\", json::as_pretty_json(&hm)).unwrap();\n-    let json_str = from_utf8(&mem_buf[..]).unwrap();\n-    match from_str(json_str) {\n-        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-        _ => {} // it parsed and we are good to go\n-    }\n-}\n-\n-#[test]\n-fn test_prettyencoder_indent_level_param() {\n-    use std::collections::BTreeMap;\n-    use std::str::from_utf8;\n-\n-    let mut tree = BTreeMap::new();\n-\n-    tree.insert(\"hello\".to_string(), String(\"guten tag\".to_string()));\n-    tree.insert(\"goodbye\".to_string(), String(\"sayonara\".to_string()));\n-\n-    let json = Array(\n-        // The following layout below should look a lot like\n-        // the pretty-printed JSON (indent * x)\n-        vec![\n-            // 0x\n-            String(\"greetings\".to_string()), // 1x\n-            Object(tree),                    // 1x + 2x + 2x + 1x\n-        ], // 0x\n-           // End JSON array (7 lines)\n-    );\n-\n-    // Helper function for counting indents\n-    fn indents(source: &str) -> usize {\n-        let trimmed = source.trim_start_matches(' ');\n-        source.len() - trimmed.len()\n-    }\n-\n-    // Test up to 4 spaces of indents (more?)\n-    for i in 0..4 {\n-        let mut writer = Vec::new();\n-        write!(&mut writer, \"{}\", json::as_pretty_json(&json).indent(i)).unwrap();\n-\n-        let printed = from_utf8(&writer[..]).unwrap();\n-\n-        // Check for indents at each line\n-        let lines: Vec<&str> = printed.lines().collect();\n-        assert_eq!(lines.len(), 7); // JSON should be 7 lines\n-\n-        assert_eq!(indents(lines[0]), 0 * i); // [\n-        assert_eq!(indents(lines[1]), 1 * i); //   \"greetings\",\n-        assert_eq!(indents(lines[2]), 1 * i); //   {\n-        assert_eq!(indents(lines[3]), 2 * i); //     \"hello\": \"guten tag\",\n-        assert_eq!(indents(lines[4]), 2 * i); //     \"goodbye\": \"sayonara\"\n-        assert_eq!(indents(lines[5]), 1 * i); //   },\n-        assert_eq!(indents(lines[6]), 0 * i); // ]\n-\n-        // Finally, test that the pretty-printed JSON is valid\n-        from_str(printed).ok().expect(\"Pretty-printed JSON is invalid!\");\n-    }\n-}\n-\n-#[test]\n-fn test_hashmap_with_enum_key() {\n-    use std::collections::HashMap;\n-    #[derive(Encodable, Eq, Hash, PartialEq, Debug)]\n-    enum Enum {\n-        Foo,\n-        #[allow(dead_code)]\n-        Bar,\n-    }\n-    let mut map = HashMap::new();\n-    map.insert(Enum::Foo, 0);\n-    let result = json::encode(&map).unwrap();\n-    assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n-}\n-\n-fn assert_stream_equal(src: &str, expected: Vec<(JsonEvent, Vec<StackElement<'_>>)>) {\n-    let mut parser = Parser::new(src.chars());\n-    let mut i = 0;\n-    loop {\n-        let evt = match parser.next() {\n-            Some(e) => e,\n-            None => {\n-                break;\n-            }\n-        };\n-        let (ref expected_evt, ref expected_stack) = expected[i];\n-        if !parser.stack().is_equal_to(expected_stack) {\n-            panic!(\"Parser stack is not equal to {:?}\", expected_stack);\n-        }\n-        assert_eq!(&evt, expected_evt);\n-        i += 1;\n-    }\n-}\n-#[test]\n-fn test_streaming_parser() {\n-    assert_stream_equal(\n-        r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n-        vec![\n-            (ObjectStart, vec![]),\n-            (StringValue(\"bar\".to_string()), vec![StackElement::Key(\"foo\")]),\n-            (ArrayStart, vec![StackElement::Key(\"array\")]),\n-            (U64Value(0), vec![StackElement::Key(\"array\"), StackElement::Index(0)]),\n-            (U64Value(1), vec![StackElement::Key(\"array\"), StackElement::Index(1)]),\n-            (U64Value(2), vec![StackElement::Key(\"array\"), StackElement::Index(2)]),\n-            (U64Value(3), vec![StackElement::Key(\"array\"), StackElement::Index(3)]),\n-            (U64Value(4), vec![StackElement::Key(\"array\"), StackElement::Index(4)]),\n-            (U64Value(5), vec![StackElement::Key(\"array\"), StackElement::Index(5)]),\n-            (ArrayEnd, vec![StackElement::Key(\"array\")]),\n-            (ArrayStart, vec![StackElement::Key(\"idents\")]),\n-            (NullValue, vec![StackElement::Key(\"idents\"), StackElement::Index(0)]),\n-            (BooleanValue(true), vec![StackElement::Key(\"idents\"), StackElement::Index(1)]),\n-            (BooleanValue(false), vec![StackElement::Key(\"idents\"), StackElement::Index(2)]),\n-            (ArrayEnd, vec![StackElement::Key(\"idents\")]),\n-            (ObjectEnd, vec![]),\n-        ],\n-    );\n-}\n-fn last_event(src: &str) -> JsonEvent {\n-    let mut parser = Parser::new(src.chars());\n-    let mut evt = NullValue;\n-    loop {\n-        evt = match parser.next() {\n-            Some(e) => e,\n-            None => return evt,\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_read_object_streaming() {\n-    assert_eq!(last_event(\"{ \"), Error(SyntaxError(EOFWhileParsingObject, 1, 3)));\n-    assert_eq!(last_event(\"{1\"), Error(SyntaxError(KeyMustBeAString, 1, 2)));\n-    assert_eq!(last_event(\"{ \\\"a\\\"\"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-    assert_eq!(last_event(\"{\\\"a\\\"\"), Error(SyntaxError(EOFWhileParsingObject, 1, 5)));\n-    assert_eq!(last_event(\"{\\\"a\\\" \"), Error(SyntaxError(EOFWhileParsingObject, 1, 6)));\n-\n-    assert_eq!(last_event(\"{\\\"a\\\" 1\"), Error(SyntaxError(ExpectedColon, 1, 6)));\n-    assert_eq!(last_event(\"{\\\"a\\\":\"), Error(SyntaxError(EOFWhileParsingValue, 1, 6)));\n-    assert_eq!(last_event(\"{\\\"a\\\":1\"), Error(SyntaxError(EOFWhileParsingObject, 1, 7)));\n-    assert_eq!(last_event(\"{\\\"a\\\":1 1\"), Error(SyntaxError(InvalidSyntax, 1, 8)));\n-    assert_eq!(last_event(\"{\\\"a\\\":1,\"), Error(SyntaxError(EOFWhileParsingObject, 1, 8)));\n-    assert_eq!(last_event(\"{\\\"a\\\":1,}\"), Error(SyntaxError(TrailingComma, 1, 8)));\n-\n-    assert_stream_equal(\"{}\", vec![(ObjectStart, vec![]), (ObjectEnd, vec![])]);\n-    assert_stream_equal(\n-        \"{\\\"a\\\": 3}\",\n-        vec![\n-            (ObjectStart, vec![]),\n-            (U64Value(3), vec![StackElement::Key(\"a\")]),\n-            (ObjectEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"{ \\\"a\\\": null, \\\"b\\\" : true }\",\n-        vec![\n-            (ObjectStart, vec![]),\n-            (NullValue, vec![StackElement::Key(\"a\")]),\n-            (BooleanValue(true), vec![StackElement::Key(\"b\")]),\n-            (ObjectEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n-        vec![\n-            (ObjectStart, vec![]),\n-            (F64Value(1.0), vec![StackElement::Key(\"a\")]),\n-            (ArrayStart, vec![StackElement::Key(\"b\")]),\n-            (BooleanValue(true), vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n-            (ArrayEnd, vec![StackElement::Key(\"b\")]),\n-            (ObjectEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        r#\"{\n-            \"a\": 1.0,\n-            \"b\": [\n-                true,\n-                \"foo\\nbar\",\n-                { \"c\": {\"d\": null} }\n-            ]\n-        }\"#,\n-        vec![\n-            (ObjectStart, vec![]),\n-            (F64Value(1.0), vec![StackElement::Key(\"a\")]),\n-            (ArrayStart, vec![StackElement::Key(\"b\")]),\n-            (BooleanValue(true), vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n-            (\n-                StringValue(\"foo\\nbar\".to_string()),\n-                vec![StackElement::Key(\"b\"), StackElement::Index(1)],\n-            ),\n-            (ObjectStart, vec![StackElement::Key(\"b\"), StackElement::Index(2)]),\n-            (\n-                ObjectStart,\n-                vec![StackElement::Key(\"b\"), StackElement::Index(2), StackElement::Key(\"c\")],\n-            ),\n-            (\n-                NullValue,\n-                vec![\n-                    StackElement::Key(\"b\"),\n-                    StackElement::Index(2),\n-                    StackElement::Key(\"c\"),\n-                    StackElement::Key(\"d\"),\n-                ],\n-            ),\n-            (\n-                ObjectEnd,\n-                vec![StackElement::Key(\"b\"), StackElement::Index(2), StackElement::Key(\"c\")],\n-            ),\n-            (ObjectEnd, vec![StackElement::Key(\"b\"), StackElement::Index(2)]),\n-            (ArrayEnd, vec![StackElement::Key(\"b\")]),\n-            (ObjectEnd, vec![]),\n-        ],\n-    );\n-}\n-#[test]\n-fn test_read_array_streaming() {\n-    assert_stream_equal(\"[]\", vec![(ArrayStart, vec![]), (ArrayEnd, vec![])]);\n-    assert_stream_equal(\"[ ]\", vec![(ArrayStart, vec![]), (ArrayEnd, vec![])]);\n-    assert_stream_equal(\n-        \"[true]\",\n-        vec![\n-            (ArrayStart, vec![]),\n-            (BooleanValue(true), vec![StackElement::Index(0)]),\n-            (ArrayEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"[ false ]\",\n-        vec![\n-            (ArrayStart, vec![]),\n-            (BooleanValue(false), vec![StackElement::Index(0)]),\n-            (ArrayEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"[null]\",\n-        vec![(ArrayStart, vec![]), (NullValue, vec![StackElement::Index(0)]), (ArrayEnd, vec![])],\n-    );\n-    assert_stream_equal(\n-        \"[3, 1]\",\n-        vec![\n-            (ArrayStart, vec![]),\n-            (U64Value(3), vec![StackElement::Index(0)]),\n-            (U64Value(1), vec![StackElement::Index(1)]),\n-            (ArrayEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"\\n[3, 2]\\n\",\n-        vec![\n-            (ArrayStart, vec![]),\n-            (U64Value(3), vec![StackElement::Index(0)]),\n-            (U64Value(2), vec![StackElement::Index(1)]),\n-            (ArrayEnd, vec![]),\n-        ],\n-    );\n-    assert_stream_equal(\n-        \"[2, [4, 1]]\",\n-        vec![\n-            (ArrayStart, vec![]),\n-            (U64Value(2), vec![StackElement::Index(0)]),\n-            (ArrayStart, vec![StackElement::Index(1)]),\n-            (U64Value(4), vec![StackElement::Index(1), StackElement::Index(0)]),\n-            (U64Value(1), vec![StackElement::Index(1), StackElement::Index(1)]),\n-            (ArrayEnd, vec![StackElement::Index(1)]),\n-            (ArrayEnd, vec![]),\n-        ],\n-    );\n-\n-    assert_eq!(last_event(\"[\"), Error(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-\n-    assert_eq!(from_str(\"[\"), Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-    assert_eq!(from_str(\"[1\"), Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n-    assert_eq!(from_str(\"[1,\"), Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n-    assert_eq!(from_str(\"[1,]\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax, 1, 4)));\n-}\n-#[test]\n-fn test_trailing_characters_streaming() {\n-    assert_eq!(last_event(\"nulla\"), Error(SyntaxError(TrailingCharacters, 1, 5)));\n-    assert_eq!(last_event(\"truea\"), Error(SyntaxError(TrailingCharacters, 1, 5)));\n-    assert_eq!(last_event(\"falsea\"), Error(SyntaxError(TrailingCharacters, 1, 6)));\n-    assert_eq!(last_event(\"1a\"), Error(SyntaxError(TrailingCharacters, 1, 2)));\n-    assert_eq!(last_event(\"[]a\"), Error(SyntaxError(TrailingCharacters, 1, 3)));\n-    assert_eq!(last_event(\"{}a\"), Error(SyntaxError(TrailingCharacters, 1, 3)));\n-}\n-#[test]\n-fn test_read_identifiers_streaming() {\n-    assert_eq!(Parser::new(\"null\".chars()).next(), Some(NullValue));\n-    assert_eq!(Parser::new(\"true\".chars()).next(), Some(BooleanValue(true)));\n-    assert_eq!(Parser::new(\"false\".chars()).next(), Some(BooleanValue(false)));\n-\n-    assert_eq!(last_event(\"n\"), Error(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(last_event(\"nul\"), Error(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(last_event(\"t\"), Error(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(last_event(\"truz\"), Error(SyntaxError(InvalidSyntax, 1, 4)));\n-    assert_eq!(last_event(\"f\"), Error(SyntaxError(InvalidSyntax, 1, 2)));\n-    assert_eq!(last_event(\"faz\"), Error(SyntaxError(InvalidSyntax, 1, 3)));\n-}\n-\n-#[test]\n-fn test_to_json() {\n-    use json::ToJson;\n-    use std::collections::{BTreeMap, HashMap};\n-\n-    let array2 = Array(vec![U64(1), U64(2)]);\n-    let array3 = Array(vec![U64(1), U64(2), U64(3)]);\n-    let object = {\n-        let mut tree_map = BTreeMap::new();\n-        tree_map.insert(\"a\".to_string(), U64(1));\n-        tree_map.insert(\"b\".to_string(), U64(2));\n-        Object(tree_map)\n-    };\n-\n-    assert_eq!(array2.to_json(), array2);\n-    assert_eq!(object.to_json(), object);\n-    assert_eq!(3_isize.to_json(), I64(3));\n-    assert_eq!(4_i8.to_json(), I64(4));\n-    assert_eq!(5_i16.to_json(), I64(5));\n-    assert_eq!(6_i32.to_json(), I64(6));\n-    assert_eq!(7_i64.to_json(), I64(7));\n-    assert_eq!(8_usize.to_json(), U64(8));\n-    assert_eq!(9_u8.to_json(), U64(9));\n-    assert_eq!(10_u16.to_json(), U64(10));\n-    assert_eq!(11_u32.to_json(), U64(11));\n-    assert_eq!(12_u64.to_json(), U64(12));\n-    assert_eq!(13.0_f32.to_json(), F64(13.0_f64));\n-    assert_eq!(14.0_f64.to_json(), F64(14.0_f64));\n-    assert_eq!(().to_json(), Null);\n-    assert_eq!(f32::INFINITY.to_json(), Null);\n-    assert_eq!(f64::NAN.to_json(), Null);\n-    assert_eq!(true.to_json(), Boolean(true));\n-    assert_eq!(false.to_json(), Boolean(false));\n-    assert_eq!(\"abc\".to_json(), String(\"abc\".to_string()));\n-    assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n-    assert_eq!((1_usize, 2_usize).to_json(), array2);\n-    assert_eq!((1_usize, 2_usize, 3_usize).to_json(), array3);\n-    assert_eq!([1_usize, 2_usize].to_json(), array2);\n-    assert_eq!((&[1_usize, 2_usize, 3_usize]).to_json(), array3);\n-    assert_eq!((vec![1_usize, 2_usize]).to_json(), array2);\n-    assert_eq!(vec![1_usize, 2_usize, 3_usize].to_json(), array3);\n-    let mut tree_map = BTreeMap::new();\n-    tree_map.insert(\"a\".to_string(), 1 as usize);\n-    tree_map.insert(\"b\".to_string(), 2);\n-    assert_eq!(tree_map.to_json(), object);\n-    let mut hash_map = HashMap::new();\n-    hash_map.insert(\"a\".to_string(), 1 as usize);\n-    hash_map.insert(\"b\".to_string(), 2);\n-    assert_eq!(hash_map.to_json(), object);\n-    assert_eq!(Some(15).to_json(), I64(15));\n-    assert_eq!(Some(15 as usize).to_json(), U64(15));\n-    assert_eq!(None::<isize>.to_json(), Null);\n-}\n-\n-#[test]\n-fn test_encode_hashmap_with_arbitrary_key() {\n-    use std::collections::HashMap;\n-    #[derive(PartialEq, Eq, Hash, Encodable)]\n-    struct ArbitraryType(usize);\n-    let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n-    hm.insert(ArbitraryType(1), true);\n-    let mut mem_buf = string::String::new();\n-    let mut encoder = Encoder::new(&mut mem_buf);\n-    let result = hm.encode(&mut encoder);\n-    match result.unwrap_err() {\n-        EncoderError::BadHashmapKey => (),\n-        _ => panic!(\"expected bad hash map key\"),\n-    }\n-}"}]}