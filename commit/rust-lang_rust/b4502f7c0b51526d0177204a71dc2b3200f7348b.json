{"sha": "b4502f7c0b51526d0177204a71dc2b3200f7348b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NTAyZjdjMGI1MTUyNmQwMTc3MjA0YTcxZGMyYjMyMDBmNzM0OGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-15T02:22:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-15T02:22:11Z"}, "message": "Auto merge of #43184 - nikomatsakis:incr-comp-anonymize-trait-selection, r=michaelwoerister\n\nintegrate anon dep nodes into trait selection\n\nUse anonymous nodes for trait selection. In all cases, we use the same basic \"memoization\" strategy:\n\n- Store the `DepNodeIndex` in the slot along with value.\n- If value is present, return it, and add a read of the dep-node-index.\n- Else, start an anonymous task, and store resulting node.\n\nWe apply this strategy to a number of caches in trait selection:\n\n- The \"trans\" caches of selection and projection\n- The \"evaluation\" cache\n- The \"candidate selection\" cache\n\nIn general, for our cache strategy to be \"dep-correct\", the computation of the value is permitted to rely on the *value in the key* but nothing else. The basic argument is this: in order to look something up, you have to produce the key, and to do that you must have whatever reads were needed to create the key. Then, you get whatever reads were further needed to produce the value. But if the \"closure\" that produced the value made use of *other* environmental data, not derivable from the key, that would be bad -- but that would **also** suggest that the cache is messed up (though it's not proof).\n\nThe structure of these caches do not obviously prove that the correctness criteria are met, and I aim to address that in further refactorings. But I *believe* it to be the case that, if we assume that the existing caches are correct, there are also no dependency failures (in other words, if there's a bug, it's a pre-existing one). Specifically:\n\n- The trans caches: these take as input just a `tcx`, which is \"by definition\" not leaky, the `trait-ref` etc, which is part of the key, and sometimes a span (doesn't influence the result). So they seem fine.\n- The evaluation cache:\n    - This computation takes as input the \"stack\" and has access to the infcx.\n    - The infcx is a problem -- would be better to take the tcx -- and this is exactly one of the things I plan to improve in later PRs. Let's ignore it for now. =)\n    - The stack itself is also not great, in that the *key* only consists of the top-entry in the stack.\n    - However, the stack can cause a problem in two ways:\n        - overflow (we panic)\n        - cycle check fails (we do not update the cache, I believe)\n- The candidate selection cache:\n    - as before, takes the \"stack\" and has access to the infcx.\n    - here it is not as obvious that we avoid caching stack-dependent computations. However, to the extent that we do, this is a pre-existing bug, in that we are making cache entries we shouldn't.\n    - I aim to resolve this by -- following the chalk-style of evaluation -- merging candidate selection and evaluation.\n    - The infcx is a problem -- would be better to take the tcx -- and this is exactly one of the things I plan to improve in later PRs. Let's ignore it for now. =)\n    - The stack itself is also not great, in that the *key* only consists of the top-entry in the stack.\n    - Moreover, the stack would generally just introduce ambiguities and errors anyhow, so that lessens the risk.\n\nAnyway, the existing approach to handle dependencies in the trait code carries the same risks or worse, so this seems like a strict improvement!\n\nr? @michaelwoerister\n\ncc @arielb1", "tree": {"sha": "4e78cb0ec3dcf090487c6c1fbc1f89321269695f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e78cb0ec3dcf090487c6c1fbc1f89321269695f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4502f7c0b51526d0177204a71dc2b3200f7348b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4502f7c0b51526d0177204a71dc2b3200f7348b", "html_url": "https://github.com/rust-lang/rust/commit/b4502f7c0b51526d0177204a71dc2b3200f7348b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4502f7c0b51526d0177204a71dc2b3200f7348b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23ecebd6bd4362142ac586014aec44070a177a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/23ecebd6bd4362142ac586014aec44070a177a3d", "html_url": "https://github.com/rust-lang/rust/commit/23ecebd6bd4362142ac586014aec44070a177a3d"}, {"sha": "4f030d04f499f650e54ef947799fe6cef20fb380", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f030d04f499f650e54ef947799fe6cef20fb380", "html_url": "https://github.com/rust-lang/rust/commit/4f030d04f499f650e54ef947799fe6cef20fb380"}], "stats": {"total": 203, "additions": 83, "deletions": 120}, "files": [{"sha": "8e2c44a427b7099da78d94f6db0ee79b221604c3", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b4502f7c0b51526d0177204a71dc2b3200f7348b", "patch": "@@ -495,7 +495,7 @@ define_dep_nodes!( <'tcx>\n     // imprecision in our dep-graph tracking.  The important thing is\n     // that for any given trait-ref, we always map to the **same**\n     // trait-select node.\n-    [] TraitSelect { trait_def_id: DefId, input_def_id: DefId },\n+    [anon] TraitSelect,\n \n     // For proj. cache, we just keep a list of all def-ids, since it is\n     // not a hotspot."}, {"sha": "2d19b34c5040ef01124506fd282bbdfd9cf7d336", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=b4502f7c0b51526d0177204a71dc2b3200f7348b", "patch": "@@ -12,24 +12,23 @@ use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n use std::hash::Hash;\n use std::marker::PhantomData;\n-use ty::TyCtxt;\n use util::common::MemoizationMap;\n \n-use super::{DepNode, DepGraph};\n+use super::{DepKind, DepNodeIndex, DepGraph};\n \n /// A DepTrackingMap offers a subset of the `Map` API and ensures that\n /// we make calls to `read` and `write` as appropriate. We key the\n /// maps with a unique type for brevity.\n pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n     phantom: PhantomData<M>,\n     graph: DepGraph,\n-    map: FxHashMap<M::Key, M::Value>,\n+    map: FxHashMap<M::Key, (M::Value, DepNodeIndex)>,\n }\n \n pub trait DepTrackingMapConfig {\n     type Key: Eq + Hash + Clone;\n     type Value: Clone;\n-    fn to_dep_node(tcx: TyCtxt, key: &Self::Key) -> DepNode;\n+    fn to_dep_kind() -> DepKind;\n }\n \n impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n@@ -40,27 +39,6 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n             map: FxHashMap(),\n         }\n     }\n-\n-    /// Registers a (synthetic) read from the key `k`. Usually this\n-    /// is invoked automatically by `get`.\n-    fn read(&self, tcx: TyCtxt, k: &M::Key) {\n-        let dep_node = M::to_dep_node(tcx, k);\n-        self.graph.read(dep_node);\n-    }\n-\n-    pub fn get(&self, tcx: TyCtxt, k: &M::Key) -> Option<&M::Value> {\n-        self.read(tcx, k);\n-        self.map.get(k)\n-    }\n-\n-    pub fn contains_key(&self, tcx: TyCtxt, k: &M::Key) -> bool {\n-        self.read(tcx, k);\n-        self.map.contains_key(k)\n-    }\n-\n-    pub fn keys(&self) -> Vec<M::Key> {\n-        self.map.keys().cloned().collect()\n-    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n@@ -98,22 +76,22 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     /// The key is the line marked `(*)`: the closure implicitly\n     /// accesses the body of the item `item`, so we register a read\n     /// from `Hir(item_def_id)`.\n-    fn memoize<OP>(&self, tcx: TyCtxt, key: M::Key, op: OP) -> M::Value\n+    fn memoize<OP>(&self, key: M::Key, op: OP) -> M::Value\n         where OP: FnOnce() -> M::Value\n     {\n         let graph;\n         {\n             let this = self.borrow();\n-            if let Some(result) = this.map.get(&key) {\n-                this.read(tcx, &key);\n+            if let Some(&(ref result, dep_node)) = this.map.get(&key) {\n+                this.graph.read_index(dep_node);\n                 return result.clone();\n             }\n             graph = this.graph.clone();\n         }\n \n-        let _task = graph.in_task(M::to_dep_node(tcx, &key));\n-        let result = op();\n-        self.borrow_mut().map.insert(key, result.clone());\n+        let (result, dep_node) = graph.with_anon_task(M::to_dep_kind(), op);\n+        self.borrow_mut().map.insert(key, (result.clone(), dep_node));\n+        graph.read_index(dep_node);\n         result\n     }\n }"}, {"sha": "c690bebed8c00f09404b1780fd688d53b62b6425", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b4502f7c0b51526d0177204a71dc2b3200f7348b", "patch": "@@ -30,6 +30,7 @@ use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n             VtableClosureData, VtableDefaultImplData, VtableFnPointerData};\n use super::util;\n \n+use dep_graph::{DepNodeIndex, DepKind};\n use hir::def_id::DefId;\n use infer;\n use infer::{InferCtxt, InferOk, TypeFreshener};\n@@ -105,7 +106,7 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n #[derive(Clone)]\n pub struct SelectionCache<'tcx> {\n     hashmap: RefCell<FxHashMap<ty::TraitRef<'tcx>,\n-                               SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n+                               WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>>>,\n }\n \n /// The selection process begins by considering all impls, where\n@@ -369,7 +370,7 @@ impl EvaluationResult {\n \n #[derive(Clone)]\n pub struct EvaluationCache<'tcx> {\n-    hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n+    hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, WithDepNode<EvaluationResult>>>\n }\n \n impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n@@ -466,8 +467,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let tcx = self.tcx();\n-        let dep_node = obligation.predicate.dep_node(tcx);\n-        let _task = tcx.dep_graph.in_task(dep_node);\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         let ret = match self.candidate_from_obligation(&stack)? {\n@@ -710,12 +709,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return result;\n         }\n \n-        let result = self.evaluate_stack(&stack);\n+        let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n \n         debug!(\"CACHE MISS: EVAL({:?})={:?}\",\n                fresh_trait_ref,\n                result);\n-        self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, result);\n+        self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n \n         result\n     }\n@@ -870,22 +869,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                               trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Option<EvaluationResult>\n     {\n+        let tcx = self.tcx();\n         if self.can_use_global_caches(param_env) {\n-            let cache = self.tcx().evaluation_cache.hashmap.borrow();\n+            let cache = tcx.evaluation_cache.hashmap.borrow();\n             if let Some(cached) = cache.get(&trait_ref) {\n-                let dep_node = trait_ref\n-                    .to_poly_trait_predicate()\n-                    .dep_node(self.tcx());\n-                self.tcx().hir.dep_graph.read(dep_node);\n-                return Some(cached.clone());\n+                return Some(cached.get(tcx));\n             }\n         }\n-        self.infcx.evaluation_cache.hashmap.borrow().get(&trait_ref).cloned()\n+        self.infcx.evaluation_cache.hashmap\n+                                   .borrow()\n+                                   .get(&trait_ref)\n+                                   .map(|v| v.get(tcx))\n     }\n \n     fn insert_evaluation_cache(&mut self,\n                                param_env: ty::ParamEnv<'tcx>,\n                                trait_ref: ty::PolyTraitRef<'tcx>,\n+                               dep_node: DepNodeIndex,\n                                result: EvaluationResult)\n     {\n         // Avoid caching results that depend on more than just the trait-ref:\n@@ -902,12 +902,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         if self.can_use_global_caches(param_env) {\n             let mut cache = self.tcx().evaluation_cache.hashmap.borrow_mut();\n             if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n-                cache.insert(trait_ref, result);\n+                cache.insert(trait_ref, WithDepNode::new(dep_node, result));\n                 return;\n             }\n         }\n \n-        self.infcx.evaluation_cache.hashmap.borrow_mut().insert(trait_ref, result);\n+        self.infcx.evaluation_cache.hashmap\n+                                   .borrow_mut()\n+                                   .insert(trait_ref, WithDepNode::new(dep_node, result));\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -949,19 +951,32 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         // If no match, compute result and insert into cache.\n-        let candidate = self.candidate_from_obligation_no_cache(stack);\n+        let (candidate, dep_node) = self.in_task(|this| {\n+            this.candidate_from_obligation_no_cache(stack)\n+        });\n \n         if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n             debug!(\"CACHE MISS: SELECT({:?})={:?}\",\n                    cache_fresh_trait_pred, candidate);\n             self.insert_candidate_cache(stack.obligation.param_env,\n                                         cache_fresh_trait_pred,\n+                                        dep_node,\n                                         candidate.clone());\n         }\n \n         candidate\n     }\n \n+    fn in_task<OP, R>(&mut self, op: OP) -> (R, DepNodeIndex)\n+        where OP: FnOnce(&mut Self) -> R\n+    {\n+        let (result, dep_node) = self.tcx().dep_graph.with_anon_task(DepKind::TraitSelect, || {\n+            op(self)\n+        });\n+        self.tcx().dep_graph.read_index(dep_node);\n+        (result, dep_node)\n+    }\n+\n     // Treat negative impls as unimplemented\n     fn filter_negative_impls(&self, candidate: SelectionCandidate<'tcx>)\n                              -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n@@ -1151,33 +1166,41 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                              cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n                              -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>>\n     {\n+        let tcx = self.tcx();\n         let trait_ref = &cache_fresh_trait_pred.0.trait_ref;\n         if self.can_use_global_caches(param_env) {\n-            let cache = self.tcx().selection_cache.hashmap.borrow();\n+            let cache = tcx.selection_cache.hashmap.borrow();\n             if let Some(cached) = cache.get(&trait_ref) {\n-                return Some(cached.clone());\n+                return Some(cached.get(tcx));\n             }\n         }\n-        self.infcx.selection_cache.hashmap.borrow().get(trait_ref).cloned()\n+        self.infcx.selection_cache.hashmap\n+                                  .borrow()\n+                                  .get(trait_ref)\n+                                  .map(|v| v.get(tcx))\n     }\n \n     fn insert_candidate_cache(&mut self,\n                               param_env: ty::ParamEnv<'tcx>,\n                               cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+                              dep_node: DepNodeIndex,\n                               candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n     {\n+        let tcx = self.tcx();\n         let trait_ref = cache_fresh_trait_pred.0.trait_ref;\n         if self.can_use_global_caches(param_env) {\n-            let mut cache = self.tcx().selection_cache.hashmap.borrow_mut();\n-            if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n-                if let Some(candidate) = self.tcx().lift_to_global(&candidate) {\n-                    cache.insert(trait_ref, candidate);\n+            let mut cache = tcx.selection_cache.hashmap.borrow_mut();\n+            if let Some(trait_ref) = tcx.lift_to_global(&trait_ref) {\n+                if let Some(candidate) = tcx.lift_to_global(&candidate) {\n+                    cache.insert(trait_ref, WithDepNode::new(dep_node, candidate));\n                     return;\n                 }\n             }\n         }\n \n-        self.infcx.selection_cache.hashmap.borrow_mut().insert(trait_ref, candidate);\n+        self.infcx.selection_cache.hashmap\n+                                  .borrow_mut()\n+                                  .insert(trait_ref, WithDepNode::new(dep_node, candidate));\n     }\n \n     fn should_update_candidate_cache(&mut self,\n@@ -3138,3 +3161,20 @@ impl<'o,'tcx> fmt::Debug for TraitObligationStack<'o,'tcx> {\n         write!(f, \"TraitObligationStack({:?})\", self.obligation)\n     }\n }\n+\n+#[derive(Clone)]\n+pub struct WithDepNode<T> {\n+    dep_node: DepNodeIndex,\n+    cached_value: T\n+}\n+\n+impl<T: Clone> WithDepNode<T> {\n+    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n+        WithDepNode { dep_node, cached_value }\n+    }\n+\n+    pub fn get(&self, tcx: TyCtxt) -> T {\n+        tcx.dep_graph.read_index(self.dep_node);\n+        self.cached_value.clone()\n+    }\n+}"}, {"sha": "827a5092c00420e6a5c47355e2caad3b7d3fbd9d", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=b4502f7c0b51526d0177204a71dc2b3200f7348b", "patch": "@@ -13,9 +13,7 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig,\n-                DepConstructor};\n-use hir::def_id::DefId;\n+use dep_graph::{DepGraph, DepKind, DepTrackingMap, DepTrackingMapConfig};\n use infer::TransNormalize;\n use std::cell::RefCell;\n use std::marker::PhantomData;\n@@ -41,7 +39,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         // Remove any references to regions; this helps improve caching.\n         let trait_ref = self.erase_regions(&trait_ref);\n \n-        self.trans_trait_caches.trait_cache.memoize(self, trait_ref, || {\n+        self.trans_trait_caches.trait_cache.memoize(trait_ref, || {\n             debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n                    trait_ref, trait_ref.def_id());\n \n@@ -139,7 +137,7 @@ impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n         if !ty.has_projection_types() {\n             ty\n         } else {\n-            self.tcx.trans_trait_caches.project_cache.memoize(self.tcx, ty, || {\n+            self.tcx.trans_trait_caches.project_cache.memoize(ty, || {\n                 debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n                 self.tcx.normalize_associated_type(&ty)\n             })\n@@ -171,8 +169,8 @@ pub struct TraitSelectionCache<'tcx> {\n impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n     type Key = ty::PolyTraitRef<'tcx>;\n     type Value = Vtable<'tcx, ()>;\n-    fn to_dep_node(tcx: TyCtxt, key: &ty::PolyTraitRef<'tcx>) -> DepNode {\n-        key.to_poly_trait_predicate().dep_node(tcx)\n+    fn to_dep_kind() -> DepKind {\n+        DepKind::TraitSelect\n     }\n }\n \n@@ -185,31 +183,8 @@ pub struct ProjectionCache<'gcx> {\n impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n     type Key = Ty<'gcx>;\n     type Value = Ty<'gcx>;\n-    fn to_dep_node(tcx: TyCtxt, key: &Self::Key) -> DepNode {\n-        // Ideally, we'd just put `key` into the dep-node, but we\n-        // can't put full types in there. So just collect up all the\n-        // def-ids of structs/enums as well as any traits that we\n-        // project out of. It doesn't matter so much what we do here,\n-        // except that if we are too coarse, we'll create overly\n-        // coarse edges between impls and the trans. For example, if\n-        // we just used the def-id of things we are projecting out of,\n-        // then the key for `<Foo as SomeTrait>::T` and `<Bar as\n-        // SomeTrait>::T` would both share a dep-node\n-        // (`TraitSelect(SomeTrait)`), and hence the impls for both\n-        // `Foo` and `Bar` would be considered inputs. So a change to\n-        // `Bar` would affect things that just normalized `Foo`.\n-        // Anyway, this heuristic is not ideal, but better than\n-        // nothing.\n-        let def_ids: Vec<DefId> =\n-            key.walk()\n-               .filter_map(|t| match t.sty {\n-                    ty::TyAdt(adt_def, _) => Some(adt_def.did),\n-                    ty::TyProjection(ref proj) => Some(proj.item_def_id),\n-                    _ => None,\n-               })\n-               .collect();\n-\n-        DepNode::new(tcx, DepConstructor::ProjectionCache { def_ids: def_ids })\n+    fn to_dep_kind() -> DepKind {\n+        DepKind::TraitSelect\n     }\n }\n "}, {"sha": "5aaba526e265f8a40b5494f0a49cb7dc592de58d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b4502f7c0b51526d0177204a71dc2b3200f7348b", "patch": "@@ -15,7 +15,6 @@ pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n-use dep_graph::{DepNode, DepConstructor};\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -947,28 +946,6 @@ impl<'tcx> TraitPredicate<'tcx> {\n         self.trait_ref.def_id\n     }\n \n-    /// Creates the dep-node for selecting/evaluating this trait reference.\n-    fn dep_node(&self, tcx: TyCtxt) -> DepNode {\n-        // Extact the trait-def and first def-id from inputs.  See the\n-        // docs for `DepNode::TraitSelect` for more information.\n-        let trait_def_id = self.def_id();\n-        let input_def_id =\n-            self.input_types()\n-                .flat_map(|t| t.walk())\n-                .filter_map(|t| match t.sty {\n-                    ty::TyAdt(adt_def, ..) => Some(adt_def.did),\n-                    ty::TyClosure(def_id, ..) => Some(def_id),\n-                    ty::TyFnDef(def_id, ..) => Some(def_id),\n-                    _ => None\n-                })\n-                .next()\n-                .unwrap_or(trait_def_id);\n-        DepNode::new(tcx, DepConstructor::TraitSelect {\n-            trait_def_id,\n-            input_def_id,\n-        })\n-    }\n-\n     pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         self.trait_ref.input_types()\n     }\n@@ -983,11 +960,6 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n         // ok to skip binder since trait def-id does not care about regions\n         self.0.def_id()\n     }\n-\n-    pub fn dep_node(&self, tcx: TyCtxt) -> DepNode {\n-        // ok to skip binder since depnode does not care about regions\n-        self.0.dep_node(tcx)\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "17564671a1e364f45eed26442e33e6b9e8231b06", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4502f7c0b51526d0177204a71dc2b3200f7348b/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=b4502f7c0b51526d0177204a71dc2b3200f7348b", "patch": "@@ -19,8 +19,6 @@ use std::iter::repeat;\n use std::path::Path;\n use std::time::{Duration, Instant};\n \n-use ty::TyCtxt;\n-\n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -211,7 +209,7 @@ pub trait MemoizationMap {\n     /// needed in the `op` to ensure that the correct edges are\n     /// added into the dep graph. See the `DepTrackingMap` impl for\n     /// more details!\n-    fn memoize<OP>(&self, tcx: TyCtxt, key: Self::Key, op: OP) -> Self::Value\n+    fn memoize<OP>(&self, key: Self::Key, op: OP) -> Self::Value\n         where OP: FnOnce() -> Self::Value;\n }\n \n@@ -221,7 +219,7 @@ impl<K, V, S> MemoizationMap for RefCell<HashMap<K,V,S>>\n     type Key = K;\n     type Value = V;\n \n-    fn memoize<OP>(&self, _tcx: TyCtxt, key: K, op: OP) -> V\n+    fn memoize<OP>(&self, key: K, op: OP) -> V\n         where OP: FnOnce() -> V\n     {\n         let result = self.borrow().get(&key).cloned();"}]}