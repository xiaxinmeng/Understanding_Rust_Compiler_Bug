{"sha": "f81d253c07e0f3560f58dffed0a2015d147236b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MWQyNTNjMDdlMGYzNTYwZjU4ZGZmZWQwYTIwMTVkMTQ3MjM2YjA=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-06-22T11:06:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-22T11:06:12Z"}, "message": "Merge pull request #995 from oli-obk/oh_the_horror\n\nlint on `filter(x).map(y)`, `filter(x).flat_map(y)`, `filter_map(x).flat_map(y)`", "tree": {"sha": "5167765d0a05cc272441838e56d7481aad066ed4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5167765d0a05cc272441838e56d7481aad066ed4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f81d253c07e0f3560f58dffed0a2015d147236b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f81d253c07e0f3560f58dffed0a2015d147236b0", "html_url": "https://github.com/rust-lang/rust/commit/f81d253c07e0f3560f58dffed0a2015d147236b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f81d253c07e0f3560f58dffed0a2015d147236b0/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "294aeaf4b3246b8976acf454c85f851c6e3520b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/294aeaf4b3246b8976acf454c85f851c6e3520b1", "html_url": "https://github.com/rust-lang/rust/commit/294aeaf4b3246b8976acf454c85f851c6e3520b1"}, {"sha": "262148c946187dd69e2d875360c45fc4cbd9becf", "url": "https://api.github.com/repos/rust-lang/rust/commits/262148c946187dd69e2d875360c45fc4cbd9becf", "html_url": "https://github.com/rust-lang/rust/commit/262148c946187dd69e2d875360c45fc4cbd9becf"}], "stats": {"total": 170, "additions": 131, "deletions": 39}, "files": [{"sha": "728ed347da27dd82a6f30ca73d107e6eb32f58be", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f81d253c07e0f3560f58dffed0a2015d147236b0/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f81d253c07e0f3560f58dffed0a2015d147236b0/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=f81d253c07e0f3560f58dffed0a2015d147236b0", "patch": "@@ -158,6 +158,7 @@ All notable changes to this project will be documented in this file.\n [`explicit_counter_loop`]: https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop\n [`explicit_iter_loop`]: https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop\n [`extend_from_slice`]: https://github.com/Manishearth/rust-clippy/wiki#extend_from_slice\n+[`filter_map`]: https://github.com/Manishearth/rust-clippy/wiki#filter_map\n [`filter_next`]: https://github.com/Manishearth/rust-clippy/wiki#filter_next\n [`float_arithmetic`]: https://github.com/Manishearth/rust-clippy/wiki#float_arithmetic\n [`float_cmp`]: https://github.com/Manishearth/rust-clippy/wiki#float_cmp"}, {"sha": "d210a1b218ff10b63e6650547ec5e709d08c2d6d", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f81d253c07e0f3560f58dffed0a2015d147236b0/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f81d253c07e0f3560f58dffed0a2015d147236b0/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f81d253c07e0f3560f58dffed0a2015d147236b0", "patch": "@@ -17,7 +17,7 @@ Table of contents:\n \n ## Lints\n \n-There are 154 lints included in this crate:\n+There are 155 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -60,6 +60,7 @@ name\n [explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)                       | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n [explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)                             | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n [extend_from_slice](https://github.com/Manishearth/rust-clippy/wiki#extend_from_slice)                               | warn    | `.extend_from_slice(_)` is a faster way to extend a Vec by a slice\n+[filter_map](https://github.com/Manishearth/rust-clippy/wiki#filter_map)                                             | allow   | using combinations of `filter`, `map`, `filter_map` and `flat_map` which can usually be written as a single method call\n [filter_next](https://github.com/Manishearth/rust-clippy/wiki#filter_next)                                           | warn    | using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\n [float_arithmetic](https://github.com/Manishearth/rust-clippy/wiki#float_arithmetic)                                 | allow   | Any floating-point arithmetic statement\n [float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                               | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)"}, {"sha": "835823b8cd31d114937e6bd50ec0c853d1e30be9", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f81d253c07e0f3560f58dffed0a2015d147236b0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f81d253c07e0f3560f58dffed0a2015d147236b0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f81d253c07e0f3560f58dffed0a2015d147236b0", "patch": "@@ -268,6 +268,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         items_after_statements::ITEMS_AFTER_STATEMENTS,\n         matches::SINGLE_MATCH_ELSE,\n         mem_forget::MEM_FORGET,\n+        methods::FILTER_MAP,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::WRONG_PUB_SELF_CONVENTION,"}, {"sha": "dc5df87402019f581ad48c61308abcbebc7c7908", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f81d253c07e0f3560f58dffed0a2015d147236b0/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f81d253c07e0f3560f58dffed0a2015d147236b0/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=f81d253c07e0f3560f58dffed0a2015d147236b0", "patch": "@@ -71,19 +71,17 @@ enum RefLt {\n     Named(Name),\n }\n \n-fn bound_lifetimes(bound: &TyParamBound) -> Option<HirVec<&Lifetime>> {\n+fn bound_lifetimes(bound: &TyParamBound) -> HirVec<&Lifetime> {\n     if let TraitTyParamBound(ref trait_ref, _) = *bound {\n-        let lt = trait_ref.trait_ref\n-                          .path\n-                          .segments\n-                          .last()\n-                          .expect(\"a path must have at least one segment\")\n-                          .parameters\n-                          .lifetimes();\n-\n-        Some(lt)\n+        trait_ref.trait_ref\n+                 .path\n+                 .segments\n+                 .last()\n+                 .expect(\"a path must have at least one segment\")\n+                 .parameters\n+                 .lifetimes()\n     } else {\n-        None\n+        HirVec::new()\n     }\n }\n \n@@ -94,7 +92,7 @@ fn check_fn_inner(cx: &LateContext, decl: &FnDecl, generics: &Generics, span: Sp\n \n     let bounds_lts = generics.ty_params\n                              .iter()\n-                             .flat_map(|ref typ| typ.bounds.iter().filter_map(bound_lifetimes).flat_map(|lts| lts));\n+                             .flat_map(|typ| typ.bounds.iter().flat_map(bound_lifetimes));\n \n     if could_use_elision(cx, decl, &generics.lifetimes, bounds_lts) {\n         span_lint(cx,"}, {"sha": "e578fbf6d68ca3fbbc6d747d273582d266194a36", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f81d253c07e0f3560f58dffed0a2015d147236b0/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f81d253c07e0f3560f58dffed0a2015d147236b0/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=f81d253c07e0f3560f58dffed0a2015d147236b0", "patch": "@@ -334,31 +334,30 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n /// Get all arms that are unbounded `PatRange`s.\n fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n     arms.iter()\n-        .filter_map(|arm| {\n+        .flat_map(|arm| {\n             if let Arm { ref pats, guard: None, .. } = *arm {\n-                Some(pats.iter().filter_map(|pat| {\n-                    if_let_chain! {[\n-                        let PatKind::Range(ref lhs, ref rhs) = pat.node,\n-                        let Ok(lhs) = eval_const_expr_partial(cx.tcx, lhs, ExprTypeChecked, None),\n-                        let Ok(rhs) = eval_const_expr_partial(cx.tcx, rhs, ExprTypeChecked, None)\n-                    ], {\n-                        return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n-                    }}\n-\n-                    if_let_chain! {[\n-                        let PatKind::Lit(ref value) = pat.node,\n-                        let Ok(value) = eval_const_expr_partial(cx.tcx, value, ExprTypeChecked, None)\n-                    ], {\n-                        return Some(SpannedRange { span: pat.span, node: (value.clone(), value) });\n-                    }}\n-\n-                    None\n-                }))\n+                pats.iter()\n             } else {\n+                [].iter()\n+            }.filter_map(|pat| {\n+                if_let_chain! {[\n+                    let PatKind::Range(ref lhs, ref rhs) = pat.node,\n+                    let Ok(lhs) = eval_const_expr_partial(cx.tcx, lhs, ExprTypeChecked, None),\n+                    let Ok(rhs) = eval_const_expr_partial(cx.tcx, rhs, ExprTypeChecked, None)\n+                ], {\n+                    return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n+                }}\n+\n+                if_let_chain! {[\n+                    let PatKind::Lit(ref value) = pat.node,\n+                    let Ok(value) = eval_const_expr_partial(cx.tcx, value, ExprTypeChecked, None)\n+                ], {\n+                    return Some(SpannedRange { span: pat.span, node: (value.clone(), value) });\n+                }}\n+\n                 None\n-            }\n+            })\n         })\n-        .flat_map(IntoIterator::into_iter)\n         .collect()\n }\n "}, {"sha": "950a03159b22d8d3b5714772032a60c132e4c328", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 70, "deletions": 3, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f81d253c07e0f3560f58dffed0a2015d147236b0/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f81d253c07e0f3560f58dffed0a2015d147236b0/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=f81d253c07e0f3560f58dffed0a2015d147236b0", "patch": "@@ -159,6 +159,18 @@ declare_lint! {\n     \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\"\n }\n \n+/// **What it does:** This lint `Warn`s on `_.filter(_).map(_)`, `_.filter(_).flat_map(_)`, `_.filter_map(_).flat_map(_)` and similar.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as a single method call\n+///\n+/// **Known problems:** Often requires a condition + Option/Iterator creation inside the closure\n+///\n+/// **Example:** `iter.filter(|x| x == 0).map(|x| x * 2)`\n+declare_lint! {\n+    pub FILTER_MAP, Allow,\n+    \"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can usually be written as a single method call\"\n+}\n+\n /// **What it does:** This lint `Warn`s on an iterator search (such as `find()`, `position()`, or\n /// `rposition()`) followed by a call to `is_some()`.\n ///\n@@ -356,6 +368,7 @@ impl LintPass for Pass {\n                     SINGLE_CHAR_PATTERN,\n                     SEARCH_IS_SOME,\n                     TEMPORARY_CSTRING_AS_PTR,\n+                    FILTER_MAP,\n                     ITER_NTH)\n     }\n }\n@@ -379,6 +392,14 @@ impl LateLintPass for Pass {\n                     lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n                 } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"next\"]) {\n                     lint_filter_next(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"map\"]) {\n+                    lint_filter_map(cx, expr, arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"filter_map\", \"map\"]) {\n+                    lint_filter_map_map(cx, expr, arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"flat_map\"]) {\n+                    lint_filter_flat_map(cx, expr, arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"filter_map\", \"flat_map\"]) {\n+                    lint_filter_map_flat_map(cx, expr, arglists[0], arglists[1]);\n                 } else if let Some(arglists) = method_chain_args(expr, &[\"find\", \"is_some\"]) {\n                     lint_search_is_some(cx, expr, \"find\", arglists[0], arglists[1]);\n                 } else if let Some(arglists) = method_chain_args(expr, &[\"position\", \"is_some\"]) {\n@@ -813,11 +834,11 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &Method\n \n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n-/// lint use of `filter().next() for Iterators`\n+/// lint use of `filter().next()` for `Iterators`\n fn lint_filter_next(cx: &LateContext, expr: &hir::Expr, filter_args: &MethodArgs) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `filter(p).next()` on an Iterator. This is more succinctly expressed by calling `.find(p)` \\\n+        let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` \\\n                    instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n@@ -834,14 +855,60 @@ fn lint_filter_next(cx: &LateContext, expr: &hir::Expr, filter_args: &MethodArgs\n     }\n }\n \n+// Type of MethodArgs is potentially a Vec\n+/// lint use of `filter().map()` for `Iterators`\n+fn lint_filter_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &MethodArgs, _map_args: &MethodArgs) {\n+    // lint if caller of `.filter().map()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter(p).map(q)` on an `Iterator`. \\\n+                   This is more succinctly expressed by calling `.filter_map(..)` instead.\";\n+        span_lint(cx, FILTER_MAP, expr.span, msg);\n+    }\n+}\n+\n+// Type of MethodArgs is potentially a Vec\n+/// lint use of `filter().map()` for `Iterators`\n+fn lint_filter_map_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &MethodArgs, _map_args: &MethodArgs) {\n+    // lint if caller of `.filter().map()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter_map(p).map(q)` on an `Iterator`. \\\n+                   This is more succinctly expressed by only calling `.filter_map(..)` instead.\";\n+        span_lint(cx, FILTER_MAP, expr.span, msg);\n+    }\n+}\n+\n+// Type of MethodArgs is potentially a Vec\n+/// lint use of `filter().flat_map()` for `Iterators`\n+fn lint_filter_flat_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &MethodArgs, _map_args: &MethodArgs) {\n+    // lint if caller of `.filter().flat_map()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter(p).flat_map(q)` on an `Iterator`. \\\n+                   This is more succinctly expressed by calling `.flat_map(..)` \\\n+                   and filtering by returning an empty Iterator.\";\n+        span_lint(cx, FILTER_MAP, expr.span, msg);\n+    }\n+}\n+\n+// Type of MethodArgs is potentially a Vec\n+/// lint use of `filter_map().flat_map()` for `Iterators`\n+fn lint_filter_map_flat_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &MethodArgs, _map_args: &MethodArgs) {\n+    // lint if caller of `.filter_map().flat_map()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter_map(p).flat_map(q)` on an `Iterator`. \\\n+                   This is more succinctly expressed by calling `.flat_map(..)` \\\n+                   and filtering by returning an empty Iterator.\";\n+        span_lint(cx, FILTER_MAP, expr.span, msg);\n+    }\n+}\n+\n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n /// lint searching an Iterator followed by `is_some()`\n fn lint_search_is_some(cx: &LateContext, expr: &hir::Expr, search_method: &str, search_args: &MethodArgs,\n                        is_some_args: &MethodArgs) {\n     // lint if caller of search is an Iterator\n     if match_trait_method(cx, &*is_some_args[0], &paths::ITERATOR) {\n-        let msg = format!(\"called `is_some()` after searching an iterator with {}. This is more succinctly expressed \\\n+        let msg = format!(\"called `is_some()` after searching an `Iterator` with {}. This is more succinctly expressed \\\n                            by calling `any()`.\",\n                           search_method);\n         let search_snippet = snippet(cx, search_args[1].span, \"..\");"}, {"sha": "743c3c15aeb82cbbf83693c2947c796861e1cf1c", "filename": "tests/compile-fail/filter_methods.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f81d253c07e0f3560f58dffed0a2015d147236b0/tests%2Fcompile-fail%2Ffilter_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f81d253c07e0f3560f58dffed0a2015d147236b0/tests%2Fcompile-fail%2Ffilter_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffilter_methods.rs?ref=f81d253c07e0f3560f58dffed0a2015d147236b0", "patch": "@@ -0,0 +1,25 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(clippy, clippy_pedantic)]\n+fn main() {\n+    let _: Vec<_> = vec![5; 6].into_iter() //~ERROR called `filter(p).map(q)` on an `Iterator`\n+                              .filter(|&x| x == 0)\n+                              .map(|x| x * 2)\n+                              .collect();\n+\n+    let _: Vec<_> = vec![5i8; 6].into_iter() //~ERROR called `filter(p).flat_map(q)` on an `Iterator`\n+                                .filter(|&x| x == 0)\n+                                .flat_map(|x| x.checked_mul(2))\n+                                .collect();\n+\n+    let _: Vec<_> = vec![5i8; 6].into_iter() //~ERROR called `filter_map(p).flat_map(q)` on an `Iterator`\n+                                .filter_map(|x| x.checked_mul(2))\n+                                .flat_map(|x| x.checked_mul(2))\n+                                .collect();\n+\n+    let _: Vec<_> = vec![5i8; 6].into_iter() //~ERROR called `filter_map(p).map(q)` on an `Iterator`\n+                                .filter_map(|x| x.checked_mul(2))\n+                                .map(|x| x.checked_mul(2))\n+                                .collect();\n+}"}, {"sha": "c3f18bef46254735dc105a1c0ff8152d3d5a10bb", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f81d253c07e0f3560f58dffed0a2015d147236b0/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f81d253c07e0f3560f58dffed0a2015d147236b0/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=f81d253c07e0f3560f58dffed0a2015d147236b0", "patch": "@@ -181,11 +181,11 @@ fn filter_next() {\n \n     // check single-line case\n     let _ = v.iter().filter(|&x| *x < 0).next();\n-    //~^ ERROR called `filter(p).next()` on an Iterator.\n+    //~^ ERROR called `filter(p).next()` on an `Iterator`.\n     //~| NOTE replace `filter(|&x| *x < 0).next()`\n \n     // check multi-line case\n-    let _ = v.iter().filter(|&x| { //~ERROR called `filter(p).next()` on an Iterator.\n+    let _ = v.iter().filter(|&x| { //~ERROR called `filter(p).next()` on an `Iterator`.\n                                 *x < 0\n                             }\n                    ).next();"}]}