{"sha": "db4dc1ffe29045361c34abab8d810d2c717b82e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNGRjMWZmZTI5MDQ1MzYxYzM0YWJhYjhkODEwZDJjNzE3YjgyZTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-20T07:09:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-20T07:09:47Z"}, "message": "auto merge of #5443 : alexcrichton/rust/less-bad-copy, r=catamorphism\n\nRemoves a lot of instances of `/*bad*/ copy` throughout libsyntax/librustc. On the plus side, this shaves about 2s off of the runtime when compiling `librustc` with optimizations.\r\n\r\nIdeally I would have run a profiler to figure out which copies are the most critical to remove, but in reality there was a liberal amount of `git grep`s along with some spot checking and removing the easy ones.", "tree": {"sha": "3b82df18e18849d74e4b00b86007282ec30c5cbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b82df18e18849d74e4b00b86007282ec30c5cbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db4dc1ffe29045361c34abab8d810d2c717b82e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db4dc1ffe29045361c34abab8d810d2c717b82e0", "html_url": "https://github.com/rust-lang/rust/commit/db4dc1ffe29045361c34abab8d810d2c717b82e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db4dc1ffe29045361c34abab8d810d2c717b82e0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01e179840fe57c9d2a574613b0cafce756520894", "url": "https://api.github.com/repos/rust-lang/rust/commits/01e179840fe57c9d2a574613b0cafce756520894", "html_url": "https://github.com/rust-lang/rust/commit/01e179840fe57c9d2a574613b0cafce756520894"}, {"sha": "3fac7cce8fb3fb50328e2c2051532361d7d25aaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fac7cce8fb3fb50328e2c2051532361d7d25aaf", "html_url": "https://github.com/rust-lang/rust/commit/3fac7cce8fb3fb50328e2c2051532361d7d25aaf"}], "stats": {"total": 941, "additions": 469, "deletions": 472}, "files": [{"sha": "9965a4a6fcdd61a268363f708892253cec2b54a8", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -194,8 +194,7 @@ pub mod write {\n             let opts = sess.opts;\n             if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }\n             let mut pm = mk_pass_manager();\n-            let td = mk_target_data(\n-                /*bad*/copy sess.targ_cfg.target_strs.data_layout);\n+            let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n             llvm::LLVMAddTargetData(td.lltd, pm.llpm);\n             // FIXME (#2812): run the linter here also, once there are llvm-c\n             // bindings for it.\n@@ -866,8 +865,9 @@ pub fn link_binary(sess: Session,\n     // to be found at compile time so it is still entirely up to outside\n     // forces to make sure that library can be found at runtime.\n \n-    let addl_paths = /*bad*/copy sess.opts.addl_lib_search_paths;\n-    for addl_paths.each |path| { cc_args.push(~\"-L\" + path.to_str()); }\n+    for sess.opts.addl_lib_search_paths.each |path| {\n+        cc_args.push(~\"-L\" + path.to_str());\n+    }\n \n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);"}, {"sha": "1911764da3c38bebe3806ea0b80f9e40e3222130", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -45,8 +45,8 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n     // where rustrt is and we know every rust program needs it\n     let libs = vec::append_one(libs, get_sysroot_absolute_rt_lib(sess));\n \n-    let target_triple = /*bad*/copy sess.opts.target_triple;\n-    let rpaths = get_rpaths(os, &sysroot, output, libs, target_triple);\n+    let rpaths = get_rpaths(os, &sysroot, output, libs,\n+                            sess.opts.target_triple);\n     rpaths_to_flags(rpaths)\n }\n \n@@ -140,8 +140,8 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     let abs2 = abs2.normalize();\n     debug!(\"finding relative path from %s to %s\",\n            abs1.to_str(), abs2.to_str());\n-    let split1 = /*bad*/copy abs1.components;\n-    let split2 = /*bad*/copy abs2.components;\n+    let split1: &[~str] = abs1.components;\n+    let split2: &[~str] = abs2.components;\n     let len1 = vec::len(split1);\n     let len2 = vec::len(split2);\n     fail_unless!(len1 > 0);"}, {"sha": "dfac6a0162f2e355267980f34af4b96a9e100870", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -132,15 +132,12 @@ pub fn build_configuration(sess: Session, +argv0: ~str, input: input) ->\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: ~[~str],\n+fn parse_cfgspecs(+cfgspecs: ~[~str],\n                   demitter: diagnostic::Emitter) -> ast::crate_cfg {\n-    let mut meta = ~[];\n-    for cfgspecs.each |s| {\n+    do vec::map_consume(cfgspecs) |s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n-        let m = parse::parse_meta_from_source_str(~\"cfgspec\", @/*bad*/ copy *s, ~[], sess);\n-        meta.push(m)\n+        parse::parse_meta_from_source_str(~\"cfgspec\", @s, ~[], sess)\n     }\n-    return meta;\n }\n \n pub enum input {\n@@ -580,9 +577,9 @@ pub fn build_session_options(+binary: ~str,\n     let debug_map = session::debugging_opts_map();\n     for debug_flags.each |debug_flag| {\n         let mut this_bit = 0u;\n-        for debug_map.each |pair| {\n-            let (name, _, bit) = /*bad*/copy *pair;\n-            if name == *debug_flag { this_bit = bit; break; }\n+        for debug_map.each |tuple| {\n+            let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n+            if name == debug_flag { this_bit = bit; break; }\n         }\n         if this_bit == 0u {\n             early_error(demitter, fmt!(\"unknown debug flag: %s\", *debug_flag))\n@@ -647,7 +644,7 @@ pub fn build_session_options(+binary: ~str,\n     let target =\n         match target_opt {\n             None => host_triple(),\n-            Some(ref s) => (/*bad*/copy *s)\n+            Some(s) => s\n         };\n \n     let addl_lib_search_paths ="}, {"sha": "e5234dff91d1335ec8a9cd1475e7854877e78015", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -1647,7 +1647,7 @@ pub struct TargetData {\n     dtor: @target_data_res\n }\n \n-pub fn mk_target_data(string_rep: ~str) -> TargetData {\n+pub fn mk_target_data(string_rep: &str) -> TargetData {\n     let lltd =\n         str::as_c_str(string_rep, |buf| unsafe {\n             llvm::LLVMCreateTargetData(buf)"}, {"sha": "21b035f2242f6d476bc270a4408dbb31d965cd0f", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -142,8 +142,8 @@ fn visit_crate(e: @mut Env, c: ast::crate) {\n }\n \n fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n-    match /*bad*/copy i.node {\n-      ast::view_item_extern_mod(ident, meta_items, id) => {\n+    match i.node {\n+      ast::view_item_extern_mod(ident, /*bad*/copy meta_items, id) => {\n         debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n                ident, meta_items);\n         let cnum = resolve_crate(e, ident, meta_items, @~\"\", i.span);\n@@ -154,8 +154,8 @@ fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n }\n \n fn visit_item(e: @mut Env, i: @ast::item) {\n-    match /*bad*/copy i.node {\n-      ast::item_foreign_mod(fm) => {\n+    match i.node {\n+      ast::item_foreign_mod(ref fm) => {\n         match attr::foreign_abi(i.attrs) {\n           either::Right(abi) => {\n             if abi != ast::foreign_abi_cdecl &&"}, {"sha": "f057b04e06698b96cc128ec5ae11738c918f6d8a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -645,7 +645,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     debug!(\"encoding info for item at %s\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n \n-    match /*bad*/copy item.node {\n+    match item.node {\n       item_const(_, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n@@ -1196,10 +1196,10 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n             if *attr::get_attr_name(attr) != ~\"link\" {\n                 /*bad*/copy *attr\n             } else {\n-                match /*bad*/copy attr.node.value.node {\n-                  meta_list(_, l) => {\n+                match attr.node.value.node {\n+                  meta_list(_, ref l) => {\n                     found_link_attr = true;;\n-                    synthesize_link_attr(ecx, l)\n+                    synthesize_link_attr(ecx, /*bad*/copy *l)\n                   }\n                   _ => /*bad*/copy *attr\n                 }"}, {"sha": "853bb8df3a4c021104932d8672c414abebfa4152", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -639,14 +639,14 @@ fn encode_vtable_origin(ecx: @e::EncodeContext,\n                       ebml_w: writer::Encoder,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n-        match /*bad*/copy vtable_origin {\n-          typeck::vtable_static(def_id, tys, vtable_res) => {\n+        match vtable_origin {\n+          typeck::vtable_static(def_id, ref tys, vtable_res) => {\n             do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) {\n                 do ebml_w.emit_enum_variant_arg(0u) {\n                     ebml_w.emit_def_id(def_id)\n                 }\n                 do ebml_w.emit_enum_variant_arg(1u) {\n-                    ebml_w.emit_tys(ecx, /*bad*/copy tys);\n+                    ebml_w.emit_tys(ecx, /*bad*/copy *tys);\n                 }\n                 do ebml_w.emit_enum_variant_arg(2u) {\n                     encode_vtable_res(ecx, ebml_w, vtable_res);"}, {"sha": "83fe2db79ef7379ab13f70ed76715d8dd7d77bba", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -139,7 +139,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n     }\n \n     // Special checks for various kinds of expressions:\n-    match /*bad*/copy ex.node {\n+    match ex.node {\n       ast::expr_addr_of(mutbl, base) => {\n         let base_cmt = self.bccx.cat_expr(base);\n \n@@ -150,10 +150,10 @@ fn req_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, self, vt);\n       }\n \n-      ast::expr_call(f, args, _) => {\n+      ast::expr_call(f, ref args, _) => {\n         let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n         let scope_r = ty::re_scope(ex.id);\n-        for vec::each2(args, arg_tys) |arg, arg_ty| {\n+        for vec::each2(*args, arg_tys) |arg, arg_ty| {\n             match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n                 ast::by_ref => {\n                     let arg_cmt = self.bccx.cat_expr(*arg);\n@@ -165,11 +165,11 @@ fn req_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, self, vt);\n       }\n \n-      ast::expr_method_call(rcvr, _, _, args, _) => {\n+      ast::expr_method_call(rcvr, _, _, ref args, _) => {\n         let arg_tys = ty::ty_fn_args(ty::node_id_to_type(self.tcx(),\n                                                          ex.callee_id));\n         let scope_r = ty::re_scope(ex.id);\n-        for vec::each2(args, arg_tys) |arg, arg_ty| {\n+        for vec::each2(*args, arg_tys) |arg, arg_ty| {\n             match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n                 ast::by_ref => {\n                     let arg_cmt = self.bccx.cat_expr(*arg);"}, {"sha": "245872c39c61a49716ca16b6459b2fdc618a9273", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -243,8 +243,8 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n               }\n               ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n                 let max_len = do m.foldr(0) |r, max_len| {\n-                  match /*bad*/copy r[0].node {\n-                    pat_vec(before, _, after) => {\n+                  match r[0].node {\n+                    pat_vec(ref before, _, ref after) => {\n                       uint::max(before.len() + after.len(), max_len)\n                     }\n                     _ => max_len\n@@ -299,7 +299,7 @@ pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n \n pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     let pat = raw_pat(p);\n-    match /*bad*/copy pat.node {\n+    match pat.node {\n       pat_wild => { None }\n       pat_ident(_, _, _) | pat_enum(_, _) => {\n         match cx.tcx.def_map.find(&pat.id) {\n@@ -324,7 +324,7 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n       pat_box(_) | pat_uniq(_) | pat_tup(_) | pat_region(*) => {\n         Some(single)\n       }\n-      pat_vec(before, slice, after) => {\n+      pat_vec(ref before, slice, ref after) => {\n         match slice {\n           Some(_) => None,\n           None => Some(vec(before.len() + after.len()))\n@@ -448,8 +448,8 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n }\n \n pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n-    match /*bad*/copy ty::get(ty).sty {\n-      ty::ty_tup(fs) => fs.len(),\n+    match ty::get(ty).sty {\n+      ty::ty_tup(ref fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n           let id = match ctor { variant(id) => id,\n@@ -704,7 +704,7 @@ pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n       _ => ()\n     }\n \n-    match /*bad*/copy pat.node {\n+    match pat.node {\n       pat_box(sub) | pat_uniq(sub) | pat_region(sub) |\n       pat_ident(_, _, Some(sub)) => {\n         is_refutable(cx, sub)\n@@ -715,13 +715,13 @@ pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n         false\n       }\n       pat_lit(_) | pat_range(_, _) => { true }\n-      pat_struct(_, fields, _) => {\n+      pat_struct(_, ref fields, _) => {\n         fields.any(|f| is_refutable(cx, f.pat))\n       }\n-      pat_tup(elts) => {\n+      pat_tup(ref elts) => {\n         elts.any(|elt| is_refutable(cx, *elt))\n       }\n-      pat_enum(_, Some(args)) => {\n+      pat_enum(_, Some(ref args)) => {\n         args.any(|a| is_refutable(cx, *a))\n       }\n       pat_enum(_,_) => { false }"}, {"sha": "4888a01c6b95346e44e58a40fb273a9c676d61d4", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -81,7 +81,7 @@ pub fn classify(e: @expr,\n       Some(x) => x,\n       None => {\n         let cn =\n-            match /*bad*/copy e.node {\n+            match e.node {\n               ast::expr_lit(lit) => {\n                 match lit.node {\n                   ast::lit_str(*) |\n@@ -101,9 +101,9 @@ pub fn classify(e: @expr,\n                      classify(b, def_map, tcx))\n               }\n \n-              ast::expr_tup(es) |\n-              ast::expr_vec(es, ast::m_imm) => {\n-                join_all(vec::map(es, |e| classify(*e, def_map, tcx)))\n+              ast::expr_tup(ref es) |\n+              ast::expr_vec(ref es, ast::m_imm) => {\n+                join_all(vec::map(*es, |e| classify(*e, def_map, tcx)))\n               }\n \n               ast::expr_vstore(e, vstore) => {"}, {"sha": "e4ea2333d2763f48ccf019eac8365f730dc9ea29", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -56,7 +56,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n                     Some(df) => {\n                       let mut def = df;\n                       while i < depth {\n-                        match copy def {\n+                        match def {\n                           ast::def_upvar(_, inner, _, _) => { def = *inner; }\n                           _ => break\n                         }"}, {"sha": "a8fe25b61c79add3f51262909936b7cd4aa216c1", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -360,8 +360,8 @@ pub impl Context {\n             let metas =\n                 attr::attr_metas(attr::find_attrs_by_name(attrs, level_name));\n             for metas.each |meta| {\n-                match /*bad*/copy meta.node {\n-                  ast::meta_list(_, metas) => {\n+                match meta.node {\n+                  ast::meta_list(_, ref metas) => {\n                     for metas.each |meta| {\n                         match meta.node {\n                           ast::meta_word(ref lintname) => {\n@@ -653,8 +653,8 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n }\n \n fn check_item_default_methods(cx: ty::ctxt, item: @ast::item) {\n-    match /*bad*/copy item.node {\n-        ast::item_trait(_, _, methods) => {\n+    match item.node {\n+        ast::item_trait(_, _, ref methods) => {\n             for methods.each |method| {\n                 match *method {\n                     ast::required(*) => {}"}, {"sha": "7f14b21585889e94e4ac3db35adf82b51f3ed1f3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -383,7 +383,7 @@ pub impl IrMaps {\n     }\n \n     fn variable_name(&mut self, var: Variable) -> @~str {\n-        match copy self.var_kinds[*var] {\n+        match self.var_kinds[*var] {\n             Local(LocalInfo {ident: nm, _}) |\n             Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n             ImplicitRet => @~\"<implicit-ret>\"\n@@ -1065,8 +1065,8 @@ pub impl Liveness {\n \n     fn propagate_through_decl(&self, decl: @decl, succ: LiveNode)\n                              -> LiveNode {\n-        match /*bad*/copy decl.node {\n-          decl_local(locals) => {\n+        match decl.node {\n+          decl_local(ref locals) => {\n             do locals.foldr(succ) |local, succ| {\n                 self.propagate_through_local(*local, succ)\n             }\n@@ -1097,7 +1097,7 @@ pub impl Liveness {\n         self.define_bindings_in_pat(local.node.pat, succ)\n     }\n \n-    fn propagate_through_exprs(&self, exprs: ~[@expr],\n+    fn propagate_through_exprs(&self, exprs: &[@expr],\n                                succ: LiveNode) -> LiveNode {\n         do exprs.foldr(succ) |expr, succ| {\n             self.propagate_through_expr(*expr, succ)\n@@ -1116,7 +1116,7 @@ pub impl Liveness {\n         debug!(\"propagate_through_expr: %s\",\n              expr_to_str(expr, self.tcx.sess.intr()));\n \n-        match /*bad*/copy expr.node {\n+        match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n           expr_path(_) => {\n@@ -1283,8 +1283,8 @@ pub impl Liveness {\n             self.propagate_through_expr(expr, succ)\n           }\n \n-          expr_vec(exprs, _) => {\n-            self.propagate_through_exprs(exprs, succ)\n+          expr_vec(ref exprs, _) => {\n+            self.propagate_through_exprs(*exprs, succ)\n           }\n \n           expr_repeat(element, count, _) => {\n@@ -1299,29 +1299,29 @@ pub impl Liveness {\n             }\n           }\n \n-          expr_call(f, args, _) => {\n+          expr_call(f, ref args, _) => {\n             // calling a fn with bot return type means that the fn\n             // will fail, and hence the successors can be ignored\n             let t_ret = ty::ty_fn_ret(ty::expr_ty(self.tcx, f));\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n-            let succ = self.propagate_through_exprs(args, succ);\n+            let succ = self.propagate_through_exprs(*args, succ);\n             self.propagate_through_expr(f, succ)\n           }\n \n-          expr_method_call(rcvr, _, _, args, _) => {\n+          expr_method_call(rcvr, _, _, ref args, _) => {\n             // calling a method with bot return type means that the method\n             // will fail, and hence the successors can be ignored\n             let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx,\n                                                           expr.callee_id));\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n-            let succ = self.propagate_through_exprs(args, succ);\n+            let succ = self.propagate_through_exprs(*args, succ);\n             self.propagate_through_expr(rcvr, succ)\n           }\n \n-          expr_tup(exprs) => {\n-            self.propagate_through_exprs(exprs, succ)\n+          expr_tup(ref exprs) => {\n+            self.propagate_through_exprs(*exprs, succ)\n           }\n \n           expr_binary(op, l, r) if ast_util::lazy_binop(op) => {\n@@ -1350,7 +1350,7 @@ pub impl Liveness {\n             self.propagate_through_expr(e, succ)\n           }\n \n-          expr_inline_asm(_, ins, outs, _, _, _) =>{\n+          expr_inline_asm(_, ref ins, ref outs, _, _, _) =>{\n             let succ = do ins.foldr(succ) |&(_, expr), succ| {\n                 self.propagate_through_expr(expr, succ)\n             };\n@@ -1579,7 +1579,7 @@ fn check_arm(arm: &arm, &&self: @Liveness, vt: vt<@Liveness>) {\n }\n \n fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n-    match /*bad*/copy expr.node {\n+    match expr.node {\n       expr_path(_) => {\n         for self.variable_from_def_map(expr.id, expr.span).each |var| {\n             let ln = self.live_node(expr.id, expr.span);\n@@ -1624,7 +1624,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n         visit::visit_expr(expr, self, vt);\n       }\n \n-      expr_inline_asm(_, ins, outs, _, _, _) => {\n+      expr_inline_asm(_, ref ins, ref outs, _, _, _) => {\n         for ins.each |&(_, in)| {\n           (vt.visit_expr)(in, self, vt);\n         }"}, {"sha": "fee3695002da1f9b67e17de7a26e6f959ff4801a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -1106,7 +1106,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n                    node_id: ast::node_id)\n                 -> Option<ast::mutability> {\n     // Need to refactor so that struct/enum fields can be treated uniformly.\n-    match /*bad*/copy ty::get(base_ty).sty {\n+    match ty::get(base_ty).sty {\n       ty::ty_struct(did, _) => {\n         for ty::lookup_struct_fields(tcx, did).each |fld| {\n             if fld.ident == f_name {"}, {"sha": "5a4fe4018ceaf33de04808b75b2f1859c84754c8", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -544,8 +544,8 @@ pub fn check_crate(tcx: ty::ctxt,\n             visit::visit_expr(expr, method_map, visitor);\n         },\n         visit_pat: |pattern, method_map, visitor| {\n-            match /*bad*/copy pattern.node {\n-                pat_struct(_, fields, _) => {\n+            match pattern.node {\n+                pat_struct(_, ref fields, _) => {\n                     match ty::get(ty::pat_ty(tcx, pattern)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||"}, {"sha": "6c2168548f147489676922d7eef72e96a247974a", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -1080,7 +1080,7 @@ pub impl Resolver {\n         let sp = item.span;\n         let privacy = visibility_to_privacy(item.vis);\n \n-        match /*bad*/copy item.node {\n+        match item.node {\n             item_mod(ref module_) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateModules, sp);\n@@ -1099,7 +1099,7 @@ pub impl Resolver {\n                 visit_mod(module_, sp, item.id, new_parent, visitor);\n             }\n \n-            item_foreign_mod(fm) => {\n+            item_foreign_mod(ref fm) => {\n                 let new_parent = match fm.sort {\n                     named => {\n                         let (name_bindings, new_parent) =\n@@ -1196,7 +1196,7 @@ pub impl Resolver {\n                 visit_item(item, new_parent, visitor);\n             }\n \n-            item_impl(_, trait_ref_opt, ty, methods) => {\n+            item_impl(_, trait_ref_opt, ty, ref methods) => {\n                 // If this implements an anonymous trait and it has static\n                 // methods, then add all the static methods within to a new\n                 // module, if the type was defined within this module.\n@@ -1401,8 +1401,8 @@ pub impl Resolver {\n                                          parent: ReducedGraphParent,\n                                          &&_visitor: vt<ReducedGraphParent>) {\n         let privacy = visibility_to_privacy(view_item.vis);\n-        match /*bad*/copy view_item.node {\n-            view_item_use(view_paths) => {\n+        match view_item.node {\n+            view_item_use(ref view_paths) => {\n                 for view_paths.each |view_path| {\n                     // Extract and intern the module part of the path. For\n                     // globs and lists, the path is found directly in the AST;\n@@ -1571,7 +1571,7 @@ pub impl Resolver {\n                            new_parent: ReducedGraphParent) {\n         match def {\n           def_mod(def_id) | def_foreign_mod(def_id) => {\n-            match copy child_name_bindings.type_def {\n+            match child_name_bindings.type_def {\n               Some(TypeNsDef { module_def: Some(copy module_def), _ }) => {\n                 debug!(\"(building reduced graph for external crate) \\\n                         already created module\");\n@@ -1790,7 +1790,7 @@ pub impl Resolver {\n                                     // Process the static methods. First,\n                                     // create the module.\n                                     let type_module;\n-                                    match copy child_name_bindings.type_def {\n+                                    match child_name_bindings.type_def {\n                                         Some(TypeNsDef {\n                                             module_def: Some(copy module_def),\n                                             _\n@@ -2008,10 +2008,13 @@ pub impl Resolver {\n     }\n \n     fn idents_to_str(@mut self, idents: &[ident]) -> ~str {\n-        let ident_strs = do idents.map |ident| {\n-            /*bad*/ copy *self.session.str_of(*ident)\n+        let mut first = true;\n+        let mut result = ~\"\";\n+        for idents.each |ident| {\n+            if first { first = false; } else { result += \"::\" };\n+            result += *self.session.str_of(*ident);\n         };\n-        str::connect(ident_strs, \"::\")\n+        return result;\n     }\n \n     fn import_directive_subclass_to_str(@mut self,\n@@ -2511,22 +2514,22 @@ pub impl Resolver {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n \n-                    match copy target_import_resolution.value_target {\n+                    match target_import_resolution.value_target {\n                         None => {\n                             // Continue.\n                         }\n-                        Some(value_target) => {\n+                        Some(copy value_target) => {\n                             dest_import_resolution.value_target =\n-                                Some(copy value_target);\n+                                Some(value_target);\n                         }\n                     }\n-                    match copy target_import_resolution.type_target {\n+                    match target_import_resolution.type_target {\n                         None => {\n                             // Continue.\n                         }\n-                        Some(type_target) => {\n+                        Some(copy type_target) => {\n                             dest_import_resolution.type_target =\n-                                Some(copy type_target);\n+                                Some(type_target);\n                         }\n                     }\n                 }\n@@ -3149,7 +3152,7 @@ pub impl Resolver {\n         let mut exports2 = ~[];\n \n         self.add_exports_for_module(&mut exports2, module_);\n-        match copy module_.def_id {\n+        match /*bad*/copy module_.def_id {\n             Some(def_id) => {\n                 self.export_map2.insert(def_id.node, exports2);\n                 debug!(\"(computing exports) writing exports for %d (some)\",\n@@ -3448,12 +3451,12 @@ pub impl Resolver {\n         // Items with the !resolve_unexported attribute are X-ray contexts.\n         // This is used to allow the test runner to run unexported tests.\n         let orig_xray_flag = self.xray_context;\n-        if contains_name(attr_metas(/*bad*/copy item.attrs),\n+        if contains_name(attr_metas(item.attrs),\n                          ~\"!resolve_unexported\") {\n             self.xray_context = Xray;\n         }\n \n-        match /*bad*/copy item.node {\n+        match item.node {\n \n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n@@ -3578,7 +3581,7 @@ pub impl Resolver {\n                 self.type_ribs.pop();\n             }\n \n-            item_struct(struct_def, ref generics) => {\n+            item_struct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n                                     struct_def.fields,\n@@ -3593,7 +3596,7 @@ pub impl Resolver {\n                 }\n             }\n \n-            item_foreign_mod(foreign_module) => {\n+            item_foreign_mod(ref foreign_module) => {\n                 do self.with_scope(Some(item.ident)) {\n                     for foreign_module.items.each |foreign_item| {\n                         match foreign_item.node {\n@@ -3639,7 +3642,7 @@ pub impl Resolver {\n                 }\n \n                 self.resolve_function(OpaqueFunctionRibKind,\n-                                      Some(@/*bad*/copy *fn_decl),\n+                                      Some(fn_decl),\n                                       HasTypeParameters\n                                         (generics,\n                                          item.id,\n@@ -3721,7 +3724,7 @@ pub impl Resolver {\n \n     fn resolve_function(@mut self,\n                         rib_kind: RibKind,\n-                        optional_declaration: Option<@fn_decl>,\n+                        optional_declaration: Option<&fn_decl>,\n                         type_parameters: TypeParameters,\n                         block: &blk,\n                         self_binding: SelfBinding,\n@@ -3868,7 +3871,7 @@ pub impl Resolver {\n         };\n \n         self.resolve_function(rib_kind,\n-                              Some(@/*bad*/copy method.decl),\n+                              Some(&method.decl),\n                               type_parameters,\n                               &method.body,\n                               self_binding,\n@@ -4133,7 +4136,7 @@ pub impl Resolver {\n                     }\n                 }\n \n-                match copy result_def {\n+                match result_def {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `%s` \\\n@@ -4681,7 +4684,7 @@ pub impl Resolver {\n             }\n         }\n \n-        match copy search_result {\n+        match search_result {\n             Some(dl_def(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `%s` to \\\n                         local: %?\",\n@@ -4823,7 +4826,7 @@ pub impl Resolver {\n                     }\n                     None => {\n                         let wrong_name = self.idents_to_str(\n-                            /*bad*/copy path.idents);\n+                            path.idents);\n                         if self.name_exists_in_scope_struct(wrong_name) {\n                             self.session.span_err(expr.span,\n                                         fmt!(\"unresolved name: `%s`. \\\n@@ -4855,7 +4858,7 @@ pub impl Resolver {\n \n             expr_fn_block(ref fn_decl, ref block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.node.id),\n-                                      Some(@/*bad*/copy *fn_decl),\n+                                      Some(fn_decl),\n                                       NoTypeParameters,\n                                       block,\n                                       NoSelfBinding,\n@@ -5007,7 +5010,7 @@ pub impl Resolver {\n         let mut search_module = self.current_module;\n         loop {\n             // Look for the current trait.\n-            match copy self.current_trait_refs {\n+            match /*bad*/copy self.current_trait_refs {\n                 Some(trait_def_ids) => {\n                     for trait_def_ids.each |trait_def_id| {\n                         self.add_trait_info_if_containing_method("}, {"sha": "45fe40ca1f70fc6e3aca6886dec2b71e870940fe", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -501,12 +501,13 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n     let tcx = bcx.tcx();\n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n-        match /*bad*/copy p.node {\n-            ast::pat_enum(_, subpats) => {\n+        match p.node {\n+            ast::pat_enum(_, ref subpats) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n-                    Some(option::get_or_default(subpats,\n-                                             vec::from_elem(variant_size,\n-                                                            dummy)))\n+                    match *subpats {\n+                        None => Some(vec::from_elem(variant_size, dummy)),\n+                        _ => copy *subpats\n+                    }\n                 } else {\n                     None\n                 }\n@@ -534,7 +535,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n             ast::pat_range(l1, l2) => {\n                 if opt_eq(tcx, &range(l1, l2), opt) {Some(~[])} else {None}\n             }\n-            ast::pat_struct(_, field_pats, _) => {\n+            ast::pat_struct(_, ref field_pats, _) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n@@ -565,22 +566,22 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                     None\n                 }\n             }\n-            ast::pat_vec(before, slice, after) => {\n+            ast::pat_vec(ref before, slice, ref after) => {\n                 match slice {\n-                    Some(_) => {\n+                    Some(slice) => {\n                         let n = before.len() + after.len();\n                         let i = before.len();\n                         if opt_eq(tcx, &vec_len_ge(n, i), opt) {\n-                            Some(vec::concat(\n-                                &[before, ~[slice.get()], after]))\n+                            Some(vec::append_one(copy *before, slice) +\n+                                    *after)\n                         } else {\n                             None\n                         }\n                     }\n                     None => {\n                         let n = before.len();\n                         if opt_eq(tcx, &vec_len_eq(n), opt) {\n-                            Some(copy before)\n+                            Some(copy *before)\n                         } else {\n                             None\n                         }\n@@ -611,10 +612,10 @@ pub fn enter_rec_or_struct(bcx: block,\n \n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n-        match /*bad*/copy p.node {\n-            ast::pat_struct(_, fpats, _) => {\n+        match p.node {\n+            ast::pat_struct(_, ref fpats, _) => {\n                 let mut pats = ~[];\n-                for vec::each(fields) |fname| {\n+                for fields.each |fname| {\n                     match fpats.find(|p| p.ident == *fname) {\n                         None => pats.push(dummy),\n                         Some(pat) => pats.push(pat.pat)\n@@ -642,8 +643,8 @@ pub fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n \n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n-        match /*bad*/copy p.node {\n-            ast::pat_tup(elts) => {\n+        match p.node {\n+            ast::pat_tup(/*bad*/copy elts) => {\n                 Some(elts)\n             }\n             _ => {\n@@ -670,8 +671,8 @@ pub fn enter_tuple_struct(bcx: block,\n \n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n-        match /*bad*/copy p.node {\n-            ast::pat_enum(_, Some(elts)) => Some(elts),\n+        match p.node {\n+            ast::pat_enum(_, Some(/*bad*/copy elts)) => Some(elts),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n@@ -774,7 +775,7 @@ pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     let mut found = ~[];\n     for m.each |br| {\n         let cur = br.pats[col];\n-        match /*bad*/copy cur.node {\n+        match cur.node {\n             ast::pat_lit(l) => {\n                 add_to_set(ccx.tcx, &mut found, lit(ExprLit(l)));\n             }\n@@ -811,7 +812,7 @@ pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n             ast::pat_range(l1, l2) => {\n                 add_to_set(ccx.tcx, &mut found, range(l1, l2));\n             }\n-            ast::pat_vec(before, slice, after) => {\n+            ast::pat_vec(ref before, slice, ref after) => {\n                 let opt = match slice {\n                     None => vec_len_eq(before.len()),\n                     Some(_) => vec_len_ge(before.len() + after.len(),\n@@ -902,10 +903,10 @@ pub fn collect_record_or_struct_fields(bcx: block,\n                                     -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n     for vec::each(m) |br| {\n-        match /*bad*/copy br.pats[col].node {\n-          ast::pat_struct(_, fs, _) => {\n+        match br.pats[col].node {\n+          ast::pat_struct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n-              ty::ty_struct(*) => extend(&mut fields, fs),\n+              ty::ty_struct(*) => extend(&mut fields, *fs),\n               _ => ()\n             }\n           }\n@@ -1300,8 +1301,8 @@ pub fn compile_submatch(bcx: block,\n     if any_tup_pat(m, col) {\n         let tup_ty = node_id_type(bcx, pat_id);\n         let tup_repr = adt::represent_type(bcx.ccx(), tup_ty);\n-        let n_tup_elts = match /*bad*/copy ty::get(tup_ty).sty {\n-          ty::ty_tup(elts) => elts.len(),\n+        let n_tup_elts = match ty::get(tup_ty).sty {\n+          ty::ty_tup(ref elts) => elts.len(),\n           _ => ccx.sess.bug(~\"non-tuple type in tuple pattern\")\n         };\n         let tup_vals = do vec::from_fn(n_tup_elts) |i| {\n@@ -1701,8 +1702,8 @@ pub fn bind_irrefutable_pat(bcx: block,\n     let mut bcx = bcx;\n \n     // Necessary since bind_irrefutable_pat is called outside trans_match\n-    match /*bad*/copy pat.node {\n-        ast::pat_ident(_, _,inner) => {\n+    match pat.node {\n+        ast::pat_ident(_, _, ref inner) => {\n             if pat_is_variant_or_struct(bcx.tcx().def_map, pat) {\n                 return bcx;\n             }\n@@ -1740,7 +1741,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                     bcx, *inner_pat, val, true, binding_mode);\n             }\n         }\n-        ast::pat_enum(_, sub_pats) => {\n+        ast::pat_enum(_, ref sub_pats) => {\n             match bcx.tcx().def_map.find(&pat.id) {\n                 Some(ast::def_variant(enum_id, var_id)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n@@ -1762,14 +1763,14 @@ pub fn bind_irrefutable_pat(bcx: block,\n                     }\n                 }\n                 Some(ast::def_struct(*)) => {\n-                    match sub_pats {\n+                    match *sub_pats {\n                         None => {\n                             // This is a unit-like struct. Nothing to do here.\n                         }\n-                        Some(elems) => {\n+                        Some(ref elems) => {\n                             // This is the tuple struct case.\n                             let repr = adt::represent_node(bcx, pat.id);\n-                            for vec::eachi(elems) |i, elem| {\n+                            for elems.eachi |i, elem| {\n                                 let fldptr = adt::trans_field_ptr(bcx, repr,\n                                                             val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx,\n@@ -1786,12 +1787,12 @@ pub fn bind_irrefutable_pat(bcx: block,\n                 }\n             }\n         }\n-        ast::pat_struct(_, fields, _) => {\n+        ast::pat_struct(_, ref fields, _) => {\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n-                for vec::each(fields) |f| {\n+                for fields.each |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n                                                 discr, ix);\n@@ -1803,9 +1804,9 @@ pub fn bind_irrefutable_pat(bcx: block,\n                 }\n             }\n         }\n-        ast::pat_tup(elems) => {\n+        ast::pat_tup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n-            for vec::eachi(elems) |i, elem| {\n+            for elems.eachi |i, elem| {\n                 let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx,\n                                            *elem,"}, {"sha": "c36d0446ef0a7d11a0f469e54b8fdc2890a9d532", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -638,7 +638,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     }\n \n     let mut cx = cx;\n-    match /*bad*/copy ty::get(t).sty {\n+    match ty::get(t).sty {\n       ty::ty_struct(*) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n@@ -653,9 +653,9 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let (base, len) = tvec::get_base_and_len(cx, av, t);\n         cx = tvec::iter_vec_raw(cx, base, t, len, f);\n       }\n-      ty::ty_tup(args) => {\n+      ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          for vec::eachi(args) |i, arg| {\n+          for args.eachi |i, arg| {\n               let llfld_a = adt::trans_field_ptr(cx, repr, av, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n@@ -756,9 +756,9 @@ pub fn cast_shift_rhs(op: ast::binop,\n pub fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n                     rhs: ValueRef, rhs_t: ty::t) -> block {\n     let text = if divmod == ast::div {\n-        ~\"divide by zero\"\n+        @~\"divide by zero\"\n     } else {\n-        ~\"modulo zero\"\n+        @~\"modulo zero\"\n     };\n     let is_zero = match ty::get(rhs_t).sty {\n       ty::ty_int(t) => {\n@@ -775,7 +775,7 @@ pub fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n       }\n     };\n     do with_cond(cx, is_zero) |bcx| {\n-        controlflow::trans_fail(bcx, Some(span), @/*bad*/copy text)\n+        controlflow::trans_fail(bcx, Some(span), text)\n     }\n }\n \n@@ -914,7 +914,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     let mut cached = None, pad_bcx = bcx; // Guaranteed to be set below\n     do in_lpad_scope_cx(bcx) |inf| {\n         // If there is a valid landing pad still around, use it\n-        match copy inf.landing_pad {\n+        match inf.landing_pad {\n           Some(target) => cached = Some(target),\n           None => {\n             pad_bcx = lpad_block(bcx, ~\"unwind\");\n@@ -944,7 +944,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n \n     // We store the retval in a function-central alloca, so that calls to\n     // Resume can find it.\n-    match copy bcx.fcx.personality {\n+    match bcx.fcx.personality {\n       Some(addr) => Store(pad_bcx, llretval, addr),\n       None => {\n         let addr = alloca(pad_bcx, val_ty(llretval));\n@@ -1143,9 +1143,9 @@ pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n             bcx = expr::trans_into(cx, e, expr::Ignore);\n         }\n         ast::stmt_decl(d, _) => {\n-            match /*bad*/copy d.node {\n-                ast::decl_local(locals) => {\n-                    for vec::each(locals) |local| {\n+            match d.node {\n+                ast::decl_local(ref locals) => {\n+                    for locals.each |local| {\n                         bcx = init_local(bcx, *local);\n                         if cx.sess().opts.extra_debuginfo {\n                             debuginfo::create_local_var(bcx, *local);\n@@ -1390,9 +1390,9 @@ pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n     for vec::each(b.node.stmts) |s| {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n-            match /*bad*/copy d.node {\n-              ast::decl_local(locals) => {\n-                for vec::each(locals) |local| {\n+            match d.node {\n+              ast::decl_local(ref locals) => {\n+                for locals.each |local| {\n                     it(*local);\n                 }\n               }\n@@ -1771,7 +1771,7 @@ pub fn trans_closure(ccx: @CrateContext,\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, impl_id, param_substs,\n                                   Some(body.span));\n     let raw_llargs = create_llargs_for_fn_args(fcx, ty_self,\n-                                               /*bad*/copy decl.inputs);\n+                                               decl.inputs);\n \n     // Set GC for function.\n     if ccx.sess.opts.gc {\n@@ -1871,8 +1871,8 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n                                param_substs, None);\n     let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n     let ty_param_substs = match param_substs {\n-      Some(ref substs) => /*bad*/copy substs.tys,\n-      None => ~[]\n+        Some(ref substs) => { copy substs.tys }\n+        None => ~[]\n     };\n     let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n@@ -1932,8 +1932,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n                                param_substs,\n                                None);\n \n-    // XXX: Bad copy.\n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, copy fn_args);\n+    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n \n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n@@ -1942,7 +1941,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n \n     // XXX is there a better way to reconstruct the ty::t?\n     let ty_param_substs = match param_substs {\n-        Some(ref substs) => /*bad*/copy substs.tys,\n+        Some(ref substs) => { copy substs.tys }\n         None => ~[]\n     };\n     let ctor_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n@@ -2022,7 +2021,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, *variant, /*bad*/copy *args,\n+                trans_enum_variant(ccx, id, *variant, *args,\n                                    disr_val, None, llfn);\n             }\n             ast::tuple_variant_kind(_) => {\n@@ -2051,7 +2050,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n         // tjc: ?\n         _ => fail!(~\"trans_item\"),\n     };\n-    match /*bad*/copy item.node {\n+    match item.node {\n       ast::item_fn(ref decl, purity, ref generics, ref body) => {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n@@ -2096,11 +2095,11 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n       ast::item_foreign_mod(ref foreign_mod) => {\n         let abi = match attr::foreign_abi(item.attrs) {\n             Right(abi_) => abi_,\n-            Left(ref msg) => ccx.sess.span_fatal(item.span, /*bad*/copy *msg)\n+            Left(msg) => ccx.sess.span_fatal(item.span, msg)\n         };\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }\n-      ast::item_struct(struct_def, generics) => {\n+      ast::item_struct(struct_def, ref generics) => {\n         if !generics.is_type_parameterized() {\n             trans_struct_def(ccx, struct_def, path, item.id);\n         }\n@@ -2124,7 +2123,7 @@ pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def,\n         // otherwise this is a unit-like struct.\n         Some(ctor_id) if struct_def.fields.len() > 0 => {\n             let llfndecl = get_item_val(ccx, ctor_id);\n-            trans_tuple_struct(ccx, /*bad*/copy struct_def.fields,\n+            trans_tuple_struct(ccx, struct_def.fields,\n                                ctor_id, None, llfndecl);\n         }\n         Some(_) | None => {}\n@@ -2405,7 +2404,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n                                                  i.id,\n                                                  i.attrs)\n                 };\n-                set_inline_hint_if_appr(/*bad*/copy i.attrs, llfn);\n+                set_inline_hint_if_appr(i.attrs, llfn);\n                 llfn\n               }\n               _ => fail!(~\"get_item_val: weird result in table\")\n@@ -2479,8 +2478,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n \n           ast_map::node_variant(ref v, enm, pth) => {\n             let llfn;\n-            match /*bad*/copy (*v).node.kind {\n-                ast::tuple_variant_kind(args) => {\n+            match v.node.kind {\n+                ast::tuple_variant_kind(ref args) => {\n                     fail_unless!(args.len() != 0u);\n                     let pth = vec::append(/*bad*/copy *pth,\n                                           ~[path_name(enm.ident),\n@@ -2543,7 +2542,7 @@ pub fn register_method(ccx: @CrateContext,\n     let pth = vec::append(/*bad*/copy *pth, ~[path_name((ccx.names)(~\"meth\")),\n                                   path_name(m.ident)]);\n     let llfn = register_fn_full(ccx, m.span, pth, id, m.attrs, mty);\n-    set_inline_hint_if_appr(/*bad*/copy m.attrs, llfn);\n+    set_inline_hint_if_appr(m.attrs, llfn);\n     llfn\n }\n \n@@ -3013,17 +3012,16 @@ pub fn trans_crate(sess: session::Session,\n             llvm::LLVMModuleCreateWithNameInContext\n                 (buf, llvm::LLVMGetGlobalContext())\n         });\n-        let data_layout = /*bad*/copy sess.targ_cfg.target_strs.data_layout;\n-        let targ_triple = /*bad*/copy sess.targ_cfg.target_strs.target_triple;\n+        let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n+        let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n         let _: () =\n             str::as_c_str(data_layout,\n                         |buf| llvm::LLVMSetDataLayout(llmod, buf));\n         let _: () =\n             str::as_c_str(targ_triple,\n                         |buf| llvm::LLVMSetTarget(llmod, buf));\n         let targ_cfg = sess.targ_cfg;\n-        let td = mk_target_data(\n-            /*bad*/copy sess.targ_cfg.target_strs.data_layout);\n+        let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n         let tn = mk_type_names();\n         let intrinsics = declare_intrinsics(llmod);\n         if sess.opts.extra_debuginfo {"}, {"sha": "0933cf6c8e5350e23d1413d549576f0cc0efe669", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -70,10 +70,9 @@ pub fn count_insn(cx: block, category: &str) {\n         let mut s = ~\".\";\n         i = 0u;\n         while i < len {\n-            let e = /*bad*/copy v[i];\n-            i = mm.get(&e);\n+            i = mm.get(&v[i]);\n             s += ~\"/\";\n-            s += e;\n+            s += v[i];\n             i += 1u;\n         }\n "}, {"sha": "8c95ee4fd963508749535e8a5d3100649a016a72", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -1291,14 +1291,14 @@ pub type mono_id = @mono_id_;\n \n impl to_bytes::IterBytes for mono_param_id {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        match /*bad*/copy *self {\n-          mono_precise(t, mids) =>\n-          to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), &mids, lsb0, f),\n+        match *self {\n+            mono_precise(t, ref mids) =>\n+                to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), mids, lsb0, f),\n \n-          mono_any => 1u8.iter_bytes(lsb0, f),\n+            mono_any => 1u8.iter_bytes(lsb0, f),\n \n-          mono_repr(ref a, ref b, ref c, ref d) =>\n-          to_bytes::iter_bytes_5(&2u8, a, b, c, d, lsb0, f)\n+            mono_repr(ref a, ref b, ref c, ref d) =>\n+                to_bytes::iter_bytes_5(&2u8, a, b, c, d, lsb0, f)\n         }\n     }\n }\n@@ -1340,7 +1340,7 @@ pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n }\n \n pub fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n-    match /*bad*/copy bcx.fcx.param_substs {\n+    match bcx.fcx.param_substs {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n         }\n@@ -1367,7 +1367,7 @@ pub fn expr_ty_adjusted(bcx: block, ex: @ast::expr) -> ty::t {\n pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n-    match /*bad*/copy bcx.fcx.param_substs {\n+    match bcx.fcx.param_substs {\n       Some(substs) => {\n         do vec::map(params) |t| {\n             ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n@@ -1396,7 +1396,7 @@ pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, +vt: typeck::vtable_origin)\n     let tcx = fcx.ccx.tcx;\n     match vt {\n         typeck::vtable_static(trait_id, tys, sub) => {\n-            let tys = match /*bad*/copy fcx.param_substs {\n+            let tys = match fcx.param_substs {\n                 Some(substs) => {\n                     do vec::map(tys) |t| {\n                         ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)"}, {"sha": "b630a9b44e84a90046e54bccf167bb3c587d5a7b", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -242,7 +242,7 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n     unsafe {\n         let _icx = cx.insn_ctxt(\"const_expr\");\n-        return match /*bad*/copy e.node {\n+        return match e.node {\n           ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n           ast::expr_binary(b, e1, e2) => {\n             let te1 = const_expr(cx, e1);\n@@ -438,7 +438,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n           ast::expr_addr_of(ast::m_imm, sub) => {\n               const_addr_of(cx, const_expr(cx, sub))\n           }\n-          ast::expr_tup(es) => {\n+          ast::expr_tup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n               adt::trans_const(cx, repr, 0, es.map(|e| const_expr(cx, *e)))\n@@ -460,24 +460,24 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                   adt::trans_const(cx, repr, discr, cs)\n               }\n           }\n-          ast::expr_vec(es, ast::m_imm) => {\n-            let (v, _, _) = const_vec(cx, e, es);\n+          ast::expr_vec(ref es, ast::m_imm) => {\n+            let (v, _, _) = const_vec(cx, e, *es);\n             v\n           }\n           ast::expr_vstore(e, ast::expr_vstore_fixed(_)) => {\n             const_expr(cx, e)\n           }\n           ast::expr_vstore(sub, ast::expr_vstore_slice) => {\n-            match /*bad*/copy sub.node {\n-              ast::expr_lit(lit) => {\n+            match sub.node {\n+              ast::expr_lit(ref lit) => {\n                 match lit.node {\n                   ast::lit_str(*) => { const_expr(cx, sub) }\n                   _ => { cx.sess.span_bug(e.span,\n                                           ~\"bad const-slice lit\") }\n                 }\n               }\n-              ast::expr_vec(es, ast::m_imm) => {\n-                let (cv, sz, llunitty) = const_vec(cx, e, es);\n+              ast::expr_vec(ref es, ast::m_imm) => {\n+                let (cv, sz, llunitty) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n                 let gv = do str::as_c_str(\"const\") |name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty, name)\n@@ -525,7 +525,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 }\n             }\n           }\n-          ast::expr_call(callee, args, _) => {\n+          ast::expr_call(callee, ref args, _) => {\n               match cx.tcx.def_map.find(&callee.id) {\n                   Some(ast::def_struct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);"}, {"sha": "f74f83e4573f50c803c485dbff1f1dd990dbeaae", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -520,7 +520,7 @@ fn create_struct(cx: @CrateContext, t: ty::t, fields: ~[ty::field],\n     return mdval;\n }\n \n-fn create_tuple(cx: @CrateContext, t: ty::t, elements: ~[ty::t], span: span)\n+fn create_tuple(cx: @CrateContext, t: ty::t, elements: &[ty::t], span: span)\n     -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n@@ -648,46 +648,46 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n     }*/\n \n     let sty = copy ty::get(t).sty;\n-    match copy sty {\n+    match sty {\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_)\n         | ty::ty_float(_) => create_basic_type(cx, t, span),\n         ty::ty_estr(_vstore) => {\n             cx.sess.span_bug(span, ~\"debuginfo for estr NYI\")\n         },\n-        ty::ty_enum(_did, _substs) => {\n+        ty::ty_enum(_did, ref _substs) => {\n             cx.sess.span_bug(span, ~\"debuginfo for enum NYI\")\n         }\n-        ty::ty_box(_mt) => {\n+        ty::ty_box(ref _mt) => {\n             cx.sess.span_bug(span, ~\"debuginfo for box NYI\")\n         },\n-        ty::ty_uniq(_mt) => {\n+        ty::ty_uniq(ref _mt) => {\n             cx.sess.span_bug(span, ~\"debuginfo for uniq NYI\")\n         },\n-        ty::ty_evec(_mt, _vstore) => {\n+        ty::ty_evec(ref _mt, ref _vstore) => {\n             cx.sess.span_bug(span, ~\"debuginfo for evec NYI\")\n         },\n-        ty::ty_ptr(mt) => {\n+        ty::ty_ptr(ref mt) => {\n             let pointee = create_ty(cx, mt.ty, span);\n             create_pointer_type(cx, t, span, pointee)\n         },\n-        ty::ty_rptr(_region, _mt) => {\n+        ty::ty_rptr(ref _region, ref _mt) => {\n             cx.sess.span_bug(span, ~\"debuginfo for rptr NYI\")\n         },\n-        ty::ty_bare_fn(_barefnty) => {\n+        ty::ty_bare_fn(ref _barefnty) => {\n             cx.sess.span_bug(span, ~\"debuginfo for bare_fn NYI\")\n         },\n-        ty::ty_closure(_closurety) => {\n+        ty::ty_closure(ref _closurety) => {\n             cx.sess.span_bug(span, ~\"debuginfo for closure NYI\")\n         },\n-        ty::ty_trait(_did, _substs, _vstore) => {\n+        ty::ty_trait(_did, ref _substs, ref _vstore) => {\n             cx.sess.span_bug(span, ~\"debuginfo for trait NYI\")\n         },\n-        ty::ty_struct(did, substs) => {\n-            let fields = ty::struct_fields(cx.tcx, did, &substs);\n+        ty::ty_struct(did, ref substs) => {\n+            let fields = ty::struct_fields(cx.tcx, did, substs);\n             create_struct(cx, t, fields, span)\n         },\n-        ty::ty_tup(elements) => {\n-            create_tuple(cx, t, elements, span)\n+        ty::ty_tup(ref elements) => {\n+            create_tuple(cx, t, *elements, span)\n         },\n         _ => cx.sess.bug(~\"debuginfo: unexpected type in create_ty\")\n     }\n@@ -853,8 +853,8 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n \n     let (ident, ret_ty, id) = match cx.tcx.items.get(&fcx.id) {\n       ast_map::node_item(item, _) => {\n-        match /*bad*/copy item.node {\n-          ast::item_fn(decl, _, _, _) => {\n+        match item.node {\n+          ast::item_fn(ref decl, _, _, _) => {\n             (item.ident, decl.output, item.id)\n           }\n           _ => fcx.ccx.sess.span_bug(item.span, ~\"create_function: item \\\n@@ -865,8 +865,8 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n           (method.ident, method.decl.output, method.id)\n       }\n       ast_map::node_expr(expr) => {\n-        match /*bad*/copy expr.node {\n-          ast::expr_fn_block(decl, _) => {\n+        match expr.node {\n+          ast::expr_fn_block(ref decl, _) => {\n             ((dbg_cx.names)(~\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,"}, {"sha": "2352ada8cedb358370d91ddc9b4ecc7c4f46536d", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -792,7 +792,7 @@ pub fn emit_tydescs(ccx: @CrateContext) {\n         // tydesc type. Then we'll recast each function to its real type when\n         // calling it.\n         let take_glue =\n-            match copy ti.take_glue {\n+            match ti.take_glue {\n               None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               Some(v) => {\n                 unsafe {\n@@ -802,7 +802,7 @@ pub fn emit_tydescs(ccx: @CrateContext) {\n               }\n             };\n         let drop_glue =\n-            match copy ti.drop_glue {\n+            match ti.drop_glue {\n               None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               Some(v) => {\n                 unsafe {\n@@ -812,7 +812,7 @@ pub fn emit_tydescs(ccx: @CrateContext) {\n               }\n             };\n         let free_glue =\n-            match copy ti.free_glue {\n+            match ti.free_glue {\n               None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               Some(v) => {\n                 unsafe {\n@@ -822,7 +822,7 @@ pub fn emit_tydescs(ccx: @CrateContext) {\n               }\n             };\n         let visit_glue =\n-            match copy ti.visit_glue {\n+            match ti.visit_glue {\n               None => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               Some(v) => {\n                 unsafe {"}, {"sha": "205acedb9e1c2ad3f923622a6e0d8a996fd7c485", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -320,12 +320,12 @@ pub fn trans_static_method_callee(bcx: block,\n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get(&callee_id));\n \n-    match /*bad*/copy vtbls[bound_index] {\n-        typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n+    match vtbls[bound_index] {\n+        typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n \n             let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n             let callee_substs = combine_impl_and_methods_tps(\n-                bcx, mth_id, impl_did, callee_id, rcvr_substs);\n+                bcx, mth_id, impl_did, callee_id, *rcvr_substs);\n             let callee_origins = combine_impl_and_methods_origins(\n                 bcx, mth_id, impl_did, callee_id, rcvr_origins);\n \n@@ -347,7 +347,7 @@ pub fn trans_static_method_callee(bcx: block,\n     }\n }\n \n-pub fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n+pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n     -> Option<ast::def_id> {\n     ms.find(|m| m.ident == name).map(|m| ast_util::local_def(m.id))\n }\n@@ -360,7 +360,7 @@ pub fn method_with_name(ccx: @CrateContext, impl_id: ast::def_id,\n                 node: ast::item_impl(_, _, _, ref ms),\n                 _\n             }, _) => {\n-            method_from_methods(/*bad*/copy *ms, name).get()\n+            method_from_methods(*ms, name).get()\n           }\n           _ => fail!(~\"method_with_name\")\n         }\n@@ -376,7 +376,7 @@ pub fn method_with_name_or_default(ccx: @CrateContext, impl_id: ast::def_id,\n           ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref ms), _\n           }, _) => {\n-              let did = method_from_methods(/*bad*/copy *ms, name);\n+              let did = method_from_methods(*ms, name);\n               if did.is_some() {\n                   return did.get();\n               } else {\n@@ -440,7 +440,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n                                -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     return match vtbl {\n-      typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n+      typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n           let mname = ty::trait_methods(ccx.tcx, trait_id)[n_method].ident;\n           let mth_id = method_with_name_or_default(\n@@ -453,7 +453,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n           // create a concatenated set of substitutions which includes\n           // those from the impl and those from the method:\n           let callee_substs = combine_impl_and_methods_tps(\n-              bcx, mth_id, impl_did, callee_id, rcvr_substs);\n+              bcx, mth_id, impl_did, callee_id, *rcvr_substs);\n           let callee_origins = combine_impl_and_methods_origins(\n               bcx, mth_id, impl_did, callee_id, rcvr_origins);\n \n@@ -490,7 +490,7 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n                                     mth_did: ast::def_id,\n                                     impl_did: ast::def_id,\n                                     callee_id: ast::node_id,\n-                                    +rcvr_substs: ~[ty::t])\n+                                    rcvr_substs: &[ty::t])\n                                  -> ~[ty::t] {\n     /*!\n     *\n@@ -514,7 +514,7 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n     let node_substs = node_id_type_params(bcx, callee_id);\n     debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(*t)));\n     let ty_substs\n-        = vec::append(rcvr_substs,\n+        = vec::append(rcvr_substs.to_vec(),\n                       vec::tailn(node_substs,\n                                  node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps=%?\", n_m_tps);"}, {"sha": "015fc61a3c880a218fe7e0d4195e93e4f60b0a16", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -98,7 +98,7 @@ fn traverse_public_mod(cx: ctx, mod_id: node_id, m: &_mod) {\n fn traverse_public_item(cx: ctx, item: @item) {\n     if cx.rmap.contains_key(&item.id) { return; }\n     cx.rmap.insert(item.id, ());\n-    match /*bad*/copy item.node {\n+    match item.node {\n       item_mod(ref m) => traverse_public_mod(cx, item.id, m),\n       item_foreign_mod(ref nm) => {\n           if !traverse_exports(cx, item.id) {"}, {"sha": "c6bf8ff3a3a2b2dca0d83ab42bccba111f2c6bfd", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -75,7 +75,7 @@ pub impl Reflector {\n         PointerCast(bcx, static_ti.tydesc, T_ptr(self.tydesc_ty))\n     }\n \n-    fn c_mt(&mut self, mt: ty::mt) -> ~[ValueRef] {\n+    fn c_mt(&mut self, mt: &ty::mt) -> ~[ValueRef] {\n         ~[self.c_uint(mt.mutbl as uint),\n           self.c_tydesc(mt.ty)]\n     }\n@@ -151,7 +151,7 @@ pub impl Reflector {\n         debug!(\"reflect::visit_ty %s\",\n                ty_to_str(bcx.ccx().tcx, t));\n \n-        match /*bad*/copy ty::get(t).sty {\n+        match ty::get(t).sty {\n           ty::ty_bot => self.leaf(~\"bot\"),\n           ty::ty_nil => self.leaf(~\"nil\"),\n           ty::ty_bool => self.leaf(~\"bool\"),\n@@ -170,7 +170,7 @@ pub impl Reflector {\n           ty::ty_float(ast::ty_f32) => self.leaf(~\"f32\"),\n           ty::ty_float(ast::ty_f64) => self.leaf(~\"f64\"),\n \n-          ty::ty_unboxed_vec(mt) => {\n+          ty::ty_unboxed_vec(ref mt) => {\n               let values = self.c_mt(mt);\n               self.visit(~\"vec\", values)\n           }\n@@ -179,30 +179,30 @@ pub impl Reflector {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               self.visit(~\"estr_\" + name, extra)\n           }\n-          ty::ty_evec(mt, vst) => {\n+          ty::ty_evec(ref mt, vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               let extra = extra + self.c_mt(mt);\n               self.visit(~\"evec_\" + name, extra)\n           }\n-          ty::ty_box(mt) => {\n+          ty::ty_box(ref mt) => {\n               let extra = self.c_mt(mt);\n               self.visit(~\"box\", extra)\n           }\n-          ty::ty_uniq(mt) => {\n+          ty::ty_uniq(ref mt) => {\n               let extra = self.c_mt(mt);\n               self.visit(~\"uniq\", extra)\n           }\n-          ty::ty_ptr(mt) => {\n+          ty::ty_ptr(ref mt) => {\n               let extra = self.c_mt(mt);\n               self.visit(~\"ptr\", extra)\n           }\n-          ty::ty_rptr(_, mt) => {\n+          ty::ty_rptr(_, ref mt) => {\n               let extra = self.c_mt(mt);\n               self.visit(~\"rptr\", extra)\n           }\n \n-          ty::ty_tup(tys) => {\n-              let extra = ~[self.c_uint(vec::len(tys))]\n+          ty::ty_tup(ref tys) => {\n+              let extra = ~[self.c_uint(tys.len())]\n                   + self.c_size_and_align(t);\n               do self.bracketed(~\"tup\", extra) |this| {\n                   for tys.eachi |i, t| {\n@@ -254,7 +254,7 @@ pub impl Reflector {\n                       let extra = ~[this.c_uint(i),\n                                     this.c_slice(\n                                         bcx.ccx().sess.str_of(field.ident))]\n-                          + this.c_mt(field.mt);\n+                          + this.c_mt(&field.mt);\n                       this.visit(~\"class_field\", extra);\n                   }\n               }\n@@ -293,7 +293,7 @@ pub impl Reflector {\n           ty::ty_trait(_, _, _) => self.leaf(~\"trait\"),\n           ty::ty_infer(_) => self.leaf(~\"infer\"),\n           ty::ty_err => self.leaf(~\"err\"),\n-          ty::ty_param(p) => {\n+          ty::ty_param(ref p) => {\n               let extra = ~[self.c_uint(p.idx)];\n               self.visit(~\"param\", extra)\n           }"}, {"sha": "586b29c19c90cf295a73db0b2dd57e83895b2d30", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -361,7 +361,7 @@ pub fn write_content(bcx: block,\n            bcx.expr_to_str(vstore_expr));\n     let _indenter = indenter();\n \n-    match /*bad*/copy content_expr.node {\n+    match content_expr.node {\n         ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n             match dest {\n                 Ignore => {\n@@ -376,7 +376,7 @@ pub fn write_content(bcx: block,\n                 }\n             }\n         }\n-        ast::expr_vec(elements, _) => {\n+        ast::expr_vec(ref elements, _) => {\n             match dest {\n                 Ignore => {\n                     for elements.each |element| {\n@@ -467,11 +467,11 @@ pub fn vec_types(bcx: block, vec_ty: ty::t) -> VecTypes {\n pub fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n-    match /*bad*/copy content_expr.node {\n+    match content_expr.node {\n         ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n             s.len() + 1\n         },\n-        ast::expr_vec(es, _) => es.len(),\n+        ast::expr_vec(ref es, _) => es.len(),\n         ast::expr_repeat(_, count_expr, _) => {\n             ty::eval_repeat_count(bcx.tcx(), count_expr)\n         }"}, {"sha": "785a31836767bd9a0b0571f8b747fa02e63167a8", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -176,7 +176,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n     }\n \n     // XXX: This is a terrible terrible copy.\n-    let llty = match /*bad*/copy ty::get(t).sty {\n+    let llty = match ty::get(t).sty {\n       ty::ty_nil | ty::ty_bot => T_nil(),\n       ty::ty_bool => T_bool(),\n       ty::ty_int(t) => T_int_ty(cx, t),\n@@ -199,22 +199,22 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       ty::ty_estr(ty::vstore_box) => {\n         T_box_ptr(T_box(cx, T_vec(cx, T_i8())))\n       }\n-      ty::ty_evec(mt, ty::vstore_box) => {\n+      ty::ty_evec(ref mt, ty::vstore_box) => {\n         T_box_ptr(T_box(cx, T_vec(cx, type_of(cx, mt.ty))))\n       }\n-      ty::ty_box(mt) => T_box_ptr(T_box(cx, type_of(cx, mt.ty))),\n+      ty::ty_box(ref mt) => T_box_ptr(T_box(cx, type_of(cx, mt.ty))),\n       ty::ty_opaque_box => T_box_ptr(T_box(cx, T_i8())),\n-      ty::ty_uniq(mt) => T_unique_ptr(T_unique(cx, type_of(cx, mt.ty))),\n-      ty::ty_evec(mt, ty::vstore_uniq) => {\n+      ty::ty_uniq(ref mt) => T_unique_ptr(T_unique(cx, type_of(cx, mt.ty))),\n+      ty::ty_evec(ref mt, ty::vstore_uniq) => {\n         T_unique_ptr(T_unique(cx, T_vec(cx, type_of(cx, mt.ty))))\n       }\n-      ty::ty_unboxed_vec(mt) => {\n+      ty::ty_unboxed_vec(ref mt) => {\n         T_vec(cx, type_of(cx, mt.ty))\n       }\n-      ty::ty_ptr(mt) => T_ptr(type_of(cx, mt.ty)),\n-      ty::ty_rptr(_, mt) => T_ptr(type_of(cx, mt.ty)),\n+      ty::ty_ptr(ref mt) => T_ptr(type_of(cx, mt.ty)),\n+      ty::ty_rptr(_, ref mt) => T_ptr(type_of(cx, mt.ty)),\n \n-      ty::ty_evec(mt, ty::vstore_slice(_)) => {\n+      ty::ty_evec(ref mt, ty::vstore_slice(_)) => {\n         T_struct(~[T_ptr(type_of(cx, mt.ty)),\n                    T_uint_ty(cx, ast::ty_u)])\n       }\n@@ -228,7 +228,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n         T_array(T_i8(), n + 1u /* +1 for trailing null */)\n       }\n \n-      ty::ty_evec(mt, ty::vstore_fixed(n)) => {\n+      ty::ty_evec(ref mt, ty::vstore_fixed(n)) => {\n         T_array(type_of(cx, mt.ty), n)\n       }\n "}, {"sha": "fc634f91ccf5fda2e66eeb53dc40951a5034050c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -1161,20 +1161,20 @@ pub fn walk_ty(ty: t, f: &fn(t)) {\n \n pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n     if !f(ty) { return; }\n-    match /*bad*/copy get(ty).sty {\n+    match get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self |\n       ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {\n       }\n-      ty_box(tm) | ty_evec(tm, _) | ty_unboxed_vec(tm) |\n-      ty_ptr(tm) | ty_rptr(_, tm) => {\n+      ty_box(ref tm) | ty_evec(ref tm, _) | ty_unboxed_vec(ref tm) |\n+      ty_ptr(ref tm) | ty_rptr(_, ref tm) | ty_uniq(ref tm) => {\n         maybe_walk_ty(tm.ty, f);\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n       ty_trait(_, ref substs, _) => {\n         for (*substs).tps.each |subty| { maybe_walk_ty(*subty, f); }\n       }\n-      ty_tup(ts) => { for ts.each |tt| { maybe_walk_ty(*tt, f); } }\n+      ty_tup(ref ts) => { for ts.each |tt| { maybe_walk_ty(*tt, f); } }\n       ty_bare_fn(ref ft) => {\n         for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.sig.output, f);\n@@ -1183,7 +1183,6 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n         for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n-      ty_uniq(tm) => { maybe_walk_ty(tm.ty, f); }\n     }\n }\n \n@@ -1209,20 +1208,20 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n                 tps: substs.tps.map(|t| fldop(*t))}\n     }\n \n-    match /*bad*/copy *sty {\n-        ty_box(tm) => {\n+    match *sty {\n+        ty_box(ref tm) => {\n             ty_box(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n-        ty_uniq(tm) => {\n+        ty_uniq(ref tm) => {\n             ty_uniq(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n-        ty_ptr(tm) => {\n+        ty_ptr(ref tm) => {\n             ty_ptr(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n-        ty_unboxed_vec(tm) => {\n+        ty_unboxed_vec(ref tm) => {\n             ty_unboxed_vec(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n-        ty_evec(tm, vst) => {\n+        ty_evec(ref tm, vst) => {\n             ty_evec(mt {ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n         }\n         ty_enum(tid, ref substs) => {\n@@ -1231,8 +1230,8 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n         ty_trait(did, ref substs, st) => {\n             ty_trait(did, fold_substs(substs, fldop), st)\n         }\n-        ty_tup(ts) => {\n-            let new_ts = vec::map(ts, |tt| fldop(*tt));\n+        ty_tup(ref ts) => {\n+            let new_ts = ts.map(|tt| fldop(*tt));\n             ty_tup(new_ts)\n         }\n         ty_bare_fn(ref f) => {\n@@ -1243,7 +1242,7 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n             let sig = fold_sig(&f.sig, fldop);\n             ty_closure(ClosureTy {sig: sig, ..copy *f})\n         }\n-        ty_rptr(r, tm) => {\n+        ty_rptr(r, ref tm) => {\n             ty_rptr(r, mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_struct(did, ref substs) => {\n@@ -1510,8 +1509,8 @@ pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n }\n \n pub fn get_element_type(ty: t, i: uint) -> t {\n-    match /*bad*/copy get(ty).sty {\n-      ty_tup(ts) => return ts[i],\n+    match get(ty).sty {\n+      ty_tup(ref ts) => return ts[i],\n       _ => fail!(~\"get_element_type called on invalid type\")\n     }\n }\n@@ -2118,7 +2117,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n     /// gives a rough estimate of how much space it takes to represent\n     /// an instance of `ty`.  Used for the mode transition.\n     fn type_size(cx: ctxt, ty: t) -> uint {\n-        match /*bad*/copy get(ty).sty {\n+        match get(ty).sty {\n           ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n           ty_ptr(_) | ty_box(_) | ty_uniq(_) | ty_estr(vstore_uniq) |\n           ty_trait(*) | ty_rptr(*) | ty_evec(_, vstore_uniq) |\n@@ -2146,7 +2145,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n           }\n \n-          ty_tup(tys) => {\n+          ty_tup(ref tys) => {\n             tys.foldl(0, |s, t| *s + type_size(cx, *t))\n           }\n \n@@ -2208,7 +2207,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty));\n \n-        let r = match /*bad*/copy get(ty).sty {\n+        let r = match get(ty).sty {\n           ty_nil |\n           ty_bot |\n           ty_bool |\n@@ -2229,9 +2228,9 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_unboxed_vec(_) => {\n             false\n           }\n-          ty_box(mt) |\n-          ty_uniq(mt) |\n-          ty_rptr(_, mt) => {\n+          ty_box(ref mt) |\n+          ty_uniq(ref mt) |\n+          ty_rptr(_, ref mt) => {\n             return type_requires(cx, seen, r_ty, mt.ty);\n           }\n \n@@ -2255,8 +2254,8 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             r\n           }\n \n-          ty_tup(ts) => {\n-            vec::any(ts, |t| type_requires(cx, seen, r_ty, *t))\n+          ty_tup(ref ts) => {\n+            ts.any(|t| type_requires(cx, seen, r_ty, *t))\n           }\n \n           ty_enum(ref did, _) if vec::contains(*seen, did) => {\n@@ -2297,7 +2296,7 @@ pub fn type_structurally_contains(cx: ctxt,\n     debug!(\"type_structurally_contains: %s\",\n            ::util::ppaux::ty_to_str(cx, ty));\n     if test(sty) { return true; }\n-    match /*bad*/copy *sty {\n+    match *sty {\n       ty_enum(did, ref substs) => {\n         for vec::each(*enum_variants(cx, did)) |variant| {\n             for variant.args.each |aty| {\n@@ -2315,13 +2314,13 @@ pub fn type_structurally_contains(cx: ctxt,\n         return false;\n       }\n \n-      ty_tup(ts) => {\n+      ty_tup(ref ts) => {\n         for ts.each |tt| {\n             if type_structurally_contains(cx, *tt, test) { return true; }\n         }\n         return false;\n       }\n-      ty_evec(mt, vstore_fixed(_)) => {\n+      ty_evec(ref mt, vstore_fixed(_)) => {\n         return type_structurally_contains(cx, mt.ty, test);\n       }\n       _ => return false\n@@ -2375,7 +2374,7 @@ pub fn type_is_signed(ty: t) -> bool {\n // that the cycle collector might care about.\n pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let mut result = true;\n-    match /*bad*/copy get(ty).sty {\n+    match get(ty).sty {\n       // Scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) | ty_bare_fn(_) => result = true,\n@@ -2395,11 +2394,11 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n             if !type_is_pod(cx, tup_ty) { result = false; }\n         }\n       }\n-      ty_tup(elts) => {\n+      ty_tup(ref elts) => {\n         for elts.each |elt| { if !type_is_pod(cx, *elt) { result = false; } }\n       }\n       ty_estr(vstore_fixed(_)) => result = true,\n-      ty_evec(mt, vstore_fixed(_)) | ty_unboxed_vec(mt) => {\n+      ty_evec(ref mt, vstore_fixed(_)) | ty_unboxed_vec(ref mt) => {\n         result = type_is_pod(cx, mt.ty);\n       }\n       ty_param(_) => result = false,\n@@ -3007,8 +3006,8 @@ pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n             // trait itself.  This ought to be harmonized.\n             let trt_bounds =\n                 ty::lookup_item_type(tcx, trt_id).bounds;\n-            let mth = /*bad*/copy ty::trait_methods(tcx, trt_id)[n_mth];\n-            @(vec::append(/*bad*/copy *trt_bounds, *mth.tps))\n+            @(vec::append(/*bad*/copy *trt_bounds,\n+                          *ty::trait_methods(tcx, trt_id)[n_mth].tps))\n           }\n         }\n     }\n@@ -3528,7 +3527,7 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n                         node: item_trait(_, _, ref ms),\n                         _\n                     }, _)) =>\n-                match ast_util::split_trait_methods((/*bad*/copy *ms)) {\n+                match ast_util::split_trait_methods(*ms) {\n                    (_, p) => p.map(|method| method.ident)\n                 },\n             _ => cx.sess.bug(fmt!(\"provided_trait_methods: %? is not a trait\",\n@@ -3830,9 +3829,8 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n                 }, _) => {\n-            let variants = /*bad*/copy (*enum_definition).variants;\n             let mut disr_val = -1;\n-            @vec::map(variants, |variant| {\n+            @vec::map(enum_definition.variants, |variant| {\n                 match variant.node.kind {\n                     ast::tuple_variant_kind(ref args) => {\n                         let ctor_ty = node_id_to_type(cx, variant.node.id);\n@@ -3945,15 +3943,15 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n        Some(ast_map::node_item(i,_)) => {\n          match i.node {\n             ast::item_struct(struct_def, _) => {\n-               struct_field_tys(/*bad*/copy struct_def.fields)\n+               struct_field_tys(struct_def.fields)\n             }\n             _ => cx.sess.bug(~\"struct ID bound to non-struct\")\n          }\n        }\n        Some(ast_map::node_variant(ref variant, _, _)) => {\n           match (*variant).node.kind {\n             ast::struct_variant_kind(struct_def) => {\n-              struct_field_tys(/*bad*/copy struct_def.fields)\n+              struct_field_tys(struct_def.fields)\n             }\n             _ => {\n               cx.sess.bug(~\"struct ID bound to enum variant that isn't \\\n@@ -3993,7 +3991,7 @@ pure fn is_public(f: field_ty) -> bool {\n     }\n }\n \n-fn struct_field_tys(fields: ~[@struct_field]) -> ~[field_ty] {\n+fn struct_field_tys(fields: &[@struct_field]) -> ~[field_ty] {\n     do fields.map |field| {\n         match field.node.kind {\n             named_field(ident, mutability, visibility) => {"}, {"sha": "b49c8c2bff8618849723e26585e114a56b2ba2ce", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -212,7 +212,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n     self: &AC, rscope: &RS, &&ast_ty: @ast::Ty) -> ty::t {\n \n     fn ast_mt_to_mt<AC:AstConv, RS:region_scope + Copy + Durable>(\n-        self: &AC, rscope: &RS, mt: ast::mt) -> ty::mt {\n+        self: &AC, rscope: &RS, mt: &ast::mt) -> ty::mt {\n \n         ty::mt {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl}\n     }\n@@ -223,14 +223,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n     fn mk_pointer<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: &AC,\n         rscope: &RS,\n-        a_seq_ty: ast::mt,\n+        a_seq_ty: &ast::mt,\n         vst: ty::vstore,\n         constr: &fn(ty::mt) -> ty::t) -> ty::t\n     {\n         let tcx = self.tcx();\n \n         match a_seq_ty.ty.node {\n-            ast::ty_vec(mt) => {\n+            ast::ty_vec(ref mt) => {\n                 let mut mt = ast_mt_to_mt(self, rscope, mt);\n                 if a_seq_ty.mutbl == ast::m_mutbl ||\n                         a_seq_ty.mutbl == ast::m_const {\n@@ -318,34 +318,34 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n     }\n \n     tcx.ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_unresolved);\n-    let typ = match /*bad*/copy ast_ty.node {\n+    let typ = match ast_ty.node {\n       ast::ty_nil => ty::mk_nil(tcx),\n       ast::ty_bot => ty::mk_bot(tcx),\n-      ast::ty_box(mt) => {\n+      ast::ty_box(ref mt) => {\n         mk_pointer(self, rscope, mt, ty::vstore_box,\n                    |tmt| ty::mk_box(tcx, tmt))\n       }\n-      ast::ty_uniq(mt) => {\n+      ast::ty_uniq(ref mt) => {\n         mk_pointer(self, rscope, mt, ty::vstore_uniq,\n                    |tmt| ty::mk_uniq(tcx, tmt))\n       }\n-      ast::ty_vec(mt) => {\n+      ast::ty_vec(ref mt) => {\n         tcx.sess.span_err(ast_ty.span,\n                           ~\"bare `[]` is not a type\");\n         // return /something/ so they can at least get more errors\n         ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, mt),\n                     ty::vstore_uniq)\n       }\n-      ast::ty_ptr(mt) => {\n+      ast::ty_ptr(ref mt) => {\n         ty::mk_ptr(tcx, ast_mt_to_mt(self, rscope, mt))\n       }\n-      ast::ty_rptr(region, mt) => {\n+      ast::ty_rptr(region, ref mt) => {\n         let r = ast_region_to_region(self, rscope, ast_ty.span, region);\n         mk_pointer(self, rscope, mt, ty::vstore_slice(r),\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n-      ast::ty_tup(fields) => {\n-        let flds = vec::map(fields, |t| ast_ty_to_ty(self, rscope, *t));\n+      ast::ty_tup(ref fields) => {\n+        let flds = fields.map(|t| ast_ty_to_ty(self, rscope, *t));\n         ty::mk_tup(tcx, flds)\n       }\n       ast::ty_bare_fn(ref bf) => {\n@@ -413,7 +413,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n           }\n         }\n       }\n-      ast::ty_fixed_length_vec(a_mt, e) => {\n+      ast::ty_fixed_length_vec(ref a_mt, e) => {\n         match const_eval::eval_const_expr_partial(tcx, e) {\n           Ok(ref r) => {\n             match *r {"}, {"sha": "5e106668fc97e2ff25feb2ee553f8c2445c2f8bc", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -28,7 +28,7 @@ use syntax::print::pprust;\n pub fn check_match(fcx: @mut FnCtxt,\n                    expr: @ast::expr,\n                    discrim: @ast::expr,\n-                   arms: ~[ast::arm]) -> bool {\n+                   arms: &[ast::arm]) -> bool {\n     let tcx = fcx.ccx.tcx;\n     let mut bot;\n \n@@ -74,7 +74,7 @@ pub struct pat_ctxt {\n }\n \n pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n-                         +subpats: Option<~[@ast::pat]>, expected: ty::t) {\n+                         subpats: &Option<~[@ast::pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -162,7 +162,7 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n \n     // Count the number of subpatterns.\n     let subpats_len;\n-    match subpats {\n+    match *subpats {\n         None => subpats_len = arg_len,\n         Some(ref subpats) => subpats_len = subpats.len()\n     }\n@@ -207,7 +207,7 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n pub fn check_struct_pat_fields(pcx: pat_ctxt,\n                                span: span,\n                                path: @ast::path,\n-                               fields: ~[ast::field_pat],\n+                               fields: &[ast::field_pat],\n                                class_fields: ~[ty::field_ty],\n                                class_id: ast::def_id,\n                                substitutions: &ty::substs,\n@@ -258,7 +258,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n \n pub fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n                         expected: ty::t, path: @ast::path,\n-                        +fields: ~[ast::field_pat], etc: bool,\n+                        fields: &[ast::field_pat], etc: bool,\n                         class_id: ast::def_id, substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n@@ -299,7 +299,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n                                           span: span,\n                                           expected: ty::t,\n                                           path: @ast::path,\n-                                          +fields: ~[ast::field_pat],\n+                                          fields: &[ast::field_pat],\n                                           etc: bool,\n                                           enum_id: ast::def_id,\n                                           substitutions: &ty::substs) {\n@@ -336,7 +336,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    match /*bad*/copy pat.node {\n+    match pat.node {\n       ast::pat_wild => {\n         fcx.write_ty(pat.id, expected);\n       }\n@@ -409,22 +409,22 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n       }\n       ast::pat_ident(_, path, _) => {\n-        check_pat_variant(pcx, pat, path, Some(~[]), expected);\n+        check_pat_variant(pcx, pat, path, &Some(~[]), expected);\n       }\n-      ast::pat_enum(path, subpats) => {\n+      ast::pat_enum(path, ref subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n-      ast::pat_struct(path, fields, etc) => {\n+      ast::pat_struct(path, ref fields, etc) => {\n         // Grab the class data that we care about.\n         let structure = structure_of(fcx, pat.span, expected);\n         match structure {\n             ty::ty_struct(cid, ref substs) => {\n                 check_struct_pat(pcx, pat.id, pat.span, expected, path,\n-                                 fields, etc, cid, substs);\n+                                 *fields, etc, cid, substs);\n             }\n             ty::ty_enum(eid, ref substs) => {\n                 check_struct_like_enum_variant_pat(\n-                    pcx, pat.id, pat.span, expected, path, fields, etc, eid,\n+                    pcx, pat.id, pat.span, expected, path, *fields, etc, eid,\n                     substs);\n             }\n             _ => {\n@@ -439,22 +439,23 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         // Finally, write in the type.\n         fcx.write_ty(pat.id, expected);\n       }\n-      ast::pat_tup(elts) => {\n-        let ex_elts = match structure_of(fcx, pat.span, expected) {\n-          ty::ty_tup(elts) => elts,\n+      ast::pat_tup(ref elts) => {\n+        let s = structure_of(fcx, pat.span, expected);\n+        let ex_elts = match s {\n+          ty::ty_tup(ref elts) => elts,\n           _ => {\n             tcx.sess.span_fatal\n                 (pat.span,\n                  fmt!(\"mismatched types: expected `%s`, found tuple\",\n                       fcx.infcx().ty_to_str(expected)));\n           }\n         };\n-        let e_count = vec::len(elts);\n-        if e_count != vec::len(ex_elts) {\n+        let e_count = elts.len();\n+        if e_count != ex_elts.len() {\n             tcx.sess.span_fatal\n                 (pat.span, fmt!(\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n-                      fields\", vec::len(ex_elts), e_count));\n+                      fields\", ex_elts.len(), e_count));\n         }\n         let mut i = 0u;\n         for elts.each |elt| {\n@@ -509,7 +510,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           }\n         }\n       }\n-      ast::pat_vec(before, slice, after) => {\n+      ast::pat_vec(ref before, slice, ref after) => {\n         let default_region_var =\n             fcx.infcx().next_region_var_with_lb(\n                 pat.span, pcx.block_region"}, {"sha": "63a210f84ebc12198dec08b624d6fd6ec87b2671", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -1051,7 +1051,7 @@ pub impl LookupContext/&self {\n \n             let mut j = i + 1;\n             while j < candidates.len() {\n-                let candidate_b = /*bad*/copy candidates[j];\n+                let candidate_b = &candidates[j];\n                 debug!(\"attempting to merge %? and %?\",\n                        candidate_a, candidate_b);\n                 let candidates_same = match (&candidate_a.origin,"}, {"sha": "2d35fc17ede849e084fb0739492fcfedcc46e836", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -577,18 +577,18 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n     let _indenter = indenter();\n \n-    match /*bad*/copy it.node {\n+    match it.node {\n       ast::item_const(_, e) => check_const(ccx, it.span, e, it.id),\n       ast::item_enum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n-                            /*bad*/copy (*enum_definition).variants,\n+                            enum_definition.variants,\n                             it.id);\n       }\n       ast::item_fn(ref decl, _, _, ref body) => {\n         check_bare_fn(ccx, decl, body, it.id, None);\n       }\n-      ast::item_impl(_, _, ty, ms) => {\n+      ast::item_impl(_, _, ty, ref ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id);\n         debug!(\"item_impl %s with id %d rp %?\",\n                *ccx.tcx.sess.str_of(it.ident), it.id, rp);\n@@ -617,7 +617,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n       }\n-      ast::item_foreign_mod(m) => {\n+      ast::item_foreign_mod(ref m) => {\n         if syntax::attr::foreign_abi(it.attrs) ==\n             either::Right(ast::foreign_abi_rust_intrinsic) {\n             for m.items.each |item| {\n@@ -1157,7 +1157,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         call_expr_id: ast::node_id,\n         in_fty: ty::t,\n         callee_expr: @ast::expr,\n-        args: ~[@ast::expr],\n+        args: &[@ast::expr],\n         sugar: ast::CallSugar,\n         deref_args: DerefArgs) -> (ty::t, bool)\n     {\n@@ -1309,7 +1309,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                             call_expr_id: ast::node_id,\n                             fn_ty: ty::t,\n                             expr: @ast::expr,\n-                            +args: ~[@ast::expr],\n+                            args: &[@ast::expr],\n                             bot: bool,\n                             sugar: ast::CallSugar) -> bool\n     {\n@@ -1331,14 +1331,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                   sp: span,\n                   call_expr_id: ast::node_id,\n                   f: @ast::expr,\n-                  +args: ~[@ast::expr],\n+                  args: &[@ast::expr],\n                   sugar: ast::CallSugar)\n                -> bool {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n-        let mut bot = match /*bad*/copy f.node {\n-            ast::expr_field(base, field, tys) => {\n-                check_field(fcx, f, true, base, field, tys)\n+        let mut bot = match f.node {\n+            ast::expr_field(base, field, ref tys) => {\n+                check_field(fcx, f, true, base, field, *tys)\n             }\n             _ => check_expr(fcx, f)\n         };\n@@ -1358,8 +1358,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                          expr: @ast::expr,\n                          rcvr: @ast::expr,\n                          method_name: ast::ident,\n-                         +args: ~[@ast::expr],\n-                         tps: ~[@ast::Ty],\n+                         args: &[@ast::expr],\n+                         tps: &[@ast::Ty],\n                          sugar: ast::CallSugar)\n                       -> bool {\n         let bot = check_expr(fcx, rcvr);\n@@ -1594,7 +1594,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     fn check_user_unop(fcx: @mut FnCtxt,\n                        op_str: ~str,\n-                       mname: ~str,\n+                       +mname: ~str,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr,\n                        rhs_t: ty::t)\n@@ -1603,7 +1603,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                ex,\n                                rhs_expr,\n                                rhs_t,\n-                               fcx.tcx().sess.ident_of(/*bad*/ copy mname),\n+                               fcx.tcx().sess.ident_of(mname),\n                                ~[],\n                                DontDerefArgs,\n                                DontAutoderefReceiver) {\n@@ -1713,7 +1713,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                    is_callee: bool,\n                    base: @ast::expr,\n                    field: ast::ident,\n-                   tys: ~[@ast::Ty])\n+                   tys: &[@ast::Ty])\n                 -> bool {\n         let tcx = fcx.ccx.tcx;\n         let bot = check_expr(fcx, base);\n@@ -1791,8 +1791,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                       span: span,\n                                       class_id: ast::def_id,\n                                       substitutions: &ty::substs,\n-                                      field_types: ~[ty::field_ty],\n-                                      ast_fields: ~[ast::field],\n+                                      field_types: &[ty::field_ty],\n+                                      ast_fields: &[ast::field],\n                                       check_completeness: bool)\n                                    -> bool {\n         let tcx = fcx.ccx.tcx;\n@@ -1870,7 +1870,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 id: ast::node_id,\n                                 span: codemap::span,\n                                 class_id: ast::def_id,\n-                                fields: ~[ast::field],\n+                                fields: &[ast::field],\n                                 base_expr: Option<@ast::expr>)\n                              -> bool {\n         let mut bot = false;\n@@ -1955,7 +1955,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                  span: codemap::span,\n                                  enum_id: ast::def_id,\n                                  variant_id: ast::def_id,\n-                                 fields: ~[ast::field])\n+                                 fields: &[ast::field])\n                               -> bool {\n         let mut bot = false;\n         let tcx = fcx.ccx.tcx;\n@@ -2147,14 +2147,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     let mut bot = false;\n-    match /*bad*/copy expr.node {\n+    match expr.node {\n       ast::expr_vstore(ev, vst) => {\n-        let typ = match /*bad*/copy ev.node {\n+        let typ = match ev.node {\n           ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(*s), vst);\n             ty::mk_estr(tcx, tt)\n           }\n-          ast::expr_vec(args, mutbl) => {\n+          ast::expr_vec(ref args, mutbl) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, args.len(), vst);\n             let mutability;\n             match vst {\n@@ -2317,7 +2317,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let region_lb = ty::re_scope(expr.id);\n         instantiate_path(fcx, pth, tpt, expr.span, expr.id, region_lb);\n       }\n-      ast::expr_inline_asm(_, ins, outs, _, _, _) => {\n+      ast::expr_inline_asm(_, ref ins, ref outs, _, _, _) => {\n           fcx.require_unsafe(expr.span, ~\"use of inline assembly\");\n \n           for ins.each |&(_, in)| {\n@@ -2389,7 +2389,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         bot = !may_break(tcx, expr.id, body);\n       }\n       ast::expr_match(discrim, ref arms) => {\n-        bot = _match::check_match(fcx, expr, discrim, (/*bad*/copy *arms));\n+        bot = _match::check_match(fcx, expr, discrim, *arms);\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         check_expr_fn(fcx, expr, None,\n@@ -2441,11 +2441,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             };\n         fcx.write_ty(id, typ);\n       }\n-      ast::expr_call(f, args, sugar) => {\n-        bot = check_call(fcx, expr.span, expr.id, f, args, sugar);\n+      ast::expr_call(f, ref args, sugar) => {\n+        bot = check_call(fcx, expr.span, expr.id, f, *args, sugar);\n       }\n-      ast::expr_method_call(rcvr, ident, tps, args, sugar) => {\n-        bot = check_method_call(fcx, expr, rcvr, ident, args, tps, sugar);\n+      ast::expr_method_call(rcvr, ident, ref tps, ref args, sugar) => {\n+        bot = check_method_call(fcx, expr, rcvr, ident, *args, *tps, sugar);\n       }\n       ast::expr_cast(e, t) => {\n         bot = check_expr(fcx, e);\n@@ -2528,7 +2528,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n         fcx.write_ty(id, t_1);\n       }\n-      ast::expr_vec(args, mutbl) => {\n+      ast::expr_vec(ref args, mutbl) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n         for args.each |e| { bot |= check_expr_has_type(fcx, *e, t); }\n         let typ = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n@@ -2544,7 +2544,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                             ty::vstore_fixed(count));\n         fcx.write_ty(id, t);\n       }\n-      ast::expr_tup(elts) => {\n+      ast::expr_tup(ref elts) => {\n         let flds = unpack_expected(fcx, expected, |sty| {\n             match *sty { ty::ty_tup(ref flds) => Some(copy *flds), _ => None }\n         });\n@@ -2560,20 +2560,20 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         match tcx.def_map.find(&id) {\n             Some(ast::def_struct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n-                                         (/*bad*/copy *fields), base_expr);\n+                                         *fields, base_expr);\n             }\n             Some(ast::def_variant(enum_id, variant_id)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, (/*bad*/copy *fields));\n+                                          variant_id, *fields);\n             }\n             _ => {\n                 tcx.sess.span_bug(path.span, ~\"structure constructor does \\\n                                                not name a structure type\");\n             }\n         }\n       }\n-      ast::expr_field(base, field, tys) => {\n-        bot = check_field(fcx, expr, false, base, field, tys);\n+      ast::expr_field(base, field, ref tys) => {\n+        bot = check_field(fcx, expr, false, base, field, *tys);\n       }\n       ast::expr_index(base, idx) => {\n           bot |= check_expr(fcx, base);\n@@ -2678,8 +2678,8 @@ pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt) -> bool {\n     match stmt.node {\n       ast::stmt_decl(decl, id) => {\n         node_id = id;\n-        match /*bad*/copy decl.node {\n-          ast::decl_local(ls) => for ls.each |l| {\n+        match decl.node {\n+          ast::decl_local(ref ls) => for ls.each |l| {\n             bot |= check_decl_local(fcx, *l);\n           },\n           ast::decl_item(_) => {/* ignore for now */ }\n@@ -2803,11 +2803,11 @@ pub fn check_instantiable(tcx: ty::ctxt,\n \n pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                            sp: span,\n-                           +vs: ~[ast::variant],\n+                           vs: &[ast::variant],\n                            id: ast::node_id) {\n     fn do_check(ccx: @mut CrateCtxt,\n                 sp: span,\n-                vs: ~[ast::variant],\n+                vs: &[ast::variant],\n                 id: ast::node_id,\n                 disr_vals: &mut ~[int],\n                 disr_val: &mut int,\n@@ -2867,7 +2867,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                     arg_tys = None;\n                     do_check(ccx,\n                              sp,\n-                             /*bad*/copy vs,\n+                             vs,\n                              id,\n                              &mut *disr_vals,\n                              &mut *disr_val,"}, {"sha": "e0441d2e5447f5bcd2dc7b1ef288f3edc7c92627", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -192,7 +192,7 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n         }\n     }\n \n-    match /*bad*/copy expr.node {\n+    match expr.node {\n         ast::expr_path(*) => {\n             // Avoid checking the use of local variables, as we\n             // already check their definitions.  The def'n always\n@@ -207,7 +207,7 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n             }\n         }\n \n-        ast::expr_call(callee, args, _) => {\n+        ast::expr_call(callee, ref args, _) => {\n             // Check for a.b() where b is a method.  Ensure that\n             // any types in the callee are valid for the entire\n             // method call.\n@@ -236,7 +236,7 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n             }\n         }\n \n-        ast::expr_method_call(rcvr, _, _, args, _) => {\n+        ast::expr_method_call(rcvr, _, _, ref args, _) => {\n             // Check for a.b() where b is a method.  Ensure that\n             // any types in the callee are valid for the entire\n             // method call."}, {"sha": "620d64fd58e3d5e73fda754eb0ac020885f3954c", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -610,7 +610,7 @@ pub impl CoherenceChecker {\n     fn check_privileged_scopes(self, crate: @crate) {\n         visit_crate(*crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor| {\n-                match /*bad*/copy item.node {\n+                match item.node {\n                     item_mod(ref module_) => {\n                         // Then visit the module items.\n                         visit_mod(module_, item.span, item.id, (), visitor);\n@@ -738,8 +738,8 @@ pub impl CoherenceChecker {\n             }\n         }\n \n-        match /*bad*/copy item.node {\n-            item_impl(_, trait_refs, _, ast_methods) => {\n+        match item.node {\n+            item_impl(_, ref trait_refs, _, ref ast_methods) => {\n                 let mut methods = ~[];\n                 for ast_methods.each |ast_method| {\n                     methods.push(method_to_MethodInfo(*ast_method));"}, {"sha": "a8e91f0097a03098aefd8d696ffe013e0cec72b0", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -228,9 +228,9 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             trait_ty: ty::t) {\n     fn store_methods<T>(ccx: &CrateCtxt,\n                         id: ast::node_id,\n-                        stuff: ~[T],\n+                        stuff: &[T],\n                         f: &fn(v: &T) -> ty::method) {\n-        ty::store_trait_methods(ccx.tcx, id, @vec::map(stuff, f));\n+        ty::store_trait_methods(ccx.tcx, id, @stuff.map(f));\n     }\n \n     fn make_static_method_ty(ccx: &CrateCtxt,\n@@ -285,7 +285,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                 node: ast::item_trait(ref generics, _, ref ms),\n                 _\n             }, _) => {\n-        store_methods::<ast::trait_method>(ccx, id, (/*bad*/copy *ms), |m| {\n+        store_methods::<ast::trait_method>(ccx, id, *ms, |m| {\n             let def_id;\n             match *m {\n                 ast::required(ref ty_method) => {\n@@ -502,7 +502,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                                    rp: Option<ty::region_variance>,\n                                    selfty: ty::t,\n                                    a_trait_ty: @ast::trait_ref,\n-                                   impl_ms: ~[ConvertedMethod]) {\n+                                   impl_ms: &[ConvertedMethod]) {\n \n     let tcx = ccx.tcx;\n     let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp);\n@@ -643,8 +643,7 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n         // XXX: Bad copy of `ms` below.\n         let cms = convert_methods(ccx, *ms, rp, i_bounds);\n         for trait_ref.each |t| {\n-            check_methods_against_trait(ccx, generics, rp, selfty,\n-                                        *t, /*bad*/copy cms);\n+            check_methods_against_trait(ccx, generics, rp, selfty, *t, cms);\n         }\n       }\n       ast::item_trait(ref generics, ref supertraits, ref trait_methods) => {\n@@ -656,7 +655,7 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n         ensure_supertraits(ccx, it.id, it.span, rp, *supertraits);\n \n         let (_, provided_methods) =\n-            split_trait_methods(/*bad*/copy *trait_methods);\n+            split_trait_methods(*trait_methods);\n         let (bounds, _) = mk_substs(ccx, generics, rp);\n         let _ = convert_methods(ccx, provided_methods, rp, bounds);\n       }"}, {"sha": "8b128dbc5c5956d42b29f5ec2a7b480648bcd982", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -82,7 +82,7 @@ pub trait Combine {\n     fn lub(&self) -> Lub;\n     fn glb(&self) -> Glb;\n \n-    fn mts(&self, a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n+    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt>;\n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]>;\n@@ -305,7 +305,7 @@ pub fn super_flds<C:Combine>(\n     self: &C, a: ty::field, b: ty::field) -> cres<ty::field> {\n \n     if a.ident == b.ident {\n-        self.mts(a.mt, b.mt)\n+        self.mts(&a.mt, &b.mt)\n             .chain(|mt| Ok(ty::field {ident: a.ident, mt: mt}) )\n             .chain_err(|e| Err(ty::terr_in_field(@e, a.ident)) )\n     } else {\n@@ -419,8 +419,8 @@ pub fn super_fn_sigs<C:Combine>(\n     self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n {\n     fn argvecs<C:Combine>(self: &C,\n-                          +a_args: ~[ty::arg],\n-                          +b_args: ~[ty::arg]) -> cres<~[ty::arg]>\n+                          a_args: &[ty::arg],\n+                          b_args: &[ty::arg]) -> cres<~[ty::arg]>\n     {\n         if vec::same_length(a_args, b_args) {\n             map_vec2(a_args, b_args, |a, b| self.args(*a, *b))\n@@ -429,7 +429,7 @@ pub fn super_fn_sigs<C:Combine>(\n         }\n     }\n \n-    do argvecs(self, /*bad*/copy a_f.inputs, /*bad*/copy b_f.inputs)\n+    do argvecs(self, a_f.inputs, b_f.inputs)\n             .chain |inputs| {\n         do self.tys(a_f.output, b_f.output).chain |output| {\n             Ok(FnSig {inputs: /*bad*/copy inputs, output: output})\n@@ -509,7 +509,7 @@ pub fn super_tys<C:Combine>(\n         }\n       }\n \n-      (ty::ty_param(a_p), ty::ty_param(b_p)) if a_p.idx == b_p.idx => {\n+      (ty::ty_param(ref a_p), ty::ty_param(ref b_p)) if a_p.idx == b_p.idx => {\n         Ok(a)\n       }\n \n@@ -538,31 +538,31 @@ pub fn super_tys<C:Combine>(\n         }\n       }\n \n-      (ty::ty_box(a_mt), ty::ty_box(b_mt)) => {\n+      (ty::ty_box(ref a_mt), ty::ty_box(ref b_mt)) => {\n         do self.mts(a_mt, b_mt).chain |mt| {\n             Ok(ty::mk_box(tcx, mt))\n         }\n       }\n \n-      (ty::ty_uniq(a_mt), ty::ty_uniq(b_mt)) => {\n+      (ty::ty_uniq(ref a_mt), ty::ty_uniq(ref b_mt)) => {\n         do self.mts(a_mt, b_mt).chain |mt| {\n             Ok(ty::mk_uniq(tcx, mt))\n         }\n       }\n \n-      (ty::ty_ptr(a_mt), ty::ty_ptr(b_mt)) => {\n+      (ty::ty_ptr(ref a_mt), ty::ty_ptr(ref b_mt)) => {\n         do self.mts(a_mt, b_mt).chain |mt| {\n             Ok(ty::mk_ptr(tcx, mt))\n         }\n       }\n \n-      (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) => {\n+      (ty::ty_rptr(a_r, ref a_mt), ty::ty_rptr(b_r, ref b_mt)) => {\n           let r = if_ok!(self.contraregions(a_r, b_r));\n           let mt = if_ok!(self.mts(a_mt, b_mt));\n           Ok(ty::mk_rptr(tcx, r, mt))\n       }\n \n-      (ty::ty_evec(a_mt, vs_a), ty::ty_evec(b_mt, vs_b)) => {\n+      (ty::ty_evec(ref a_mt, vs_a), ty::ty_evec(ref b_mt, vs_b)) => {\n         do self.mts(a_mt, b_mt).chain |mt| {\n             do self.vstores(ty::terr_vec, vs_a, vs_b).chain |vs| {\n                 Ok(ty::mk_evec(tcx, mt, vs))\n@@ -576,9 +576,9 @@ pub fn super_tys<C:Combine>(\n         }\n       }\n \n-      (ty::ty_tup(as_), ty::ty_tup(bs)) => {\n-        if vec::same_length(as_, bs) {\n-            map_vec2(as_, bs, |a, b| self.tys(*a, *b) )\n+      (ty::ty_tup(ref as_), ty::ty_tup(ref bs)) => {\n+        if as_.len() == bs.len() {\n+            map_vec2(*as_, *bs, |a, b| self.tys(*a, *b) )\n                 .chain(|ts| Ok(ty::mk_tup(tcx, ts)) )\n         } else {\n             Err(ty::terr_tuple_size("}, {"sha": "55bfa9888c0dfdc149d45288f0f240635ef57376", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -41,7 +41,7 @@ impl Combine for Glb {\n     fn lub(&self) -> Lub { Lub(**self) }\n     fn glb(&self) -> Glb { Glb(**self) }\n \n-    fn mts(&self, a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n         debug!(\"%s.mts(%s, %s)\","}, {"sha": "59cc15dfc024d965f4e29be5cc81c0007197130c", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -47,7 +47,7 @@ impl Combine for Lub {\n     fn lub(&self) -> Lub { Lub(**self) }\n     fn glb(&self) -> Glb { Glb(**self) }\n \n-    fn mts(&self, a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n         debug!(\"%s.mts(%s, %s)\","}, {"sha": "1d9594d930c6d91ef2346248937a22735ec92093", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -150,7 +150,7 @@ pub impl ResolveState {\n             return typ;\n         }\n \n-        match /*bad*/ copy ty::get(typ).sty {\n+        match ty::get(typ).sty {\n             ty::ty_infer(TyVar(vid)) => {\n                 self.resolve_ty_var(vid)\n             }"}, {"sha": "561fabd9d702771e53645dfb3df4d1b70ef3f039", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -69,7 +69,7 @@ impl Combine for Sub {\n         }\n     }\n \n-    fn mts(&self, a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         debug!(\"mts(%s <: %s)\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         if a.mutbl != b.mutbl && b.mutbl != m_const {\n@@ -80,11 +80,11 @@ impl Combine for Sub {\n           m_mutbl => {\n             // If supertype is mut, subtype must match exactly\n             // (i.e., invariant if mut):\n-            eq_tys(self, a.ty, b.ty).then(|| Ok(a) )\n+            eq_tys(self, a.ty, b.ty).then(|| Ok(copy *a) )\n           }\n           m_imm | m_const => {\n             // Otherwise we can be covariant:\n-            self.tys(a.ty, b.ty).chain(|_t| Ok(a) )\n+            self.tys(a.ty, b.ty).chain(|_t| Ok(copy *a) )\n           }\n         }\n     }"}, {"sha": "7a28e7d1607c837c091c7aaf1b2ca3bb64119c96", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -43,7 +43,7 @@ impl InferStr for FnSig {\n \n impl InferStr for ty::mt {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n-        mt_to_str(cx.tcx, *self)\n+        mt_to_str(cx.tcx, self)\n     }\n }\n "}, {"sha": "d8636470555b3bc497f86e56b8a9ea6383165d94", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -218,7 +218,7 @@ pub fn region_to_str_space(cx: ctxt, prefix: &str, region: Region) -> ~str {\n     }\n }\n \n-pub fn mt_to_str(cx: ctxt, m: mt) -> ~str {\n+pub fn mt_to_str(cx: ctxt, m: &mt) -> ~str {\n     let mstr = match m.mutbl {\n       ast::m_mutbl => \"mut \",\n       ast::m_imm => \"\",\n@@ -391,7 +391,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                        &m.fty.sig) + ~\";\"\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n-        return *cx.sess.str_of(f.ident) + ~\": \" + mt_to_str(cx, f.mt);\n+        return *cx.sess.str_of(f.ident) + ~\": \" + mt_to_str(cx, &f.mt);\n     }\n \n     // if there is an id, print that instead of the structural type:\n@@ -402,7 +402,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }*/\n \n     // pretty print the structural type representation:\n-    return match /*bad*/copy ty::get(typ).sty {\n+    return match ty::get(typ).sty {\n       ty_nil => ~\"()\",\n       ty_bot => ~\"!\",\n       ty_bool => ~\"bool\",\n@@ -413,15 +413,15 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_uint(t) => ast_util::uint_ty_to_str(t),\n       ty_float(ast::ty_f) => ~\"float\",\n       ty_float(t) => ast_util::float_ty_to_str(t),\n-      ty_box(tm) => ~\"@\" + mt_to_str(cx, tm),\n-      ty_uniq(tm) => ~\"~\" + mt_to_str(cx, tm),\n-      ty_ptr(tm) => ~\"*\" + mt_to_str(cx, tm),\n-      ty_rptr(r, tm) => {\n+      ty_box(ref tm) => ~\"@\" + mt_to_str(cx, tm),\n+      ty_uniq(ref tm) => ~\"~\" + mt_to_str(cx, tm),\n+      ty_ptr(ref tm) => ~\"*\" + mt_to_str(cx, tm),\n+      ty_rptr(r, ref tm) => {\n         region_to_str_space(cx, ~\"&\", r) + mt_to_str(cx, tm)\n       }\n-      ty_unboxed_vec(tm) => { ~\"unboxed_vec<\" + mt_to_str(cx, tm) + ~\">\" }\n+      ty_unboxed_vec(ref tm) => { ~\"unboxed_vec<\" + mt_to_str(cx, tm) + ~\">\" }\n       ty_type => ~\"type\",\n-      ty_tup(elems) => {\n+      ty_tup(ref elems) => {\n         let strs = elems.map(|elem| ty_to_str(cx, *elem));\n         ~\"(\" + str::connect(strs, ~\",\") + ~\")\"\n       }\n@@ -455,7 +455,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         let ty = parameterized(cx, base, substs.self_r, substs.tps);\n         fmt!(\"%s%s\", trait_store_to_str(cx, s), ty)\n       }\n-      ty_evec(mt, vs) => {\n+      ty_evec(ref mt, vs) => {\n         vstore_ty_to_str(cx, fmt!(\"%s\", mt_to_str(cx, mt)), vs)\n       }\n       ty_estr(vs) => fmt!(\"%s%s\", vstore_to_str(cx, vs), ~\"str\"),"}, {"sha": "9973c9558c9683d2e71fa09bf6f329c6f2fc5c45", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -65,7 +65,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n \n-    fn make_rt_conv_expr(cx: @ext_ctxt, sp: span, cnv: Conv) -> @ast::expr {\n+    fn make_rt_conv_expr(cx: @ext_ctxt, sp: span, cnv: &Conv) -> @ast::expr {\n         fn make_flags(cx: @ext_ctxt, sp: span, flags: ~[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, @~\"flag_none\");\n             for flags.each |f| {\n@@ -139,7 +139,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         make_conv_struct(cx, sp, rt_conv_flags, rt_conv_width,\n                          rt_conv_precision, rt_conv_ty)\n     }\n-    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: ~str, cnv: Conv,\n+    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: ~str, cnv: &Conv,\n                       arg: @ast::expr) -> @ast::expr {\n         let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(cx, @fname);\n@@ -148,11 +148,11 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         return mk_call_global(cx, arg.span, path, args);\n     }\n \n-    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: Conv, arg: @ast::expr) ->\n+    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: &Conv, arg: @ast::expr) ->\n        @ast::expr {\n         // FIXME: Move validation code into core::extfmt (Issue #2249)\n \n-        fn is_signed_type(cnv: Conv) -> bool {\n+        fn is_signed_type(cnv: &Conv) -> bool {\n             match cnv.ty {\n               TyInt(s) => match s {\n                 Signed => return true,\n@@ -220,7 +220,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                        mk_addr_of(cx, sp, arg))\n         }\n     }\n-    fn log_conv(c: Conv) {\n+    fn log_conv(c: &Conv) {\n         match c.param {\n           Some(p) => { debug!(\"param: %s\", p.to_str()); }\n           _ => debug!(\"param: none\")\n@@ -285,12 +285,12 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                                   ~\"for the given format string\");\n             }\n             debug!(\"Building conversion:\");\n-            log_conv(/*bad*/ copy *conv);\n+            log_conv(conv);\n             let arg_expr = args[n];\n             let c_expr = make_new_conv(\n                 cx,\n                 fmt_sp,\n-                /*bad*/ copy *conv,\n+                conv,\n                 arg_expr\n             );\n             piece_exprs.push(c_expr);"}, {"sha": "98208bf9f7668ecaa41fcc279da55b60c918a3d1", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -220,7 +220,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n         if col < len {\n             s1 = str::slice(s, col, len);\n         } else { s1 = ~\"\"; }\n-    } else { s1 = /*bad*/ copy s; }\n+    } else { s1 = s; }\n     debug!(\"pushing line: %s\", s1);\n     lines.push(s1);\n }\n@@ -357,8 +357,8 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(&tok) {\n             let s = get_str_from(rdr, bstart);\n-            literals.push(lit {lit: /*bad*/ copy s, pos: sp.lo});\n             debug!(\"tok lit: %s\", s);\n+            literals.push(lit {lit: s, pos: sp.lo});\n         } else {\n             debug!(\"tok: %s\", token::to_str(rdr.interner, &tok));\n         }"}, {"sha": "086bf86b4b2680d8e1b14f5a817f0d6f87405069", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -1444,7 +1444,7 @@ pub impl Parser {\n                     let (s, z) = p.parse_sep_and_zerok();\n                     tt_seq(\n                         mk_sp(sp.lo ,p.span.hi),\n-                        /*bad*/ copy seq.node,\n+                        seq.node,\n                         s,\n                         z\n                     )\n@@ -1861,7 +1861,7 @@ pub impl Parser {\n         // Turn on the restriction to stop at | or || so we can parse\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n-        match /*bad*/ copy e.node {\n+        match e.node {\n             expr_call(f, args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n@@ -2135,7 +2135,7 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         let mut pat;\n-        match copy *self.token {\n+        match *self.token {\n           token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n           token::AT => {\n             self.bump();\n@@ -2243,7 +2243,7 @@ pub impl Parser {\n             self.expect(&token::RBRACKET);\n             pat = ast::pat_vec(before, slice, after);\n           }\n-          copy tok => {\n+          tok => {\n             if !is_ident_or_path(&tok)\n                 || self.is_keyword(&~\"true\")\n                 || self.is_keyword(&~\"false\")\n@@ -3347,6 +3347,7 @@ pub impl Parser {\n                                             VIEW_ITEMS_AND_ITEMS_ALLOWED,\n                                             true);\n         let mut items: ~[@item] = starting_items;\n+        let attrs_remaining_len = attrs_remaining.len();\n \n         // looks like this code depends on the invariant that\n         // outer attributes can't occur on view items (or macros\n@@ -3355,7 +3356,7 @@ pub impl Parser {\n         while *self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n             if first {\n-                attrs = vec::append(/*bad*/ copy attrs_remaining, attrs);\n+                attrs = attrs_remaining + attrs;\n                 first = false;\n             }\n             debug!(\"parse_mod_items: parse_item_or_view_item(attrs=%?)\",\n@@ -3384,7 +3385,7 @@ pub impl Parser {\n             debug!(\"parse_mod_items: attrs=%?\", attrs);\n         }\n \n-        if first && attrs_remaining.len() > 0u {\n+        if first && attrs_remaining_len > 0u {\n             // We parsed attributes for the first item but didn't find it\n             self.fatal(~\"expected item\");\n         }"}, {"sha": "ba9a5082132e7232fb5e00c85d802280bd919e4e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4dc1ffe29045361c34abab8d810d2c717b82e0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=db4dc1ffe29045361c34abab8d810d2c717b82e0", "patch": "@@ -134,7 +134,7 @@ pub fn print_crate(cm: @CodeMap,\n }\n \n pub fn print_crate_(s: @ps, &&crate: @ast::crate) {\n-    print_mod(s, crate.node.module, crate.node.attrs);\n+    print_mod(s, &crate.node.module, crate.node.attrs);\n     print_remaining_comments(s);\n     eof(s.s);\n }\n@@ -310,7 +310,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, ~\"*/\");\n }\n \n-pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN)) {\n+pub fn commasep<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.each |elt| {\n@@ -321,7 +321,7 @@ pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN)) {\n }\n \n \n-pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN),\n+pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n                          get_span: &fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n@@ -340,20 +340,20 @@ pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN),\n     end(s);\n }\n \n-pub fn commasep_exprs(s: @ps, b: breaks, exprs: ~[@ast::expr]) {\n+pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n     fn expr_span(&&expr: @ast::expr) -> codemap::span { return expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-pub fn print_mod(s: @ps, _mod: ast::_mod, attrs: ~[ast::attribute]) {\n+pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.each |vitem| {\n         print_view_item(s, *vitem);\n     }\n     for _mod.items.each |item| { print_item(s, *item); }\n }\n \n-pub fn print_foreign_mod(s: @ps, nmod: ast::foreign_mod,\n+pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n                          attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.each |vitem| {\n@@ -376,12 +376,12 @@ pub fn print_type(s: @ps, &&ty: @ast::Ty) {\n pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n-    match /*bad*/ copy ty.node {\n+    match ty.node {\n       ast::ty_nil => word(s.s, ~\"()\"),\n       ast::ty_bot => word(s.s, ~\"!\"),\n-      ast::ty_box(mt) => { word(s.s, ~\"@\"); print_mt(s, mt); }\n-      ast::ty_uniq(mt) => { word(s.s, ~\"~\"); print_mt(s, mt); }\n-      ast::ty_vec(mt) => {\n+      ast::ty_box(ref mt) => { word(s.s, ~\"@\"); print_mt(s, mt); }\n+      ast::ty_uniq(ref mt) => { word(s.s, ~\"~\"); print_mt(s, mt); }\n+      ast::ty_vec(ref mt) => {\n         word(s.s, ~\"[\");\n         match mt.mutbl {\n           ast::m_mutbl => word_space(s, ~\"mut\"),\n@@ -391,15 +391,15 @@ pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n         print_type(s, mt.ty);\n         word(s.s, ~\"]\");\n       }\n-      ast::ty_ptr(mt) => { word(s.s, ~\"*\"); print_mt(s, mt); }\n-      ast::ty_rptr(lifetime, mt) => {\n+      ast::ty_ptr(ref mt) => { word(s.s, ~\"*\"); print_mt(s, mt); }\n+      ast::ty_rptr(lifetime, ref mt) => {\n           word(s.s, ~\"&\");\n           print_opt_lifetime(s, lifetime);\n           print_mt(s, mt);\n       }\n-      ast::ty_tup(elts) => {\n+      ast::ty_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, elts, print_type);\n+        commasep(s, inconsistent, *elts, print_type);\n         if elts.len() == 1 {\n             word(s.s, ~\",\");\n         }\n@@ -416,7 +416,7 @@ pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n                       None, None);\n       }\n       ast::ty_path(path, _) => print_path(s, path, print_colons),\n-      ast::ty_fixed_length_vec(mt, v) => {\n+      ast::ty_fixed_length_vec(ref mt, v) => {\n         word(s.s, ~\"[\");\n         match mt.mutbl {\n             ast::m_mutbl => word_space(s, ~\"mut\"),\n@@ -443,7 +443,7 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n-    match /*bad*/ copy item.node {\n+    match item.node {\n       ast::foreign_item_fn(ref decl, purity, ref generics) => {\n         print_fn(s, decl, Some(purity), item.ident, generics, None,\n                  ast::inherited);\n@@ -469,7 +469,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n     print_outer_attributes(s, item.attrs);\n     let ann_node = node_item(s, item);\n     (s.ann.pre)(ann_node);\n-    match /*bad*/ copy item.node {\n+    match item.node {\n       ast::item_const(ty, expr) => {\n         head(s, visibility_qualified(item.vis, ~\"static\"));\n         print_ident(s, item.ident);\n@@ -497,15 +497,15 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         word(s.s, ~\" \");\n         print_block_with_attrs(s, body, item.attrs);\n       }\n-      ast::item_mod(_mod) => {\n+      ast::item_mod(ref _mod) => {\n         head(s, visibility_qualified(item.vis, ~\"mod\"));\n         print_ident(s, item.ident);\n         nbsp(s);\n         bopen(s);\n         print_mod(s, _mod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_foreign_mod(nmod) => {\n+      ast::item_foreign_mod(ref nmod) => {\n         head(s, visibility_qualified(item.vis, ~\"extern\"));\n         print_string(s, *s.intr.get(nmod.abi));\n         nbsp(s);\n@@ -767,15 +767,15 @@ pub fn print_tts(s: @ps, &&tts: &[ast::token_tree]) {\n \n pub fn print_variant(s: @ps, v: ast::variant) {\n     print_visibility(s, v.node.vis);\n-    match /*bad*/ copy v.node.kind {\n-        ast::tuple_variant_kind(args) => {\n+    match v.node.kind {\n+        ast::tuple_variant_kind(ref args) => {\n             print_ident(s, v.node.name);\n             if !args.is_empty() {\n                 popen(s);\n                 fn print_variant_arg(s: @ps, arg: ast::variant_arg) {\n                     print_type(s, arg.ty);\n                 }\n-                commasep(s, consistent, args, print_variant_arg);\n+                commasep(s, consistent, *args, print_variant_arg);\n                 pclose(s);\n             }\n         }\n@@ -1103,7 +1103,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n     (s.ann.pre)(ann_node);\n-    match /*bad*/ copy expr.node {\n+    match expr.node {\n         ast::expr_vstore(e, v) => match v {\n             ast::expr_vstore_fixed(_) => {\n                 print_expr(s, e);\n@@ -1115,14 +1115,14 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n                 print_expr(s, e);\n             }\n         },\n-      ast::expr_vec(exprs, mutbl) => {\n+      ast::expr_vec(ref exprs, mutbl) => {\n         ibox(s, indent_unit);\n         word(s.s, ~\"[\");\n         if mutbl == ast::m_mutbl {\n             word(s.s, ~\"mut\");\n-            if vec::len(exprs) > 0u { nbsp(s); }\n+            if exprs.len() > 0u { nbsp(s); }\n         }\n-        commasep_exprs(s, inconsistent, exprs);\n+        commasep_exprs(s, inconsistent, *exprs);\n         word(s.s, ~\"]\");\n         end(s);\n       }\n@@ -1159,29 +1159,29 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         }\n         word(s.s, ~\"}\");\n       }\n-      ast::expr_tup(exprs) => {\n+      ast::expr_tup(ref exprs) => {\n         popen(s);\n-        commasep_exprs(s, inconsistent, exprs);\n+        commasep_exprs(s, inconsistent, *exprs);\n         if exprs.len() == 1 {\n             word(s.s, ~\",\");\n         }\n         pclose(s);\n       }\n-      ast::expr_call(func, args, sugar) => {\n-        let mut base_args = copy args;\n+      ast::expr_call(func, ref args, sugar) => {\n+        let mut base_args = copy *args;\n         let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n         print_call_post(s, sugar, &blk, &mut base_args);\n       }\n-      ast::expr_method_call(func, ident, tys, args, sugar) => {\n-        let mut base_args = copy args;\n+      ast::expr_method_call(func, ident, ref tys, ref args, sugar) => {\n+        let mut base_args = copy *args;\n         let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n         word(s.s, ~\".\");\n         print_ident(s, ident);\n-        if vec::len(tys) > 0u {\n+        if tys.len() > 0u {\n             word(s.s, ~\"::<\");\n-            commasep(s, inconsistent, tys, print_type);\n+            commasep(s, inconsistent, *tys, print_type);\n             word(s.s, ~\">\");\n         }\n         print_call_post(s, sugar, &blk, &mut base_args);\n@@ -1356,13 +1356,13 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         word_space(s, ~\"=\");\n         print_expr(s, rhs);\n       }\n-      ast::expr_field(expr, id, tys) => {\n+      ast::expr_field(expr, id, ref tys) => {\n         print_expr(s, expr);\n         word(s.s, ~\".\");\n         print_ident(s, id);\n-        if vec::len(tys) > 0u {\n+        if tys.len() > 0u {\n             word(s.s, ~\"::<\");\n-            commasep(s, inconsistent, tys, print_type);\n+            commasep(s, inconsistent, *tys, print_type);\n             word(s.s, ~\">\");\n         }\n       }\n@@ -1454,15 +1454,15 @@ pub fn print_local_decl(s: @ps, loc: @ast::local) {\n \n pub fn print_decl(s: @ps, decl: @ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n-    match /*bad*/ copy decl.node {\n-      ast::decl_local(locs) => {\n+    match decl.node {\n+      ast::decl_local(ref locs) => {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n         word_nbsp(s, ~\"let\");\n \n         // if any are mut, all are mut\n-        if vec::any(locs, |l| l.node.is_mutbl) {\n-            fail_unless!(vec::all(locs, |l| l.node.is_mutbl));\n+        if locs.any(|l| l.node.is_mutbl) {\n+            fail_unless!(locs.all(|l| l.node.is_mutbl));\n             word_nbsp(s, ~\"mut\");\n         }\n \n@@ -1479,7 +1479,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n               _ => ()\n             }\n         }\n-        commasep(s, consistent, locs, print_local);\n+        commasep(s, consistent, *locs, print_local);\n         end(s);\n       }\n       ast::decl_item(item) => print_item(s, item)\n@@ -1539,7 +1539,7 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n     (s.ann.pre)(ann_node);\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n-    match /*bad*/ copy pat.node {\n+    match pat.node {\n       ast::pat_wild => word(s.s, ~\"_\"),\n       ast::pat_ident(binding_mode, path, sub) => {\n           if refutable {\n@@ -1563,14 +1563,14 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n               None => ()\n           }\n       }\n-      ast::pat_enum(path, args_) => {\n+      ast::pat_enum(path, ref args_) => {\n         print_path(s, path, true);\n-        match args_ {\n+        match *args_ {\n           None => word(s.s, ~\"(*)\"),\n-          Some(args) => {\n+          Some(ref args) => {\n             if !args.is_empty() {\n               popen(s);\n-              commasep(s, inconsistent, args,\n+              commasep(s, inconsistent, *args,\n                        |s, p| print_pat(s, p, refutable));\n               pclose(s);\n             } else { }\n@@ -1851,7 +1851,7 @@ pub fn print_view_path(s: @ps, &&vp: @ast::view_path) {\n     }\n }\n \n-pub fn print_view_paths(s: @ps, vps: ~[@ast::view_path]) {\n+pub fn print_view_paths(s: @ps, vps: &[@ast::view_path]) {\n     commasep(s, inconsistent, vps, print_view_path);\n }\n \n@@ -1860,7 +1860,7 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     print_visibility(s, item.vis);\n-    match /*bad*/ copy item.node {\n+    match item.node {\n         ast::view_item_extern_mod(id, mta, _) => {\n             head(s, ~\"extern mod\");\n             print_ident(s, id);\n@@ -1871,9 +1871,9 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n             }\n         }\n \n-        ast::view_item_use(vps) => {\n+        ast::view_item_use(ref vps) => {\n             head(s, ~\"use\");\n-            print_view_paths(s, vps);\n+            print_view_paths(s, *vps);\n         }\n     }\n     word(s.s, ~\";\");\n@@ -1889,7 +1889,7 @@ pub fn print_mutability(s: @ps, mutbl: ast::mutability) {\n     }\n }\n \n-pub fn print_mt(s: @ps, mt: ast::mt) {\n+pub fn print_mt(s: @ps, mt: &ast::mt) {\n     print_mutability(s, mt.mutbl);\n     print_type(s, mt.ty);\n }\n@@ -1942,7 +1942,7 @@ pub fn print_ty_fn(s: @ps,\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n     match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n-    match /*bad*/ copy generics { Some(g) => print_generics(s, g), _ => () }\n+    match generics { Some(g) => print_generics(s, g), _ => () }\n     zerobreak(s.s);\n \n     popen(s);"}]}