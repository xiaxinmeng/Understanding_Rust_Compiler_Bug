{"sha": "d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxNzliYTNiOGViNjVjOTUxYjY4ZjZjNTJkYTNhYmE4MjgwNmEzYTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-26T03:03:10Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-26T06:14:06Z"}, "message": "Merge remote-tracking branch 'rust-lang/master'\n\nConflicts:\n\tsrc/libcore/cmp.rs\n\tsrc/libcore/fmt/mod.rs\n\tsrc/libcore/iter.rs\n\tsrc/libcore/marker.rs\n\tsrc/libcore/num/f32.rs\n\tsrc/libcore/num/f64.rs\n\tsrc/libcore/result.rs\n\tsrc/libcore/str/mod.rs\n\tsrc/librustc/lint/builtin.rs\n\tsrc/librustc/lint/context.rs\n\tsrc/libstd/sync/mpsc/mod.rs\n\tsrc/libstd/sync/poison.rs", "tree": {"sha": "fa8b3475117a5d145a48f200b44f75eebf9f1b9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa8b3475117a5d145a48f200b44f75eebf9f1b9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "html_url": "https://github.com/rust-lang/rust/commit/d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de5498650a4702a9552951d28f344229f37e7ae3", "url": "https://api.github.com/repos/rust-lang/rust/commits/de5498650a4702a9552951d28f344229f37e7ae3", "html_url": "https://github.com/rust-lang/rust/commit/de5498650a4702a9552951d28f344229f37e7ae3"}, {"sha": "c80e556e159af38f86eea5ee2ba796d7c724c92b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c80e556e159af38f86eea5ee2ba796d7c724c92b", "html_url": "https://github.com/rust-lang/rust/commit/c80e556e159af38f86eea5ee2ba796d7c724c92b"}], "stats": {"total": 6040, "additions": 5483, "deletions": 557}, "files": [{"sha": "7b7eac8e73527e3c2127b356305c0975f7ce2e2b", "filename": "configure", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/configure", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -28,8 +28,8 @@ need_ok() {\n \n need_cmd() {\n     if command -v $1 >/dev/null 2>&1\n-    then msg \"found $1\"\n-    else err \"need $1\"\n+    then msg \"found program $1\"\n+    else err \"need program $1\"\n     fi\n }\n \n@@ -340,6 +340,7 @@ need_cmd date\n need_cmd tr\n need_cmd sed\n need_cmd file\n+need_cmd make\n \n msg \"inspecting environment\"\n \n@@ -645,6 +646,8 @@ probe CFG_ISCC             iscc\n probe CFG_JAVAC            javac\n probe CFG_ANTLR4           antlr4\n probe CFG_GRUN             grun\n+probe CFG_FLEX             flex\n+probe CFG_BISON            bison\n probe CFG_PANDOC           pandoc\n probe CFG_PDFLATEX         pdflatex\n probe CFG_XELATEX          xelatex"}, {"sha": "d9c66e282bc4e22cfbeefae78bc2c267a5479bcc", "filename": "mk/grammar.mk", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/mk%2Fgrammar.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/mk%2Fgrammar.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fgrammar.mk?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -14,6 +14,11 @@ B = $(CFG_BUILD_DIR)/$(CFG_BUILD)/stage2/\n L = $(B)lib/rustlib/$(CFG_BUILD)/lib\n LD = $(CFG_BUILD)/stage2/lib/rustlib/$(CFG_BUILD)/lib/\n RUSTC = $(STAGE2_T_$(CFG_BUILD)_H_$(CFG_BUILD))\n+ifeq ($(CFG_OSTYPE),apple-darwin)\n+\tFLEX_LDFLAGS=-ll\n+else\n+\tFLEX_LDFLAGS=-lfl\n+endif\n \n # Run the reference lexer against libsyntax and compare the tokens and spans.\n # If \"// ignore-lexer-test\" is present in the file, it will be ignored.\n@@ -67,3 +72,46 @@ $(info cfg: javac not available, skipping lexer test...)\n check-lexer:\n \n endif\n+\n+$(BG)lex.yy.c: $(SG)lexer.l $(BG)\n+\t@$(call E, flex: $@)\n+\t$(Q)$(CFG_FLEX) -o $@ $<\n+\n+$(BG)lexer-lalr.o: $(BG)lex.yy.c $(BG)parser-lalr.tab.h\n+\t@$(call E, cc: $@)\n+\t$(Q)$(CFG_CC) -include $(BG)parser-lalr.tab.h -c -o $@ $<\n+\n+$(BG)parser-lalr.tab.c $(BG)parser-lalr.tab.h: $(SG)parser-lalr.y\n+\t@$(call E, bison: $@)\n+\t$(Q)$(CFG_BISON) $< --output=$(BG)parser-lalr.tab.c --defines=$(BG)parser-lalr.tab.h \\\n+\t\t--name-prefix=rs --warnings=error=all\n+\n+$(BG)parser-lalr.o: $(BG)parser-lalr.tab.c\n+\t@$(call E, cc: $@)\n+\t$(Q)$(CFG_CC) -c -o $@ $<\n+\n+$(BG)parser-lalr-main.o: $(SG)parser-lalr-main.c\n+\t@$(call E, cc: $@)\n+\t$(Q)$(CFG_CC) -std=c99 -c -o $@ $<\n+\n+$(BG)parser-lalr: $(BG)parser-lalr.o $(BG)parser-lalr-main.o $(BG)lexer-lalr.o\n+\t@$(call E, cc: $@)\n+\t$(Q)$(CFG_CC) -o $@ $^ $(FLEX_LDFLAGS)\n+\n+\n+ifdef CFG_FLEX\n+ifdef CFG_BISON\n+check-grammar: $(BG) $(BG)parser-lalr\n+\t$(info Verifying grammar ...)\n+\t$(SG)testparser.py -p $(BG)parser-lalr -s $(S)src\n+\n+else\n+$(info cfg: bison not available, skipping parser test...)\n+check-grammar:\n+\n+endif\n+else\n+$(info cfg: flex not available, skipping parser test...)\n+check-grammar:\n+\n+endif"}, {"sha": "0e52f168f59ed2072cb87c2eddfee295cb821685", "filename": "mk/main.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -30,8 +30,8 @@ CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)\n CFG_DISABLE_UNSTABLE_FEATURES=1\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),beta)\n-CFG_RELEASE=$(CFG_RELEASE_NUM)-beta(CFG_PRERELEASE_VERSION)\n-CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)-beta(CFG_PRERELEASE_VERSION)\n+CFG_RELEASE=$(CFG_RELEASE_NUM)-beta$(CFG_PRERELEASE_VERSION)\n+CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)-beta$(CFG_PRERELEASE_VERSION)\n CFG_DISABLE_UNSTABLE_FEATURES=1\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),nightly)"}, {"sha": "b2e852a36f7c36485c7d7ed9fa5469369f684c0b", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -12,6 +12,20 @@ pub use self::Mode::*;\n use std::fmt;\n use std::str::FromStr;\n \n+#[cfg(stage0)] // NOTE: remove impl after snapshot\n+#[derive(Clone, PartialEq, Show)]\n+pub enum Mode {\n+    CompileFail,\n+    RunFail,\n+    RunPass,\n+    RunPassValgrind,\n+    Pretty,\n+    DebugInfoGdb,\n+    DebugInfoLldb,\n+    Codegen\n+}\n+\n+#[cfg(not(stage0))] // NOTE: remove cfg after snapshot\n #[derive(Clone, PartialEq, Debug)]\n pub enum Mode {\n     CompileFail,\n@@ -24,6 +38,7 @@ pub enum Mode {\n     Codegen\n }\n \n+\n impl Copy for Mode {}\n \n impl FromStr for Mode {"}, {"sha": "db025ddcc5d3ae0e33007a2062736e2ddc3b9c2f", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 133, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -2291,136 +2291,7 @@ The name `str_eq` has a special meaning to the Rust compiler, and the presence\n of this definition means that it will use this definition when generating calls\n to the string equality function.\n \n-A complete list of the built-in language items follows:\n-\n-#### Built-in Traits\n-\n-* `copy`\n-  : Types that do not move ownership when used by-value.\n-* `drop`\n-  : Have destructors.\n-* `send`\n-  : Able to be sent across thread boundaries.\n-* `sized`\n-  : Has a size known at compile time.\n-* `sync`\n-  : Able to be safely shared between threads when aliased.\n-\n-#### Operators\n-\n-These language items are traits:\n-\n-* `add`\n-  : Elements can be added (for example, integers and floats).\n-* `sub`\n-  : Elements can be subtracted.\n-* `mul`\n-  : Elements can be multiplied.\n-* `div`\n-  : Elements have a division operation.\n-* `rem`\n-  : Elements have a remainder operation.\n-* `neg`\n-  : Elements can be negated arithmetically.\n-* `not`\n-  : Elements can be negated logically.\n-* `bitxor`\n-  : Elements have an exclusive-or operation.\n-* `bitand`\n-  : Elements have a bitwise `and` operation.\n-* `bitor`\n-  : Elements have a bitwise `or` operation.\n-* `shl`\n-  : Elements have a left shift operation.\n-* `shr`\n-  : Elements have a right shift operation.\n-* `index`\n-  : Elements can be indexed.\n-* `index_mut`\n-  : ___Needs filling in___\n-* `eq`\n-  : Elements can be compared for equality.\n-* `ord`\n-  : Elements have a partial ordering.\n-* `deref`\n-  : `*` can be applied, yielding a reference to another type.\n-* `deref_mut`\n-  : `*` can be applied, yielding a mutable reference to another type.\n-\n-These are functions:\n-\n-* `fn`\n-  : ___Needs filling in___\n-* `fn_mut`\n-  : ___Needs filling in___\n-* `fn_once`\n-  : ___Needs filling in___\n-* `str_eq`\n-  : Compare two strings (`&str`) for equality.\n-* `strdup_uniq`\n-  : Return a new unique string\n-    containing a copy of the contents of a unique string.\n-\n-#### Types\n-\n-* `type_id`\n-  : The type returned by the `type_id` intrinsic.\n-* `unsafe`\n-  : A type whose contents can be mutated through an immutable reference.\n-\n-#### Marker types\n-\n-These types help drive the compiler's analysis\n-\n-* `begin_unwind`\n-  : ___Needs filling in___\n-* `no_copy_bound`\n-  : This type does not implement \"copy\", even if eligible.\n-* `eh_personality`\n-  : ___Needs filling in___\n-* `exchange_free`\n-  : Free memory that was allocated on the exchange heap.\n-* `exchange_malloc`\n-  : Allocate memory on the exchange heap.\n-* `closure_exchange_malloc`\n-  : ___Needs filling in___\n-* `panic`\n-  : Abort the program with an error.\n-* `fail_bounds_check`\n-  : Abort the program with a bounds check error.\n-* `free`\n-  : Free memory that was allocated on the managed heap.\n-* `gc`\n-  : ___Needs filling in___\n-* `exchange_heap`\n-  : ___Needs filling in___\n-* `iterator`\n-  : ___Needs filling in___\n-* `contravariant_lifetime`\n-  : The lifetime parameter should be considered contravariant.\n-* `covariant_lifetime`\n-  : The lifetime parameter should be considered covariant.\n-* `invariant_lifetime`\n-  : The lifetime parameter should be considered invariant.\n-* `malloc`\n-  : Allocate memory on the managed heap.\n-* `owned_box`\n-  : ___Needs filling in___\n-* `stack_exhausted`\n-  : ___Needs filling in___\n-* `start`\n-  : ___Needs filling in___\n-* `contravariant_type`\n-  : The type parameter should be considered contravariant.\n-* `covariant_type`\n-  : The type parameter should be considered covariant.\n-* `invariant_type`\n-  : The type parameter should be considered invariant.\n-* `ty_desc`\n-  : ___Needs filling in___\n-\n-> **Note:** This list is likely to become out of date. We should auto-generate\n-> it from `librustc/middle/lang_items.rs`.\n+A complete list of the built-in language items will be added in the future.\n \n ### Inline attributes\n \n@@ -2581,9 +2452,7 @@ The currently implemented features of the reference compiler are:\n                    declare a `static` as being unique per-thread leveraging\n                    LLVM's implementation which works in concert with the kernel\n                    loader and dynamic linker. This is not necessarily available\n-                   on all platforms, and usage of it is discouraged (rust\n-                   focuses more on thread-local data instead of thread-local\n-                   data).\n+                   on all platforms, and usage of it is discouraged.\n \n * `trace_macros` - Allows use of the `trace_macros` macro, which is a nasty\n                    hack that will certainly be removed."}, {"sha": "80288c4c3d9ca9604373e67f74b0c43eb51ec3c8", "filename": "src/doc/trpl/installing-rust.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -83,7 +83,6 @@ If not, there are a number of places where you can get help. The easiest is\n you can access through\n [Mibbit](http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust). Click\n that link, and you'll be chatting with other Rustaceans (a silly nickname we\n-call ourselves), and we can help you out. Other great resources include [our\n-forum](http://discuss.rust-lang.org/), [the /r/rust\n-subreddit](http://www.reddit.com/r/rust), and [Stack\n+call ourselves), and we can help you out. Other great resources include [the\n+/r/rust subreddit](http://www.reddit.com/r/rust), and [Stack\n Overflow](http://stackoverflow.com/questions/tagged/rust)."}, {"sha": "e6570c2ee74c8d649faaf8afec41cf76358d30ba", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 112, "deletions": 2, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -18,6 +18,8 @@ x.foo().bar().baz();\n Luckily, as you may have guessed with the leading question, you can! Rust provides\n the ability to use this *method call syntax* via the `impl` keyword.\n \n+## Method calls\n+\n Here's how it works:\n \n ```{rust}\n@@ -56,11 +58,56 @@ other parameter. Because we know it's a `Circle`, we can access the `radius`\n just like we would with any other struct. An import of \u03c0 and some\n multiplications later, and we have our area.\n \n+## Chaining method calls\n+\n+So, now we know how to call a method, such as `foo.bar()`. But what about our\n+original example, `foo.bar().baz()`? This is called 'method chaining', and we\n+can do it by returning `self`.\n+\n+```\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+impl Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+\n+    fn grow(&self) -> Circle {\n+        Circle { x: self.x, y: self.y, radius: (self.radius * 10.0) }\n+    }\n+}\n+\n+fn main() {\n+    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };\n+    println!(\"{}\", c.area());\n+\n+    let d = c.grow().area();\n+    println!(\"{}\", d);\n+}\n+```\n+\n+Check the return type:\n+\n+```\n+# struct Circle;\n+# impl Circle {\n+fn grow(&self) -> Circle {\n+# Circle } }\n+```\n+\n+We just say we're returning a `Circle`. With this, we can grow a new circle\n+that's twice as big as the old one.\n+\n+## Static methods\n+\n You can also define methods that do not take a `self` parameter. Here's a\n pattern that's very common in Rust code:\n \n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n+```\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -86,3 +133,66 @@ This *static method* builds a new `Circle` for us. Note that static methods\n are called with the `Struct::method()` syntax, rather than the `ref.method()`\n syntax.\n \n+## Builder Pattern\n+\n+Let's say that we want our users to be able to create Circles, but we will\n+allow them to only set the properties they care about. Otherwise, the `x`\n+and `y` attributes will be `0.0`, and the `radius` will be `1.0`. Rust doesn't\n+have method overloading, named arguments, or variable arguments. We employ\n+the builder pattern instead. It looks like this:\n+\n+```\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+impl Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+\n+struct CircleBuilder {\n+    coordinate: f64,\n+    radius: f64,\n+}\n+\n+impl CircleBuilder {\n+    fn new() -> CircleBuilder {\n+        CircleBuilder { coordinate: 0.0, radius: 0.0, }\n+    }\n+\n+    fn coordinate(&mut self, coordinate: f64) -> &mut CircleBuilder {\n+\tself.coordinate = coordinate;\n+\tself\n+    }\n+\n+    fn radius(&mut self, radius: f64) -> &mut CircleBuilder {\n+\tself.radius = radius;\n+\tself\n+    }\n+\n+    fn finalize(&self) -> Circle {\n+        Circle { x: self.coordinate, y: self.coordinate, radius: self.radius }\n+    }\n+}\n+\n+fn main() {\n+    let c = CircleBuilder::new()\n+                .coordinate(10.0)\n+                .radius(5.0)\n+                .finalize();\n+\n+\n+    println!(\"area: {}\", c.area());\n+}\n+```\n+\n+What we've done here is make another struct, `CircleBuilder`. We've defined our\n+builder methods on it. We've also defined our `area()` method on `Circle`. We\n+also made one more method on `CircleBuilder`: `finalize()`. This method creates\n+our final `Circle` from the builder. Now, we've used the type system to enforce\n+our concerns: we can use the methods on `CircleBuilder` to constrain making\n+`Circle`s in any way we choose."}, {"sha": "952e299265d85aba4ca5d6f76ca4b8c37ca2aa0a", "filename": "src/etc/errorck.py", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fetc%2Ferrorck.py", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fetc%2Ferrorck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ferrorck.py?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -14,11 +14,10 @@\n import sys, os, re\n \n src_dir = sys.argv[1]\n-\n-errcode_map = { }\n+errcode_map = {}\n+error_re = re.compile(\"(E\\d\\d\\d\\d)\")\n \n for (dirpath, dirnames, filenames) in os.walk(src_dir):\n-\n     if \"src/test\" in dirpath or \"src/llvm\" in dirpath:\n         # Short circuit for fast\n         continue\n@@ -28,15 +27,12 @@\n             continue\n \n         path = os.path.join(dirpath, filename)\n-        line_num = 1\n-        with open(path, 'r') as f:\n-            for line in f:\n-\n-                p = re.compile(\"(E\\d\\d\\d\\d)\")\n-                m = p.search(line)\n-                if not m is None:\n-                    errcode = m.group(1)\n \n+        with open(path, 'r') as f:\n+            for line_num, line in enumerate(f, start=1):\n+                match = error_re.search(line)\n+                if match:\n+                    errcode = match.group(1)\n                     new_record = [(errcode, path, line_num, line)]\n                     existing = errcode_map.get(errcode)\n                     if existing is not None:\n@@ -45,26 +41,19 @@\n                     else:\n                         errcode_map[errcode] = new_record\n \n-                line_num += 1\n-\n errors = False\n all_errors = []\n-for errcode in errcode_map:\n-    entries = errcode_map[errcode]\n-    all_errors += [entries[0][0]]\n+\n+for errcode, entries in errcode_map.items():\n+    all_errors.append(entries[0][0])\n     if len(entries) > 1:\n-        print \"error: duplicate error code \" + errcode\n+        print(\"error: duplicate error code \" + errcode)\n         for entry in entries:\n-            print entry[1] + \": \" + str(entry[2])\n-            print entry[3]\n+            print(\"{1}: {2}\\n{3}\".format(*entry))\n         errors = True\n \n-print str(len(errcode_map)) + \" error codes\"\n-\n-all_errors.sort()\n-all_errors.reverse()\n-\n-print \"highest error code: \" + all_errors[0]\n+print(\"{0} error codes\".format(len(errcode_map)))\n+print(\"highest error code: \" + max(all_errors))\n \n if errors:\n     sys.exit(1)"}, {"sha": "f38583ee1fb3774c8bf01c56304358b58992fe70", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -8,29 +8,18 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-license1 = \"\"\"// Copyright \"\"\"\n-license2 = \"\"\" The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\"\"\"\n+import re\n \n-license3 = \"\"\"# Copyright \"\"\"\n-license4 = \"\"\" The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\"\"\"\n+license_re = re.compile(\n+u\"\"\"(#|//) Copyright .* The Rust Project Developers. See the COPYRIGHT\n+\\\\1 file at the top-level directory of this distribution and at\n+\\\\1 http://rust-lang.org/COPYRIGHT.\n+\\\\1\n+\\\\1 Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+\\\\1 http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+\\\\1 <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+\\\\1 option. This file may not be copied, modified, or distributed\n+\\\\1 except according to those terms.\"\"\")\n \n exceptions = [\n     \"rt/rust_android_dummy.cpp\", # BSD, chromium\n@@ -57,18 +46,14 @@\n \n def check_license(name, contents):\n     # Whitelist check\n-    for exception in exceptions:\n-        if name.endswith(exception):\n-            return True\n+    if any(name.endswith(e) for e in exceptions):\n+        return True\n \n     # Xfail check\n     firstlineish = contents[:100]\n-    if firstlineish.find(\"ignore-license\") != -1:\n+    if \"ignore-license\" in firstlineish:\n         return True\n \n     # License check\n     boilerplate = contents[:500]\n-    if (boilerplate.find(license1) == -1 or boilerplate.find(license2) == -1) and \\\n-       (boilerplate.find(license3) == -1 or boilerplate.find(license4) == -1):\n-        return False\n-    return True\n+    return bool(license_re.search(boilerplate))"}, {"sha": "c65b762e5173168c880f18dc5209b99e62c65226", "filename": "src/etc/tidy.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -113,7 +113,7 @@ def do_license_check(name, contents):\n     if current_name != \"\":\n         do_license_check(current_name, current_contents)\n \n-except UnicodeDecodeError, e:\n+except UnicodeDecodeError as e:\n     report_err(\"UTF-8 decoding error \" + str(e))\n \n "}, {"sha": "58202a08c372742b8d2f44253810a4811ad43f0f", "filename": "src/grammar/lexer.l", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,342 @@\n+%{\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <stdio.h>\n+#include <ctype.h>\n+\n+static int num_hashes;\n+static int end_hashes;\n+static int saw_non_hash;\n+\n+%}\n+\n+%option stack\n+%option yylineno\n+\n+%x str\n+%x rawstr\n+%x rawstr_esc_begin\n+%x rawstr_esc_body\n+%x rawstr_esc_end\n+%x byte\n+%x bytestr\n+%x rawbytestr\n+%x rawbytestr_nohash\n+%x pound\n+%x shebang_or_attr\n+%x ltorchar\n+%x linecomment\n+%x doc_line\n+%x blockcomment\n+%x doc_block\n+%x suffix\n+\n+ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n+\n+%%\n+\n+<suffix>{ident}            { BEGIN(INITIAL); }\n+<suffix>(.|\\n)  { yyless(0); BEGIN(INITIAL); }\n+\n+[ \\n\\t\\r]             { }\n+\n+\\xef\\xbb\\xbf {\n+  // UTF-8 byte order mark (BOM), ignore if in line 1, error otherwise\n+  if (yyget_lineno() != 1) {\n+    return -1;\n+  }\n+}\n+\n+\\/\\/(\\/|\\!)           { BEGIN(doc_line); yymore(); }\n+<doc_line>\\n          { BEGIN(INITIAL);\n+                        yyleng--;\n+                        yytext[yyleng] = 0;\n+                        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n+                      }\n+<doc_line>[^\\n]*      { yymore(); }\n+\n+\\/\\/|\\/\\/\\/\\/         { BEGIN(linecomment); }\n+<linecomment>\\n       { BEGIN(INITIAL); }\n+<linecomment>[^\\n]*   { }\n+\n+\\/\\*(\\*|\\!)[^*]       { yy_push_state(INITIAL); yy_push_state(doc_block); yymore(); }\n+<doc_block>\\/\\*       { yy_push_state(doc_block); yymore(); }\n+<doc_block>\\*\\/       {\n+    yy_pop_state();\n+    if (yy_top_state() == doc_block) {\n+        yymore();\n+    } else {\n+        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n+    }\n+}\n+<doc_block>(.|\\n)     { yymore(); }\n+\n+\\/\\*                  { yy_push_state(blockcomment); }\n+<blockcomment>\\/\\*    { yy_push_state(blockcomment); }\n+<blockcomment>\\*\\/    { yy_pop_state(); }\n+<blockcomment>(.|\\n)   { }\n+\n+_        { return UNDERSCORE; }\n+as       { return AS; }\n+box      { return BOX; }\n+break    { return BREAK; }\n+const    { return CONST; }\n+continue { return CONTINUE; }\n+crate    { return CRATE; }\n+else     { return ELSE; }\n+enum     { return ENUM; }\n+extern   { return EXTERN; }\n+false    { return FALSE; }\n+fn       { return FN; }\n+for      { return FOR; }\n+if       { return IF; }\n+impl     { return IMPL; }\n+in       { return IN; }\n+let      { return LET; }\n+loop     { return LOOP; }\n+match    { return MATCH; }\n+mod      { return MOD; }\n+move     { return MOVE; }\n+mut      { return MUT; }\n+priv     { return PRIV; }\n+proc     { return PROC; }\n+pub      { return PUB; }\n+ref      { return REF; }\n+return   { return RETURN; }\n+self     { return SELF; }\n+static   { return STATIC; }\n+struct   { return STRUCT; }\n+trait    { return TRAIT; }\n+true     { return TRUE; }\n+type     { return TYPE; }\n+typeof   { return TYPEOF; }\n+unsafe   { return UNSAFE; }\n+use      { return USE; }\n+where    { return WHERE; }\n+while    { return WHILE; }\n+\n+{ident}  { return IDENT; }\n+\n+0x[0-9a-fA-F_]+                                    { BEGIN(suffix); return LIT_INTEGER; }\n+0o[0-8_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n+0b[01_]+                                           { BEGIN(suffix); return LIT_INTEGER; }\n+[0-9][0-9_]*                                       { BEGIN(suffix); return LIT_INTEGER; }\n+[0-9][0-9_]*\\.(\\.|[a-zA-Z])    { yyless(yyleng - 2); BEGIN(suffix); return LIT_INTEGER; }\n+\n+[0-9][0-9_]*\\.[0-9_]*([eE][-\\+]?[0-9_]+)?          { BEGIN(suffix); return LIT_FLOAT; }\n+[0-9][0-9_]*(\\.[0-9_]*)?[eE][-\\+]?[0-9_]+          { BEGIN(suffix); return LIT_FLOAT; }\n+\n+;      { return ';'; }\n+,      { return ','; }\n+\\.\\.\\. { return DOTDOTDOT; }\n+\\.\\.   { return DOTDOT; }\n+\\.     { return '.'; }\n+\\(     { return '('; }\n+\\)     { return ')'; }\n+\\{     { return '{'; }\n+\\}     { return '}'; }\n+\\[     { return '['; }\n+\\]     { return ']'; }\n+@      { return '@'; }\n+#      { BEGIN(pound); yymore(); }\n+<pound>\\! { BEGIN(shebang_or_attr); yymore(); }\n+<shebang_or_attr>\\[ {\n+  BEGIN(INITIAL);\n+  yyless(2);\n+  return SHEBANG;\n+}\n+<shebang_or_attr>[^\\[\\n]*\\n {\n+  // Since the \\n was eaten as part of the token, yylineno will have\n+  // been incremented to the value 2 if the shebang was on the first\n+  // line. This yyless undoes that, setting yylineno back to 1.\n+  yyless(yyleng - 1);\n+  if (yyget_lineno() == 1) {\n+    BEGIN(INITIAL);\n+    return SHEBANG_LINE;\n+  } else {\n+    BEGIN(INITIAL);\n+    yyless(2);\n+    return SHEBANG;\n+  }\n+}\n+<pound>. { BEGIN(INITIAL); yyless(1); return '#'; }\n+\n+\\~     { return '~'; }\n+::     { return MOD_SEP; }\n+:      { return ':'; }\n+\\$     { return '$'; }\n+\\?     { return '?'; }\n+\n+==    { return EQEQ; }\n+=>    { return FAT_ARROW; }\n+=     { return '='; }\n+\\!=   { return NE; }\n+\\!    { return '!'; }\n+\\<=   { return LE; }\n+\\<\\<  { return SHL; }\n+\\<\\<= { return SHLEQ; }\n+\\<    { return '<'; }\n+\\>=   { return GE; }\n+\\>\\>  { return SHR; }\n+\\>\\>= { return SHREQ; }\n+\\>    { return '>'; }\n+\n+\\x27                                  { BEGIN(ltorchar); yymore(); }\n+<ltorchar>static                      { BEGIN(INITIAL); return STATIC_LIFETIME; }\n+<ltorchar>{ident}                     { BEGIN(INITIAL); return LIFETIME; }\n+<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27      { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27       { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\u\\{[0-9a-fA-F]?{6}\\}\\x27  { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>.\\x27                       { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>[\\x80-\\xff]{2,4}\\x27        { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar><<EOF>>                     { BEGIN(INITIAL); return -1; }\n+\n+b\\x22              { BEGIN(bytestr); yymore(); }\n+<bytestr>\\x22      { BEGIN(suffix); return LIT_BINARY; }\n+\n+<bytestr><<EOF>>                { return -1; }\n+<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n+<bytestr>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n+<bytestr>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n+<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n+<bytestr>(.|\\n)                 { yymore(); }\n+\n+br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n+<rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BINARY_RAW; }\n+<rawbytestr_nohash>(.|\\n)   { yymore(); }\n+<rawbytestr_nohash><<EOF>>  { return -1; }\n+\n+br/# {\n+    BEGIN(rawbytestr);\n+    yymore();\n+    num_hashes = 0;\n+    saw_non_hash = 0;\n+    end_hashes = 0;\n+}\n+<rawbytestr># {\n+    if (!saw_non_hash) {\n+        num_hashes++;\n+    } else if (end_hashes != 0) {\n+        end_hashes++;\n+        if (end_hashes == num_hashes) {\n+            BEGIN(INITIAL);\n+            return LIT_BINARY_RAW;\n+        }\n+    }\n+    yymore();\n+}\n+<rawbytestr>\\x22# {\n+    end_hashes = 1;\n+    if (end_hashes == num_hashes) {\n+        BEGIN(INITIAL);\n+        return LIT_BINARY_RAW;\n+    }\n+    yymore();\n+}\n+<rawbytestr>(.|\\n) {\n+    if (!saw_non_hash) {\n+        saw_non_hash = 1;\n+    }\n+    if (end_hashes != 0) {\n+        end_hashes = 0;\n+    }\n+    yymore();\n+}\n+<rawbytestr><<EOF>> { return -1; }\n+\n+b\\x27                        { BEGIN(byte); yymore(); }\n+<byte>\\\\[nrt\\\\\\x27\\x220]\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\x[0-9a-fA-F]{2}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\u[0-9a-fA-F]{4}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\U[0-9a-fA-F]{8}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>.\\x27                  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte><<EOF>>                { BEGIN(INITIAL); return -1; }\n+\n+r\\x22           { BEGIN(rawstr); yymore(); }\n+<rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n+<rawstr>(.|\\n)  { yymore(); }\n+<rawstr><<EOF>> { return -1; }\n+\n+r/#             {\n+    BEGIN(rawstr_esc_begin);\n+    yymore();\n+    num_hashes = 0;\n+    saw_non_hash = 0;\n+    end_hashes = 0;\n+}\n+\n+<rawstr_esc_begin># {\n+    num_hashes++;\n+    yymore();\n+}\n+<rawstr_esc_begin>\\x22 {\n+    BEGIN(rawstr_esc_body);\n+    yymore();\n+}\n+<rawstr_esc_begin>(.|\\n) { return -1; }\n+\n+<rawstr_esc_body>\\x22/# {\n+  BEGIN(rawstr_esc_end);\n+  yymore();\n+ }\n+<rawstr_esc_body>(.|\\n) {\n+  yymore();\n+ }\n+\n+<rawstr_esc_end># {\n+  end_hashes++;\n+  if (end_hashes == num_hashes) {\n+    BEGIN(INITIAL);\n+    return LIT_STR_RAW;\n+  }\n+  yymore();\n+ }\n+<rawstr_esc_end>[^#] {\n+  end_hashes = 0;\n+  BEGIN(rawstr_esc_body);\n+  yymore();\n+ }\n+\n+<rawstr_esc_begin,rawstr_esc_body,rawstr_esc_end><<EOF>> { return -1; }\n+\n+\\x22                     { BEGIN(str); yymore(); }\n+<str>\\x22                { BEGIN(suffix); return LIT_STR; }\n+\n+<str><<EOF>>                { return -1; }\n+<str>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n+<str>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n+<str>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n+<str>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n+<str>(.|\\n)                 { yymore(); }\n+\n+-\\>  { return RARROW; }\n+-    { return '-'; }\n+-=   { return MINUSEQ; }\n+&&   { return ANDAND; }\n+&    { return '&'; }\n+&=   { return ANDEQ; }\n+\\|\\| { return OROR; }\n+\\|   { return '|'; }\n+\\|=  { return OREQ; }\n+\\+   { return '+'; }\n+\\+=  { return PLUSEQ; }\n+\\*   { return '*'; }\n+\\*=  { return STAREQ; }\n+\\/   { return '/'; }\n+\\/=  { return SLASHEQ; }\n+\\^   { return '^'; }\n+\\^=  { return CARETEQ; }\n+%    { return '%'; }\n+%=   { return PERCENTEQ; }\n+\n+<<EOF>> { return 0; }\n+\n+%%"}, {"sha": "db88a1f2999aa56a8fdac9d26472e20c3b9c824f", "filename": "src/grammar/parser-lalr-main.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fgrammar%2Fparser-lalr-main.c", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fgrammar%2Fparser-lalr-main.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr-main.c?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,203 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+extern int yylex();\n+extern int rsparse();\n+\n+#define PUSHBACK_LEN 4\n+\n+static char pushback[PUSHBACK_LEN];\n+static int verbose;\n+\n+void print(const char* format, ...) {\n+  va_list args;\n+  va_start(args, format);\n+  if (verbose) {\n+    vprintf(format, args);\n+  }\n+  va_end(args);\n+}\n+\n+// If there is a non-null char at the head of the pushback queue,\n+// dequeue it and shift the rest of the queue forwards. Otherwise,\n+// return the token from calling yylex.\n+int rslex() {\n+  if (pushback[0] == '\\0') {\n+    return yylex();\n+  } else {\n+    char c = pushback[0];\n+    memmove(pushback, pushback + 1, PUSHBACK_LEN - 1);\n+    pushback[PUSHBACK_LEN - 1] = '\\0';\n+    return c;\n+  }\n+}\n+\n+// Note: this does nothing if the pushback queue is full. As long as\n+// there aren't more than PUSHBACK_LEN consecutive calls to push_back\n+// in an action, this shouldn't be a problem.\n+void push_back(char c) {\n+  for (int i = 0; i < PUSHBACK_LEN; ++i) {\n+    if (pushback[i] == '\\0') {\n+      pushback[i] = c;\n+      break;\n+    }\n+  }\n+}\n+\n+extern int rsdebug;\n+\n+struct node {\n+  struct node *next;\n+  struct node *prev;\n+  int own_string;\n+  char const *name;\n+  int n_elems;\n+  struct node *elems[];\n+};\n+\n+struct node *nodes = NULL;\n+int n_nodes;\n+\n+struct node *mk_node(char const *name, int n, ...) {\n+  va_list ap;\n+  int i = 0;\n+  unsigned sz = sizeof(struct node) + (n * sizeof(struct node *));\n+  struct node *nn, *nd = (struct node *)malloc(sz);\n+\n+  print(\"# New %d-ary node: %s = %p\\n\", n, name, nd);\n+\n+  nd->own_string = 0;\n+  nd->prev = NULL;\n+  nd->next = nodes;\n+  if (nodes) {\n+    nodes->prev = nd;\n+  }\n+  nodes = nd;\n+\n+  nd->name = name;\n+  nd->n_elems = n;\n+\n+  va_start(ap, n);\n+  while (i < n) {\n+    nn = va_arg(ap, struct node *);\n+    print(\"#   arg[%d]: %p\\n\", i, nn);\n+    print(\"#            (%s ...)\\n\", nn->name);\n+    nd->elems[i++] = nn;\n+  }\n+  va_end(ap);\n+  n_nodes++;\n+  return nd;\n+}\n+\n+struct node *mk_atom(char *name) {\n+  struct node *nd = mk_node((char const *)strdup(name), 0);\n+  nd->own_string = 1;\n+  return nd;\n+}\n+\n+struct node *mk_none() {\n+  return mk_atom(\"<none>\");\n+}\n+\n+struct node *ext_node(struct node *nd, int n, ...) {\n+  va_list ap;\n+  int i = 0, c = nd->n_elems + n;\n+  unsigned sz = sizeof(struct node) + (c * sizeof(struct node *));\n+  struct node *nn;\n+\n+  print(\"# Extending %d-ary node by %d nodes: %s = %p\",\n+        nd->n_elems, c, nd->name, nd);\n+\n+  if (nd->next) {\n+    nd->next->prev = nd->prev;\n+  }\n+  if (nd->prev) {\n+    nd->prev->next = nd->next;\n+  }\n+  nd = realloc(nd, sz);\n+  nd->prev = NULL;\n+  nd->next = nodes;\n+  nodes->prev = nd;\n+  nodes = nd;\n+\n+  print(\" ==> %p\\n\", nd);\n+\n+  va_start(ap, n);\n+  while (i < n) {\n+    nn = va_arg(ap, struct node *);\n+    print(\"#   arg[%d]: %p\\n\", i, nn);\n+    print(\"#            (%s ...)\\n\", nn->name);\n+    nd->elems[nd->n_elems++] = nn;\n+    ++i;\n+  }\n+  va_end(ap);\n+  return nd;\n+}\n+\n+int const indent_step = 4;\n+\n+void print_indent(int depth) {\n+  while (depth) {\n+    if (depth-- % indent_step == 0) {\n+      print(\"|\");\n+    } else {\n+      print(\" \");\n+    }\n+  }\n+}\n+\n+void print_node(struct node *n, int depth) {\n+  int i = 0;\n+  print_indent(depth);\n+  if (n->n_elems == 0) {\n+    print(\"%s\\n\", n->name);\n+  } else {\n+    print(\"(%s\\n\", n->name);\n+    for (i = 0; i < n->n_elems; ++i) {\n+      print_node(n->elems[i], depth + indent_step);\n+    }\n+    print_indent(depth);\n+    print(\")\\n\");\n+  }\n+}\n+\n+int main(int argc, char **argv) {\n+  if (argc == 2 && strcmp(argv[1], \"-v\") == 0) {\n+    verbose = 1;\n+  } else {\n+    verbose = 0;\n+  }\n+  int ret = 0;\n+  struct node *tmp;\n+  memset(pushback, '\\0', PUSHBACK_LEN);\n+  ret = rsparse();\n+  print(\"--- PARSE COMPLETE: ret:%d, n_nodes:%d ---\\n\", ret, n_nodes);\n+  if (nodes) {\n+    print_node(nodes, 0);\n+  }\n+  while (nodes) {\n+    tmp = nodes;\n+    nodes = tmp->next;\n+    if (tmp->own_string) {\n+      free((void*)tmp->name);\n+    }\n+    free(tmp);\n+  }\n+  return ret;\n+}\n+\n+void rserror(char const *s) {\n+  fprintf(stderr, \"%s\\n\", s);\n+}"}, {"sha": "24185ed65d5c50df01c13d95783a97c63387121a", "filename": "src/grammar/parser-lalr.y", "status": "added", "additions": 1912, "deletions": 0, "changes": 1912, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,1912 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+%{\n+#define YYERROR_VERBOSE\n+#define YYSTYPE struct node *\n+struct node;\n+extern int yylex();\n+extern void yyerror(char const *s);\n+extern struct node *mk_node(char const *name, int n, ...);\n+extern struct node *mk_atom(char *text);\n+extern struct node *mk_none();\n+extern struct node *ext_node(struct node *nd, int n, ...);\n+extern void push_back(char c);\n+extern char *yytext;\n+%}\n+%debug\n+\n+%token SHL\n+%token SHR\n+%token LE\n+%token EQEQ\n+%token NE\n+%token GE\n+%token ANDAND\n+%token OROR\n+%token SHLEQ\n+%token SHREQ\n+%token MINUSEQ\n+%token ANDEQ\n+%token OREQ\n+%token PLUSEQ\n+%token STAREQ\n+%token SLASHEQ\n+%token CARETEQ\n+%token PERCENTEQ\n+%token DOTDOT\n+%token DOTDOTDOT\n+%token MOD_SEP\n+%token RARROW\n+%token FAT_ARROW\n+%token LIT_BYTE\n+%token LIT_CHAR\n+%token LIT_INTEGER\n+%token LIT_FLOAT\n+%token LIT_STR\n+%token LIT_STR_RAW\n+%token LIT_BINARY\n+%token LIT_BINARY_RAW\n+%token IDENT\n+%token UNDERSCORE\n+%token LIFETIME\n+\n+// keywords\n+%token SELF\n+%token STATIC\n+%token AS\n+%token BREAK\n+%token CRATE\n+%token ELSE\n+%token ENUM\n+%token EXTERN\n+%token FALSE\n+%token FN\n+%token FOR\n+%token IF\n+%token IMPL\n+%token IN\n+%token LET\n+%token LOOP\n+%token MATCH\n+%token MOD\n+%token MOVE\n+%token MUT\n+%token PRIV\n+%token PUB\n+%token REF\n+%token RETURN\n+%token STRUCT\n+%token TRUE\n+%token TRAIT\n+%token TYPE\n+%token UNSAFE\n+%token USE\n+%token WHILE\n+%token CONTINUE\n+%token PROC\n+%token BOX\n+%token CONST\n+%token WHERE\n+%token TYPEOF\n+%token INNER_DOC_COMMENT\n+%token OUTER_DOC_COMMENT\n+\n+%token SHEBANG\n+%token SHEBANG_LINE\n+%token STATIC_LIFETIME\n+\n+ /*\n+   Quoting from the Bison manual:\n+\n+   \"Finally, the resolution of conflicts works by comparing the precedence\n+   of the rule being considered with that of the lookahead token. If the\n+   token's precedence is higher, the choice is to shift. If the rule's\n+   precedence is higher, the choice is to reduce. If they have equal\n+   precedence, the choice is made based on the associativity of that\n+   precedence level. The verbose output file made by \u2018-v\u2019 (see Invoking\n+   Bison) says how each conflict was resolved\"\n+ */\n+\n+// We expect no shift/reduce or reduce/reduce conflicts in this grammar;\n+// all potential ambiguities are scrutinized and eliminated manually.\n+%expect 0\n+\n+// fake-precedence symbol to cause '|' bars in lambda context to parse\n+// at low precedence, permit things like |x| foo = bar, where '=' is\n+// otherwise lower-precedence than '|'. Also used for proc() to cause\n+// things like proc() a + b to parse as proc() { a + b }.\n+%precedence LAMBDA\n+\n+%precedence SELF\n+\n+// MUT should be lower precedence than IDENT so that in the pat rule,\n+// \"& MUT pat\" has higher precedence than \"binding_mode ident [@ pat]\"\n+%precedence MUT\n+\n+// IDENT needs to be lower than '{' so that 'foo {' is shifted when\n+// trying to decide if we've got a struct-construction expr (esp. in\n+// contexts like 'if foo { .')\n+//\n+// IDENT also needs to be lower precedence than '<' so that '<' in\n+// 'foo:bar . <' is shifted (in a trait reference occurring in a\n+// bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n+%precedence IDENT\n+\n+// A couple fake-precedence symbols to use in rules associated with +\n+// and < in trailing type contexts. These come up when you have a type\n+// in the RHS of operator-AS, such as \"foo as bar<baz>\". The \"<\" there\n+// has to be shifted so the parser keeps trying to parse a type, even\n+// though it might well consider reducing the type \"bar\" and then\n+// going on to \"<\" as a subsequent binop. The \"+\" case is with\n+// trailing type-bounds (\"foo as bar:A+B\"), for the same reason.\n+%precedence SHIFTPLUS\n+\n+%precedence MOD_SEP\n+%precedence RARROW ':'\n+\n+// Binops & unops, and their precedences\n+%precedence BOX\n+%precedence BOXPLACE\n+%nonassoc DOTDOT\n+\n+// RETURN needs to be lower-precedence than tokens that start\n+// prefix_exprs\n+%precedence RETURN\n+\n+%left '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n+%left OROR\n+%left ANDAND\n+%left EQEQ NE\n+%left '<' '>' LE GE\n+%left '|'\n+%left '^'\n+%left '&'\n+%left SHL SHR\n+%left '+' '-'\n+%precedence AS\n+%left '*' '/' '%'\n+%precedence '!'\n+\n+%precedence '{' '[' '(' '.'\n+\n+%start crate\n+\n+%%\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 1: Items and attributes\n+////////////////////////////////////////////////////////////////////////\n+\n+crate\n+: maybe_shebang inner_attrs maybe_mod_items  { mk_node(\"crate\", 2, $2, $3); }\n+| maybe_shebang maybe_mod_items  { mk_node(\"crate\", 1, $2); }\n+;\n+\n+maybe_shebang\n+: SHEBANG_LINE\n+| %empty\n+;\n+\n+maybe_inner_attrs\n+: inner_attrs\n+| %empty                   { $$ = mk_none(); }\n+;\n+\n+inner_attrs\n+: inner_attr               { $$ = mk_node(\"InnerAttrs\", 1, $1); }\n+| inner_attrs inner_attr   { $$ = ext_node($1, 1, $2); }\n+;\n+\n+inner_attr\n+: SHEBANG '[' meta_item ']'   { $$ = mk_node(\"InnerAttr\", 1, $3); }\n+| INNER_DOC_COMMENT           { $$ = mk_node(\"InnerAttr\", 1, mk_node(\"doc-comment\", 1, mk_atom(yytext))); }\n+;\n+\n+maybe_outer_attrs\n+: outer_attrs\n+| %empty                   { $$ = mk_none(); }\n+;\n+\n+outer_attrs\n+: outer_attr               { $$ = mk_node(\"OuterAttrs\", 1, $1); }\n+| outer_attrs outer_attr   { $$ = ext_node($1, 1, $2); }\n+;\n+\n+outer_attr\n+: '#' '[' meta_item ']'    { $$ = $3; }\n+| OUTER_DOC_COMMENT        { $$ = mk_node(\"doc-comment\", 1, mk_atom(yytext)); }\n+;\n+\n+meta_item\n+: ident                      { $$ = mk_node(\"MetaWord\", 1, $1); }\n+| ident '=' lit              { $$ = mk_node(\"MetaNameValue\", 2, $1, $3); }\n+| ident '(' meta_seq ')'     { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n+| ident '(' meta_seq ',' ')' { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n+;\n+\n+meta_seq\n+: %empty                   { $$ = mk_none(); }\n+| meta_item                { $$ = mk_node(\"MetaItems\", 1, $1); }\n+| meta_seq ',' meta_item   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+maybe_mod_items\n+: mod_items\n+| %empty             { $$ = mk_none(); }\n+;\n+\n+mod_items\n+: mod_item                               { $$ = mk_node(\"Items\", 1, $1); }\n+| mod_items mod_item                     { $$ = ext_node($1, 1, $2); }\n+;\n+\n+attrs_and_vis\n+: maybe_outer_attrs visibility           { $$ = mk_node(\"AttrsAndVis\", 2, $1, $2); }\n+;\n+\n+mod_item\n+: attrs_and_vis item    { $$ = mk_node(\"Item\", 2, $1, $2); }\n+;\n+\n+// items that can appear outside of a fn block\n+item\n+: item_static\n+| item_const\n+| item_type\n+| block_item\n+| view_item\n+| item_macro\n+;\n+\n+// items that can appear in \"stmts\"\n+stmt_item\n+: item_static\n+| item_const\n+| item_type\n+| block_item\n+| use_item\n+| extern_fn_item\n+;\n+\n+item_static\n+: STATIC ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $2, $4, $6); }\n+| STATIC MUT ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $3, $5, $7); }\n+;\n+\n+item_const\n+: CONST ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemConst\", 3, $2, $4, $6); }\n+;\n+\n+item_macro\n+: path_expr '!' maybe_ident parens_delimited_token_trees ';'\n+| path_expr '!' maybe_ident braces_delimited_token_trees\n+| path_expr '!' maybe_ident brackets_delimited_token_trees ';'\n+;\n+\n+view_item\n+: use_item\n+| extern_fn_item\n+| EXTERN CRATE ident ';'                      { $$ = mk_node(\"ViewItemExternCrate\", 1, $3); }\n+| EXTERN CRATE ident '=' str ';'              { $$ = mk_node(\"ViewItemExternCrate\", 2, $3, $5); }\n+| EXTERN CRATE str AS ident ';'               { $$ = mk_node(\"ViewItemExternCrate\", 2, $3, $5); }\n+;\n+\n+extern_fn_item\n+: EXTERN maybe_abi item_fn                    { $$ = mk_node(\"ViewItemExternFn\", 2, $2, $3); }\n+;\n+\n+use_item\n+: USE view_path ';'                           { $$ = mk_node(\"ViewItemUse\", 1, $2); }\n+;\n+\n+view_path\n+: path_no_types_allowed                                    { $$ = mk_node(\"ViewPathSimple\", 1, $1); }\n+| path_no_types_allowed MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, mk_atom(\"ViewPathListEmpty\")); }\n+| path_no_types_allowed MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n+| path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n+| path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n+|                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n+|                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n+|                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n+| path_no_types_allowed AS ident                           { $$ = mk_node(\"ViewPathSimple\", 2, $1, $3); }\n+;\n+\n+block_item\n+: item_fn\n+| item_unsafe_fn\n+| item_mod\n+| item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n+| item_struct\n+| item_enum\n+| item_trait\n+| item_impl\n+;\n+\n+maybe_ty_ascription\n+: ':' ty { $$ = $2; }\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_init_expr\n+: '=' expr { $$ = $2; }\n+| %empty   { $$ = mk_none(); }\n+;\n+\n+// structs\n+item_struct\n+: STRUCT ident generic_params maybe_where_clause struct_decl_args\n+{\n+  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n+}\n+| STRUCT ident generic_params struct_tuple_args maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n+}\n+| STRUCT ident generic_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"ItemStruct\", 3, $2, $3, $4);\n+}\n+;\n+\n+struct_decl_args\n+: '{' struct_decl_fields '}'                  { $$ = $2; }\n+| '{' struct_decl_fields ',' '}'              { $$ = $2; }\n+;\n+\n+struct_tuple_args\n+: '(' struct_tuple_fields ')'                 { $$ = $2; }\n+| '(' struct_tuple_fields ',' ')'             { $$ = $2; }\n+;\n+\n+struct_decl_fields\n+: struct_decl_field                           { $$ = mk_node(\"StructFields\", 1, $1); }\n+| struct_decl_fields ',' struct_decl_field    { $$ = ext_node($1, 1, $3); }\n+| %empty                                      { $$ = mk_none(); }\n+;\n+\n+struct_decl_field\n+: attrs_and_vis ident ':' ty_sum              { $$ = mk_node(\"StructField\", 3, $1, $2, $4); }\n+;\n+\n+struct_tuple_fields\n+: struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n+| struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n+;\n+\n+struct_tuple_field\n+: attrs_and_vis ty_sum                    { $$ = mk_node(\"StructField\", 2, $1, $2); }\n+;\n+\n+// enums\n+item_enum\n+: ENUM ident generic_params maybe_where_clause '{' enum_defs '}'     { $$ = mk_node(\"ItemEnum\", 0); }\n+| ENUM ident generic_params maybe_where_clause '{' enum_defs ',' '}' { $$ = mk_node(\"ItemEnum\", 0); }\n+;\n+\n+enum_defs\n+: enum_def               { $$ = mk_node(\"EnumDefs\", 1, $1); }\n+| enum_defs ',' enum_def { $$ = ext_node($1, 1, $3); }\n+| %empty                 { $$ = mk_none(); }\n+;\n+\n+enum_def\n+: attrs_and_vis ident enum_args { $$ = mk_node(\"EnumDef\", 3, $1, $2, $3); }\n+;\n+\n+enum_args\n+: '{' struct_decl_fields '}'     { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| '{' struct_decl_fields ',' '}' { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| '(' maybe_ty_sums ')'          { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| '=' expr                       { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| %empty                         { $$ = mk_none(); }\n+;\n+\n+item_mod\n+: MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n+| MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n+| MOD ident '{' inner_attrs maybe_mod_items '}' { $$ = mk_node(\"ItemMod\", 3, $2, $4, $5); }\n+;\n+\n+item_foreign_mod\n+: EXTERN maybe_abi '{' maybe_foreign_items '}'             { $$ = mk_node(\"ItemForeignMod\", 1, $4); }\n+| EXTERN maybe_abi '{' inner_attrs maybe_foreign_items '}' { $$ = mk_node(\"ItemForeignMod\", 2, $4, $5); }\n+;\n+\n+maybe_abi\n+: str\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_foreign_items\n+: foreign_items\n+| %empty { $$ = mk_none(); }\n+;\n+\n+foreign_items\n+: foreign_item               { $$ = mk_node(\"ForeignItems\", 1, $1); }\n+| foreign_items foreign_item { $$ = ext_node($1, 1, $2); }\n+;\n+\n+foreign_item\n+: attrs_and_vis STATIC item_foreign_static { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n+| attrs_and_vis item_foreign_fn            { $$ = mk_node(\"ForeignItem\", 2, $1, $2); }\n+| attrs_and_vis UNSAFE item_foreign_fn     { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n+;\n+\n+item_foreign_static\n+: maybe_mut ident ':' ty ';'               { $$ = mk_node(\"StaticItem\", 3, $1, $2, $4); }\n+;\n+\n+item_foreign_fn\n+: FN ident generic_params fn_decl_allow_variadic maybe_where_clause ';' { $$ = mk_node(\"ForeignFn\", 4, $2, $3, $4, $5); }\n+;\n+\n+fn_decl_allow_variadic\n+: fn_params_allow_variadic ret_ty { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_params_allow_variadic\n+: '(' ')'                      { $$ = mk_none(); }\n+| '(' params ')'               { $$ = $2; }\n+| '(' params ',' ')'           { $$ = $2; }\n+| '(' params ',' DOTDOTDOT ')' { $$ = $2; }\n+;\n+\n+visibility\n+: PUB      { $$ = mk_atom(\"Public\"); }\n+| %empty   { $$ = mk_atom(\"Inherited\"); }\n+;\n+\n+idents_or_self\n+: ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n+| idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ident_or_self\n+: ident\n+| SELF  { $$ = mk_atom(yytext); }\n+;\n+\n+item_type\n+: TYPE ident generic_params maybe_where_clause '=' ty_sum ';'  { $$ = mk_node(\"ItemTy\", 4, $2, $3, $4, $6); }\n+;\n+\n+for_sized\n+: FOR '?' ident { $$ = mk_node(\"ForSized\", 1, $3); }\n+| FOR ident '?' { $$ = mk_node(\"ForSized\", 1, $2); }\n+| %empty        { $$ = mk_none(); }\n+;\n+\n+item_trait\n+: maybe_unsafe TRAIT ident generic_params for_sized maybe_ty_param_bounds maybe_where_clause '{' maybe_trait_items '}'\n+{\n+  $$ = mk_node(\"ItemTrait\", 7, $1, $3, $4, $5, $6, $7, $9);\n+}\n+;\n+\n+maybe_trait_items\n+: trait_items\n+| %empty { $$ = mk_none(); }\n+;\n+\n+trait_items\n+: trait_item               { $$ = mk_node(\"TraitItems\", 1, $1); }\n+| trait_items trait_item   { $$ = ext_node($1, 1, $2); }\n+;\n+\n+trait_item\n+: trait_type\n+| trait_method\n+;\n+\n+trait_type\n+: maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(\"TypeTraitItem\", 2, $1, $3); }\n+;\n+\n+maybe_unsafe\n+: UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n+| %empty { $$ = mk_none(); }\n+;\n+\n+trait_method\n+: type_method { $$ = mk_node(\"Required\", 1, $1); }\n+| method      { $$ = mk_node(\"Provided\", 1, $1); }\n+;\n+\n+type_method\n+: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n+}\n+| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n+}\n+;\n+\n+method\n+: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n+}\n+| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n+}\n+;\n+\n+impl_method\n+: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n+}\n+| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n+}\n+;\n+\n+// There are two forms of impl:\n+//\n+// impl (<...>)? TY { ... }\n+// impl (<...>)? TRAIT for TY { ... }\n+//\n+// Unfortunately since TY can begin with '<' itself -- as part of a\n+// TyQualifiedPath type -- there's an s/r conflict when we see '<' after IMPL:\n+// should we reduce one of the early rules of TY (such as maybe_once)\n+// or shall we continue shifting into the generic_params list for the\n+// impl?\n+//\n+// The production parser disambiguates a different case here by\n+// permitting / requiring the user to provide parens around types when\n+// they are ambiguous with traits. We do the same here, regrettably,\n+// by splitting ty into ty and ty_prim.\n+item_impl\n+: maybe_unsafe IMPL generic_params ty_prim_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImpl\", 6, $1, $3, $4, $5, $7, $8);\n+}\n+| maybe_unsafe IMPL generic_params '(' ty ')' maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImpl\", 6, $1, $3, 5, $6, $9, $10);\n+}\n+| maybe_unsafe IMPL generic_params trait_ref FOR ty maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImpl\", 6, $3, $4, $6, $7, $9, $10);\n+}\n+| maybe_unsafe IMPL generic_params '!' trait_ref FOR ty maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImplNeg\", 7, $1, $3, $5, $7, $8, $10, $11);\n+}\n+;\n+\n+maybe_impl_items\n+: impl_items\n+| %empty { $$ = mk_none(); }\n+;\n+\n+impl_items\n+: impl_item               { $$ = mk_node(\"ImplItems\", 1, $1); }\n+| impl_item impl_items    { $$ = ext_node($1, 1, $2); }\n+;\n+\n+impl_item\n+: impl_method\n+| item_macro\n+| trait_type\n+;\n+\n+item_fn\n+: FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n+}\n+;\n+\n+item_unsafe_fn\n+: UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n+}\n+| UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n+}\n+;\n+\n+fn_decl\n+: fn_params ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_decl_with_self\n+: fn_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_decl_with_self_allow_anon_params\n+: fn_anon_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_params\n+: '(' maybe_params ')'  { $$ = $2; }\n+;\n+\n+fn_anon_params\n+: '(' anon_param anon_params_allow_variadic_tail ')' { $$ = ext_node($2, 1, $3); }\n+| '(' ')'                                            { $$ = mk_none(); }\n+;\n+\n+fn_params_with_self\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n+| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n+| '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n+;\n+\n+fn_anon_params_with_self\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n+| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n+| '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n+;\n+\n+maybe_params\n+: params\n+| params ','\n+| %empty  { $$ = mk_none(); }\n+;\n+\n+params\n+: param                { $$ = mk_node(\"Args\", 1, $1); }\n+| params ',' param     { $$ = ext_node($1, 1, $3); }\n+;\n+\n+param\n+: pat ':' ty   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n+;\n+\n+inferrable_params\n+: inferrable_param                       { $$ = mk_node(\"InferrableParams\", 1, $1); }\n+| inferrable_params ',' inferrable_param { $$ = ext_node($1, 1, $3); }\n+;\n+\n+inferrable_param\n+: pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n+;\n+\n+maybe_unboxed_closure_kind\n+: %empty\n+| ':'\n+| '&' maybe_mut ':'\n+;\n+\n+maybe_comma_params\n+: ','            { $$ = mk_none(); }\n+| ',' params     { $$ = $2; }\n+| ',' params ',' { $$ = $2; }\n+| %empty         { $$ = mk_none(); }\n+;\n+\n+maybe_comma_anon_params\n+: ','                 { $$ = mk_none(); }\n+| ',' anon_params     { $$ = $2; }\n+| ',' anon_params ',' { $$ = $2; }\n+| %empty              { $$ = mk_none(); }\n+;\n+\n+maybe_anon_params\n+: anon_params\n+| anon_params ','\n+| %empty      { $$ = mk_none(); }\n+;\n+\n+anon_params\n+: anon_param                 { $$ = mk_node(\"Args\", 1, $1); }\n+| anon_params ',' anon_param { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// anon means it's allowed to be anonymous (type-only), but it can\n+// still have a name\n+anon_param\n+: named_arg ':' ty   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n+| ty\n+;\n+\n+anon_params_allow_variadic_tail\n+: ',' DOTDOTDOT                                  { $$ = mk_none(); }\n+| ',' anon_param anon_params_allow_variadic_tail { $$ = mk_node(\"Args\", 2, $2, $3); }\n+| %empty                                         { $$ = mk_none(); }\n+;\n+\n+named_arg\n+: ident\n+| UNDERSCORE        { $$ = mk_atom(\"PatWild\"); }\n+| '&' ident         { $$ = $2; }\n+| '&' UNDERSCORE    { $$ = mk_atom(\"PatWild\"); }\n+| ANDAND ident      { $$ = $2; }\n+| ANDAND UNDERSCORE { $$ = mk_atom(\"PatWild\"); }\n+| MUT ident         { $$ = $2; }\n+;\n+\n+ret_ty\n+: RARROW '!'         { $$ = mk_none(); }\n+| RARROW ty          { $$ = mk_node(\"ret-ty\", 1, $2); }\n+| %prec IDENT %empty { $$ = mk_none(); }\n+;\n+\n+generic_params\n+: '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes ',' ty_params '>'     { $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' lifetimes ',' ty_params ',' '>' { $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' lifetimes ',' ty_params SHR     { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' lifetimes ',' ty_params ',' SHR { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' ty_params '>'                   { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| '<' ty_params ',' '>'               { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| '<' ty_params SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| '<' ty_params ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| %empty                              { $$ = mk_none(); }\n+;\n+\n+maybe_where_clause\n+: %empty                              { $$ = mk_none(); }\n+| where_clause\n+;\n+\n+where_clause\n+: WHERE where_predicates              { $$ = mk_node(\"WhereClause\", 1, $2); }\n+| WHERE where_predicates ','          { $$ = mk_node(\"WhereClause\", 1, $2); }\n+;\n+\n+where_predicates\n+: where_predicate                      { $$ = mk_node(\"WherePredicates\", 1, $1); }\n+| where_predicates ',' where_predicate { $$ = ext_node($1, 1, $3); }\n+;\n+\n+where_predicate\n+: lifetime ':' bounds    { $$ = mk_node(\"WherePredicate\", 2, $1, $3); }\n+| ty ':' ty_param_bounds { $$ = mk_node(\"WherePredicate\", 2, $1, $3); }\n+;\n+\n+ty_params\n+: ty_param               { $$ = mk_node(\"TyParams\", 1, $1); }\n+| ty_params ',' ty_param { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// A path with no type parameters; e.g. `foo::bar::Baz`\n+//\n+// These show up in 'use' view-items, because these are processed\n+// without respect to types.\n+path_no_types_allowed\n+: ident                               { $$ = mk_node(\"ViewPath\", 1, $1); }\n+| MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n+| SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n+| MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n+| path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// A path with a lifetime and type parameters, with no double colons\n+// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n+//\n+// These show up in \"trait references\", the components of\n+// type-parameter bounds lists, as well as in the prefix of the\n+// path_generic_args_and_bounds rule, which is the full form of a\n+// named typed expression.\n+//\n+// They do not have (nor need) an extra '::' before '<' because\n+// unlike in expr context, there are no \"less-than\" type exprs to\n+// be ambiguous with.\n+path_generic_args_without_colons\n+: %prec IDENT\n+  ident                                                                       { $$ = mk_node(\"components\", 1, $1); }\n+| %prec IDENT\n+  ident generic_args                                                          { $$ = mk_node(\"components\", 2, $1, $2); }\n+| %prec IDENT\n+  ident '(' maybe_ty_sums ')' ret_ty                                          { $$ = mk_node(\"components\", 2, $1, $3); }\n+| %prec IDENT\n+  path_generic_args_without_colons MOD_SEP ident                              { $$ = ext_node($1, 1, $3); }\n+| %prec IDENT\n+  path_generic_args_without_colons MOD_SEP ident generic_args                 { $$ = ext_node($1, 2, $3, $4); }\n+| %prec IDENT\n+  path_generic_args_without_colons MOD_SEP ident '(' maybe_ty_sums ')' ret_ty { $$ = ext_node($1, 2, $3, $5); }\n+;\n+\n+generic_args\n+: '<' generic_values '>'   { $$ = $2; }\n+| '<' generic_values SHR   { push_back('>'); $$ = $2; }\n+| '<' generic_values GE    { push_back('='); $$ = $2; }\n+| '<' generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n+// If generic_args starts with \"<<\", the first arg must be a\n+// TyQualifiedPath because that's the only type that can start with a\n+// '<'. This rule parses that as the first ty_sum and then continues\n+// with the rest of generic_values.\n+| SHL ty_qualified_path_and_generic_values '>'   { $$ = $2; }\n+| SHL ty_qualified_path_and_generic_values SHR   { push_back('>'); $$ = $2; }\n+| SHL ty_qualified_path_and_generic_values GE    { push_back('='); $$ = $2; }\n+| SHL ty_qualified_path_and_generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n+;\n+\n+generic_values\n+: maybe_lifetimes maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 2, $1, $2); }\n+;\n+\n+maybe_ty_sums_and_or_bindings\n+: ty_sums\n+| ty_sums ','\n+| ty_sums ',' bindings { $$ = mk_node(\"TySumsAndBindings\", 2, $1, $3); }\n+| bindings\n+| bindings ','\n+| %empty               { $$ = mk_none(); }\n+;\n+\n+maybe_bindings\n+: ',' bindings { $$ = $2; }\n+| %empty       { $$ = mk_none(); }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 2: Patterns\n+////////////////////////////////////////////////////////////////////////\n+\n+pat\n+: UNDERSCORE                                      { $$ = mk_atom(\"PatWild\"); }\n+| '&' pat                                         { $$ = mk_node(\"PatRegion\", 1, $2); }\n+| '&' MUT pat                                     { $$ = mk_node(\"PatRegion\", 1, $3); }\n+| ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n+| '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n+| '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n+| '(' pat_tup ',' ')'                             { $$ = mk_node(\"PatTup\", 1, $2); }\n+| '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n+| lit_or_path\n+| lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n+| path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n+| path_expr '(' DOTDOT ')'                        { $$ = mk_node(\"PatEnum\", 1, $1); }\n+| path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n+| path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n+| binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n+|              ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, mk_node(\"BindByValue\", 1, mk_atom(\"MutImmutable\")), $1, $3); }\n+| binding_mode ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, $1, $2, $4); }\n+| BOX pat                                         { $$ = mk_node(\"PatUniq\", 1, $2); }\n+;\n+\n+pats_or\n+: pat              { $$ = mk_node(\"Pats\", 1, $1); }\n+| pats_or '|' pat  { $$ = ext_node($1, 1, $3); }\n+;\n+\n+binding_mode\n+: REF         { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutImmutable\")); }\n+| REF MUT     { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutMutable\")); }\n+| MUT         { $$ = mk_node(\"BindByValue\", 1, mk_atom(\"MutMutable\")); }\n+;\n+\n+lit_or_path\n+: path_expr    { $$ = mk_node(\"PatLit\", 1, $1); }\n+| lit          { $$ = mk_node(\"PatLit\", 1, $1); }\n+| '-' lit      { $$ = mk_node(\"PatLit\", 1, $2); }\n+;\n+\n+pat_field\n+:                  ident        { $$ = mk_node(\"PatField\", 1, $1); }\n+|     binding_mode ident        { $$ = mk_node(\"PatField\", 2, $1, $2); }\n+| BOX              ident        { $$ = mk_node(\"PatField\", 2, mk_atom(\"box\"), $2); }\n+| BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n+|              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n+| binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n+;\n+\n+pat_fields\n+: pat_field                  { $$ = mk_node(\"PatFields\", 1, $1); }\n+| pat_fields ',' pat_field   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+pat_struct\n+: pat_fields                 { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n+| pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n+| pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n+| DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n+;\n+\n+pat_tup\n+: pat               { $$ = mk_node(\"pat_tup\", 1, $1); }\n+| pat_tup ',' pat   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+pat_vec\n+: pat_vec_elts                                  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts                             ','  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts     DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts ',' DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts     DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n+| pat_vec_elts     DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n+| pat_vec_elts ',' DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n+| pat_vec_elts ',' DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n+|                  DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n+|                  DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n+|                  DOTDOT                       { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n+| %empty                                        { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n+;\n+\n+pat_vec_elts\n+: pat                    { $$ = mk_node(\"PatVecElts\", 1, $1); }\n+| pat_vec_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 3: Types\n+////////////////////////////////////////////////////////////////////////\n+\n+ty\n+: ty_prim\n+| ty_closure\n+| '<' ty_sum AS trait_ref '>' MOD_SEP ident                                { $$ = mk_node(\"TyQualifiedPath\", 3, $2, $4, $7); }\n+| SHL ty_sum AS trait_ref '>' MOD_SEP ident AS trait_ref '>' MOD_SEP ident { $$ = mk_node(\"TyQualifiedPath\", 3, mk_node(\"TyQualifiedPath\", 3, $2, $4, $7), $9, $12); }\n+| '(' ty_sums ')'                                                          { $$ = mk_node(\"TyTup\", 1, $2); }\n+| '(' ty_sums ',' ')'                                                      { $$ = mk_node(\"TyTup\", 1, $2); }\n+| '(' ')'                                                                  { $$ = mk_atom(\"TyNil\"); }\n+;\n+\n+ty_prim\n+: %prec IDENT path_generic_args_without_colons              { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons      { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n+| %prec IDENT SELF MOD_SEP path_generic_args_without_colons { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n+| BOX ty                                                    { $$ = mk_node(\"TyBox\", 1, $2); }\n+| '*' maybe_mut_or_const ty                                 { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n+| '&' ty                                                    { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n+| '&' MUT ty                                                { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n+| ANDAND ty                                                 { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n+| ANDAND MUT ty                                             { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n+| '&' lifetime maybe_mut ty                                 { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n+| ANDAND lifetime maybe_mut ty                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n+| '[' ty ']'                                                { $$ = mk_node(\"TyVec\", 1, $2); }\n+| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n+| '[' ty ';' expr ']'                                       { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n+| TYPEOF '(' expr ')'                                       { $$ = mk_node(\"TyTypeof\", 1, $3); }\n+| UNDERSCORE                                                { $$ = mk_atom(\"TyInfer\"); }\n+| ty_bare_fn\n+| ty_proc\n+| for_in_type\n+;\n+\n+ty_bare_fn\n+:                         FN ty_fn_decl { $$ = $2; }\n+| UNSAFE                  FN ty_fn_decl { $$ = $3; }\n+|        EXTERN maybe_abi FN ty_fn_decl { $$ = $4; }\n+| UNSAFE EXTERN maybe_abi FN ty_fn_decl { $$ = $5; }\n+;\n+\n+ty_fn_decl\n+: generic_params fn_anon_params ret_ty { $$ = mk_node(\"TyFnDecl\", 3, $1, $2, $3); }\n+;\n+\n+ty_closure\n+: UNSAFE '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $3, $5, $6); }\n+|        '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $2, $4, $5); }\n+| UNSAFE OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $3, $4); }\n+|        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n+;\n+\n+ty_proc\n+: PROC generic_params fn_params maybe_bounds ret_ty { $$ = mk_node(\"TyProc\", 4, $2, $3, $4, $5); }\n+;\n+\n+for_in_type\n+: FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n+;\n+\n+for_in_type_suffix\n+: ty_proc\n+| ty_bare_fn\n+| trait_ref\n+| ty_closure\n+;\n+\n+maybe_mut\n+: MUT              { $$ = mk_atom(\"MutMutable\"); }\n+| %prec MUT %empty { $$ = mk_atom(\"MutImmutable\"); }\n+;\n+\n+maybe_mut_or_const\n+: MUT    { $$ = mk_atom(\"MutMutable\"); }\n+| CONST  { $$ = mk_atom(\"MutImmutable\"); }\n+| %empty { $$ = mk_atom(\"MutImmutable\"); }\n+;\n+\n+ty_qualified_path_and_generic_values\n+: ty_qualified_path maybe_bindings\n+{\n+  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 1, mk_node(\"TySum\", 1, $1)), $2);\n+}\n+| ty_qualified_path ',' ty_sums maybe_bindings\n+{\n+  $$ = mk_node(\"GenericValues\", 3, mk_none(), ext_node(mk_node(\"TySums\", 1, $1), 1, $3), $4); }\n+;\n+\n+ty_qualified_path\n+: ty_sum AS trait_ref '>' MOD_SEP ident                     { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n+| ty_sum AS trait_ref '>' MOD_SEP ident '+' ty_param_bounds { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n+;\n+\n+maybe_ty_sums\n+: ty_sums\n+| ty_sums ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+ty_sums\n+: ty_sum             { $$ = mk_node(\"TySums\", 1, $1); }\n+| ty_sums ',' ty_sum { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_sum\n+: ty                     { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+;\n+\n+ty_prim_sum\n+: ty_prim                     { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_prim '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+;\n+\n+maybe_ty_param_bounds\n+: ':' ty_param_bounds { $$ = $2; }\n+| %empty              { $$ = mk_none(); }\n+;\n+\n+ty_param_bounds\n+: boundseq\n+| %empty { $$ = mk_none(); }\n+;\n+\n+boundseq\n+: polybound\n+| boundseq '+' polybound { $$ = ext_node($1, 1, $3); }\n+;\n+\n+polybound\n+: FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n+| bound\n+| '?' bound { $$ = $2; }\n+;\n+\n+bindings\n+: binding              { $$ = mk_node(\"Bindings\", 1, $1); }\n+| bindings ',' binding { $$ = ext_node($1, 1, $3); }\n+;\n+\n+binding\n+: ident '=' ty { mk_node(\"Binding\", 2, $1, $3); }\n+;\n+\n+ty_param\n+: ident maybe_ty_param_bounds maybe_ty_default           { $$ = mk_node(\"TyParam\", 3, $1, $2, $3); }\n+| ident '?' ident maybe_ty_param_bounds maybe_ty_default { $$ = mk_node(\"TyParam\", 4, $1, $3, $4, $5); }\n+;\n+\n+maybe_bounds\n+: %prec SHIFTPLUS\n+  ':' bounds             { $$ = $2; }\n+| %prec SHIFTPLUS %empty { $$ = mk_none(); }\n+;\n+\n+bounds\n+: bound            { $$ = mk_node(\"bounds\", 1, $1); }\n+| bounds '+' bound { $$ = ext_node($1, 1, $3); }\n+;\n+\n+bound\n+: lifetime\n+| trait_ref\n+;\n+\n+maybe_ltbounds\n+: %prec SHIFTPLUS\n+  ':' ltbounds       { $$ = $2; }\n+| %empty             { $$ = mk_none(); }\n+;\n+\n+ltbounds\n+: lifetime              { $$ = mk_node(\"ltbounds\", 1, $1); }\n+| ltbounds '+' lifetime { $$ = ext_node($1, 1, $3); }\n+;\n+\n+maybe_ty_default\n+: '=' ty_sum { $$ = mk_node(\"TyDefault\", 1, $2); }\n+| %empty     { $$ = mk_none(); }\n+;\n+\n+maybe_lifetimes\n+: lifetimes\n+| lifetimes ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+lifetimes\n+: lifetime_and_bounds               { $$ = mk_node(\"Lifetimes\", 1, $1); }\n+| lifetimes ',' lifetime_and_bounds { $$ = ext_node($1, 1, $3); }\n+;\n+\n+lifetime_and_bounds\n+: LIFETIME maybe_ltbounds         { $$ = mk_node(\"lifetime\", 2, mk_atom(yytext), $2); }\n+| STATIC_LIFETIME                 { $$ = mk_atom(\"static_lifetime\"); }\n+;\n+\n+lifetime\n+: LIFETIME         { $$ = mk_node(\"lifetime\", 1, mk_atom(yytext)); }\n+| STATIC_LIFETIME  { $$ = mk_atom(\"static_lifetime\"); }\n+;\n+\n+trait_ref\n+: %prec IDENT path_generic_args_without_colons\n+| %prec IDENT MOD_SEP path_generic_args_without_colons { $$ = $2; }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 4: Blocks, statements, and expressions\n+////////////////////////////////////////////////////////////////////////\n+\n+inner_attrs_and_block\n+: '{' maybe_inner_attrs maybe_stmts '}'        { $$ = mk_node(\"ExprBlock\", 2, $2, $3); }\n+;\n+\n+block\n+: '{' maybe_stmts '}'                          { $$ = mk_node(\"ExprBlock\", 1, $2); }\n+;\n+\n+maybe_stmts\n+: stmts\n+| stmts nonblock_expr { $$ = ext_node($1, 1, $2); }\n+| nonblock_expr\n+| %empty              { $$ = mk_none(); }\n+;\n+\n+// There are two sub-grammars within a \"stmts: exprs\" derivation\n+// depending on whether each stmt-expr is a block-expr form; this is to\n+// handle the \"semicolon rule\" for stmt sequencing that permits\n+// writing\n+//\n+//     if foo { bar } 10\n+//\n+// as a sequence of two stmts (one if-expr stmt, one lit-10-expr\n+// stmt). Unfortunately by permitting juxtaposition of exprs in\n+// sequence like that, the non-block expr grammar has to have a\n+// second limited sub-grammar that excludes the prefix exprs that\n+// are ambiguous with binops. That is to say:\n+//\n+//     {10} - 1\n+//\n+// should parse as (progn (progn 10) (- 1)) not (- (progn 10) 1), that\n+// is to say, two statements rather than one, at least according to\n+// the mainline rust parser.\n+//\n+// So we wind up with a 3-way split in exprs that occur in stmt lists:\n+// block, nonblock-prefix, and nonblock-nonprefix.\n+//\n+// In non-stmts contexts, expr can relax this trichotomy.\n+//\n+// There are also two other expr subtypes: first, nonparen_expr\n+// disallows exprs surrounded by parens (including tuple expressions),\n+// this is neccesary for BOX (place) expressions, so a parens expr\n+// following the BOX is always parsed as the place. There is also\n+// expr_norange used in index_expr, which disallows '..' in\n+// expressions as that has special meaning inside of brackets.\n+\n+stmts\n+: stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n+| stmts stmt     { $$ = ext_node($1, 1, $2); }\n+;\n+\n+stmt\n+: let\n+|                 stmt_item\n+|             PUB stmt_item { $$ = $2; }\n+| outer_attrs     stmt_item { $$ = $2; }\n+| outer_attrs PUB stmt_item { $$ = $3; }\n+| full_block_expr\n+| block\n+| nonblock_expr ';'\n+| ';'                   { $$ = mk_none(); }\n+;\n+\n+maybe_exprs\n+: exprs\n+| exprs ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_expr\n+: expr\n+| %empty { $$ = mk_none(); }\n+;\n+\n+exprs\n+: expr                                                        { $$ = mk_node(\"exprs\", 1, $1); }\n+| exprs ',' expr                                              { $$ = ext_node($1, 1, $3); }\n+;\n+\n+path_expr\n+: path_generic_args_with_colons\n+| MOD_SEP path_generic_args_with_colons      { $$ = $2; }\n+| SELF MOD_SEP path_generic_args_with_colons { $$ = mk_node(\"SelfPath\", 1, $3); }\n+;\n+\n+// A path with a lifetime and type parameters with double colons before\n+// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n+//\n+// These show up in expr context, in order to disambiguate from \"less-than\"\n+// expressions.\n+path_generic_args_with_colons\n+: ident                                              { $$ = mk_node(\"components\", 1, $1); }\n+| path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n+| path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// the braces-delimited macro is a block_expr so it doesn't appear here\n+macro_expr\n+: path_expr '!' maybe_ident parens_delimited_token_trees   { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n+| path_expr '!' maybe_ident brackets_delimited_token_trees { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n+;\n+\n+nonblock_expr\n+: lit                                                           { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                                     { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| nonblock_expr '[' index_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| nonblock_expr '(' maybe_exprs ')'                             { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '[' vec_expr ']'                                              { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| '(' maybe_exprs ')'                                           { $$ = mk_node(\"ExprParen\", 1, $2); }\n+| CONTINUE                                                      { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE lifetime                                             { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                                        { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| nonblock_expr MINUSEQ expr                                    { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| nonblock_expr ANDEQ expr                                      { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| nonblock_expr OREQ expr                                       { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| nonblock_expr PLUSEQ expr                                     { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| nonblock_expr STAREQ expr                                     { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| nonblock_expr SLASHEQ expr                                    { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| nonblock_expr CARETEQ expr                                    { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| nonblock_expr PERCENTEQ expr                                  { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| nonblock_expr OROR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| nonblock_expr ANDAND expr                                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| nonblock_expr EQEQ expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| nonblock_expr NE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| nonblock_expr '<' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| nonblock_expr '>' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| nonblock_expr LE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| nonblock_expr GE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| nonblock_expr '|' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| nonblock_expr '^' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| nonblock_expr '&' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| nonblock_expr SHL expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| nonblock_expr SHR expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| nonblock_expr '+' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| nonblock_expr '-' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| nonblock_expr '*' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| nonblock_expr '/' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| nonblock_expr '%' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| nonblock_expr DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| nonblock_expr DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+| nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                             { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' nonblock_expr           { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| nonblock_prefix_expr\n+;\n+\n+expr\n+: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| expr '[' index_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| expr '(' maybe_exprs ')'                            { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n+| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| expr MINUSEQ expr                                   { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| expr ANDEQ expr                                     { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| expr OREQ expr                                      { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| expr PLUSEQ expr                                    { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| expr STAREQ expr                                    { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| expr SLASHEQ expr                                   { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| expr CARETEQ expr                                   { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| expr PERCENTEQ expr                                 { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| expr OROR expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| expr ANDAND expr                                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| expr EQEQ expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| expr NE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| expr '<' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| expr '>' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| expr LE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| expr GE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| expr '|' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| expr '^' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| expr '&' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| expr SHL expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| expr SHR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| expr '+' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| expr '-' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| expr '*' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| expr '/' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| expr '%' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| expr DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| expr DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+| expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| block_expr\n+| block\n+| nonblock_prefix_expr\n+;\n+\n+nonparen_expr\n+: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| nonparen_expr '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| nonparen_expr '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| nonparen_expr '[' index_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| nonparen_expr '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| nonparen_expr '=' nonparen_expr                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| nonparen_expr SHLEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| nonparen_expr SHREQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| nonparen_expr MINUSEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| nonparen_expr ANDEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| nonparen_expr OREQ nonparen_expr                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| nonparen_expr PLUSEQ nonparen_expr                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| nonparen_expr STAREQ nonparen_expr                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| nonparen_expr SLASHEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| nonparen_expr CARETEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| nonparen_expr PERCENTEQ nonparen_expr               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| nonparen_expr OROR nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| nonparen_expr ANDAND nonparen_expr                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| nonparen_expr EQEQ nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| nonparen_expr NE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| nonparen_expr '<' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| nonparen_expr '>' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| nonparen_expr LE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| nonparen_expr GE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| nonparen_expr '|' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| nonparen_expr '^' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| nonparen_expr '&' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| nonparen_expr SHL nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| nonparen_expr SHR nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| nonparen_expr '+' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| nonparen_expr '-' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| nonparen_expr '*' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| nonparen_expr '/' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| nonparen_expr '%' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| nonparen_expr DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| nonparen_expr DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|               DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+| nonparen_expr AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| block_expr\n+| block\n+| nonblock_prefix_expr\n+;\n+\n+expr_norange\n+: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| expr_norange '.' path_generic_args_with_colons      { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| expr_norange '.' LIT_INTEGER                        { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| expr_norange '[' index_expr ']'                     { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| expr_norange '(' maybe_exprs ')'                    { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n+| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| expr_norange '=' expr_norange                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| expr_norange SHLEQ expr_norange                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| expr_norange SHREQ expr_norange                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| expr_norange MINUSEQ expr_norange                   { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| expr_norange ANDEQ expr_norange                     { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| expr_norange OREQ expr_norange                      { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| expr_norange PLUSEQ expr_norange                    { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| expr_norange STAREQ expr_norange                    { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| expr_norange SLASHEQ expr_norange                   { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| expr_norange CARETEQ expr_norange                   { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| expr_norange PERCENTEQ expr_norange                 { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| expr_norange OROR expr_norange                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| expr_norange ANDAND expr_norange                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| expr_norange EQEQ expr_norange                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| expr_norange NE expr_norange                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| expr_norange '<' expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| expr_norange '>' expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| expr_norange LE expr_norange                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| expr_norange GE expr_norange                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| expr_norange '|' expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| expr_norange '^' expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| expr_norange '&' expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| expr_norange SHL expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| expr_norange SHR expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| expr_norange '+' expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| expr_norange '-' expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| expr_norange '*' expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| expr_norange '/' expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| expr_norange '%' expr_norange                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| expr_norange AS ty                                  { $$ = mk_node(\"Expr_NorangeCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' expr_norange  { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| block_expr\n+| block\n+| nonblock_prefix_expr\n+;\n+\n+expr_nostruct\n+: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| expr_nostruct '[' index_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| expr_nostruct '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n+| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| expr_nostruct MINUSEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| expr_nostruct ANDEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| expr_nostruct OREQ expr_nostruct                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| expr_nostruct PLUSEQ expr_nostruct                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| expr_nostruct STAREQ expr_nostruct                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| expr_nostruct SLASHEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| expr_nostruct CARETEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| expr_nostruct PERCENTEQ expr_nostruct               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| expr_nostruct OROR expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| expr_nostruct ANDAND expr_nostruct                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| expr_nostruct EQEQ expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| expr_nostruct NE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| expr_nostruct '<' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| expr_nostruct '>' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| expr_nostruct LE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| expr_nostruct GE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| expr_nostruct '|' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| expr_nostruct '^' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| expr_nostruct '&' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| expr_nostruct SHL expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| expr_nostruct SHR expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| expr_nostruct '+' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| expr_nostruct '-' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| expr_nostruct '*' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| expr_nostruct '/' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| expr_nostruct '%' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| expr_nostruct DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| expr_nostruct DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+| expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' expr_nostruct { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| block_expr\n+| block\n+| nonblock_prefix_expr_nostruct\n+;\n+\n+nonblock_prefix_expr_nostruct\n+: '-' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n+| '!' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n+| '*' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n+| '&' maybe_mut expr_nostruct               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n+| ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n+| lambda_expr_nostruct\n+| MOVE lambda_expr_nostruct                 { $$ = $2; }\n+| proc_expr_nostruct\n+;\n+\n+nonblock_prefix_expr\n+: '-' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n+| '!' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n+| '*' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n+| '&' maybe_mut expr               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n+| ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n+| lambda_expr\n+| MOVE lambda_expr                 { $$ = $2; }\n+| proc_expr\n+;\n+\n+lambda_expr\n+: %prec LAMBDA\n+  OROR ret_ty expr                                        { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n+| %prec LAMBDA\n+  '|' maybe_unboxed_closure_kind '|' ret_ty expr          { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $4, $5); }\n+| %prec LAMBDA\n+  '|' inferrable_params '|' ret_ty expr                   { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n+| %prec LAMBDA\n+  '|' '&' maybe_mut ':' inferrable_params '|' ret_ty expr { $$ = mk_node(\"ExprFnBlock\", 3, $5, $7, $8); }\n+| %prec LAMBDA\n+  '|' ':' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $3, $5, $6); }\n+;\n+\n+lambda_expr_nostruct\n+: %prec LAMBDA\n+  OROR expr_nostruct                                        { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n+| %prec LAMBDA\n+  '|' maybe_unboxed_closure_kind '|'  expr_nostruct         { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $4); }\n+| %prec LAMBDA\n+  '|' inferrable_params '|' expr_nostruct                   { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+| %prec LAMBDA\n+  '|' '&' maybe_mut ':' inferrable_params '|' expr_nostruct { $$ = mk_node(\"ExprFnBlock\", 2, $5, $7); }\n+| %prec LAMBDA\n+  '|' ':' inferrable_params '|' expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 2, $3, $5); }\n+\n+;\n+\n+proc_expr\n+: %prec LAMBDA\n+  PROC '(' ')' expr                         { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+| %prec LAMBDA\n+  PROC '(' inferrable_params ')' expr       { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+;\n+\n+proc_expr_nostruct\n+: %prec LAMBDA\n+  PROC '(' ')' expr_nostruct                     { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+| %prec LAMBDA\n+  PROC '(' inferrable_params ')' expr_nostruct   { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+;\n+\n+vec_expr\n+: maybe_exprs\n+| exprs ';' expr { $$ = mk_node(\"VecRepeat\", 2, $1, $3); }\n+;\n+\n+index_expr\n+: expr_norange                     { $$ = mk_node(\"Index\", 1, $1); }\n+| expr_norange DOTDOT              { $$ = mk_node(\"SliceToEnd\", 1, $1); }\n+|              DOTDOT expr_norange { $$ = mk_node(\"SliceFromBeginning\", 1, $2); }\n+| expr_norange DOTDOT expr_norange { $$ = mk_node(\"Slice\", 2, $1, $3); }\n+| %empty                           { $$ = mk_none(); }\n+;\n+\n+struct_expr_fields\n+: field_inits\n+| field_inits ','\n+| maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n+;\n+\n+maybe_field_inits\n+: field_inits\n+| field_inits ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+field_inits\n+: field_init                 { $$ = mk_node(\"FieldInits\", 1, $1); }\n+| field_inits ',' field_init { $$ = ext_node($1, 1, $3); }\n+;\n+\n+field_init\n+: ident ':' expr   { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+;\n+\n+default_field_init\n+: DOTDOT expr   { $$ = mk_node(\"DefaultFieldInit\", 1, $2); }\n+;\n+\n+block_expr\n+: expr_match\n+| expr_if\n+| expr_if_let\n+| expr_while\n+| expr_while_let\n+| expr_loop\n+| expr_for\n+| UNSAFE block                                           { $$ = mk_node(\"UnsafeBlock\", 1, $2); }\n+| path_expr '!' maybe_ident braces_delimited_token_trees { $$ = mk_node(\"Macro\", 3, $1, $3, $4); }\n+;\n+\n+full_block_expr\n+: block_expr\n+| full_block_expr '.' path_generic_args_with_colons { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| full_block_expr '.' LIT_INTEGER                   { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+;\n+\n+expr_match\n+: MATCH expr_nostruct '{' '}'                                     { $$ = mk_node(\"ExprMatch\", 1, $2); }\n+| MATCH expr_nostruct '{' match_clauses                       '}' { $$ = mk_node(\"ExprMatch\", 2, $2, $4); }\n+| MATCH expr_nostruct '{' match_clauses nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, ext_node($4, 1, $5)); }\n+| MATCH expr_nostruct '{'               nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, mk_node(\"Arms\", 1, $4)); }\n+;\n+\n+match_clauses\n+: match_clause               { $$ = mk_node(\"Arms\", 1, $1); }\n+| match_clauses match_clause { $$ = ext_node($1, 1, $2); }\n+;\n+\n+match_clause\n+: nonblock_match_clause ','\n+| block_match_clause\n+| block_match_clause ','\n+;\n+\n+nonblock_match_clause\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr   { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW full_block_expr { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+;\n+\n+block_match_clause\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+;\n+\n+maybe_guard\n+: IF expr_nostruct           { $$ = $2; }\n+| %empty                     { $$ = mk_none(); }\n+;\n+\n+expr_if\n+: IF expr_nostruct block                              { $$ = mk_node(\"ExprIf\", 2, $2, $3); }\n+| IF expr_nostruct block ELSE block_or_if             { $$ = mk_node(\"ExprIf\", 3, $2, $3, $5); }\n+;\n+\n+expr_if_let\n+: IF LET pat '=' expr_nostruct block                  { $$ = mk_node(\"ExprIfLet\", 3, $3, $5, $6); }\n+| IF LET pat '=' expr_nostruct block ELSE block_or_if { $$ = mk_node(\"ExprIfLet\", 4, $3, $5, $6, $8); }\n+;\n+\n+block_or_if\n+: block\n+| expr_if\n+| expr_if_let\n+;\n+\n+expr_while\n+: maybe_label WHILE expr_nostruct block               { $$ = mk_node(\"ExprWhile\", 3, $1, $3, $4); }\n+;\n+\n+expr_while_let\n+: maybe_label WHILE LET pat '=' expr_nostruct block   { $$ = mk_node(\"ExprWhileLet\", 4, $1, $4, $6, $7); }\n+;\n+\n+expr_loop\n+: maybe_label LOOP block                              { $$ = mk_node(\"ExprLoop\", 2, $1, $3); }\n+;\n+\n+expr_for\n+: maybe_label FOR pat IN expr_nostruct block          { $$ = mk_node(\"ExprForLoop\", 4, $1, $3, $5, $6); }\n+;\n+\n+maybe_label\n+: lifetime ':'\n+| %empty { $$ = mk_none(); }\n+;\n+\n+let\n+: LET pat maybe_ty_ascription maybe_init_expr ';' { $$ = mk_node(\"DeclLocal\", 3, $2, $3, $4); }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 5: Macros and misc. rules\n+////////////////////////////////////////////////////////////////////////\n+\n+lit\n+: LIT_BYTE                   { $$ = mk_node(\"LitByte\", 1, mk_atom(yytext)); }\n+| LIT_CHAR                   { $$ = mk_node(\"LitChar\", 1, mk_atom(yytext)); }\n+| LIT_INTEGER                { $$ = mk_node(\"LitInteger\", 1, mk_atom(yytext)); }\n+| LIT_FLOAT                  { $$ = mk_node(\"LitFloat\", 1, mk_atom(yytext)); }\n+| TRUE                       { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n+| FALSE                      { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n+| str\n+;\n+\n+str\n+: LIT_STR                    { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"CookedStr\")); }\n+| LIT_STR_RAW                { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"RawStr\")); }\n+| LIT_BINARY                 { $$ = mk_node(\"LitBinary\", 1, mk_atom(yytext), mk_atom(\"BinaryStr\")); }\n+| LIT_BINARY_RAW             { $$ = mk_node(\"LitBinary\", 1, mk_atom(yytext), mk_atom(\"RawBinaryStr\")); }\n+;\n+\n+maybe_ident\n+: %empty { $$ = mk_none(); }\n+| ident\n+;\n+\n+ident\n+: IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+;\n+\n+unpaired_token\n+: SHL                        { $$ = mk_atom(yytext); }\n+| SHR                        { $$ = mk_atom(yytext); }\n+| LE                         { $$ = mk_atom(yytext); }\n+| EQEQ                       { $$ = mk_atom(yytext); }\n+| NE                         { $$ = mk_atom(yytext); }\n+| GE                         { $$ = mk_atom(yytext); }\n+| ANDAND                     { $$ = mk_atom(yytext); }\n+| OROR                       { $$ = mk_atom(yytext); }\n+| SHLEQ                      { $$ = mk_atom(yytext); }\n+| SHREQ                      { $$ = mk_atom(yytext); }\n+| MINUSEQ                    { $$ = mk_atom(yytext); }\n+| ANDEQ                      { $$ = mk_atom(yytext); }\n+| OREQ                       { $$ = mk_atom(yytext); }\n+| PLUSEQ                     { $$ = mk_atom(yytext); }\n+| STAREQ                     { $$ = mk_atom(yytext); }\n+| SLASHEQ                    { $$ = mk_atom(yytext); }\n+| CARETEQ                    { $$ = mk_atom(yytext); }\n+| PERCENTEQ                  { $$ = mk_atom(yytext); }\n+| DOTDOT                     { $$ = mk_atom(yytext); }\n+| DOTDOTDOT                  { $$ = mk_atom(yytext); }\n+| MOD_SEP                    { $$ = mk_atom(yytext); }\n+| RARROW                     { $$ = mk_atom(yytext); }\n+| FAT_ARROW                  { $$ = mk_atom(yytext); }\n+| LIT_BYTE                   { $$ = mk_atom(yytext); }\n+| LIT_CHAR                   { $$ = mk_atom(yytext); }\n+| LIT_INTEGER                { $$ = mk_atom(yytext); }\n+| LIT_FLOAT                  { $$ = mk_atom(yytext); }\n+| LIT_STR                    { $$ = mk_atom(yytext); }\n+| LIT_STR_RAW                { $$ = mk_atom(yytext); }\n+| LIT_BINARY                 { $$ = mk_atom(yytext); }\n+| LIT_BINARY_RAW             { $$ = mk_atom(yytext); }\n+| IDENT                      { $$ = mk_atom(yytext); }\n+| UNDERSCORE                 { $$ = mk_atom(yytext); }\n+| LIFETIME                   { $$ = mk_atom(yytext); }\n+| SELF                       { $$ = mk_atom(yytext); }\n+| STATIC                     { $$ = mk_atom(yytext); }\n+| AS                         { $$ = mk_atom(yytext); }\n+| BREAK                      { $$ = mk_atom(yytext); }\n+| CRATE                      { $$ = mk_atom(yytext); }\n+| ELSE                       { $$ = mk_atom(yytext); }\n+| ENUM                       { $$ = mk_atom(yytext); }\n+| EXTERN                     { $$ = mk_atom(yytext); }\n+| FALSE                      { $$ = mk_atom(yytext); }\n+| FN                         { $$ = mk_atom(yytext); }\n+| FOR                        { $$ = mk_atom(yytext); }\n+| IF                         { $$ = mk_atom(yytext); }\n+| IMPL                       { $$ = mk_atom(yytext); }\n+| IN                         { $$ = mk_atom(yytext); }\n+| LET                        { $$ = mk_atom(yytext); }\n+| LOOP                       { $$ = mk_atom(yytext); }\n+| MATCH                      { $$ = mk_atom(yytext); }\n+| MOD                        { $$ = mk_atom(yytext); }\n+| MOVE                       { $$ = mk_atom(yytext); }\n+| MUT                        { $$ = mk_atom(yytext); }\n+| PRIV                       { $$ = mk_atom(yytext); }\n+| PUB                        { $$ = mk_atom(yytext); }\n+| REF                        { $$ = mk_atom(yytext); }\n+| RETURN                     { $$ = mk_atom(yytext); }\n+| STRUCT                     { $$ = mk_atom(yytext); }\n+| TRUE                       { $$ = mk_atom(yytext); }\n+| TRAIT                      { $$ = mk_atom(yytext); }\n+| TYPE                       { $$ = mk_atom(yytext); }\n+| UNSAFE                     { $$ = mk_atom(yytext); }\n+| USE                        { $$ = mk_atom(yytext); }\n+| WHILE                      { $$ = mk_atom(yytext); }\n+| CONTINUE                   { $$ = mk_atom(yytext); }\n+| PROC                       { $$ = mk_atom(yytext); }\n+| BOX                        { $$ = mk_atom(yytext); }\n+| CONST                      { $$ = mk_atom(yytext); }\n+| WHERE                      { $$ = mk_atom(yytext); }\n+| TYPEOF                     { $$ = mk_atom(yytext); }\n+| INNER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n+| OUTER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n+| SHEBANG                    { $$ = mk_atom(yytext); }\n+| STATIC_LIFETIME            { $$ = mk_atom(yytext); }\n+| ';'                        { $$ = mk_atom(yytext); }\n+| ','                        { $$ = mk_atom(yytext); }\n+| '.'                        { $$ = mk_atom(yytext); }\n+| '@'                        { $$ = mk_atom(yytext); }\n+| '#'                        { $$ = mk_atom(yytext); }\n+| '~'                        { $$ = mk_atom(yytext); }\n+| ':'                        { $$ = mk_atom(yytext); }\n+| '$'                        { $$ = mk_atom(yytext); }\n+| '='                        { $$ = mk_atom(yytext); }\n+| '?'                        { $$ = mk_atom(yytext); }\n+| '!'                        { $$ = mk_atom(yytext); }\n+| '<'                        { $$ = mk_atom(yytext); }\n+| '>'                        { $$ = mk_atom(yytext); }\n+| '-'                        { $$ = mk_atom(yytext); }\n+| '&'                        { $$ = mk_atom(yytext); }\n+| '|'                        { $$ = mk_atom(yytext); }\n+| '+'                        { $$ = mk_atom(yytext); }\n+| '*'                        { $$ = mk_atom(yytext); }\n+| '/'                        { $$ = mk_atom(yytext); }\n+| '^'                        { $$ = mk_atom(yytext); }\n+| '%'                        { $$ = mk_atom(yytext); }\n+;\n+\n+token_trees\n+: %empty                     { $$ = mk_node(\"TokenTrees\", 0); }\n+| token_trees token_tree     { $$ = ext_node($1, 1, $2); }\n+;\n+\n+token_tree\n+: delimited_token_trees\n+| unpaired_token         { $$ = mk_node(\"TTTok\", 1, $1); }\n+;\n+\n+delimited_token_trees\n+: parens_delimited_token_trees\n+| braces_delimited_token_trees\n+| brackets_delimited_token_trees\n+;\n+\n+parens_delimited_token_trees\n+: '(' token_trees ')'\n+{\n+  $$ = mk_node(\"TTDelim\", 3,\n+               mk_node(\"TTTok\", 1, mk_atom(\"(\")),\n+               $2,\n+               mk_node(\"TTTok\", 1, mk_atom(\")\")));\n+}\n+;\n+\n+braces_delimited_token_trees\n+: '{' token_trees '}'\n+{\n+  $$ = mk_node(\"TTDelim\", 3,\n+               mk_node(\"TTTok\", 1, mk_atom(\"{\")),\n+               $2,\n+               mk_node(\"TTTok\", 1, mk_atom(\"}\")));\n+}\n+;\n+\n+brackets_delimited_token_trees\n+: '[' token_trees ']'\n+{\n+  $$ = mk_node(\"TTDelim\", 3,\n+               mk_node(\"TTTok\", 1, mk_atom(\"[\")),\n+               $2,\n+               mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n+}\n+;"}, {"sha": "38e57be288b240f3d2b4e780ac02a6f9aa3ef803", "filename": "src/grammar/testparser.py", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fgrammar%2Ftestparser.py", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fgrammar%2Ftestparser.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftestparser.py?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,65 @@\n+#!/usr/bin/env python\n+#\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+import sys\n+\n+import os\n+import subprocess\n+import argparse\n+\n+# usage: testparser.py [-h] [-p PARSER [PARSER ...]] -s SOURCE_DIR\n+\n+# Parsers should read from stdin and return exit status 0 for a\n+# successful parse, and nonzero for an unsuccessful parse\n+\n+parser = argparse.ArgumentParser()\n+parser.add_argument('-p', '--parser', nargs='+')\n+parser.add_argument('-s', '--source-dir', nargs=1, required=True)\n+args = parser.parse_args(sys.argv[1:])\n+\n+total = 0\n+ok = {}\n+bad = {}\n+for parser in args.parser:\n+    ok[parser] = 0\n+    bad[parser] = []\n+devnull = open(os.devnull, 'w')\n+print \"\\n\"\n+\n+for base, dirs, files in os.walk(args.source_dir[0]):\n+    for f in filter(lambda p: p.endswith('.rs'), files):\n+        p = os.path.join(base, f)\n+        compile_fail = 'compile-fail' in p\n+        ignore = any('ignore-test' in line or 'ignore-lexer-test' in line\n+                     for line in open(p).readlines())\n+        if compile_fail or ignore:\n+            continue\n+        total += 1\n+        for parser in args.parser:\n+            if subprocess.call(parser, stdin=open(p), stderr=subprocess.STDOUT, stdout=devnull) == 0:\n+                ok[parser] += 1\n+            else:\n+                bad[parser].append(p)\n+        parser_stats = ', '.join(['{}: {}'.format(parser, ok[parser]) for parser in args.parser])\n+        sys.stdout.write(\"\\033[K\\r total: {}, {}, scanned {}\"\n+                         .format(total, os.path.relpath(parser_stats), os.path.relpath(p)))\n+\n+devnull.close()\n+\n+print \"\\n\"\n+\n+for parser in args.parser:\n+    filename = os.path.basename(parser) + '.bad'\n+    print(\"writing {} files that failed to parse with {} to {}\".format(len(bad[parser]), parser, filename))\n+    with open(filename, \"w\") as f:\n+          for p in bad[parser]:\n+              f.write(p)\n+              f.write(\"\\n\")"}, {"sha": "4457e3f8b5aa513766e2b371dff11e1c59816d46", "filename": "src/grammar/tokens.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Token {\n+  SHL = 257, // Parser generators reserve 0-256 for char literals\n+  SHR,\n+  LE,\n+  EQEQ,\n+  NE,\n+  GE,\n+  ANDAND,\n+  OROR,\n+  SHLEQ,\n+  SHREQ,\n+  MINUSEQ,\n+  ANDEQ,\n+  OREQ,\n+  PLUSEQ,\n+  STAREQ,\n+  SLASHEQ,\n+  CARETEQ,\n+  PERCENTEQ,\n+  DOTDOT,\n+  DOTDOTDOT,\n+  MOD_SEP,\n+  RARROW,\n+  FAT_ARROW,\n+  LIT_BYTE,\n+  LIT_CHAR,\n+  LIT_INTEGER,\n+  LIT_FLOAT,\n+  LIT_STR,\n+  LIT_STR_RAW,\n+  LIT_BINARY,\n+  LIT_BINARY_RAW,\n+  IDENT,\n+  UNDERSCORE,\n+  LIFETIME,\n+\n+  // keywords\n+  SELF,\n+  STATIC,\n+  AS,\n+  BREAK,\n+  CRATE,\n+  ELSE,\n+  ENUM,\n+  EXTERN,\n+  FALSE,\n+  FN,\n+  FOR,\n+  IF,\n+  IMPL,\n+  IN,\n+  LET,\n+  LOOP,\n+  MATCH,\n+  MOD,\n+  MOVE,\n+  MUT,\n+  PRIV,\n+  PUB,\n+  REF,\n+  RETURN,\n+  STRUCT,\n+  TRUE,\n+  TRAIT,\n+  TYPE,\n+  UNSAFE,\n+  USE,\n+  WHILE,\n+  CONTINUE,\n+  PROC,\n+  BOX,\n+  CONST,\n+  WHERE,\n+  TYPEOF,\n+  INNER_DOC_COMMENT,\n+  OUTER_DOC_COMMENT,\n+\n+  SHEBANG,\n+  SHEBANG_LINE,\n+  STATIC_LIFETIME\n+};"}, {"sha": "cf2854be016e1da9b9c9d17fab2e136d0b299743", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -589,7 +589,7 @@ impl AtomicUsize {\n     /// ```\n     /// use std::sync::atomic::AtomicUsize;\n     ///\n-    /// let atomic_forty_two = AtomicUsize::new(42u);\n+    /// let atomic_forty_two = AtomicUsize::new(42);\n     /// ```\n     #[inline]\n     pub fn new(v: usize) -> AtomicUsize {\n@@ -765,7 +765,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     /// use std::sync::atomic::AtomicPtr;\n     ///\n-    /// let ptr = &mut 5i;\n+    /// let ptr = &mut 5;\n     /// let atomic_ptr  = AtomicPtr::new(ptr);\n     /// ```\n     #[inline]\n@@ -787,7 +787,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n-    /// let ptr = &mut 5i;\n+    /// let ptr = &mut 5;\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n     /// let value = some_ptr.load(Ordering::Relaxed);\n@@ -809,10 +809,10 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n-    /// let ptr = &mut 5i;\n+    /// let ptr = &mut 5;\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n-    /// let other_ptr = &mut 10i;\n+    /// let other_ptr = &mut 10;\n     ///\n     /// some_ptr.store(other_ptr, Ordering::Relaxed);\n     /// ```\n@@ -835,10 +835,10 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n-    /// let ptr = &mut 5i;\n+    /// let ptr = &mut 5;\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n-    /// let other_ptr = &mut 10i;\n+    /// let other_ptr = &mut 10;\n     ///\n     /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n     /// ```\n@@ -860,11 +860,11 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n-    /// let ptr = &mut 5i;\n+    /// let ptr = &mut 5;\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n-    /// let other_ptr   = &mut 10i;\n-    /// let another_ptr = &mut 10i;\n+    /// let other_ptr   = &mut 10;\n+    /// let another_ptr = &mut 10;\n     ///\n     /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n     /// ```"}, {"sha": "ddcc41938f28f201c943edcf124d8dce769b575d", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -67,10 +67,10 @@\n //!\n //! fn main() {\n //!     let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n-//!     shared_map.borrow_mut().insert(\"africa\", 92388i);\n-//!     shared_map.borrow_mut().insert(\"kyoto\", 11837i);\n-//!     shared_map.borrow_mut().insert(\"piccadilly\", 11826i);\n-//!     shared_map.borrow_mut().insert(\"marbles\", 38i);\n+//!     shared_map.borrow_mut().insert(\"africa\", 92388);\n+//!     shared_map.borrow_mut().insert(\"kyoto\", 11837);\n+//!     shared_map.borrow_mut().insert(\"piccadilly\", 11826);\n+//!     shared_map.borrow_mut().insert(\"marbles\", 38);\n //! }\n //! ```\n //!"}, {"sha": "22bfd47893c973700a20b7529a86af892cfd04c6", "filename": "src/libcore/char.rs", "status": "modified", "additions": 66, "deletions": 46, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -102,7 +102,7 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n             if num < 10 {\n                 Some(transmute(('0' as uint + num) as u32))\n             } else {\n-                Some(transmute(('a' as uint + num - 10u) as u32))\n+                Some(transmute(('a' as uint + num - 10) as u32))\n             }\n         }\n     } else {\n@@ -212,8 +212,8 @@ impl CharExt for char {\n         }\n         let val = match self {\n           '0' ... '9' => self as uint - ('0' as uint),\n-          'a' ... 'z' => self as uint + 10u - ('a' as uint),\n-          'A' ... 'Z' => self as uint + 10u - ('A' as uint),\n+          'a' ... 'z' => self as uint + 10 - ('a' as uint),\n+          'A' ... 'Z' => self as uint + 10 - ('A' as uint),\n           _ => return None,\n         };\n         if val < radix { Some(val) }\n@@ -245,10 +245,10 @@ impl CharExt for char {\n     fn len_utf8(self) -> uint {\n         let code = self as u32;\n         match () {\n-            _ if code < MAX_ONE_B   => 1u,\n-            _ if code < MAX_TWO_B   => 2u,\n-            _ if code < MAX_THREE_B => 3u,\n-            _  => 4u,\n+            _ if code < MAX_ONE_B   => 1,\n+            _ if code < MAX_TWO_B   => 2,\n+            _ if code < MAX_THREE_B => 3,\n+            _  => 4,\n         }\n     }\n \n@@ -263,50 +263,70 @@ impl CharExt for char {\n     #[unstable(feature = \"core\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> {\n-        // Marked #[inline] to allow llvm optimizing it away\n-        let code = self as u32;\n-        if code < MAX_ONE_B && dst.len() >= 1 {\n-            dst[0] = code as u8;\n-            Some(1)\n-        } else if code < MAX_TWO_B && dst.len() >= 2 {\n-            dst[0] = (code >> 6u & 0x1F_u32) as u8 | TAG_TWO_B;\n-            dst[1] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            Some(2)\n-        } else if code < MAX_THREE_B && dst.len() >= 3  {\n-            dst[0] = (code >> 12u & 0x0F_u32) as u8 | TAG_THREE_B;\n-            dst[1] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n-            dst[2] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            Some(3)\n-        } else if dst.len() >= 4 {\n-            dst[0] = (code >> 18u & 0x07_u32) as u8 | TAG_FOUR_B;\n-            dst[1] = (code >> 12u & 0x3F_u32) as u8 | TAG_CONT;\n-            dst[2] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n-            dst[3] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            Some(4)\n-        } else {\n-            None\n-        }\n+        encode_utf8_raw(self as u32, dst)\n     }\n \n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> {\n-        // Marked #[inline] to allow llvm optimizing it away\n-        let mut ch = self as u32;\n-        if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n-            // The BMP falls through (assuming non-surrogate, as it should)\n-            dst[0] = ch as u16;\n-            Some(1)\n-        } else if dst.len() >= 2 {\n-            // Supplementary planes break into surrogates.\n-            ch -= 0x1_0000_u32;\n-            dst[0] = 0xD800_u16 | ((ch >> 10) as u16);\n-            dst[1] = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            Some(2)\n-        } else {\n-            None\n-        }\n+        encode_utf16_raw(self as u32, dst)\n+    }\n+}\n+\n+/// Encodes a raw u32 value as UTF-8 into the provided byte buffer,\n+/// and then returns the number of bytes written.\n+///\n+/// If the buffer is not large enough, nothing will be written into it\n+/// and a `None` will be returned.\n+#[inline]\n+#[unstable(feature = \"core\")]\n+pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n+    // Marked #[inline] to allow llvm optimizing it away\n+    if code < MAX_ONE_B && dst.len() >= 1 {\n+        dst[0] = code as u8;\n+        Some(1)\n+    } else if code < MAX_TWO_B && dst.len() >= 2 {\n+        dst[0] = (code >> 6u & 0x1F_u32) as u8 | TAG_TWO_B;\n+        dst[1] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+        Some(2)\n+    } else if code < MAX_THREE_B && dst.len() >= 3  {\n+        dst[0] = (code >> 12u & 0x0F_u32) as u8 | TAG_THREE_B;\n+        dst[1] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n+        dst[2] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+        Some(3)\n+    } else if dst.len() >= 4 {\n+        dst[0] = (code >> 18u & 0x07_u32) as u8 | TAG_FOUR_B;\n+        dst[1] = (code >> 12u & 0x3F_u32) as u8 | TAG_CONT;\n+        dst[2] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n+        dst[3] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+        Some(4)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Encodes a raw u32 value as UTF-16 into the provided `u16` buffer,\n+/// and then returns the number of `u16`s written.\n+///\n+/// If the buffer is not large enough, nothing will be written into it\n+/// and a `None` will be returned.\n+#[inline]\n+#[unstable(feature = \"core\")]\n+pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<uint> {\n+    // Marked #[inline] to allow llvm optimizing it away\n+    if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n+        // The BMP falls through (assuming non-surrogate, as it should)\n+        dst[0] = ch as u16;\n+        Some(1)\n+    } else if dst.len() >= 2 {\n+        // Supplementary planes break into surrogates.\n+        ch -= 0x1_0000_u32;\n+        dst[0] = 0xD800_u16 | ((ch >> 10) as u16);\n+        dst[1] = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n+        Some(2)\n+    } else {\n+        None\n     }\n }\n \n@@ -345,7 +365,7 @@ impl Iterator for EscapeUnicode {\n                 Some('u')\n             }\n             EscapeUnicodeState::LeftBrace => {\n-                let mut n = 0u;\n+                let mut n = 0;\n                 while (self.c as u32) >> (4 * (n + 1)) != 0 {\n                     n += 1;\n                 }"}, {"sha": "2ecbd55fcb1d542c830ab1d351baa254b824eea3", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -110,13 +110,13 @@ pub trait Eq: PartialEq<Self> {\n pub enum Ordering {\n     /// An ordering where a compared value is less [than another].\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Less = -1i,\n+    Less = -1,\n     /// An ordering where a compared value is equal [to another].\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Equal = 0i,\n+    Equal = 0,\n     /// An ordering where a compared value is greater [than another].\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Greater = 1i,\n+    Greater = 1,\n }\n \n impl Ordering {\n@@ -132,12 +132,12 @@ impl Ordering {\n     /// assert_eq!(Equal.reverse(), Equal);\n     /// assert_eq!(Greater.reverse(), Less);\n     ///\n-    /// let mut data: &mut [_] = &mut [2u, 10, 5, 8];\n+    /// let mut data: &mut [_] = &mut [2, 10, 5, 8];\n     ///\n     /// // sort the array from largest to smallest.\n     /// data.sort_by(|a, b| a.cmp(b).reverse());\n     ///\n-    /// let b: &mut [_] = &mut [10u, 8, 5, 2];\n+    /// let b: &mut [_] = &mut [10, 8, 5, 2];\n     /// assert!(data == b);\n     /// ```\n     #[inline]\n@@ -174,9 +174,9 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// ```\n     /// use std::cmp::Ordering::{Less, Equal, Greater};\n     ///\n-    /// assert_eq!( 5u.cmp(&10), Less);     // because 5 < 10\n-    /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n-    /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5\n+    /// assert_eq!( 5.cmp(&10), Less);     // because 5 < 10\n+    /// assert_eq!(10.cmp(&5),  Greater);  // because 10 > 5\n+    /// assert_eq!( 5.cmp(&5),  Equal);    // because 5 == 5\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;"}, {"sha": "d79b613f589495c92ef4f360c6103386af567e65", "filename": "src/libcore/default.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -150,17 +150,17 @@ default_impl! { (), () }\n default_impl! { bool, false }\n default_impl! { char, '\\x00' }\n \n-default_impl! { uint, 0u }\n-default_impl! { u8,  0u8 }\n-default_impl! { u16, 0u16 }\n-default_impl! { u32, 0u32 }\n-default_impl! { u64, 0u64 }\n+default_impl! { uint, 0 }\n+default_impl! { u8, 0 }\n+default_impl! { u16, 0 }\n+default_impl! { u32, 0 }\n+default_impl! { u64, 0 }\n \n-default_impl! { int, 0i }\n-default_impl! { i8,  0i8 }\n-default_impl! { i16, 0i16 }\n-default_impl! { i32, 0i32 }\n-default_impl! { i64, 0i64 }\n+default_impl! { int, 0 }\n+default_impl! { i8, 0 }\n+default_impl! { i16, 0 }\n+default_impl! { i32, 0 }\n+default_impl! { i64, 0 }\n \n default_impl! { f32, 0.0f32 }\n default_impl! { f64, 0.0f64 }"}, {"sha": "50123499ebae47b240c7d7ece948c1cd0c6b98a4", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -53,7 +53,7 @@ pub enum SignFormat {\n     SignNeg\n }\n \n-static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n+static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11;\n \n /// Converts a number to its string representation as a byte vector.\n /// This is meant to be a common base implementation for all numeric string\n@@ -191,7 +191,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n         buf[end] = b'.';\n         end += 1;\n-        let mut dig = 0u;\n+        let mut dig = 0;\n \n         // calculate new digits while\n         // - there is no limit and there are digits left\n@@ -218,7 +218,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             // Decrease the deccumulator one fractional digit at a time\n             deccum = deccum.fract();\n-            dig += 1u;\n+            dig += 1;\n         }\n \n         // If digits are limited, and that limit has been reached,"}, {"sha": "577c277893c9c4546a5294d025692c3457eb118c", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -253,6 +253,8 @@ pub trait Show {\n /// should implement this.\n #[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is defined in your \\\n+                            crate, add `#[derive(Debug)]` or manually implement it\"]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n@@ -278,6 +280,8 @@ pub trait String {\n /// used. It corresponds to the default format, `{}`.\n #[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default formatter; try using \\\n+                            `:?` instead if you are using a format string\"]\n pub trait Display {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n@@ -582,8 +586,8 @@ impl<'a> Formatter<'a> {\n         };\n \n         let (pre_pad, post_pad) = match align {\n-            rt::AlignLeft => (0u, padding),\n-            rt::AlignRight | rt::AlignUnknown => (padding, 0u),\n+            rt::AlignLeft => (0, padding),\n+            rt::AlignRight | rt::AlignUnknown => (padding, 0),\n             rt::AlignCenter => (padding / 2, (padding + 1) / 2),\n         };\n \n@@ -873,7 +877,7 @@ macro_rules! tuple {\n             fn fmt(&self, f: &mut Formatter) -> Result {\n                 try!(write!(f, \"(\"));\n                 let ($(ref $name,)*) = *self;\n-                let mut n = 0i;\n+                let mut n = 0;\n                 $(\n                     if n > 0 {\n                         try!(write!(f, \", \"));"}, {"sha": "1222126b5e0cdef73c0a3bccc4ce5dff3630c90f", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -147,7 +147,7 @@ pub struct RadixFmt<T, R>(T, R);\n ///\n /// ```\n /// use std::fmt::radix;\n-/// assert_eq!(format!(\"{}\", radix(55i, 36)), \"1j\".to_string());\n+/// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_string());\n /// ```\n #[unstable(feature = \"core\",\n            reason = \"may be renamed or move to a different module\")]"}, {"sha": "bef196d48246040ebef25f1d7688ae907a58eff0", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -123,7 +123,7 @@ impl Writer for SipHasher {\n         let length = msg.len();\n         self.length += length;\n \n-        let mut needed = 0u;\n+        let mut needed = 0;\n \n         if self.ntail != 0 {\n             needed = 8 - self.ntail;"}, {"sha": "74d8a7ae1d6b56913cd10cf9afd36baa65d03fc7", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -33,7 +33,7 @@\n //! translated to the `loop` below.\n //!\n //! ```\n-//! let values = vec![1i, 2, 3];\n+//! let values = vec![1, 2, 3];\n //!\n //! // \"Syntactical sugar\" taking advantage of an iterator\n //! for &x in values.iter() {\n@@ -82,6 +82,8 @@ use usize;\n /// else.\n #[lang=\"iterator\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling `.iter()` or a similar \\\n+                            method\"]\n pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n@@ -616,7 +618,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().all(|x| *x > 0));\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n@@ -1147,7 +1149,7 @@ pub trait AdditiveIterator<A> {\n     /// ```\n     /// use std::iter::AdditiveIterator;\n     ///\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1i32, 2, 3, 4, 5];\n     /// let mut it = a.iter().map(|&x| x);\n     /// assert!(it.sum() == 15);\n     /// ```\n@@ -1190,7 +1192,7 @@ pub trait MultiplicativeIterator<A> {\n     /// use std::iter::{count, MultiplicativeIterator};\n     ///\n     /// fn factorial(n: usize) -> usize {\n-    ///     count(1u, 1).take_while(|&i| i <= n).product()\n+    ///     count(1, 1).take_while(|&i| i <= n).product()\n     /// }\n     /// assert!(factorial(0) == 1);\n     /// assert!(factorial(1) == 1);\n@@ -2537,7 +2539,7 @@ pub struct Range<A> {\n /// ```\n /// let array = [0, 1, 2, 3, 4];\n ///\n-/// for i in range(0, 5u) {\n+/// for i in range(0, 5) {\n ///     println!(\"{}\", i);\n ///     assert_eq!(i,  array[i]);\n /// }"}, {"sha": "943365d8454d4629ed65a6757aa17ef28817e961", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -48,7 +48,7 @@ macro_rules! panic {\n /// let x = true;\n /// assert!(x, \"x wasn't true!\");\n ///\n-/// let a = 3i; let b = 27i;\n+/// let a = 3; let b = 27;\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n@@ -74,8 +74,8 @@ macro_rules! assert {\n /// # Example\n ///\n /// ```\n-/// let a = 3i;\n-/// let b = 1i + 2i;\n+/// let a = 3;\n+/// let b = 1 + 2;\n /// assert_eq!(a, b);\n /// ```\n #[macro_export]\n@@ -141,8 +141,8 @@ macro_rules! debug_assert {\n /// # Example\n ///\n /// ```\n-/// let a = 3i;\n-/// let b = 1i + 2i;\n+/// let a = 3;\n+/// let b = 1 + 2;\n /// debug_assert_eq!(a, b);\n /// ```\n #[macro_export]"}, {"sha": "1fc3e34af5e31dafd1dc4e9cf903be7ef603947d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -27,17 +27,19 @@\n \n use clone::Clone;\n \n-/// Types able to be transferred across task boundaries.\n+/// Types able to be transferred across thread boundaries.\n #[unstable(feature = \"core\",\n            reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"send\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n pub unsafe trait Send: 'static {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n+#[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n pub trait Sized {\n     // Empty.\n }\n@@ -147,11 +149,11 @@ pub trait Copy {\n     // Empty.\n }\n \n-/// Types that can be safely shared between tasks when aliased.\n+/// Types that can be safely shared between threads when aliased.\n ///\n /// The precise definition is: a type `T` is `Sync` if `&T` is\n /// thread-safe. In other words, there is no possibility of data races\n-/// when passing `&T` references between tasks.\n+/// when passing `&T` references between threads.\n ///\n /// As one would expect, primitive types like `u8` and `f64` are all\n /// `Sync`, and so are simple aggregate types containing them (like\n@@ -195,6 +197,7 @@ pub trait Copy {\n #[unstable(feature = \"core\",\n            reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"sync\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n pub unsafe trait Sync {\n     // Empty\n }"}, {"sha": "0d26c8e79142ae728bf071fc216143a496387841", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -187,13 +187,13 @@ pub unsafe fn uninitialized<T>() -> T {\n /// ```\n /// use std::mem;\n ///\n-/// let x = &mut 5i;\n-/// let y = &mut 42i;\n+/// let x = &mut 5;\n+/// let y = &mut 42;\n ///\n /// mem::swap(x, y);\n ///\n-/// assert_eq!(42i, *x);\n-/// assert_eq!(5i, *y);\n+/// assert_eq!(42, *x);\n+/// assert_eq!(5, *y);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -277,7 +277,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// ```\n /// use std::cell::RefCell;\n ///\n-/// let x = RefCell::new(1i);\n+/// let x = RefCell::new(1);\n ///\n /// let mut mutable_borrow = x.borrow_mut();\n /// *mutable_borrow = 1;\n@@ -306,9 +306,9 @@ pub fn drop<T>(_x: T) { }\n /// ```\n /// use std::mem;\n ///\n-/// let one = unsafe { mem::transmute_copy(&1i) };\n+/// let one = unsafe { mem::transmute_copy(&1) };\n ///\n-/// assert_eq!(1u, one);\n+/// assert_eq!(1, one);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "83d070feb8a69303f7d2791cdcb2aebb649dc999", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -23,12 +23,12 @@ use num::FpCategory as Fp;\n use option::Option;\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const RADIX: uint = 2u;\n+pub const RADIX: uint = 2;\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const MANTISSA_DIGITS: uint = 24u;\n+pub const MANTISSA_DIGITS: uint = 24;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const DIGITS: uint = 6u;\n+pub const DIGITS: uint = 6;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f32 = 1.19209290e-07_f32;"}, {"sha": "ce011b3c2eeb6a40e2e33a462cad58da92dfdee6", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -27,11 +27,11 @@ use option::Option;\n // members of `Bounded` and `Float`.\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const RADIX: uint = 2u;\n+pub const RADIX: uint = 2;\n \n-pub const MANTISSA_DIGITS: uint = 53u;\n+pub const MANTISSA_DIGITS: uint = 53;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const DIGITS: uint = 15u;\n+pub const DIGITS: uint = 15;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f64 = 2.2204460492503131e-16_f64;"}, {"sha": "9e460492b64bd9789d37c666d902e111d093a6c7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -366,7 +366,7 @@ pub trait Int\n     /// ```rust\n     /// use std::num::Int;\n     ///\n-    /// assert_eq!(2i.pow(4), 16);\n+    /// assert_eq!(2.pow(4), 16);\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n@@ -1196,7 +1196,7 @@ impl_from_primitive! { f64, to_f64 }\n /// ```\n /// use std::num;\n ///\n-/// let twenty: f32 = num::cast(0x14i).unwrap();\n+/// let twenty: f32 = num::cast(0x14).unwrap();\n /// assert_eq!(twenty, 20f32);\n /// ```\n ///\n@@ -1607,8 +1607,8 @@ macro_rules! from_str_radix_float_impl {\n                 let exp = match exp_info {\n                     Some((c, offset)) => {\n                         let base = match c {\n-                            'E' | 'e' if radix == 10 => 10u as $T,\n-                            'P' | 'p' if radix == 16 => 2u as $T,\n+                            'E' | 'e' if radix == 10 => 10.0,\n+                            'P' | 'p' if radix == 16 => 2.0,\n                             _ => return None,\n                         };\n "}, {"sha": "c7266aa4f1a8b1d98f1548160475854501b1e378", "filename": "src/libcore/option.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -254,12 +254,12 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let mut x = Some(2u);\n+    /// let mut x = Some(2);\n     /// match x.as_mut() {\n     ///     Some(v) => *v = 42,\n     ///     None => {},\n     /// }\n-    /// assert_eq!(x, Some(42u));\n+    /// assert_eq!(x, Some(42));\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -385,9 +385,9 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let k = 10u;\n-    /// assert_eq!(Some(4u).unwrap_or_else(|| 2 * k), 4u);\n-    /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20u);\n+    /// let k = 10i32;\n+    /// assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n+    /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -428,10 +428,10 @@ impl<T> Option<T> {\n     ///\n     /// ```\n     /// let x = Some(\"foo\");\n-    /// assert_eq!(x.map_or(42u, |v| v.len()), 3u);\n+    /// assert_eq!(x.map_or(42, |v| v.len()), 3);\n     ///\n     /// let x: Option<&str> = None;\n-    /// assert_eq!(x.map_or(42u, |v| v.len()), 42u);\n+    /// assert_eq!(x.map_or(42, |v| v.len()), 42);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -447,13 +447,13 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let k = 21u;\n+    /// let k = 21;\n     ///\n     /// let x = Some(\"foo\");\n-    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3u);\n+    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);\n     ///\n     /// let x: Option<&str> = None;\n-    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42u);\n+    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -471,10 +471,10 @@ impl<T> Option<T> {\n     ///\n     /// ```\n     /// let x = Some(\"foo\");\n-    /// assert_eq!(x.ok_or(0i), Ok(\"foo\"));\n+    /// assert_eq!(x.ok_or(0), Ok(\"foo\"));\n     ///\n     /// let x: Option<&str> = None;\n-    /// assert_eq!(x.ok_or(0i), Err(0i));\n+    /// assert_eq!(x.ok_or(0), Err(0));\n     /// ```\n     #[inline]\n     #[unstable(feature = \"core\")]\n@@ -492,10 +492,10 @@ impl<T> Option<T> {\n     ///\n     /// ```\n     /// let x = Some(\"foo\");\n-    /// assert_eq!(x.ok_or_else(|| 0i), Ok(\"foo\"));\n+    /// assert_eq!(x.ok_or_else(|| 0), Ok(\"foo\"));\n     ///\n     /// let x: Option<&str> = None;\n-    /// assert_eq!(x.ok_or_else(|| 0i), Err(0i));\n+    /// assert_eq!(x.ok_or_else(|| 0), Err(0));\n     /// ```\n     #[inline]\n     #[unstable(feature = \"core\")]\n@@ -515,7 +515,7 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x = Some(4u);\n+    /// let x = Some(4);\n     /// assert_eq!(x.iter().next(), Some(&4));\n     ///\n     /// let x: Option<uint> = None;\n@@ -532,9 +532,9 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let mut x = Some(4u);\n+    /// let mut x = Some(4);\n     /// match x.iter_mut().next() {\n-    ///     Some(&mut ref mut v) => *v = 42u,\n+    ///     Some(&mut ref mut v) => *v = 42,\n     ///     None => {},\n     /// }\n     /// assert_eq!(x, Some(42));\n@@ -577,15 +577,15 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x = Some(2u);\n+    /// let x = Some(2);\n     /// let y: Option<&str> = None;\n     /// assert_eq!(x.and(y), None);\n     ///\n     /// let x: Option<uint> = None;\n     /// let y = Some(\"foo\");\n     /// assert_eq!(x.and(y), None);\n     ///\n-    /// let x = Some(2u);\n+    /// let x = Some(2);\n     /// let y = Some(\"foo\");\n     /// assert_eq!(x.and(y), Some(\"foo\"));\n     ///\n@@ -630,17 +630,17 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x = Some(2u);\n+    /// let x = Some(2);\n     /// let y = None;\n-    /// assert_eq!(x.or(y), Some(2u));\n+    /// assert_eq!(x.or(y), Some(2));\n     ///\n     /// let x = None;\n-    /// let y = Some(100u);\n-    /// assert_eq!(x.or(y), Some(100u));\n+    /// let y = Some(100);\n+    /// assert_eq!(x.or(y), Some(100));\n     ///\n-    /// let x = Some(2u);\n-    /// let y = Some(100u);\n-    /// assert_eq!(x.or(y), Some(2u));\n+    /// let x = Some(2);\n+    /// let y = Some(100);\n+    /// assert_eq!(x.or(y), Some(2));\n     ///\n     /// let x: Option<uint> = None;\n     /// let y = None;\n@@ -686,7 +686,7 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let mut x = Some(2u);\n+    /// let mut x = Some(2);\n     /// x.take();\n     /// assert_eq!(x, None);\n     ///\n@@ -731,8 +731,8 @@ impl<T: Default> Option<T> {\n     /// let good_year = good_year_from_input.parse().unwrap_or_default();\n     /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n     ///\n-    /// assert_eq!(1909i, good_year);\n-    /// assert_eq!(0i, bad_year);\n+    /// assert_eq!(1909, good_year);\n+    /// assert_eq!(0, bad_year);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -898,12 +898,12 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// ```rust\n     /// use std::uint;\n     ///\n-    /// let v = vec!(1u, 2u);\n+    /// let v = vec!(1, 2);\n     /// let res: Option<Vec<uint>> = v.iter().map(|&x: &uint|\n     ///     if x == uint::MAX { None }\n     ///     else { Some(x + 1) }\n     /// ).collect();\n-    /// assert!(res == Some(vec!(2u, 3u)));\n+    /// assert!(res == Some(vec!(2, 3)));\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "bfbc96c5a399e6d43ce16cfef40ad77d1be6375b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -229,7 +229,7 @@\n use self::Result::{Ok, Err};\n \n use clone::Clone;\n-use fmt::Display;\n+use fmt::Debug;\n use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, ExactSizeIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n@@ -483,8 +483,8 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// fn stringify(x: uint) -> String { format!(\"error code: {}\", x) }\n     ///\n-    /// let x: Result<uint, uint> = Ok(2u);\n-    /// assert_eq!(x.map_err(stringify), Ok(2u));\n+    /// let x: Result<uint, uint> = Ok(2);\n+    /// assert_eq!(x.map_err(stringify), Ok(2));\n     ///\n     /// let x: Result<uint, uint> = Err(13);\n     /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n@@ -547,7 +547,7 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// let x: Result<uint, &str> = Ok(5);\n     /// let v: Vec<uint> = x.into_iter().collect();\n-    /// assert_eq!(v, vec![5u]);\n+    /// assert_eq!(v, vec![5]);\n     ///\n     /// let x: Result<uint, &str> = Err(\"nothing!\");\n     /// let v: Vec<uint> = x.into_iter().collect();\n@@ -677,9 +677,9 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let optb = 2u;\n-    /// let x: Result<uint, &str> = Ok(9u);\n-    /// assert_eq!(x.unwrap_or(optb), 9u);\n+    /// let optb = 2;\n+    /// let x: Result<uint, &str> = Ok(9);\n+    /// assert_eq!(x.unwrap_or(optb), 9);\n     ///\n     /// let x: Result<uint, &str> = Err(\"error\");\n     /// assert_eq!(x.unwrap_or(optb), optb);\n@@ -701,8 +701,8 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// fn count(x: &str) -> uint { x.len() }\n     ///\n-    /// assert_eq!(Ok(2u).unwrap_or_else(count), 2u);\n-    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3u);\n+    /// assert_eq!(Ok(2).unwrap_or_else(count), 2);\n+    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -715,7 +715,7 @@ impl<T, E> Result<T, E> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, E: Display> Result<T, E> {\n+impl<T, E: Debug> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n     /// # Panics\n@@ -726,8 +726,8 @@ impl<T, E: Display> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2u);\n-    /// assert_eq!(x.unwrap(), 2u);\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// assert_eq!(x.unwrap(), 2);\n     /// ```\n     ///\n     /// ```{.should_fail}\n@@ -740,13 +740,13 @@ impl<T, E: Display> Result<T, E> {\n         match self {\n             Ok(t) => t,\n             Err(e) =>\n-                panic!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n+                panic!(\"called `Result::unwrap()` on an `Err` value: {:?}\", e)\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Display, E> Result<T, E> {\n+impl<T: Debug, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n     /// # Panics\n@@ -757,7 +757,7 @@ impl<T: Display, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```{.should_fail}\n-    /// let x: Result<uint, &str> = Ok(2u);\n+    /// let x: Result<uint, &str> = Ok(2);\n     /// x.unwrap_err(); // panics with `2`\n     /// ```\n     ///\n@@ -770,7 +770,7 @@ impl<T: Display, E> Result<T, E> {\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n-                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n+                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {:?}\", t),\n             Err(e) => e\n         }\n     }\n@@ -898,12 +898,12 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// ```rust\n     /// use std::uint;\n     ///\n-    /// let v = vec!(1u, 2u);\n+    /// let v = vec!(1, 2);\n     /// let res: Result<Vec<uint>, &'static str> = v.iter().map(|&x: &uint|\n     ///     if x == uint::MAX { Err(\"Overflow!\") }\n     ///     else { Ok(x + 1) }\n     /// ).collect();\n-    /// assert!(res == Ok(vec!(2u, 3u)));\n+    /// assert!(res == Ok(vec!(2, 3)));\n     /// ```\n     #[inline]\n     fn from_iter<I: Iterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {"}, {"sha": "a113a34ef3569b1c814d25b48eb8d06db9253cf2", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -654,7 +654,7 @@ macro_rules! iterator {\n                             self.ptr = transmute(self.ptr as uint + 1);\n \n                             // Use a non-null pointer value\n-                            Some(transmute(1u))\n+                            Some(&mut *(1 as *mut _))\n                         } else {\n                             let old = self.ptr;\n                             self.ptr = self.ptr.offset(1);\n@@ -688,7 +688,7 @@ macro_rules! iterator {\n                             self.end = transmute(self.end as uint - 1);\n \n                             // Use a non-null pointer value\n-                            Some(transmute(1u))\n+                            Some(&mut *(1 as *mut _))\n                         } else {\n                             self.end = self.end.offset(-1);\n \n@@ -796,7 +796,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n             if index < self.indexable() {\n                 if mem::size_of::<T>() == 0 {\n                     // Use a non-null pointer value\n-                    Some(transmute(1u))\n+                    Some(&mut *(1 as *mut _))\n                 } else {\n                     Some(transmute(self.ptr.offset(index as int)))\n                 }\n@@ -1176,7 +1176,7 @@ impl<'a, T> Iterator for Windows<'a, T> {\n             (0, Some(0))\n         } else {\n             let x = self.v.len() - self.size;\n-            (x.saturating_add(1), x.checked_add(1u))\n+            (x.saturating_add(1), x.checked_add(1))\n         }\n     }\n }"}, {"sha": "5b94733ea6fd6d3ca5f4e31396c40380b9c2c27c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 72, "deletions": 54, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -202,9 +202,9 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n              reason = \"use std::ffi::c_str_to_bytes + str::from_utf8\")]\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n-    let mut len = 0u;\n+    let mut len = 0;\n     while *s.offset(len as int) != 0 {\n-        len += 1u;\n+        len += 1;\n     }\n     let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n     from_utf8(v).ok().expect(\"from_c_str passed invalid utf-8 data\")\n@@ -310,43 +310,52 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n     }\n }\n \n+/// Reads the next code point out of a byte iterator (assuming a\n+/// UTF-8-like encoding).\n+#[unstable(feature = \"core\")]\n+pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n+    // Decode UTF-8\n+    let x = match bytes.next() {\n+        None => return None,\n+        Some(&next_byte) if next_byte < 128 => return Some(next_byte as u32),\n+        Some(&next_byte) => next_byte,\n+    };\n+\n+    // Multibyte case follows\n+    // Decode from a byte combination out of: [[[x y] z] w]\n+    // NOTE: Performance is sensitive to the exact formulation here\n+    let init = utf8_first_byte!(x, 2);\n+    let y = unwrap_or_0(bytes.next());\n+    let mut ch = utf8_acc_cont_byte!(init, y);\n+    if x >= 0xE0 {\n+        // [[x y z] w] case\n+        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n+        let z = unwrap_or_0(bytes.next());\n+        let y_z = utf8_acc_cont_byte!((y & CONT_MASK) as u32, z);\n+        ch = init << 12 | y_z;\n+        if x >= 0xF0 {\n+            // [x y z w] case\n+            // use only the lower 3 bits of `init`\n+            let w = unwrap_or_0(bytes.next());\n+            ch = (init & 7) << 18 | utf8_acc_cont_byte!(y_z, w);\n+        }\n+    }\n+\n+    Some(ch)\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n \n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        // Decode UTF-8, using the valid UTF-8 invariant\n-        let x = match self.iter.next() {\n-            None => return None,\n-            Some(&next_byte) if next_byte < 128 => return Some(next_byte as char),\n-            Some(&next_byte) => next_byte,\n-        };\n-\n-        // Multibyte case follows\n-        // Decode from a byte combination out of: [[[x y] z] w]\n-        // NOTE: Performance is sensitive to the exact formulation here\n-        let init = utf8_first_byte!(x, 2);\n-        let y = unwrap_or_0(self.iter.next());\n-        let mut ch = utf8_acc_cont_byte!(init, y);\n-        if x >= 0xE0 {\n-            // [[x y z] w] case\n-            // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n-            let z = unwrap_or_0(self.iter.next());\n-            let y_z = utf8_acc_cont_byte!((y & CONT_MASK) as u32, z);\n-            ch = init << 12 | y_z;\n-            if x >= 0xF0 {\n-                // [x y z w] case\n-                // use only the lower 3 bits of `init`\n-                let w = unwrap_or_0(self.iter.next());\n-                ch = (init & 7) << 18 | utf8_acc_cont_byte!(y_z, w);\n+        next_code_point(&mut self.iter).map(|ch| {\n+            // str invariant says `ch` is a valid Unicode Scalar Value\n+            unsafe {\n+                mem::transmute(ch)\n             }\n-        }\n-\n-        // str invariant says `ch` is a valid Unicode Scalar Value\n-        unsafe {\n-            Some(mem::transmute(ch))\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -1509,7 +1518,7 @@ impl StrExt for str {\n             None => \"\",\n             Some(last) => {\n                 let next = self.char_range_at(last).next;\n-                unsafe { self.slice_unchecked(0u, next) }\n+                unsafe { self.slice_unchecked(0, next) }\n             }\n         }\n     }\n@@ -1525,25 +1534,8 @@ impl StrExt for str {\n \n     #[inline]\n     fn char_range_at(&self, i: uint) -> CharRange {\n-        if self.as_bytes()[i] < 128u8 {\n-            return CharRange {ch: self.as_bytes()[i] as char, next: i + 1 };\n-        }\n-\n-        // Multibyte case is a fn to allow char_range_at to inline cleanly\n-        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n-            let mut val = s.as_bytes()[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n-            assert!((w != 0));\n-\n-            val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 3]); }\n-\n-            return CharRange {ch: unsafe { mem::transmute(val) }, next: i + w};\n-        }\n-\n-        return multibyte_char_range_at(self, i);\n+        let (c, n) = char_range_at_raw(self.as_bytes(), i);\n+        CharRange { ch: unsafe { mem::transmute(c) }, next: n }\n     }\n \n     #[inline]\n@@ -1559,7 +1551,7 @@ impl StrExt for str {\n         fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n             // while there is a previous byte == 10......\n             while i > 0 && s.as_bytes()[i] & !CONT_MASK == TAG_CONT_U8 {\n-                i -= 1u;\n+                i -= 1;\n             }\n \n             let mut val = s.as_bytes()[i] as u32;\n@@ -1629,7 +1621,7 @@ impl StrExt for str {\n         if self.is_empty() {\n             None\n         } else {\n-            let CharRange {ch, next} = self.char_range_at(0u);\n+            let CharRange {ch, next} = self.char_range_at(0);\n             let next_s = unsafe { self.slice_unchecked(next, self.len()) };\n             Some((ch, next_s))\n         }\n@@ -1661,6 +1653,32 @@ impl StrExt for str {\n     fn parse<T: FromStr>(&self) -> Option<T> { FromStr::from_str(self) }\n }\n \n+/// Pluck a code point out of a UTF-8-like byte slice and return the\n+/// index of the next code point.\n+#[inline]\n+#[unstable(feature = \"core\")]\n+pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n+    if bytes[i] < 128u8 {\n+        return (bytes[i] as u32, i + 1);\n+    }\n+\n+    // Multibyte case is a fn to allow char_range_at to inline cleanly\n+    fn multibyte_char_range_at(bytes: &[u8], i: uint) -> (u32, usize) {\n+        let mut val = bytes[i] as u32;\n+        let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+        assert!((w != 0));\n+\n+        val = utf8_first_byte!(val, w);\n+        val = utf8_acc_cont_byte!(val, bytes[i + 1]);\n+        if w > 2 { val = utf8_acc_cont_byte!(val, bytes[i + 2]); }\n+        if w > 3 { val = utf8_acc_cont_byte!(val, bytes[i + 3]); }\n+\n+        return (val, i + w);\n+    }\n+\n+    multibyte_char_range_at(bytes, i)\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Default for &'a str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "421f39941891254fa2f8ccfc5c82ea8ffe59f870", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 198, "deletions": 8, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -32,10 +32,12 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::{def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n+use middle::cfg;\n use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n-use lint::{Context, LintPass, LintArray, Lint};\n+use lint::{Level, Context, LintPass, LintArray, Lint};\n \n+use std::collections::BitvSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::num::SignedInt;\n use std::{cmp, slice};\n@@ -44,7 +46,7 @@ use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::{abi, ast, ast_map};\n use syntax::ast_util::is_shift_binop;\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::Span;\n+use syntax::codemap::{self, Span};\n use syntax::parse::token;\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n use syntax::ast_util;\n@@ -185,7 +187,7 @@ impl LintPass for TypeLimits {\n                                  \"comparison is useless due to type limits\");\n                 }\n \n-                if is_shift_binop(binop) {\n+                if is_shift_binop(binop.node) {\n                     let opt_ty_bits = match ty::expr_ty(cx.tcx, &**l).sty {\n                         ty::ty_int(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::ty_uint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n@@ -272,7 +274,7 @@ impl LintPass for TypeLimits {\n \n         fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n                                 min: T, max: T) -> bool {\n-            match binop {\n+            match binop.node {\n                 ast::BiLt => v >  min && v <= max,\n                 ast::BiLe => v >= min && v <  max,\n                 ast::BiGt => v >= min && v <  max,\n@@ -283,13 +285,13 @@ impl LintPass for TypeLimits {\n         }\n \n         fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n-            match binop {\n+            codemap::respan(binop.span, match binop.node {\n                 ast::BiLt => ast::BiGt,\n                 ast::BiLe => ast::BiGe,\n                 ast::BiGt => ast::BiLt,\n                 ast::BiGe => ast::BiLe,\n-                _ => binop\n-            }\n+                _ => return binop\n+            })\n         }\n \n         // for int & uint, be conservative with the warnings, so that the\n@@ -382,7 +384,7 @@ impl LintPass for TypeLimits {\n         }\n \n         fn is_comparison(binop: ast::BinOp) -> bool {\n-            match binop {\n+            match binop.node {\n                 ast::BiEq | ast::BiLt | ast::BiLe |\n                 ast::BiNe | ast::BiGe | ast::BiGt => true,\n                 _ => false\n@@ -1674,6 +1676,194 @@ impl LintPass for Stability {\n     }\n }\n \n+declare_lint! {\n+    pub UNCONDITIONAL_RECURSION,\n+    Warn,\n+    \"functions that cannot return without calling themselves\"\n+}\n+\n+#[derive(Copy)]\n+pub struct UnconditionalRecursion;\n+\n+\n+impl LintPass for UnconditionalRecursion {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![UNCONDITIONAL_RECURSION]\n+    }\n+\n+    fn check_fn(&mut self, cx: &Context, fn_kind: visit::FnKind, _: &ast::FnDecl,\n+                blk: &ast::Block, sp: Span, id: ast::NodeId) {\n+        type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n+                              ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n+\n+        let (name, checker) = match fn_kind {\n+            visit::FkItemFn(name, _, _, _) => (name, id_refers_to_this_fn as F),\n+            visit::FkMethod(name, _, _) => (name, id_refers_to_this_method as F),\n+            // closures can't recur, so they don't matter.\n+            visit::FkFnBlock => return\n+        };\n+\n+        let impl_def_id = ty::impl_of_method(cx.tcx, ast_util::local_def(id))\n+            .unwrap_or(ast_util::local_def(ast::DUMMY_NODE_ID));\n+        assert!(ast_util::is_local(impl_def_id));\n+        let impl_node_id = impl_def_id.node;\n+\n+        // Walk through this function (say `f`) looking to see if\n+        // every possible path references itself, i.e. the function is\n+        // called recursively unconditionally. This is done by trying\n+        // to find a path from the entry node to the exit node that\n+        // *doesn't* call `f` by traversing from the entry while\n+        // pretending that calls of `f` are sinks (i.e. ignoring any\n+        // exit edges from them).\n+        //\n+        // NB. this has an edge case with non-returning statements,\n+        // like `loop {}` or `panic!()`: control flow never reaches\n+        // the exit node through these, so one can have a function\n+        // that never actually calls itselfs but is still picked up by\n+        // this lint:\n+        //\n+        //     fn f(cond: bool) {\n+        //         if !cond { panic!() } // could come from `assert!(cond)`\n+        //         f(false)\n+        //     }\n+        //\n+        // In general, functions of that form may be able to call\n+        // itself a finite number of times and then diverge. The lint\n+        // considers this to be an error for two reasons, (a) it is\n+        // easier to implement, and (b) it seems rare to actually want\n+        // to have behaviour like the above, rather than\n+        // e.g. accidentally recurring after an assert.\n+\n+        let cfg = cfg::CFG::new(cx.tcx, blk);\n+\n+        let mut work_queue = vec![cfg.entry];\n+        let mut reached_exit_without_self_call = false;\n+        let mut self_call_spans = vec![];\n+        let mut visited = BitvSet::new();\n+\n+        while let Some(idx) = work_queue.pop() {\n+            let cfg_id = idx.node_id();\n+            if idx == cfg.exit {\n+                // found a path!\n+                reached_exit_without_self_call = true;\n+                break\n+            } else if visited.contains(&cfg_id) {\n+                // already done\n+                continue\n+            }\n+            visited.insert(cfg_id);\n+            let node_id = cfg.graph.node_data(idx).id;\n+\n+            // is this a recursive call?\n+            if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {\n+\n+                self_call_spans.push(cx.tcx.map.span(node_id));\n+                // this is a self call, so we shouldn't explore past\n+                // this node in the CFG.\n+                continue\n+            }\n+            // add the successors of this node to explore the graph further.\n+            cfg.graph.each_outgoing_edge(idx, |_, edge| {\n+                let target_idx = edge.target();\n+                let target_cfg_id = target_idx.node_id();\n+                if !visited.contains(&target_cfg_id) {\n+                    work_queue.push(target_idx)\n+                }\n+                true\n+            });\n+        }\n+\n+        // check the number of sell calls because a function that\n+        // doesn't return (e.g. calls a `-> !` function or `loop { /*\n+        // no break */ }`) shouldn't be linted unless it actually\n+        // recurs.\n+        if !reached_exit_without_self_call && self_call_spans.len() > 0 {\n+            cx.span_lint(UNCONDITIONAL_RECURSION, sp,\n+                         \"function cannot return without recurring\");\n+\n+            // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n+            if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n+                let sess = cx.sess();\n+                // offer some help to the programmer.\n+                for call in self_call_spans.iter() {\n+                    sess.span_note(*call, \"recursive call site\")\n+                }\n+                sess.span_help(sp, \"a `loop` may express intention better if this is on purpose\")\n+            }\n+        }\n+\n+        // all done\n+        return;\n+\n+        // Functions for identifying if the given NodeId `id`\n+        // represents a call to the function `fn_id`/method\n+        // `method_id`.\n+\n+        fn id_refers_to_this_fn<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      _: ast::NodeId,\n+                                      fn_id: ast::NodeId,\n+                                      _: ast::Ident,\n+                                      id: ast::NodeId) -> bool {\n+            tcx.def_map.borrow().get(&id)\n+                .map_or(false, |def| {\n+                    let did = def.def_id();\n+                    ast_util::is_local(did) && did.node == fn_id\n+                })\n+        }\n+\n+        // check if the method call `id` refers to method `method_id`\n+        // (with name `method_name` contained in impl `impl_id`).\n+        fn id_refers_to_this_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          impl_id: ast::NodeId,\n+                                          method_id: ast::NodeId,\n+                                          method_name: ast::Ident,\n+                                          id: ast::NodeId) -> bool {\n+            let did = match tcx.method_map.borrow().get(&ty::MethodCall::expr(id)) {\n+                None => return false,\n+                Some(m) => match m.origin {\n+                    // There's no way to know if a method call via a\n+                    // vtable is recursion, so we assume it's not.\n+                    ty::MethodTraitObject(_) => return false,\n+\n+                    // This `did` refers directly to the method definition.\n+                    ty::MethodStatic(did) | ty::MethodStaticUnboxedClosure(did) => did,\n+\n+                    // MethodTypeParam are methods from traits:\n+\n+                    // The `impl ... for ...` of this method call\n+                    // isn't known, e.g. it might be a default method\n+                    // in a trait, so we get the def-id of the trait\n+                    // method instead.\n+                    ty::MethodTypeParam(\n+                        ty::MethodParam { ref trait_ref, method_num, impl_def_id: None, }) => {\n+                        ty::trait_item(tcx, trait_ref.def_id, method_num).def_id()\n+                    }\n+\n+                    // The `impl` is known, so we check that with a\n+                    // special case:\n+                    ty::MethodTypeParam(\n+                        ty::MethodParam { impl_def_id: Some(impl_def_id), .. }) => {\n+\n+                        let name = match tcx.map.expect_expr(id).node {\n+                            ast::ExprMethodCall(ref sp_ident, _, _) => sp_ident.node,\n+                            _ => tcx.sess.span_bug(\n+                                tcx.map.span(id),\n+                                \"non-method call expr behaving like a method call?\")\n+                        };\n+                        // it matches if it comes from the same impl,\n+                        // and has the same method name.\n+                        return ast_util::is_local(impl_def_id)\n+                            && impl_def_id.node == impl_id\n+                            && method_name.name == name.name\n+                    }\n+                }\n+            };\n+\n+            ast_util::is_local(did) && did.node == method_id\n+        }\n+    }\n+}\n+\n declare_lint! {\n     pub UNUSED_IMPORTS,\n     Warn,"}, {"sha": "1d3904e85122c0817ce82cb0e9131185abf396d8", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -212,6 +212,7 @@ impl LintStore {\n                      MissingCopyImplementations,\n                      UnstableFeatures,\n                      Stability,\n+                     UnconditionalRecursion,\n         );\n \n         add_builtin_with_new!(sess,"}, {"sha": "430b63f81c852e82eabbf9d6953902c64466da5e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -627,6 +627,7 @@ impl<'tcx> tr for MethodOrigin<'tcx> {\n                         // def-id is already translated when we read it out\n                         trait_ref: mp.trait_ref.clone(),\n                         method_num: mp.method_num,\n+                        impl_def_id: mp.impl_def_id.tr(dcx),\n                     }\n                 )\n             }\n@@ -879,6 +880,16 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                             try!(this.emit_struct_field(\"method_num\", 0, |this| {\n                                 this.emit_uint(p.method_num)\n                             }));\n+                            try!(this.emit_struct_field(\"impl_def_id\", 0, |this| {\n+                                this.emit_option(|this| {\n+                                    match p.impl_def_id {\n+                                        None => this.emit_option_none(),\n+                                        Some(did) => this.emit_option_some(|this| {\n+                                            Ok(this.emit_def_id(did))\n+                                        })\n+                                    }\n+                                })\n+                            }));\n                             Ok(())\n                         })\n                     })\n@@ -1452,6 +1463,17 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                         this.read_struct_field(\"method_num\", 1, |this| {\n                                             this.read_uint()\n                                         }).unwrap()\n+                                    },\n+                                    impl_def_id: {\n+                                        this.read_struct_field(\"impl_def_id\", 2, |this| {\n+                                            this.read_option(|this, b| {\n+                                                if b {\n+                                                    Ok(Some(this.read_def_id(dcx)))\n+                                                } else {\n+                                                    Ok(None)\n+                                                }\n+                                            })\n+                                        }).unwrap()\n                                     }\n                                 }))\n                         }).unwrap()"}, {"sha": "6162f61fde1c7f4b5ae43877c183bc7ab0ba4dd0", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -372,7 +372,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n+            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {\n                 //\n                 //     [pred]\n                 //       |"}, {"sha": "c2533c1a9c688bde51530240c2441904166860e6", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -400,7 +400,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n         match (eval_const_expr_partial(tcx, &**a),\n                eval_const_expr_partial(tcx, &**b)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {\n-            match op {\n+            match op.node {\n               ast::BiAdd => Ok(const_float(a + b)),\n               ast::BiSub => Ok(const_float(a - b)),\n               ast::BiMul => Ok(const_float(a * b)),\n@@ -416,7 +416,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n-            match op {\n+            match op.node {\n               ast::BiAdd => Ok(const_int(a + b)),\n               ast::BiSub => Ok(const_int(a - b)),\n               ast::BiMul => Ok(const_int(a * b)),\n@@ -443,7 +443,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_uint(b))) => {\n-            match op {\n+            match op.node {\n               ast::BiAdd => Ok(const_uint(a + b)),\n               ast::BiSub => Ok(const_uint(a - b)),\n               ast::BiMul => Ok(const_uint(a * b)),\n@@ -471,21 +471,21 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n           }\n           // shifts can have any integral type as their rhs\n           (Ok(const_int(a)), Ok(const_uint(b))) => {\n-            match op {\n+            match op.node {\n               ast::BiShl => Ok(const_int(a << b as uint)),\n               ast::BiShr => Ok(const_int(a >> b as uint)),\n               _ => Err(\"can't do this op on an int and uint\".to_string())\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n-            match op {\n+            match op.node {\n               ast::BiShl => Ok(const_uint(a << b as uint)),\n               ast::BiShr => Ok(const_uint(a >> b as uint)),\n               _ => Err(\"can't do this op on a uint and int\".to_string())\n             }\n           }\n           (Ok(const_bool(a)), Ok(const_bool(b))) => {\n-            Ok(const_bool(match op {\n+            Ok(const_bool(match op.node {\n               ast::BiAnd => a && b,\n               ast::BiOr => a || b,\n               ast::BiBitXor => a ^ b,"}, {"sha": "d9ab86deb3b7c4454fe2f27b916182d8ac80165d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -568,7 +568,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprBinary(op, ref lhs, ref rhs) => {\n-                let pass_args = if ast_util::is_by_value_binop(op) {\n+                let pass_args = if ast_util::is_by_value_binop(op.node) {\n                     PassArgs::ByValue\n                 } else {\n                     PassArgs::ByRef"}, {"sha": "c08af95f139963a34ee836f728838a45fe9afcd0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -504,7 +504,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n-      ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n+      ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op.node) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n@@ -1177,7 +1177,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(&exprs[], succ)\n           }\n \n-          ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n+          ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {\n             let r_succ = self.propagate_through_expr(&**r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);"}, {"sha": "67c0e52d6649a6da95e5abb27b5f8bd1e7f77418", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -22,7 +22,7 @@ use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n use util::common::can_reach;\n \n use std::cell::RefCell;\n-use syntax::codemap::Span;\n+use syntax::codemap::{self, Span};\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::{stmt_id};\n@@ -496,8 +496,8 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n \n-            ast::ExprBinary(ast::BiAnd, _, ref r) |\n-            ast::ExprBinary(ast::BiOr, _, ref r) => {\n+            ast::ExprBinary(codemap::Spanned { node: ast::BiAnd, .. }, _, ref r) |\n+            ast::ExprBinary(codemap::Spanned { node: ast::BiOr, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n                 terminating(r.id);"}, {"sha": "d04c2d2d1a09449dff84d436fcbbbeb1cfc2fbb4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -453,9 +453,14 @@ pub struct MethodParam<'tcx> {\n     // never contains bound regions; those regions should have been\n     // instantiated with fresh variables at this point.\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n-\n     // index of uint in the list of methods for the trait\n     pub method_num: uint,\n+\n+    /// The impl for the trait from which the method comes. This\n+    /// should only be used for certain linting/heuristic purposes\n+    /// since there is no guarantee that this is Some in every\n+    /// situation that it could/should be.\n+    pub impl_def_id: Option<ast::DefId>,\n }\n \n // details for a method invoked with a receiver whose type is an object\n@@ -5716,7 +5721,7 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n     static opcat_mod: int = 8;\n \n     fn opcat(op: ast::BinOp) -> int {\n-        match op {\n+        match op.node {\n           ast::BiAdd => opcat_add,\n           ast::BiSub => opcat_sub,\n           ast::BiMul => opcat_mult,"}, {"sha": "0b8c77860155a5854eaf8e82656530d64939e530", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -310,7 +310,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::MethodOrigin<'tcx> {\n             ty::MethodTypeParam(ref param) => {\n                 ty::MethodTypeParam(ty::MethodParam {\n                     trait_ref: param.trait_ref.fold_with(folder),\n-                    method_num: param.method_num\n+                    method_num: param.method_num,\n+                    impl_def_id: param.impl_def_id,\n                 })\n             }\n             ty::MethodTraitObject(ref object) => {"}, {"sha": "266048fce51c9ac6a90f326f3018c8be808d54f0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -544,7 +544,7 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Option<T> {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for P<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        (*self).repr(tcx)\n+        (**self).repr(tcx)\n     }\n }\n "}, {"sha": "65a7fbf60a5d8e395ab2addc58ea8f43de07e0c2", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -231,7 +231,7 @@ mod svh_visitor {\n         SawExprCall,\n         SawExprMethodCall,\n         SawExprTup,\n-        SawExprBinary(ast::BinOp),\n+        SawExprBinary(ast::BinOp_),\n         SawExprUnary(ast::UnOp),\n         SawExprLit(ast::Lit_),\n         SawExprCast,\n@@ -241,7 +241,7 @@ mod svh_visitor {\n         SawExprClosure,\n         SawExprBlock,\n         SawExprAssign,\n-        SawExprAssignOp(ast::BinOp),\n+        SawExprAssignOp(ast::BinOp_),\n         SawExprIndex,\n         SawExprRange,\n         SawExprPath,\n@@ -262,7 +262,7 @@ mod svh_visitor {\n             ExprCall(..)             => SawExprCall,\n             ExprMethodCall(..)       => SawExprMethodCall,\n             ExprTup(..)              => SawExprTup,\n-            ExprBinary(op, _, _)     => SawExprBinary(op),\n+            ExprBinary(op, _, _)     => SawExprBinary(op.node),\n             ExprUnary(op, _)         => SawExprUnary(op),\n             ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n             ExprCast(..)             => SawExprCast,\n@@ -273,7 +273,7 @@ mod svh_visitor {\n             ExprClosure(..)          => SawExprClosure,\n             ExprBlock(..)            => SawExprBlock,\n             ExprAssign(..)           => SawExprAssign,\n-            ExprAssignOp(op, _, _)   => SawExprAssignOp(op),\n+            ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n             ExprField(_, id)         => SawExprField(content(id.node)),\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,"}, {"sha": "5d0ae9d1f92ec8c53caafb5563bda11fde08c776", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -13,7 +13,7 @@\n pub use self::OptimizationDiagnosticKind::*;\n pub use self::Diagnostic::*;\n \n-use libc::c_char;\n+use libc::{c_char, c_uint};\n use std::ptr;\n \n use {ValueRef, TwineRef, DebugLocRef, DiagnosticInfoRef};\n@@ -69,9 +69,37 @@ impl OptimizationDiagnostic {\n     }\n }\n \n+pub struct InlineAsmDiagnostic {\n+    pub cookie: c_uint,\n+    pub message: TwineRef,\n+    pub instruction: ValueRef,\n+}\n+\n+impl Copy for InlineAsmDiagnostic {}\n+\n+impl InlineAsmDiagnostic {\n+    unsafe fn unpack(di: DiagnosticInfoRef)\n+            -> InlineAsmDiagnostic {\n+\n+        let mut opt = InlineAsmDiagnostic {\n+            cookie: 0,\n+            message: ptr::null_mut(),\n+            instruction: ptr::null_mut(),\n+        };\n+\n+        super::LLVMUnpackInlineAsmDiagnostic(di,\n+            &mut opt.cookie,\n+            &mut opt.message,\n+            &mut opt.instruction);\n+\n+        opt\n+    }\n+}\n+\n #[derive(Copy)]\n pub enum Diagnostic {\n     Optimization(OptimizationDiagnostic),\n+    InlineAsm(InlineAsmDiagnostic),\n \n     /// LLVM has other types that we do not wrap here.\n     UnknownDiagnostic(DiagnosticInfoRef),\n@@ -82,6 +110,9 @@ impl Diagnostic {\n         let kind = super::LLVMGetDiagInfoKind(di);\n \n         match kind {\n+            super::DK_InlineAsm\n+                => InlineAsm(InlineAsmDiagnostic::unpack(di)),\n+\n             super::DK_OptimizationRemark\n                 => Optimization(OptimizationDiagnostic::unpack(OptimizationRemark, di)),\n "}, {"sha": "17191356d3fb063a3dd656c7e20b7dd11e73c3d8", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -2055,6 +2055,10 @@ extern {\n                                             function_out: *mut ValueRef,\n                                             debugloc_out: *mut DebugLocRef,\n                                             message_out: *mut TwineRef);\n+    pub fn LLVMUnpackInlineAsmDiagnostic(DI: DiagnosticInfoRef,\n+                                            cookie_out: *mut c_uint,\n+                                            message_out: *mut TwineRef,\n+                                            instruction_out: *mut ValueRef);\n \n     pub fn LLVMWriteDiagnosticInfoToString(DI: DiagnosticInfoRef, s: RustStringRef);\n     pub fn LLVMGetDiagInfoSeverity(DI: DiagnosticInfoRef) -> DiagnosticSeverity;"}, {"sha": "5e48ce384be518a4a85a386cad7311d252c5a3f7", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -336,37 +336,49 @@ struct HandlerFreeVars<'a> {\n     cgcx: &'a CodegenContext<'a>,\n }\n \n-unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n-                                        user: *const c_void,\n-                                        cookie: c_uint) {\n+unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n+                                           msg: &'b str,\n+                                           cookie: c_uint) {\n     use syntax::codemap::ExpnId;\n \n-    let HandlerFreeVars { cgcx, .. }\n-        = *mem::transmute::<_, *const HandlerFreeVars>(user);\n-\n-    let msg = llvm::build_string(|s| llvm::LLVMWriteSMDiagnosticToString(diag, s))\n-        .expect(\"non-UTF8 SMDiagnostic\");\n-\n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n             sess.codemap().with_expn_info(ExpnId::from_llvm_cookie(cookie), |info| match info {\n-                Some(ei) => sess.span_err(ei.call_site, &msg[]),\n-                None     => sess.err(&msg[]),\n+                Some(ei) => sess.span_err(ei.call_site, msg),\n+                None     => sess.err(msg),\n             });\n         }\n \n         None => {\n-            cgcx.handler.err(&msg[]);\n+            cgcx.handler.err(msg);\n             cgcx.handler.note(\"build without -C codegen-units for more exact errors\");\n         }\n     }\n }\n \n+unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n+                                        user: *const c_void,\n+                                        cookie: c_uint) {\n+    let HandlerFreeVars { cgcx, .. }\n+        = *mem::transmute::<_, *const HandlerFreeVars>(user);\n+\n+    let msg = llvm::build_string(|s| llvm::LLVMWriteSMDiagnosticToString(diag, s))\n+        .expect(\"non-UTF8 SMDiagnostic\");\n+\n+    report_inline_asm(cgcx, &msg[], cookie);\n+}\n+\n unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n     let HandlerFreeVars { llcx, cgcx }\n         = *mem::transmute::<_, *const HandlerFreeVars>(user);\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n+        llvm::diagnostic::InlineAsm(inline) => {\n+            report_inline_asm(cgcx,\n+                              llvm::twine_to_string(inline.message).as_slice(),\n+                              inline.cookie);\n+        }\n+\n         llvm::diagnostic::Optimization(opt) => {\n             let pass_name = str::from_utf8(ffi::c_str_to_bytes(&opt.pass_name))\n                                 .ok()\n@@ -407,10 +419,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     let fv = &fv as *const HandlerFreeVars as *mut c_void;\n \n     llvm::LLVMSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, fv);\n-\n-    if !cgcx.remark.is_empty() {\n-        llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, fv);\n-    }\n+    llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, fv);\n \n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);"}, {"sha": "4c1fdc6140ec07a4b73728630dbb3ad8d732ea57", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -540,7 +540,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n                                         t: Ty<'tcx>,\n-                                        op: ast::BinOp)\n+                                        op: ast::BinOp_)\n                                         -> Result<'blk, 'tcx> {\n     let f = |&: a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n \n@@ -561,7 +561,7 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                          lhs: ValueRef,\n                                          rhs: ValueRef,\n                                          nt: scalar_type,\n-                                         op: ast::BinOp)\n+                                         op: ast::BinOp_)\n                                          -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n     fn die(cx: Block) -> ! {\n@@ -635,7 +635,7 @@ pub fn compare_simd_types<'blk, 'tcx>(\n                            not supported for floating point SIMD types\")\n         },\n         ty::ty_uint(_) | ty::ty_int(_) => {\n-            let cmp = match op {\n+            let cmp = match op.node {\n                 ast::BiEq => llvm::IntEQ,\n                 ast::BiNe => llvm::IntNE,\n                 ast::BiLt => llvm::IntSLT,\n@@ -823,7 +823,7 @@ pub fn cast_shift_rhs<F, G>(op: ast::BinOp,\n     G: FnOnce(ValueRef, Type) -> ValueRef,\n {\n     // Shifts may have any size int on the rhs\n-    if ast_util::is_shift_binop(op) {\n+    if ast_util::is_shift_binop(op.node) {\n         let mut rhs_llty = val_ty(rhs);\n         let mut lhs_llty = val_ty(lhs);\n         if rhs_llty.kind() == Vector { rhs_llty = rhs_llty.element_type() }\n@@ -852,7 +852,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n                                 rhs: ValueRef,\n                                 rhs_t: Ty<'tcx>)\n                                 -> Block<'blk, 'tcx> {\n-    let (zero_text, overflow_text) = if divrem == ast::BiDiv {\n+    let (zero_text, overflow_text) = if divrem.node == ast::BiDiv {\n         (\"attempted to divide by zero\",\n          \"attempted to divide with overflow\")\n     } else {"}, {"sha": "ba3af53a9160a4030c8a8bdc320bcddb9eef061b", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -310,7 +310,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             let ty = ty::expr_ty(cx.tcx(), &**e1);\n             let is_float = ty::type_is_fp(ty);\n             let signed = ty::type_is_signed(ty);\n-            return match b {\n+            return match b.node {\n               ast::BiAdd   => {\n                 if is_float { llvm::LLVMConstFAdd(te1, te2) }\n                 else        { llvm::LLVMConstAdd(te1, te2) }"}, {"sha": "b366c7faefab08e0ee5eab94204d6ce90799ba40", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -207,7 +207,7 @@ use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n use util::ppaux;\n \n-use libc::c_uint;\n+use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n use std::ptr;\n@@ -2764,7 +2764,7 @@ fn create_struct_stub(cx: &CrateContext,\n fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 unique_type_id: UniqueTypeId,\n                                 element_type: Ty<'tcx>,\n-                                len: uint,\n+                                len: Option<u64>,\n                                 span: Span)\n                                 -> MetadataCreationResult {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n@@ -2774,18 +2774,20 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n \n+    let (array_size_in_bytes, upper_bound) = match len {\n+        Some(len) => (element_type_size * len, len as c_longlong),\n+        None => (0, -1)\n+    };\n+\n     let subrange = unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateSubrange(\n-            DIB(cx),\n-            0,\n-            len as i64)\n+        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, upper_bound)\n     };\n \n     let subscripts = create_DIArray(DIB(cx), &[subrange]);\n     let metadata = unsafe {\n         llvm::LLVMDIBuilderCreateArrayType(\n             DIB(cx),\n-            bytes_to_bits(element_type_size * (len as u64)),\n+            bytes_to_bits(array_size_in_bytes),\n             bytes_to_bits(element_type_align),\n             element_type_metadata,\n             subscripts)\n@@ -2991,12 +2993,12 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_enum(def_id, _) => {\n             prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx)\n         }\n-        ty::ty_vec(typ, Some(len)) => {\n-            fixed_vec_metadata(cx, unique_type_id, typ, len, usage_site_span)\n+        ty::ty_vec(typ, len) => {\n+            fixed_vec_metadata(cx, unique_type_id, typ, len.map(|x| x as u64), usage_site_span)\n+        }\n+        ty::ty_str => {\n+            fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, None, usage_site_span)\n         }\n-        // FIXME Can we do better than this for unsized vec/str fields?\n-        ty::ty_vec(typ, None) => fixed_vec_metadata(cx, unique_type_id, typ, 0, usage_site_span),\n-        ty::ty_str => fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, 0, usage_site_span),\n         ty::ty_trait(..) => {\n             MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, t, None, unique_type_id),"}, {"sha": "f0b491bdea848d4a7400a7a73694f4fcbd3b03eb", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -1132,7 +1132,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let rhs_datum = unpack_datum!(bcx, trans(bcx, &**rhs));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n                                 vec![(rhs_datum, rhs.id)], Some(dest),\n-                                !ast_util::is_by_value_binop(op)).bcx\n+                                !ast_util::is_by_value_binop(op.node)).bcx\n         }\n         ast::ExprUnary(op, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n@@ -1676,7 +1676,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let binop_debug_loc = binop_expr.debug_loc();\n \n     let mut bcx = bcx;\n-    let val = match op {\n+    let val = match op.node {\n       ast::BiAdd => {\n         if is_float {\n             FAdd(bcx, lhs, rhs, binop_debug_loc)\n@@ -1739,7 +1739,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_scalar(rhs_t) {\n-            unpack_result!(bcx, base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op))\n+            unpack_result!(bcx, base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op.node))\n         } else if is_simd {\n             base::compare_simd_types(bcx, lhs, rhs, intype, ty::simd_size(tcx, lhs_t), op)\n         } else {\n@@ -1811,7 +1811,7 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // if overloaded, would be RvalueDpsExpr\n     assert!(!ccx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n \n-    match op {\n+    match op.node {\n         ast::BiAnd => {\n             trans_lazy_binop(bcx, expr, lazy_and, lhs, rhs)\n         }"}, {"sha": "9356be1b9b410808718bfc9e983f596b084a88a6", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -132,7 +132,8 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         ty::MethodTypeParam(ty::MethodParam {\n             ref trait_ref,\n-            method_num\n+            method_num,\n+            impl_def_id: _\n         }) => {\n             let trait_ref = ty::Binder(bcx.monomorphize(trait_ref));\n             let span = bcx.tcx().map.span(method_call.expr_id);"}, {"sha": "4aa0a211221ef526afd7313d59596ae840966496", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -256,7 +256,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         &impl_polytype.substs,\n                         &ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap());\n                 let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n-                                                           method_num: method_num });\n+                                                           method_num: method_num,\n+                                                           impl_def_id: Some(impl_def_id) });\n                 (impl_trait_ref.substs.clone(), origin)\n             }\n \n@@ -275,7 +276,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 let trait_ref =\n                     Rc::new(ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs.clone())));\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n-                                                           method_num: method_num });\n+                                                           method_num: method_num,\n+                                                           impl_def_id: None });\n                 (substs, origin)\n             }\n \n@@ -285,7 +287,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 let trait_ref = self.replace_late_bound_regions_with_fresh_var(&*poly_trait_ref);\n                 let substs = trait_ref.substs.clone();\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n-                                                           method_num: method_num });\n+                                                           method_num: method_num,\n+                                                           impl_def_id: None });\n                 (substs, origin)\n             }\n         }"}, {"sha": "d92cc1dfc1e95f4af178b5bc176a0e49e76db449", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -287,7 +287,8 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     let callee = MethodCallee {\n         origin: MethodTypeParam(MethodParam{trait_ref: trait_ref.clone(),\n-                                            method_num: method_num}),\n+                                            method_num: method_num,\n+                                            impl_def_id: None}),\n         ty: fty,\n         substs: trait_ref.substs.clone()\n     };"}, {"sha": "a9f81d3a26632b98727d6f805586d1e2cb710d40", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -2859,7 +2859,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let lhs_t = structurally_resolved_type(fcx, lhs.span,\n                                                fcx.expr_ty(&*lhs));\n \n-        if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n+        if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op.node) {\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n             check_expr(fcx, &**rhs);\n             let rhs_ty = fcx.expr_ty(&**rhs);\n@@ -2887,7 +2887,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n             check_expr_has_type(fcx, &**rhs, tvar);\n \n-            let result_t = match op {\n+            let result_t = match op.node {\n                 ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n                 ast::BiGt => {\n                     if ty::type_is_simd(tcx, lhs_t) {\n@@ -2898,7 +2898,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                              operation `{}` not \\\n                                              supported for floating \\\n                                              point SIMD vector `{}`\",\n-                                            ast_util::binop_to_string(op),\n+                                            ast_util::binop_to_string(op.node),\n                                             actual)\n                                 },\n                                 lhs_t,\n@@ -2919,7 +2919,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             return;\n         }\n \n-        if op == ast::BiOr || op == ast::BiAnd {\n+        if op.node == ast::BiOr || op.node == ast::BiAnd {\n             // This is an error; one of the operands must have the wrong\n             // type\n             fcx.write_error(expr.id);\n@@ -2928,7 +2928,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                    |actual| {\n                     format!(\"binary operation `{}` cannot be applied \\\n                              to type `{}`\",\n-                            ast_util::binop_to_string(op),\n+                            ast_util::binop_to_string(op.node),\n                             actual)\n                 },\n                 lhs_t,\n@@ -2945,7 +2945,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  operation `{}=` \\\n                                                  cannot be applied to \\\n                                                  type `{}`\",\n-                                                ast_util::binop_to_string(op),\n+                                                ast_util::binop_to_string(op.node),\n                                                 actual)\n                                    },\n                                    lhs_t,\n@@ -2968,7 +2968,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                   rhs: &P<ast::Expr>) -> Ty<'tcx> {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n-        let (name, trait_did) = match op {\n+        let (name, trait_did) = match op.node {\n             ast::BiAdd => (\"add\", lang.add_trait()),\n             ast::BiSub => (\"sub\", lang.sub_trait()),\n             ast::BiMul => (\"mul\", lang.mul_trait()),\n@@ -2994,10 +2994,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                          trait_did, lhs_expr, Some(rhs), || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"binary operation `{}` cannot be applied to type `{}`\",\n-                        ast_util::binop_to_string(op),\n+                        ast_util::binop_to_string(op.node),\n                         actual)\n             }, lhs_resolved_t, None)\n-        }, if ast_util::is_by_value_binop(op) { AutorefArgs::No } else { AutorefArgs::Yes })\n+        }, if ast_util::is_by_value_binop(op.node) { AutorefArgs::No } else { AutorefArgs::Yes })\n     }\n \n     fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,"}, {"sha": "af5250805b7c608679437d0ec0985c0de1587ac8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -564,7 +564,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         },\n \n         ast::ExprBinary(op, ref lhs, ref rhs) if has_method_map => {\n-            let implicitly_ref_args = !ast_util::is_by_value_binop(op);\n+            let implicitly_ref_args = !ast_util::is_by_value_binop(op.node);\n \n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an"}, {"sha": "69ada28a4b4a456ba05b452591d163d1e7c53fa4", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -18,4 +18,9 @@ pub use self::c_str::CString;\n pub use self::c_str::c_str_to_bytes;\n pub use self::c_str::c_str_to_bytes_with_nul;\n \n+pub use self::os_str::OsString;\n+pub use self::os_str::OsStr;\n+pub use self::os_str::AsOsStr;\n+\n mod c_str;\n+mod os_str;"}, {"sha": "8fdc5547e46b106994600555fab427c74b8f8eaa", "filename": "src/libstd/ffi/os_str.rs", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,260 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A type that can represent all platform-native strings, but is cheaply\n+//! interconvertable with Rust strings.\n+//!\n+//! The need for this type arises from the fact that:\n+//!\n+//! * On Unix systems, strings are often arbitrary sequences of non-zero\n+//!   bytes, in many cases interpreted as UTF-8.\n+//!\n+//! * On Windows, strings are often arbitrary sequences of non-zero 16-bit\n+//!   values, interpreted as UTF-16 when it is valid to do so.\n+//!\n+//! * In Rust, strings are always valid UTF-8, but may contain zeros.\n+//!\n+//! The types in this module bridge this gap by simultaneously representing Rust\n+//! and platform-native string values, and in particular allowing a Rust string\n+//! to be converted into an \"OS\" string with no cost.\n+//!\n+//! **Note**: At the moment, these types are extremely bare-bones, usable only\n+//! for conversion to/from various other string types. Eventually these types\n+//! will offer a full-fledged string API.\n+\n+#![unstable(feature = \"os\",\n+            reason = \"recently added as part of path/io reform\")]\n+\n+use core::prelude::*;\n+\n+use core::borrow::{BorrowFrom, ToOwned};\n+use fmt::{self, Debug};\n+use mem;\n+use string::{String, CowString};\n+use ops;\n+use cmp;\n+use hash::{Hash, Hasher, Writer};\n+\n+use sys::os_str::{Buf, Slice};\n+use sys_common::{AsInner, IntoInner, FromInner};\n+\n+/// Owned, mutable OS strings.\n+#[derive(Clone)]\n+pub struct OsString {\n+    inner: Buf\n+}\n+\n+/// Slices into OS strings.\n+pub struct OsStr {\n+    inner: Slice\n+}\n+\n+impl OsString {\n+    /// Constructs an `OsString` at no cost by consuming a `String`.\n+    pub fn from_string(s: String) -> OsString {\n+        OsString { inner: Buf::from_string(s) }\n+    }\n+\n+    /// Constructs an `OsString` by copying from a `&str` slice.\n+    ///\n+    /// Equivalent to: `OsString::from_string(String::from_str(s))`.\n+    pub fn from_str(s: &str) -> OsString {\n+        OsString { inner: Buf::from_str(s) }\n+    }\n+\n+    /// Convert the `OsString` into a `String` if it contains valid Unicode data.\n+    ///\n+    /// On failure, ownership of the original `OsString` is returned.\n+    pub fn into_string(self) -> Result<String, OsString> {\n+        self.inner.into_string().map_err(|buf| OsString { inner: buf} )\n+    }\n+\n+    /// Extend the string with the given `&OsStr` slice.\n+    pub fn push_os_str(&mut self, s: &OsStr) {\n+        self.inner.push_slice(&s.inner)\n+    }\n+}\n+\n+impl ops::Index<ops::FullRange> for OsString {\n+    type Output = OsStr;\n+\n+    #[inline]\n+    fn index(&self, _index: &ops::FullRange) -> &OsStr {\n+        unsafe { mem::transmute(self.inner.as_slice()) }\n+    }\n+}\n+\n+impl ops::Deref for OsString {\n+    type Target = OsStr;\n+\n+    #[inline]\n+    fn deref(&self) -> &OsStr {\n+        &self[]\n+    }\n+}\n+\n+impl Debug for OsString {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        fmt::Debug::fmt(&**self, formatter)\n+    }\n+}\n+\n+impl OsStr {\n+    /// Coerce directly from a `&str` slice to a `&OsStr` slice.\n+    pub fn from_str(s: &str) -> &OsStr {\n+        unsafe { mem::transmute(Slice::from_str(s)) }\n+    }\n+\n+    /// Yield a `&str` slice if the `OsStr` is valid unicode.\n+    ///\n+    /// This conversion may entail doing a check for UTF-8 validity.\n+    pub fn to_str(&self) -> Option<&str> {\n+        self.inner.to_str()\n+    }\n+\n+    /// Convert an `OsStr` to a `CowString`.\n+    ///\n+    /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    pub fn to_string_lossy(&self) -> CowString {\n+        self.inner.to_string_lossy()\n+    }\n+\n+    /// Copy the slice into an onwed `OsString`.\n+    pub fn to_os_string(&self) -> OsString {\n+        OsString { inner: self.inner.to_owned() }\n+    }\n+\n+    /// Get the underlying byte representation.\n+    ///\n+    /// Note: it is *crucial* that this API is private, to avoid\n+    /// revealing the internal, platform-specific encodings.\n+    fn bytes(&self) -> &[u8] {\n+        unsafe { mem::transmute(&self.inner) }\n+    }\n+}\n+\n+impl PartialEq for OsStr {\n+    fn eq(&self, other: &OsStr) -> bool {\n+        self.bytes().eq(other.bytes())\n+    }\n+}\n+\n+impl PartialEq<str> for OsStr {\n+    fn eq(&self, other: &str) -> bool {\n+        *self == *OsStr::from_str(other)\n+    }\n+}\n+\n+impl PartialEq<OsStr> for str {\n+    fn eq(&self, other: &OsStr) -> bool {\n+        *other == *OsStr::from_str(self)\n+    }\n+}\n+\n+impl Eq for OsStr {}\n+\n+impl PartialOrd for OsStr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> {\n+        self.bytes().partial_cmp(other.bytes())\n+    }\n+    #[inline]\n+    fn lt(&self, other: &OsStr) -> bool { self.bytes().lt(other.bytes()) }\n+    #[inline]\n+    fn le(&self, other: &OsStr) -> bool { self.bytes().le(other.bytes()) }\n+    #[inline]\n+    fn gt(&self, other: &OsStr) -> bool { self.bytes().gt(other.bytes()) }\n+    #[inline]\n+    fn ge(&self, other: &OsStr) -> bool { self.bytes().ge(other.bytes()) }\n+}\n+\n+impl PartialOrd<str> for OsStr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n+        self.partial_cmp(OsStr::from_str(other))\n+    }\n+}\n+\n+// FIXME (#19470): cannot provide PartialOrd<OsStr> for str until we\n+// have more flexible coherence rules.\n+\n+impl Ord for OsStr {\n+    #[inline]\n+    fn cmp(&self, other: &OsStr) -> cmp::Ordering { self.bytes().cmp(other.bytes()) }\n+}\n+\n+impl<'a, S: Hasher + Writer> Hash<S> for OsStr {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.bytes().hash(state)\n+    }\n+}\n+\n+impl Debug for OsStr {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.inner.fmt(formatter)\n+    }\n+}\n+\n+impl BorrowFrom<OsString> for OsStr {\n+    fn borrow_from(owned: &OsString) -> &OsStr { &owned[] }\n+}\n+\n+impl ToOwned<OsString> for OsStr {\n+    fn to_owned(&self) -> OsString { self.to_os_string() }\n+}\n+\n+/// Freely convertible to an `&OsStr` slice.\n+pub trait AsOsStr {\n+    /// Convert to an `&OsStr` slice.\n+    fn as_os_str(&self) -> &OsStr;\n+}\n+\n+impl AsOsStr for OsStr {\n+    fn as_os_str(&self) -> &OsStr {\n+        self\n+    }\n+}\n+\n+impl AsOsStr for OsString {\n+    fn as_os_str(&self) -> &OsStr {\n+        &self[]\n+    }\n+}\n+\n+impl AsOsStr for str {\n+    fn as_os_str(&self) -> &OsStr {\n+        OsStr::from_str(self)\n+    }\n+}\n+\n+impl AsOsStr for String {\n+    fn as_os_str(&self) -> &OsStr {\n+        OsStr::from_str(&self[])\n+    }\n+}\n+\n+impl FromInner<Buf> for OsString {\n+    fn from_inner(buf: Buf) -> OsString {\n+        OsString { inner: buf }\n+    }\n+}\n+\n+impl IntoInner<Buf> for OsString {\n+    fn into_inner(self) -> Buf {\n+        self.inner\n+    }\n+}\n+\n+impl AsInner<Slice> for OsStr {\n+    fn as_inner(&self) -> &Slice {\n+        &self.inner\n+    }\n+}"}, {"sha": "92316fe26b4ea8ef98689fb525031b922c6f0770", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -382,7 +382,7 @@ impl<T> !Sync for SyncSender<T> {}\n /// A `send` operation can only fail if the receiving end of a channel is\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n-#[derive(PartialEq, Eq, Show)]\n+#[derive(PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SendError<T>(pub T);\n \n@@ -412,7 +412,7 @@ pub enum TryRecvError {\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n-#[derive(PartialEq, Clone, Show)]\n+#[derive(PartialEq, Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n@@ -961,13 +961,30 @@ impl<T: Send> Drop for Receiver<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> fmt::Debug for SendError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"SendError(..)\".fmt(f)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Display for SendError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"sending on a closed channel\".fmt(f)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> fmt::Debug for TrySendError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            TrySendError::Full(..) => \"Full(..)\".fmt(f),\n+            TrySendError::Disconnected(..) => \"Disconnected(..)\".fmt(f),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Display for TrySendError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "18680b96592ce3b9589de4b0a5f7b863bb36def5", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -53,15 +53,13 @@ pub struct Guard {\n /// is held. The precise semantics for when a lock is poisoned is documented on\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error.\n-#[derive(Show)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PoisonError<T> {\n     guard: T,\n }\n \n /// An enumeration of possible errors which can occur while calling the\n /// `try_lock` method.\n-#[derive(Show)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryLockError<T> {\n     /// The lock could not be acquired because another task failed while holding\n@@ -92,6 +90,13 @@ pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> fmt::Debug for PoisonError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"PoisonError { inner: .. }\".fmt(f)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Display for PoisonError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -134,6 +139,16 @@ impl<T> FromError<PoisonError<T>> for TryLockError<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> fmt::Debug for TryLockError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            TryLockError::Poisoned(..) => \"Poisoned(..)\".fmt(f),\n+            TryLockError::WouldBlock => \"WouldBlock\".fmt(f)\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Display for TryLockError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "272cf9bd0c07a388cc9928095640eb3fc97d327d", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -29,6 +29,7 @@ pub mod stack;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local;\n+pub mod wtf8;\n \n // common error constructors\n \n@@ -93,11 +94,21 @@ pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where\n     return (origamt - amt) as i64;\n }\n \n-// A trait for extracting representations from std::io types\n-pub trait AsInner<Inner> {\n+/// A trait for viewing representations from std types\n+pub trait AsInner<Inner: ?Sized> {\n     fn as_inner(&self) -> &Inner;\n }\n \n+/// A trait for extracting representations from std types\n+pub trait IntoInner<Inner> {\n+    fn into_inner(self) -> Inner;\n+}\n+\n+/// A trait for creating std types from internal representations\n+pub trait FromInner<Inner> {\n+    fn from_inner(inner: Inner) -> Self;\n+}\n+\n pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> {\n     fn program(&self) -> &CString;\n     fn args(&self) -> &[CString];"}, {"sha": "bc0721550634c21b5d9ecddc1b826eebcc460f45", "filename": "src/libstd/sys/common/wtf8.rs", "status": "added", "additions": 1212, "deletions": 0, "changes": 1212, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,1212 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of [the WTF-8 encoding](https://simonsapin.github.io/wtf-8/).\n+//!\n+//! This library uses Rust\u2019s type system to maintain\n+//! [well-formedness](https://simonsapin.github.io/wtf-8/#well-formed),\n+//! like the `String` and `&str` types do for UTF-8.\n+//!\n+//! Since [WTF-8 must not be used\n+//! for interchange](https://simonsapin.github.io/wtf-8/#intended-audience),\n+//! this library deliberately does not provide access to the underlying bytes\n+//! of WTF-8 strings,\n+//! nor can it decode WTF-8 from arbitrary bytes.\n+//! WTF-8 strings can be obtained from UTF-8, UTF-16, or code points.\n+\n+use core::prelude::*;\n+\n+use core::char::{encode_utf8_raw, encode_utf16_raw};\n+use core::str::{char_range_at_raw, next_code_point};\n+use core::raw::Slice as RawSlice;\n+\n+use borrow::Cow;\n+use cmp;\n+use fmt;\n+use hash::{Hash, Writer, Hasher};\n+use iter::FromIterator;\n+use mem;\n+use num::Int;\n+use ops;\n+use slice;\n+use str;\n+use string::{String, CowString};\n+use unicode::str::{Utf16Item, utf16_items};\n+use vec::Vec;\n+\n+static UTF8_REPLACEMENT_CHARACTER: &'static [u8] = b\"\\xEF\\xBF\\xBD\";\n+\n+/// A Unicode code point: from U+0000 to U+10FFFF.\n+///\n+/// Compare with the `char` type,\n+/// which represents a Unicode scalar value:\n+/// a code point that is not a surrogate (U+D800 to U+DFFF).\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy)]\n+pub struct CodePoint {\n+    value: u32\n+}\n+\n+/// Format the code point as `U+` followed by four to six hexadecimal digits.\n+/// Example: `U+1F4A9`\n+impl fmt::Debug for CodePoint {\n+    #[inline]\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(formatter, \"U+{:04X}\", self.value)\n+    }\n+}\n+\n+impl CodePoint {\n+    /// Unsafely create a new `CodePoint` without checking the value.\n+    ///\n+    /// Only use when `value` is known to be less than or equal to 0x10FFFF.\n+    #[inline]\n+    pub unsafe fn from_u32_unchecked(value: u32) -> CodePoint {\n+        CodePoint { value: value }\n+    }\n+\n+    /// Create a new `CodePoint` if the value is a valid code point.\n+    ///\n+    /// Return `None` if `value` is above 0x10FFFF.\n+    #[inline]\n+    pub fn from_u32(value: u32) -> Option<CodePoint> {\n+        match value {\n+            0 ... 0x10FFFF => Some(CodePoint { value: value }),\n+            _ => None\n+        }\n+    }\n+\n+    /// Create a new `CodePoint` from a `char`.\n+    ///\n+    /// Since all Unicode scalar values are code points, this always succeds.\n+    #[inline]\n+    pub fn from_char(value: char) -> CodePoint {\n+        CodePoint { value: value as u32 }\n+    }\n+\n+    /// Return the numeric value of the code point.\n+    #[inline]\n+    pub fn to_u32(&self) -> u32 {\n+        self.value\n+    }\n+\n+    /// Optionally return a Unicode scalar value for the code point.\n+    ///\n+    /// Return `None` if the code point is a surrogate (from U+D800 to U+DFFF).\n+    #[inline]\n+    pub fn to_char(&self) -> Option<char> {\n+        match self.value {\n+            0xD800 ... 0xDFFF => None,\n+            _ => Some(unsafe { mem::transmute(self.value) })\n+        }\n+    }\n+\n+    /// Return a Unicode scalar value for the code point.\n+    ///\n+    /// Return `'\\u{FFFD}'` (the replacement character \u201c\ufffd\u201d)\n+    /// if the code point is a surrogate (from U+D800 to U+DFFF).\n+    #[inline]\n+    pub fn to_char_lossy(&self) -> char {\n+        self.to_char().unwrap_or('\\u{FFFD}')\n+    }\n+}\n+\n+/// An owned, growable string of well-formed WTF-8 data.\n+///\n+/// Similar to `String`, but can additionally contain surrogate code points\n+/// if they\u2019re not in a surrogate pair.\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Clone)]\n+pub struct Wtf8Buf {\n+    bytes: Vec<u8>\n+}\n+\n+impl ops::Deref for Wtf8Buf {\n+    type Target = Wtf8;\n+\n+    fn deref(&self) -> &Wtf8 {\n+        self.as_slice()\n+    }\n+}\n+\n+/// Format the string with double quotes,\n+/// and surrogates as `\\u` followed by four hexadecimal digits.\n+/// Example: `\"a\\u{D800}\"` for a string with code points [U+0061, U+D800]\n+impl fmt::Debug for Wtf8Buf {\n+    #[inline]\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.as_slice().fmt(formatter)\n+    }\n+}\n+\n+impl Wtf8Buf {\n+    /// Create an new, empty WTF-8 string.\n+    #[inline]\n+    pub fn new() -> Wtf8Buf {\n+        Wtf8Buf { bytes: Vec::new() }\n+    }\n+\n+    /// Create an new, empty WTF-8 string with pre-allocated capacity for `n` bytes.\n+    #[inline]\n+    pub fn with_capacity(n: uint) -> Wtf8Buf {\n+        Wtf8Buf { bytes: Vec::with_capacity(n) }\n+    }\n+\n+    /// Create a WTF-8 string from an UTF-8 `String`.\n+    ///\n+    /// This takes ownership of the `String` and does not copy.\n+    ///\n+    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n+    #[inline]\n+    pub fn from_string(string: String) -> Wtf8Buf {\n+        Wtf8Buf { bytes: string.into_bytes() }\n+    }\n+\n+    /// Create a WTF-8 string from an UTF-8 `&str` slice.\n+    ///\n+    /// This copies the content of the slice.\n+    ///\n+    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n+    #[inline]\n+    pub fn from_str(str: &str) -> Wtf8Buf {\n+        Wtf8Buf { bytes: slice::SliceExt::to_vec(str.as_bytes()) }\n+    }\n+\n+    /// Create a WTF-8 string from a potentially ill-formed UTF-16 slice of 16-bit code units.\n+    ///\n+    /// This is lossless: calling `.encode_wide()` on the resulting string\n+    /// will always return the original code units.\n+    pub fn from_wide(v: &[u16]) -> Wtf8Buf {\n+        let mut string = Wtf8Buf::with_capacity(v.len());\n+        for item in utf16_items(v) {\n+            match item {\n+                Utf16Item::ScalarValue(c) => string.push_char(c),\n+                Utf16Item::LoneSurrogate(s) => {\n+                    // Surrogates are known to be in the code point range.\n+                    let code_point = unsafe { CodePoint::from_u32_unchecked(s as u32) };\n+                    // Skip the WTF-8 concatenation check,\n+                    // surrogate pairs are already decoded by utf16_items\n+                    string.push_code_point_unchecked(code_point)\n+                }\n+            }\n+        }\n+        string\n+    }\n+\n+    /// Copied from String::push\n+    /// This does **not** include the WTF-8 concatenation check.\n+    fn push_code_point_unchecked(&mut self, code_point: CodePoint) {\n+        let cur_len = self.len();\n+        // This may use up to 4 bytes.\n+        self.reserve(4);\n+\n+        unsafe {\n+            // Attempt to not use an intermediate buffer by just pushing bytes\n+            // directly onto this string.\n+            let slice = RawSlice {\n+                data: self.bytes.as_ptr().offset(cur_len as int),\n+                len: 4,\n+            };\n+            let used = encode_utf8_raw(code_point.value, mem::transmute(slice))\n+                .unwrap_or(0);\n+            self.bytes.set_len(cur_len + used);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &Wtf8 {\n+        unsafe { mem::transmute(self.bytes.as_slice()) }\n+    }\n+\n+    /// Reserves capacity for at least `additional` more bytes to be inserted\n+    /// in the given `Wtf8Buf`.\n+    /// The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n+    #[inline]\n+    pub fn reserve(&mut self, additional: uint) {\n+        self.bytes.reserve(additional)\n+    }\n+\n+    /// Returns the number of bytes that this string buffer can hold without reallocating.\n+    #[inline]\n+    pub fn capacity(&self) -> uint {\n+        self.bytes.capacity()\n+    }\n+\n+    /// Append an UTF-8 slice at the end of the string.\n+    #[inline]\n+    pub fn push_str(&mut self, other: &str) {\n+        self.bytes.push_all(other.as_bytes())\n+    }\n+\n+    /// Append a WTF-8 slice at the end of the string.\n+    ///\n+    /// This replaces newly paired surrogates at the boundary\n+    /// with a supplementary code point,\n+    /// like concatenating ill-formed UTF-16 strings effectively would.\n+    #[inline]\n+    pub fn push_wtf8(&mut self, other: &Wtf8) {\n+        match ((&*self).final_lead_surrogate(), other.initial_trail_surrogate()) {\n+            // Replace newly paired surrogates by a supplementary code point.\n+            (Some(lead), Some(trail)) => {\n+                let len_without_lead_surrogate = self.len() - 3;\n+                self.bytes.truncate(len_without_lead_surrogate);\n+                let other_without_trail_surrogate = &other.bytes[3..];\n+                // 4 bytes for the supplementary code point\n+                self.bytes.reserve(4 + other_without_trail_surrogate.len());\n+                self.push_char(decode_surrogate_pair(lead, trail));\n+                self.bytes.push_all(other_without_trail_surrogate);\n+            }\n+            _ => self.bytes.push_all(&other.bytes)\n+        }\n+    }\n+\n+    /// Append a Unicode scalar value at the end of the string.\n+    #[inline]\n+    pub fn push_char(&mut self, c: char) {\n+        self.push_code_point_unchecked(CodePoint::from_char(c))\n+    }\n+\n+    /// Append a code point at the end of the string.\n+    ///\n+    /// This replaces newly paired surrogates at the boundary\n+    /// with a supplementary code point,\n+    /// like concatenating ill-formed UTF-16 strings effectively would.\n+    #[inline]\n+    pub fn push(&mut self, code_point: CodePoint) {\n+        match code_point.to_u32() {\n+            trail @ 0xDC00...0xDFFF => {\n+                match (&*self).final_lead_surrogate() {\n+                    Some(lead) => {\n+                        let len_without_lead_surrogate = self.len() - 3;\n+                        self.bytes.truncate(len_without_lead_surrogate);\n+                        self.push_char(decode_surrogate_pair(lead, trail as u16));\n+                        return\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // No newly paired surrogates at the boundary.\n+        self.push_code_point_unchecked(code_point)\n+    }\n+\n+    /// Shortens a string to the specified length.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `new_len` > current length,\n+    /// or if `new_len` is not a code point boundary.\n+    #[inline]\n+    pub fn truncate(&mut self, new_len: uint) {\n+        assert!(is_code_point_boundary(self.as_slice(), new_len));\n+        self.bytes.truncate(new_len)\n+    }\n+\n+    /// Consume the WTF-8 string and try to convert it to UTF-8.\n+    ///\n+    /// This does not copy the data.\n+    ///\n+    /// If the contents are not well-formed UTF-8\n+    /// (that is, if the string contains surrogates),\n+    /// the original WTF-8 string is returned instead.\n+    pub fn into_string(self) -> Result<String, Wtf8Buf> {\n+        match self.next_surrogate(0) {\n+            None => Ok(unsafe { String::from_utf8_unchecked(self.bytes) }),\n+            Some(_) => Err(self),\n+        }\n+    }\n+\n+    /// Consume the WTF-8 string and convert it lossily to UTF-8.\n+    ///\n+    /// This does not copy the data (but may overwrite parts of it in place).\n+    ///\n+    /// Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character \u201c\ufffd\u201d)\n+    pub fn into_string_lossy(mut self) -> String {\n+        let mut pos = 0;\n+        loop {\n+            match self.next_surrogate(pos) {\n+                Some((surrogate_pos, _)) => {\n+                    pos = surrogate_pos + 3;\n+                    slice::bytes::copy_memory(\n+                        &mut self.bytes[surrogate_pos .. pos],\n+                        UTF8_REPLACEMENT_CHARACTER\n+                    );\n+                },\n+                None => return unsafe { String::from_utf8_unchecked(self.bytes) }\n+            }\n+        }\n+    }\n+}\n+\n+/// Create a new WTF-8 string from an iterator of code points.\n+///\n+/// This replaces surrogate code point pairs with supplementary code points,\n+/// like concatenating ill-formed UTF-16 strings effectively would.\n+impl FromIterator<CodePoint> for Wtf8Buf {\n+    fn from_iter<T: Iterator<Item=CodePoint>>(iterator: T) -> Wtf8Buf {\n+        let mut string = Wtf8Buf::new();\n+        string.extend(iterator);\n+        string\n+    }\n+}\n+\n+/// Append code points from an iterator to the string.\n+///\n+/// This replaces surrogate code point pairs with supplementary code points,\n+/// like concatenating ill-formed UTF-16 strings effectively would.\n+impl Extend<CodePoint> for Wtf8Buf {\n+    fn extend<T: Iterator<Item=CodePoint>>(&mut self, mut iterator: T) {\n+        let (low, _high) = iterator.size_hint();\n+        // Lower bound of one byte per code point (ASCII only)\n+        self.bytes.reserve(low);\n+        for code_point in iterator {\n+            self.push(code_point);\n+        }\n+    }\n+}\n+\n+/// A borrowed slice of well-formed WTF-8 data.\n+///\n+/// Similar to `&str`, but can additionally contain surrogate code points\n+/// if they\u2019re not in a surrogate pair.\n+pub struct Wtf8 {\n+    bytes: [u8]\n+}\n+\n+// FIXME: https://github.com/rust-lang/rust/issues/18805\n+impl PartialEq for Wtf8 {\n+    fn eq(&self, other: &Wtf8) -> bool { self.bytes.eq(&other.bytes) }\n+}\n+\n+// FIXME: https://github.com/rust-lang/rust/issues/18805\n+impl Eq for Wtf8 {}\n+\n+// FIXME: https://github.com/rust-lang/rust/issues/18738\n+impl PartialOrd for Wtf8 {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Wtf8) -> Option<cmp::Ordering> {\n+        self.bytes.partial_cmp(&other.bytes)\n+    }\n+    #[inline]\n+    fn lt(&self, other: &Wtf8) -> bool { self.bytes.lt(&other.bytes) }\n+    #[inline]\n+    fn le(&self, other: &Wtf8) -> bool { self.bytes.le(&other.bytes) }\n+    #[inline]\n+    fn gt(&self, other: &Wtf8) -> bool { self.bytes.gt(&other.bytes) }\n+    #[inline]\n+    fn ge(&self, other: &Wtf8) -> bool { self.bytes.ge(&other.bytes) }\n+}\n+\n+// FIXME: https://github.com/rust-lang/rust/issues/18738\n+impl Ord for Wtf8 {\n+    #[inline]\n+    fn cmp(&self, other: &Wtf8) -> cmp::Ordering { self.bytes.cmp(&other.bytes) }\n+}\n+\n+/// Format the slice with double quotes,\n+/// and surrogates as `\\u` followed by four hexadecimal digits.\n+/// Example: `\"a\\u{D800}\"` for a slice with code points [U+0061, U+D800]\n+impl fmt::Debug for Wtf8 {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        try!(formatter.write_str(\"\\\"\"));\n+        let mut pos = 0;\n+        loop {\n+            match self.next_surrogate(pos) {\n+                None => break,\n+                Some((surrogate_pos, surrogate)) => {\n+                    try!(formatter.write_str(unsafe {\n+                        // the data in this slice is valid UTF-8, transmute to &str\n+                        mem::transmute(&self.bytes[pos .. surrogate_pos])\n+                    }));\n+                    try!(write!(formatter, \"\\\\u{{{:X}}}\", surrogate));\n+                    pos = surrogate_pos + 3;\n+                }\n+            }\n+        }\n+        try!(formatter.write_str(unsafe {\n+            // the data in this slice is valid UTF-8, transmute to &str\n+            mem::transmute(&self.bytes[pos..])\n+        }));\n+        formatter.write_str(\"\\\"\")\n+    }\n+}\n+\n+impl Wtf8 {\n+    /// Create a WTF-8 slice from a UTF-8 `&str` slice.\n+    ///\n+    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n+    #[inline]\n+    pub fn from_str(value: &str) -> &Wtf8 {\n+        unsafe { mem::transmute(value.as_bytes()) }\n+    }\n+\n+    /// Return the length, in WTF-8 bytes.\n+    #[inline]\n+    pub fn len(&self) -> uint {\n+        self.bytes.len()\n+    }\n+\n+    /// Return the code point at `position` if it is in the ASCII range,\n+    /// or `b'\\xFF' otherwise.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `position` is beyond the end of the string.\n+    #[inline]\n+    pub fn ascii_byte_at(&self, position: uint) -> u8 {\n+        match self.bytes[position] {\n+            ascii_byte @ 0x00 ... 0x7F => ascii_byte,\n+            _ => 0xFF\n+        }\n+    }\n+\n+    /// Return the code point at `position`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `position` is not at a code point boundary,\n+    /// or is beyond the end of the string.\n+    #[inline]\n+    pub fn code_point_at(&self, position: uint) -> CodePoint {\n+        let (code_point, _) = self.code_point_range_at(position);\n+        code_point\n+    }\n+\n+    /// Return the code point at `position`\n+    /// and the position of the next code point.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `position` is not at a code point boundary,\n+    /// or is beyond the end of the string.\n+    #[inline]\n+    pub fn code_point_range_at(&self, position: uint) -> (CodePoint, uint) {\n+        let (c, n) = char_range_at_raw(&self.bytes, position);\n+        (CodePoint { value: c }, n)\n+    }\n+\n+    /// Return an iterator for the string\u2019s code points.\n+    #[inline]\n+    pub fn code_points(&self) -> Wtf8CodePoints {\n+        Wtf8CodePoints { bytes: self.bytes.iter() }\n+    }\n+\n+    /// Try to convert the string to UTF-8 and return a `&str` slice.\n+    ///\n+    /// Return `None` if the string contains surrogates.\n+    ///\n+    /// This does not copy the data.\n+    #[inline]\n+    pub fn as_str(&self) -> Option<&str> {\n+        // Well-formed WTF-8 is also well-formed UTF-8\n+        // if and only if it contains no surrogate.\n+        match self.next_surrogate(0) {\n+            None => Some(unsafe { str::from_utf8_unchecked(&self.bytes) }),\n+            Some(_) => None,\n+        }\n+    }\n+\n+    /// Lossily convert the string to UTF-8.\n+    /// Return an UTF-8 `&str` slice if the contents are well-formed in UTF-8.\n+    ///\n+    /// Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character \u201c\ufffd\u201d).\n+    ///\n+    /// This only copies the data if necessary (if it contains any surrogate).\n+    pub fn to_string_lossy(&self) -> CowString {\n+        let surrogate_pos = match self.next_surrogate(0) {\n+            None => return Cow::Borrowed(unsafe { str::from_utf8_unchecked(&self.bytes) }),\n+            Some((pos, _)) => pos,\n+        };\n+        let wtf8_bytes = &self.bytes;\n+        let mut utf8_bytes = Vec::with_capacity(self.len());\n+        utf8_bytes.push_all(&wtf8_bytes[..surrogate_pos]);\n+        utf8_bytes.push_all(UTF8_REPLACEMENT_CHARACTER);\n+        let mut pos = surrogate_pos + 3;\n+        loop {\n+            match self.next_surrogate(pos) {\n+                Some((surrogate_pos, _)) => {\n+                    utf8_bytes.push_all(&wtf8_bytes[pos .. surrogate_pos]);\n+                    utf8_bytes.push_all(UTF8_REPLACEMENT_CHARACTER);\n+                    pos = surrogate_pos + 3;\n+                },\n+                None => {\n+                    utf8_bytes.push_all(&wtf8_bytes[pos..]);\n+                    return Cow::Owned(unsafe { String::from_utf8_unchecked(utf8_bytes) })\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Convert the WTF-8 string to potentially ill-formed UTF-16\n+    /// and return an iterator of 16-bit code units.\n+    ///\n+    /// This is lossless:\n+    /// calling `Wtf8Buf::from_ill_formed_utf16` on the resulting code units\n+    /// would always return the original WTF-8 string.\n+    #[inline]\n+    pub fn encode_wide(&self) -> EncodeWide {\n+        EncodeWide { code_points: self.code_points(), extra: 0 }\n+    }\n+\n+    #[inline]\n+    fn next_surrogate(&self, mut pos: uint) -> Option<(uint, u16)> {\n+        let mut iter = self.bytes[pos..].iter();\n+        loop {\n+            let b = match iter.next() {\n+                None => return None,\n+                Some(&b) => b,\n+            };\n+            if b < 0x80 {\n+                pos += 1;\n+            } else if b < 0xE0 {\n+                iter.next();\n+                pos += 2;\n+            } else if b == 0xED {\n+                match (iter.next(), iter.next()) {\n+                    (Some(&b2), Some(&b3)) if b2 >= 0xA0 => {\n+                        return Some((pos, decode_surrogate(b2, b3)))\n+                    }\n+                    _ => pos += 3\n+                }\n+            } else if b < 0xF0 {\n+                iter.next();\n+                iter.next();\n+                pos += 3;\n+            } else {\n+                iter.next();\n+                iter.next();\n+                iter.next();\n+                pos += 4;\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn final_lead_surrogate(&self) -> Option<u16> {\n+        let len = self.len();\n+        if len < 3 {\n+            return None\n+        }\n+        match &self.bytes[(len - 3)..] {\n+            [0xED, b2 @ 0xA0...0xAF, b3] => Some(decode_surrogate(b2, b3)),\n+            _ => None\n+        }\n+    }\n+\n+    #[inline]\n+    fn initial_trail_surrogate(&self) -> Option<u16> {\n+        let len = self.len();\n+        if len < 3 {\n+            return None\n+        }\n+        match &self.bytes[..3] {\n+            [0xED, b2 @ 0xB0...0xBF, b3] => Some(decode_surrogate(b2, b3)),\n+            _ => None\n+        }\n+    }\n+}\n+\n+\n+/// Return a slice of the given string for the byte range [`begin`..`end`).\n+///\n+/// # Panics\n+///\n+/// Panics when `begin` and `end` do not point to code point boundaries,\n+/// or point beyond the end of the string.\n+impl ops::Index<ops::Range<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: &ops::Range<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if range.start <= range.end &&\n+           is_code_point_boundary(self, range.start) &&\n+           is_code_point_boundary(self, range.end) {\n+            unsafe { slice_unchecked(self, range.start, range.end) }\n+        } else {\n+            slice_error_fail(self, range.start, range.end)\n+        }\n+    }\n+}\n+\n+/// Return a slice of the given string from byte `begin` to its end.\n+///\n+/// # Panics\n+///\n+/// Panics when `begin` is not at a code point boundary,\n+/// or is beyond the end of the string.\n+impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: &ops::RangeFrom<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if is_code_point_boundary(self, range.start) {\n+            unsafe { slice_unchecked(self, range.start, self.len()) }\n+        } else {\n+            slice_error_fail(self, range.start, self.len())\n+        }\n+    }\n+}\n+\n+/// Return a slice of the given string from its beginning to byte `end`.\n+///\n+/// # Panics\n+///\n+/// Panics when `end` is not at a code point boundary,\n+/// or is beyond the end of the string.\n+impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: &ops::RangeTo<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if is_code_point_boundary(self, range.end) {\n+            unsafe { slice_unchecked(self, 0, range.end) }\n+        } else {\n+            slice_error_fail(self, 0, range.end)\n+        }\n+    }\n+}\n+\n+impl ops::Index<ops::FullRange> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, _range: &ops::FullRange) -> &Wtf8 {\n+        self\n+    }\n+}\n+\n+#[inline]\n+fn decode_surrogate(second_byte: u8, third_byte: u8) -> u16 {\n+    // The first byte is assumed to be 0xED\n+    0xD800 | (second_byte as u16 & 0x3F) << 6 | third_byte as u16 & 0x3F\n+}\n+\n+#[inline]\n+fn decode_surrogate_pair(lead: u16, trail: u16) -> char {\n+    let code_point = 0x10000 + ((((lead - 0xD800) as u32) << 10) | (trail - 0xDC00) as u32);\n+    unsafe { mem::transmute(code_point) }\n+}\n+\n+/// Copied from core::str::StrPrelude::is_char_boundary\n+#[inline]\n+pub fn is_code_point_boundary(slice: &Wtf8, index: uint) -> bool {\n+    if index == slice.len() { return true; }\n+    match slice.bytes.get(index) {\n+        None => false,\n+        Some(&b) => b < 128u8 || b >= 192u8,\n+    }\n+}\n+\n+/// Copied from core::str::raw::slice_unchecked\n+#[inline]\n+pub unsafe fn slice_unchecked(s: &Wtf8, begin: uint, end: uint) -> &Wtf8 {\n+    mem::transmute(RawSlice {\n+        data: s.bytes.as_ptr().offset(begin as int),\n+        len: end - begin,\n+    })\n+}\n+\n+/// Copied from core::str::raw::slice_error_fail\n+#[inline(never)]\n+pub fn slice_error_fail(s: &Wtf8, begin: uint, end: uint) -> ! {\n+    assert!(begin <= end);\n+    panic!(\"index {} and/or {} in `{:?}` do not lie on character boundary\",\n+          begin, end, s);\n+}\n+\n+/// Iterator for the code points of a WTF-8 string.\n+///\n+/// Created with the method `.code_points()`.\n+#[derive(Clone)]\n+pub struct Wtf8CodePoints<'a> {\n+    bytes: slice::Iter<'a, u8>\n+}\n+\n+impl<'a> Iterator for Wtf8CodePoints<'a> {\n+    type Item = CodePoint;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<CodePoint> {\n+        next_code_point(&mut self.bytes).map(|c| CodePoint { value: c })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (len, _) = self.bytes.size_hint();\n+        (len.saturating_add(3) / 4, Some(len))\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct EncodeWide<'a> {\n+    code_points: Wtf8CodePoints<'a>,\n+    extra: u16\n+}\n+\n+// Copied from libunicode/u_str.rs\n+impl<'a> Iterator for EncodeWide<'a> {\n+    type Item = u16;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        if self.extra != 0 {\n+            let tmp = self.extra;\n+            self.extra = 0;\n+            return Some(tmp);\n+        }\n+\n+        let mut buf = [0u16; 2];\n+        self.code_points.next().map(|code_point| {\n+            let n = encode_utf16_raw(code_point.value, buf.as_mut_slice())\n+                .unwrap_or(0);\n+            if n == 2 { self.extra = buf[1]; }\n+            buf[0]\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (low, high) = self.code_points.size_hint();\n+        // every code point gets either one u16 or two u16,\n+        // so this iterator is between 1 or 2 times as\n+        // long as the underlying iterator.\n+        (low, high.and_then(|n| n.checked_mul(2)))\n+    }\n+}\n+\n+impl<S: Writer + Hasher> Hash<S> for CodePoint {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.value.hash(state)\n+    }\n+}\n+\n+impl<S: Writer + Hasher> Hash<S> for Wtf8Buf {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        state.write(self.bytes.as_slice());\n+        0xfeu8.hash(state)\n+    }\n+}\n+\n+impl<'a, S: Writer + Hasher> Hash<S> for Wtf8 {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        state.write(&self.bytes);\n+        0xfeu8.hash(state)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use borrow::Cow;\n+    use super::*;\n+    use mem::transmute;\n+    use string::CowString;\n+\n+    #[test]\n+    fn code_point_from_u32() {\n+        assert!(CodePoint::from_u32(0).is_some());\n+        assert!(CodePoint::from_u32(0xD800).is_some());\n+        assert!(CodePoint::from_u32(0x10FFFF).is_some());\n+        assert!(CodePoint::from_u32(0x110000).is_none());\n+    }\n+\n+    #[test]\n+    fn code_point_to_u32() {\n+        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        assert_eq!(c(0).to_u32(), 0);\n+        assert_eq!(c(0xD800).to_u32(), 0xD800);\n+        assert_eq!(c(0x10FFFF).to_u32(), 0x10FFFF);\n+    }\n+\n+    #[test]\n+    fn code_point_from_char() {\n+        assert_eq!(CodePoint::from_char('a').to_u32(), 0x61);\n+        assert_eq!(CodePoint::from_char('\ud83d\udca9').to_u32(), 0x1F4A9);\n+    }\n+\n+    #[test]\n+    fn code_point_to_string() {\n+        assert_eq!(format!(\"{:?}\", CodePoint::from_char('a')).as_slice(), \"U+0061\");\n+        assert_eq!(format!(\"{:?}\", CodePoint::from_char('\ud83d\udca9')).as_slice(), \"U+1F4A9\");\n+    }\n+\n+    #[test]\n+    fn code_point_to_char() {\n+        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        assert_eq!(c(0x61).to_char(), Some('a'));\n+        assert_eq!(c(0x1F4A9).to_char(), Some('\ud83d\udca9'));\n+        assert_eq!(c(0xD800).to_char(), None);\n+    }\n+\n+    #[test]\n+    fn code_point_to_char_lossy() {\n+        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        assert_eq!(c(0x61).to_char_lossy(), 'a');\n+        assert_eq!(c(0x1F4A9).to_char_lossy(), '\ud83d\udca9');\n+        assert_eq!(c(0xD800).to_char_lossy(), '\\u{FFFD}');\n+    }\n+\n+    #[test]\n+    fn wtf8buf_new() {\n+        assert_eq!(Wtf8Buf::new().bytes.as_slice(), b\"\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_from_str() {\n+        assert_eq!(Wtf8Buf::from_str(\"\").bytes.as_slice(), b\"\");\n+        assert_eq!(Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\").bytes.as_slice(),\n+                   b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_from_string() {\n+        assert_eq!(Wtf8Buf::from_string(String::from_str(\"\")).bytes.as_slice(), b\"\");\n+        assert_eq!(Wtf8Buf::from_string(String::from_str(\"a\u00e9 \ud83d\udca9\")).bytes.as_slice(),\n+                   b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_from_wide() {\n+        assert_eq!(Wtf8Buf::from_wide(&[]).bytes.as_slice(), b\"\");\n+        assert_eq!(Wtf8Buf::from_wide(\n+                      &[0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]).bytes.as_slice(),\n+                   b\"a\\xC3\\xA9 \\xED\\xA0\\xBD\\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_push_str() {\n+        let mut string = Wtf8Buf::new();\n+        assert_eq!(string.bytes.as_slice(), b\"\");\n+        string.push_str(\"a\u00e9 \ud83d\udca9\");\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_push_char() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \");\n+        string.push_char('\ud83d\udca9');\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_push() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \");\n+        string.push(CodePoint::from_char('\ud83d\udca9'));\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+\n+        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xD83D));  // lead\n+        string.push(c(0xDCA9));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xD83D));  // lead\n+        string.push(c(0x20));  // not surrogate\n+        string.push(c(0xDCA9));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xD800));  // lead\n+        string.push(c(0xDBFF));  // lead\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xD800));  // lead\n+        string.push(c(0xE000));  // not surrogate\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xD7FF));  // not surrogate\n+        string.push(c(0xDC00));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0x61));  // not surrogate, < 3 bytes\n+        string.push(c(0xDC00));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xDC00));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_push_wtf8() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9\");\n+        string.push_wtf8(Wtf8::from_str(\" \ud83d\udca9\"));\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+\n+        fn w(value: &[u8]) -> &Wtf8 { unsafe { transmute(value) } }\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\xA0\\xBD\"));  // lead\n+        string.push_wtf8(w(b\"\\xED\\xB2\\xA9\"));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\xA0\\xBD\"));  // lead\n+        string.push_wtf8(w(b\" \"));  // not surrogate\n+        string.push_wtf8(w(b\"\\xED\\xB2\\xA9\"));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\xA0\\x80\"));  // lead\n+        string.push_wtf8(w(b\"\\xED\\xAF\\xBF\"));  // lead\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\xA0\\x80\"));  // lead\n+        string.push_wtf8(w(b\"\\xEE\\x80\\x80\"));  // not surrogate\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\x9F\\xBF\"));  // not surrogate\n+        string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"a\"));  // not surrogate, < 3 bytes\n+        string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_truncate() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n+        string.truncate(1);\n+        assert_eq!(string.bytes.as_slice(), b\"a\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn wtf8buf_truncate_fail_code_point_boundary() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n+        string.truncate(2);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn wtf8buf_truncate_fail_longer() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n+        string.truncate(4);\n+    }\n+\n+    #[test]\n+    fn wtf8buf_into_string() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        assert_eq!(string.clone().into_string(), Ok(String::from_str(\"a\u00e9 \ud83d\udca9\")));\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(string.clone().into_string(), Err(string));\n+    }\n+\n+    #[test]\n+    fn wtf8buf_into_string_lossy() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        assert_eq!(string.clone().into_string_lossy(), String::from_str(\"a\u00e9 \ud83d\udca9\"));\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(string.clone().into_string_lossy(), String::from_str(\"a\u00e9 \ud83d\udca9\ufffd\"));\n+    }\n+\n+    #[test]\n+    fn wtf8buf_from_iterator() {\n+        fn f(values: &[u32]) -> Wtf8Buf {\n+            values.iter().map(|&c| CodePoint::from_u32(c).unwrap()).collect::<Wtf8Buf>()\n+        };\n+        assert_eq!(f(&[0x61, 0xE9, 0x20, 0x1F4A9]).bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+\n+        assert_eq!(f(&[0xD83D, 0xDCA9]).bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        assert_eq!(f(&[0xD83D, 0x20, 0xDCA9]).bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+        assert_eq!(f(&[0xD800, 0xDBFF]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+        assert_eq!(f(&[0xD800, 0xE000]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+        assert_eq!(f(&[0xD7FF, 0xDC00]).bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+        assert_eq!(f(&[0x61, 0xDC00]).bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n+        assert_eq!(f(&[0xDC00]).bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_extend() {\n+        fn e(initial: &[u32], extended: &[u32]) -> Wtf8Buf {\n+            fn c(value: &u32) -> CodePoint { CodePoint::from_u32(*value).unwrap() }\n+            let mut string = initial.iter().map(c).collect::<Wtf8Buf>();\n+            string.extend(extended.iter().map(c));\n+            string\n+        };\n+\n+        assert_eq!(e(&[0x61, 0xE9], &[0x20, 0x1F4A9]).bytes.as_slice(),\n+                   b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+\n+        assert_eq!(e(&[0xD83D], &[0xDCA9]).bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        assert_eq!(e(&[0xD83D, 0x20], &[0xDCA9]).bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+        assert_eq!(e(&[0xD800], &[0xDBFF]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+        assert_eq!(e(&[0xD800], &[0xE000]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+        assert_eq!(e(&[0xD7FF], &[0xDC00]).bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+        assert_eq!(e(&[0x61], &[0xDC00]).bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n+        assert_eq!(e(&[], &[0xDC00]).bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_show() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(format!(\"{:?}\", string).as_slice(), r#\"\"a\u00e9 \ud83d\udca9\\u{D800}\"\"#);\n+    }\n+\n+    #[test]\n+    fn wtf8buf_as_slice() {\n+        assert_eq!(Wtf8Buf::from_str(\"a\u00e9\").as_slice(), Wtf8::from_str(\"a\u00e9\"));\n+    }\n+\n+    #[test]\n+    fn wtf8_show() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(format!(\"{:?}\", string.as_slice()).as_slice(), r#\"\"a\u00e9 \ud83d\udca9\\u{D800}\"\"#);\n+    }\n+\n+    #[test]\n+    fn wtf8_from_str() {\n+        assert_eq!(&Wtf8::from_str(\"\").bytes, b\"\");\n+        assert_eq!(&Wtf8::from_str(\"a\u00e9 \ud83d\udca9\").bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8_len() {\n+        assert_eq!(Wtf8::from_str(\"\").len(), 0);\n+        assert_eq!(Wtf8::from_str(\"a\u00e9 \ud83d\udca9\").len(), 8);\n+    }\n+\n+    #[test]\n+    fn wtf8_slice() {\n+        assert_eq!(&Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[1.. 4].bytes, b\"\\xC3\\xA9 \");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn wtf8_slice_not_code_point_boundary() {\n+        &Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[2.. 4];\n+    }\n+\n+    #[test]\n+    fn wtf8_slice_from() {\n+        assert_eq!(&Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[1..].bytes, b\"\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn wtf8_slice_from_not_code_point_boundary() {\n+        &Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[2..];\n+    }\n+\n+    #[test]\n+    fn wtf8_slice_to() {\n+        assert_eq!(&Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[..4].bytes, b\"a\\xC3\\xA9 \");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn wtf8_slice_to_not_code_point_boundary() {\n+        &Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[5..];\n+    }\n+\n+    #[test]\n+    fn wtf8_ascii_byte_at() {\n+        let slice = Wtf8::from_str(\"a\u00e9 \ud83d\udca9\");\n+        assert_eq!(slice.ascii_byte_at(0), b'a');\n+        assert_eq!(slice.ascii_byte_at(1), b'\\xFF');\n+        assert_eq!(slice.ascii_byte_at(2), b'\\xFF');\n+        assert_eq!(slice.ascii_byte_at(3), b' ');\n+        assert_eq!(slice.ascii_byte_at(4), b'\\xFF');\n+    }\n+\n+    #[test]\n+    fn wtf8_code_point_at() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n+        string.push(CodePoint::from_u32(0xD83D).unwrap());\n+        string.push_char('\ud83d\udca9');\n+        assert_eq!(string.code_point_at(0), CodePoint::from_char('a'));\n+        assert_eq!(string.code_point_at(1), CodePoint::from_char('\u00e9'));\n+        assert_eq!(string.code_point_at(3), CodePoint::from_char(' '));\n+        assert_eq!(string.code_point_at(4), CodePoint::from_u32(0xD83D).unwrap());\n+        assert_eq!(string.code_point_at(7), CodePoint::from_char('\ud83d\udca9'));\n+    }\n+\n+    #[test]\n+    fn wtf8_code_point_range_at() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n+        string.push(CodePoint::from_u32(0xD83D).unwrap());\n+        string.push_char('\ud83d\udca9');\n+        assert_eq!(string.code_point_range_at(0), (CodePoint::from_char('a'), 1));\n+        assert_eq!(string.code_point_range_at(1), (CodePoint::from_char('\u00e9'), 3));\n+        assert_eq!(string.code_point_range_at(3), (CodePoint::from_char(' '), 4));\n+        assert_eq!(string.code_point_range_at(4), (CodePoint::from_u32(0xD83D).unwrap(), 7));\n+        assert_eq!(string.code_point_range_at(7), (CodePoint::from_char('\ud83d\udca9'), 11));\n+    }\n+\n+    #[test]\n+    fn wtf8_code_points() {\n+        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        fn cp(string: &Wtf8Buf) -> Vec<Option<char>> {\n+            string.code_points().map(|c| c.to_char()).collect::<Vec<_>>()\n+        }\n+        let mut string = Wtf8Buf::from_str(\"\u00e9 \");\n+        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' ')]);\n+        string.push(c(0xD83D));\n+        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' '), None]);\n+        string.push(c(0xDCA9));\n+        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' '), Some('\ud83d\udca9')]);\n+    }\n+\n+    #[test]\n+    fn wtf8_as_str() {\n+        assert_eq!(Wtf8::from_str(\"\").as_str(), Some(\"\"));\n+        assert_eq!(Wtf8::from_str(\"a\u00e9 \ud83d\udca9\").as_str(), Some(\"a\u00e9 \ud83d\udca9\"));\n+        let mut string = Wtf8Buf::new();\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(string.as_str(), None);\n+    }\n+\n+    #[test]\n+    fn wtf8_to_string_lossy() {\n+        assert_eq!(Wtf8::from_str(\"\").to_string_lossy(), Cow::Borrowed(\"\"));\n+        assert_eq!(Wtf8::from_str(\"a\u00e9 \ud83d\udca9\").to_string_lossy(), Cow::Borrowed(\"a\u00e9 \ud83d\udca9\"));\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        let expected: CowString = Cow::Owned(String::from_str(\"a\u00e9 \ud83d\udca9\ufffd\"));\n+        assert_eq!(string.to_string_lossy(), expected);\n+    }\n+\n+    #[test]\n+    fn wtf8_encode_wide() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n+        string.push(CodePoint::from_u32(0xD83D).unwrap());\n+        string.push_char('\ud83d\udca9');\n+        assert_eq!(string.encode_wide().collect::<Vec<_>>(),\n+                   vec![0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]);\n+    }\n+}"}, {"sha": "3cff5be071c07dd76c669d379e8784d65e10665a", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -31,7 +31,10 @@\n \n #![unstable(feature = \"std_misc\")]\n \n-use sys_common::AsInner;\n+use vec::Vec;\n+use sys::os_str::Buf;\n+use sys_common::{AsInner, IntoInner, FromInner};\n+use ffi::{OsStr, OsString};\n use libc;\n \n use io;\n@@ -99,6 +102,36 @@ impl AsRawFd for io::net::udp::UdpSocket {\n     }\n }\n \n+// Unix-specific extensions to `OsString`.\n+pub trait OsStringExt {\n+    /// Create an `OsString` from a byte vector.\n+    fn from_vec(vec: Vec<u8>) -> Self;\n+\n+    /// Yield the underlying byte vector of this `OsString`.\n+    fn into_vec(self) -> Vec<u8>;\n+}\n+\n+impl OsStringExt for OsString {\n+    fn from_vec(vec: Vec<u8>) -> OsString {\n+        FromInner::from_inner(Buf { inner: vec })\n+    }\n+\n+    fn into_vec(self) -> Vec<u8> {\n+        self.into_inner().inner\n+    }\n+}\n+\n+// Unix-specific extensions to `OsStr`.\n+pub trait OsStrExt {\n+    fn as_byte_slice(&self) -> &[u8];\n+}\n+\n+impl OsStrExt for OsStr {\n+    fn as_byte_slice(&self) -> &[u8] {\n+        &self.as_inner().inner\n+    }\n+}\n+\n /// A prelude for conveniently writing platform-specific code.\n ///\n /// Includes all extension traits, and some important type definitions."}, {"sha": "5493bc20a87ef92246bf1dca131d4432b7d470d2", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -44,6 +44,7 @@ pub mod fs;\n pub mod helper_signal;\n pub mod mutex;\n pub mod os;\n+pub mod os_str;\n pub mod pipe;\n pub mod process;\n pub mod rwlock;"}, {"sha": "3dd89ad07593a2c48a0dbf5a782fd1340288b343", "filename": "src/libstd/sys/unix/os_str.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The underlying OsString/OsStr implementation on Unix systems: just\n+/// a `Vec<u8>`/`[u8]`.\n+\n+use core::prelude::*;\n+\n+use fmt::{self, Debug};\n+use vec::Vec;\n+use slice::SliceExt as StdSliceExt;\n+use str;\n+use string::{String, CowString};\n+use mem;\n+\n+#[derive(Clone)]\n+pub struct Buf {\n+    pub inner: Vec<u8>\n+}\n+\n+pub struct Slice {\n+    pub inner: [u8]\n+}\n+\n+impl Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.to_string_lossy().fmt(formatter)\n+    }\n+}\n+\n+impl Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.as_slice().fmt(formatter)\n+    }\n+}\n+\n+impl Buf {\n+    pub fn from_string(s: String) -> Buf {\n+        Buf { inner: s.into_bytes() }\n+    }\n+\n+    pub fn from_str(s: &str) -> Buf {\n+        Buf { inner: s.as_bytes().to_vec() }\n+    }\n+\n+    pub fn as_slice(&self) -> &Slice {\n+        unsafe { mem::transmute(self.inner.as_slice()) }\n+    }\n+\n+    pub fn into_string(self) -> Result<String, Buf> {\n+        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() } )\n+    }\n+\n+    pub fn push_slice(&mut self, s: &Slice) {\n+        self.inner.push_all(&s.inner)\n+    }\n+}\n+\n+impl Slice {\n+    fn from_u8_slice(s: &[u8]) -> &Slice {\n+        unsafe { mem::transmute(s) }\n+    }\n+\n+    pub fn from_str(s: &str) -> &Slice {\n+        unsafe { mem::transmute(s.as_bytes()) }\n+    }\n+\n+    pub fn to_str(&self) -> Option<&str> {\n+        str::from_utf8(&self.inner).ok()\n+    }\n+\n+    pub fn to_string_lossy(&self) -> CowString {\n+        String::from_utf8_lossy(&self.inner)\n+    }\n+\n+    pub fn to_owned(&self) -> Buf {\n+        Buf { inner: self.inner.to_vec() }\n+    }\n+}"}, {"sha": "d20469f5106f86fb753919db5ee56a4ea2abcac6", "filename": "src/libstd/sys/unix/tty.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -11,14 +11,22 @@\n use prelude::v1::*;\n \n use sys::fs::FileDesc;\n-use libc::{self, c_int};\n+use libc::{self, c_int, c_ulong, funcs};\n use io::{self, IoResult, IoError};\n+use sys::c;\n use sys_common;\n \n pub struct TTY {\n     pub fd: FileDesc,\n }\n \n+#[cfg(any(target_os = \"macos\",\n+          target_os = \"freebsd\"))]\n+const TIOCGWINSZ: c_ulong = 0x40087468;\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+const TIOCGWINSZ: c_ulong = 0x00005413;\n+\n impl TTY {\n     pub fn new(fd: c_int) -> IoResult<TTY> {\n         if unsafe { libc::isatty(fd) } != 0 {\n@@ -41,8 +49,39 @@ impl TTY {\n     pub fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n         Err(sys_common::unimpl())\n     }\n+\n+    #[cfg(any(target_os = \"linux\",\n+              target_os = \"android\",\n+              target_os = \"macos\",\n+              target_os = \"freebsd\"))]\n+    pub fn get_winsize(&mut self) -> IoResult<(int, int)> {\n+        unsafe {\n+            #[repr(C)]\n+            struct winsize {\n+                ws_row: u16,\n+                ws_col: u16,\n+                ws_xpixel: u16,\n+                ws_ypixel: u16\n+            }\n+\n+            let mut size = winsize { ws_row: 0, ws_col: 0, ws_xpixel: 0, ws_ypixel: 0 };\n+            if c::ioctl(self.fd.fd(), TIOCGWINSZ, &mut size) == -1 {\n+                Err(IoError {\n+                    kind: io::OtherIoError,\n+                    desc: \"Size of terminal could not be determined\",\n+                    detail: None,\n+                })\n+            } else {\n+                Ok((size.ws_col as int, size.ws_row as int))\n+            }\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"ios\",\n+              target_os = \"dragonfly\"))]\n     pub fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         Err(sys_common::unimpl())\n     }\n+\n     pub fn isatty(&self) -> bool { false }\n }"}, {"sha": "2f45cb78cda8a99057a336f6a72449e1ef945c88", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -16,7 +16,11 @@\n \n #![unstable(feature = \"std_misc\")]\n \n-use sys_common::AsInner;\n+pub use sys_common::wtf8::{Wtf8Buf, EncodeWide};\n+\n+use sys::os_str::Buf;\n+use sys_common::{AsInner, FromInner};\n+use ffi::{OsStr, OsString};\n use libc;\n \n use io;\n@@ -92,9 +96,35 @@ impl AsRawSocket for io::net::udp::UdpSocket {\n     }\n }\n \n+// Windows-specific extensions to `OsString`.\n+pub trait OsStringExt {\n+    /// Create an `OsString` from a potentially ill-formed UTF-16 slice of 16-bit code units.\n+    ///\n+    /// This is lossless: calling `.encode_wide()` on the resulting string\n+    /// will always return the original code units.\n+    fn from_wide(wide: &[u16]) -> Self;\n+}\n+\n+impl OsStringExt for OsString {\n+    fn from_wide(wide: &[u16]) -> OsString {\n+        FromInner::from_inner(Buf { inner: Wtf8Buf::from_wide(wide) })\n+    }\n+}\n+\n+// Windows-specific extensions to `OsStr`.\n+pub trait OsStrExt {\n+    fn encode_wide(&self) -> EncodeWide;\n+}\n+\n+impl OsStrExt for OsStr {\n+    fn encode_wide(&self) -> EncodeWide {\n+        self.as_inner().inner.encode_wide()\n+    }\n+}\n+\n /// A prelude for conveniently writing platform-specific code.\n ///\n /// Includes all extension traits, and some important type definitions.\n pub mod prelude {\n-    pub use super::{Socket, Handle, AsRawSocket, AsRawHandle};\n+    pub use super::{Socket, Handle, AsRawSocket, AsRawHandle, OsStrExt, OsStringExt};\n }"}, {"sha": "876159623ac9915cf7734c31fbb4a1e89c654528", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -44,6 +44,7 @@ pub mod fs;\n pub mod helper_signal;\n pub mod mutex;\n pub mod os;\n+pub mod os_str;\n pub mod pipe;\n pub mod process;\n pub mod rwlock;"}, {"sha": "aab2406cef92bd0a21aeb1dba5e9e2f0a56beaae", "filename": "src/libstd/sys/windows/os_str.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The underlying OsString/OsStr implementation on Windows is a\n+/// wrapper around the \"WTF-8\" encoding; see the `wtf8` module for more.\n+\n+use fmt::{self, Debug};\n+use sys_common::wtf8::{Wtf8, Wtf8Buf};\n+use string::{String, CowString};\n+use result::Result;\n+use option::Option;\n+use mem;\n+\n+#[derive(Clone)]\n+pub struct Buf {\n+    pub inner: Wtf8Buf\n+}\n+\n+impl Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.as_slice().fmt(formatter)\n+    }\n+}\n+\n+pub struct Slice {\n+    pub inner: Wtf8\n+}\n+\n+impl Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.inner.fmt(formatter)\n+    }\n+}\n+\n+impl Buf {\n+    pub fn from_string(s: String) -> Buf {\n+        Buf { inner: Wtf8Buf::from_string(s) }\n+    }\n+\n+    pub fn from_str(s: &str) -> Buf {\n+        Buf { inner: Wtf8Buf::from_str(s) }\n+    }\n+\n+    pub fn as_slice(&self) -> &Slice {\n+        unsafe { mem::transmute(self.inner.as_slice()) }\n+    }\n+\n+    pub fn into_string(self) -> Result<String, Buf> {\n+        self.inner.into_string().map_err(|buf| Buf { inner: buf })\n+    }\n+\n+    pub fn push_slice(&mut self, s: &Slice) {\n+        self.inner.push_wtf8(&s.inner)\n+    }\n+}\n+\n+impl Slice {\n+    pub fn from_str(s: &str) -> &Slice {\n+        unsafe { mem::transmute(Wtf8::from_str(s)) }\n+    }\n+\n+    pub fn to_str(&self) -> Option<&str> {\n+        self.inner.as_str()\n+    }\n+\n+    pub fn to_string_lossy(&self) -> CowString {\n+        self.inner.to_string_lossy()\n+    }\n+\n+    pub fn to_owned(&self) -> Buf {\n+        let mut buf = Wtf8Buf::with_capacity(self.inner.len());\n+        buf.push_wtf8(&self.inner);\n+        Buf { inner: buf }\n+    }\n+}"}, {"sha": "25a30b5e8e2ee41751338bd5d4ef063b55f178c3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -13,7 +13,7 @@\n pub use self::AsmDialect::*;\n pub use self::AttrStyle::*;\n pub use self::BindingMode::*;\n-pub use self::BinOp::*;\n+pub use self::BinOp_::*;\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n pub use self::Decl_::*;\n@@ -582,7 +582,7 @@ pub enum Mutability {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n-pub enum BinOp {\n+pub enum BinOp_ {\n     BiAdd,\n     BiSub,\n     BiMul,\n@@ -603,6 +603,8 @@ pub enum BinOp {\n     BiGt,\n }\n \n+pub type BinOp = Spanned<BinOp_>;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n pub enum UnOp {\n     UnUniq,"}, {"sha": "5aeea47ac60dc4b56d9d634765d1296c3bf6120d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -46,7 +46,7 @@ pub fn stmt_id(s: &Stmt) -> NodeId {\n     }\n }\n \n-pub fn binop_to_string(op: BinOp) -> &'static str {\n+pub fn binop_to_string(op: BinOp_) -> &'static str {\n     match op {\n         BiAdd => \"+\",\n         BiSub => \"-\",\n@@ -69,31 +69,31 @@ pub fn binop_to_string(op: BinOp) -> &'static str {\n     }\n }\n \n-pub fn lazy_binop(b: BinOp) -> bool {\n+pub fn lazy_binop(b: BinOp_) -> bool {\n     match b {\n       BiAnd => true,\n       BiOr => true,\n       _ => false\n     }\n }\n \n-pub fn is_shift_binop(b: BinOp) -> bool {\n+pub fn is_shift_binop(b: BinOp_) -> bool {\n     match b {\n       BiShl => true,\n       BiShr => true,\n       _ => false\n     }\n }\n \n-pub fn is_comparison_binop(b: BinOp) -> bool {\n+pub fn is_comparison_binop(b: BinOp_) -> bool {\n     match b {\n         BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => true,\n         _ => false\n     }\n }\n \n /// Returns `true` if the binary operator takes its arguments by value\n-pub fn is_by_value_binop(b: BinOp) -> bool {\n+pub fn is_by_value_binop(b: BinOp_) -> bool {\n     match b {\n         BiAdd | BiSub | BiMul | BiDiv | BiRem | BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr => {\n             true\n@@ -319,7 +319,7 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n }\n \n /// Maps a binary operator to its precedence\n-pub fn operator_prec(op: ast::BinOp) -> usize {\n+pub fn operator_prec(op: ast::BinOp_) -> usize {\n   match op {\n       // 'as' sits here with 12\n       BiMul | BiDiv | BiRem     => 11us,"}, {"sha": "2b3a72126831e7d8a3ae69def8692ade112586e5", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -106,7 +106,7 @@ pub trait AstBuilder {\n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n \n     fn expr_self(&self, span: Span) -> P<ast::Expr>;\n-    fn expr_binary(&self, sp: Span, op: ast::BinOp,\n+    fn expr_binary(&self, sp: Span, op: ast::BinOp_,\n                    lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr>;\n@@ -561,9 +561,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_ident(span, special_idents::self_)\n     }\n \n-    fn expr_binary(&self, sp: Span, op: ast::BinOp,\n+    fn expr_binary(&self, sp: Span, op: ast::BinOp_,\n                    lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprBinary(op, lhs, rhs))\n+        self.expr(sp, ast::ExprBinary(Spanned { node: op, span: sp }, lhs, rhs))\n     }\n \n     fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {"}, {"sha": "f8812f4d28dc7ad5c8cca5b1ab04a28c9e37bd22", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -1449,7 +1449,7 @@ pub fn cs_same_method_fold<F>(use_foldl: bool,\n /// Use a given binop to combine the result of calling the derived method\n /// on all the fields.\n #[inline]\n-pub fn cs_binop(binop: ast::BinOp, base: P<Expr>,\n+pub fn cs_binop(binop: ast::BinOp_, base: P<Expr>,\n                 enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                 cx: &mut ExtCtxt, trait_span: Span,\n                 substructure: &Substructure) -> P<Expr> {"}, {"sha": "759e5e8229a0e91343eb9337a30a11965f72a90e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -2840,6 +2840,7 @@ impl<'a> Parser<'a> {\n \n         self.expected_tokens.push(TokenType::Operator);\n \n+        let cur_op_span = self.span;\n         let cur_opt = self.token.to_binop();\n         match cur_opt {\n             Some(cur_op) => {\n@@ -2853,7 +2854,7 @@ impl<'a> Parser<'a> {\n                     let rhs = self.parse_more_binops(expr, cur_prec + 1);\n                     let lhs_span = lhs.span;\n                     let rhs_span = rhs.span;\n-                    let binary = self.mk_binary(cur_op, lhs, rhs);\n+                    let binary = self.mk_binary(codemap::respan(cur_op_span, cur_op), lhs, rhs);\n                     let bin = self.mk_expr(lhs_span.lo, rhs_span.hi, binary);\n                     self.parse_more_binops(bin, min_prec)\n                 } else {\n@@ -2877,16 +2878,17 @@ impl<'a> Parser<'a> {\n     /// Produce an error if comparison operators are chained (RFC #558).\n     /// We only need to check lhs, not rhs, because all comparison ops\n     /// have same precedence and are left-associative\n-    fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: ast::BinOp) {\n+    fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: ast::BinOp_) {\n         debug_assert!(ast_util::is_comparison_binop(outer_op));\n         match lhs.node {\n-            ExprBinary(op, _, _) if ast_util::is_comparison_binop(op) => {\n-                let op_span = self.span;\n+            ExprBinary(op, _, _) if ast_util::is_comparison_binop(op.node) => {\n+                // respan to include both operators\n+                let op_span = mk_sp(op.span.lo, self.span.hi);\n                 self.span_err(op_span,\n-                    \"Chained comparison operators require parentheses\");\n-                if op == BiLt && outer_op == BiGt {\n+                    \"chained comparison operators require parentheses\");\n+                if op.node == BiLt && outer_op == BiGt {\n                     self.span_help(op_span,\n-                        \"use ::< instead of < if you meant to specify type arguments\");\n+                        \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n                 }\n             }\n             _ => {}\n@@ -2919,6 +2921,7 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_assign_expr_with(&mut self, lhs: P<Expr>) -> P<Expr> {\n         let restrictions = self.restrictions & RESTRICTION_NO_STRUCT_LITERAL;\n+        let op_span = self.span;\n         match self.token {\n           token::Eq => {\n               self.bump();\n@@ -2942,7 +2945,7 @@ impl<'a> Parser<'a> {\n               };\n               let rhs_span = rhs.span;\n               let span = lhs.span;\n-              let assign_op = self.mk_assign_op(aop, lhs, rhs);\n+              let assign_op = self.mk_assign_op(codemap::respan(op_span, aop), lhs, rhs);\n               self.mk_expr(span.lo, rhs_span.hi, assign_op)\n           }\n           // A range expression, either `expr..expr` or `expr..`."}, {"sha": "ac694afac6bf729e92f41c1026bfe999b4ce6238", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -249,7 +249,7 @@ impl Token {\n     }\n \n     /// Maps a token to its corresponding binary operator.\n-    pub fn to_binop(&self) -> Option<ast::BinOp> {\n+    pub fn to_binop(&self) -> Option<ast::BinOp_> {\n         match *self {\n             BinOp(Star)     => Some(ast::BiMul),\n             BinOp(Slash)    => Some(ast::BiDiv),"}, {"sha": "699b4f43b14c9de6741d4aa37b288d348350a293", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -1627,7 +1627,7 @@ impl<'a> State<'a> {\n                          rhs: &ast::Expr) -> IoResult<()> {\n         try!(self.print_expr(lhs));\n         try!(space(&mut self.s));\n-        try!(self.word_space(ast_util::binop_to_string(op)));\n+        try!(self.word_space(ast_util::binop_to_string(op.node)));\n         self.print_expr(rhs)\n     }\n \n@@ -1795,7 +1795,7 @@ impl<'a> State<'a> {\n             ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n-                try!(word(&mut self.s, ast_util::binop_to_string(op)));\n+                try!(word(&mut self.s, ast_util::binop_to_string(op.node)));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }"}, {"sha": "a7679adca2e178eeca05d954605132af0d2fdb50", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -313,6 +313,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n           &ast::ItemFn(ref decl, _, _, ref generics, _) => {\n             let no_output = match decl.output {\n                 ast::DefaultReturn(..) => true,\n+                ast::Return(ref t) if t.node == ast::TyTup(vec![]) => true,\n                 _ => false\n             };\n             if decl.inputs.is_empty()\n@@ -349,6 +350,7 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n                 let input_cnt = decl.inputs.len();\n                 let no_output = match decl.output {\n                     ast::DefaultReturn(..) => true,\n+                    ast::Return(ref t) if t.node == ast::TyTup(vec![]) => true,\n                     _ => false\n                 };\n                 let tparm_cnt = generics.ty_params.len();"}, {"sha": "728ff1461fc2bde54d2079264009474988f728c0", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -894,6 +894,22 @@ LLVMUnpackOptimizationDiagnostic(\n     *message_out = wrap(&opt->getMsg());\n }\n \n+extern \"C\" void\n+LLVMUnpackInlineAsmDiagnostic(\n+    LLVMDiagnosticInfoRef di,\n+    unsigned *cookie_out,\n+    LLVMTwineRef *message_out,\n+    LLVMValueRef *instruction_out)\n+{\n+    // Undefined to call this not on an inline assembly diagnostic!\n+    llvm::DiagnosticInfoInlineAsm *ia\n+        = static_cast<llvm::DiagnosticInfoInlineAsm*>(unwrap(di));\n+\n+    *cookie_out = ia->getLocCookie();\n+    *message_out = wrap(&ia->getMsgStr());\n+    *instruction_out = wrap(ia->getInstruction());\n+}\n+\n extern \"C\" void LLVMWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef di, RustStringRef str) {\n     raw_rust_string_ostream os(str);\n     DiagnosticPrinterRawOStream dp(os);"}, {"sha": "f83037d47bbb1dc398068a64e95551f3fae8805c", "filename": "src/test/compile-fail/issue-19660.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Fcompile-fail%2Fissue-19660.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Fcompile-fail%2Fissue-19660.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19660.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: requires `copy` lang_item\n+\n+#![feature(lang_items, start)]\n+#![no_std]\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+#[start]\n+fn main(_: int, _: *const *const u8) -> int {\n+    0\n+}"}, {"sha": "0c3d1c6adea40c247440a8d77a039175b6630a45", "filename": "src/test/compile-fail/lint-unconditional-recursion.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(unconditional_recursion)]\n+#![allow(dead_code)]\n+fn foo() { //~ ERROR function cannot return without recurring\n+    foo(); //~ NOTE recursive call site\n+}\n+\n+fn bar() {\n+    if true {\n+        bar()\n+    }\n+}\n+\n+fn baz() { //~ ERROR function cannot return without recurring\n+    if true {\n+        baz() //~ NOTE recursive call site\n+    } else {\n+        baz() //~ NOTE recursive call site\n+    }\n+}\n+\n+fn qux() {\n+    loop {}\n+}\n+\n+fn quz() -> bool { //~ ERROR function cannot return without recurring\n+    if true {\n+        while quz() {} //~ NOTE recursive call site\n+        true\n+    } else {\n+        loop { quz(); } //~ NOTE recursive call site\n+    }\n+}\n+\n+trait Foo {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        self.bar() //~ NOTE recursive call site\n+    }\n+}\n+\n+impl Foo for Box<Foo+'static> {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        loop {\n+            self.bar() //~ NOTE recursive call site\n+        }\n+    }\n+\n+}\n+\n+struct Baz;\n+impl Baz {\n+    fn qux(&self) { //~ ERROR function cannot return without recurring\n+        self.qux(); //~ NOTE recursive call site\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f2705f58331b463a9d486df1d634f8434d38b052", "filename": "src/test/compile-fail/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Fcompile-fail%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Fcompile-fail%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frequire-parens-for-chained-comparison.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -12,12 +12,12 @@ fn f<T>() {}\n \n fn main() {\n     false == false == false;\n-    //~^ ERROR: Chained comparison operators require parentheses\n+    //~^ ERROR: chained comparison operators require parentheses\n \n     false == 0 < 2;\n-    //~^ ERROR: Chained comparison operators require parentheses\n+    //~^ ERROR: chained comparison operators require parentheses\n \n     f<X>();\n-    //~^ ERROR: Chained comparison operators require parentheses\n-    //~^^ HELP: use ::< instead of < if you meant to specify type arguments\n+    //~^ ERROR: chained comparison operators require parentheses\n+    //~^^ HELP: use `::<...>` instead of `<...>`\n }"}, {"sha": "b2eb2064aeb0932d8c300642e027d9e4f9c432ab", "filename": "src/test/compile-fail/unsized2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Fcompile-fail%2Funsized2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Fcompile-fail%2Funsized2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized2.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -15,6 +15,6 @@ fn f<X>() {}\n pub fn main() {\n     f<type>();\n     //~^ ERROR expected identifier, found keyword `type`\n-    //~^^ ERROR: Chained comparison operators require parentheses\n-    //~^^^ HELP: use ::< instead of < if you meant to specify type arguments\n+    //~^^ ERROR: chained comparison\n+    //~^^^ HELP: use `::<\n }"}, {"sha": "fdfbcda7421cd91cf245f685b06054934beb60f4", "filename": "src/test/debuginfo/option-like-enum.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -36,6 +36,12 @@\n // gdb-command:print void_droid_gdb->internals\n // gdb-check:$6 = (isize *) 0x0\n \n+// gdb-command:print nested_non_zero_yep\n+// gdb-check:$7 = {RUST$ENCODED$ENUM$1$2$Nope = {10.5, {a = 10, b = 20, c = [...]}}}\n+\n+// gdb-command:print nested_non_zero_nope\n+// gdb-check:$8 = {RUST$ENCODED$ENUM$1$2$Nope = {[...], {a = [...], b = [...], c = 0x0}}}\n+\n // gdb-command:continue\n \n \n@@ -67,6 +73,12 @@\n // lldb-command:print none_str\n // lldb-check:[...]$7 = None\n \n+// lldb-command:print nested_non_zero_yep\n+// lldb-check:[...]$8 = Yep(10.5, NestedNonZeroField { a: 10, b: 20, c: &[...] })\n+\n+// lldb-command:print nested_non_zero_nope\n+// lldb-check:[...]$9 = Nope\n+\n \n #![omit_gdb_pretty_printer_section]\n \n@@ -102,6 +114,17 @@ struct NamedFieldsRepr<'a> {\n     internals: &'a isize\n }\n \n+struct NestedNonZeroField<'a> {\n+    a: u16,\n+    b: u32,\n+    c: &'a char,\n+}\n+\n+enum NestedNonZero<'a> {\n+    Yep(f64, NestedNonZeroField<'a>),\n+    Nope\n+}\n+\n fn main() {\n \n     let some_str: Option<&'static str> = Some(\"abc\");\n@@ -124,6 +147,17 @@ fn main() {\n     let void_droid = NamedFields::Void;\n     let void_droid_gdb: &NamedFieldsRepr = unsafe { std::mem::transmute(&NamedFields::Void) };\n \n+    let x = 'x';\n+    let nested_non_zero_yep = NestedNonZero::Yep(\n+        10.5,\n+        NestedNonZeroField {\n+            a: 10,\n+            b: 20,\n+            c: &x\n+        });\n+\n+    let nested_non_zero_nope = NestedNonZero::Nope;\n+\n     zzz(); // #break\n }\n "}, {"sha": "bf395b14eb4eceafedb6bd2f75ffeb27ff386729", "filename": "src/test/run-pass/issue-15149.rs", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -8,33 +8,54 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::{TempDir, Command, fs};\n+use std::slice::SliceExt;\n+use std::io::{Command, fs, USER_RWX};\n use std::os;\n+use std::path::BytesContainer;\n+use std::rand::random;\n \n fn main() {\n     // If we're the child, make sure we were invoked correctly\n     let args = os::args();\n     if args.len() > 1 && args[1].as_slice() == \"child\" {\n-        return assert_eq!(args[0].as_slice(), \"mytest\");\n+        // FIXME: This should check the whole `args[0]` instead of just\n+        // checking that it ends_with the executable name. This\n+        // is needed because of Windows, which has a different behavior.\n+        // See #15149 for more info.\n+        return assert!(args[0].ends_with(&format!(\"mytest{}\", os::consts::EXE_SUFFIX)[]));\n     }\n \n     test();\n }\n \n fn test() {\n-    // If we're the parent, copy our own binary to a tempr directory, and then\n-    // make it executable.\n-    let dir = TempDir::new(\"mytest\").unwrap();\n-    let me = os::self_exe_name().unwrap();\n-    let dest = dir.path().join(format!(\"mytest{}\", os::consts::EXE_SUFFIX));\n-    fs::copy(&me, &dest).unwrap();\n-\n-    // Append the temp directory to our own PATH.\n+    // If we're the parent, copy our own binary to a new directory.\n+    let my_path = os::self_exe_name().unwrap();\n+    let my_dir  = my_path.dir_path();\n+\n+    let random_u32: u32 = random();\n+    let child_dir = Path::new(my_dir.join(format!(\"issue-15149-child-{}\",\n+                                                  random_u32)));\n+    fs::mkdir(&child_dir, USER_RWX).unwrap();\n+\n+    let child_path = child_dir.join(format!(\"mytest{}\",\n+                                            os::consts::EXE_SUFFIX));\n+    fs::copy(&my_path, &child_path).unwrap();\n+\n+    // Append the new directory to our own PATH.\n     let mut path = os::split_paths(os::getenv(\"PATH\").unwrap_or(String::new()));\n-    path.push(dir.path().clone());\n+    path.push(child_dir.clone());\n     let path = os::join_paths(path.as_slice()).unwrap();\n \n-    Command::new(\"mytest\").env(\"PATH\", path.as_slice())\n-                          .arg(\"child\")\n-                          .spawn().unwrap();\n+    let child_output = Command::new(\"mytest\").env(\"PATH\", path.as_slice())\n+                                             .arg(\"child\")\n+                                             .output().unwrap();\n+\n+    assert!(child_output.status.success(),\n+            format!(\"child assertion failed\\n child stdout:\\n {}\\n child stderr:\\n {}\",\n+                    child_output.output.container_as_str().unwrap(),\n+                    child_output.error.container_as_str().unwrap()));\n+\n+    fs::rmdir_recursive(&child_dir).unwrap();\n+\n }"}, {"sha": "7c99c968e352317a3a313c79c20dd0074909ea76", "filename": "src/test/run-pass/test-fn-signature-verification-for-explicit-return-type.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Frun-pass%2Ftest-fn-signature-verification-for-explicit-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d179ba3b8eb65c951b68f6c52da3aba82806a3a1/src%2Ftest%2Frun-pass%2Ftest-fn-signature-verification-for-explicit-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-fn-signature-verification-for-explicit-return-type.rs?ref=d179ba3b8eb65c951b68f6c52da3aba82806a3a1", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+// no-pretty-expanded\n+extern crate test;\n+\n+#[bench]\n+fn bench_explicit_return_type(_: &mut ::test::Bencher) -> () {}\n+\n+#[test]\n+fn test_explicit_return_type() -> () {}\n+"}]}