{"sha": "2d0db312b543343f1c208b6be21a7a001cec7dd6", "node_id": "C_kwDOAAsO6NoAKDJkMGRiMzEyYjU0MzM0M2YxYzIwOGI2YmUyMWE3YTAwMWNlYzdkZDY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-30T14:07:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-30T14:07:39Z"}, "message": "Merge #10872\n\n10872: ide_db: build symbol index from crate def map r=Veykril a=jhgg\n\nfixes #4842, #10764\r\n\r\nIs this looking correct? :eyes: \r\n\r\n- [x] build the symbol index based upon the CrateDefMap for the given crate in `crate_symbols`\r\n   - [x] make it multi threaded again, and figure out how to cache each moduleid's symbol index in salsa.\r\n   - [x] NavigationTarget for names in macros is wrong, need to figure out how to compute a text range in the original file id?\r\n   - [x] cleanup some duped code\r\n   - [x] collect macros from `ItemScope.declared_macros()` into symbol index.\r\n        - [x] store declared macros in `ItemScope` so we can figure out where macros were defined for the index.  \r\n   - [x] do something about `SymbolIndex::for_files` - ideally it should use the new module symbol index stuff. \r\n       - [x] delete `source_file_to_file_symbols` & co...\r\n           - [x] figure out what to do about `library_symbols` \r\n           - [x] maybe... speed up the new `library_symbols` - the new impl is probably much slower, and definitely much less parallel. **deciding to do nothing here, we can optimize later if necerssary.** \r\n   - [x] fix failing test: `navigation_target::tests::test_nav_for_symbol` - notably the crate def map doesn't seem to find declarations inside function. \r\n       - [x] now a bunch of other tests are failing around auto_import & qualify_path handlers. :(\r\n           - [x] need to assoc items in traits and impls\r\n \n\nCo-authored-by: Jake Heinz <jh@discordapp.com>", "tree": {"sha": "2cf8e7b9adf14afae77e2722f672c5f7d6049281", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cf8e7b9adf14afae77e2722f672c5f7d6049281"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d0db312b543343f1c208b6be21a7a001cec7dd6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhpjArCRBK7hj4Ov3rIwAAidQIAKGzOoVVF50MAY3kOF/BTfEd\n+MCkb1wuqnhPq9zDrYr7kYL2R5ovB4zpQ00PNO8aC9RHN1ykCy/M+zyFqWawiOWx\nJreQ+BUujJGFjMnM2k6KdT6/OQEKjcNS8BkTqBFZHhSru+5zl93aLvBaJkx3fj4R\nQlJdAKC46McsCFttLtKognrJwce7L7GK5bgNV/OII8W8wc5Llo9dN1OVegYMDm2w\n0a6kD4U9GB8KBSphC79ILkiGqfGYtwjguwj9DWb6V3ahYgZcl1kFsR7Mk9+wZuRb\nwX5NjHT2I2XYJpaI/FGfbJAdYIMe5o083TTF2HwXKTKaxL3pBIM1ZdTmQFzFI9o=\n=RjA6\n-----END PGP SIGNATURE-----\n", "payload": "tree 2cf8e7b9adf14afae77e2722f672c5f7d6049281\nparent e217632b9819876cd59f4f6f963d04b0637bd8d2\nparent f4bf750016c4c51b0ec1f1b0e6e2fe25578796f3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1638281259 +0000\ncommitter GitHub <noreply@github.com> 1638281259 +0000\n\nMerge #10872\n\n10872: ide_db: build symbol index from crate def map r=Veykril a=jhgg\n\nfixes #4842, #10764\r\n\r\nIs this looking correct? :eyes: \r\n\r\n- [x] build the symbol index based upon the CrateDefMap for the given crate in `crate_symbols`\r\n   - [x] make it multi threaded again, and figure out how to cache each moduleid's symbol index in salsa.\r\n   - [x] NavigationTarget for names in macros is wrong, need to figure out how to compute a text range in the original file id?\r\n   - [x] cleanup some duped code\r\n   - [x] collect macros from `ItemScope.declared_macros()` into symbol index.\r\n        - [x] store declared macros in `ItemScope` so we can figure out where macros were defined for the index.  \r\n   - [x] do something about `SymbolIndex::for_files` - ideally it should use the new module symbol index stuff. \r\n       - [x] delete `source_file_to_file_symbols` & co...\r\n           - [x] figure out what to do about `library_symbols` \r\n           - [x] maybe... speed up the new `library_symbols` - the new impl is probably much slower, and definitely much less parallel. **deciding to do nothing here, we can optimize later if necerssary.** \r\n   - [x] fix failing test: `navigation_target::tests::test_nav_for_symbol` - notably the crate def map doesn't seem to find declarations inside function. \r\n       - [x] now a bunch of other tests are failing around auto_import & qualify_path handlers. :(\r\n           - [x] need to assoc items in traits and impls\r\n \n\nCo-authored-by: Jake Heinz <jh@discordapp.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d0db312b543343f1c208b6be21a7a001cec7dd6", "html_url": "https://github.com/rust-lang/rust/commit/2d0db312b543343f1c208b6be21a7a001cec7dd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d0db312b543343f1c208b6be21a7a001cec7dd6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e217632b9819876cd59f4f6f963d04b0637bd8d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e217632b9819876cd59f4f6f963d04b0637bd8d2", "html_url": "https://github.com/rust-lang/rust/commit/e217632b9819876cd59f4f6f963d04b0637bd8d2"}, {"sha": "f4bf750016c4c51b0ec1f1b0e6e2fe25578796f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4bf750016c4c51b0ec1f1b0e6e2fe25578796f3", "html_url": "https://github.com/rust-lang/rust/commit/f4bf750016c4c51b0ec1f1b0e6e2fe25578796f3"}], "stats": {"total": 1223, "additions": 1045, "deletions": 178}, "files": [{"sha": "5326a5a44048b693d374a5e9680b6f294334c84f", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -19,8 +19,8 @@ use crate::{\n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n \n pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n-    fn with_single_file(text: &str) -> (Self, FileId) {\n-        let fixture = ChangeFixture::parse(text);\n+    fn with_single_file(ra_fixture: &str) -> (Self, FileId) {\n+        let fixture = ChangeFixture::parse(ra_fixture);\n         let mut db = Self::default();\n         fixture.change.apply(&mut db);\n         assert_eq!(fixture.files.len(), 1);"}, {"sha": "d80660f7c9a36553775b52a5ac483e602b4ee651", "filename": "crates/base_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fbase_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fbase_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Flib.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -102,7 +102,7 @@ fn source_root_crates(db: &dyn SourceDatabaseExt, id: SourceRootId) -> Arc<FxHas\n             let root_file = graph[krate].root_file_id;\n             db.file_source_root(root_file) == id\n         })\n-        .collect::<FxHashSet<_>>();\n+        .collect();\n     Arc::new(res)\n }\n "}, {"sha": "e0dc921c9f019694dcf03bcaf88dcecb4487ce0f", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -40,18 +40,14 @@ use hir_def::{\n     adt::{ReprKind, VariantData},\n     body::{BodyDiagnostic, SyntheticSyntax},\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n-    item_tree::ItemTreeNode,\n     lang_item::LangItemTarget,\n     nameres,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n-    src::HasSource as _,\n-    AdtId, AssocContainerId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId,\n-    DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule, ImplId, LifetimeParamId,\n-    LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeParamId, UnionId,\n+    AttrDefId, ConstId, ConstParamId, EnumId, FunctionId, GenericDefId, HasModule, LifetimeParamId,\n+    LocalEnumVariantId, LocalFieldId, StaticId, StructId, TypeAliasId, TypeParamId, UnionId,\n };\n-use hir_expand::{name::name, MacroCallKind, MacroDefId, MacroDefKind};\n+use hir_expand::{name::name, MacroCallKind, MacroDefKind};\n use hir_ty::{\n     autoderef,\n     consteval::ConstExt,\n@@ -109,14 +105,28 @@ pub use {\n         attr::{Attr, Attrs, AttrsWithOwner, Documentation},\n         find_path::PrefixKind,\n         import_map,\n-        nameres::ModuleSource,\n+        item_scope::ItemScope,\n+        item_tree::ItemTreeNode,\n+        nameres::{DefMap, ModuleData, ModuleOrigin, ModuleSource},\n         path::{ModPath, PathKind},\n+        src::HasSource as DefHasSource, // xx: I don't like this shadowing of HasSource... :(\n         type_ref::{Mutability, TypeRef},\n         visibility::Visibility,\n+        AdtId,\n+        AssocContainerId,\n+        AssocItemId,\n+        AssocItemLoc,\n+        DefWithBodyId,\n+        ImplId,\n+        ItemLoc,\n+        Lookup,\n+        ModuleDefId,\n+        ModuleId,\n+        TraitId,\n     },\n     hir_expand::{\n         name::{known, Name},\n-        ExpandResult, HirFileId, InFile, MacroFile, Origin,\n+        ExpandResult, HirFileId, InFile, MacroDefId, MacroFile, Origin,\n     },\n     hir_ty::display::HirDisplay,\n };"}, {"sha": "27ba42ce1afcde6399a28bc65037a6e1c89e13d0", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -143,6 +143,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.parse(file_id)\n     }\n \n+    pub fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode> {\n+        self.imp.parse_or_expand(file_id)\n+    }\n+\n     pub fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n         self.imp.expand(macro_call)\n     }\n@@ -416,6 +420,12 @@ impl<'db> SemanticsImpl<'db> {\n         tree\n     }\n \n+    fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode> {\n+        let node = self.db.parse_or_expand(file_id)?;\n+        self.cache(node.clone(), file_id);\n+        Some(node)\n+    }\n+\n     fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n         let sa = self.analyze(macro_call.syntax());\n         let file_id = sa.expand(self.db, InFile::new(sa.file_id, macro_call))?;"}, {"sha": "37599371f61fee8f13a6ddae18172740f0061e39", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -44,6 +44,8 @@ pub struct ItemScope {\n     /// The defs declared in this scope. Each def has a single scope where it is\n     /// declared.\n     declarations: Vec<ModuleDefId>,\n+    macro_declarations: Vec<MacroDefId>,\n+\n     impls: Vec<ImplId>,\n     unnamed_consts: Vec<ConstId>,\n     /// Traits imported via `use Trait as _;`.\n@@ -101,6 +103,10 @@ impl ItemScope {\n         self.declarations.iter().copied()\n     }\n \n+    pub fn macro_declarations(&self) -> impl Iterator<Item = MacroDefId> + '_ {\n+        self.macro_declarations.iter().copied()\n+    }\n+\n     pub fn impls(&self) -> impl Iterator<Item = ImplId> + ExactSizeIterator + '_ {\n         self.impls.iter().copied()\n     }\n@@ -163,6 +169,10 @@ impl ItemScope {\n         self.declarations.push(def)\n     }\n \n+    pub(crate) fn declare_macro(&mut self, def: MacroDefId) {\n+        self.macro_declarations.push(def);\n+    }\n+\n     pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n         self.legacy_macros.get(name).copied()\n     }\n@@ -336,7 +346,8 @@ impl ItemScope {\n             values,\n             macros,\n             unresolved,\n-            declarations: defs,\n+            declarations,\n+            macro_declarations,\n             impls,\n             unnamed_consts,\n             unnamed_trait_imports,\n@@ -348,7 +359,8 @@ impl ItemScope {\n         values.shrink_to_fit();\n         macros.shrink_to_fit();\n         unresolved.shrink_to_fit();\n-        defs.shrink_to_fit();\n+        declarations.shrink_to_fit();\n+        macro_declarations.shrink_to_fit();\n         impls.shrink_to_fit();\n         unnamed_consts.shrink_to_fit();\n         unnamed_trait_imports.shrink_to_fit();"}, {"sha": "cf670e5cc17b83730d5d0ce5f6b7f79c093bf76a", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -148,7 +148,7 @@ pub enum ModuleOrigin {\n }\n \n impl ModuleOrigin {\n-    fn declaration(&self) -> Option<AstId<ast::Module>> {\n+    pub fn declaration(&self) -> Option<AstId<ast::Module>> {\n         match self {\n             ModuleOrigin::File { declaration: module, .. }\n             | ModuleOrigin::Inline { definition: module, .. } => Some(*module),"}, {"sha": "d7a35caf29eef4c774c73f6cff2be6ff737c3fe0", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -594,6 +594,7 @@ impl DefCollector<'_> {\n     ) {\n         // Textual scoping\n         self.define_legacy_macro(module_id, name.clone(), macro_);\n+        self.def_map.modules[module_id].scope.declare_macro(macro_);\n \n         // Module scoping\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n@@ -632,6 +633,7 @@ impl DefCollector<'_> {\n     ) {\n         let vis =\n             self.def_map.resolve_visibility(self.db, module_id, vis).unwrap_or(Visibility::Public);\n+        self.def_map.modules[module_id].scope.declare_macro(macro_);\n         self.update(module_id, &[(Some(name), PerNs::macros(macro_, vis))], vis, ImportType::Named);\n     }\n \n@@ -640,6 +642,7 @@ impl DefCollector<'_> {\n     /// A proc macro is similar to normal macro scope, but it would not visible in legacy textual scoped.\n     /// And unconditionally exported.\n     fn define_proc_macro(&mut self, name: Name, macro_: MacroDefId) {\n+        self.def_map.modules[self.def_map.root].scope.declare_macro(macro_);\n         self.update(\n             self.def_map.root,\n             &[(Some(name), PerNs::macros(macro_, Visibility::Public))],"}, {"sha": "e7feb042b22c734a75337b4bec73dc3b1aad00bd", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -367,8 +367,8 @@ impl Analysis {\n     pub fn symbol_search(&self, query: Query) -> Cancellable<Vec<NavigationTarget>> {\n         self.with_db(|db| {\n             symbol_index::world_symbols(db, query)\n-                .into_iter()\n-                .map(|s| s.to_nav(db))\n+                .into_iter() // xx: should we make this a par iter?\n+                .filter_map(|s| s.try_to_nav(db))\n                 .collect::<Vec<_>>()\n         })\n     }"}, {"sha": "7deb6cae38b18a077fbb32c988c36ca99fe7e4a0", "filename": "crates/ide/src/navigation_target.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fnavigation_target.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -167,10 +167,13 @@ impl NavigationTarget {\n     }\n }\n \n-impl ToNav for FileSymbol {\n-    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        NavigationTarget {\n-            file_id: self.file_id,\n+impl TryToNav for FileSymbol {\n+    fn try_to_nav(&self, db: &RootDatabase) -> Option<NavigationTarget> {\n+        let full_range = self.loc.original_range(db)?;\n+        let name_range = self.loc.original_name_range(db)?;\n+\n+        Some(NavigationTarget {\n+            file_id: full_range.file_id,\n             name: self.name.clone(),\n             kind: Some(match self.kind {\n                 FileSymbolKind::Function => SymbolKind::Function,\n@@ -184,12 +187,12 @@ impl ToNav for FileSymbol {\n                 FileSymbolKind::Macro => SymbolKind::Macro,\n                 FileSymbolKind::Union => SymbolKind::Union,\n             }),\n-            full_range: self.range,\n-            focus_range: self.name_range,\n+            full_range: full_range.range,\n+            focus_range: Some(name_range.range),\n             container_name: self.container_name.clone(),\n             description: description_from_symbol(db, self),\n             docs: None,\n-        }\n+        })\n     }\n }\n \n@@ -517,8 +520,7 @@ impl TryToNav for hir::ConstParam {\n /// e.g. `struct Name`, `enum Name`, `fn Name`\n pub(crate) fn description_from_symbol(db: &RootDatabase, symbol: &FileSymbol) -> Option<String> {\n     let sema = Semantics::new(db);\n-    let parse = sema.parse(symbol.file_id);\n-    let node = symbol.ptr.to_node(parse.syntax());\n+    let node = symbol.loc.syntax(&sema)?;\n \n     match_ast! {\n         match node {"}, {"sha": "9f589c1ea1a344a8c3ea5a539f23c506978d0cf5", "filename": "crates/ide/src/status.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatus.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -11,7 +11,6 @@ use ide_db::{\n };\n use itertools::Itertools;\n use profile::{memory_usage, Bytes};\n-use rustc_hash::FxHashMap;\n use std::env;\n use stdx::format_to;\n use syntax::{ast, Parse, SyntaxNode};\n@@ -149,20 +148,16 @@ impl fmt::Display for LibrarySymbolsStats {\n     }\n }\n \n-impl FromIterator<TableEntry<(), Arc<FxHashMap<SourceRootId, SymbolIndex>>>>\n-    for LibrarySymbolsStats\n-{\n+impl FromIterator<TableEntry<SourceRootId, Arc<SymbolIndex>>> for LibrarySymbolsStats {\n     fn from_iter<T>(iter: T) -> LibrarySymbolsStats\n     where\n-        T: IntoIterator<Item = TableEntry<(), Arc<FxHashMap<SourceRootId, SymbolIndex>>>>,\n+        T: IntoIterator<Item = TableEntry<SourceRootId, Arc<SymbolIndex>>>,\n     {\n         let mut res = LibrarySymbolsStats::default();\n         for entry in iter {\n-            let value = entry.value.unwrap();\n-            for symbols in value.values() {\n-                res.total += symbols.len();\n-                res.size += symbols.memory_size();\n-            }\n+            let symbols = entry.value.unwrap();\n+            res.total += symbols.len();\n+            res.size += symbols.memory_size();\n         }\n         res\n     }"}, {"sha": "6c085ffc979031a9f3b75effbb7576333c0b0b34", "filename": "crates/ide_db/src/apply_change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fapply_change.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -137,7 +137,7 @@ impl RootDatabase {\n             hir::db::InternTypeParamIdQuery\n \n             // SymbolsDatabase\n-            crate::symbol_index::FileSymbolsQuery\n+            crate::symbol_index::ModuleSymbolsQuery\n             crate::symbol_index::LibrarySymbolsQuery\n             crate::symbol_index::LocalRootsQuery\n             crate::symbol_index::LibraryRootsQuery"}, {"sha": "e0dbe6caf0af23383c62df50d6503415697fca97", "filename": "crates/ide_db/src/items_locator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fitems_locator.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -133,9 +133,8 @@ fn get_name_definition(\n     import_candidate: &FileSymbol,\n ) -> Option<Definition> {\n     let _p = profile::span(\"get_name_definition\");\n-    let file_id = import_candidate.file_id;\n \n-    let candidate_node = import_candidate.ptr.to_node(sema.parse(file_id).syntax());\n+    let candidate_node = import_candidate.loc.syntax(sema)?;\n     let candidate_name_node = if candidate_node.kind() != NAME {\n         candidate_node.children().find(|it| it.kind() == NAME)?\n     } else {"}, {"sha": "cc2b2bbb7b84d0d0019a020376157baffddf336b", "filename": "crates/ide_db/src/symbol_index.rs", "status": "modified", "additions": 448, "deletions": 139, "changes": 587, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -30,18 +30,19 @@ use std::{\n \n use base_db::{\n     salsa::{self, ParallelDatabase},\n-    CrateId, FileId, SourceDatabaseExt, SourceRootId,\n+    CrateId, FileRange, SourceDatabaseExt, SourceRootId, Upcast,\n };\n+use either::Either;\n use fst::{self, Streamer};\n-use hir::db::DefDatabase;\n-use rayon::prelude::*;\n-use rustc_hash::{FxHashMap, FxHashSet};\n-use syntax::{\n-    ast::{self, HasName},\n-    match_ast, AstNode, Parse, SmolStr, SourceFile,\n-    SyntaxKind::*,\n-    SyntaxNode, SyntaxNodePtr, TextRange, WalkEvent,\n+use hir::{\n+    db::{DefDatabase, HirDatabase},\n+    AdtId, AssocContainerId, AssocItemId, AssocItemLoc, DefHasSource, DefWithBodyId, HasSource,\n+    HirFileId, ImplId, InFile, ItemLoc, ItemTreeNode, Lookup, MacroDef, Module, ModuleDefId,\n+    ModuleId, Semantics, TraitId,\n };\n+use rayon::prelude::*;\n+use rustc_hash::FxHashSet;\n+use syntax::{ast::HasName, AstNode, SmolStr, SyntaxNode, SyntaxNodePtr};\n \n use crate::RootDatabase;\n \n@@ -92,58 +93,68 @@ impl Query {\n }\n \n #[salsa::query_group(SymbolsDatabaseStorage)]\n-pub trait SymbolsDatabase: hir::db::HirDatabase + SourceDatabaseExt {\n-    fn file_symbols(&self, file_id: FileId) -> Arc<SymbolIndex>;\n-    fn library_symbols(&self) -> Arc<FxHashMap<SourceRootId, SymbolIndex>>;\n+pub trait SymbolsDatabase: HirDatabase + SourceDatabaseExt + Upcast<dyn HirDatabase> {\n+    /// The symbol index for a given module. These modules should only be in source roots that\n+    /// are inside local_roots.\n+    fn module_symbols(&self, module_id: ModuleId) -> Arc<SymbolIndex>;\n+\n+    /// The symbol index for a given source root within library_roots.\n+    fn library_symbols(&self, source_root_id: SourceRootId) -> Arc<SymbolIndex>;\n+\n     /// The set of \"local\" (that is, from the current workspace) roots.\n     /// Files in local roots are assumed to change frequently.\n     #[salsa::input]\n     fn local_roots(&self) -> Arc<FxHashSet<SourceRootId>>;\n+\n     /// The set of roots for crates.io libraries.\n     /// Files in libraries are assumed to never change.\n     #[salsa::input]\n     fn library_roots(&self) -> Arc<FxHashSet<SourceRootId>>;\n }\n \n-fn library_symbols(db: &dyn SymbolsDatabase) -> Arc<FxHashMap<SourceRootId, SymbolIndex>> {\n+fn library_symbols(db: &dyn SymbolsDatabase, source_root_id: SourceRootId) -> Arc<SymbolIndex> {\n     let _p = profile::span(\"library_symbols\");\n \n-    let roots = db.library_roots();\n-    let res = roots\n+    // todo: this could be parallelized, once I figure out how to do that...\n+    let symbols = db\n+        .source_root_crates(source_root_id)\n         .iter()\n-        .map(|&root_id| {\n-            let root = db.source_root(root_id);\n-            let files = root\n-                .iter()\n-                .map(|it| (it, SourceDatabaseExt::file_text(db, it)))\n-                .collect::<Vec<_>>();\n-            let symbol_index = SymbolIndex::for_files(\n-                files.into_par_iter().map(|(file, text)| (file, SourceFile::parse(&text))),\n-            );\n-            (root_id, symbol_index)\n-        })\n+        .flat_map(|&krate| module_ids_for_crate(db.upcast(), krate))\n+        // we specifically avoid calling SymbolsDatabase::module_symbols here, even they do the same thing,\n+        // as the index for a library is not going to really ever change, and we do not want to store each\n+        // module's index in salsa.\n+        .map(|module_id| SymbolCollector::collect(db, module_id))\n+        .flatten()\n         .collect();\n-    Arc::new(res)\n-}\n-\n-fn file_symbols(db: &dyn SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex> {\n-    db.unwind_if_cancelled();\n-    let parse = db.parse(file_id);\n-\n-    let symbols = source_file_to_file_symbols(&parse.tree(), file_id);\n \n-    // FIXME: add macros here\n+    Arc::new(SymbolIndex::new(symbols))\n+}\n \n+fn module_symbols(db: &dyn SymbolsDatabase, module_id: ModuleId) -> Arc<SymbolIndex> {\n+    let _p = profile::span(\"module_symbols\");\n+    let symbols = SymbolCollector::collect(db, module_id);\n     Arc::new(SymbolIndex::new(symbols))\n }\n \n /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n struct Snap<DB>(DB);\n+impl<DB: ParallelDatabase> Snap<salsa::Snapshot<DB>> {\n+    fn new(db: &DB) -> Self {\n+        Self(db.snapshot())\n+    }\n+}\n impl<DB: ParallelDatabase> Clone for Snap<salsa::Snapshot<DB>> {\n     fn clone(&self) -> Snap<salsa::Snapshot<DB>> {\n         Snap(self.0.snapshot())\n     }\n }\n+impl<DB> std::ops::Deref for Snap<DB> {\n+    type Target = DB;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n \n // Feature: Workspace Symbol\n //\n@@ -174,51 +185,45 @@ impl<DB: ParallelDatabase> Clone for Snap<salsa::Snapshot<DB>> {\n pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n     let _p = profile::span(\"world_symbols\").detail(|| query.query.clone());\n \n-    let tmp1;\n-    let tmp2;\n-    let buf: Vec<&SymbolIndex> = if query.libs {\n-        tmp1 = db.library_symbols();\n-        tmp1.values().collect()\n+    let indices: Vec<_> = if query.libs {\n+        db.library_roots()\n+            .par_iter()\n+            .map_with(Snap::new(db), |snap, &root| snap.library_symbols(root))\n+            .collect()\n     } else {\n-        let mut files = Vec::new();\n+        let mut module_ids = Vec::new();\n+\n         for &root in db.local_roots().iter() {\n-            let sr = db.source_root(root);\n-            files.extend(sr.iter())\n+            let crates = db.source_root_crates(root);\n+            for &krate in crates.iter() {\n+                module_ids.extend(module_ids_for_crate(db, krate));\n+            }\n         }\n \n-        let snap = Snap(db.snapshot());\n-        tmp2 = files\n+        module_ids\n             .par_iter()\n-            .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n-            .collect::<Vec<_>>();\n-        tmp2.iter().map(|it| &**it).collect()\n+            .map_with(Snap::new(db), |snap, &module_id| snap.module_symbols(module_id))\n+            .collect()\n     };\n-    query.search(&buf)\n+\n+    query.search(&indices)\n }\n \n pub fn crate_symbols(db: &RootDatabase, krate: CrateId, query: Query) -> Vec<FileSymbol> {\n     let _p = profile::span(\"crate_symbols\").detail(|| format!(\"{:?}\", query));\n-    // FIXME(#4842): This now depends on DefMap, why not build the entire symbol index from\n-    // that instead?\n \n-    let def_map = db.crate_def_map(krate);\n-    let mut files = Vec::new();\n-    let mut modules = vec![def_map.root()];\n-    while let Some(module) = modules.pop() {\n-        let data = &def_map[module];\n-        files.extend(data.origin.file_id());\n-        modules.extend(data.children.values());\n-    }\n-\n-    let snap = Snap(db.snapshot());\n-\n-    let buf = files\n+    let module_ids = module_ids_for_crate(db, krate);\n+    let indices: Vec<_> = module_ids\n         .par_iter()\n-        .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n-        .collect::<Vec<_>>();\n-    let buf = buf.iter().map(|it| &**it).collect::<Vec<_>>();\n+        .map_with(Snap::new(db), |snap, &module_id| snap.module_symbols(module_id))\n+        .collect();\n \n-    query.search(&buf)\n+    query.search(&indices)\n+}\n+\n+fn module_ids_for_crate(db: &dyn DefDatabase, krate: CrateId) -> Vec<ModuleId> {\n+    let def_map = db.crate_def_map(krate);\n+    def_map.modules().map(|(id, _)| def_map.module_id(id)).collect()\n }\n \n pub fn index_resolve(db: &RootDatabase, name: &str) -> Vec<FileSymbol> {\n@@ -297,15 +302,6 @@ impl SymbolIndex {\n         self.map.as_fst().size() + self.symbols.len() * mem::size_of::<FileSymbol>()\n     }\n \n-    pub(crate) fn for_files(\n-        files: impl ParallelIterator<Item = (FileId, Parse<ast::SourceFile>)>,\n-    ) -> SymbolIndex {\n-        let symbols = files\n-            .flat_map(|(file_id, file)| source_file_to_file_symbols(&file.tree(), file_id))\n-            .collect::<Vec<_>>();\n-        SymbolIndex::new(symbols)\n-    }\n-\n     fn range_to_map_value(start: usize, end: usize) -> u64 {\n         debug_assert![start <= (std::u32::MAX as usize)];\n         debug_assert![end <= (std::u32::MAX as usize)];\n@@ -321,7 +317,7 @@ impl SymbolIndex {\n }\n \n impl Query {\n-    pub(crate) fn search(self, indices: &[&SymbolIndex]) -> Vec<FileSymbol> {\n+    pub(crate) fn search(self, indices: &[Arc<SymbolIndex>]) -> Vec<FileSymbol> {\n         let _p = profile::span(\"symbol_index::Query::search\");\n         let mut op = fst::map::OpBuilder::new();\n         for file_symbols in indices.iter() {\n@@ -364,15 +360,49 @@ impl Query {\n /// possible.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FileSymbol {\n-    pub file_id: FileId,\n     pub name: SmolStr,\n+    pub loc: DeclarationLocation,\n     pub kind: FileSymbolKind,\n-    pub range: TextRange,\n-    pub ptr: SyntaxNodePtr,\n-    pub name_range: Option<TextRange>,\n     pub container_name: Option<SmolStr>,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DeclarationLocation {\n+    /// The file id for both the `ptr` and `name_ptr`.\n+    pub hir_file_id: HirFileId,\n+    /// This points to the whole syntax node of the declaration.\n+    pub ptr: SyntaxNodePtr,\n+    /// This points to the [`syntax::ast::Name`] identifier of the declaration.\n+    pub name_ptr: SyntaxNodePtr,\n+}\n+\n+impl DeclarationLocation {\n+    pub fn syntax(&self, semantics: &Semantics<'_, RootDatabase>) -> Option<SyntaxNode> {\n+        let root = semantics.parse_or_expand(self.hir_file_id)?;\n+        Some(self.ptr.to_node(&root))\n+    }\n+\n+    pub fn original_range(&self, db: &dyn HirDatabase) -> Option<FileRange> {\n+        find_original_file_range(db, self.hir_file_id, &self.ptr)\n+    }\n+\n+    pub fn original_name_range(&self, db: &dyn HirDatabase) -> Option<FileRange> {\n+        find_original_file_range(db, self.hir_file_id, &self.name_ptr)\n+    }\n+}\n+\n+fn find_original_file_range(\n+    db: &dyn HirDatabase,\n+    file_id: HirFileId,\n+    ptr: &SyntaxNodePtr,\n+) -> Option<FileRange> {\n+    let root = db.parse_or_expand(file_id)?;\n+    let node = ptr.to_node(&root);\n+    let node = InFile::new(file_id, &node);\n+\n+    Some(node.original_file_range(db.upcast()))\n+}\n+\n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum FileSymbolKind {\n     Const,\n@@ -400,79 +430,358 @@ impl FileSymbolKind {\n     }\n }\n \n-fn source_file_to_file_symbols(source_file: &SourceFile, file_id: FileId) -> Vec<FileSymbol> {\n-    let mut symbols = Vec::new();\n-    let mut stack = Vec::new();\n+/// Represents an outstanding module that the symbol collector must collect symbols from.\n+struct SymbolCollectorWork {\n+    module_id: ModuleId,\n+    parent: Option<DefWithBodyId>,\n+}\n+\n+struct SymbolCollector<'a> {\n+    db: &'a dyn SymbolsDatabase,\n+    symbols: Vec<FileSymbol>,\n+    work: Vec<SymbolCollectorWork>,\n+    current_container_name: Option<SmolStr>,\n+}\n+\n+/// Given a [`ModuleId`] and a [`SymbolsDatabase`], use the DefMap for the module's crate to collect all symbols that should be\n+/// indexed for the given module.\n+impl<'a> SymbolCollector<'a> {\n+    fn collect(db: &dyn SymbolsDatabase, module_id: ModuleId) -> Vec<FileSymbol> {\n+        let mut symbol_collector = SymbolCollector {\n+            db,\n+            symbols: Default::default(),\n+            current_container_name: None,\n+            // The initial work is the root module we're collecting, additional work will\n+            // be populated as we traverse the module's definitions.\n+            work: vec![SymbolCollectorWork { module_id, parent: None }],\n+        };\n+\n+        while let Some(work) = symbol_collector.work.pop() {\n+            symbol_collector.do_work(work);\n+        }\n+\n+        symbol_collector.symbols\n+    }\n+\n+    fn do_work(&mut self, work: SymbolCollectorWork) {\n+        self.db.unwind_if_cancelled();\n+\n+        let parent_name = work.parent.and_then(|id| self.def_with_body_id_name(id));\n+        self.with_container_name(parent_name, |s| s.collect_from_module(work.module_id));\n+    }\n \n-    for event in source_file.syntax().preorder() {\n-        match event {\n-            WalkEvent::Enter(node) => {\n-                if let Some(mut symbol) = to_file_symbol(&node, file_id) {\n-                    symbol.container_name = stack.last().cloned();\n+    fn collect_from_module(&mut self, module_id: ModuleId) {\n+        let def_map = module_id.def_map(self.db.upcast());\n+        let scope = &def_map[module_id.local_id].scope;\n \n-                    stack.push(symbol.name.clone());\n-                    symbols.push(symbol);\n+        for module_def_id in scope.declarations() {\n+            match module_def_id {\n+                ModuleDefId::ModuleId(id) => self.push_module(id),\n+                ModuleDefId::FunctionId(id) => {\n+                    self.push_decl_assoc(id, FileSymbolKind::Function);\n+                    self.collect_from_body(id);\n+                }\n+                ModuleDefId::AdtId(AdtId::StructId(id)) => {\n+                    self.push_decl(id, FileSymbolKind::Struct)\n+                }\n+                ModuleDefId::AdtId(AdtId::EnumId(id)) => self.push_decl(id, FileSymbolKind::Enum),\n+                ModuleDefId::AdtId(AdtId::UnionId(id)) => self.push_decl(id, FileSymbolKind::Union),\n+                ModuleDefId::ConstId(id) => {\n+                    self.push_decl_assoc(id, FileSymbolKind::Const);\n+                    self.collect_from_body(id);\n+                }\n+                ModuleDefId::StaticId(id) => {\n+                    self.push_decl(id, FileSymbolKind::Static);\n+                    self.collect_from_body(id);\n+                }\n+                ModuleDefId::TraitId(id) => {\n+                    self.push_decl(id, FileSymbolKind::Trait);\n+                    self.collect_from_trait(id);\n                 }\n+                ModuleDefId::TypeAliasId(id) => {\n+                    self.push_decl_assoc(id, FileSymbolKind::TypeAlias);\n+                }\n+                // Don't index these.\n+                ModuleDefId::BuiltinType(_) => {}\n+                ModuleDefId::EnumVariantId(_) => {}\n             }\n+        }\n+\n+        for impl_id in scope.impls() {\n+            self.collect_from_impl(impl_id);\n+        }\n \n-            WalkEvent::Leave(node) => {\n-                if to_symbol(&node).is_some() {\n-                    stack.pop();\n+        for const_id in scope.unnamed_consts() {\n+            self.collect_from_body(const_id);\n+        }\n+\n+        for macro_def_id in scope.macro_declarations() {\n+            self.push_decl_macro(macro_def_id.into());\n+        }\n+    }\n+\n+    fn collect_from_body(&mut self, body_id: impl Into<DefWithBodyId>) {\n+        let body_id = body_id.into();\n+        let body = self.db.body(body_id);\n+\n+        // Descend into the blocks and enqueue collection of all modules within.\n+        for (_, def_map) in body.blocks(self.db.upcast()) {\n+            for (id, _) in def_map.modules() {\n+                self.work.push(SymbolCollectorWork {\n+                    module_id: def_map.module_id(id),\n+                    parent: Some(body_id),\n+                });\n+            }\n+        }\n+    }\n+\n+    fn collect_from_impl(&mut self, impl_id: ImplId) {\n+        let impl_data = self.db.impl_data(impl_id);\n+        for &assoc_item_id in &impl_data.items {\n+            self.push_assoc_item(assoc_item_id)\n+        }\n+    }\n+\n+    fn collect_from_trait(&mut self, trait_id: TraitId) {\n+        let trait_data = self.db.trait_data(trait_id);\n+        self.with_container_name(trait_data.name.as_text(), |s| {\n+            for &(_, assoc_item_id) in &trait_data.items {\n+                s.push_assoc_item(assoc_item_id);\n+            }\n+        });\n+    }\n+\n+    fn with_container_name(&mut self, container_name: Option<SmolStr>, f: impl FnOnce(&mut Self)) {\n+        if let Some(container_name) = container_name {\n+            let prev = self.current_container_name.replace(container_name);\n+            f(self);\n+            self.current_container_name = prev;\n+        } else {\n+            f(self);\n+        }\n+    }\n+\n+    fn current_container_name(&self) -> Option<SmolStr> {\n+        self.current_container_name.clone()\n+    }\n+\n+    fn def_with_body_id_name(&self, body_id: DefWithBodyId) -> Option<SmolStr> {\n+        match body_id {\n+            DefWithBodyId::FunctionId(id) => Some(\n+                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n+            ),\n+            DefWithBodyId::StaticId(id) => Some(\n+                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n+            ),\n+            DefWithBodyId::ConstId(id) => Some(\n+                id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n+            ),\n+        }\n+    }\n+\n+    fn push_assoc_item(&mut self, assoc_item_id: AssocItemId) {\n+        match assoc_item_id {\n+            AssocItemId::FunctionId(id) => self.push_decl_assoc(id, FileSymbolKind::Function),\n+            AssocItemId::ConstId(id) => self.push_decl_assoc(id, FileSymbolKind::Const),\n+            AssocItemId::TypeAliasId(id) => self.push_decl_assoc(id, FileSymbolKind::TypeAlias),\n+        }\n+    }\n+\n+    fn push_decl_assoc<L, T>(&mut self, id: L, kind: FileSymbolKind)\n+    where\n+        L: Lookup<Data = AssocItemLoc<T>>,\n+        T: ItemTreeNode,\n+        <T as ItemTreeNode>::Source: HasName,\n+    {\n+        fn container_name(db: &dyn HirDatabase, container: AssocContainerId) -> Option<SmolStr> {\n+            match container {\n+                AssocContainerId::ModuleId(module_id) => {\n+                    let module = Module::from(module_id);\n+                    module.name(db).and_then(|name| name.as_text())\n                 }\n+                AssocContainerId::TraitId(trait_id) => {\n+                    let trait_data = db.trait_data(trait_id);\n+                    trait_data.name.as_text()\n+                }\n+                AssocContainerId::ImplId(_) => None,\n             }\n         }\n+\n+        self.push_file_symbol(|s| {\n+            let loc = id.lookup(s.db.upcast());\n+            let source = loc.source(s.db.upcast());\n+            let name_node = source.value.name()?;\n+            let container_name =\n+                container_name(s.db.upcast(), loc.container).or_else(|| s.current_container_name());\n+\n+            Some(FileSymbol {\n+                name: name_node.text().into(),\n+                kind,\n+                container_name,\n+                loc: DeclarationLocation {\n+                    hir_file_id: source.file_id,\n+                    ptr: SyntaxNodePtr::new(source.value.syntax()),\n+                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n+                },\n+            })\n+        })\n     }\n \n-    symbols\n-}\n+    fn push_decl<L, T>(&mut self, id: L, kind: FileSymbolKind)\n+    where\n+        L: Lookup<Data = ItemLoc<T>>,\n+        T: ItemTreeNode,\n+        <T as ItemTreeNode>::Source: HasName,\n+    {\n+        self.push_file_symbol(|s| {\n+            let loc = id.lookup(s.db.upcast());\n+            let source = loc.source(s.db.upcast());\n+            let name_node = source.value.name()?;\n+\n+            Some(FileSymbol {\n+                name: name_node.text().into(),\n+                kind,\n+                container_name: s.current_container_name(),\n+                loc: DeclarationLocation {\n+                    hir_file_id: source.file_id,\n+                    ptr: SyntaxNodePtr::new(source.value.syntax()),\n+                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n+                },\n+            })\n+        })\n+    }\n+\n+    fn push_module(&mut self, module_id: ModuleId) {\n+        self.push_file_symbol(|s| {\n+            let def_map = module_id.def_map(s.db.upcast());\n+            let module_data = &def_map[module_id.local_id];\n+            let declaration = module_data.origin.declaration()?;\n+            let module = declaration.to_node(s.db.upcast());\n+            let name_node = module.name()?;\n+\n+            Some(FileSymbol {\n+                name: name_node.text().into(),\n+                kind: FileSymbolKind::Module,\n+                container_name: s.current_container_name(),\n+                loc: DeclarationLocation {\n+                    hir_file_id: declaration.file_id,\n+                    ptr: SyntaxNodePtr::new(module.syntax()),\n+                    name_ptr: SyntaxNodePtr::new(name_node.syntax()),\n+                },\n+            })\n+        })\n+    }\n \n-fn to_symbol(node: &SyntaxNode) -> Option<(SmolStr, SyntaxNodePtr, TextRange)> {\n-    fn decl<N: HasName>(node: N) -> Option<(SmolStr, SyntaxNodePtr, TextRange)> {\n-        let name = node.name()?;\n-        let name_range = name.syntax().text_range();\n-        let name = name.text().into();\n-        let ptr = SyntaxNodePtr::new(node.syntax());\n+    fn push_decl_macro(&mut self, macro_def: MacroDef) {\n+        self.push_file_symbol(|s| {\n+            let name = macro_def.name(s.db.upcast())?.as_text()?;\n+            let source = macro_def.source(s.db.upcast())?;\n \n-        Some((name, ptr, name_range))\n+            let (ptr, name_ptr) = match source.value {\n+                Either::Left(m) => {\n+                    (SyntaxNodePtr::new(m.syntax()), SyntaxNodePtr::new(m.name()?.syntax()))\n+                }\n+                Either::Right(f) => {\n+                    (SyntaxNodePtr::new(f.syntax()), SyntaxNodePtr::new(f.name()?.syntax()))\n+                }\n+            };\n+\n+            Some(FileSymbol {\n+                name,\n+                kind: FileSymbolKind::Macro,\n+                container_name: s.current_container_name(),\n+                loc: DeclarationLocation { hir_file_id: source.file_id, name_ptr, ptr },\n+            })\n+        })\n     }\n-    match_ast! {\n-        match node {\n-            ast::Fn(it) => decl(it),\n-            ast::Struct(it) => decl(it),\n-            ast::Enum(it) => decl(it),\n-            ast::Trait(it) => decl(it),\n-            ast::Module(it) => decl(it),\n-            ast::TypeAlias(it) => decl(it),\n-            ast::Const(it) => decl(it),\n-            ast::Static(it) => decl(it),\n-            ast::Macro(it) => decl(it),\n-            ast::Union(it) => decl(it),\n-            _ => None,\n+\n+    fn push_file_symbol(&mut self, f: impl FnOnce(&Self) -> Option<FileSymbol>) {\n+        if let Some(file_symbol) = f(self) {\n+            self.symbols.push(file_symbol);\n         }\n     }\n }\n \n-fn to_file_symbol(node: &SyntaxNode, file_id: FileId) -> Option<FileSymbol> {\n-    to_symbol(node).map(move |(name, ptr, name_range)| FileSymbol {\n-        name,\n-        kind: match node.kind() {\n-            FN => FileSymbolKind::Function,\n-            STRUCT => FileSymbolKind::Struct,\n-            ENUM => FileSymbolKind::Enum,\n-            TRAIT => FileSymbolKind::Trait,\n-            MODULE => FileSymbolKind::Module,\n-            TYPE_ALIAS => FileSymbolKind::TypeAlias,\n-            CONST => FileSymbolKind::Const,\n-            STATIC => FileSymbolKind::Static,\n-            MACRO_RULES => FileSymbolKind::Macro,\n-            MACRO_DEF => FileSymbolKind::Macro,\n-            UNION => FileSymbolKind::Union,\n-            kind => unreachable!(\"{:?}\", kind),\n-        },\n-        range: node.text_range(),\n-        ptr,\n-        file_id,\n-        name_range: Some(name_range),\n-        container_name: None,\n-    })\n+#[cfg(test)]\n+mod tests {\n+\n+    use base_db::fixture::WithFixture;\n+    use expect_test::expect_file;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_symbol_index_collection() {\n+        let (db, _) = RootDatabase::with_many_files(\n+            r#\"\n+//- /main.rs\n+\n+macro_rules! macro_rules_macro {\n+    () => {}\n+};\n+\n+macro_rules! define_struct {\n+    () => {\n+        struct StructFromMacro;\n+    }\n+};\n+\n+define_struct!();\n+\n+macro Macro { }\n+\n+struct Struct;\n+enum Enum {\n+    A, B\n+}\n+union Union {}\n+\n+impl Struct {\n+    fn impl_fn() {}\n+}\n+\n+trait Trait {\n+    fn trait_fn(&self);\n+}\n+\n+fn main() {\n+    struct StructInFn;\n+}\n+\n+const CONST: u32 = 1;\n+static STATIC: &'static str = \"2\";\n+type Alias = Struct;\n+\n+mod a_mod {\n+    struct StructInModA;\n+}\n+\n+const _: () = {\n+    struct StructInUnnamedConst;\n+\n+    ()\n+};\n+\n+const CONST_WITH_INNER: () = {\n+    struct StructInNamedConst;\n+\n+    ()\n+};\n+\n+mod b_mod;\n+\n+//- /b_mod.rs\n+struct StructInModB;\n+        \"#,\n+        );\n+\n+        let symbols: Vec<_> = module_ids_for_crate(db.upcast(), db.test_crate())\n+            .into_iter()\n+            .map(|module_id| {\n+                (module_id, SymbolCollector::collect(&db as &dyn SymbolsDatabase, module_id))\n+            })\n+            .collect();\n+\n+        expect_file![\"./test_data/test_symbol_index_collection.txt\"].assert_debug_eq(&symbols);\n+    }\n }"}, {"sha": "fe6eebc4f01d060098e4b211804aa57b79351c6e", "filename": "crates/ide_db/src/test_data/test_symbol_index_collection.txt", "status": "added", "additions": 527, "deletions": 0, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide_db%2Fsrc%2Ftest_data%2Ftest_symbol_index_collection.txt", "raw_url": "https://github.com/rust-lang/rust/raw/2d0db312b543343f1c208b6be21a7a001cec7dd6/crates%2Fide_db%2Fsrc%2Ftest_data%2Ftest_symbol_index_collection.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ftest_data%2Ftest_symbol_index_collection.txt?ref=2d0db312b543343f1c208b6be21a7a001cec7dd6", "patch": "@@ -0,0 +1,527 @@\n+[\n+    (\n+        ModuleId {\n+            krate: CrateId(\n+                0,\n+            ),\n+            block: None,\n+            local_id: Idx::<ModuleData>(0),\n+        },\n+        [\n+            FileSymbol {\n+                name: \"StructFromMacro\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        MacroFile(\n+                            MacroFile {\n+                                macro_call_id: MacroCallId(\n+                                    0,\n+                                ),\n+                            },\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 0..22,\n+                        kind: STRUCT,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 6..21,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Struct,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"Struct\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 170..184,\n+                        kind: STRUCT,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 177..183,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Struct,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"Enum\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 185..207,\n+                        kind: ENUM,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 190..194,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Enum,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"Union\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 208..222,\n+                        kind: UNION,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 214..219,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Union,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"Trait\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 261..300,\n+                        kind: TRAIT,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 267..272,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Trait,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"trait_fn\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 279..298,\n+                        kind: FN,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 282..290,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Function,\n+                container_name: Some(\n+                    \"Trait\",\n+                ),\n+            },\n+            FileSymbol {\n+                name: \"main\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 302..338,\n+                        kind: FN,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 305..309,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Function,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"CONST\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 340..361,\n+                        kind: CONST,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 346..351,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Const,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"STATIC\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 362..396,\n+                        kind: STATIC,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 369..375,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Static,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"Alias\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 397..417,\n+                        kind: TYPE_ALIAS,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 402..407,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: TypeAlias,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"a_mod\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 419..457,\n+                        kind: MODULE,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 423..428,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Module,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"CONST_WITH_INNER\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 520..592,\n+                        kind: CONST,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 526..542,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Const,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"b_mod\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 594..604,\n+                        kind: MODULE,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 598..603,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Module,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"impl_fn\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 242..257,\n+                        kind: FN,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 245..252,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Function,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"macro_rules_macro\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 1..48,\n+                        kind: MACRO_RULES,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 14..31,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Macro,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"define_struct\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 51..131,\n+                        kind: MACRO_RULES,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 64..77,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Macro,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"Macro\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 153..168,\n+                        kind: MACRO_DEF,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 159..164,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Macro,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"StructInUnnamedConst\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 479..507,\n+                        kind: STRUCT,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 486..506,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Struct,\n+                container_name: None,\n+            },\n+            FileSymbol {\n+                name: \"StructInNamedConst\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 555..581,\n+                        kind: STRUCT,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 562..580,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Struct,\n+                container_name: Some(\n+                    \"CONST_WITH_INNER\",\n+                ),\n+            },\n+            FileSymbol {\n+                name: \"StructInFn\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 318..336,\n+                        kind: STRUCT,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 325..335,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Struct,\n+                container_name: Some(\n+                    \"main\",\n+                ),\n+            },\n+        ],\n+    ),\n+    (\n+        ModuleId {\n+            krate: CrateId(\n+                0,\n+            ),\n+            block: None,\n+            local_id: Idx::<ModuleData>(1),\n+        },\n+        [\n+            FileSymbol {\n+                name: \"StructInModA\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                0,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 435..455,\n+                        kind: STRUCT,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 442..454,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Struct,\n+                container_name: None,\n+            },\n+        ],\n+    ),\n+    (\n+        ModuleId {\n+            krate: CrateId(\n+                0,\n+            ),\n+            block: None,\n+            local_id: Idx::<ModuleData>(2),\n+        },\n+        [\n+            FileSymbol {\n+                name: \"StructInModB\",\n+                loc: DeclarationLocation {\n+                    hir_file_id: HirFileId(\n+                        FileId(\n+                            FileId(\n+                                1,\n+                            ),\n+                        ),\n+                    ),\n+                    ptr: SyntaxNodePtr {\n+                        range: 0..20,\n+                        kind: STRUCT,\n+                    },\n+                    name_ptr: SyntaxNodePtr {\n+                        range: 7..19,\n+                        kind: NAME,\n+                    },\n+                },\n+                kind: Struct,\n+                container_name: None,\n+            },\n+        ],\n+    ),\n+]"}]}