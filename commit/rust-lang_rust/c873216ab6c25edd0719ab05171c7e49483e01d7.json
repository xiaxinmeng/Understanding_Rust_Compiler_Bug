{"sha": "c873216ab6c25edd0719ab05171c7e49483e01d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NzMyMTZhYjZjMjVlZGQwNzE5YWIwNTE3MWM3ZTQ5NDgzZTAxZDc=", "commit": {"author": {"name": "kud1ing", "email": "github@kudling.de", "date": "2013-09-26T06:12:30Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-26T13:15:42Z"}, "message": "bigint: backticks for code in documentation", "tree": {"sha": "0d559c4547493c6c462a0e4a619a34afb246fc79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d559c4547493c6c462a0e4a619a34afb246fc79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c873216ab6c25edd0719ab05171c7e49483e01d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c873216ab6c25edd0719ab05171c7e49483e01d7", "html_url": "https://github.com/rust-lang/rust/commit/c873216ab6c25edd0719ab05171c7e49483e01d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c873216ab6c25edd0719ab05171c7e49483e01d7/comments", "author": null, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d964f799987d3f14ad67582dc74f1e95026fb70f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d964f799987d3f14ad67582dc74f1e95026fb70f", "html_url": "https://github.com/rust-lang/rust/commit/d964f799987d3f14ad67582dc74f1e95026fb70f"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "efb39f7c51e027f039c4a52ec5e389f6ad0aa6a5", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c873216ab6c25edd0719ab05171c7e49483e01d7/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c873216ab6c25edd0719ab05171c7e49483e01d7/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=c873216ab6c25edd0719ab05171c7e49483e01d7", "patch": "@@ -10,10 +10,10 @@\n \n /*!\n \n-A Big integer (signed version: BigInt, unsigned version: BigUint).\n+A Big integer (signed version: `BigInt`, unsigned version: `BigUint`).\n \n-A BigUint is represented as an array of BigDigits.\n-A BigInt is a combination of BigUint and Sign.\n+A `BigUint` is represented as an array of `BigDigit`s.\n+A `BigInt` is a combination of `BigUint` and `Sign`.\n */\n \n #[allow(missing_doc)];\n@@ -29,17 +29,17 @@ use std::uint;\n use std::vec;\n \n /**\n-A BigDigit is a BigUint's composing element.\n+A `BigDigit` is a `BigUint`'s composing element.\n \n-A BigDigit is half the size of machine word size.\n+A `BigDigit` is half the size of machine word size.\n */\n #[cfg(target_word_size = \"32\")]\n pub type BigDigit = u16;\n \n /**\n-A BigDigit is a BigUint's composing element.\n+A `BigDigit` is a `BigUint`'s composing element.\n \n-A BigDigit is half the size of machine word size.\n+A `BigDigit` is half the size of machine word size.\n */\n #[cfg(target_word_size = \"64\")]\n pub type BigDigit = u32;\n@@ -64,13 +64,13 @@ pub mod BigDigit {\n     #[inline]\n     fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n-    /// Split one machine sized unsigned integer into two BigDigits.\n+    /// Split one machine sized unsigned integer into two `BigDigit`s.\n     #[inline]\n     pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n-    /// Join two BigDigits into one machine sized unsigned integer\n+    /// Join two `BigDigit`s into one machine sized unsigned integer\n     #[inline]\n     pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n         (lo as uint) | ((hi as uint) << bits)\n@@ -80,8 +80,8 @@ pub mod BigDigit {\n /**\n A big unsigned integer type.\n \n-A BigUint-typed value BigUint { data: @[a, b, c] } represents a number\n-(a + b * BigDigit::base + c * BigDigit::base^2).\n+A `BigUint`-typed value `BigUint { data: @[a, b, c] }` represents a number\n+`(a + b * BigDigit::base + c * BigDigit::base^2)`.\n */\n #[deriving(Clone)]\n pub struct BigUint {\n@@ -550,7 +550,7 @@ impl ToStrRadix for BigUint {\n }\n \n impl FromStrRadix for BigUint {\n-    /// Creates and initializes an BigUint.\n+    /// Creates and initializes a `BigUint`.\n     #[inline]\n     fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n@@ -559,7 +559,7 @@ impl FromStrRadix for BigUint {\n }\n \n impl BigUint {\n-    /// Creates and initializes an BigUint.\n+    /// Creates and initializes a `BigUint`.\n     #[inline]\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n@@ -571,7 +571,7 @@ impl BigUint {\n         return BigUint { data: v };\n     }\n \n-    /// Creates and initializes an BigUint.\n+    /// Creates and initializes a `BigUint`.\n     #[inline]\n     pub fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n@@ -581,13 +581,13 @@ impl BigUint {\n         }\n     }\n \n-    /// Creates and initializes an BigUint.\n+    /// Creates and initializes a `BigUint`.\n     #[inline]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(slice.to_owned());\n     }\n \n-    /// Creates and initializes an BigUint.\n+    /// Creates and initializes a `BigUint`.\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n@@ -615,14 +615,14 @@ impl BigUint {\n     }\n \n \n-    /// Converts this BigUint into a uint, failing if the conversion\n+    /// Converts this `BigUint` into a `uint`, failing if the conversion\n     /// would overflow.\n     #[inline]\n     pub fn to_uint(&self) -> uint {\n         self.to_uint_opt().expect(\"BigUint conversion would overflow uint\")\n     }\n \n-    /// Converts this BigUint into a uint, unless it would overflow.\n+    /// Converts this `BigUint` into a `uint`, unless it would overflow.\n     #[inline]\n     pub fn to_uint_opt(&self) -> Option<uint> {\n         match self.data.len() {\n@@ -633,7 +633,7 @@ impl BigUint {\n         }\n     }\n \n-    // Converts this BigUint into an int, unless it would overflow.\n+    /// Converts this `BigUint` into an `int`, unless it would overflow.\n     pub fn to_int_opt(&self) -> Option<int> {\n         self.to_uint_opt().and_then(|n| {\n             // If top bit of uint is set, it's too large to convert to\n@@ -646,7 +646,7 @@ impl BigUint {\n         })\n     }\n \n-    /// Converts this BigUint into a BigInt.\n+    /// Converts this `BigUint` into a `BigInt`.\n     #[inline]\n     pub fn to_bigint(&self) -> BigInt {\n         BigInt::from_biguint(Plus, self.clone())\n@@ -698,7 +698,7 @@ impl BigUint {\n         return BigUint::new(shifted);\n     }\n \n-    /// Determines the fewest bits necessary to express the BigUint.\n+    /// Determines the fewest bits necessary to express the `BigUint`.\n     pub fn bits(&self) -> uint {\n         if self.is_zero() { return 0; }\n         let zeros = self.data.last().leading_zeros();\n@@ -754,7 +754,7 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n     }\n }\n \n-/// A Sign is a BigInt's composing element.\n+/// A Sign is a `BigInt`'s composing element.\n #[deriving(Eq, Clone)]\n pub enum Sign { Minus, Zero, Plus }\n \n@@ -1117,22 +1117,22 @@ impl FromStrRadix for BigInt {\n }\n \n trait RandBigInt {\n-    /// Generate a random BigUint of the given bit size.\n+    /// Generate a random `BigUint` of the given bit size.\n     fn gen_biguint(&mut self, bit_size: uint) -> BigUint;\n \n     /// Generate a random BigInt of the given bit size.\n     fn gen_bigint(&mut self, bit_size: uint) -> BigInt;\n \n-    /// Generate a random BigUint less than the given bound. Fails\n+    /// Generate a random `BigUint` less than the given bound. Fails\n     /// when the bound is zero.\n     fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;\n \n-    /// Generate a random BigUint within the given range. The lower\n+    /// Generate a random `BigUint` within the given range. The lower\n     /// bound is inclusive; the upper bound is exclusive. Fails when\n     /// the upper bound is not greater than the lower bound.\n     fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;\n \n-    /// Generate a random BigInt within the given range. The lower\n+    /// Generate a random `BigInt` within the given range. The lower\n     /// bound is inclusive; the upper bound is exclusive. Fails when\n     /// the upper bound is not greater than the lower bound.\n     fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;\n@@ -1208,7 +1208,7 @@ impl BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n-    /// Creates and initializes an BigInt.\n+    /// Creates and initializes a `BigInt`.\n     #[inline]\n     pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n@@ -1217,20 +1217,20 @@ impl BigInt {\n         return BigInt { sign: sign, data: data };\n     }\n \n-    /// Creates and initializes an BigInt.\n+    /// Creates and initializes a `BigInt`.\n     #[inline]\n     pub fn from_uint(n: uint) -> BigInt {\n         if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n-    /// Creates and initializes an BigInt.\n+    /// Creates and initializes a `BigInt`.\n     #[inline]\n     pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n-    /// Creates and initializes an BigInt.\n+    /// Creates and initializes a `BigInt`.\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n@@ -1244,14 +1244,14 @@ impl BigInt {\n             .map_move(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n-    /// Converts this BigInt into a uint, failing if the conversion\n+    /// Converts this `BigInt` into a `uint`, failing if the conversion\n     /// would overflow.\n     #[inline]\n     pub fn to_uint(&self) -> uint {\n         self.to_uint_opt().expect(\"BigInt conversion would overflow uint\")\n     }\n \n-    /// Converts this BigInt into a uint, unless it would overflow.\n+    /// Converts this `BigInt` into a `uint`, unless it would overflow.\n     #[inline]\n     pub fn to_uint_opt(&self) -> Option<uint> {\n         match self.sign {\n@@ -1261,7 +1261,7 @@ impl BigInt {\n         }\n     }\n \n-    /// Converts this BigInt into an int, unless it would overflow.\n+    /// Converts this `BigInt` into an `int`, unless it would overflow.\n     pub fn to_int_opt(&self) -> Option<int> {\n         match self.sign {\n             Plus  => self.data.to_int_opt(),\n@@ -1279,14 +1279,14 @@ impl BigInt {\n         }\n     }\n \n-    /// Converts this BigInt into a BigUint, failing if BigInt is\n+    /// Converts this `BigInt` into a `BigUint`, failing if BigInt is\n     /// negative.\n     #[inline]\n     pub fn to_biguint(&self) -> BigUint {\n         self.to_biguint_opt().expect(\"negative BigInt cannot convert to BigUint\")\n     }\n \n-    /// Converts this BigInt into a BigUint, if it's not negative.\n+    /// Converts this `BigInt` into a `BigUint`, if it's not negative.\n     #[inline]\n     pub fn to_biguint_opt(&self) -> Option<BigUint> {\n         match self.sign {"}]}