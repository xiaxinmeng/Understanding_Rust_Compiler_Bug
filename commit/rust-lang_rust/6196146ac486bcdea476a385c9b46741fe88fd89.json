{"sha": "6196146ac486bcdea476a385c9b46741fe88fd89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxOTYxNDZhYzQ4NmJjZGVhNDc2YTM4NWM5YjQ2NzQxZmU4OGZkODk=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-09-08T16:00:06Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-09-08T16:00:06Z"}, "message": "Implement trait objects (cc #14)", "tree": {"sha": "8c788c79515882d08ab1e08861d149e006f2bfa8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c788c79515882d08ab1e08861d149e006f2bfa8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6196146ac486bcdea476a385c9b46741fe88fd89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6196146ac486bcdea476a385c9b46741fe88fd89", "html_url": "https://github.com/rust-lang/rust/commit/6196146ac486bcdea476a385c9b46741fe88fd89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6196146ac486bcdea476a385c9b46741fe88fd89/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62a0203a5a1ec3ba1165b98cdfab9547fa755814", "url": "https://api.github.com/repos/rust-lang/rust/commits/62a0203a5a1ec3ba1165b98cdfab9547fa755814", "html_url": "https://github.com/rust-lang/rust/commit/62a0203a5a1ec3ba1165b98cdfab9547fa755814"}], "stats": {"total": 420, "additions": 243, "deletions": 177}, "files": [{"sha": "96226073ce3f08405a641d9f8a1af77b29249c3a", "filename": "0006-Disable-all-trait-object-unsizing.patch", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/62a0203a5a1ec3ba1165b98cdfab9547fa755814/0006-Disable-all-trait-object-unsizing.patch", "raw_url": "https://github.com/rust-lang/rust/raw/62a0203a5a1ec3ba1165b98cdfab9547fa755814/0006-Disable-all-trait-object-unsizing.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/0006-Disable-all-trait-object-unsizing.patch?ref=62a0203a5a1ec3ba1165b98cdfab9547fa755814", "patch": "@@ -1,137 +0,0 @@\n-From 307aba455c6ee3227d7c522c07761cda19dc716c Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Wed, 29 Aug 2018 14:29:05 +0200\n-Subject: [PATCH] Disable all trait object unsizing\n-\n----\n- src/libcore/alloc.rs        |  2 +-\n- src/libcore/fmt/builders.rs | 13 ++++++++-----\n- src/libcore/fmt/mod.rs      |  3 ++-\n- src/libcore/panic.rs        |  5 +++--\n- src/libcore/slice/mod.rs    |  2 +-\n- 5 files changed, 15 insertions(+), 10 deletions(-)\n-\n-diff --git a/src/libcore/alloc.rs b/src/libcore/alloc.rs\n-index 35e4eea..28b6e2f 100644\n---- a/src/libcore/alloc.rs\n-+++ b/src/libcore/alloc.rs\n-@@ -144,7 +144,7 @@ impl Layout {\n-     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-     #[inline]\n-     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n--        let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n-+        let (size, align) = panic!(); //(mem::size_of_val(t), mem::align_of_val(t));\n-         // See rationale in `new` for why this us using an unsafe variant below\n-         debug_assert!(Layout::from_size_align(size, align).is_ok());\n-         unsafe {\n-diff --git a/src/libcore/fmt/builders.rs b/src/libcore/fmt/builders.rs\n-index 3c5f934..1427ab3 100644\n---- a/src/libcore/fmt/builders.rs\n-+++ b/src/libcore/fmt/builders.rs\n-@@ -18,6 +18,7 @@ struct PadAdapter<'a> {\n- impl<'a> PadAdapter<'a> {\n-     fn wrap<'b, 'c: 'a+'b>(fmt: &'c mut fmt::Formatter, slot: &'b mut Option<Self>)\n-                         -> fmt::Formatter<'b> {\n-+        /*\n-         fmt.wrap_buf(move |buf| {\n-             *slot = Some(PadAdapter {\n-                 buf,\n-@@ -25,6 +26,8 @@ impl<'a> PadAdapter<'a> {\n-             });\n-             slot.as_mut().unwrap()\n-         })\n-+        */\n-+        panic!();\n-     }\n- }\n-\n-@@ -107,7 +110,7 @@ pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,\n- impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n-     /// Adds a new field to the generated struct output.\n-     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n--    pub fn field(&mut self, name: &str, value: &dyn fmt::Debug) -> &mut DebugStruct<'a, 'b> {\n-+    pub fn field(&mut self, name: &str, value: &impl fmt::Debug) -> &mut DebugStruct<'a, 'b> {\n-         self.result = self.result.and_then(|_| {\n-             let prefix = if self.has_fields {\n-                 \",\"\n-@@ -204,7 +207,7 @@ pub fn debug_tuple_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> D\n- impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n-     /// Adds a new field to the generated tuple struct output.\n-     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n--    pub fn field(&mut self, value: &dyn fmt::Debug) -> &mut DebugTuple<'a, 'b> {\n-+    pub fn field(&mut self, value: &impl fmt::Debug) -> &mut DebugTuple<'a, 'b> {\n-         self.result = self.result.and_then(|_| {\n-             let (prefix, space) = if self.fields > 0 {\n-                 (\",\", \" \")\n-@@ -258,7 +261,7 @@ struct DebugInner<'a, 'b: 'a> {\n- }\n-\n- impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n--    fn entry(&mut self, entry: &dyn fmt::Debug) {\n-+    fn entry(&mut self, entry: &impl fmt::Debug) {\n-         self.result = self.result.and_then(|_| {\n-             if self.is_pretty() {\n-                 let mut slot = None;\n-@@ -340,7 +343,7 @@ pub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b\n- impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n-     /// Adds a new entry to the set output.\n-     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n--    pub fn entry(&mut self, entry: &dyn fmt::Debug) -> &mut DebugSet<'a, 'b> {\n-+    pub fn entry(&mut self, entry: &impl fmt::Debug) -> &mut DebugSet<'a, 'b> {\n-         self.inner.entry(entry);\n-         self\n-     }\n-@@ -411,7 +414,7 @@ pub fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a,\n- impl<'a, 'b: 'a> DebugList<'a, 'b> {\n-     /// Adds a new entry to the list output.\n-     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n--    pub fn entry(&mut self, entry: &dyn fmt::Debug) -> &mut DebugList<'a, 'b> {\n-+    pub fn entry(&mut self, entry: &impl fmt::Debug) -> &mut DebugList<'a, 'b> {\n-         self.inner.entry(entry);\n-         self\n-     }\n-diff --git a/src/libcore/fmt/mod.rs b/src/libcore/fmt/mod.rs\n-index 928f95e..ad33906 100644\n---- a/src/libcore/fmt/mod.rs\n-+++ b/src/libcore/fmt/mod.rs\n-@@ -224,7 +224,8 @@ pub trait Write {\n-             }\n-         }\n-\n--        write(&mut Adapter(self), args)\n-+        //write(&mut Adapter(self), args)\n-+        panic!()\n-     }\n- }\n-\n-diff --git a/src/libcore/panic.rs b/src/libcore/panic.rs\n-index 17cac5a..27b7dde 100644\n---- a/src/libcore/panic.rs\n-+++ b/src/libcore/panic.rs\n-@@ -58,8 +58,9 @@ impl<'a> PanicInfo<'a> {\n-     pub fn internal_constructor(message: Option<&'a fmt::Arguments<'a>>,\n-                                 location: Location<'a>)\n-                                 -> Self {\n--        struct NoPayload;\n--        PanicInfo { payload: &NoPayload, location, message }\n-+        //struct NoPayload;\n-+        //PanicInfo { payload: &NoPayload, location, message }\n-+        panic!();\n-     }\n-\n-     #[doc(hidden)]\n-diff --git a/src/libcore/slice/mod.rs b/src/libcore/slice/mod.rs\n-index 88fdd76..8537f0e 100644\n---- a/src/libcore/slice/mod.rs\n-+++ b/src/libcore/slice/mod.rs\n-@@ -4003,7 +4003,7 @@ impl<A> SlicePartialEq<A> for [A]\n-             return true;\n-         }\n-         unsafe {\n--            let size = mem::size_of_val(self);\n-+            let size = panic!(); //mem::size_of_val(self);\n-             memcmp(self.as_ptr() as *const u8,\n-                    other.as_ptr() as *const u8, size) == 0\n-         }\n---\n-2.11.0"}, {"sha": "8e52485c2fc8becde5fd3b61c4b9d0ed7a588ee7", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6196146ac486bcdea476a385c9b46741fe88fd89/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6196146ac486bcdea476a385c9b46741fe88fd89/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6196146ac486bcdea476a385c9b46741fe88fd89", "patch": "@@ -416,6 +416,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"ar 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"byteorder 1.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cranelift 0.21.0 (git+https://github.com/CraneStation/cranelift.git)\",\n  \"cranelift-faerie 0.21.0 (git+https://github.com/CraneStation/cranelift.git)\",\n  \"cranelift-module 0.21.0 (git+https://github.com/CraneStation/cranelift.git)\","}, {"sha": "5a3da6179bef45d292edc51345c91f4de6ceb3d6", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6196146ac486bcdea476a385c9b46741fe88fd89/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6196146ac486bcdea476a385c9b46741fe88fd89/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=6196146ac486bcdea476a385c9b46741fe88fd89", "patch": "@@ -24,6 +24,7 @@ target-lexicon = \"0.0.3\"\n faerie = \"0.5.0\"\n ar = \"0.6.0\"\n bitflags = \"1.0.3\"\n+byteorder = \"1.2.6\"\n \n # Uncomment to use local checkout of cranelift\n #[patch.\"https://github.com/CraneStation/cranelift.git\"]"}, {"sha": "b9614cf00a7abbcb0409096fdaa8f3aceec82e8d", "filename": "examples/mini_core_hello_world.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6196146ac486bcdea476a385c9b46741fe88fd89/examples%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6196146ac486bcdea476a385c9b46741fe88fd89/examples%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fmini_core_hello_world.rs?ref=6196146ac486bcdea476a385c9b46741fe88fd89", "patch": "@@ -31,6 +31,18 @@ impl Termination for () {\n     }\n }\n \n+trait SomeTrait {\n+    fn object_safe(&self);\n+}\n+\n+impl SomeTrait for &'static str {\n+    fn object_safe(&self) {\n+        unsafe {\n+            puts(*self as *const str as *const u8);\n+        }\n+    }\n+}\n+\n #[lang = \"start\"]\n fn start<T: Termination + 'static>(\n     main: fn() -> T,\n@@ -45,15 +57,28 @@ static NUM_REF: &'static u8 = unsafe { &NUM };\n \n fn main() {\n     unsafe {\n-        let slice: &[u8] = b\"Hello\\0\" as &[u8; 6];\n-        if intrinsics::size_of_val(slice) as u8 != 6 {\n-            panic(&(\"eji\", \"frjio\", 0, 0));\n-        };\n-        let ptr: *const u8 = slice as *const [u8] as *const u8;\n-        let world = box \"World!\\0\";\n+        let hello: &[u8] = b\"Hello\\0\" as &[u8; 6];\n+        let ptr: *const u8 = hello as *const [u8] as *const u8;\n         puts(ptr);\n+\n+        let world = box \"World!\\0\";\n         puts(*world as *const str as *const u8);\n-    }\n \n-    //panic(&(\"panic msg\", \"abc.rs\", 0, 43));\n+        if intrinsics::size_of_val(hello) as u8 != 6 {\n+            panic(&(\"\", \"\", 0, 0));\n+        };\n+\n+        let chars = &['C', 'h', 'a', 'r', 's'];\n+        let chars = chars as &[char];\n+        if intrinsics::size_of_val(chars) as u8 != 4 * 5 {\n+            panic(&(\"\", \"\", 0, 0));\n+        }\n+\n+        let a: &dyn SomeTrait = &\"abc\\0\";\n+        a.object_safe();\n+\n+        if intrinsics::size_of_val(a) as u8 != 16 {\n+            panic(&(\"\", \"\", 0, 0));\n+        }\n+    }\n }"}, {"sha": "3d020087e476053e415d0540a0779b9267778a2f", "filename": "src/abi.rs", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6196146ac486bcdea476a385c9b46741fe88fd89/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6196146ac486bcdea476a385c9b46741fe88fd89/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=6196146ac486bcdea476a385c9b46741fe88fd89", "patch": "@@ -50,6 +50,18 @@ fn get_pass_mode<'a, 'tcx: 'a>(\n     }\n }\n \n+fn adjust_arg_for_abi<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    sig: FnSig<'tcx>,\n+    arg: CValue<'tcx>,\n+) -> Value {\n+    match get_pass_mode(fx.tcx, sig.abi, arg.layout().ty, false) {\n+        PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n+        PassMode::ByVal(_) => arg.load_value(fx),\n+        PassMode::ByRef => arg.force_stack(fx),\n+    }\n+}\n+\n pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     fn_ty: Ty<'tcx>,\n@@ -164,12 +176,16 @@ pub fn get_function_name_and_sig<'a, 'tcx>(\n \n impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n     /// Instance must be monomorphized\n-    pub fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n+    pub fn get_function_id(&mut self, inst: Instance<'tcx>) -> FuncId {\n         let (name, sig) = get_function_name_and_sig(self.tcx, inst);\n-        let func_id = self\n-            .module\n+        self.module\n             .declare_function(&name, Linkage::Import, &sig)\n-            .unwrap();\n+            .unwrap()\n+    }\n+\n+    /// Instance must be monomorphized\n+    pub fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n+        let func_id = self.get_function_id(inst);\n         self.module\n             .declare_func_in_func(func_id, &mut self.bcx.func)\n     }\n@@ -468,29 +484,51 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n         PassMode::ByVal(_) => None,\n     };\n \n-    let call_args: Vec<Value> = return_ptr\n-        .into_iter()\n-        .chain(args.into_iter().map(|arg| {\n-            match get_pass_mode(fx.tcx, sig.abi, arg.layout().ty, false) {\n-                PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n-                PassMode::ByVal(_) => arg.load_value(fx),\n-                PassMode::ByRef => arg.force_stack(fx),\n-            }\n-        })).collect::<Vec<_>>();\n-\n-    let call_inst = match fn_ty.sty {\n+    let instance = match fn_ty.sty {\n         ty::FnDef(def_id, substs) => {\n-            let inst = Instance::resolve(fx.tcx, ParamEnv::reveal_all(), def_id, substs).unwrap();\n-            let func_ref = fx.get_function_ref(inst);\n-            fx.bcx.ins().call(func_ref, &call_args)\n+            Some(Instance::resolve(fx.tcx, ParamEnv::reveal_all(), def_id, substs).unwrap())\n         }\n-        ty::FnPtr(_) => {\n-            let func = trans_operand(fx, func);\n-            let func = func.load_value(fx);\n-            let sig = fx.bcx.import_signature(cton_sig_from_fn_ty(fx.tcx, fn_ty));\n-            fx.bcx.ins().call_indirect(sig, func, &call_args)\n-        }\n-        _ => bug!(\"{:?}\", fn_ty),\n+        _ => None,\n+    };\n+\n+    let func_ref: Option<Value>; // Indirect call target\n+\n+    let first_arg = {\n+        if let Some(Instance {\n+            def: InstanceDef::Virtual(_, idx),\n+            ..\n+        }) = instance\n+        {\n+            let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0], idx);\n+            func_ref = Some(method);\n+            Some(ptr)\n+        } else {\n+            func_ref = if instance.is_none() {\n+                let func = trans_operand(fx, func);\n+                Some(func.load_value(fx))\n+            } else {\n+                None\n+            };\n+\n+            args.get(0).map(|arg| adjust_arg_for_abi(fx, sig, *arg))\n+        }.into_iter()\n+    };\n+\n+    let call_args: Vec<Value> = return_ptr\n+        .into_iter()\n+        .chain(first_arg)\n+        .chain(\n+            args.into_iter()\n+                .skip(1)\n+                .map(|arg| adjust_arg_for_abi(fx, sig, arg)),\n+        ).collect::<Vec<_>>();\n+\n+    let sig = fx.bcx.import_signature(cton_sig_from_fn_ty(fx.tcx, fn_ty));\n+    let call_inst = if let Some(func_ref) = func_ref {\n+        fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n+    } else {\n+        let func_ref = fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n+        fx.bcx.ins().call(func_ref, &call_args)\n     };\n \n     match output_pass_mode {\n@@ -610,6 +648,7 @@ fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                             let elem_size = fx.layout_of(elem).size.bytes();\n                             fx.bcx.ins().imul_imm(len, elem_size as i64)\n                         }\n+                        ty::Dynamic(..) => crate::vtable::size_of_obj(fx, args[0]),\n                         ty => unimplemented!(\"size_of_val for {:?}\", ty),\n                     };\n                     ret.write_cvalue(fx, CValue::ByVal(size, usize_layout));"}, {"sha": "caa4eae75f86309491ecfc5e72c0484ecb1bc1ed", "filename": "src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6196146ac486bcdea476a385c9b46741fe88fd89/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6196146ac486bcdea476a385c9b46741fe88fd89/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=6196146ac486bcdea476a385c9b46741fe88fd89", "patch": "@@ -12,7 +12,7 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n pub fn trans_mono_item<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     module: &mut Module<impl Backend>,\n-    caches: &mut Caches,\n+    caches: &mut Caches<'tcx>,\n     ccx: &mut crate::constant::ConstantCx,\n     mono_item: MonoItem<'tcx>,\n ) {\n@@ -59,7 +59,7 @@ fn trans_fn<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     module: &mut Module<impl Backend>,\n     constants: &mut crate::constant::ConstantCx,\n-    caches: &mut Caches,\n+    caches: &mut Caches<'tcx>,\n     instance: Instance<'tcx>,\n ) {\n     // Step 1. Get mir"}, {"sha": "55cf333bbdc8e4ada599a9fa84d39d1abdadef9f", "filename": "src/common.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6196146ac486bcdea476a385c9b46741fe88fd89/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6196146ac486bcdea476a385c9b46741fe88fd89/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=6196146ac486bcdea476a385c9b46741fe88fd89", "patch": "@@ -236,9 +236,13 @@ impl<'tcx> CValue<'tcx> {\n                         }\n                         _ => bug!(\"unsize non array {:?} to slice\", ty),\n                     },\n-                    ty::Dynamic(_, _) => match ty.sty {\n+                    ty::Dynamic(data, _) => match ty.sty {\n                         ty::Dynamic(_, _) => self.load_value_pair(fx),\n-                        _ => unimpl!(\"unsize of type ... to {:?}\", dest.layout().ty),\n+                        _ => {\n+                            let ptr = self.load_value(fx);\n+                            let vtable = crate::vtable::get_vtable(fx, ty, data.principal());\n+                            (ptr, vtable)\n+                        }\n                     },\n                     _ => bug!(\n                         \"unsize of type {:?} to {:?}\",\n@@ -556,7 +560,7 @@ pub struct FunctionCx<'a, 'tcx: 'a, B: Backend + 'a> {\n     pub local_map: HashMap<Local, CPlace<'tcx>>,\n     pub comments: HashMap<Inst, String>,\n     pub constants: &'a mut crate::constant::ConstantCx,\n-    pub caches: &'a mut Caches,\n+    pub caches: &'a mut Caches<'tcx>,\n \n     /// add_global_comment inserts a comment here\n     pub top_nop: Option<Inst>,"}, {"sha": "7e8f5ac0e47e3f47374a905de307afbb13ee4be7", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6196146ac486bcdea476a385c9b46741fe88fd89/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6196146ac486bcdea476a385c9b46741fe88fd89/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=6196146ac486bcdea476a385c9b46741fe88fd89", "patch": "@@ -1,6 +1,7 @@\n #![feature(rustc_private, macro_at_most_once_rep)]\n #![allow(intra_doc_link_resolution_failure)]\n \n+extern crate byteorder;\n extern crate syntax;\n #[macro_use]\n extern crate rustc;\n@@ -53,6 +54,7 @@ mod common;\n mod constant;\n mod metadata;\n mod pretty_clif;\n+mod vtable;\n \n mod prelude {\n     pub use std::any::Any;\n@@ -100,14 +102,16 @@ mod prelude {\n use crate::constant::ConstantCx;\n use crate::prelude::*;\n \n-pub struct Caches {\n+pub struct Caches<'tcx> {\n     pub context: Context,\n+    pub vtables: HashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n }\n \n-impl Caches {\n+impl<'tcx> Caches<'tcx> {\n     fn new() -> Self {\n         Caches {\n             context: Context::new(),\n+            vtables: HashMap::new(),\n         }\n     }\n }"}, {"sha": "4d2382979c976debcc1354a08b96cd2ab389e998", "filename": "src/vtable.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/6196146ac486bcdea476a385c9b46741fe88fd89/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6196146ac486bcdea476a385c9b46741fe88fd89/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=6196146ac486bcdea476a385c9b46741fe88fd89", "patch": "@@ -0,0 +1,129 @@\n+//! See librustc_codegen_llvm/meth.rs for reference\n+\n+use crate::prelude::*;\n+\n+const DROP_FN_INDEX: usize = 0;\n+const SIZE_INDEX: usize = 1;\n+const ALIGN_INDEX: usize = 2;\n+\n+pub fn size_of_obj<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    val: CValue<'tcx>,\n+) -> Value {\n+    let (_ptr, vtable) = val.load_value_pair(fx);\n+    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n+    fx.bcx.ins().load(\n+        pointer_ty(fx.tcx),\n+        MemFlags::new(),\n+        vtable,\n+        (SIZE_INDEX * usize_size) as i32,\n+    )\n+}\n+\n+pub fn get_ptr_and_method_ref<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    arg: CValue<'tcx>,\n+    idx: usize,\n+) -> (Value, Value) {\n+    let (ptr, vtable) = arg.load_value_pair(fx);\n+    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes();\n+    let func_ref = fx.bcx.ins().load(\n+        pointer_ty(fx.tcx),\n+        MemFlags::new(),\n+        vtable,\n+        ((idx + 3) * usize_size as usize) as i32,\n+    );\n+    (ptr, func_ref)\n+}\n+\n+pub fn get_vtable<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    ty: Ty<'tcx>,\n+    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+) -> Value {\n+    let data_id = if let Some(data_id) = fx.caches.vtables.get(&(ty, trait_ref)) {\n+        *data_id\n+    } else {\n+        let data_id = build_vtable(fx, ty, trait_ref);\n+        fx.caches.vtables.insert((ty, trait_ref), data_id);\n+        data_id\n+    };\n+\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    fx.bcx\n+        .ins()\n+        .global_value(fx.module.pointer_type(), local_data_id)\n+}\n+\n+fn build_vtable<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    ty: Ty<'tcx>,\n+    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+) -> DataId {\n+    let tcx = fx.tcx;\n+    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n+\n+    let (size, align) = tcx\n+        .layout_of(ParamEnv::reveal_all().and(ty))\n+        .unwrap()\n+        .size_and_align();\n+    let drop_in_place_fn =\n+        fx.get_function_id(::rustc_mir::monomorphize::resolve_drop_in_place(tcx, ty));\n+\n+    let mut components: Vec<_> = vec![Some(drop_in_place_fn), None, None];\n+\n+    if let Some(trait_ref) = trait_ref {\n+        let trait_ref = trait_ref.with_self_ty(tcx, ty);\n+        let methods = tcx.vtable_methods(trait_ref);\n+        let methods = methods.iter().cloned().map(|opt_mth| {\n+            opt_mth.map_or(None, |(def_id, substs)| {\n+                Some(fx.get_function_id(\n+                    Instance::resolve(tcx, ParamEnv::reveal_all(), def_id, substs).unwrap(),\n+                ))\n+            })\n+        });\n+        components.extend(methods);\n+    }\n+\n+    let mut data_ctx = DataContext::new();\n+    let mut data = ::std::iter::repeat(0u8)\n+        .take(components.len() * usize_size)\n+        .collect::<Vec<u8>>()\n+        .into_boxed_slice();\n+    write_usize(fx.tcx, &mut data, SIZE_INDEX, size.bytes());\n+    write_usize(fx.tcx, &mut data, ALIGN_INDEX, align.abi());\n+    data_ctx.define(data);\n+\n+    for (i, component) in components.into_iter().enumerate() {\n+        if let Some(func_id) = component {\n+            let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n+            data_ctx.write_function_addr((i * usize_size) as u32, func_ref);\n+        }\n+    }\n+\n+    let data_id = fx\n+        .module\n+        .declare_data(\n+            &format!(\"vtable.{:?}.for.{:?}\", trait_ref, ty),\n+            Linkage::Local,\n+            false,\n+        ).unwrap();\n+    fx.module.define_data(data_id, &data_ctx).unwrap();\n+    data_id\n+}\n+\n+fn write_usize(tcx: TyCtxt, buf: &mut [u8], idx: usize, num: u64) {\n+    use byteorder::{BigEndian, LittleEndian, WriteBytesExt};\n+\n+    let usize_size = tcx\n+        .layout_of(ParamEnv::reveal_all().and(tcx.types.usize))\n+        .unwrap()\n+        .size\n+        .bytes() as usize;\n+    let mut target = &mut buf[idx * usize_size..(idx + 1) * usize_size];\n+\n+    match tcx.data_layout.endian {\n+        layout::Endian::Little => target.write_uint::<LittleEndian>(num, usize_size),\n+        layout::Endian::Big => target.write_uint::<BigEndian>(num, usize_size),\n+    }.unwrap()\n+}"}]}