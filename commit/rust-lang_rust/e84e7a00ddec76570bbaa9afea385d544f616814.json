{"sha": "e84e7a00ddec76570bbaa9afea385d544f616814", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NGU3YTAwZGRlYzc2NTcwYmJhYTlhZmVhMzg1ZDU0NGY2MTY4MTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-06T08:06:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-06T08:06:50Z"}, "message": "auto merge of #18467 : japaric/rust/eq, r=alexcrichton\n\n`eq`, `ne`, `cmp`, etc methods now require one less level of indirection when dealing with `&str`/`&[T]`\r\n\r\n``` rust\r\n\"foo\".ne(&\"bar\") -> \"foo\".ne(\"bar\")\r\nslice.cmp(&another_slice) -> slice.cmp(another_slice)\r\n// slice and another_slice have type `&[T]`\r\n```\r\n\r\n[breaking-change]", "tree": {"sha": "5757b1eec689ab03459c9f2518cc602284c44733", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5757b1eec689ab03459c9f2518cc602284c44733"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e84e7a00ddec76570bbaa9afea385d544f616814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e84e7a00ddec76570bbaa9afea385d544f616814", "html_url": "https://github.com/rust-lang/rust/commit/e84e7a00ddec76570bbaa9afea385d544f616814", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e84e7a00ddec76570bbaa9afea385d544f616814/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e2f9b948564708085373fc28d91b4524c821fa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2f9b948564708085373fc28d91b4524c821fa3", "html_url": "https://github.com/rust-lang/rust/commit/0e2f9b948564708085373fc28d91b4524c821fa3"}, {"sha": "11f4baeafb83459befd0196b2b82cda7ed5ea2f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/11f4baeafb83459befd0196b2b82cda7ed5ea2f1", "html_url": "https://github.com/rust-lang/rust/commit/11f4baeafb83459befd0196b2b82cda7ed5ea2f1"}], "stats": {"total": 664, "additions": 635, "deletions": 29}, "files": [{"sha": "d1fc921ffdab5ca4b9347439527863d350fd7f2c", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -61,12 +61,16 @@ impl<T: Clone> Clone for Box<T> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T:PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { *(*self) == *(*other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n }\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T:PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n@@ -81,14 +85,50 @@ impl<T:PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn gt(&self, other: &Box<T>) -> bool { *(*self) > *(*other) }\n }\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         (**self).cmp(&**other)\n     }\n }\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T: Eq> Eq for Box<T> {}\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<Sized? T: PartialEq> PartialEq for Box<T> {\n+    #[inline]\n+    fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&**self, &**other)\n+    }\n+    #[inline]\n+    fn lt(&self, other: &Box<T>) -> bool { PartialOrd::lt(&**self, &**other) }\n+    #[inline]\n+    fn le(&self, other: &Box<T>) -> bool { PartialOrd::le(&**self, &**other) }\n+    #[inline]\n+    fn ge(&self, other: &Box<T>) -> bool { PartialOrd::ge(&**self, &**other) }\n+    #[inline]\n+    fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n+}\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<Sized? T: Ord> Ord for Box<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Box<T>) -> Ordering {\n+        Ord::cmp(&**self, &**other)\n+    }\n+}\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<Sized? T: Eq> Eq for Box<T> {}\n+\n /// Extension methods for an owning `Any` trait object.\n #[unstable = \"post-DST and coherence changes, this will not be a trait but \\\n               rather a direct `impl` on `Box<Any>`\"]"}, {"sha": "e4af5795e1cc99f3e473de423f6e9dfbb814ddcd", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -1598,15 +1598,15 @@ mod tests {\n     #[test]\n     fn test_total_ord() {\n         let c: &[int] = &[1, 2, 3];\n-        [1, 2, 3, 4][].cmp(& c) == Greater;\n+        [1, 2, 3, 4][].cmp(c) == Greater;\n         let c: &[int] = &[1, 2, 3, 4];\n-        [1, 2, 3][].cmp(& c) == Less;\n+        [1, 2, 3][].cmp(c) == Less;\n         let c: &[int] = &[1, 2, 3, 6];\n-        [1, 2, 3, 4][].cmp(& c) == Equal;\n+        [1, 2, 3, 4][].cmp(c) == Equal;\n         let c: &[int] = &[1, 2, 3, 4, 5, 6];\n-        [1, 2, 3, 4, 5, 5, 5, 5][].cmp(& c) == Less;\n+        [1, 2, 3, 4, 5, 5, 5, 5][].cmp(c) == Less;\n         let c: &[int] = &[1, 2, 3, 4];\n-        [2, 2][].cmp(& c) == Greater;\n+        [2, 2][].cmp(c) == Greater;\n     }\n \n     #[test]"}, {"sha": "cdca0d10eedde3ebeff8f02ddce4891d05555729", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -532,10 +532,17 @@ impl<'a> PartialOrd for MaybeOwned<'a> {\n }\n \n impl<'a> Ord for MaybeOwned<'a> {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     #[inline]\n     fn cmp(&self, other: &MaybeOwned) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[inline]\n+    fn cmp(&self, other: &MaybeOwned) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n+    }\n }\n \n impl<'a, S: Str> Equiv<S> for MaybeOwned<'a> {\n@@ -1523,11 +1530,11 @@ mod tests {\n \n     #[test]\n     fn test_total_ord() {\n-        \"1234\".cmp(&(\"123\")) == Greater;\n-        \"123\".cmp(&(\"1234\")) == Less;\n-        \"1234\".cmp(&(\"1234\")) == Equal;\n-        \"12345555\".cmp(&(\"123456\")) == Less;\n-        \"22\".cmp(&(\"1234\")) == Greater;\n+        \"1234\".cmp(\"123\") == Greater;\n+        \"123\".cmp(\"1234\") == Less;\n+        \"1234\".cmp(\"1234\") == Equal;\n+        \"12345555\".cmp(\"123456\") == Less;\n+        \"22\".cmp(\"1234\") == Greater;\n     }\n \n     #[test]"}, {"sha": "8e24eabfccfe65d709174e7dd83fb78414a2f5e6", "filename": "src/libcollections/tree/map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -579,7 +579,7 @@ impl<K, V> TreeMap<K, V> {\n     /// let headers = get_headers();\n     /// let ua_key = \"User-Agent\";\n     /// let ua = headers.find_with(|k| {\n-    ///    ua_key.cmp(&k.as_slice())\n+    ///    ua_key.cmp(k.as_slice())\n     /// });\n     ///\n     /// assert_eq!((*ua.unwrap()).as_slice(), \"Curl-Rust/0.1\");\n@@ -603,7 +603,7 @@ impl<K, V> TreeMap<K, V> {\n     /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n     ///\n     /// let new_ua = \"Safari/156.0\";\n-    /// match t.find_with_mut(|k| \"User-Agent\".cmp(k)) {\n+    /// match t.find_with_mut(|&k| \"User-Agent\".cmp(k)) {\n     ///    Some(x) => *x = new_ua,\n     ///    None => panic!(),\n     /// }\n@@ -1302,7 +1302,7 @@ mod test_treemap {\n     #[test]\n     fn find_with_empty() {\n         let m: TreeMap<&'static str,int> = TreeMap::new();\n-        assert!(m.find_with(|k| \"test\".cmp(k)) == None);\n+        assert!(m.find_with(|&k| \"test\".cmp(k)) == None);\n     }\n \n     #[test]\n@@ -1311,7 +1311,7 @@ mod test_treemap {\n         assert!(m.insert(\"test1\", 2i));\n         assert!(m.insert(\"test2\", 3i));\n         assert!(m.insert(\"test3\", 3i));\n-        assert_eq!(m.find_with(|k| \"test4\".cmp(k)), None);\n+        assert_eq!(m.find_with(|&k| \"test4\".cmp(k)), None);\n     }\n \n     #[test]\n@@ -1320,7 +1320,7 @@ mod test_treemap {\n         assert!(m.insert(\"test1\", 2i));\n         assert!(m.insert(\"test2\", 3i));\n         assert!(m.insert(\"test3\", 4i));\n-        assert_eq!(m.find_with(|k| \"test2\".cmp(k)), Some(&3i));\n+        assert_eq!(m.find_with(|&k| \"test2\".cmp(k)), Some(&3i));\n     }\n \n     #[test]\n@@ -1343,10 +1343,10 @@ mod test_treemap {\n         assert!(m.insert(\"t2\", 8));\n         assert!(m.insert(\"t5\", 14));\n         let new = 100;\n-        match m.find_with_mut(|k| \"t5\".cmp(k)) {\n+        match m.find_with_mut(|&k| \"t5\".cmp(k)) {\n           None => panic!(), Some(x) => *x = new\n         }\n-        assert_eq!(m.find_with(|k| \"t5\".cmp(k)), Some(&new));\n+        assert_eq!(m.find_with(|&k| \"t5\".cmp(k)), Some(&new));\n     }\n \n     #[test]"}, {"sha": "4b6921ed0c0d98b57b15436c03510463325be999", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -506,10 +506,17 @@ impl<T: PartialEq> PartialEq for Vec<T> {\n \n #[unstable = \"waiting on PartialOrd stability\"]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[inline]\n+    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(other.as_slice())\n+    }\n }\n \n #[unstable = \"waiting on Eq stability\"]\n@@ -523,10 +530,17 @@ impl<T: PartialEq, V: AsSlice<T>> Equiv<V> for Vec<T> {\n \n #[unstable = \"waiting on Ord stability\"]\n impl<T: Ord> Ord for Vec<T> {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[inline]\n+    fn cmp(&self, other: &Vec<T>) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n+    }\n }\n \n // FIXME: #13996: need a way to mark the return value as `noalias`"}, {"sha": "6e87fe4ced02dbc141b0cc49a28c5f3a364d8d9f", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -55,6 +55,8 @@ use option::{Option, Some, None};\n ///\n /// Eventually, this will be implemented by default for types that implement\n /// `Eq`.\n+// NOTE(stage0): remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"eq\"]\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait PartialEq {\n@@ -66,6 +68,31 @@ pub trait PartialEq {\n     fn ne(&self, other: &Self) -> bool { !self.eq(other) }\n }\n \n+/// Trait for values that can be compared for equality and inequality.\n+///\n+/// This trait allows for partial equality, for types that do not have an\n+/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n+/// so floating point types implement `PartialEq` but not `Eq`.\n+///\n+/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n+/// in terms of it by default. Any manual implementation of `ne` *must* respect\n+/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n+/// only if `a != b`.\n+///\n+/// Eventually, this will be implemented by default for types that implement\n+/// `Eq`.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[lang=\"eq\"]\n+#[unstable = \"Definition may change slightly after trait reform\"]\n+pub trait PartialEq for Sized? {\n+    /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n+    fn eq(&self, other: &Self) -> bool;\n+\n+    /// This method tests for `!=`.\n+    #[inline]\n+    fn ne(&self, other: &Self) -> bool { !self.eq(other) }\n+}\n+\n /// Trait for equality comparisons which are [equivalence relations](\n /// https://en.wikipedia.org/wiki/Equivalence_relation).\n ///\n@@ -75,6 +102,8 @@ pub trait PartialEq {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n+// NOTE(stage0): remove trait after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait Eq: PartialEq {\n     // FIXME #13101: this method is used solely by #[deriving] to\n@@ -89,6 +118,30 @@ pub trait Eq: PartialEq {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n+/// Trait for equality comparisons which are [equivalence relations](\n+/// https://en.wikipedia.org/wiki/Equivalence_relation).\n+///\n+/// This means, that in addition to `a == b` and `a != b` being strict\n+/// inverses, the equality must be (for all `a`, `b` and `c`):\n+///\n+/// - reflexive: `a == a`;\n+/// - symmetric: `a == b` implies `b == a`; and\n+/// - transitive: `a == b` and `b == c` implies `a == c`.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"Definition may change slightly after trait reform\"]\n+pub trait Eq for Sized?: PartialEq {\n+    // FIXME #13101: this method is used solely by #[deriving] to\n+    // assert that every component of a type implements #[deriving]\n+    // itself, the current deriving infrastructure means doing this\n+    // assertion without using a method on this trait is nearly\n+    // impossible.\n+    //\n+    // This should never be implemented by hand.\n+    #[doc(hidden)]\n+    #[inline(always)]\n+    fn assert_receiver_is_total_eq(&self) {}\n+}\n+\n /// An ordering is, e.g, a result of a comparison between two values.\n #[deriving(Clone, PartialEq, Show)]\n #[stable]\n@@ -145,6 +198,8 @@ impl Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n+// NOTE(stage0): remove trait after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait Ord: Eq + PartialOrd {\n     /// This method returns an ordering between `self` and `other` values.\n@@ -160,6 +215,31 @@ pub trait Ord: Eq + PartialOrd {\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n+/// Trait for types that form a [total order](\n+/// https://en.wikipedia.org/wiki/Total_order).\n+///\n+/// An order is a total order if it is (for all `a`, `b` and `c`):\n+///\n+/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is\n+///   true; and\n+/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n+///   both `==` and `>`.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"Definition may change slightly after trait reform\"]\n+pub trait Ord for Sized?: Eq + PartialOrd {\n+    /// This method returns an ordering between `self` and `other` values.\n+    ///\n+    /// By convention, `self.cmp(&other)` returns the ordering matching\n+    /// the expression `self <operator> other` if true.  For example:\n+    ///\n+    /// ```\n+    /// assert_eq!( 5u.cmp(&10), Less);     // because 5 < 10\n+    /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n+    /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5\n+    /// ```\n+    fn cmp(&self, other: &Self) -> Ordering;\n+}\n+\n #[unstable = \"Trait is unstable.\"]\n impl Eq for Ordering {}\n \n@@ -188,6 +268,8 @@ impl PartialOrd for Ordering {\n /// which do not have a total order. For example, for floating point numbers,\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n+// NOTE(stage0): remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"ord\"]\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait PartialOrd: PartialEq {\n@@ -232,6 +314,60 @@ pub trait PartialOrd: PartialEq {\n     }\n }\n \n+/// Trait for values that can be compared for a sort-order.\n+///\n+/// PartialOrd only requires implementation of the `partial_cmp` method,\n+/// with the others generated from default implementations.\n+///\n+/// However it remains possible to implement the others separately for types\n+/// which do not have a total order. For example, for floating point numbers,\n+/// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n+/// 5.11).\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[lang=\"ord\"]\n+#[unstable = \"Definition may change slightly after trait reform\"]\n+pub trait PartialOrd for Sized?: PartialEq {\n+    /// This method returns an ordering between `self` and `other` values\n+    /// if one exists.\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering>;\n+\n+    /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n+    #[inline]\n+    fn lt(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Less) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// This method tests less than or equal to (`<=`).\n+    #[inline]\n+    fn le(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Less) | Some(Equal) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// This method tests greater than (`>`).\n+    #[inline]\n+    fn gt(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Greater) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// This method tests greater than or equal to (`>=`).\n+    #[inline]\n+    fn ge(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Greater) | Some(Equal) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// The equivalence relation. Two values may be equivalent even if they are\n /// of different types. The most common use case for this relation is\n /// container types; e.g. it is often desirable to be able to use `&str`\n@@ -286,6 +422,8 @@ pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n mod impls {\n     use cmp::{PartialOrd, Ord, PartialEq, Eq, Ordering,\n               Less, Greater, Equal};\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    use kinds::Sized;\n     use option::{Option, Some, None};\n \n     macro_rules! partial_eq_impl(\n@@ -393,13 +531,17 @@ mod impls {\n     ord_impl!(char uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n     // & pointers\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialEq> PartialEq for &'a T {\n         #[inline]\n         fn eq(&self, other: & &'a T) -> bool { *(*self) == *(*other) }\n         #[inline]\n         fn ne(&self, other: & &'a T) -> bool { *(*self) != *(*other) }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialOrd> PartialOrd for &'a T {\n         #[inline]\n@@ -415,22 +557,64 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: & &'a T) -> bool { *(*self) > *(*other) }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Ord> Ord for &'a T {\n         #[inline]\n         fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Eq> Eq for &'a T {}\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: PartialEq> PartialEq for &'a T {\n+        #[inline]\n+        fn eq(&self, other: & &'a T) -> bool { PartialEq::eq(*self, *other) }\n+        #[inline]\n+        fn ne(&self, other: & &'a T) -> bool { PartialEq::ne(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: PartialOrd> PartialOrd for &'a T {\n+        #[inline]\n+        fn partial_cmp(&self, other: &&'a T) -> Option<Ordering> {\n+            PartialOrd::partial_cmp(*self, *other)\n+        }\n+        #[inline]\n+        fn lt(&self, other: & &'a T) -> bool { PartialOrd::lt(*self, *other) }\n+        #[inline]\n+        fn le(&self, other: & &'a T) -> bool { PartialOrd::le(*self, *other) }\n+        #[inline]\n+        fn ge(&self, other: & &'a T) -> bool { PartialOrd::ge(*self, *other) }\n+        #[inline]\n+        fn gt(&self, other: & &'a T) -> bool { PartialOrd::gt(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: Ord> Ord for &'a T {\n+        #[inline]\n+        fn cmp(&self, other: & &'a T) -> Ordering { Ord::cmp(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: Eq> Eq for &'a T {}\n+\n     // &mut pointers\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialEq> PartialEq for &'a mut T {\n         #[inline]\n         fn eq(&self, other: &&'a mut T) -> bool { **self == *(*other) }\n         #[inline]\n         fn ne(&self, other: &&'a mut T) -> bool { **self != *(*other) }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialOrd> PartialOrd for &'a mut T {\n         #[inline]\n@@ -446,11 +630,49 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &&'a mut T) -> bool { **self > **other }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Ord> Ord for &'a mut T {\n         #[inline]\n         fn cmp(&self, other: &&'a mut T) -> Ordering { (**self).cmp(*other) }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Eq> Eq for &'a mut T {}\n+\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: PartialEq> PartialEq for &'a mut T {\n+        #[inline]\n+        fn eq(&self, other: &&'a mut T) -> bool { PartialEq::eq(*self, *other) }\n+        #[inline]\n+        fn ne(&self, other: &&'a mut T) -> bool { PartialEq::ne(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: PartialOrd> PartialOrd for &'a mut T {\n+        #[inline]\n+        fn partial_cmp(&self, other: &&'a mut T) -> Option<Ordering> {\n+            PartialOrd::partial_cmp(*self, *other)\n+        }\n+        #[inline]\n+        fn lt(&self, other: &&'a mut T) -> bool { PartialOrd::lt(*self, *other) }\n+        #[inline]\n+        fn le(&self, other: &&'a mut T) -> bool { PartialOrd::le(*self, *other) }\n+        #[inline]\n+        fn ge(&self, other: &&'a mut T) -> bool { PartialOrd::ge(*self, *other) }\n+        #[inline]\n+        fn gt(&self, other: &&'a mut T) -> bool { PartialOrd::gt(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: Ord> Ord for &'a mut T {\n+        #[inline]\n+        fn cmp(&self, other: &&'a mut T) -> Ordering { Ord::cmp(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: Eq> Eq for &'a mut T {}\n }"}, {"sha": "2964a6b68534e0f2e0d126ba5c37058c1b03040b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -143,7 +143,7 @@\n \n #![stable]\n \n-use cmp::{PartialEq, Eq, Ord};\n+use cmp::{Eq, Ord};\n use default::Default;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use mem;"}, {"sha": "c4cb2987241533c5cef3bbd4f240bb546c37377e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -276,7 +276,6 @@\n \n #![stable]\n \n-use cmp::PartialEq;\n use std::fmt::Show;\n use slice;\n use slice::AsSlice;"}, {"sha": "3cc904162a13464bffec6de2bb3717f976404080", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -1555,6 +1555,8 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a,T:PartialEq> PartialEq for &'a [T] {\n     fn eq(&self, other: & &'a [T]) -> bool {\n@@ -1567,15 +1569,36 @@ impl<'a,T:PartialEq> PartialEq for &'a [T] {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"waiting for DST\"]\n+impl<T: PartialEq> PartialEq for [T] {\n+    fn eq(&self, other: &[T]) -> bool {\n+        self.len() == other.len() &&\n+            order::eq(self.iter(), other.iter())\n+    }\n+    fn ne(&self, other: &[T]) -> bool {\n+        self.len() != other.len() ||\n+            order::ne(self.iter(), other.iter())\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a,T:Eq> Eq for &'a [T] {}\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"waiting for DST\"]\n+impl<T: Eq> Eq for [T] {}\n+\n #[unstable = \"waiting for DST\"]\n impl<T: PartialEq, V: AsSlice<T>> Equiv<V> for [T] {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a,T:PartialEq> PartialEq for &'a mut [T] {\n     fn eq(&self, other: & &'a mut [T]) -> bool {\n@@ -1588,6 +1611,8 @@ impl<'a,T:PartialEq> PartialEq for &'a mut [T] {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a,T:Eq> Eq for &'a mut [T] {}\n \n@@ -1597,13 +1622,25 @@ impl<'a,T:PartialEq, V: AsSlice<T>> Equiv<V> for &'a mut [T] {\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a,T:Ord> Ord for &'a [T] {\n     fn cmp(&self, other: & &'a [T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"waiting for DST\"]\n+impl<T: Ord> Ord for [T] {\n+    fn cmp(&self, other: &[T]) -> Ordering {\n+        order::cmp(self.iter(), other.iter())\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n     #[inline]\n@@ -1628,6 +1665,31 @@ impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"waiting for DST\"]\n+impl<T: PartialOrd> PartialOrd for [T] {\n+    #[inline]\n+    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n+        order::partial_cmp(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn lt(&self, other: &[T]) -> bool {\n+        order::lt(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn le(&self, other: &[T]) -> bool {\n+        order::le(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn ge(&self, other: &[T]) -> bool {\n+        order::ge(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn gt(&self, other: &[T]) -> bool {\n+        order::gt(self.iter(), other.iter())\n+    }\n+}\n+\n /// Extension methods for immutable slices containing integers.\n #[experimental]\n pub trait ImmutableIntSlice<U, S> for Sized? {"}, {"sha": "175f9f3f5771c44ecfff763331245978a014357f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -19,8 +19,7 @@\n use mem;\n use char;\n use char::Char;\n-use cmp;\n-use cmp::{PartialEq, Eq};\n+use cmp::{Eq, mod};\n use default::Default;\n use iter::{Map, Iterator};\n use iter::{DoubleEndedIterator, ExactSize};\n@@ -1123,6 +1122,8 @@ pub mod traits {\n     use ops;\n     use str::{Str, StrSlice, eq_slice};\n \n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     impl<'a> Ord for &'a str {\n         #[inline]\n         fn cmp(&self, other: & &'a str) -> Ordering {\n@@ -1138,6 +1139,24 @@ pub mod traits {\n         }\n     }\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    impl Ord for str {\n+        #[inline]\n+        fn cmp(&self, other: &str) -> Ordering {\n+            for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n+                match s_b.cmp(&o_b) {\n+                    Greater => return Greater,\n+                    Less => return Less,\n+                    Equal => ()\n+                }\n+            }\n+\n+            self.len().cmp(&other.len())\n+        }\n+    }\n+\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     impl<'a> PartialEq for &'a str {\n         #[inline]\n         fn eq(&self, other: & &'a str) -> bool {\n@@ -1147,15 +1166,40 @@ pub mod traits {\n         fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }\n     }\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    impl PartialEq for str {\n+        #[inline]\n+        fn eq(&self, other: &str) -> bool {\n+            eq_slice(self, other)\n+        }\n+        #[inline]\n+        fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     impl<'a> Eq for &'a str {}\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    impl Eq for str {}\n+\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     impl<'a> PartialOrd for &'a str {\n         #[inline]\n         fn partial_cmp(&self, other: &&'a str) -> Option<Ordering> {\n             Some(self.cmp(other))\n         }\n     }\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    impl PartialOrd for str {\n+        #[inline]\n+        fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n+    }\n+\n     impl<S: Str> Equiv<S> for str {\n         #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(self, other.as_slice()) }"}, {"sha": "d60835dff1745a29c2469a7c9a4c8ef87f9bbdf3", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -93,7 +93,6 @@\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n-use std::cmp::PartialEq;\n use std::fmt;\n use std::result::{Err, Ok};\n use std::result;"}, {"sha": "3a89d8b3f81cd522d687b18aebb35d406d7a6157", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -76,15 +76,27 @@ impl<'a, T: PartialEq> PartialEq for MaybeOwnedVector<'a, T> {\n impl<'a, T: Eq> Eq for MaybeOwnedVector<'a, T> {}\n \n impl<'a, T: PartialOrd> PartialOrd for MaybeOwnedVector<'a, T> {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     fn partial_cmp(&self, other: &MaybeOwnedVector<T>) -> Option<Ordering> {\n         self.as_slice().partial_cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    fn partial_cmp(&self, other: &MaybeOwnedVector<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(other.as_slice())\n+    }\n }\n \n impl<'a, T: Ord> Ord for MaybeOwnedVector<'a, T> {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     fn cmp(&self, other: &MaybeOwnedVector<T>) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    fn cmp(&self, other: &MaybeOwnedVector<T>) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n+    }\n }\n \n impl<'a, T: PartialEq, V: AsSlice<T>> Equiv<V> for MaybeOwnedVector<'a, T> {"}, {"sha": "6723ea725a356de73aaf68a9141e59cbca581421", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -1020,13 +1020,23 @@ fn is_valid_cap(c: char) -> bool {\n     || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n }\n \n+// NOTE(stage0): remove function after a snapshot\n+#[cfg(stage0)]\n fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n     match classes.binary_search(|&(s, _)| s.cmp(&name)) {\n         slice::Found(i) => Some(classes[i].val1().to_vec()),\n         slice::NotFound(_) => None,\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n+    match classes.binary_search(|&(s, _)| s.cmp(name)) {\n+        slice::Found(i) => Some(classes[i].val1().to_vec()),\n+        slice::NotFound(_) => None,\n+    }\n+}\n+\n type Class = &'static [(char, char)];\n type NamedClasses = &'static [(&'static str, &'static Class)];\n "}, {"sha": "8753795d9e25d59905a21c6f140698c4fe561bb1", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -182,6 +182,8 @@ Available lint options:\n \n \");\n \n+    // NOTE(stage0): remove function after a snapshot\n+    #[cfg(stage0)]\n     fn sort_lints(lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n         let mut lints: Vec<_> = lints.into_iter().map(|(x, _)| x).collect();\n         lints.sort_by(|x: &&Lint, y: &&Lint| {\n@@ -194,6 +196,21 @@ Available lint options:\n         lints\n     }\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    fn sort_lints(lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n+        let mut lints: Vec<_> = lints.into_iter().map(|(x, _)| x).collect();\n+        lints.sort_by(|x: &&Lint, y: &&Lint| {\n+            match x.default_level.cmp(&y.default_level) {\n+                // The sort doesn't case-fold but it's doubtful we care.\n+                Equal => x.name.cmp(y.name),\n+                r => r,\n+            }\n+        });\n+        lints\n+    }\n+\n+    // NOTE(stage0): remove function after a snapshot\n+    #[cfg(stage0)]\n     fn sort_lint_groups(lints: Vec<(&'static str, Vec<lint::LintId>, bool)>)\n                      -> Vec<(&'static str, Vec<lint::LintId>)> {\n         let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n@@ -204,6 +221,17 @@ Available lint options:\n         lints\n     }\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    fn sort_lint_groups(lints: Vec<(&'static str, Vec<lint::LintId>, bool)>)\n+                     -> Vec<(&'static str, Vec<lint::LintId>)> {\n+        let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n+        lints.sort_by(|&(x, _): &(&'static str, Vec<lint::LintId>),\n+                       &(y, _): &(&'static str, Vec<lint::LintId>)| {\n+            x.cmp(y)\n+        });\n+        lints\n+    }\n+\n     let (plugin, builtin) = lint_store.get_lints().partitioned(|&(_, p)| p);\n     let plugin = sort_lints(plugin);\n     let builtin = sort_lints(builtin);"}, {"sha": "b7a2c8f947341be13f3e4889fbba8939ad0ef304", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -121,10 +121,17 @@ impl PartialEq for CString {\n }\n \n impl PartialOrd for CString {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     #[inline]\n     fn partial_cmp(&self, other: &CString) -> Option<Ordering> {\n         self.as_bytes().partial_cmp(&other.as_bytes())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[inline]\n+    fn partial_cmp(&self, other: &CString) -> Option<Ordering> {\n+        self.as_bytes().partial_cmp(other.as_bytes())\n+    }\n }\n \n impl Eq for CString {}"}, {"sha": "dbdfa17bfc2285198d67b38f2b9de1a1f26d8797", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -890,13 +890,25 @@ impl Json {\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n+    // NOTE(stage0): remove function after a snapshot\n+    #[cfg(stage0)]\n     pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n         match self {\n             &Object(ref map) => map.find_with(|s| key.cmp(&s.as_slice())),\n             _ => None\n         }\n     }\n \n+     /// If the Json value is an Object, returns the value associated with the provided key.\n+    /// Otherwise, returns None.\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n+        match self {\n+            &Object(ref map) => map.find_with(|s| key.cmp(s.as_slice())),\n+            _ => None\n+        }\n+    }\n+\n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, find_path will return None.\n     /// Otherwise, it will return the Json value associated with the final key.\n@@ -914,6 +926,8 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n+    // NOTE(stage0): remove function after a snapshot\n+    #[cfg(stage0)]\n     pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n@@ -934,6 +948,30 @@ impl Json {\n         }\n     }\n \n+    /// If the Json value is an Object, performs a depth-first search until\n+    /// a value associated with the provided key is found. If no value is found\n+    /// or the Json value is not an Object, returns None.\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n+        match self {\n+            &Object(ref map) => {\n+                match map.find_with(|s| key.cmp(s.as_slice())) {\n+                    Some(json_value) => Some(json_value),\n+                    None => {\n+                        for (_, v) in map.iter() {\n+                            match v.search(key) {\n+                                x if x.is_some() => return x,\n+                                _ => ()\n+                            }\n+                        }\n+                        None\n+                    }\n+                }\n+            },\n+            _ => None\n+        }\n+    }\n+\n     /// Returns true if the Json value is an Object. Returns false otherwise.\n     pub fn is_object<'a>(&'a self) -> bool {\n         self.as_object().is_some()"}, {"sha": "c3b1a52925d452ea3749001673efbe281a880f38", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Item, Expr, mod};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -25,12 +25,38 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n-                                 cx, span, substr)\n+        cs_fold(\n+            true,  // use foldl\n+            |cx, span, subexpr, self_f, other_fs| {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Eq)`\")\n+                };\n+\n+                let eq = cx.expr_binary(span, ast::BiEq, self_f, other_f.clone());\n+\n+                cx.expr_binary(span, ast::BiAnd, subexpr, eq)\n+            },\n+            cx.expr_bool(span, true),\n+            |cx, span, _, _| cx.expr_bool(span, false),\n+            cx, span, substr)\n     }\n     fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n-              cx, span, substr)\n+        cs_fold(\n+            true,  // use foldl\n+            |cx, span, subexpr, self_f, other_fs| {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Eq)`\")\n+                };\n+\n+                let eq = cx.expr_binary(span, ast::BiNe, self_f, other_f.clone());\n+\n+                cx.expr_binary(span, ast::BiOr, subexpr, eq)\n+            },\n+            cx.expr_bool(span, false),\n+            |cx, span, _, _| cx.expr_bool(span, true),\n+            cx, span, substr)\n     }\n \n     macro_rules! md ("}, {"sha": "e6c98a9e3d09abdce17ebcd70619a2280675d4a1", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -97,9 +97,15 @@ pub struct RcStr {\n impl Eq for RcStr {}\n \n impl Ord for RcStr {\n+    // NOTE(stage0): remove method after a snapshot\n+    #[cfg(stage0)]\n     fn cmp(&self, other: &RcStr) -> Ordering {\n         self.as_slice().cmp(&other.as_slice())\n     }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    fn cmp(&self, other: &RcStr) -> Ordering {\n+        self.as_slice().cmp(other.as_slice())\n+    }\n }\n \n impl Str for RcStr {"}, {"sha": "74bead9e5f2ddee67760115105cf9f7065861b21", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -973,6 +973,8 @@ fn get_concurrency() -> uint {\n     }\n }\n \n+// NOTE(stage0): remove function after a snapshot\n+#[cfg(stage0)]\n pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     let mut filtered = tests;\n \n@@ -1020,6 +1022,54 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n+    let mut filtered = tests;\n+\n+    // Remove tests that don't match the test filter\n+    filtered = match opts.filter {\n+        None => filtered,\n+        Some(ref re) => {\n+            filtered.into_iter()\n+                .filter(|test| re.is_match(test.desc.name.as_slice())).collect()\n+        }\n+    };\n+\n+    // Maybe pull out the ignored test and unignore them\n+    filtered = if !opts.run_ignored {\n+        filtered\n+    } else {\n+        fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n+            if test.desc.ignore {\n+                let TestDescAndFn {desc, testfn} = test;\n+                Some(TestDescAndFn {\n+                    desc: TestDesc {ignore: false, ..desc},\n+                    testfn: testfn\n+                })\n+            } else {\n+                None\n+            }\n+        };\n+        filtered.into_iter().filter_map(|x| filter(x)).collect()\n+    };\n+\n+    // Sort the tests alphabetically\n+    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n+\n+    // Shard the remaining tests, if sharding requested.\n+    match opts.test_shard {\n+        None => filtered,\n+        Some((a,b)) => {\n+            filtered.into_iter().enumerate()\n+            // note: using a - 1 so that the valid shards, for example, are\n+            // 1.2 and 2.2 instead of 0.2 and 1.2\n+            .filter(|&(i,_)| i % b == (a - 1))\n+            .map(|(_,t)| t)\n+            .collect()\n+        }\n+    }\n+}\n+\n pub fn run_test(opts: &TestOpts,\n                 force_ignore: bool,\n                 test: TestDescAndFn,"}, {"sha": "18be03f97d934ef1db232563788b18402c47b877", "filename": "src/test/compile-fail/deriving-no-inner-impl-error-message.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Ftest%2Fcompile-fail%2Fderiving-no-inner-impl-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Ftest%2Fcompile-fail%2Fderiving-no-inner-impl-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-no-inner-impl-error-message.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -12,8 +12,8 @@ struct NoCloneOrEq;\n \n #[deriving(PartialEq)]\n struct E {\n-    x: NoCloneOrEq //~ ERROR does not implement any method in scope named `eq`\n-         //~^ ERROR does not implement any method in scope named `ne`\n+    x: NoCloneOrEq //~ ERROR binary operation `==` cannot be applied to type `NoCloneOrEq`\n+         //~^ ERROR binary operation `!=` cannot be applied to type `NoCloneOrEq`\n }\n #[deriving(Clone)]\n struct C {"}, {"sha": "b16c2ccb46eb887071d7c7928b04cf8581828c5d", "filename": "src/test/run-pass/deriving-eq-ord-boxed-slice.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Ftest%2Frun-pass%2Fderiving-eq-ord-boxed-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Ftest%2Frun-pass%2Fderiving-eq-ord-boxed-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-eq-ord-boxed-slice.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(PartialEq, PartialOrd, Eq, Ord)]\n+struct Foo(Box<[u8]>);\n+\n+pub fn main() {\n+    let a = Foo(box [0, 1, 2]);\n+    let b = Foo(box [0, 1, 2]);\n+    assert!(a == b);\n+    println!(\"{}\", a != b);\n+    println!(\"{}\", a < b);\n+    println!(\"{}\", a <= b);\n+    println!(\"{}\", a == b);\n+    println!(\"{}\", a > b);\n+    println!(\"{}\", a >= b);\n+}"}, {"sha": "8d17fc4600614aee9b3053215df3c2e8d3ad1403", "filename": "src/test/run-pass/issue-15689-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Ftest%2Frun-pass%2Fissue-15689-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84e7a00ddec76570bbaa9afea385d544f616814/src%2Ftest%2Frun-pass%2Fissue-15689-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15689-1.rs?ref=e84e7a00ddec76570bbaa9afea385d544f616814", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(PartialEq)]\n+enum Test<'a> {\n+    Slice(&'a int)\n+}\n+\n+fn main() {\n+    assert!(Slice(&1) == Slice(&1))\n+}"}]}