{"sha": "82dc2ebfe3696705a3aa6f6375ea26ba944a1d5e", "node_id": "C_kwDOAAsO6NoAKDgyZGMyZWJmZTM2OTY3MDVhM2FhNmY2Mzc1ZWEyNmJhOTQ0YTFkNWU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-21T22:02:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-21T22:02:01Z"}, "message": "Rollup merge of #108322 - cjgillot:clean-const-prop, r=oli-obk\n\nClean ConstProp\n\nSmall simplifications from the time when there that pass output lints.", "tree": {"sha": "d4c59ecbf92f1543b125384b4848854734037dae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4c59ecbf92f1543b125384b4848854734037dae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82dc2ebfe3696705a3aa6f6375ea26ba944a1d5e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj9T9ZCRBK7hj4Ov3rIwAAjGwIAFtDC3SOKxAUOkohYR6Ufekj\nDHQOV2fET9GHN0kPqzNtjc9BDU3iI4zumUH1zxD03f5Y19oAU5M+MLCo/bsNHHHz\nwvn0+ejQELyb7iFR3bgGv8ZIHspGk0T/azmBQcf2WF5/E3EuJKyggZTBUnuYlcYw\no4QstiqeUfKNbwuxBHRtt/OQv9zhzvhQbD8UFZJn5ZIZreCSusj/PTbfywt9I607\nXXZuvSTpSX80NhoaZVZYE2qvL5ZOicMC2CVjAyT7rO9RkuBbG17NLliadtd2KOTc\nivQPdg0uaiQ0phznnqqV/GFmIrn1C569YpopvcDjMi/4bxgm9TMqu8srIeX9s+s=\n=YCt2\n-----END PGP SIGNATURE-----\n", "payload": "tree d4c59ecbf92f1543b125384b4848854734037dae\nparent c21b7f69140237e22f84bbc98717aed108f8084f\nparent f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1677016921 +0100\ncommitter GitHub <noreply@github.com> 1677016921 +0100\n\nRollup merge of #108322 - cjgillot:clean-const-prop, r=oli-obk\n\nClean ConstProp\n\nSmall simplifications from the time when there that pass output lints.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82dc2ebfe3696705a3aa6f6375ea26ba944a1d5e", "html_url": "https://github.com/rust-lang/rust/commit/82dc2ebfe3696705a3aa6f6375ea26ba944a1d5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82dc2ebfe3696705a3aa6f6375ea26ba944a1d5e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c21b7f69140237e22f84bbc98717aed108f8084f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c21b7f69140237e22f84bbc98717aed108f8084f", "html_url": "https://github.com/rust-lang/rust/commit/c21b7f69140237e22f84bbc98717aed108f8084f"}, {"sha": "f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4", "html_url": "https://github.com/rust-lang/rust/commit/f02d6c45e1117ef1d4e16f07b52ef6fe6f809ae4"}], "stats": {"total": 237, "additions": 105, "deletions": 132}, "files": [{"sha": "cff3da720fc5c79cfb32a490644cd35c269d3fbd", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 105, "deletions": 132, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/82dc2ebfe3696705a3aa6f6375ea26ba944a1d5e/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dc2ebfe3696705a3aa6f6375ea26ba944a1d5e/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=82dc2ebfe3696705a3aa6f6375ea26ba944a1d5e", "patch": "@@ -13,11 +13,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n-use rustc_middle::mir::{\n-    BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind, Location,\n-    Operand, Place, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind,\n-    RETURN_PLACE,\n-};\n+use rustc_middle::mir::*;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeVisitable};\n@@ -456,27 +452,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         };\n     }\n \n-    fn use_ecx<F, T>(&mut self, f: F) -> Option<T>\n-    where\n-        F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n-    {\n-        match f(self) {\n-            Ok(val) => Some(val),\n-            Err(error) => {\n-                trace!(\"InterpCx operation failed: {:?}\", error);\n-                // Some errors shouldn't come up because creating them causes\n-                // an allocation, which we should avoid. When that happens,\n-                // dedicated error variants should be introduced instead.\n-                assert!(\n-                    !error.kind().formatted_string(),\n-                    \"const-prop encountered formatting error: {}\",\n-                    error\n-                );\n-                None\n-            }\n-        }\n-    }\n-\n     /// Returns the value, if any, of evaluating `c`.\n     fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n@@ -491,7 +466,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Returns the value, if any, of evaluating `place`.\n     fn eval_place(&mut self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        self.use_ecx(|this| this.ecx.eval_place_to_op(place, None))\n+        self.ecx.eval_place_to_op(place, None).ok()\n     }\n \n     /// Returns the value, if any, of evaluating `op`. Calls upon `eval_constant`\n@@ -595,52 +570,54 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         rvalue: &Rvalue<'tcx>,\n         place: Place<'tcx>,\n     ) -> Option<()> {\n-        self.use_ecx(|this| match rvalue {\n+        match rvalue {\n             Rvalue::BinaryOp(op, box (left, right))\n             | Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n-                let l = this.ecx.eval_operand(left, None).and_then(|x| this.ecx.read_immediate(&x));\n+                let l = self.ecx.eval_operand(left, None).and_then(|x| self.ecx.read_immediate(&x));\n                 let r =\n-                    this.ecx.eval_operand(right, None).and_then(|x| this.ecx.read_immediate(&x));\n+                    self.ecx.eval_operand(right, None).and_then(|x| self.ecx.read_immediate(&x));\n \n                 let const_arg = match (l, r) {\n                     (Ok(x), Err(_)) | (Err(_), Ok(x)) => x, // exactly one side is known\n-                    (Err(e), Err(_)) => return Err(e),      // neither side is known\n-                    (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place), // both sides are known\n+                    (Err(_), Err(_)) => return None,        // neither side is known\n+                    (Ok(_), Ok(_)) => return self.ecx.eval_rvalue_into_place(rvalue, place).ok(), // both sides are known\n                 };\n \n                 if !matches!(const_arg.layout.abi, abi::Abi::Scalar(..)) {\n                     // We cannot handle Scalar Pair stuff.\n                     // No point in calling `eval_rvalue_into_place`, since only one side is known\n-                    throw_machine_stop_str!(\"cannot optimize this\")\n+                    return None;\n                 }\n \n-                let arg_value = const_arg.to_scalar().to_bits(const_arg.layout.size)?;\n-                let dest = this.ecx.eval_place(place)?;\n+                let arg_value = const_arg.to_scalar().to_bits(const_arg.layout.size).ok()?;\n+                let dest = self.ecx.eval_place(place).ok()?;\n \n                 match op {\n-                    BinOp::BitAnd if arg_value == 0 => this.ecx.write_immediate(*const_arg, &dest),\n+                    BinOp::BitAnd if arg_value == 0 => {\n+                        self.ecx.write_immediate(*const_arg, &dest).ok()\n+                    }\n                     BinOp::BitOr\n                         if arg_value == const_arg.layout.size.truncate(u128::MAX)\n                             || (const_arg.layout.ty.is_bool() && arg_value == 1) =>\n                     {\n-                        this.ecx.write_immediate(*const_arg, &dest)\n+                        self.ecx.write_immediate(*const_arg, &dest).ok()\n                     }\n                     BinOp::Mul if const_arg.layout.ty.is_integral() && arg_value == 0 => {\n                         if let Rvalue::CheckedBinaryOp(_, _) = rvalue {\n                             let val = Immediate::ScalarPair(\n                                 const_arg.to_scalar(),\n                                 Scalar::from_bool(false),\n                             );\n-                            this.ecx.write_immediate(val, &dest)\n+                            self.ecx.write_immediate(val, &dest).ok()\n                         } else {\n-                            this.ecx.write_immediate(*const_arg, &dest)\n+                            self.ecx.write_immediate(*const_arg, &dest).ok()\n                         }\n                     }\n-                    _ => throw_machine_stop_str!(\"cannot optimize this\"),\n+                    _ => None,\n                 }\n             }\n-            _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n-        })\n+            _ => self.ecx.eval_rvalue_into_place(rvalue, place).ok(),\n+        }\n     }\n \n     /// Creates a new `Operand::Constant` from a `Scalar` value\n@@ -682,7 +659,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         // FIXME> figure out what to do when read_immediate_raw fails\n-        let imm = self.use_ecx(|this| this.ecx.read_immediate_raw(value));\n+        let imm = self.ecx.read_immediate_raw(value).ok();\n \n         if let Some(Right(imm)) = imm {\n             match *imm {\n@@ -702,25 +679,23 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     if let ty::Tuple(types) = ty.kind() {\n                         // Only do it if tuple is also a pair with two scalars\n                         if let [ty1, ty2] = types[..] {\n-                            let alloc = self.use_ecx(|this| {\n-                                let ty_is_scalar = |ty| {\n-                                    this.ecx.layout_of(ty).ok().map(|layout| layout.abi.is_scalar())\n-                                        == Some(true)\n-                                };\n-                                if ty_is_scalar(ty1) && ty_is_scalar(ty2) {\n-                                    let alloc = this\n-                                        .ecx\n-                                        .intern_with_temp_alloc(value.layout, |ecx, dest| {\n-                                            ecx.write_immediate(*imm, dest)\n-                                        })\n-                                        .unwrap();\n-                                    Ok(Some(alloc))\n-                                } else {\n-                                    Ok(None)\n-                                }\n-                            });\n-\n-                            if let Some(Some(alloc)) = alloc {\n+                            let ty_is_scalar = |ty| {\n+                                self.ecx.layout_of(ty).ok().map(|layout| layout.abi.is_scalar())\n+                                    == Some(true)\n+                            };\n+                            let alloc = if ty_is_scalar(ty1) && ty_is_scalar(ty2) {\n+                                let alloc = self\n+                                    .ecx\n+                                    .intern_with_temp_alloc(value.layout, |ecx, dest| {\n+                                        ecx.write_immediate(*imm, dest)\n+                                    })\n+                                    .unwrap();\n+                                Some(alloc)\n+                            } else {\n+                                None\n+                            };\n+\n+                            if let Some(alloc) = alloc {\n                                 // Assign entire constant in a single statement.\n                                 // We can't use aggregates, as we run after the aggregate-lowering `MirPhase`.\n                                 let const_val = ConstValue::ByRef { alloc, offset: Size::ZERO };\n@@ -921,84 +896,80 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n-        if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n-            let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n-            if let Some(()) = self.const_prop(rval, place) {\n-                // This will return None if the above `const_prop` invocation only \"wrote\" a\n-                // type whose creation requires no write. E.g. a generator whose initial state\n-                // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                if let Some(ref value) = self.get_const(place) && self.should_const_prop(value) {\n-                    trace!(\"replacing {:?} with {:?}\", rval, value);\n-                    self.replace_with_const(rval, value, source_info);\n-                    if can_const_prop == ConstPropMode::FullConstProp\n-                        || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                    {\n-                        trace!(\"propagated into {:?}\", place);\n+        match statement.kind {\n+            StatementKind::Assign(box (place, ref mut rval)) => {\n+                let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n+                if let Some(()) = self.const_prop(rval, place) {\n+                    // This will return None if the above `const_prop` invocation only \"wrote\" a\n+                    // type whose creation requires no write. E.g. a generator whose initial state\n+                    // consists solely of uninitialized memory (so it doesn't capture any locals).\n+                    if let Some(ref value) = self.get_const(place) && self.should_const_prop(value) {\n+                        trace!(\"replacing {:?} with {:?}\", rval, value);\n+                        self.replace_with_const(rval, value, source_info);\n+                        if can_const_prop == ConstPropMode::FullConstProp\n+                            || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n+                        {\n+                            trace!(\"propagated into {:?}\", place);\n+                        }\n                     }\n-                }\n-                match can_const_prop {\n-                    ConstPropMode::OnlyInsideOwnBlock => {\n-                        trace!(\n-                            \"found local restricted to its block. \\\n+                    match can_const_prop {\n+                        ConstPropMode::OnlyInsideOwnBlock => {\n+                            trace!(\n+                                \"found local restricted to its block. \\\n                                 Will remove it from const-prop after block is finished. Local: {:?}\",\n-                            place.local\n-                        );\n-                    }\n-                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                        trace!(\"can't propagate into {:?}\", place);\n-                        if place.local != RETURN_PLACE {\n-                            Self::remove_const(&mut self.ecx, place.local);\n+                                place.local\n+                            );\n                         }\n-                    }\n-                    ConstPropMode::FullConstProp => {}\n-                }\n-            } else {\n-                // Const prop failed, so erase the destination, ensuring that whatever happens\n-                // from here on, does not know about the previous value.\n-                // This is important in case we have\n-                // ```rust\n-                // let mut x = 42;\n-                // x = SOME_MUTABLE_STATIC;\n-                // // x must now be uninit\n-                // ```\n-                // FIXME: we overzealously erase the entire local, because that's easier to\n-                // implement.\n-                trace!(\n-                    \"propagation into {:?} failed.\n-                        Nuking the entire site from orbit, it's the only way to be sure\",\n-                    place,\n-                );\n-                Self::remove_const(&mut self.ecx, place.local);\n-            }\n-        } else {\n-            match statement.kind {\n-                StatementKind::SetDiscriminant { ref place, .. } => {\n-                    match self.ecx.machine.can_const_prop[place.local] {\n-                        ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n-                            if self.use_ecx(|this| this.ecx.statement(statement)).is_some() {\n-                                trace!(\"propped discriminant into {:?}\", place);\n-                            } else {\n+                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                            trace!(\"can't propagate into {:?}\", place);\n+                            if place.local != RETURN_PLACE {\n                                 Self::remove_const(&mut self.ecx, place.local);\n                             }\n                         }\n-                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                            Self::remove_const(&mut self.ecx, place.local);\n-                        }\n+                        ConstPropMode::FullConstProp => {}\n                     }\n+                } else {\n+                    // Const prop failed, so erase the destination, ensuring that whatever happens\n+                    // from here on, does not know about the previous value.\n+                    // This is important in case we have\n+                    // ```rust\n+                    // let mut x = 42;\n+                    // x = SOME_MUTABLE_STATIC;\n+                    // // x must now be uninit\n+                    // ```\n+                    // FIXME: we overzealously erase the entire local, because that's easier to\n+                    // implement.\n+                    trace!(\n+                        \"propagation into {:?} failed.\n+                        Nuking the entire site from orbit, it's the only way to be sure\",\n+                        place,\n+                    );\n+                    Self::remove_const(&mut self.ecx, place.local);\n                 }\n-                StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n-                    let frame = self.ecx.frame_mut();\n-                    frame.locals[local].value =\n-                        if let StatementKind::StorageLive(_) = statement.kind {\n-                            LocalValue::Live(interpret::Operand::Immediate(\n-                                interpret::Immediate::Uninit,\n-                            ))\n+            }\n+            StatementKind::SetDiscriminant { ref place, .. } => {\n+                match self.ecx.machine.can_const_prop[place.local] {\n+                    ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n+                        if self.ecx.statement(statement).is_ok() {\n+                            trace!(\"propped discriminant into {:?}\", place);\n                         } else {\n-                            LocalValue::Dead\n-                        };\n+                            Self::remove_const(&mut self.ecx, place.local);\n+                        }\n+                    }\n+                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                        Self::remove_const(&mut self.ecx, place.local);\n+                    }\n                 }\n-                _ => {}\n             }\n+            StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value = if let StatementKind::StorageLive(_) = statement.kind {\n+                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n+                } else {\n+                    LocalValue::Dead\n+                };\n+            }\n+            _ => {}\n         }\n \n         self.super_statement(statement, location);\n@@ -1008,12 +979,10 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         let source_info = terminator.source_info;\n         self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n-        // Do NOT early return in this function, it does some crucial fixup of the state at the end!\n+\n         match &mut terminator.kind {\n             TerminatorKind::Assert { expected, ref mut cond, .. } => {\n                 if let Some(ref value) = self.eval_operand(&cond)\n-                    // FIXME should be used use_ecx rather than a local match... but we have\n-                    // quite a few of these read_scalar/read_immediate that need fixing.\n                     && let Ok(value_const) = self.ecx.read_scalar(&value)\n                     && self.should_const_prop(value)\n                 {\n@@ -1050,6 +1019,10 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             // gated on `mir_opt_level=3`.\n             TerminatorKind::Call { .. } => {}\n         }\n+    }\n+\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n+        self.super_basic_block_data(block, data);\n \n         // We remove all Locals which are restricted in propagation to their containing blocks and\n         // which were modified in the current block."}]}