{"sha": "bc11475a2a0f06d5083a7032764a50e5f8ade130", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMTE0NzVhMmEwZjA2ZDUwODNhNzAzMjc2NGE1MGU1ZjhhZGUxMzA=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-14T19:40:51Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-15T16:31:33Z"}, "message": "Properly qualify trait methods in qualify_path assist", "tree": {"sha": "bc9f1fde67ad95fbd8061779469897576f233cc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc9f1fde67ad95fbd8061779469897576f233cc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc11475a2a0f06d5083a7032764a50e5f8ade130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc11475a2a0f06d5083a7032764a50e5f8ade130", "html_url": "https://github.com/rust-lang/rust/commit/bc11475a2a0f06d5083a7032764a50e5f8ade130", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc11475a2a0f06d5083a7032764a50e5f8ade130/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d983f18df7dd484ec43510111169180d7abe038d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d983f18df7dd484ec43510111169180d7abe038d", "html_url": "https://github.com/rust-lang/rust/commit/d983f18df7dd484ec43510111169180d7abe038d"}], "stats": {"total": 188, "additions": 118, "deletions": 70}, "files": [{"sha": "13e390a1f5e9e22b34bb79e4c27b88931ef02723", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc11475a2a0f06d5083a7032764a50e5f8ade130/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc11475a2a0f06d5083a7032764a50e5f8ade130/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=bc11475a2a0f06d5083a7032764a50e5f8ade130", "patch": "@@ -45,7 +45,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let group = import_group_message(import_assets.import_candidate());\n     let scope = ImportScope::find_insert_use_container(import_assets.syntax_under_caret(), ctx)?;\n     let syntax = scope.as_syntax_node();\n-    for import in proposed_imports {\n+    for (import, _) in proposed_imports {\n         acc.add_group(\n             &group,\n             AssistId(\"auto_import\", AssistKind::QuickFix),"}, {"sha": "479ff498cc7889a5077eeae541a8e4eadcf82767", "filename": "crates/assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 78, "deletions": 46, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bc11475a2a0f06d5083a7032764a50e5f8ade130/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc11475a2a0f06d5083a7032764a50e5f8ade130/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=bc11475a2a0f06d5083a7032764a50e5f8ade130", "patch": "@@ -1,6 +1,12 @@\n-use std::collections::BTreeSet;\n-\n-use syntax::{ast, AstNode, TextRange};\n+use std::iter;\n+\n+use hir::AsName;\n+use ide_db::RootDatabase;\n+use syntax::{\n+    ast,\n+    ast::{make, ArgListOwner},\n+    AstNode, TextRange,\n+};\n use test_utils::mark;\n \n use crate::{\n@@ -10,6 +16,8 @@ use crate::{\n     AssistId, AssistKind, GroupLabel,\n };\n \n+const ASSIST_ID: AssistId = AssistId(\"qualify_path\", AssistKind::QuickFix);\n+\n // Assist: qualify_path\n //\n // If the name is unresolved, provides all possible qualified paths for it.\n@@ -53,30 +61,14 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         ImportCandidate::UnqualifiedName(candidate) => {\n             qualify_path_unqualified_name(acc, proposed_imports, range, &candidate.name)\n         }\n-        ImportCandidate::TraitAssocItem(candidate) => {\n+        ImportCandidate::TraitAssocItem(_) => {\n             let path = ast::Path::cast(import_assets.syntax_under_caret().clone())?;\n             let (qualifier, segment) = (path.qualifier()?, path.segment()?);\n-            qualify_path_trait_assoc_item(\n-                acc,\n-                proposed_imports,\n-                range,\n-                qualifier,\n-                segment,\n-                &candidate.name,\n-            )\n+            qualify_path_trait_assoc_item(acc, proposed_imports, range, qualifier, segment)\n         }\n-        ImportCandidate::TraitMethod(candidate) => {\n+        ImportCandidate::TraitMethod(_) => {\n             let mcall_expr = ast::MethodCallExpr::cast(import_assets.syntax_under_caret().clone())?;\n-            let receiver = mcall_expr.receiver()?;\n-            let name_ref = mcall_expr.name_ref()?;\n-            qualify_path_trait_method(\n-                acc,\n-                proposed_imports,\n-                range,\n-                receiver,\n-                name_ref,\n-                &candidate.name,\n-            )\n+            qualify_path_trait_method(acc, ctx.sema.db, proposed_imports, range, mcall_expr)?;\n         }\n     };\n     Some(())\n@@ -85,17 +77,17 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n // a test that covers this -> `associated_struct_const`\n fn qualify_path_qualifier_start(\n     acc: &mut Assists,\n-    proposed_imports: BTreeSet<hir::ModPath>,\n+    proposed_imports: Vec<(hir::ModPath, hir::ItemInNs)>,\n     range: TextRange,\n     segment: ast::PathSegment,\n-    qualifier_start: &str,\n+    qualifier_start: &ast::NameRef,\n ) {\n     mark::hit!(qualify_path_qualifier_start);\n     let group_label = GroupLabel(format!(\"Qualify {}\", qualifier_start));\n-    for import in proposed_imports {\n+    for (import, _) in proposed_imports {\n         acc.add_group(\n             &group_label,\n-            AssistId(\"qualify_path\", AssistKind::QuickFix),\n+            ASSIST_ID,\n             format!(\"Qualify with `{}`\", &import),\n             range,\n             |builder| {\n@@ -109,16 +101,16 @@ fn qualify_path_qualifier_start(\n // a test that covers this -> `applicable_when_found_an_import_partial`\n fn qualify_path_unqualified_name(\n     acc: &mut Assists,\n-    proposed_imports: BTreeSet<hir::ModPath>,\n+    proposed_imports: Vec<(hir::ModPath, hir::ItemInNs)>,\n     range: TextRange,\n-    name: &str,\n+    name: &ast::NameRef,\n ) {\n     mark::hit!(qualify_path_unqualified_name);\n     let group_label = GroupLabel(format!(\"Qualify {}\", name));\n-    for import in proposed_imports {\n+    for (import, _) in proposed_imports {\n         acc.add_group(\n             &group_label,\n-            AssistId(\"qualify_path\", AssistKind::QuickFix),\n+            ASSIST_ID,\n             format!(\"Qualify as `{}`\", &import),\n             range,\n             |builder| builder.replace(range, mod_path_to_ast(&import).to_string()),\n@@ -129,18 +121,17 @@ fn qualify_path_unqualified_name(\n // a test that covers this -> `associated_trait_const`\n fn qualify_path_trait_assoc_item(\n     acc: &mut Assists,\n-    proposed_imports: BTreeSet<hir::ModPath>,\n+    proposed_imports: Vec<(hir::ModPath, hir::ItemInNs)>,\n     range: TextRange,\n     qualifier: ast::Path,\n     segment: ast::PathSegment,\n-    trait_assoc_item_name: &str,\n ) {\n     mark::hit!(qualify_path_trait_assoc_item);\n-    let group_label = GroupLabel(format!(\"Qualify {}\", trait_assoc_item_name));\n-    for import in proposed_imports {\n+    let group_label = GroupLabel(format!(\"Qualify {}\", &segment));\n+    for (import, _) in proposed_imports {\n         acc.add_group(\n             &group_label,\n-            AssistId(\"qualify_path\", AssistKind::QuickFix),\n+            ASSIST_ID,\n             format!(\"Qualify with cast as `{}`\", &import),\n             range,\n             |builder| {\n@@ -154,33 +145,74 @@ fn qualify_path_trait_assoc_item(\n // a test that covers this -> `trait_method`\n fn qualify_path_trait_method(\n     acc: &mut Assists,\n-    proposed_imports: BTreeSet<hir::ModPath>,\n+    db: &RootDatabase,\n+    proposed_imports: Vec<(hir::ModPath, hir::ItemInNs)>,\n     range: TextRange,\n-    receiver: ast::Expr,\n-    name_ref: ast::NameRef,\n-    trait_method_name: &str,\n-) {\n+    mcall_expr: ast::MethodCallExpr,\n+) -> Option<()> {\n     mark::hit!(qualify_path_trait_method);\n+\n+    let receiver = mcall_expr.receiver()?;\n+    let trait_method_name = mcall_expr.name_ref()?;\n+    let arg_list = mcall_expr.arg_list().map(|arg_list| arg_list.args());\n     let group_label = GroupLabel(format!(\"Qualify {}\", trait_method_name));\n-    for import in proposed_imports {\n+    let find_method = |item: &hir::AssocItem| {\n+        item.name(db).map(|name| name == trait_method_name.as_name()).unwrap_or(false)\n+    };\n+    for (import, trait_) in proposed_imports.into_iter().filter_map(filter_trait) {\n         acc.add_group(\n             &group_label,\n-            AssistId(\"qualify_path\", AssistKind::QuickFix), // < Does this still count as quickfix?\n+            ASSIST_ID,\n             format!(\"Qualify `{}`\", &import),\n             range,\n             |builder| {\n                 let import = mod_path_to_ast(&import);\n-                // TODO: check the receiver self type and emit refs accordingly, don't discard other function parameters\n-                builder.replace(range, format!(\"{}::{}(&{})\", import, name_ref, receiver));\n+                if let Some(hir::AssocItem::Function(method)) =\n+                    trait_.items(db).into_iter().find(find_method)\n+                {\n+                    if let Some(self_access) = method.self_param(db).map(|sp| sp.access(db)) {\n+                        let receiver = receiver.clone();\n+                        let receiver = match self_access {\n+                            hir::Access::Shared => make::expr_ref(receiver, false),\n+                            hir::Access::Exclusive => make::expr_ref(receiver, true),\n+                            hir::Access::Owned => receiver,\n+                        };\n+                        builder.replace(\n+                            range,\n+                            format!(\n+                                \"{}::{}{}\",\n+                                import,\n+                                trait_method_name,\n+                                match arg_list.clone() {\n+                                    Some(args) => make::arg_list(iter::once(receiver).chain(args)),\n+                                    None => make::arg_list(iter::once(receiver)),\n+                                }\n+                            ),\n+                        );\n+                    }\n+                }\n             },\n         );\n     }\n+    Some(())\n+}\n+\n+fn filter_trait(\n+    (import, trait_): (hir::ModPath, hir::ItemInNs),\n+) -> Option<(hir::ModPath, hir::Trait)> {\n+    if let hir::ModuleDef::Trait(trait_) = hir::ModuleDef::from(trait_.as_module_def_id()?) {\n+        Some((import, trait_))\n+    } else {\n+        None\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n+\n+    use super::*;\n+\n     #[test]\n     fn applicable_when_found_an_import_partial() {\n         mark::check!(qualify_path_unqualified_name);"}, {"sha": "7d561826318125f00171671eda6348582d9f9b27", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc11475a2a0f06d5083a7032764a50e5f8ade130/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc11475a2a0f06d5083a7032764a50e5f8ade130/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=bc11475a2a0f06d5083a7032764a50e5f8ade130", "patch": "@@ -712,6 +712,25 @@ fn handle(action: Action) {\n     )\n }\n \n+#[test]\n+fn doctest_qualify_path() {\n+    check_doc_test(\n+        \"qualify_path\",\n+        r#####\"\n+fn main() {\n+    let map = HashMap<|>::new();\n+}\n+pub mod std { pub mod collections { pub struct HashMap { } } }\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let map = std::collections::HashMap::new();\n+}\n+pub mod std { pub mod collections { pub struct HashMap { } } }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_remove_dbg() {\n     check_doc_test("}, {"sha": "23db3a74bdb1e814ad7318a6e597907502db4c2b", "filename": "crates/assists/src/utils/import_assets.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bc11475a2a0f06d5083a7032764a50e5f8ade130/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc11475a2a0f06d5083a7032764a50e5f8ade130/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs?ref=bc11475a2a0f06d5083a7032764a50e5f8ade130", "patch": "@@ -1,6 +1,4 @@\n //! Look up accessible paths for items.\n-use std::collections::BTreeSet;\n-\n use either::Either;\n use hir::{AsAssocItem, AssocItemContainer, ModuleDef, Semantics};\n use ide_db::{imports_locator, RootDatabase};\n@@ -29,12 +27,12 @@ pub(crate) enum ImportCandidate {\n #[derive(Debug)]\n pub(crate) struct TraitImportCandidate {\n     pub ty: hir::Type,\n-    pub name: String,\n+    pub name: ast::NameRef,\n }\n \n #[derive(Debug)]\n pub(crate) struct PathImportCandidate {\n-    pub name: String,\n+    pub name: ast::NameRef,\n }\n \n #[derive(Debug)]\n@@ -86,17 +84,17 @@ impl ImportAssets {\n     fn get_search_query(&self) -> &str {\n         match &self.import_candidate {\n             ImportCandidate::UnqualifiedName(candidate)\n-            | ImportCandidate::QualifierStart(candidate) => &candidate.name,\n+            | ImportCandidate::QualifierStart(candidate) => candidate.name.text(),\n             ImportCandidate::TraitAssocItem(candidate)\n-            | ImportCandidate::TraitMethod(candidate) => &candidate.name,\n+            | ImportCandidate::TraitMethod(candidate) => candidate.name.text(),\n         }\n     }\n \n     pub(crate) fn search_for_imports(\n         &self,\n         sema: &Semantics<RootDatabase>,\n         config: &InsertUseConfig,\n-    ) -> BTreeSet<hir::ModPath> {\n+    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n         let _p = profile::span(\"import_assists::search_for_imports\");\n         self.search_for(sema, Some(config.prefix_kind))\n     }\n@@ -106,7 +104,7 @@ impl ImportAssets {\n     pub(crate) fn search_for_relative_paths(\n         &self,\n         sema: &Semantics<RootDatabase>,\n-    ) -> BTreeSet<hir::ModPath> {\n+    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n         let _p = profile::span(\"import_assists::search_for_relative_paths\");\n         self.search_for(sema, None)\n     }\n@@ -115,7 +113,7 @@ impl ImportAssets {\n         &self,\n         sema: &Semantics<RootDatabase>,\n         prefixed: Option<hir::PrefixKind>,\n-    ) -> BTreeSet<hir::ModPath> {\n+    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n         let db = sema.db;\n         let mut trait_candidates = FxHashSet::default();\n         let current_crate = self.module_with_name_to_import.krate();\n@@ -181,7 +179,7 @@ impl ImportAssets {\n             }\n         };\n \n-        imports_locator::find_imports(sema, current_crate, &self.get_search_query())\n+        let mut res = imports_locator::find_imports(sema, current_crate, &self.get_search_query())\n             .into_iter()\n             .filter_map(filter)\n             .filter_map(|candidate| {\n@@ -191,10 +189,13 @@ impl ImportAssets {\n                 } else {\n                     self.module_with_name_to_import.find_use_path(db, item)\n                 }\n+                .map(|path| (path, item))\n             })\n-            .filter(|use_path| !use_path.segments.is_empty())\n+            .filter(|(use_path, _)| !use_path.segments.is_empty())\n             .take(20)\n-            .collect::<BTreeSet<_>>()\n+            .collect::<Vec<_>>();\n+        res.sort_by_key(|(path, _)| path.clone());\n+        res\n     }\n \n     fn assoc_to_trait(assoc: AssocItemContainer) -> Option<hir::Trait> {\n@@ -215,7 +216,7 @@ impl ImportCandidate {\n             Some(_) => None,\n             None => Some(Self::TraitMethod(TraitImportCandidate {\n                 ty: sema.type_of_expr(&method_call.receiver()?)?,\n-                name: method_call.name_ref()?.syntax().to_string(),\n+                name: method_call.name_ref()?,\n             })),\n         }\n     }\n@@ -243,24 +244,17 @@ impl ImportCandidate {\n                     hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => {\n                         ImportCandidate::TraitAssocItem(TraitImportCandidate {\n                             ty: assoc_item_path.ty(sema.db),\n-                            name: segment.syntax().to_string(),\n+                            name: segment.name_ref()?,\n                         })\n                     }\n                     _ => return None,\n                 }\n             } else {\n-                ImportCandidate::QualifierStart(PathImportCandidate {\n-                    name: qualifier_start.syntax().to_string(),\n-                })\n+                ImportCandidate::QualifierStart(PathImportCandidate { name: qualifier_start })\n             }\n         } else {\n             ImportCandidate::UnqualifiedName(PathImportCandidate {\n-                name: segment\n-                    .syntax()\n-                    .descendants()\n-                    .find_map(ast::NameRef::cast)?\n-                    .syntax()\n-                    .to_string(),\n+                name: segment.syntax().descendants().find_map(ast::NameRef::cast)?,\n             })\n         };\n         Some(candidate)"}, {"sha": "5b06cb7671882a1de9fda237b39d98013c5bbcb7", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc11475a2a0f06d5083a7032764a50e5f8ade130/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc11475a2a0f06d5083a7032764a50e5f8ade130/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=bc11475a2a0f06d5083a7032764a50e5f8ade130", "patch": "@@ -172,6 +172,9 @@ pub fn expr_call(f: ast::Expr, arg_list: ast::ArgList) -> ast::Expr {\n pub fn expr_method_call(receiver: ast::Expr, method: &str, arg_list: ast::ArgList) -> ast::Expr {\n     expr_from_text(&format!(\"{}.{}{}\", receiver, method, arg_list))\n }\n+pub fn expr_ref(expr: ast::Expr, exclusive: bool) -> ast::Expr {\n+    expr_from_text(&if exclusive { format!(\"&mut {}\", expr) } else { format!(\"&{}\", expr) })\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }"}]}