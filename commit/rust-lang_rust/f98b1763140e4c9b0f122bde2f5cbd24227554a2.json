{"sha": "f98b1763140e4c9b0f122bde2f5cbd24227554a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5OGIxNzYzMTQwZTRjOWIwZjEyMmJkZTJmNWNiZDI0MjI3NTU0YTI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-10T10:28:44Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-11T21:39:16Z"}, "message": "syntax: gather common fields of impl & trait items into their respective types.", "tree": {"sha": "70e9da4c25e7f110b2ac58f3c6500dbb309bf772", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70e9da4c25e7f110b2ac58f3c6500dbb309bf772"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f98b1763140e4c9b0f122bde2f5cbd24227554a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f98b1763140e4c9b0f122bde2f5cbd24227554a2", "html_url": "https://github.com/rust-lang/rust/commit/f98b1763140e4c9b0f122bde2f5cbd24227554a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f98b1763140e4c9b0f122bde2f5cbd24227554a2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98491827b920884e4ea1182dcacce2a650dde861", "url": "https://api.github.com/repos/rust-lang/rust/commits/98491827b920884e4ea1182dcacce2a650dde861", "html_url": "https://github.com/rust-lang/rust/commit/98491827b920884e4ea1182dcacce2a650dde861"}], "stats": {"total": 3022, "additions": 1179, "deletions": 1843}, "files": [{"sha": "9aa6395b7b278b11b21bdf2c198340e956c4390b", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -519,28 +519,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v ast::FnDecl,\n                 body: &'v ast::Block, span: Span, id: ast::NodeId) {\n-        match fk {\n-            visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(&m.attrs, |cx| {\n-                    run_lints!(cx, check_fn, fk, decl, body, span, id);\n-                    cx.visit_ids(|v| {\n-                        v.visit_fn(fk, decl, body, span, id);\n-                    });\n-                    visit::walk_fn(cx, fk, decl, body, span);\n-                })\n-            },\n-            _ => {\n-                run_lints!(self, check_fn, fk, decl, body, span, id);\n-                visit::walk_fn(self, fk, decl, body, span);\n-            }\n-        }\n-    }\n-\n-    fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n-        self.with_lint_attrs(&t.attrs, |cx| {\n-            run_lints!(cx, check_ty_method, t);\n-            visit::walk_ty_method(cx, t);\n-        })\n+        run_lints!(self, check_fn, fk, decl, body, span, id);\n+        visit::walk_fn(self, fk, decl, body, span);\n     }\n \n     fn visit_struct_def(&mut self,\n@@ -611,9 +591,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         visit::walk_generics(self, g);\n     }\n \n-    fn visit_trait_item(&mut self, m: &ast::TraitItem) {\n-        run_lints!(self, check_trait_item, m);\n-        visit::walk_trait_item(self, m);\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        self.with_lint_attrs(&trait_item.attrs, |cx| {\n+            run_lints!(cx, check_trait_item, trait_item);\n+            cx.visit_ids(|v| v.visit_trait_item(trait_item));\n+            visit::walk_trait_item(cx, trait_item);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        self.with_lint_attrs(&impl_item.attrs, |cx| {\n+            run_lints!(cx, check_impl_item, impl_item);\n+            cx.visit_ids(|v| v.visit_impl_item(impl_item));\n+            visit::walk_impl_item(cx, impl_item);\n+        });\n     }\n \n     fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>) {"}, {"sha": "23f9cbc3a4b9cd37391b80598ee2c52a97840bd5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -143,8 +143,8 @@ pub trait LintPass {\n     fn check_generics(&mut self, _: &Context, _: &ast::Generics) { }\n     fn check_fn(&mut self, _: &Context,\n         _: FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n-    fn check_ty_method(&mut self, _: &Context, _: &ast::TypeMethod) { }\n     fn check_trait_item(&mut self, _: &Context, _: &ast::TraitItem) { }\n+    fn check_impl_item(&mut self, _: &Context, _: &ast::ImplItem) { }\n     fn check_struct_def(&mut self, _: &Context,\n         _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n     fn check_struct_def_post(&mut self, _: &Context,"}, {"sha": "0c220ab8766d20630733244dbb49e4f3af14aab4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 17, "deletions": 42, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -808,7 +808,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     impl_path: PathElems,\n                                     is_default_impl: bool,\n                                     parent_id: NodeId,\n-                                    ast_item_opt: Option<&ast::ImplItem>) {\n+                                    impl_item_opt: Option<&ast::ImplItem>) {\n \n     debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n            token::get_name(m.name));\n@@ -826,21 +826,20 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     let elem = ast_map::PathName(m.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n-    match ast_item_opt {\n-        Some(&ast::MethodImplItem(ref ast_method)) => {\n-            encode_attributes(rbml_w, &ast_method.attrs);\n+    if let Some(impl_item) = impl_item_opt {\n+        if let ast::MethodImplItem(ref ast_method) = impl_item.node {\n+            encode_attributes(rbml_w, &impl_item.attrs);\n             let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n-            if any_types || is_default_impl || attr::requests_inline(&ast_method.attrs) {\n+            if any_types || is_default_impl || attr::requests_inline(&impl_item.attrs) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n-                                                               ast_item_opt.unwrap()));\n+                                                               impl_item));\n             }\n             if !any_types {\n                 encode_symbol(ecx, rbml_w, m.def_id.node);\n             }\n             encode_method_argument_names(rbml_w, ast_method.pe_fn_decl());\n         }\n-        Some(_) | None => {}\n     }\n \n     rbml_w.end_tag();\n@@ -851,7 +850,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n                                    associated_type: &ty::AssociatedType,\n                                    impl_path: PathElems,\n                                    parent_id: NodeId,\n-                                   typedef_opt: Option<&ast::Typedef>) {\n+                                   impl_item_opt: Option<&ast::ImplItem>) {\n     debug!(\"encode_info_for_associated_type({:?},{:?})\",\n            associated_type.def_id,\n            token::get_name(associated_type.name));\n@@ -873,9 +872,9 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     let elem = ast_map::PathName(associated_type.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n \n-    if let Some(typedef) = typedef_opt {\n-        encode_attributes(rbml_w, &typedef.attrs);\n-        encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx, typedef.id));\n+    if let Some(ii) = impl_item_opt {\n+        encode_attributes(rbml_w, &ii.attrs);\n+        encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx, ii.id));\n     }\n \n     rbml_w.end_tag();\n@@ -1232,11 +1231,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 pos: rbml_w.mark_stable_position(),\n             });\n \n-            let trait_item_type =\n-                ty::impl_or_trait_item(tcx, trait_item_def_id.def_id());\n-            match (trait_item_type, ast_item) {\n-                (ty::MethodTraitItem(ref method_type),\n-                 Some(&ast::MethodImplItem(_))) => {\n+            match ty::impl_or_trait_item(tcx, trait_item_def_id.def_id()) {\n+                ty::MethodTraitItem(ref method_type) => {\n                     encode_info_for_method(ecx,\n                                            rbml_w,\n                                            &**method_type,\n@@ -1245,31 +1241,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                            item.id,\n                                            ast_item)\n                 }\n-                (ty::MethodTraitItem(ref method_type), _) => {\n-                    encode_info_for_method(ecx,\n-                                           rbml_w,\n-                                           &**method_type,\n-                                           path.clone(),\n-                                           false,\n-                                           item.id,\n-                                           None)\n-                }\n-                (ty::TypeTraitItem(ref associated_type),\n-                 Some(&ast::TypeImplItem(ref typedef))) => {\n-                    encode_info_for_associated_type(ecx,\n-                                                    rbml_w,\n-                                                    &**associated_type,\n-                                                    path.clone(),\n-                                                    item.id,\n-                                                    Some(typedef))\n-                }\n-                (ty::TypeTraitItem(ref associated_type), _) => {\n+                ty::TypeTraitItem(ref associated_type) => {\n                     encode_info_for_associated_type(ecx,\n                                                     rbml_w,\n                                                     &**associated_type,\n                                                     path.clone(),\n                                                     item.id,\n-                                                    None)\n+                                                    ast_item)\n                 }\n             }\n         }\n@@ -1393,25 +1371,22 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_bounds_and_type_for_item(rbml_w, ecx, item_def_id.def_id().local_id());\n                 }\n             };\n-            match *trait_item {\n+            encode_attributes(rbml_w, &trait_item.attrs);\n+            match trait_item.node {\n                 ast::RequiredMethod(ref m) => {\n-                    encode_attributes(rbml_w, &m.attrs);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n                 ast::ProvidedMethod(ref m) => {\n-                    encode_attributes(rbml_w, &m.attrs);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n                     encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n                 }\n \n-                ast::TypeTraitItem(ref associated_type) => {\n-                    encode_attributes(rbml_w,\n-                                      &associated_type.attrs);\n+                ast::TypeTraitItem(..) => {\n                     encode_item_sort(rbml_w, 't');\n                 }\n             }"}, {"sha": "fb5b934c2cd8d9b4010dceca1fd0d60aaa7f8630", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 13, "deletions": 50, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -32,7 +32,6 @@ use middle::ty::{self, Ty, MethodCall, MethodCallee, MethodOrigin};\n use util::ppaux::ty_to_string;\n \n use syntax::{ast, ast_map, ast_util, codemap, fold};\n-use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::parse::token;\n@@ -81,11 +80,8 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     let id = match ii {\n         e::IIItemRef(i) => i.id,\n         e::IIForeignRef(i) => i.id,\n-        e::IITraitItemRef(_, &ast::ProvidedMethod(ref m)) => m.id,\n-        e::IITraitItemRef(_, &ast::RequiredMethod(ref m)) => m.id,\n-        e::IITraitItemRef(_, &ast::TypeTraitItem(ref ti)) => ti.ty_param.id,\n-        e::IIImplItemRef(_, &ast::MethodImplItem(ref m)) => m.id,\n-        e::IIImplItemRef(_, &ast::TypeImplItem(ref ti)) => ti.id,\n+        e::IITraitItemRef(_, ti) => ti.id,\n+        e::IIImplItemRef(_, ii) => ii.id,\n     };\n     debug!(\"> Encoding inlined item: {} ({:?})\",\n            ecx.tcx.map.path_to_string(id),\n@@ -157,19 +153,8 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         let ident = match *ii {\n             ast::IIItem(ref i) => i.ident,\n             ast::IIForeign(ref i) => i.ident,\n-            ast::IITraitItem(_, ref ti) => {\n-                match *ti {\n-                    ast::ProvidedMethod(ref m) => m.pe_ident(),\n-                    ast::RequiredMethod(ref ty_m) => ty_m.ident,\n-                    ast::TypeTraitItem(ref ti) => ti.ty_param.ident,\n-                }\n-            },\n-            ast::IIImplItem(_, ref m) => {\n-                match *m {\n-                    ast::MethodImplItem(ref m) => m.pe_ident(),\n-                    ast::TypeImplItem(ref ti) => ti.ident,\n-                }\n-            }\n+            ast::IITraitItem(_, ref ti) => ti.ident,\n+            ast::IIImplItem(_, ref ii) => ii.ident\n         };\n         debug!(\"Fn named: {}\", token::get_ident(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\",\n@@ -412,38 +397,16 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n                             .expect_one(\"expected one item\"))\n         }\n         e::IITraitItemRef(d, ti) => {\n-            ast::IITraitItem(d, match *ti {\n-                ast::ProvidedMethod(ref m) => {\n-                    ast::ProvidedMethod(\n-                        fold::noop_fold_method(m.clone(), &mut fld)\n-                            .expect_one(\"noop_fold_method must produce \\\n-                                         exactly one method\"))\n-                }\n-                ast::RequiredMethod(ref ty_m) => {\n-                    ast::RequiredMethod(\n-                        fold::noop_fold_type_method(ty_m.clone(), &mut fld))\n-                }\n-                ast::TypeTraitItem(ref associated_type) => {\n-                    ast::TypeTraitItem(\n-                        fold::noop_fold_associated_type(\n-                            (*associated_type).clone(),\n-                            &mut fld))\n-                }\n-            })\n+            ast::IITraitItem(d,\n+                fold::noop_fold_trait_item(P(ti.clone()), &mut fld)\n+                    .expect_one(\"noop_fold_trait_item must produce \\\n+                                 exactly one trait item\"))\n         }\n-        e::IIImplItemRef(d, m) => {\n-            ast::IIImplItem(d, match *m {\n-                ast::MethodImplItem(ref m) => {\n-                    ast::MethodImplItem(\n-                        fold::noop_fold_method(m.clone(), &mut fld)\n-                            .expect_one(\"noop_fold_method must produce \\\n-                                         exactly one method\"))\n-                }\n-                ast::TypeImplItem(ref td) => {\n-                    ast::TypeImplItem(\n-                        fold::noop_fold_typedef((*td).clone(), &mut fld))\n-                }\n-            })\n+        e::IIImplItemRef(d, ii) => {\n+            ast::IIImplItem(d,\n+                fold::noop_fold_impl_item(P(ii.clone()), &mut fld)\n+                    .expect_one(\"noop_fold_impl_item must produce \\\n+                                 exactly one impl item\"))\n         }\n         e::IIForeignRef(i) => {\n             ast::IIForeign(fold::noop_fold_foreign_item(P(i.clone()), &mut fld))"}, {"sha": "6517378c75cd1453073bbb1629f9e343d87e4f8d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -228,16 +228,11 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     _ => ()\n                 }\n             }\n-            ast_map::NodeTraitItem(trait_method) => {\n-                visit::walk_trait_item(self, trait_method);\n+            ast_map::NodeTraitItem(trait_item) => {\n+                visit::walk_trait_item(self, trait_item);\n             }\n             ast_map::NodeImplItem(impl_item) => {\n-                match *impl_item {\n-                    ast::MethodImplItem(ref method) => {\n-                        visit::walk_method_helper(self, method);\n-                    }\n-                    ast::TypeImplItem(_) => {}\n-                }\n+                visit::walk_impl_item(self, impl_item);\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n                 visit::walk_foreign_item(self, &*foreign_item);\n@@ -355,11 +350,26 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemEnum(ref enum_def, _) if allow_dead_code => {\n                 self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n             }\n-            ast::ItemImpl(_, _, _, Some(ref _trait_ref), _, ref impl_items) => {\n+            ast::ItemTrait(_, _, _, ref trait_items) => {\n+                for trait_item in trait_items {\n+                    match trait_item.node {\n+                        ast::ProvidedMethod(_) => {\n+                            if has_allow_dead_code_or_lang_attr(&trait_item.attrs) {\n+                                self.worklist.push(trait_item.id);\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            ast::ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n                 for impl_item in impl_items {\n-                    match **impl_item {\n-                        ast::MethodImplItem(ref method) => {\n-                            self.worklist.push(method.id);\n+                    match impl_item.node {\n+                        ast::MethodImplItem(_) => {\n+                            if opt_trait.is_some() ||\n+                                    has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n+                                self.worklist.push(impl_item.id);\n+                            }\n                         }\n                         ast::TypeImplItem(_) => {}\n                     }\n@@ -369,21 +379,6 @@ impl<'v> Visitor<'v> for LifeSeeder {\n         }\n         visit::walk_item(self, item);\n     }\n-\n-    fn visit_fn(&mut self, fk: visit::FnKind<'v>,\n-                _: &'v ast::FnDecl, block: &'v ast::Block,\n-                _: codemap::Span, id: ast::NodeId) {\n-        // Check for method here because methods are not ast::Item\n-        match fk {\n-            visit::FkMethod(_, _, method) => {\n-                if has_allow_dead_code_or_lang_attr(&method.attrs) {\n-                    self.worklist.push(id);\n-                }\n-            }\n-            _ => ()\n-        }\n-        visit::walk_block(self, block);\n-    }\n }\n \n fn create_and_seed_worklist(tcx: &ty::ctxt,\n@@ -561,7 +556,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                 span: codemap::Span, id: ast::NodeId) {\n         // Have to warn method here because methods are not ast::Item\n         match fk {\n-            visit::FkMethod(name, _, _) => {\n+            visit::FkMethod(name, _) => {\n                 if !self.symbol_is_live(id, None) {\n                     self.warn_dead_code(id, span, name, \"method\");\n                 }\n@@ -582,12 +577,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n \n     // Overwrite so that we don't warn the trait method itself.\n     fn visit_trait_item(&mut self, trait_method: &ast::TraitItem) {\n-        match *trait_method {\n+        match trait_method.node {\n             ast::ProvidedMethod(ref method) => {\n-                visit::walk_block(self, &*method.pe_body())\n+                visit::walk_block(self, method.pe_body())\n             }\n             ast::RequiredMethod(_) |\n-            ast::TypeTraitItem(_) => {}\n+            ast::TypeTraitItem(..) => {}\n         }\n     }\n }"}, {"sha": "5b5e5b6555b918f804fbe72178f2918a0118d8d5", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             visit::FkItemFn(_, _, fn_style, _) =>\n                 (true, fn_style == ast::Unsafety::Unsafe),\n-            visit::FkMethod(_, _, method) =>\n+            visit::FkMethod(_, method) =>\n                 (true, method.pe_unsafety() == ast::Unsafety::Unsafe),\n             _ => (false, false),\n         };"}, {"sha": "cf3715bc3fbe8ec8f9490f224940fd3b75cbf449", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -846,28 +846,28 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                         _ => None\n                     }\n                 }\n-                ast_map::NodeImplItem(ref item) => {\n-                    match **item {\n+                ast_map::NodeImplItem(item) => {\n+                    match item.node {\n                         ast::MethodImplItem(ref m) => {\n                             Some((m.pe_fn_decl(),\n                                   m.pe_generics(),\n                                   m.pe_unsafety(),\n-                                  m.pe_ident(),\n+                                  item.ident,\n                                   Some(&m.pe_explicit_self().node),\n-                                  m.span))\n+                                  item.span))\n                         }\n                         ast::TypeImplItem(_) => None,\n                     }\n                 },\n-                ast_map::NodeTraitItem(ref item) => {\n-                    match **item {\n+                ast_map::NodeTraitItem(item) => {\n+                    match item.node {\n                         ast::ProvidedMethod(ref m) => {\n                             Some((m.pe_fn_decl(),\n                                   m.pe_generics(),\n                                   m.pe_unsafety(),\n-                                  m.pe_ident(),\n+                                  item.ident,\n                                   Some(&m.pe_explicit_self().node),\n-                                  m.span))\n+                                  item.span))\n                         }\n                         _ => None\n                     }\n@@ -1730,10 +1730,10 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n-                match *ii {\n+                match ii.node {\n                     ast::MethodImplItem(ref m) => {\n                         taken.push_all(&m.pe_generics().lifetimes);\n-                        Some(m.id)\n+                        Some(ii.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n                 }"}, {"sha": "fd6b28fd2922f198f0bdc0283c68d40071609fcb", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -54,8 +54,9 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n }\n \n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n+                           impl_item: &ast::ImplItem,\n                            impl_src: ast::DefId) -> bool {\n-    if attr::requests_inline(&method.attrs) ||\n+    if attr::requests_inline(&impl_item.attrs) ||\n         generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n@@ -66,13 +67,13 @@ fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                     item_might_be_inlined(&*item)\n                 }\n                 Some(..) | None => {\n-                    tcx.sess.span_bug(method.span, \"impl did is not an item\")\n+                    tcx.sess.span_bug(impl_item.span, \"impl did is not an item\")\n                 }\n             }\n         }\n     } else {\n-        tcx.sess.span_bug(method.span, \"found a foreign impl as a parent of a \\\n-                                        local method\")\n+        tcx.sess.span_bug(impl_item.span, \"found a foreign impl as a parent \\\n+                                           of a local method\")\n     }\n }\n \n@@ -181,17 +182,17 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 }\n             }\n             Some(ast_map::NodeTraitItem(trait_method)) => {\n-                match *trait_method {\n+                match trait_method.node {\n                     ast::RequiredMethod(_) => false,\n                     ast::ProvidedMethod(_) => true,\n-                    ast::TypeTraitItem(_) => false,\n+                    ast::TypeTraitItem(..) => false,\n                 }\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n-                match *impl_item {\n+                match impl_item.node {\n                     ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n-                                attr::requests_inline(&method.attrs) {\n+                                attr::requests_inline(&impl_item.attrs) {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -301,21 +302,21 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 }\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n-                match *trait_method {\n+                match trait_method.node {\n                     ast::RequiredMethod(..) => {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::ProvidedMethod(ref method) => {\n                         visit::walk_block(self, &*method.pe_body());\n                     }\n-                    ast::TypeTraitItem(_) => {}\n+                    ast::TypeTraitItem(..) => {}\n                 }\n             }\n             ast_map::NodeImplItem(impl_item) => {\n-                match *impl_item {\n+                match impl_item.node {\n                     ast::MethodImplItem(ref method) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n-                        if method_might_be_inlined(self.tcx, method, did) {\n+                        if method_might_be_inlined(self.tcx, method, impl_item, did) {\n                             visit::walk_block(self, method.pe_body())\n                         }\n                     }"}, {"sha": "e02f786128565dba0973b3e2942fa48f0ca3e287", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -25,6 +25,7 @@ use middle::subst;\n use middle::ty;\n use std::fmt;\n use syntax::ast;\n+use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n@@ -142,12 +143,16 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n                 b: &'v ast::Block, s: Span, _: ast::NodeId) {\n         match fk {\n-            visit::FkItemFn(_, generics, _, _) |\n-            visit::FkMethod(_, generics, _) => {\n+            visit::FkItemFn(_, generics, _, _) => {\n                 self.visit_early_late(subst::FnSpace, generics, |this| {\n                     visit::walk_fn(this, fk, fd, b, s)\n                 })\n             }\n+            visit::FkMethod(_, m) => {\n+                self.visit_early_late(subst::FnSpace, m.pe_generics(), |this| {\n+                    visit::walk_fn(this, fk, fd, b, s)\n+                })\n+            }\n             visit::FkFnBlock(..) => {\n                 visit::walk_fn(self, fk, fd, b, s)\n             }\n@@ -185,10 +190,14 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         }\n     }\n \n-    fn visit_ty_method(&mut self, m: &ast::TypeMethod) {\n-        self.visit_early_late(\n-            subst::FnSpace, &m.generics,\n-            |this| visit::walk_ty_method(this, m))\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        if let ast::RequiredMethod(ref m) = trait_item.node {\n+            self.visit_early_late(\n+                subst::FnSpace, &m.generics,\n+                |this| visit::walk_trait_item(this, trait_item))\n+        } else {\n+            visit::walk_trait_item(self, trait_item);\n+        }\n     }\n \n     fn visit_block(&mut self, b: &ast::Block) {"}, {"sha": "01766b0de085f0c4d32d5f2b70aec2a3d6257366", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -22,10 +22,10 @@ use syntax::codemap::{Span, DUMMY_SP};\n use syntax::{attr, visit};\n use syntax::ast;\n use syntax::ast::{Attribute, Block, Crate, DefId, FnDecl, NodeId, Variant};\n-use syntax::ast::{Item, TypeMethod, Method, Generics, StructField};\n+use syntax::ast::{Item, Generics, StructField};\n use syntax::ast_util::is_local;\n use syntax::attr::{Stability, AttrMetaMethods};\n-use syntax::visit::{FnKind, FkMethod, Visitor};\n+use syntax::visit::{FnKind, Visitor};\n use syntax::feature_gate::emit_feature_warn;\n use util::nodemap::{NodeMap, DefIdMap, FnvHashSet, FnvHashMap};\n use util::ppaux::Repr;\n@@ -123,32 +123,20 @@ impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n         }\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, _: &'v FnDecl,\n-                _: &'v Block, sp: Span, _: NodeId) {\n-        if let FkMethod(_, _, meth) = fk {\n-            // Methods are not already annotated, so we annotate it\n-            self.annotate(meth.id, true, &meth.attrs, sp, |_| {}, true);\n-        }\n+    fn visit_fn(&mut self, _: FnKind<'v>, _: &'v FnDecl,\n+                _: &'v Block, _: Span, _: NodeId) {\n         // Items defined in a function body have no reason to have\n         // a stability attribute, so we don't recurse.\n     }\n \n-    fn visit_trait_item(&mut self, t: &ast::TraitItem) {\n-        let (id, attrs, sp) = match *t {\n-            ast::RequiredMethod(TypeMethod {id, ref attrs, span, ..}) => (id, attrs, span),\n-\n-            // work around lack of pattern matching for @ types\n-            ast::ProvidedMethod(ref method) => {\n-                match *method {\n-                    Method {ref attrs, id, span, ..} => (id, attrs, span),\n-                }\n-            }\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        self.annotate(ti.id, true, &ti.attrs, ti.span,\n+                      |v| visit::walk_trait_item(v, ti), true);\n+    }\n \n-            ast::TypeTraitItem(ref typedef) => {\n-                (typedef.ty_param.id, &typedef.attrs, typedef.ty_param.span)\n-            }\n-        };\n-        self.annotate(id, true, attrs, sp, |v| visit::walk_trait_item(v, t), true);\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        self.annotate(ii.id, true, &ii.attrs, ii.span,\n+                      |v| visit::walk_impl_item(v, ii), true);\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics) {\n@@ -335,22 +323,11 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n             let trait_items = ty::trait_items(tcx, trait_did);\n \n             for impl_item in impl_items {\n-                let (ident, span) = match **impl_item {\n-                    ast::MethodImplItem(ref method) => {\n-                        (match method.node {\n-                            ast::MethDecl(ident, _, _, _, _, _, _, _) => ident,\n-                            ast::MethMac(..) => unreachable!(),\n-                        }, method.span)\n-                    }\n-                    ast::TypeImplItem(ref typedef) => {\n-                        (typedef.ident, typedef.span)\n-                    }\n-                };\n                 let item = trait_items.iter().find(|item| {\n-                    item.name() == ident.name\n+                    item.name() == impl_item.ident.name\n                 }).unwrap();\n                 if warn_about_defns {\n-                    maybe_do_stability_check(tcx, item.def_id(), span, cb);\n+                    maybe_do_stability_check(tcx, item.def_id(), impl_item.span, cb);\n                 }\n             }\n         }"}, {"sha": "32b85d8c0a9be0764610b3e2e766a2f7ee26fdae", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -2286,7 +2286,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n     pub fn for_item(cx: &'a ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n-                match **impl_item {\n+                match impl_item.node {\n                     ast::MethodImplItem(ref method) => {\n                         let method_def_id = ast_util::local_def(id);\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n@@ -2295,7 +2295,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                 let method_bounds = &method_ty.predicates;\n                                 construct_parameter_environment(\n                                     cx,\n-                                    method.span,\n+                                    impl_item.span,\n                                     method_generics,\n                                     method_bounds,\n                                     method.pe_body().id)\n@@ -2315,10 +2315,10 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     }\n                 }\n             }\n-            Some(ast_map::NodeTraitItem(trait_method)) => {\n-                match *trait_method {\n-                    ast::RequiredMethod(ref required) => {\n-                        cx.sess.span_bug(required.span,\n+            Some(ast_map::NodeTraitItem(trait_item)) => {\n+                match trait_item.node {\n+                    ast::RequiredMethod(_) => {\n+                        cx.sess.span_bug(trait_item.span,\n                                          \"ParameterEnvironment::for_item():\n                                           can't create a parameter \\\n                                           environment for required trait \\\n@@ -2332,7 +2332,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                 let method_bounds = &method_ty.predicates;\n                                 construct_parameter_environment(\n                                     cx,\n-                                    method.span,\n+                                    trait_item.span,\n                                     method_generics,\n                                     method_bounds,\n                                     method.pe_body().id)\n@@ -2345,7 +2345,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    ast::TypeTraitItem(_) => {\n+                    ast::TypeTraitItem(..) => {\n                         cx.sess.bug(\"ParameterEnvironment::from_item(): \\\n                                      can't create a parameter environment \\\n                                      for type trait items\")\n@@ -5082,8 +5082,8 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n     if is_local(id) {\n         if let ItemTrait(_, _, _, ref ms) = cx.map.expect_item(id.node).node {\n             ms.iter().filter_map(|ti| {\n-                if let ast::ProvidedMethod(ref m) = **ti {\n-                    match impl_or_trait_item(cx, ast_util::local_def(m.id)) {\n+                if let ast::ProvidedMethod(_) = ti.node {\n+                    match impl_or_trait_item(cx, ast_util::local_def(ti.id)) {\n                         MethodTraitItem(m) => Some(m),\n                         TypeTraitItem(_) => {\n                             cx.sess.bug(\"provided_trait_methods(): \\"}, {"sha": "f1041809701e136f3feaf424ef2053874c68f1c8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -828,14 +828,12 @@ impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ast::TraitItem {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        match *self {\n-            ast::RequiredMethod(ref data) => format!(\"RequiredMethod({}, id={})\",\n-                                                     data.ident, data.id),\n-            ast::ProvidedMethod(ref data) => format!(\"ProvidedMethod(id={})\",\n-                                                     data.id),\n-            ast::TypeTraitItem(ref data) => format!(\"TypeTraitItem({}, id={})\",\n-                                                     data.ty_param.ident, data.ty_param.id),\n-        }\n+        let kind = match self.node {\n+            ast::RequiredMethod(_) => \"RequiredMethod\",\n+            ast::ProvidedMethod(_) => \"ProvidedMethod\",\n+            ast::TypeTraitItem(..) => \"TypeTraitItem\",\n+        };\n+        format!(\"{}({}, id={})\", kind, self.ident, self.id)\n     }\n }\n "}, {"sha": "467b7c1ca381987badf30c6c629cefdead924a30", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -188,8 +188,8 @@ mod svh_visitor {\n         SawTy,\n         SawGenerics,\n         SawFn,\n-        SawTyMethod,\n-        SawTraitMethod,\n+        SawTraitItem,\n+        SawImplItem,\n         SawStructField,\n         SawVariant,\n         SawExplicitSelf,\n@@ -463,12 +463,12 @@ mod svh_visitor {\n             SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n         }\n \n-        fn visit_ty_method(&mut self, t: &TypeMethod) {\n-            SawTyMethod.hash(self.st); visit::walk_ty_method(self, t)\n+        fn visit_trait_item(&mut self, ti: &TraitItem) {\n+            SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n         }\n \n-        fn visit_trait_item(&mut self, t: &TraitItem) {\n-            SawTraitMethod.hash(self.st); visit::walk_trait_item(self, t)\n+        fn visit_impl_item(&mut self, ii: &ImplItem) {\n+            SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n         }\n \n         fn visit_struct_field(&mut self, s: &StructField) {"}, {"sha": "f3abcb4376c9851b9997a350f3733cb5fd276516", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -26,7 +26,6 @@ use rustc::util::ppaux::{Repr, UserString};\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n@@ -119,24 +118,9 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n                                        tcx: &ty::ctxt<'tcx>,\n                                        sp: Span,\n                                        id: ast::NodeId) {\n-    let (span_err, print) = {\n-        let attrs : &[ast::Attribute];\n-        attrs = match tcx.map.find(id) {\n-            Some(ast_map::NodeItem(ref item)) =>\n-                &item.attrs,\n-            Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n-                &m.attrs,\n-            Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n-                &m.attrs,\n-            _ => &[],\n-        };\n-\n-        let span_err =\n-            attrs.iter().any(|a| a.check_name(\"rustc_move_fragments\"));\n-        let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n-\n-        (span_err, print)\n-    };\n+    let span_err = tcx.map.attrs(id).iter()\n+                          .any(|a| a.check_name(\"rustc_move_fragments\"));\n+    let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n \n     if !span_err && !print { return; }\n "}, {"sha": "259a9acadc6db4e94df141fe3754d496538a3af8", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 54, "deletions": 73, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -46,13 +46,12 @@ use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::{abi, ast, ast_map};\n-use syntax::ast_util::is_shift_binop;\n+use syntax::ast_util::{self, is_shift_binop, local_def};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n use syntax::parse::token;\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n-use syntax::ast_util;\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n \n@@ -879,36 +878,18 @@ enum MethodContext {\n     PlainImpl\n }\n \n-fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n-    let did = ast::DefId {\n-        krate: ast::LOCAL_CRATE,\n-        node: m.id\n-    };\n-\n-    match cx.tcx.impl_or_trait_items.borrow().get(&did).cloned() {\n-        None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n-        Some(ty::MethodTraitItem(md)) => {\n-            match md.container {\n-                ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n-                ty::ImplContainer(cid) => {\n-                    match ty::impl_trait_ref(cx.tcx, cid) {\n-                        Some(..) => MethodContext::TraitImpl,\n-                        None => MethodContext::PlainImpl\n-                    }\n+fn method_context(cx: &Context, id: ast::NodeId, span: Span) -> MethodContext {\n+    match cx.tcx.impl_or_trait_items.borrow().get(&local_def(id)) {\n+        None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n+        Some(item) => match item.container() {\n+            ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n+            ty::ImplContainer(cid) => {\n+                match ty::impl_trait_ref(cx.tcx, cid) {\n+                    Some(_) => MethodContext::TraitImpl,\n+                    None => MethodContext::PlainImpl\n                 }\n             }\n-        },\n-        Some(ty::TypeTraitItem(typedef)) => {\n-            match typedef.container {\n-                ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n-                ty::ImplContainer(cid) => {\n-                    match ty::impl_trait_ref(cx.tcx, cid) {\n-                        Some(..) => MethodContext::TraitImpl,\n-                        None => MethodContext::PlainImpl\n-                    }\n-                }\n-            }\n-        },\n+        }\n     }\n }\n \n@@ -999,9 +980,9 @@ impl LintPass for NonSnakeCase {\n \n     fn check_fn(&mut self, cx: &Context,\n                 fk: visit::FnKind, _: &ast::FnDecl,\n-                _: &ast::Block, span: Span, _: ast::NodeId) {\n+                _: &ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n-            visit::FkMethod(ident, _, m) => match method_context(cx, m) {\n+            visit::FkMethod(ident, _) => match method_context(cx, id, span) {\n                 MethodContext::PlainImpl => {\n                     self.check_snake_case(cx, \"method\", ident, span)\n                 },\n@@ -1023,8 +1004,10 @@ impl LintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_ty_method(&mut self, cx: &Context, t: &ast::TypeMethod) {\n-        self.check_snake_case(cx, \"trait method\", t.ident, t.span);\n+    fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n+        if let ast::RequiredMethod(_) = trait_item.node {\n+            self.check_snake_case(cx, \"trait method\", trait_item.ident, trait_item.span);\n+        }\n     }\n \n     fn check_lifetime_def(&mut self, cx: &Context, t: &ast::LifetimeDef) {\n@@ -1335,19 +1318,22 @@ impl LintPass for UnsafeCode {\n             visit::FkItemFn(_, _, ast::Unsafety::Unsafe, _) =>\n                 cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n \n-            visit::FkMethod(_, _, m) => {\n-                if let ast::Method_::MethDecl(_, _, _, _, ast::Unsafety::Unsafe, _, _, _) = m.node {\n-                    cx.span_lint(UNSAFE_CODE, m.span, \"implementation of an `unsafe` method\")\n+            visit::FkMethod(_, m) => {\n+                if let ast::MethDecl(_, _, _, ast::Unsafety::Unsafe, _, _) = *m {\n+                    cx.span_lint(UNSAFE_CODE, span, \"implementation of an `unsafe` method\")\n                 }\n             },\n \n             _ => (),\n         }\n     }\n \n-    fn check_ty_method(&mut self, cx: &Context, ty_method: &ast::TypeMethod) {\n-        if let ast::TypeMethod { unsafety: ast::Unsafety::Unsafe, span, ..} = *ty_method {\n-            cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` method\")\n+    fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n+        if let ast::RequiredMethod(ref m) = trait_item.node {\n+            if m.unsafety == ast::Unsafety::Unsafe {\n+                cx.span_lint(UNSAFE_CODE, trait_item.span,\n+                             \"declaration of an `unsafe` method\")\n+            }\n         }\n     }\n }\n@@ -1576,30 +1562,30 @@ impl LintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n-    fn check_fn(&mut self, cx: &Context, fk: visit::FnKind, _: &ast::FnDecl,\n-                _: &ast::Block, _: Span, _: ast::NodeId) {\n-        if let visit::FkMethod(_, _, m) = fk {\n-            // If the method is an impl for a trait, don't doc.\n-            if method_context(cx, m) == MethodContext::TraitImpl {\n-                return;\n-            }\n-\n-            // Otherwise, doc according to privacy. This will also check\n-            // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs, m.span, \"a method\");\n-        }\n-    }\n-\n-    fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs, tm.span, \"a type method\");\n+    fn check_trait_item(&mut self, cx: &Context, trait_item: &ast::TraitItem) {\n+        let desc = match trait_item.node {\n+            ast::ProvidedMethod(_) => \"a default method\",\n+            ast::RequiredMethod(_) => \"a trait method\",\n+            ast::TypeTraitItem(..) => \"an associated type\"\n+        };\n+        self.check_missing_docs_attrs(cx, Some(trait_item.id),\n+                                      &trait_item.attrs,\n+                                      trait_item.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &Context, it: &ast::TraitItem) {\n-        if let ast::TraitItem::TypeTraitItem(ref ty) = *it {\n-            let assoc_ty = &ty.ty_param;\n-            self.check_missing_docs_attrs(cx, Some(assoc_ty.id), &ty.attrs,\n-                                          assoc_ty.span, \"an associated type\");\n+    fn check_impl_item(&mut self, cx: &Context, impl_item: &ast::ImplItem) {\n+        // If the method is an impl for a trait, don't doc.\n+        if method_context(cx, impl_item.id, impl_item.span) == MethodContext::TraitImpl {\n+            return;\n         }\n+\n+        let desc = match impl_item.node {\n+            ast::MethodImplItem(_) => \"a method\",\n+            ast::TypeImplItem(_) => \"an associated type\"\n+        };\n+        self.check_missing_docs_attrs(cx, Some(impl_item.id),\n+                                      &impl_item.attrs,\n+                                      impl_item.span, desc);\n     }\n \n     fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n@@ -1644,27 +1630,22 @@ impl LintPass for MissingCopyImplementations {\n         if !cx.exported_items.contains(&item.id) {\n             return;\n         }\n-        if cx.tcx\n-             .destructor_for_type\n-             .borrow()\n-             .contains_key(&ast_util::local_def(item.id)) {\n+        if cx.tcx.destructor_for_type.borrow().contains_key(&local_def(item.id)) {\n             return;\n         }\n         let ty = match item.node {\n             ast::ItemStruct(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                ty::mk_struct(cx.tcx,\n-                              ast_util::local_def(item.id),\n+                ty::mk_struct(cx.tcx, local_def(item.id),\n                               cx.tcx.mk_substs(Substs::empty()))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                ty::mk_enum(cx.tcx,\n-                            ast_util::local_def(item.id),\n+                ty::mk_enum(cx.tcx, local_def(item.id),\n                             cx.tcx.mk_substs(Substs::empty()))\n             }\n             _ => return,\n@@ -1828,13 +1809,13 @@ impl LintPass for UnconditionalRecursion {\n \n         let (name, checker) = match fn_kind {\n             visit::FkItemFn(name, _, _, _) => (name, id_refers_to_this_fn as F),\n-            visit::FkMethod(name, _, _) => (name, id_refers_to_this_method as F),\n+            visit::FkMethod(name, _) => (name, id_refers_to_this_method as F),\n             // closures can't recur, so they don't matter.\n             visit::FkFnBlock => return\n         };\n \n-        let impl_def_id = ty::impl_of_method(cx.tcx, ast_util::local_def(id))\n-            .unwrap_or(ast_util::local_def(ast::DUMMY_NODE_ID));\n+        let impl_def_id = ty::impl_of_method(cx.tcx, local_def(id))\n+            .unwrap_or(local_def(ast::DUMMY_NODE_ID));\n         assert!(ast_util::is_local(impl_def_id));\n         let impl_node_id = impl_def_id.node;\n \n@@ -1938,7 +1919,7 @@ impl LintPass for UnconditionalRecursion {\n                                       _: ast::Ident,\n                                       id: ast::NodeId) -> bool {\n             tcx.def_map.borrow().get(&id)\n-               .map_or(false, |def| def.def_id() == ast_util::local_def(fn_id))\n+               .map_or(false, |def| def.def_id() == local_def(fn_id))\n         }\n \n         // check if the method call `id` refers to method `method_id`"}, {"sha": "9cb9c1f2f85eb2bd12bb99893f38af26bdda6d62", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 31, "deletions": 87, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -92,17 +92,9 @@ impl<'v> Visitor<'v> for ParentVisitor {\n             // method to the root. In this case, if the trait is private, then\n             // parent all the methods to the trait to indicate that they're\n             // private.\n-            ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n-                for m in methods {\n-                    match **m {\n-                        ast::ProvidedMethod(ref m) => {\n-                            self.parents.insert(m.id, item.id);\n-                        }\n-                        ast::RequiredMethod(ref m) => {\n-                            self.parents.insert(m.id, item.id);\n-                        }\n-                        ast::TypeTraitItem(_) => {}\n-                    };\n+            ast::ItemTrait(_, _, _, ref trait_items) if item.vis != ast::Public => {\n+                for trait_item in trait_items {\n+                    self.parents.insert(trait_item.id, item.id);\n                 }\n             }\n \n@@ -280,15 +272,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n                 if public_ty || public_trait {\n                     for impl_item in impl_items {\n-                        match **impl_item {\n+                        match impl_item.node {\n                             ast::MethodImplItem(ref method) => {\n                                 let meth_public =\n                                     match method.pe_explicit_self().node {\n                                         ast::SelfStatic => public_ty,\n                                         _ => true,\n-                                    } && method.pe_vis() == ast::Public;\n+                                    } && impl_item.vis == ast::Public;\n                                 if meth_public || tr.is_some() {\n-                                    self.exported_items.insert(method.id);\n+                                    self.exported_items.insert(impl_item.id);\n                                 }\n                             }\n                             ast::TypeImplItem(_) => {}\n@@ -299,22 +291,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n             // Default methods on traits are all public so long as the trait\n             // is public\n-            ast::ItemTrait(_, _, _, ref methods) if public_first => {\n-                for method in methods {\n-                    match **method {\n-                        ast::ProvidedMethod(ref m) => {\n-                            debug!(\"provided {}\", m.id);\n-                            self.exported_items.insert(m.id);\n-                        }\n-                        ast::RequiredMethod(ref m) => {\n-                            debug!(\"required {}\", m.id);\n-                            self.exported_items.insert(m.id);\n-                        }\n-                        ast::TypeTraitItem(ref t) => {\n-                            debug!(\"typedef {}\", t.ty_param.id);\n-                            self.exported_items.insert(t.ty_param.id);\n-                        }\n-                    }\n+            ast::ItemTrait(_, _, _, ref trait_items) if public_first => {\n+                for trait_item in trait_items {\n+                    debug!(\"trait item {}\", trait_item.id);\n+                    self.exported_items.insert(trait_item.id);\n                 }\n             }\n \n@@ -510,16 +490,16 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 // FIXME(#10573) is this the right behavior? Why not consider\n                 //               where the method was defined?\n                 Some(ast_map::NodeImplItem(ii)) => {\n-                    match *ii {\n-                        ast::MethodImplItem(ref m) => {\n+                    match ii.node {\n+                        ast::MethodImplItem(_) => {\n                             let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n                             match ty::impl_trait_ref(self.tcx, imp) {\n                                 Some(..) => return Allowable,\n-                                _ if m.pe_vis() == ast::Public => {\n+                                _ if ii.vis == ast::Public => {\n                                     return Allowable\n                                 }\n-                                _ => m.pe_vis()\n+                                _ => ii.vis\n                             }\n                         }\n                         ast::TypeImplItem(_) => return Allowable,\n@@ -1088,12 +1068,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n                 for impl_item in impl_items {\n-                    match **impl_item {\n-                        ast::MethodImplItem(ref m) => {\n-                            check_inherited(m.span, m.pe_vis(), \"\");\n-                        }\n-                        ast::TypeImplItem(_) => {}\n-                    }\n+                    check_inherited(impl_item.span, impl_item.vis, \"\");\n                 }\n             }\n \n@@ -1121,23 +1096,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ast::ItemTrait(_, _, _, ref methods) => {\n-                for m in methods {\n-                    match **m {\n-                        ast::ProvidedMethod(ref m) => {\n-                            check_inherited(m.span, m.pe_vis(),\n-                                            \"unnecessary visibility\");\n-                        }\n-                        ast::RequiredMethod(ref m) => {\n-                            check_inherited(m.span, m.vis,\n-                                            \"unnecessary visibility\");\n-                        }\n-                        ast::TypeTraitItem(_) => {}\n-                    }\n-                }\n-            }\n-\n-            ast::ItemDefaultImpl(..) |\n+            ast::ItemTrait(..) | ast::ItemDefaultImpl(..) |\n             ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemExternCrate(_) | ast::ItemUse(_) | ast::ItemMac(..) => {}\n@@ -1165,9 +1124,9 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n         match item.node {\n             ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 for impl_item in impl_items {\n-                    match **impl_item {\n-                        ast::MethodImplItem(ref m) => {\n-                            check_inherited(tcx, m.span, m.pe_vis());\n+                    match impl_item.node {\n+                        ast::MethodImplItem(_) => {\n+                            check_inherited(tcx, impl_item.span, impl_item.vis);\n                         }\n                         ast::TypeImplItem(_) => {}\n                     }\n@@ -1186,18 +1145,8 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n             ast::ItemStruct(ref def, _) => check_struct(&**def),\n \n-            ast::ItemTrait(_, _, _, ref methods) => {\n-                for m in methods {\n-                    match **m {\n-                        ast::RequiredMethod(..) => {}\n-                        ast::ProvidedMethod(ref m) => check_inherited(tcx, m.span,\n-                                                                m.pe_vis()),\n-                        ast::TypeTraitItem(_) => {}\n-                    }\n-                }\n-            }\n-\n-            ast::ItemDefaultImpl(..) | ast::ItemExternCrate(_) | ast::ItemUse(_) |\n+            ast::ItemExternCrate(_) | ast::ItemUse(_) |\n+            ast::ItemTrait(..) | ast::ItemDefaultImpl(..) |\n             ast::ItemStatic(..) | ast::ItemConst(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemMac(..) => {}\n@@ -1352,9 +1301,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     trait_ref.is_some() ||\n                     impl_items.iter()\n                               .any(|impl_item| {\n-                                  match **impl_item {\n-                                      ast::MethodImplItem(ref m) => {\n-                                          self.exported_items.contains(&m.id)\n+                                  match impl_item.node {\n+                                      ast::MethodImplItem(_) => {\n+                                          self.exported_items.contains(&impl_item.id)\n                                       }\n                                       ast::TypeImplItem(_) => false,\n                                   }\n@@ -1369,12 +1318,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     match *trait_ref {\n                         None => {\n                             for impl_item in impl_items {\n-                                match **impl_item {\n-                                    ast::MethodImplItem(ref method) => {\n-                                        visit::walk_method_helper(self, method)\n-                                    }\n-                                    ast::TypeImplItem(_) => {}\n-                                }\n+                                visit::walk_impl_item(self, impl_item);\n                             }\n                         }\n                         Some(ref tr) => {\n@@ -1395,10 +1339,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                             // Those in 3. are warned with this call.\n                             for impl_item in impl_items {\n-                                match **impl_item {\n+                                match impl_item.node {\n                                     ast::MethodImplItem(..) => {},\n-                                    ast::TypeImplItem(ref typedef) => {\n-                                        self.visit_ty(&typedef.typ);\n+                                    ast::TypeImplItem(ref ty) => {\n+                                        self.visit_ty(ty);\n                                     }\n                                 }\n                             }\n@@ -1409,14 +1353,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item in impl_items {\n-                        match **impl_item {\n+                        match impl_item.node {\n                             ast::MethodImplItem(ref method) => {\n                                 if method.pe_explicit_self().node ==\n                                         ast::SelfStatic &&\n                                         self.exported_items\n-                                            .contains(&method.id) {\n+                                            .contains(&impl_item.id) {\n                                     found_pub_static = true;\n-                                    visit::walk_method_helper(self, method);\n+                                    visit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n                             ast::TypeImplItem(_) => {}"}, {"sha": "dd762f07b7246d6a4df63af3ee222fac83f98206", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 15, "deletions": 39, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -48,7 +48,7 @@ use syntax::ast::UnnamedField;\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast;\n-use syntax::ast_util::{self, local_def, PostExpansionMethod};\n+use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::{self, special_idents};\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -525,53 +525,29 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n-                    let (name, trait_item_id) = match **trait_item {\n+                    let name_bindings = self.add_child(trait_item.ident.name,\n+                                        &module_parent,\n+                                        ForbidDuplicateTypesAndValues,\n+                                        trait_item.span);\n+\n+                    match trait_item.node {\n                         ast::RequiredMethod(_) |\n                         ast::ProvidedMethod(_) => {\n-                            let (id, name, span) = match **trait_item {\n-                                ast::RequiredMethod(ref m) => {\n-                                    (m.id, m.ident.name, m.span)\n-                                }\n-                                ast::ProvidedMethod(ref m) => {\n-                                    (m.id, m.pe_ident().name, m.span)\n-                                }\n-                                _ => unreachable!()\n-                            };\n-\n-                            // Add it as a name in the trait module.\n-                            let def = DefMethod(local_def(id),\n+                            let def = DefMethod(local_def(trait_item.id),\n                                                 FromTrait(local_def(item.id)));\n-\n-                            let method_name_bindings =\n-                                self.add_child(name,\n-                                               &module_parent,\n-                                               ForbidDuplicateTypesAndValues,\n-                                               span);\n                             // NB: not IMPORTABLE\n-                            method_name_bindings.define_value(def, span, PUBLIC);\n-\n-                            (name, local_def(id))\n+                            name_bindings.define_value(def, trait_item.span, PUBLIC);\n                         }\n-                        ast::TypeTraitItem(ref associated_type) => {\n+                        ast::TypeTraitItem(..) => {\n                             let def = DefAssociatedTy(local_def(item.id),\n-                                                      local_def(associated_type.ty_param.id));\n-\n-                            let name_bindings =\n-                                self.add_child(associated_type.ty_param.ident.name,\n-                                               &module_parent,\n-                                               ForbidDuplicateTypesAndValues,\n-                                               associated_type.ty_param.span);\n+                                                      local_def(trait_item.id));\n                             // NB: not IMPORTABLE\n-                            name_bindings.define_type(def,\n-                                                      associated_type.ty_param.span,\n-                                                      PUBLIC);\n-\n-                            (associated_type.ty_param.ident.name,\n-                             local_def(associated_type.ty_param.id))\n+                            name_bindings.define_type(def, trait_item.span, PUBLIC);\n                         }\n-                    };\n+                    }\n \n-                    self.trait_item_map.insert((name, def_id), trait_item_id);\n+                    self.trait_item_map.insert((trait_item.ident.name, def_id),\n+                                               local_def(trait_item.id));\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, modifiers);"}, {"sha": "67675a5a1ae702d2c54ed522fbeb049980e88feb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -242,8 +242,8 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n-            visit::FkMethod(_, generics, method) => {\n-                self.visit_generics(generics);\n+            visit::FkMethod(_, method) => {\n+                self.visit_generics(method.pe_generics());\n                 self.visit_explicit_self(method.pe_explicit_self());\n                 MethodRibKind\n             }\n@@ -2807,13 +2807,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     this.visit_generics(generics);\n                     visit::walk_ty_param_bounds_helper(this, bounds);\n \n-                    for trait_item in &(*trait_items) {\n+                    for trait_item in trait_items {\n                         // Create a new rib for the trait_item-specific type\n                         // parameters.\n                         //\n                         // FIXME #4951: Do we need a node ID here?\n \n-                        let type_parameters = match **trait_item {\n+                        let type_parameters = match trait_item.node {\n                             ast::RequiredMethod(ref ty_m) => {\n                                 HasTypeParameters(&ty_m.generics,\n                                                   FnSpace,\n@@ -2824,10 +2824,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                   FnSpace,\n                                                   MethodRibKind)\n                             }\n-                            ast::TypeTraitItem(ref assoc_ty) => {\n-                                let ty_param = &assoc_ty.ty_param;\n-                                this.check_if_primitive_type_name(ty_param.ident.name,\n-                                                                  ty_param.span);\n+                            ast::TypeTraitItem(..) => {\n+                                this.check_if_primitive_type_name(trait_item.ident.name,\n+                                                                  trait_item.span);\n                                 NoTypeParameters\n                             }\n                         };\n@@ -3066,12 +3065,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 this.with_current_self_type(self_type, |this| {\n                     for impl_item in impl_items {\n-                        match **impl_item {\n+                        match impl_item.node {\n                             MethodImplItem(ref method) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n-                                this.check_trait_item(method.pe_ident().name,\n-                                                      method.span);\n+                                this.check_trait_item(impl_item.ident.name,\n+                                                      impl_item.span);\n \n                                 // We also need a new scope for the method-\n                                 // specific type parameters.\n@@ -3080,16 +3079,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                       FnSpace,\n                                                       MethodRibKind);\n                                 this.with_type_parameter_rib(type_parameters, |this| {\n-                                    visit::walk_method_helper(this, method);\n+                                    visit::walk_impl_item(this, impl_item);\n                                 });\n                             }\n-                            TypeImplItem(ref typedef) => {\n+                            TypeImplItem(ref ty) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n-                                this.check_trait_item(typedef.ident.name,\n-                                                      typedef.span);\n+                                this.check_trait_item(impl_item.ident.name,\n+                                                      impl_item.span);\n \n-                                this.visit_ty(&*typedef.typ);\n+                                this.visit_ty(ty);\n                             }\n                         }\n                     }\n@@ -3955,12 +3954,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         fn is_static_method(this: &Resolver, did: DefId) -> bool {\n             if did.krate == ast::LOCAL_CRATE {\n                 let explicit_self = match this.ast_map.get(did.node) {\n-                    ast_map::NodeTraitItem(m) => match *m {\n+                    ast_map::NodeTraitItem(trait_item) => match trait_item.node {\n                         ast::RequiredMethod(ref m) => &m.explicit_self,\n                         ast::ProvidedMethod(ref m) => m.pe_explicit_self(),\n                         _ => return false\n                     },\n-                    ast_map::NodeImplItem(m) => match *m {\n+                    ast_map::NodeImplItem(impl_item) => match impl_item.node {\n                         ast::MethodImplItem(ref m) => m.pe_explicit_self(),\n                         _ => return false\n                     },"}, {"sha": "953650209645b6a11c135c664318f1b0fe95b428", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 53, "deletions": 69, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -284,16 +284,18 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_method(&mut self, method: &ast::Method) {\n-        if generated_code(method.span) {\n+    fn process_method(&mut self, method: &ast::Method,\n+                      id: ast::NodeId, ident: ast::Ident,\n+                      span: Span) {\n+        if generated_code(span) {\n             return;\n         }\n \n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n-                                                ast_util::local_def(method.id)) {\n+                                                ast_util::local_def(id)) {\n             Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n@@ -303,7 +305,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             result.push_str(&ty_to_string(&**ty));\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n-                                                    ast_util::local_def(method.id)) {\n+                                                    ast_util::local_def(id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n@@ -315,54 +317,50 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             result\n                         }\n                         _ => {\n-                            self.sess.span_bug(method.span,\n-                                               &format!(\"Container {} for method {} not an impl?\",\n-                                                       impl_id.node, method.id));\n+                            self.sess.span_bug(span,\n+                                &format!(\"Container {} for method {} not an impl?\",\n+                                         impl_id.node, id));\n                         },\n                     }\n                 },\n                 _ => {\n-                    self.sess.span_bug(method.span,\n-                                       &format!(\n-                                           \"Container {} for method {} is not a node item {:?}\",\n-                                           impl_id.node,\n-                                           method.id,\n-                                           self.analysis.ty_cx.map.get(impl_id.node)));\n+                    self.sess.span_bug(span,\n+                        &format!(\"Container {} for method {} is not a node item {:?}\",\n+                                 impl_id.node, id, self.analysis.ty_cx.map.get(impl_id.node)));\n                 },\n             },\n             None => match ty::trait_of_item(&self.analysis.ty_cx,\n-                                            ast_util::local_def(method.id)) {\n+                                            ast_util::local_def(id)) {\n                 Some(def_id) => {\n                     scope_id = def_id.node;\n                     match self.analysis.ty_cx.map.get(def_id.node) {\n                         NodeItem(_) => {\n                             format!(\"::{}\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n                         }\n                         _ => {\n-                            self.sess.span_bug(method.span,\n-                                               &format!(\"Could not find container {} for method {}\",\n-                                                       def_id.node, method.id));\n+                            self.sess.span_bug(span,\n+                                &format!(\"Could not find container {} for method {}\",\n+                                         def_id.node, id));\n                         }\n                     }\n                 },\n                 None => {\n-                    self.sess.span_bug(method.span,\n-                                       &format!(\"Could not find container for method {}\",\n-                                               method.id));\n+                    self.sess.span_bug(span,\n+                        &format!(\"Could not find container for method {}\", id));\n                 },\n             },\n         };\n \n-        let qualname = format!(\"{}::{}\", qualname, &get_ident(method.pe_ident()));\n+        let qualname = format!(\"{}::{}\", qualname, &get_ident(ident));\n         let qualname = &qualname[..];\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n-                                             ast_util::local_def(method.id))\n+                                             ast_util::local_def(id))\n             .and_then(|def_id| {\n                 if match def_id {\n                     ty::MethodTraitItemId(def_id) => {\n-                        def_id.node != 0 && def_id != ast_util::local_def(method.id)\n+                        def_id.node != 0 && def_id != ast_util::local_def(id)\n                     }\n                     ty::TypeTraitItemId(_) => false,\n                 } {\n@@ -376,10 +374,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             Some(id) => Some(id.def_id()),\n         };\n \n-        let sub_span = self.span.sub_span_after_keyword(method.span, keywords::Fn);\n-        self.fmt.method_str(method.span,\n+        let sub_span = self.span.sub_span_after_keyword(span, keywords::Fn);\n+        self.fmt.method_str(span,\n                             sub_span,\n-                            method.id,\n+                            id,\n                             qualname,\n                             decl_id,\n                             scope_id);\n@@ -396,12 +394,12 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         // walk the fn body\n-        self.nest(method.id, |v| v.visit_block(&*method.pe_body()));\n+        self.nest(id, |v| v.visit_block(&*method.pe_body()));\n \n         self.process_generic_params(method.pe_generics(),\n-                                    method.span,\n+                                    span,\n                                     qualname,\n-                                    method.id);\n+                                    id);\n     }\n \n     fn process_trait_ref(&mut self,\n@@ -698,14 +696,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n-            match **impl_item {\n-                ast::MethodImplItem(ref method) => {\n-                    visit::walk_method_helper(self, method)\n-                }\n-                ast::TypeImplItem(ref typedef) => {\n-                    visit::walk_ty(self, &*typedef.typ)\n-                }\n-            }\n+            visit::walk_impl_item(self, impl_item);\n         }\n     }\n \n@@ -1233,52 +1224,34 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    // We don't actually index functions here, that is done in visit_item/ItemFn.\n-    // Here we just visit methods.\n-    fn visit_fn(&mut self,\n-                fk: visit::FnKind<'v>,\n-                fd: &'v ast::FnDecl,\n-                b: &'v ast::Block,\n-                s: Span,\n-                _: ast::NodeId) {\n-        if generated_code(s) {\n-            return;\n-        }\n-\n-        match fk {\n-            visit::FkMethod(_, _, method) => self.process_method(method),\n-            _ => visit::walk_fn(self, fk, fd, b, s),\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, tm: &ast::TraitItem) {\n-        match *tm {\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        match trait_item.node {\n             ast::RequiredMethod(ref method_type) => {\n-                if generated_code(method_type.span) {\n+                if generated_code(trait_item.span) {\n                     return;\n                 }\n \n                 let mut scope_id;\n                 let mut qualname = match ty::trait_of_item(&self.analysis.ty_cx,\n-                                                           ast_util::local_def(method_type.id)) {\n+                                                           ast_util::local_def(trait_item.id)) {\n                     Some(def_id) => {\n                         scope_id = def_id.node;\n                         format!(\"::{}::\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n                     },\n                     None => {\n-                        self.sess.span_bug(method_type.span,\n+                        self.sess.span_bug(trait_item.span,\n                                            &format!(\"Could not find trait for method {}\",\n-                                                   method_type.id));\n+                                                   trait_item.id));\n                     },\n                 };\n \n-                qualname.push_str(&get_ident(method_type.ident));\n+                qualname.push_str(&get_ident(trait_item.ident));\n                 let qualname = &qualname[..];\n \n-                let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n-                self.fmt.method_decl_str(method_type.span,\n+                let sub_span = self.span.sub_span_after_keyword(trait_item.span, keywords::Fn);\n+                self.fmt.method_decl_str(trait_item.span,\n                                          sub_span,\n-                                         method_type.id,\n+                                         trait_item.id,\n                                          qualname,\n                                          scope_id);\n \n@@ -1292,12 +1265,23 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 self.process_generic_params(&method_type.generics,\n-                                            method_type.span,\n+                                            trait_item.span,\n                                             qualname,\n-                                            method_type.id);\n+                                            trait_item.id);\n+            }\n+            ast::ProvidedMethod(ref method) => {\n+                self.process_method(method, trait_item.id, trait_item.ident, trait_item.span);\n+            }\n+            ast::TypeTraitItem(..) => {}\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        match impl_item.node {\n+            ast::MethodImplItem(ref method) => {\n+                self.process_method(method, impl_item.id, impl_item.ident, impl_item.span);\n             }\n-            ast::ProvidedMethod(ref method) => self.process_method(method),\n-            ast::TypeTraitItem(_) => {}\n+            ast::TypeImplItem(_) => {}\n         }\n     }\n "}, {"sha": "9616bf8b648936df78f9c0153d0f31c99ceae84f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 32, "deletions": 47, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -94,7 +94,7 @@ use std::rc::Rc;\n use std::str;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{Rust, RustCall, RustIntrinsic, Abi};\n-use syntax::ast_util::local_def;\n+use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -1263,41 +1263,27 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         Some(ast_map::NodeItem(i)) => {\n             match i.node {\n                 ast::ItemFn(_, _, _, _, ref blk) => {\n-                    blk\n+                    &**blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n             }\n         }\n-        Some(ast_map::NodeTraitItem(trait_method)) => {\n-            match *trait_method {\n-                ast::ProvidedMethod(ref m) => {\n-                    match m.node {\n-                        ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n-                            blk\n-                        }\n-                        ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n-                    }\n-                }\n+        Some(ast_map::NodeTraitItem(trait_item)) => {\n+            match trait_item.node {\n+                ast::ProvidedMethod(ref m) => m.pe_body(),\n                 ast::RequiredMethod(_) => {\n                     tcx.sess.bug(\"unexpected variant: required trait method \\\n                                   in has_nested_returns\")\n                 }\n-                ast::TypeTraitItem(_) => {\n+                ast::TypeTraitItem(..) => {\n                     tcx.sess.bug(\"unexpected variant: associated type trait item in \\\n                                   has_nested_returns\")\n                 }\n             }\n         }\n-        Some(ast_map::NodeImplItem(ii)) => {\n-            match *ii {\n-                ast::MethodImplItem(ref m) => {\n-                    match m.node {\n-                        ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n-                            blk\n-                        }\n-                        ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n-                    }\n-                }\n+        Some(ast_map::NodeImplItem(impl_item)) => {\n+            match impl_item.node {\n+                ast::MethodImplItem(ref m) => m.pe_body(),\n                 ast::TypeImplItem(_) => {\n                     tcx.sess.bug(\"unexpected variant: associated type impl item in \\\n                                   has_nested_returns\")\n@@ -1306,9 +1292,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         }\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n-                ast::ExprClosure(_, _, ref blk) => {\n-                    blk\n-                }\n+                ast::ExprClosure(_, _, ref blk) => &**blk,\n                 _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")\n             }\n         }\n@@ -1322,7 +1306,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n                                    tcx.map.path_to_string(id)))\n     };\n \n-    (blk.id, Some(cfg::CFG::new(tcx, &**blk)))\n+    (blk.id, Some(cfg::CFG::new(tcx, blk)))\n }\n \n // Checks for the presence of \"nested returns\" in a function.\n@@ -2818,26 +2802,27 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             v\n         }\n \n-        ast_map::NodeTraitItem(trait_method) => {\n+        ast_map::NodeTraitItem(trait_item) => {\n             debug!(\"get_item_val(): processing a NodeTraitItem\");\n-            match *trait_method {\n-                ast::RequiredMethod(_) | ast::TypeTraitItem(_) => {\n-                    ccx.sess().bug(\"unexpected variant: required trait \\\n-                                    method in get_item_val()\");\n+            match trait_item.node {\n+                ast::RequiredMethod(_) | ast::TypeTraitItem(..) => {\n+                    ccx.sess().span_bug(trait_item.span,\n+                        \"unexpected variant: required trait method in get_item_val()\");\n                 }\n-                ast::ProvidedMethod(ref m) => {\n-                    register_method(ccx, id, m)\n+                ast::ProvidedMethod(_) => {\n+                    register_method(ccx, id, &trait_item.attrs, trait_item.span)\n                 }\n             }\n         }\n \n-        ast_map::NodeImplItem(ii) => {\n-            match *ii {\n-                ast::MethodImplItem(ref m) => register_method(ccx, id, m),\n-                ast::TypeImplItem(ref typedef) => {\n-                    ccx.sess().span_bug(typedef.span,\n-                                        \"unexpected variant: associated type \\\n-                                        in get_item_val()\")\n+        ast_map::NodeImplItem(impl_item) => {\n+            match impl_item.node {\n+                ast::MethodImplItem(_) => {\n+                    register_method(ccx, id, &impl_item.attrs, impl_item.span)\n+                }\n+                ast::TypeImplItem(_) => {\n+                    ccx.sess().span_bug(impl_item.span,\n+                        \"unexpected variant: associated type in get_item_val()\")\n                 }\n             }\n         }\n@@ -2925,21 +2910,21 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n }\n \n fn register_method(ccx: &CrateContext, id: ast::NodeId,\n-                   m: &ast::Method) -> ValueRef {\n+                   attrs: &[ast::Attribute], span: Span) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n-    let sym = exported_name(ccx, id, mty, &m.attrs);\n+    let sym = exported_name(ccx, id, mty, &attrs);\n \n     if let ty::ty_bare_fn(_, ref f) = mty.sty {\n         let llfn = if f.abi == Rust || f.abi == RustCall {\n-            register_fn(ccx, m.span, sym, id, mty)\n+            register_fn(ccx, span, sym, id, mty)\n         } else {\n-            foreign::register_rust_fn_with_foreign_abi(ccx, m.span, sym, id)\n+            foreign::register_rust_fn_with_foreign_abi(ccx, span, sym, id)\n         };\n-        set_llvm_fn_attrs(ccx, &m.attrs, llfn);\n+        set_llvm_fn_attrs(ccx, &attrs, llfn);\n         return llfn;\n     } else {\n-        ccx.sess().span_bug(m.span, \"expected bare rust function\");\n+        ccx.sess().span_bug(span, \"expected bare rust function\");\n     }\n }\n "}, {"sha": "0b98beb53c57a4bd52c521ab0dc04362eae388a9", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -1300,22 +1300,22 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        ast_map::NodeImplItem(ref item) => {\n-            match **item {\n+        ast_map::NodeImplItem(impl_item) => {\n+            match impl_item.node {\n                 ast::MethodImplItem(ref method) => {\n-                    if contains_nodebug_attribute(&method.attrs) {\n+                    if contains_nodebug_attribute(&impl_item.attrs) {\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n-                    (method.pe_ident(),\n+                    (impl_item.ident,\n                      method.pe_fn_decl(),\n                      method.pe_generics(),\n                      method.pe_body(),\n-                     method.span,\n+                     impl_item.span,\n                      true)\n                 }\n-                ast::TypeImplItem(ref typedef) => {\n-                    cx.sess().span_bug(typedef.span,\n+                ast::TypeImplItem(_) => {\n+                    cx.sess().span_bug(impl_item.span,\n                                        \"create_function_debug_context() \\\n                                         called on associated type?!\")\n                 }\n@@ -1339,18 +1339,18 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n-        ast_map::NodeTraitItem(ref trait_method) => {\n-            match **trait_method {\n+        ast_map::NodeTraitItem(trait_item) => {\n+            match trait_item.node {\n                 ast::ProvidedMethod(ref method) => {\n-                    if contains_nodebug_attribute(&method.attrs) {\n+                    if contains_nodebug_attribute(&trait_item.attrs) {\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n-                    (method.pe_ident(),\n+                    (trait_item.ident,\n                      method.pe_fn_decl(),\n                      method.pe_generics(),\n                      method.pe_body(),\n-                     method.span,\n+                     trait_item.span,\n                      true)\n                 }\n                 _ => {"}, {"sha": "6c1401a4c029babc3579ecd404c57d25dd9c7736", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 29, "deletions": 41, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -42,7 +42,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.tcx(), fn_id,\n             Box::new(|a,b,c,d| astencode::decode_inlined_item(a, b, c, d)));\n \n-    let inline_def = match csearch_result {\n+    let inline_id = match csearch_result {\n         csearch::FoundAst::NotFound => {\n             ccx.external().borrow_mut().insert(fn_id, None);\n             return None;\n@@ -88,12 +88,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                 None => {}\n             }\n \n-            local_def(item.id)\n+            item.id\n         }\n         csearch::FoundAst::Found(&ast::IIForeign(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n-            local_def(item.id)\n+            item.id\n         }\n         csearch::FoundAst::FoundParent(parent_id, &ast::IIItem(ref item)) => {\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n@@ -122,65 +122,53 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                                  non-enum, non-struct parent\")\n           }\n           trans_item(ccx, &**item);\n-          local_def(my_id)\n+          my_id\n         }\n         csearch::FoundAst::FoundParent(_, _) => {\n             ccx.sess().bug(\"maybe_get_item_ast returned a FoundParent \\\n              with a non-item parent\");\n         }\n         csearch::FoundAst::Found(&ast::IITraitItem(_, ref trait_item)) => {\n-            let id = match *trait_item {\n-                ast::ProvidedMethod(ref mth) => mth.id,\n-                ast::RequiredMethod(_) => ccx.sess().bug(\"found RequiredMethod IITraitItem\"),\n-                ast::TypeTraitItem(_) => ccx.sess().bug(\"found TypeTraitItem IITraitItem\"),\n-            };\n-            ccx.external().borrow_mut().insert(fn_id, Some(id));\n-            ccx.external_srcs().borrow_mut().insert(id, fn_id);\n+            ccx.external().borrow_mut().insert(fn_id, Some(trait_item.id));\n+            ccx.external_srcs().borrow_mut().insert(trait_item.id, fn_id);\n \n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n \n             // If this is a default method, we can't look up the\n             // impl type. But we aren't going to translate anyways, so\n             // don't.\n-            local_def(id)\n+            trait_item.id\n         }\n         csearch::FoundAst::Found(&ast::IIImplItem(impl_did, ref impl_item)) => {\n-            let (id, monomorphic_method) = match *impl_item {\n-                ast::MethodImplItem(ref mth) => {\n-                    let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n-                    let unparameterized = impl_tpt.generics.types.is_empty() &&\n-                            mth.pe_generics().ty_params.is_empty();\n-\n-                    (mth.id, if unparameterized { Some(mth) } else { None })\n-                }\n-                ast::TypeImplItem(_) => {\n-                    ccx.sess().bug(\"found TypeImplItem IIImplItem\")\n-                }\n-            };\n-\n-            ccx.external().borrow_mut().insert(fn_id, Some(id));\n-            ccx.external_srcs().borrow_mut().insert(id, fn_id);\n+            ccx.external().borrow_mut().insert(fn_id, Some(impl_item.id));\n+            ccx.external_srcs().borrow_mut().insert(impl_item.id, fn_id);\n \n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n \n-            if let Some(mth) = monomorphic_method {\n-                let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                let llfn = get_item_val(ccx, mth.id);\n-                trans_fn(ccx,\n-                         &*mth.pe_fn_decl(),\n-                         &*mth.pe_body(),\n-                         llfn,\n-                         empty_substs,\n-                         mth.id,\n-                         &[]);\n-                // Use InternalLinkage so LLVM can optimize more aggressively.\n-                SetLinkage(llfn, InternalLinkage);\n+            // Translate monomorphic impl methods immediately.\n+            if let ast::MethodImplItem(ref mth) = impl_item.node {\n+                let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n+                if impl_tpt.generics.types.is_empty() &&\n+                        mth.pe_generics().ty_params.is_empty() {\n+                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+                    let llfn = get_item_val(ccx, impl_item.id);\n+                    trans_fn(ccx,\n+                            &*mth.pe_fn_decl(),\n+                            &*mth.pe_body(),\n+                            llfn,\n+                            empty_substs,\n+                            impl_item.id,\n+                            &[]);\n+                    // Use InternalLinkage so LLVM can optimize more aggressively.\n+                    SetLinkage(llfn, InternalLinkage);\n+                }\n             }\n-            local_def(id)\n+\n+            impl_item.id\n         }\n     };\n \n-    return Some(inline_def);\n+    Some(local_def(inline_id))\n }\n \n pub fn get_local_instance(ccx: &CrateContext, fn_id: ast::DefId)"}, {"sha": "aea922d9f9f57d3f52064663f48b3c29908fa521", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -62,45 +62,43 @@ pub fn trans_impl(ccx: &CrateContext,\n \n     debug!(\"trans_impl(name={}, id={})\", name.repr(tcx), id);\n \n+    let mut v = TransItemVisitor { ccx: ccx };\n+\n     // Both here and below with generic methods, be sure to recurse and look for\n     // items that we need to translate.\n     if !generics.ty_params.is_empty() {\n-        let mut v = TransItemVisitor{ ccx: ccx };\n         for impl_item in impl_items {\n-            match **impl_item {\n-                ast::MethodImplItem(ref method) => {\n-                    visit::walk_method_helper(&mut v, method);\n+            match impl_item.node {\n+                ast::MethodImplItem(_) => {\n+                    visit::walk_impl_item(&mut v, impl_item);\n                 }\n                 ast::TypeImplItem(_) => {}\n             }\n         }\n         return;\n     }\n     for impl_item in impl_items {\n-        match **impl_item {\n+        match impl_item.node {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0 {\n-                    let trans_everywhere = attr::requests_inline(&method.attrs);\n+                    let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n-                        let llfn = get_item_val(ccx, method.id);\n+                        let llfn = get_item_val(ccx, impl_item.id);\n                         let empty_substs = tcx.mk_substs(Substs::trans_empty());\n                         trans_fn(ccx,\n                                  method.pe_fn_decl(),\n                                  method.pe_body(),\n                                  llfn,\n                                  empty_substs,\n-                                 method.id,\n+                                 impl_item.id,\n                                  &[]);\n                         update_linkage(ccx,\n                                        llfn,\n-                                       Some(method.id),\n+                                       Some(impl_item.id),\n                                        if is_origin { OriginalTranslation } else { InlinedCopy });\n                     }\n                 }\n-                let mut v = TransItemVisitor {\n-                    ccx: ccx,\n-                };\n-                visit::walk_method_helper(&mut v, method);\n+                visit::walk_impl_item(&mut v, impl_item);\n             }\n             ast::TypeImplItem(_) => {}\n         }\n@@ -190,17 +188,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let mname = if method_id.krate == ast::LOCAL_CRATE {\n         match tcx.map.get(method_id.node) {\n-            ast_map::NodeTraitItem(method) => {\n-                let ident = match *method {\n-                    ast::RequiredMethod(ref m) => m.ident,\n-                    ast::ProvidedMethod(ref m) => m.pe_ident(),\n-                    ast::TypeTraitItem(_) => {\n-                        tcx.sess.bug(\"trans_static_method_callee() on \\\n-                                      an associated type?!\")\n-                    }\n-                };\n-                ident.name\n-            }\n+            ast_map::NodeTraitItem(trait_item) => trait_item.ident.name,\n             _ => panic!(\"callee is not a trait method\")\n         }\n     } else {"}, {"sha": "1af783373f9cee98ff1eb8583cd087ee8e4999be", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -216,18 +216,18 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n             d\n         }\n-        ast_map::NodeImplItem(ii) => {\n-            match *ii {\n+        ast_map::NodeImplItem(impl_item) => {\n+            match impl_item.node {\n                 ast::MethodImplItem(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, &mth.attrs);\n+                    let needs_body = setup_lldecl(d, &impl_item.attrs);\n                     if needs_body {\n                         trans_fn(ccx,\n                                  mth.pe_fn_decl(),\n                                  mth.pe_body(),\n                                  d,\n                                  psubsts,\n-                                 mth.id,\n+                                 impl_item.id,\n                                  &[]);\n                     }\n                     d\n@@ -237,14 +237,14 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        ast_map::NodeTraitItem(method) => {\n-            match *method {\n+        ast_map::NodeTraitItem(trait_item) => {\n+            match trait_item.node {\n                 ast::ProvidedMethod(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, &mth.attrs);\n+                    let needs_body = setup_lldecl(d, &trait_item.attrs);\n                     if needs_body {\n                         trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n-                                 psubsts, mth.id, &[]);\n+                                 psubsts, trait_item.id, &[]);\n                     }\n                     d\n                 }"}, {"sha": "9c2bc4da64f3313d6bdd5d0bd58cfdff00bd0784", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -1095,14 +1095,9 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         // by type collection, which may be in progress at this point.\n         match this.tcx().map.expect_item(trait_did.node).node {\n             ast::ItemTrait(_, _, _, ref trait_items) => {\n-                trait_items.iter().filter_map(|i| {\n-                    if let ast::TypeTraitItem(ref assoc) = **i {\n-                        if assoc.ty_param.ident.name == assoc_name {\n-                            return Some(ast_util::local_def(assoc.ty_param.id));\n-                        }\n-                    }\n-                    None\n-                }).next().expect(\"missing associated type\")\n+                let item = trait_items.iter().find(|i| i.ident.name == assoc_name)\n+                                      .expect(\"missing associated type\");\n+                ast_util::local_def(item.id)\n             }\n             _ => unreachable!()\n         }"}, {"sha": "3ffc36d3acb75985358a2c482932aee520f5a872", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -739,9 +739,10 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n           }\n \n         for impl_item in impl_items {\n-            match **impl_item {\n+            match impl_item.node {\n                 ast::MethodImplItem(ref m) => {\n-                    check_method_body(ccx, &impl_pty.generics, m);\n+                    check_method_body(ccx, &impl_pty.generics, m,\n+                                      impl_item.id, impl_item.span);\n                 }\n                 ast::TypeImplItem(_) => {\n                     // Nothing to do here.\n@@ -750,19 +751,20 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         }\n \n       }\n-      ast::ItemTrait(_, ref generics, _, ref trait_methods) => {\n+      ast::ItemTrait(_, ref generics, _, ref trait_items) => {\n         check_trait_on_unimplemented(ccx, generics, it);\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n-        for trait_method in trait_methods {\n-            match **trait_method {\n+        for trait_item in trait_items {\n+            match trait_item.node {\n                 RequiredMethod(..) => {\n                     // Nothing to do, since required methods don't have\n                     // bodies to check.\n                 }\n                 ProvidedMethod(ref m) => {\n-                    check_method_body(ccx, &trait_def.generics, m);\n+                    check_method_body(ccx, &trait_def.generics, m,\n+                                      trait_item.id, trait_item.span);\n                 }\n-                TypeTraitItem(_) => {\n+                TypeTraitItem(..) => {\n                     // Nothing to do.\n                 }\n             }\n@@ -855,20 +857,20 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// * `method`: the method definition\n fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                item_generics: &ty::Generics<'tcx>,\n-                               method: &'tcx ast::Method) {\n-    debug!(\"check_method_body(item_generics={}, method.id={})\",\n-            item_generics.repr(ccx.tcx),\n-            method.id);\n-    let param_env = ParameterEnvironment::for_item(ccx.tcx, method.id);\n+                               method: &'tcx ast::Method,\n+                               id: ast::NodeId, span: Span) {\n+    debug!(\"check_method_body(item_generics={}, id={})\",\n+            item_generics.repr(ccx.tcx), id);\n+    let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n \n-    let fty = ty::node_id_to_type(ccx.tcx, method.id);\n+    let fty = ty::node_id_to_type(ccx.tcx, id);\n     debug!(\"check_method_body: fty={}\", fty.repr(ccx.tcx));\n \n     check_bare_fn(ccx,\n                   &*method.pe_fn_decl(),\n                   &*method.pe_body(),\n-                  method.id,\n-                  method.span,\n+                  id,\n+                  span,\n                   fty,\n                   param_env);\n }\n@@ -884,9 +886,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        match **impl_item {\n+        match impl_item.node {\n             ast::MethodImplItem(ref impl_method) => {\n-                let impl_method_def_id = local_def(impl_method.id);\n+                let impl_method_def_id = local_def(impl_item.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n                                                           impl_method_def_id);\n \n@@ -902,7 +904,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                              &ty::MethodTraitItem(ref impl_method_ty)) => {\n                                 compare_impl_method(ccx.tcx,\n                                                     &**impl_method_ty,\n-                                                    impl_method.span,\n+                                                    impl_item.span,\n                                                     impl_method.pe_body().id,\n                                                     &**trait_method_ty,\n                                                     &*impl_trait_ref);\n@@ -911,7 +913,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 // This is span_bug as it should have already been\n                                 // caught in resolve.\n                                 tcx.sess.span_bug(\n-                                    impl_method.span,\n+                                    impl_item.span,\n                                     &format!(\"item `{}` is of a different kind from its trait `{}`\",\n                                              token::get_name(impl_item_ty.name()),\n                                              impl_trait_ref.repr(tcx)));\n@@ -922,15 +924,15 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // This is span_bug as it should have already been\n                         // caught in resolve.\n                         tcx.sess.span_bug(\n-                            impl_method.span,\n+                            impl_item.span,\n                             &format!(\"method `{}` is not a member of trait `{}`\",\n                                      token::get_name(impl_item_ty.name()),\n                                      impl_trait_ref.repr(tcx)));\n                     }\n                 }\n             }\n-            ast::TypeImplItem(ref typedef) => {\n-                let typedef_def_id = local_def(typedef.id);\n+            ast::TypeImplItem(_) => {\n+                let typedef_def_id = local_def(impl_item.id);\n                 let typedef_ty = ty::impl_or_trait_item(ccx.tcx,\n                                                         typedef_def_id);\n \n@@ -947,7 +949,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 // This is `span_bug` as it should have\n                                 // already been caught in resolve.\n                                 tcx.sess.span_bug(\n-                                    typedef.span,\n+                                    impl_item.span,\n                                     &format!(\"item `{}` is of a different kind from its trait `{}`\",\n                                              token::get_name(typedef_ty.name()),\n                                              impl_trait_ref.repr(tcx)));\n@@ -958,7 +960,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // This is `span_bug` as it should have already been\n                         // caught in resolve.\n                         tcx.sess.span_bug(\n-                            typedef.span,\n+                            impl_item.span,\n                             &format!(\n                                 \"associated type `{}` is not a member of \\\n                                  trait `{}`\",\n@@ -978,9 +980,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty::MethodTraitItem(ref trait_method) => {\n                 let is_implemented =\n                     impl_items.iter().any(|ii| {\n-                        match **ii {\n-                            ast::MethodImplItem(ref m) => {\n-                                m.pe_ident().name == trait_method.name\n+                        match ii.node {\n+                            ast::MethodImplItem(_) => {\n+                                ii.ident.name == trait_method.name\n                             }\n                             ast::TypeImplItem(_) => false,\n                         }\n@@ -993,9 +995,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n             ty::TypeTraitItem(ref associated_type) => {\n                 let is_implemented = impl_items.iter().any(|ii| {\n-                    match **ii {\n-                        ast::TypeImplItem(ref typedef) => {\n-                            typedef.ident.name == associated_type.name\n+                    match ii.node {\n+                        ast::TypeImplItem(_) => {\n+                            ii.ident.name == associated_type.name\n                         }\n                         ast::MethodImplItem(_) => false,\n                     }"}, {"sha": "0e50938abc447e3efe5a0712c9ca2c926f44981d", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -498,28 +498,24 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         visit::walk_fn(self, fk, fd, b, span)\n     }\n \n-    fn visit_trait_item(&mut self, t: &'v ast::TraitItem) {\n-        match t {\n-            &ast::TraitItem::ProvidedMethod(_) |\n-            &ast::TraitItem::TypeTraitItem(_) => {}\n-            &ast::TraitItem::RequiredMethod(ref method) => {\n-                match ty::impl_or_trait_item(self.tcx(), local_def(method.id)) {\n-                    ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n-                        reject_non_type_param_bounds(\n-                            self.tcx(),\n-                            method.span,\n-                            &ty_method.predicates);\n-                        reject_shadowing_type_parameters(\n-                            self.tcx(),\n-                            method.span,\n-                            &ty_method.generics);\n-                    }\n-                    _ => {}\n+    fn visit_trait_item(&mut self, trait_item: &'v ast::TraitItem) {\n+        if let ast::RequiredMethod(_) = trait_item.node {\n+            match ty::impl_or_trait_item(self.tcx(), local_def(trait_item.id)) {\n+                ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n+                    reject_non_type_param_bounds(\n+                        self.tcx(),\n+                        trait_item.span,\n+                        &ty_method.predicates);\n+                    reject_shadowing_type_parameters(\n+                        self.tcx(),\n+                        trait_item.span,\n+                        &ty_method.generics);\n                 }\n+                _ => {}\n             }\n         }\n \n-        visit::walk_trait_item(self, t)\n+        visit::walk_trait_item(self, trait_item)\n     }\n }\n "}, {"sha": "a4eab5b7a26503225be3ccdd95cedf25fc273978", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -275,20 +275,18 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n-            ItemImpl(_, _, _, ref opt_trait, _, ref ast_items) => {\n+            ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n                 let mut items: Vec<ImplOrTraitItemId> =\n-                        ast_items.iter()\n-                                 .map(|ast_item| {\n-                            match **ast_item {\n-                                ast::MethodImplItem(ref ast_method) => {\n-                                    MethodTraitItemId(\n-                                        local_def(ast_method.id))\n-                                }\n-                                ast::TypeImplItem(ref typedef) => {\n-                                    TypeTraitItemId(local_def(typedef.id))\n-                                }\n-                            }\n-                        }).collect();\n+                        impl_items.iter().map(|impl_item| {\n+                    match impl_item.node {\n+                        ast::MethodImplItem(_) => {\n+                            MethodTraitItemId(local_def(impl_item.id))\n+                        }\n+                        ast::TypeImplItem(_) => {\n+                            TypeTraitItemId(local_def(impl_item.id))\n+                        }\n+                    }\n+                }).collect();\n \n                 if opt_trait.is_some() {\n                     let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,"}, {"sha": "b90129f7ab7f8fa10033b011ae4e13b419a103b0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 116, "deletions": 110, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -631,18 +631,18 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.impl_or_trait_items` table:\n             for trait_item in trait_items {\n-                match **trait_item {\n+                match trait_item.node {\n                     ast::RequiredMethod(_) |\n                     ast::ProvidedMethod(_) => {\n-                        let ty_method = Rc::new(match **trait_item {\n+                        let ty_method = Rc::new(match trait_item.node {\n                             ast::RequiredMethod(ref m) => {\n                                 ty_method_of_trait_method(\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n                                     &trait_predicates,\n-                                    &m.id,\n-                                    &m.ident.name,\n+                                    trait_item.id,\n+                                    trait_item.ident,\n                                     &m.explicit_self,\n                                     m.abi,\n                                     &m.generics,\n@@ -655,18 +655,15 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     trait_id,\n                                     &trait_def.generics,\n                                     &trait_predicates,\n-                                    &m.id,\n-                                    &m.pe_ident().name,\n+                                    trait_item.id,\n+                                    trait_item.ident,\n                                     m.pe_explicit_self(),\n                                     m.pe_abi(),\n                                     m.pe_generics(),\n                                     &m.pe_unsafety(),\n                                     &*m.pe_fn_decl())\n                             }\n-                            ast::TypeTraitItem(ref at) => {\n-                                tcx.sess.span_bug(at.ty_param.span,\n-                                                  \"there shouldn't be a type trait item here\")\n-                            }\n+                            ast::TypeTraitItem(..) => unreachable!()\n                         });\n \n                         debug!(\"ty_method_of_trait_method yielded {} for method {} of trait {}\",\n@@ -680,12 +677,12 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             .borrow_mut()\n                             .insert(ty_method.def_id, ty::MethodTraitItem(ty_method));\n                     }\n-                    ast::TypeTraitItem(ref ast_associated_type) => {\n+                    ast::TypeTraitItem(..) => {\n                         let trait_did = local_def(trait_id);\n                         let associated_type = ty::AssociatedType {\n-                            name: ast_associated_type.ty_param.ident.name,\n+                            name: trait_item.ident.name,\n                             vis: ast::Public,\n-                            def_id: local_def(ast_associated_type.ty_param.id),\n+                            def_id: local_def(trait_item.id),\n                             container: TraitContainer(trait_did),\n                         };\n \n@@ -698,20 +695,18 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n \n             // Add an entry mapping\n-            let trait_item_def_ids =\n-                Rc::new(trait_items.iter().map(|ti| {\n-                    match **ti {\n-                        ast::RequiredMethod(ref ty_method) => {\n-                            ty::MethodTraitItemId(local_def(ty_method.id))\n-                        }\n-                        ast::ProvidedMethod(ref method) => {\n-                            ty::MethodTraitItemId(local_def(method.id))\n-                        }\n-                        ast::TypeTraitItem(ref typedef) => {\n-                            ty::TypeTraitItemId(local_def(typedef.ty_param.id))\n-                        }\n+            let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n+                let def_id = local_def(trait_item.id);\n+                match trait_item.node {\n+                    ast::RequiredMethod(_) |\n+                    ast::ProvidedMethod(_) => {\n+                        ty::MethodTraitItemId(def_id)\n+                    }\n+                    ast::TypeTraitItem(..) => {\n+                        ty::TypeTraitItemId(def_id)\n                     }\n-                }).collect());\n+                }\n+            }).collect());\n \n             let trait_def_id = local_def(trait_id);\n             tcx.trait_item_def_ids.borrow_mut().insert(trait_def_id, trait_item_def_ids);\n@@ -734,8 +729,8 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            trait_id: ast::NodeId,\n                                            trait_generics: &ty::Generics<'tcx>,\n                                            trait_bounds: &ty::GenericPredicates<'tcx>,\n-                                           m_id: &ast::NodeId,\n-                                           m_name: &ast::Name,\n+                                           m_id: ast::NodeId,\n+                                           m_ident: ast::Ident,\n                                            m_explicit_self: &ast::ExplicitSelf,\n                                            m_abi: abi::Abi,\n                                            m_generics: &ast::Generics,\n@@ -760,14 +755,14 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         };\n \n         ty::Method::new(\n-            *m_name,\n+            m_ident.name,\n             ty_generics,\n             ty_generic_predicates,\n             fty,\n             explicit_self_category,\n             // assume public, because this is only invoked on trait methods\n             ast::Public,\n-            local_def(*m_id),\n+            local_def(m_id),\n             TraitContainer(local_def(trait_id)),\n             None\n         )\n@@ -815,12 +810,13 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      trait_def: &ty::TraitDef<'tcx>,\n-                                     associated_type: &ast::AssociatedType)\n+                                     ident: ast::Ident,\n+                                     id: ast::NodeId)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n-        name: associated_type.ty_param.ident.name,\n+        name: ident.name,\n         vis: ast::Public,\n-        def_id: local_def(associated_type.ty_param.id),\n+        def_id: local_def(id),\n         container: TraitContainer(trait_def.trait_ref.def_id),\n     });\n     ccx.tcx\n@@ -831,12 +827,12 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  container: ImplOrTraitItemContainer,\n-                                 ms: I,\n+                                 methods: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n                                  rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n-                                 where I: Iterator<Item=&'i ast::Method>\n+    where I: Iterator<Item=(&'i ast::Method, ast::NodeId, ast::Ident, ast::Visibility, Span)>\n {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={}, rcvr_ty_predicates={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n@@ -845,24 +841,27 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let tcx = ccx.tcx;\n     let mut seen_methods = FnvHashSet();\n-    for m in ms {\n-        if !seen_methods.insert(m.pe_ident().repr(tcx)) {\n-            span_err!(tcx.sess, m.span, E0201, \"duplicate method in trait impl\");\n+    for (m, id, ident, vis, span) in methods {\n+        if !seen_methods.insert(ident.name) {\n+            span_err!(tcx.sess, span, E0201, \"duplicate method in trait impl\");\n         }\n \n-        let m_def_id = local_def(m.id);\n+        let m_def_id = local_def(id);\n \n         let mty = Rc::new(ty_of_method(ccx,\n                                        container,\n                                        m,\n+                                       id,\n+                                       ident,\n+                                       vis,\n                                        untransformed_rcvr_ty,\n                                        rcvr_ty_generics,\n                                        rcvr_ty_predicates,\n                                        rcvr_visibility));\n         let fty = ty::mk_bare_fn(tcx, Some(m_def_id), tcx.mk_bare_fn(mty.fty.clone()));\n         debug!(\"method {} (id {}) has type {}\",\n-                m.pe_ident().repr(tcx),\n-                m.id,\n+                ident.repr(tcx),\n+                id,\n                 fty.repr(tcx));\n         tcx.tcache.borrow_mut().insert(\n             m_def_id,\n@@ -872,7 +871,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n             });\n         tcx.predicates.borrow_mut().insert(m_def_id, mty.predicates.clone());\n \n-        write_ty_to_tcx(tcx, m.id, fty);\n+        write_ty_to_tcx(tcx, id, fty);\n \n         debug!(\"writing method type: def_id={:?} mty={}\",\n                mty.def_id, mty.repr(ccx.tcx));\n@@ -885,6 +884,9 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n     fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               container: ImplOrTraitItemContainer,\n                               m: &ast::Method,\n+                              id: ast::NodeId,\n+                              ident: ast::Ident,\n+                              vis: ast::Visibility,\n                               untransformed_rcvr_ty: Ty<'tcx>,\n                               rcvr_ty_generics: &ty::Generics<'tcx>,\n                               rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n@@ -909,15 +911,15 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n         // inherit the visibility from the impl (so `foo` in `pub impl\n         // { fn foo(); }` is public, but private in `priv impl { fn\n         // foo(); }`).\n-        let method_vis = m.pe_vis().inherit_from(rcvr_visibility);\n+        let method_vis = vis.inherit_from(rcvr_visibility);\n \n-        ty::Method::new(m.pe_ident().name,\n+        ty::Method::new(ident.name,\n                         m_ty_generics,\n                         m_ty_generic_predicates,\n                         fty,\n                         explicit_self_category,\n                         method_vis,\n-                        local_def(m.id),\n+                        local_def(id),\n                         container,\n                         None)\n     }\n@@ -1011,62 +1013,67 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n-            let mut methods = Vec::new();\n             for impl_item in impl_items {\n-                match **impl_item {\n-                    ast::MethodImplItem(ref method) => {\n-                        methods.push(method);\n-                    }\n-                    ast::TypeImplItem(ref typedef) => {\n+                match impl_item.node {\n+                    ast::MethodImplItem(_) => {}\n+                    ast::TypeImplItem(ref ty) => {\n                         if opt_trait_ref.is_none() {\n-                            span_err!(tcx.sess, typedef.span, E0202,\n+                            span_err!(tcx.sess, impl_item.span, E0202,\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n-                        let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &*typedef.typ);\n-                        tcx.tcache.borrow_mut().insert(local_def(typedef.id),\n+                        let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n+                        tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n                                                        TypeScheme {\n                                                            generics: ty::Generics::empty(),\n                                                            ty: typ,\n                                                        });\n-                        tcx.predicates.borrow_mut().insert(local_def(typedef.id),\n+                        tcx.predicates.borrow_mut().insert(local_def(impl_item.id),\n                                                            ty::GenericPredicates::empty());\n-                        write_ty_to_tcx(tcx, typedef.id, typ);\n+                        write_ty_to_tcx(tcx, impl_item.id, typ);\n \n                         let associated_type = Rc::new(ty::AssociatedType {\n-                            name: typedef.ident.name,\n-                            vis: typedef.vis,\n-                            def_id: local_def(typedef.id),\n+                            name: impl_item.ident.name,\n+                            vis: impl_item.vis,\n+                            def_id: local_def(impl_item.id),\n                             container: ty::ImplContainer(local_def(it.id)),\n                         });\n                         tcx.impl_or_trait_items\n                            .borrow_mut()\n-                           .insert(local_def(typedef.id),\n+                           .insert(local_def(impl_item.id),\n                                    ty::TypeTraitItem(associated_type));\n                     }\n                 }\n             }\n \n+            let methods = impl_items.iter().filter_map(|ii| {\n+                match ii.node {\n+                    ast::MethodImplItem(ref m) => {\n+                        Some((m, ii.id, ii.ident, ii.vis, ii.span))\n+                    }\n+                    ast::TypeImplItem(_) => None\n+                }\n+            });\n             convert_methods(ccx,\n                             ImplContainer(local_def(it.id)),\n-                            methods.into_iter(),\n+                            methods,\n                             selfty,\n                             &ty_generics,\n                             &ty_predicates,\n                             parent_visibility);\n \n             for impl_item in impl_items {\n-                match **impl_item {\n+                match impl_item.node {\n                     ast::MethodImplItem(ref method) => {\n                         let body_id = method.pe_body().id;\n                         check_method_self_type(ccx,\n                                                &BindingRscope::new(),\n-                                               ccx.method_ty(method.id),\n+                                               ccx.method_ty(impl_item.id),\n                                                selfty,\n                                                method.pe_explicit_self(),\n                                                body_id);\n                     }\n-                    ast::TypeImplItem(..) => { }\n+                    ast::TypeImplItem(_) => {}\n                 }\n             }\n \n@@ -1092,15 +1099,20 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n+            let methods = trait_items.iter().filter_map(|ti| {\n+                match ti.node {\n+                    ast::ProvidedMethod(ref m) => {\n+                        Some((m, ti.id, ti.ident, ast::Inherited, ti.span))\n+                    }\n+                    ast::RequiredMethod(_) |\n+                    ast::TypeTraitItem(..) => None,\n+                }\n+            });\n             // Run convert_methods on the provided methods.\n             let untransformed_rcvr_ty = ty::mk_self_type(tcx);\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n-                            trait_items.iter().filter_map(|m| match **m {\n-                                ast::RequiredMethod(_) => None,\n-                                ast::ProvidedMethod(ref m) => Some(m),\n-                                ast::TypeTraitItem(_) => None,\n-                            }),\n+                            methods,\n                             untransformed_rcvr_ty,\n                             &trait_def.generics,\n                             &trait_predicates,\n@@ -1115,28 +1127,29 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             // we have a method type stored for every method.\n             for trait_item in trait_items {\n                 let self_type = ty::mk_self_type(tcx);\n-                match **trait_item {\n+                match trait_item.node {\n                     ast::RequiredMethod(ref type_method) => {\n                         let rscope = BindingRscope::new();\n                         check_method_self_type(ccx,\n                                                &rscope,\n-                                               ccx.method_ty(type_method.id),\n+                                               ccx.method_ty(trait_item.id),\n                                                self_type,\n                                                &type_method.explicit_self,\n                                                it.id)\n                     }\n                     ast::ProvidedMethod(ref method) => {\n                         check_method_self_type(ccx,\n                                                &BindingRscope::new(),\n-                                               ccx.method_ty(method.id),\n+                                               ccx.method_ty(trait_item.id),\n                                                self_type,\n                                                method.pe_explicit_self(),\n                                                it.id)\n                     }\n-                    ast::TypeTraitItem(ref associated_type) => {\n+                    ast::TypeTraitItem(..) => {\n                         convert_associated_type(ccx,\n                                                 &*trait_def,\n-                                                associated_type);\n+                                                trait_item.ident,\n+                                                trait_item.id);\n                     }\n                 }\n             }\n@@ -1348,15 +1361,12 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let ty_generics = ty_generics_for_trait(ccx, it.id, substs, generics);\n \n-    let associated_type_names: Vec<_> =\n-        items.iter()\n-             .filter_map(|item| {\n-                 match **item {\n-                     ast::RequiredMethod(_) | ast::ProvidedMethod(_) => None,\n-                     ast::TypeTraitItem(ref data) => Some(data.ty_param.ident.name),\n-                 }\n-             })\n-             .collect();\n+    let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n+        match trait_item.node {\n+            ast::RequiredMethod(_) | ast::ProvidedMethod(_) => None,\n+            ast::TypeTraitItem(..) => Some(trait_item.ident.name),\n+        }\n+    }).collect();\n \n     let trait_ref = Rc::new(ty::TraitRef {\n         def_id: def_id,\n@@ -1423,13 +1433,12 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n         _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not a trait\", trait_node_id))\n     };\n \n-    trait_items.iter()\n-               .any(|trait_item| {\n-                   match *trait_item {\n-                       ast::TypeTraitItem(ref t) => t.ty_param.ident.name == assoc_name,\n-                       ast::RequiredMethod(..) | ast::ProvidedMethod(..) => false,\n-                   }\n-               })\n+    trait_items.iter().any(|trait_item| {\n+        match trait_item.node {\n+            ast::TypeTraitItem(..) => trait_item.ident.name == assoc_name,\n+            ast::RequiredMethod(_) | ast::ProvidedMethod(_) => false,\n+        }\n+    })\n }\n \n fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item) {\n@@ -1484,29 +1493,26 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                                                  trait_items: &[P<ast::TraitItem>])\n                                                  -> Vec<ty::Predicate<'tcx>>\n     {\n-        trait_items\n-            .iter()\n-            .flat_map(|trait_item| {\n-                let assoc_type_def = match **trait_item {\n-                    ast::TypeTraitItem(ref assoc_type) => &assoc_type.ty_param,\n-                    ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n-                        return vec!().into_iter();\n-                    }\n-                };\n+        trait_items.iter().flat_map(|trait_item| {\n+            let bounds = match trait_item.node {\n+                ast::TypeTraitItem(ref bounds, _) => bounds,\n+                ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n+                    return vec!().into_iter();\n+                }\n+            };\n \n-                let assoc_ty = ty::mk_projection(ccx.tcx,\n-                                                 self_trait_ref.clone(),\n-                                                 assoc_type_def.ident.name);\n+            let assoc_ty = ty::mk_projection(ccx.tcx,\n+                                             self_trait_ref.clone(),\n+                                             trait_item.ident.name);\n \n-                let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n-                                            assoc_ty,\n-                                            &*assoc_type_def.bounds,\n-                                            SizedByDefault::Yes,\n-                                            assoc_type_def.span);\n+            let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n+                                        assoc_ty,\n+                                        bounds,\n+                                        SizedByDefault::Yes,\n+                                        trait_item.span);\n \n-                ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n-            })\n-            .collect()\n+            ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n+        }).collect()\n     }\n }\n "}, {"sha": "9f7b68f38fa6ee980f963bb22d669aa95576e55c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -147,29 +147,13 @@ pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind\n \n pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n                             did: ast::DefId) -> clean::Trait {\n-    use clean::TraitMethod;\n-\n     let def = ty::lookup_trait_def(tcx, did);\n     let trait_items = ty::trait_items(tcx, did).clean(cx);\n-    let provided = ty::provided_trait_methods(tcx, did);\n-    let items = trait_items.into_iter().map(|trait_item| {\n-        match trait_item.inner {\n-            clean::TyMethodItem(_) => {\n-                if provided.iter().any(|a| a.def_id == trait_item.def_id) {\n-                    TraitMethod::ProvidedMethod(trait_item)\n-                } else {\n-                    TraitMethod::RequiredMethod(trait_item)\n-                }\n-            },\n-            clean::AssociatedTypeItem(_) => TraitMethod::TypeTraitItem(trait_item),\n-            _ => unreachable!()\n-        }\n-    });\n     let predicates = ty::lookup_predicates(tcx, did);\n     clean::Trait {\n         unsafety: def.unsafety,\n         generics: (&def.generics, &predicates, subst::TypeSpace).clean(cx),\n-        items: items.collect(),\n+        items: trait_items,\n         bounds: vec![], // supertraits can be found in the list of predicates\n     }\n }"}, {"sha": "202b5f59fb7bba534e9030f57abdd3e2eae8b6fa", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 63, "deletions": 145, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -11,7 +11,6 @@\n //! This module contains the \"cleaned\" pieces of the AST, and the functions\n //! that clean them.\n \n-pub use self::ImplMethod::*;\n pub use self::Type::*;\n pub use self::PrimitiveType::*;\n pub use self::TypeKind::*;\n@@ -24,7 +23,6 @@ pub use self::Attribute::*;\n pub use self::TyParamBound::*;\n pub use self::SelfTy::*;\n pub use self::FunctionRetTy::*;\n-pub use self::TraitMethod::*;\n \n use syntax;\n use syntax::abi;\n@@ -70,7 +68,7 @@ pub trait Clean<T> {\n     fn clean(&self, cx: &DocContext) -> T;\n }\n \n-impl<T: Clean<U>, U> Clean<Vec<U>> for Vec<T> {\n+impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n     fn clean(&self, cx: &DocContext) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n@@ -339,7 +337,7 @@ pub enum ItemEnum {\n     ForeignStaticItem(Static),\n     MacroItem(Macro),\n     PrimitiveItem(PrimitiveType),\n-    AssociatedTypeItem(TyParam),\n+    AssociatedTypeItem(Vec<TyParamBound>, Option<Type>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -951,34 +949,26 @@ pub struct Method {\n     pub abi: abi::Abi\n }\n \n-impl Clean<Item> for ast::Method {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+impl Clean<Method> for ast::Method {\n+    fn clean(&self, cx: &DocContext) -> Method {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n             ast::SelfStatic => &**all_inputs,\n             _ => &all_inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.iter().map(|x| x.clean(cx)).collect(),\n+                values: inputs.clean(cx),\n             },\n             output: self.pe_fn_decl().output.clean(cx),\n             attrs: Vec::new()\n         };\n-        Item {\n-            name: Some(self.pe_ident().clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n-            visibility: self.pe_vis().clean(cx),\n-            stability: get_stability(cx, ast_util::local_def(self.id)),\n-            inner: MethodItem(Method {\n-                generics: self.pe_generics().clean(cx),\n-                self_: self.pe_explicit_self().node.clean(cx),\n-                unsafety: self.pe_unsafety().clone(),\n-                decl: decl,\n-                abi: self.pe_abi()\n-            }),\n+        Method {\n+            generics: self.pe_generics().clean(cx),\n+            self_: self.pe_explicit_self().node.clean(cx),\n+            unsafety: self.pe_unsafety().clone(),\n+            decl: decl,\n+            abi: self.pe_abi()\n         }\n     }\n }\n@@ -992,33 +982,25 @@ pub struct TyMethod {\n     pub abi: abi::Abi\n }\n \n-impl Clean<Item> for ast::TypeMethod {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+impl Clean<TyMethod> for ast::TypeMethod {\n+    fn clean(&self, cx: &DocContext) -> TyMethod {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => &*self.decl.inputs,\n             _ => &self.decl.inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.iter().map(|x| x.clean(cx)).collect(),\n+                values: inputs.clean(cx),\n             },\n             output: self.decl.output.clean(cx),\n             attrs: Vec::new()\n         };\n-        Item {\n-            name: Some(self.ident.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: ast_util::local_def(self.id),\n-            visibility: None,\n-            stability: get_stability(cx, ast_util::local_def(self.id)),\n-            inner: TyMethodItem(TyMethod {\n-                unsafety: self.unsafety.clone(),\n-                decl: decl,\n-                self_: self.explicit_self.node.clean(cx),\n-                generics: self.generics.clean(cx),\n-                abi: self.abi\n-            }),\n+        TyMethod {\n+            unsafety: self.unsafety.clone(),\n+            decl: decl,\n+            self_: self.explicit_self.node.clean(cx),\n+            generics: self.generics.clean(cx),\n+            abi: self.abi\n         }\n     }\n }\n@@ -1166,7 +1148,7 @@ impl Clean<FunctionRetTy> for ast::FunctionRetTy {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Trait {\n     pub unsafety: ast::Unsafety,\n-    pub items: Vec<TraitMethod>,\n+    pub items: Vec<Item>,\n     pub generics: Generics,\n     pub bounds: Vec<TyParamBound>,\n }\n@@ -1205,64 +1187,48 @@ impl Clean<PolyTrait> for ast::PolyTraitRef {\n     }\n }\n \n-/// An item belonging to a trait, whether a method or associated. Could be named\n-/// TraitItem except that's already taken by an exported enum variant.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum TraitMethod {\n-    RequiredMethod(Item),\n-    ProvidedMethod(Item),\n-    TypeTraitItem(Item), // an associated type\n-}\n-\n-impl TraitMethod {\n-    pub fn is_req(&self) -> bool {\n-        match self {\n-            &RequiredMethod(..) => true,\n-            _ => false,\n-        }\n-    }\n-    pub fn is_def(&self) -> bool {\n-        match self {\n-            &ProvidedMethod(..) => true,\n-            _ => false,\n-        }\n-    }\n-    pub fn is_type(&self) -> bool {\n-        match self {\n-            &TypeTraitItem(..) => true,\n-            _ => false,\n-        }\n-    }\n-    pub fn item<'a>(&'a self) -> &'a Item {\n-        match *self {\n-            RequiredMethod(ref item) => item,\n-            ProvidedMethod(ref item) => item,\n-            TypeTraitItem(ref item) => item,\n-        }\n-    }\n-}\n-\n-impl Clean<TraitMethod> for ast::TraitItem {\n-    fn clean(&self, cx: &DocContext) -> TraitMethod {\n-        match self {\n-            &ast::RequiredMethod(ref t) => RequiredMethod(t.clean(cx)),\n-            &ast::ProvidedMethod(ref t) => ProvidedMethod(t.clean(cx)),\n-            &ast::TypeTraitItem(ref t) => TypeTraitItem(t.clean(cx)),\n+impl Clean<Item> for ast::TraitItem {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        let inner = match self.node {\n+            ast::ProvidedMethod(ref m) => MethodItem(m.clean(cx)),\n+            ast::RequiredMethod(ref m) => TyMethodItem(m.clean(cx)),\n+            ast::TypeTraitItem(ref bounds, ref default) => {\n+                AssociatedTypeItem(bounds.clean(cx), default.clean(cx))\n+            }\n+        };\n+        Item {\n+            name: Some(self.ident.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.span.clean(cx),\n+            def_id: ast_util::local_def(self.id),\n+            visibility: None,\n+            stability: get_stability(cx, ast_util::local_def(self.id)),\n+            inner: inner\n         }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ImplMethod {\n-    MethodImplItem(Item),\n-    TypeImplItem(Item),\n-}\n-\n-impl Clean<ImplMethod> for ast::ImplItem {\n-    fn clean(&self, cx: &DocContext) -> ImplMethod {\n-        match self {\n-            &ast::MethodImplItem(ref t) => MethodImplItem(t.clean(cx)),\n-            &ast::TypeImplItem(ref t) => TypeImplItem(t.clean(cx)),\n+impl Clean<Item> for ast::ImplItem {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        let inner = match self.node {\n+            ast::MethodImplItem(ref m) => MethodItem(m.clean(cx)),\n+            ast::TypeImplItem(ref ty) => TypedefItem(Typedef {\n+                type_: ty.clean(cx),\n+                generics: Generics {\n+                    lifetimes: Vec::new(),\n+                    type_params: Vec::new(),\n+                    where_predicates: Vec::new()\n+                },\n+            }),\n+        };\n+        Item {\n+            name: Some(self.ident.clean(cx)),\n+            source: self.span.clean(cx),\n+            attrs: self.attrs.clean(cx),\n+            def_id: ast_util::local_def(self.id),\n+            visibility: self.vis.clean(cx),\n+            stability: get_stability(cx, ast_util::local_def(self.id)),\n+            inner: inner\n         }\n     }\n }\n@@ -2128,12 +2094,7 @@ impl Clean<Item> for doctree::Impl {\n                 generics: self.generics.clean(cx),\n                 trait_: self.trait_.clean(cx),\n                 for_: self.for_.clean(cx),\n-                items: self.items.clean(cx).into_iter().map(|ti| {\n-                        match ti {\n-                            MethodImplItem(i) => i,\n-                            TypeImplItem(i) => i,\n-                        }\n-                    }).collect(),\n+                items: self.items.clean(cx),\n                 derived: detect_derived(&self.attrs),\n                 polarity: Some(self.polarity.clean(cx)),\n             }),\n@@ -2500,65 +2461,22 @@ impl Clean<Stability> for attr::Stability {\n     }\n }\n \n-impl Clean<Item> for ast::AssociatedType {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n-            source: self.ty_param.span.clean(cx),\n-            name: Some(self.ty_param.ident.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            inner: AssociatedTypeItem(self.ty_param.clean(cx)),\n-            visibility: None,\n-            def_id: ast_util::local_def(self.ty_param.id),\n-            stability: None,\n-        }\n-    }\n-}\n-\n impl Clean<Item> for ty::AssociatedType {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n             source: DUMMY_SP.clean(cx),\n             name: Some(self.name.clean(cx)),\n             attrs: Vec::new(),\n-            inner: AssociatedTypeItem(TyParam {\n-                name: self.name.clean(cx),\n-                did: ast::DefId {\n-                    krate: 0,\n-                    node: ast::DUMMY_NODE_ID\n-                },\n-                // FIXME(#20727): bounds are missing and need to be filled in from the\n-                // predicates on the trait itself\n-                bounds: vec![],\n-                default: None,\n-            }),\n+            // FIXME(#20727): bounds are missing and need to be filled in from the\n+            // predicates on the trait itself\n+            inner: AssociatedTypeItem(vec![], None),\n             visibility: None,\n             def_id: self.def_id,\n             stability: None,\n         }\n     }\n }\n \n-impl Clean<Item> for ast::Typedef {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n-            source: self.span.clean(cx),\n-            name: Some(self.ident.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            inner: TypedefItem(Typedef {\n-                type_: self.typ.clean(cx),\n-                generics: Generics {\n-                    lifetimes: Vec::new(),\n-                    type_params: Vec::new(),\n-                    where_predicates: Vec::new()\n-                },\n-            }),\n-            visibility: None,\n-            def_id: ast_util::local_def(self.id),\n-            stability: None,\n-        }\n-    }\n-}\n-\n impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ty::GenericPredicates<'a>, ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Typedef {\n         let (ref ty_scheme, ref predicates, ps) = *self;"}, {"sha": "cdeeacfb78397f0d6bc9028ebbeb093e1bfc6795", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -40,37 +40,13 @@ pub trait DocFolder : Sized {\n                 EnumItem(i)\n             },\n             TraitItem(mut i) => {\n-                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitMethod)\n-                        -> Option<TraitMethod> {\n-                    match trm {\n-                        RequiredMethod(it) => {\n-                            match this.fold_item(it) {\n-                                Some(x) => return Some(RequiredMethod(x)),\n-                                None => return None,\n-                            }\n-                        },\n-                        ProvidedMethod(it) => {\n-                            match this.fold_item(it) {\n-                                Some(x) => return Some(ProvidedMethod(x)),\n-                                None => return None,\n-                            }\n-                        },\n-                        TypeTraitItem(it) => {\n-                            match this.fold_item(it) {\n-                                Some(x) => return Some(TypeTraitItem(x)),\n-                                None => return None,\n-                            }\n-                        }\n-                    }\n-                }\n                 let mut foo = Vec::new(); swap(&mut foo, &mut i.items);\n-                i.items.extend(foo.into_iter().filter_map(|x| vtrm(self, x)));\n+                i.items.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n                 TraitItem(i)\n             },\n             ImplItem(mut i) => {\n                 let mut foo = Vec::new(); swap(&mut foo, &mut i.items);\n-                i.items.extend(foo.into_iter()\n-                                  .filter_map(|x| self.fold_item(x)));\n+                i.items.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n                 ImplItem(i)\n             },\n             VariantItem(i) => {"}, {"sha": "dba7b16eceecbe922861ed7d3274e009a6d49cde", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -1685,33 +1685,39 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                   bounds,\n                   WhereClause(&t.generics)));\n \n-    let types = t.items.iter().filter(|m| m.is_type()).collect::<Vec<_>>();\n-    let required = t.items.iter().filter(|m| m.is_req()).collect::<Vec<_>>();\n-    let provided = t.items.iter().filter(|m| m.is_def()).collect::<Vec<_>>();\n+    let types = t.items.iter().filter(|m| {\n+        match m.inner { clean::AssociatedTypeItem(..) => true, _ => false }\n+    }).collect::<Vec<_>>();\n+    let required = t.items.iter().filter(|m| {\n+        match m.inner { clean::TyMethodItem(_) => true, _ => false }\n+    }).collect::<Vec<_>>();\n+    let provided = t.items.iter().filter(|m| {\n+        match m.inner { clean::MethodItem(_) => true, _ => false }\n+    }).collect::<Vec<_>>();\n \n     if t.items.len() == 0 {\n         try!(write!(w, \"{{ }}\"));\n     } else {\n         try!(write!(w, \"{{\\n\"));\n         for t in &types {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, t.item()));\n+            try!(render_method(w, t));\n             try!(write!(w, \";\\n\"));\n         }\n         if types.len() > 0 && required.len() > 0 {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &required {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m.item()));\n+            try!(render_method(w, m));\n             try!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &provided {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m.item()));\n+            try!(render_method(w, m));\n             try!(write!(w, \" {{ ... }}\\n\"));\n         }\n         try!(write!(w, \"}}\"));\n@@ -1721,15 +1727,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     // Trait documentation\n     try!(document(w, it));\n \n-    fn trait_item(w: &mut fmt::Formatter, m: &clean::TraitMethod)\n+    fn trait_item(w: &mut fmt::Formatter, m: &clean::Item)\n                   -> fmt::Result {\n         try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n-                    shortty(m.item()),\n-                    *m.item().name.as_ref().unwrap(),\n-                    ConciseStability(&m.item().stability)));\n-        try!(render_method(w, m.item()));\n+                    shortty(m),\n+                    *m.name.as_ref().unwrap(),\n+                    ConciseStability(&m.stability)));\n+        try!(render_method(w, m));\n         try!(write!(w, \"</code></h3>\"));\n-        try!(document(w, m.item()));\n+        try!(document(w, m));\n         Ok(())\n     }\n \n@@ -1798,12 +1804,14 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n }\n \n fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n-              typ: &clean::TyParam) -> fmt::Result {\n+              bounds: &Vec<clean::TyParamBound>,\n+              default: &Option<clean::Type>)\n+              -> fmt::Result {\n     try!(write!(w, \"type {}\", it.name.as_ref().unwrap()));\n-    if typ.bounds.len() > 0 {\n-        try!(write!(w, \": {}\", TyParamBounds(&*typ.bounds)))\n+    if bounds.len() > 0 {\n+        try!(write!(w, \": {}\", TyParamBounds(bounds)))\n     }\n-    if let Some(ref default) = typ.default {\n+    if let Some(ref default) = *default {\n         try!(write!(w, \" = {}\", default));\n     }\n     Ok(())\n@@ -1839,8 +1847,8 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n         clean::MethodItem(ref m) => {\n             method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl)\n         }\n-        clean::AssociatedTypeItem(ref typ) => {\n-            assoc_type(w, meth, typ)\n+        clean::AssociatedTypeItem(ref bounds, ref default) => {\n+            assoc_type(w, meth, bounds, default)\n         }\n         _ => panic!(\"render_method called on non-method\")\n     }\n@@ -2138,13 +2146,13 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n-            clean::AssociatedTypeItem(ref typaram) => {\n+            clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let name = item.name.as_ref().unwrap();\n                 try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'>{}<code>\",\n                             *name,\n                             shortty(item),\n                             ConciseStability(&item.stability)));\n-                try!(assoc_type(w, item, typaram));\n+                try!(assoc_type(w, item, bounds, default));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n@@ -2167,13 +2175,13 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n                               t: &clean::Trait,\n                               i: &clean::Impl) -> fmt::Result {\n         for trait_item in &t.items {\n-            let n = trait_item.item().name.clone();\n+            let n = trait_item.name.clone();\n             match i.items.iter().find(|m| { m.name == n }) {\n                 Some(..) => continue,\n                 None => {}\n             }\n \n-            try!(doctraititem(w, trait_item.item(), false));\n+            try!(doctraititem(w, trait_item, false));\n         }\n         Ok(())\n     }"}, {"sha": "0726a822b59b7a469d11092e6ba9f13e3cf23b0e", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -20,8 +20,8 @@ use syntax::attr::{Unstable, Stable};\n use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n-use clean::{ImplItem, Impl, Trait, TraitItem, TraitMethod, ProvidedMethod, RequiredMethod};\n-use clean::{TypeTraitItem, ExternCrateItem, ImportItem, PrimitiveItem, Stability};\n+use clean::{ImplItem, Impl, Trait, TraitItem};\n+use clean::{ExternCrateItem, ImportItem, PrimitiveItem, Stability};\n \n use html::render::cache;\n \n@@ -140,11 +140,11 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n     // considered to have no children.\n     match item.inner {\n         // Require explicit `pub` to be visible\n-        ImplItem(Impl { items: ref subitems, trait_: None, .. }) => {\n-            let subcounts = subitems.iter().filter(|i| visible(*i))\n-                                           .map(summarize_item)\n-                                           .map(|s| s.0)\n-                                           .fold(Counts::zero(), |acc, x| acc + x);\n+        ImplItem(Impl { ref items, trait_: None, .. }) => {\n+            let subcounts = items.iter().filter(|i| visible(*i))\n+                                        .map(summarize_item)\n+                                        .map(|s| s.0)\n+                                        .fold(Counts::zero(), |acc, x| acc + x);\n             (subcounts, None)\n         }\n         // `pub` automatically\n@@ -154,22 +154,10 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n                                            .fold(Counts::zero(), |acc, x| acc + x);\n             (item_counts + subcounts, None)\n         }\n-        TraitItem(Trait {\n-            items: ref trait_items,\n-            ..\n-        }) => {\n-            fn extract_item<'a>(trait_item: &'a TraitMethod) -> &'a Item {\n-                match *trait_item {\n-                    ProvidedMethod(ref item) |\n-                    RequiredMethod(ref item) |\n-                    TypeTraitItem(ref item) => item\n-                }\n-            }\n-            let subcounts = trait_items.iter()\n-                                       .map(extract_item)\n-                                       .map(summarize_item)\n-                                       .map(|s| s.0)\n-                                       .fold(Counts::zero(), |acc, x| acc + x);\n+        TraitItem(Trait { ref items, .. }) => {\n+            let subcounts = items.iter().map(summarize_item)\n+                                        .map(|s| s.0)\n+                                        .fold(Counts::zero(), |acc, x| acc + x);\n             (item_counts + subcounts, None)\n         }\n         ModuleItem(Module { ref items, .. }) => {"}, {"sha": "bc1767fa3a44d36bdfc6a3c3e4f29bae858e1445", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -22,7 +22,7 @@ pub use self::Expr_::*;\n pub use self::FloatTy::*;\n pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n-pub use self::ImplItem::*;\n+pub use self::ImplItem_::*;\n pub use self::InlinedItem::*;\n pub use self::IntTy::*;\n pub use self::Item_::*;\n@@ -33,7 +33,7 @@ pub use self::LocalSource::*;\n pub use self::Mac_::*;\n pub use self::MacStmtStyle::*;\n pub use self::MetaItem_::*;\n-pub use self::Method_::*;\n+pub use self::Method::*;\n pub use self::Mutability::*;\n pub use self::Pat_::*;\n pub use self::PathListItem_::*;\n@@ -44,7 +44,7 @@ pub use self::Stmt_::*;\n pub use self::StrStyle::*;\n pub use self::StructFieldKind::*;\n pub use self::TokenTree::*;\n-pub use self::TraitItem::*;\n+pub use self::TraitItem_::*;\n pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n pub use self::UintTy::*;\n@@ -1062,49 +1062,47 @@ pub struct TypeField {\n /// one without a default implementation\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TypeMethod {\n-    pub ident: Ident,\n-    pub attrs: Vec<Attribute>,\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n     pub explicit_self: ExplicitSelf,\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub vis: Visibility,\n }\n \n /// Represents a method declaration in a trait declaration, possibly including\n /// a default implementation A trait method is either required (meaning it\n /// doesn't have an implementation, just a signature) or provided (meaning it\n /// has a default implementation).\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TraitItem {\n-    RequiredMethod(TypeMethod),\n-    ProvidedMethod(Method),\n-    TypeTraitItem(AssociatedType),\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum ImplItem {\n-    MethodImplItem(Method),\n-    TypeImplItem(Typedef),\n+pub struct TraitItem {\n+    pub id: NodeId,\n+    pub ident: Ident,\n+    pub attrs: Vec<Attribute>,\n+    pub node: TraitItem_,\n+    pub span: Span,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct AssociatedType {\n-    pub attrs: Vec<Attribute>,\n-    pub ty_param: TyParam,\n+pub enum TraitItem_ {\n+    RequiredMethod(TypeMethod),\n+    ProvidedMethod(Method),\n+    TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct Typedef {\n+pub struct ImplItem {\n     pub id: NodeId,\n-    pub span: Span,\n     pub ident: Ident,\n     pub vis: Visibility,\n     pub attrs: Vec<Attribute>,\n-    pub typ: P<Ty>,\n+    pub node: ImplItem_,\n+    pub span: Span,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum ImplItem_ {\n+    MethodImplItem(Method),\n+    TypeImplItem(P<Ty>),\n }\n \n #[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n@@ -1419,24 +1417,14 @@ pub enum ExplicitSelf_ {\n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct Method {\n-    pub attrs: Vec<Attribute>,\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub node: Method_,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Method_ {\n+pub enum Method {\n     /// Represents a method declaration\n-    MethDecl(Ident,\n-             Generics,\n+    MethDecl(Generics,\n              Abi,\n              ExplicitSelf,\n              Unsafety,\n              P<FnDecl>,\n-             P<Block>,\n-             Visibility),\n+             P<Block>),\n     /// Represents a macro in method position\n     MethMac(Mac),\n }\n@@ -1726,8 +1714,8 @@ impl ForeignItem_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum InlinedItem {\n     IIItem(P<Item>),\n-    IITraitItem(DefId /* impl id */, TraitItem),\n-    IIImplItem(DefId /* impl id */, ImplItem),\n+    IITraitItem(DefId /* impl id */, P<TraitItem>),\n+    IIImplItem(DefId /* impl id */, P<ImplItem>),\n     IIForeign(P<ForeignItem>),\n }\n "}, {"sha": "053c31533408890bd67717894377d4ab97af079e", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -65,7 +65,7 @@ impl MaybeFnLike for ast::Item {\n \n impl MaybeFnLike for ast::TraitItem {\n     fn is_fn_like(&self) -> bool {\n-        match *self { ast::ProvidedMethod(_) => true, _ => false, }\n+        match self.node { ast::ProvidedMethod(_) => true, _ => false, }\n     }\n }\n \n@@ -156,25 +156,25 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn body(self) -> &'a Block {\n         self.handle(|i: ItemFnParts<'a>|  &*i.body,\n-                    |m: &'a ast::Method|  m.pe_body(),\n+                    |_, _, m: &'a ast::Method, _|  m.pe_body(),\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n     pub fn decl(self) -> &'a FnDecl {\n         self.handle(|i: ItemFnParts<'a>|  &*i.decl,\n-                    |m: &'a ast::Method|  m.pe_fn_decl(),\n+                    |_, _, m: &'a ast::Method, _|  m.pe_fn_decl(),\n                     |c: ClosureParts<'a>| c.decl)\n     }\n \n     pub fn span(self) -> Span {\n         self.handle(|i: ItemFnParts|     i.span,\n-                    |m: &'a ast::Method| m.span,\n+                    |_, _, _: &'a ast::Method, span| span,\n                     |c: ClosureParts|    c.span)\n     }\n \n     pub fn id(self) -> NodeId {\n         self.handle(|i: ItemFnParts|     i.id,\n-                    |m: &'a ast::Method| m.id,\n+                    |id, _, _: &'a ast::Method, _| id,\n                     |c: ClosureParts|    c.id)\n     }\n \n@@ -185,15 +185,15 @@ impl<'a> FnLikeNode<'a> {\n         let closure = |_: ClosureParts| {\n             visit::FkFnBlock\n         };\n-        let method = |m: &'a ast::Method| {\n-            visit::FkMethod(m.pe_ident(), m.pe_generics(), m)\n+        let method = |_, ident, m: &'a ast::Method, _| {\n+            visit::FkMethod(ident, m)\n         };\n         self.handle(item, method, closure)\n     }\n \n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n-        M: FnOnce(&'a ast::Method) -> A,\n+        M: FnOnce(NodeId, ast::Ident, &'a ast::Method, Span) -> A,\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n@@ -205,13 +205,13 @@ impl<'a> FnLikeNode<'a> {\n                     }),\n                 _ => panic!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            ast_map::NodeTraitItem(t) => match *t {\n-                ast::ProvidedMethod(ref m) => method(m),\n+            ast_map::NodeTraitItem(ti) => match ti.node {\n+                ast::ProvidedMethod(ref m) => method(ti.id, ti.ident, m, ti.span),\n                 _ => panic!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             ast_map::NodeImplItem(ii) => {\n-                match *ii {\n-                    ast::MethodImplItem(ref m) => method(m),\n+                match ii.node {\n+                    ast::MethodImplItem(ref m) => method(ii.id, ii.ident, m, ii.span),\n                     ast::TypeImplItem(_) => {\n                         panic!(\"impl method FnLikeNode that is not fn-like\")\n                     }"}, {"sha": "606c6b640df2e46c6fbd48a58b6c80b0eb4d1ec4", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 65, "deletions": 188, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -14,7 +14,7 @@ use self::MapEntry::*;\n \n use abi;\n use ast::*;\n-use ast_util::{self, PostExpansionMethod};\n+use ast_util;\n use codemap::{DUMMY_SP, Span, Spanned};\n use fold::Folder;\n use parse::token;\n@@ -374,35 +374,8 @@ impl<'ast> Map<'ast> {\n                 }\n             }\n             NodeForeignItem(i) => PathName(i.ident.name),\n-            NodeImplItem(ii) => {\n-                match *ii {\n-                    MethodImplItem(ref m) => {\n-                        match m.node {\n-                            MethDecl(ident, _, _, _, _, _, _, _) => {\n-                                PathName(ident.name)\n-                            }\n-                            MethMac(_) => {\n-                                panic!(\"no path elem for {:?}\", node)\n-                            }\n-                        }\n-                    }\n-                    TypeImplItem(ref t) => PathName(t.ident.name),\n-                }\n-            },\n-            NodeTraitItem(tm) => match *tm {\n-                RequiredMethod(ref m) => PathName(m.ident.name),\n-                ProvidedMethod(ref m) => {\n-                    match m.node {\n-                        MethDecl(ident, _, _, _, _, _, _, _) => {\n-                            PathName(ident.name)\n-                        }\n-                        MethMac(_) => panic!(\"no path elem for {:?}\", node),\n-                    }\n-                }\n-                TypeTraitItem(ref m) => {\n-                    PathName(m.ty_param.ident.name)\n-                }\n-            },\n+            NodeImplItem(ii) => PathName(ii.ident.name),\n+            NodeTraitItem(ti) => PathName(ti.ident.name),\n             NodeVariant(v) => PathName(v.node.name.name),\n             _ => panic!(\"no path elem for {:?}\", node)\n         }\n@@ -458,21 +431,12 @@ impl<'ast> Map<'ast> {\n \n     /// Given a node ID, get a list of of attributes associated with the AST\n     /// corresponding to the Node ID\n-    pub fn attrs(&self, id: NodeId) -> &[Attribute] {\n+    pub fn attrs(&self, id: NodeId) -> &'ast [Attribute] {\n         let attrs = match self.find(id) {\n             Some(NodeItem(i)) => Some(&i.attrs[..]),\n             Some(NodeForeignItem(fi)) => Some(&fi.attrs[..]),\n-            Some(NodeTraitItem(ref tm)) => match **tm {\n-                RequiredMethod(ref type_m) => Some(&type_m.attrs[..]),\n-                ProvidedMethod(ref m) => Some(&m.attrs[..]),\n-                TypeTraitItem(ref typ) => Some(&typ.attrs[..]),\n-            },\n-            Some(NodeImplItem(ref ii)) => {\n-                match **ii {\n-                    MethodImplItem(ref m) => Some(&m.attrs[..]),\n-                    TypeImplItem(ref t) => Some(&t.attrs[..]),\n-                }\n-            }\n+            Some(NodeTraitItem(ref ti)) => Some(&ti.attrs[..]),\n+            Some(NodeImplItem(ref ii)) => Some(&ii.attrs[..]),\n             Some(NodeVariant(ref v)) => Some(&v.node.attrs[..]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n@@ -505,19 +469,8 @@ impl<'ast> Map<'ast> {\n         let sp = match self.find(id) {\n             Some(NodeItem(item)) => item.span,\n             Some(NodeForeignItem(foreign_item)) => foreign_item.span,\n-            Some(NodeTraitItem(trait_method)) => {\n-                match *trait_method {\n-                    RequiredMethod(ref type_method) => type_method.span,\n-                    ProvidedMethod(ref method) => method.span,\n-                    TypeTraitItem(ref typedef) => typedef.ty_param.span,\n-                }\n-            }\n-            Some(NodeImplItem(ref impl_item)) => {\n-                match **impl_item {\n-                    MethodImplItem(ref method) => method.span,\n-                    TypeImplItem(ref typedef) => typedef.span,\n-                }\n-            }\n+            Some(NodeTraitItem(trait_method)) => trait_method.span,\n+            Some(NodeImplItem(ref impl_item)) => impl_item.span,\n             Some(NodeVariant(variant)) => variant.span,\n             Some(NodeExpr(expr)) => expr.span,\n             Some(NodeStmt(stmt)) => stmt.span,\n@@ -650,31 +603,8 @@ impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() }\n impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for Variant_ { fn name(&self) -> Name { self.name.name } }\n-impl Named for TraitItem {\n-    fn name(&self) -> Name {\n-        match *self {\n-            RequiredMethod(ref tm) => tm.ident.name,\n-            ProvidedMethod(ref m) => m.name(),\n-            TypeTraitItem(ref at) => at.ty_param.ident.name,\n-        }\n-    }\n-}\n-impl Named for ImplItem {\n-    fn name(&self) -> Name {\n-        match *self {\n-            MethodImplItem(ref m) => m.name(),\n-            TypeImplItem(ref td) => td.ident.name,\n-        }\n-    }\n-}\n-impl Named for Method {\n-    fn name(&self) -> Name {\n-        match self.node {\n-            MethDecl(i, _, _, _, _, _, _, _) => i.name,\n-            MethMac(_) => panic!(\"encountered unexpanded method macro.\"),\n-        }\n-    }\n-}\n+impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n \n pub trait FoldOps {\n     fn new_id(&self, id: NodeId) -> NodeId {\n@@ -739,12 +669,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent = i.id;\n         match i.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n-                for impl_item in impl_items {\n-                    let id = match **impl_item {\n-                        MethodImplItem(ref m) => m.id,\n-                        TypeImplItem(ref t) => t.id,\n-                    };\n-                    self.insert(id, NodeImplItem(impl_item));\n+                for ii in impl_items {\n+                    self.insert(ii.id, NodeImplItem(ii));\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n@@ -773,13 +699,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                     }\n                 }\n \n-                for tm in trait_items {\n-                    let id = match **tm {\n-                        RequiredMethod(ref m) => m.id,\n-                        ProvidedMethod(ref m) => m.id,\n-                        TypeTraitItem(ref typ) => typ.ty_param.id,\n-                    };\n-                    self.insert(id, NodeTraitItem(tm));\n+                for ti in trait_items {\n+                    self.insert(ti.id, NodeTraitItem(ti));\n                 }\n             }\n             _ => {}\n@@ -788,6 +709,20 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent = parent;\n     }\n \n+    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+        let parent = self.parent;\n+        self.parent = ti.id;\n+        visit::walk_trait_item(self, ti);\n+        self.parent = parent;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+        let parent = self.parent;\n+        self.parent = ii.id;\n+        visit::walk_impl_item(self, ii);\n+        self.parent = parent;\n+    }\n+\n     fn visit_pat(&mut self, pat: &'ast Pat) {\n         self.insert(pat.id, match pat.node {\n             // Note: this is at least *potentially* a pattern...\n@@ -807,29 +742,10 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         visit::walk_stmt(self, stmt);\n     }\n \n-    fn visit_ty_method(&mut self, m: &'ast TypeMethod) {\n-        let parent = self.parent;\n-        self.parent = m.id;\n-        self.visit_fn_decl(&*m.decl);\n-        visit::walk_ty_method(self, m);\n-        self.parent = parent;\n-    }\n-\n     fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Block, s: Span, id: NodeId) {\n-        match fk {\n-            visit::FkMethod(..) => {\n-                let parent = self.parent;\n-                self.parent = id;\n-                self.visit_fn_decl(fd);\n-                visit::walk_fn(self, fk, fd, b, s);\n-                self.parent = parent;\n-            }\n-            _ => {\n-                self.visit_fn_decl(fd);\n-                visit::walk_fn(self, fk, fd, b, s);\n-            }\n-        }\n+                b: &'ast Block, s: Span, _: NodeId) {\n+        self.visit_fn_decl(fd);\n+        visit::walk_fn(self, fk, fd, b, s);\n     }\n \n     fn visit_ty(&mut self, ty: &'ast Ty) {\n@@ -911,33 +827,14 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     let mut fld = IdAndSpanUpdater { fold_ops: fold_ops };\n     let ii = match ii {\n         IIItem(i) => IIItem(fld.fold_item(i).expect_one(\"expected one item\")),\n-        IITraitItem(d, ti) => match ti {\n-            ProvidedMethod(m) => {\n-                IITraitItem(fld.fold_ops.new_def_id(d),\n-                            ProvidedMethod(fld.fold_method(m)\n-                                              .expect_one(\"expected one method\")))\n-            }\n-            RequiredMethod(ty_m) => {\n-                IITraitItem(fld.fold_ops.new_def_id(d),\n-                            RequiredMethod(fld.fold_type_method(ty_m)))\n-            }\n-            TypeTraitItem(at) => {\n-                IITraitItem(\n-                    fld.fold_ops.new_def_id(d),\n-                    TypeTraitItem(fld.fold_associated_type(at)))\n-            }\n-        },\n-        IIImplItem(d, m) => match m {\n-            MethodImplItem(m) => {\n-                IIImplItem(fld.fold_ops.new_def_id(d),\n-                           MethodImplItem(fld.fold_method(m)\n-                                             .expect_one(\"expected one method\")))\n-            }\n-            TypeImplItem(t) => {\n-                IIImplItem(fld.fold_ops.new_def_id(d),\n-                           TypeImplItem(fld.fold_typedef(t)))\n-            }\n-        },\n+        IITraitItem(d, ti) => {\n+            IITraitItem(fld.fold_ops.new_def_id(d),\n+                        fld.fold_trait_item(ti).expect_one(\"expected one trait item\"))\n+        }\n+        IIImplItem(d, ii) => {\n+            IIImplItem(fld.fold_ops.new_def_id(d),\n+                       fld.fold_impl_item(ii).expect_one(\"expected one impl item\"))\n+        }\n         IIForeign(i) => IIForeign(fld.fold_foreign_item(i))\n     };\n \n@@ -959,25 +856,14 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     // add it to the table now. Likewise with foreign items.\n     match ii_parent.ii {\n         IIItem(_) => {}\n-        IITraitItem(_, ref trait_item) => {\n-            let trait_item_id = match *trait_item {\n-                ProvidedMethod(ref m) => m.id,\n-                RequiredMethod(ref m) => m.id,\n-                TypeTraitItem(ref ty) => ty.ty_param.id,\n-            };\n-\n-            collector.insert(trait_item_id, NodeTraitItem(trait_item));\n+        IITraitItem(_, ref ti) => {\n+            collector.insert(ti.id, NodeTraitItem(ti));\n         }\n-        IIImplItem(_, ref impl_item) => {\n-            let impl_item_id = match *impl_item {\n-                MethodImplItem(ref m) => m.id,\n-                TypeImplItem(ref ti) => ti.id,\n-            };\n-\n-            collector.insert(impl_item_id, NodeImplItem(impl_item));\n+        IIImplItem(_, ref ii) => {\n+            collector.insert(ii.id, NodeImplItem(ii));\n         }\n         IIForeign(ref i) => {\n-            collector.insert(i.id, NodeForeignItem(&**i));\n+            collector.insert(i.id, NodeForeignItem(i));\n         }\n     }\n     *map.map.borrow_mut() = collector.map;\n@@ -993,8 +879,8 @@ impl<'a> NodePrinter for pprust::State<'a> {\n         match *node {\n             NodeItem(a)        => self.print_item(&*a),\n             NodeForeignItem(a) => self.print_foreign_item(&*a),\n-            NodeTraitItem(a)   => self.print_trait_method(&*a),\n-            NodeImplItem(a)    => self.print_impl_item(&*a),\n+            NodeTraitItem(a)   => self.print_trait_item(a),\n+            NodeImplItem(a)    => self.print_impl_item(a),\n             NodeVariant(a)     => self.print_variant(&*a),\n             NodeExpr(a)        => self.print_expr(&*a),\n             NodeStmt(a)        => self.print_stmt(&*a),\n@@ -1041,48 +927,39 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             format!(\"foreign item {}{}\", path_str, id_str)\n         }\n-        Some(NodeImplItem(ref ii)) => {\n-            match **ii {\n+        Some(NodeImplItem(ii)) => {\n+            match ii.node {\n                 MethodImplItem(ref m) => {\n-                    match m.node {\n-                        MethDecl(ident, _, _, _, _, _, _, _) =>\n+                    match *m {\n+                        MethDecl(..) =>\n                             format!(\"method {} in {}{}\",\n-                                    token::get_ident(ident),\n+                                    token::get_ident(ii.ident),\n                                     map.path_to_string(id), id_str),\n                         MethMac(ref mac) =>\n                             format!(\"method macro {}{}\",\n                                     pprust::mac_to_string(mac), id_str)\n                     }\n                 }\n-                TypeImplItem(ref t) => {\n+                TypeImplItem(_) => {\n                     format!(\"assoc type {} in {}{}\",\n-                            token::get_ident(t.ident),\n+                            token::get_ident(ii.ident),\n                             map.path_to_string(id),\n                             id_str)\n                 }\n             }\n         }\n-        Some(NodeTraitItem(ref tm)) => {\n-            match **tm {\n-                RequiredMethod(ref m) => {\n-                    format!(\"required method {} in {}{}\",\n-                            token::get_ident(m.ident),\n-                            map.path_to_string(id),\n-                            id_str)\n-                }\n-                ProvidedMethod(ref m) => {\n-                    format!(\"provided method {} in {}{}\",\n-                            token::get_ident(m.pe_ident()),\n-                            map.path_to_string(id),\n-                            id_str)\n-                }\n-                TypeTraitItem(ref t) => {\n-                    format!(\"assoc type {} in {}{}\",\n-                            token::get_ident(t.ty_param.ident),\n-                            map.path_to_string(id),\n-                            id_str)\n-                }\n-            }\n+        Some(NodeTraitItem(ti)) => {\n+            let kind = match ti.node {\n+                RequiredMethod(_) => \"required method\",\n+                ProvidedMethod(_) => \"provided method\",\n+                TypeTraitItem(..) => \"assoc type\",\n+            };\n+\n+            format!(\"{} {} in {}{}\",\n+                    kind,\n+                    token::get_ident(ti.ident),\n+                    map.path_to_string(id),\n+                    id_str)\n         }\n         Some(NodeVariant(ref variant)) => {\n             format!(\"variant {} in {}{}\","}, {"sha": "673ea4ac431516a3929fe13ee5faf542e8649e0b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -457,10 +457,12 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         self.operation.visit_id(node_id);\n \n         match function_kind {\n-            visit::FkItemFn(_, generics, _, _) |\n-            visit::FkMethod(_, generics, _) => {\n+            visit::FkItemFn(_, generics, _, _) => {\n                 self.visit_generics_helper(generics)\n             }\n+            visit::FkMethod(_, m) => {\n+                self.visit_generics_helper(m.pe_generics())\n+            }\n             visit::FkFnBlock => {}\n         }\n \n@@ -496,13 +498,14 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         visit::walk_struct_def(self, struct_def);\n     }\n \n-    fn visit_trait_item(&mut self, tm: &ast::TraitItem) {\n-        match *tm {\n-            ast::RequiredMethod(ref m) => self.operation.visit_id(m.id),\n-            ast::ProvidedMethod(ref m) => self.operation.visit_id(m.id),\n-            ast::TypeTraitItem(ref typ) => self.operation.visit_id(typ.ty_param.id),\n-        }\n-        visit::walk_trait_item(self, tm);\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        self.operation.visit_id(ti.id);\n+        visit::walk_trait_item(self, ti);\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        self.operation.visit_id(ii.id);\n+        visit::walk_impl_item(self, ii);\n     }\n \n     fn visit_lifetime_ref(&mut self, lifetime: &Lifetime) {\n@@ -650,20 +653,18 @@ pub fn lit_is_str(lit: &Lit) -> bool {\n /// not a macro invocation. This check is guaranteed to succeed, assuming\n /// that the invocations are indeed gone.\n pub trait PostExpansionMethod {\n-    fn pe_ident(&self) -> ast::Ident;\n     fn pe_generics<'a>(&'a self) -> &'a ast::Generics;\n     fn pe_abi(&self) -> Abi;\n     fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf;\n     fn pe_unsafety(&self) -> ast::Unsafety;\n     fn pe_fn_decl<'a>(&'a self) -> &'a ast::FnDecl;\n     fn pe_body<'a>(&'a self) -> &'a ast::Block;\n-    fn pe_vis(&self) -> ast::Visibility;\n }\n \n macro_rules! mf_method{\n     ($meth_name:ident, $field_ty:ty, $field_pat:pat, $result:expr) => {\n         fn $meth_name<'a>(&'a self) -> $field_ty {\n-            match self.node {\n+            match *self {\n                 $field_pat => $result,\n                 MethMac(_) => {\n                     panic!(\"expected an AST without macro invocations\");\n@@ -675,20 +676,18 @@ macro_rules! mf_method{\n \n \n impl PostExpansionMethod for Method {\n-    mf_method! { pe_ident,ast::Ident,MethDecl(ident,_,_,_,_,_,_,_),ident }\n     mf_method! {\n         pe_generics,&'a ast::Generics,\n-        MethDecl(_,ref generics,_,_,_,_,_,_),generics\n+        MethDecl(ref generics,_,_,_,_,_),generics\n     }\n-    mf_method! { pe_abi,Abi,MethDecl(_,_,abi,_,_,_,_,_),abi }\n+    mf_method! { pe_abi,Abi,MethDecl(_,abi,_,_,_,_),abi }\n     mf_method! {\n         pe_explicit_self,&'a ast::ExplicitSelf,\n-        MethDecl(_,_,_,ref explicit_self,_,_,_,_),explicit_self\n+        MethDecl(_,_,ref explicit_self,_,_,_),explicit_self\n     }\n-    mf_method! { pe_unsafety,ast::Unsafety,MethDecl(_,_,_,_,unsafety,_,_,_),unsafety }\n-    mf_method! { pe_fn_decl,&'a ast::FnDecl,MethDecl(_,_,_,_,_,ref decl,_,_),&**decl }\n-    mf_method! { pe_body,&'a ast::Block,MethDecl(_,_,_,_,_,_,ref body,_),&**body }\n-    mf_method! { pe_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,_,vis),vis }\n+    mf_method! { pe_unsafety,ast::Unsafety,MethDecl(_,_,_,unsafety,_,_),unsafety }\n+    mf_method! { pe_fn_decl,&'a ast::FnDecl,MethDecl(_,_,_,_,ref decl,_),&**decl }\n+    mf_method! { pe_body,&'a ast::Block,MethDecl(_,_,_,_,_,ref body),&**body }\n }\n \n #[cfg(test)]"}, {"sha": "489a7721d7ba770a117add88db41d25b25353fe8", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -118,13 +118,13 @@ fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_\n     let item = match item {\n         ast::ItemImpl(u, o, a, b, c, impl_items) => {\n             let impl_items = impl_items.into_iter()\n-                                       .filter(|ii| impl_item_in_cfg(cx, ii))\n+                                       .filter(|ii| (cx.in_cfg)(&ii.attrs))\n                                        .collect();\n             ast::ItemImpl(u, o, a, b, c, impl_items)\n         }\n         ast::ItemTrait(u, a, b, methods) => {\n             let methods = methods.into_iter()\n-                                 .filter(|m| trait_method_in_cfg(cx, m))\n+                                 .filter(|ti| (cx.in_cfg)(&ti.attrs))\n                                  .collect();\n             ast::ItemTrait(u, a, b, methods)\n         }\n@@ -246,25 +246,6 @@ fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool\n     return (cx.in_cfg)(&item.attrs);\n }\n \n-fn trait_method_in_cfg<F>(cx: &mut Context<F>, meth: &ast::TraitItem) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    match *meth {\n-        ast::RequiredMethod(ref meth) => (cx.in_cfg)(&meth.attrs),\n-        ast::ProvidedMethod(ref meth) => (cx.in_cfg)(&meth.attrs),\n-        ast::TypeTraitItem(ref typ) => (cx.in_cfg)(&typ.attrs),\n-    }\n-}\n-\n-fn impl_item_in_cfg<F>(cx: &mut Context<F>, impl_item: &ast::ImplItem) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    match *impl_item {\n-        ast::MethodImplItem(ref meth) => (cx.in_cfg)(&meth.attrs),\n-        ast::TypeImplItem(ref typ) => (cx.in_cfg)(&typ.attrs),\n-    }\n-}\n-\n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {"}, {"sha": "cad5f97a4a5bb4557c00ab8a0196ef408966383d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -77,23 +77,16 @@ impl<F> ItemModifier for F\n #[derive(Debug,Clone)]\n pub enum Annotatable {\n     Item(P<ast::Item>),\n-    TraitItem(ast::TraitItem),\n-    ImplItem(ast::ImplItem),\n+    TraitItem(P<ast::TraitItem>),\n+    ImplItem(P<ast::ImplItem>),\n }\n \n impl Annotatable {\n     pub fn attrs(&self) -> &[ast::Attribute] {\n         match *self {\n             Annotatable::Item(ref i) => &i.attrs,\n-            Annotatable::TraitItem(ref i) => match *i {\n-                ast::RequiredMethod(ref tm) => &tm.attrs,\n-                ast::ProvidedMethod(ref m) => &m.attrs,\n-                ast::TypeTraitItem(ref at) => &at.attrs,\n-            },\n-            Annotatable::ImplItem(ref i) => match *i {\n-                ast::MethodImplItem(ref m) => &m.attrs,\n-                ast::TypeImplItem(ref t) => &t.attrs,\n-            }\n+            Annotatable::TraitItem(ref ti) => &ti.attrs,\n+            Annotatable::ImplItem(ref ii) => &ii.attrs,\n         }\n     }\n \n@@ -103,20 +96,12 @@ impl Annotatable {\n                 attrs: attrs,\n                 ..i\n             })),\n-            Annotatable::TraitItem(i) => Annotatable::TraitItem(match i {\n-                ast::RequiredMethod(tm) =>\n-                    ast::RequiredMethod(ast::TypeMethod { attrs: attrs, ..tm }),\n-                ast::ProvidedMethod(m) =>\n-                    ast::ProvidedMethod(ast::Method { attrs: attrs, ..m }),\n-                ast::TypeTraitItem(at) =>\n-                    ast::TypeTraitItem(ast::AssociatedType { attrs: attrs, ..at }),\n-            }),\n-            Annotatable::ImplItem(i) => Annotatable::ImplItem(match i {\n-                ast::MethodImplItem(m) =>\n-                    ast::MethodImplItem(ast::Method { attrs: attrs, ..m }),\n-                ast::TypeImplItem(t) =>\n-                    ast::TypeImplItem(ast::Typedef { attrs: attrs, ..t }),\n-            })\n+            Annotatable::TraitItem(i) => Annotatable::TraitItem(i.map(|ti| {\n+                ast::TraitItem { attrs: attrs, ..ti }\n+            })),\n+            Annotatable::ImplItem(i) => Annotatable::ImplItem(i.map(|ii| {\n+                ast::ImplItem { attrs: attrs, ..ii }\n+            })),\n         }\n     }\n \n@@ -127,14 +112,14 @@ impl Annotatable {\n         }\n     }\n \n-    pub fn expect_trait_item(self) -> ast::TraitItem {\n+    pub fn expect_trait_item(self) -> P<ast::TraitItem> {\n         match self {\n             Annotatable::TraitItem(i) => i,\n             _ => panic!(\"expected Item\")\n         }\n     }\n \n-    pub fn expect_impl_item(self) -> ast::ImplItem {\n+    pub fn expect_impl_item(self) -> P<ast::ImplItem> {\n         match self {\n             Annotatable::ImplItem(i) => i,\n             _ => panic!(\"expected Item\")\n@@ -244,7 +229,7 @@ pub trait MacResult {\n     }\n \n     /// Create zero or more methods.\n-    fn make_methods(self: Box<Self>) -> Option<SmallVector<ast::Method>> {\n+    fn make_methods(self: Box<Self>) -> Option<SmallVector<P<ast::ImplItem>>> {\n         None\n     }\n \n@@ -290,7 +275,7 @@ make_MacEager! {\n     expr: P<ast::Expr>,\n     pat: P<ast::Pat>,\n     items: SmallVector<P<ast::Item>>,\n-    methods: SmallVector<ast::Method>,\n+    methods: SmallVector<P<ast::ImplItem>>,\n     stmt: P<ast::Stmt>,\n }\n \n@@ -303,7 +288,7 @@ impl MacResult for MacEager {\n         self.items\n     }\n \n-    fn make_methods(self: Box<Self>) -> Option<SmallVector<ast::Method>> {\n+    fn make_methods(self: Box<Self>) -> Option<SmallVector<P<ast::ImplItem>>> {\n         self.methods\n     }\n \n@@ -392,7 +377,7 @@ impl MacResult for DummyResult {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_methods(self: Box<DummyResult>) -> Option<SmallVector<ast::Method>> {\n+    fn make_methods(self: Box<DummyResult>) -> Option<SmallVector<P<ast::ImplItem>>> {\n         if self.expr_only {\n             None\n         } else {\n@@ -500,9 +485,6 @@ fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n         syntax_expanders.insert(intern(\"quote_ty\"),\n                            builtin_normal_expander(\n                                 ext::quote::expand_quote_ty));\n-        syntax_expanders.insert(intern(\"quote_method\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_method));\n         syntax_expanders.insert(intern(\"quote_item\"),\n                            builtin_normal_expander(\n                                 ext::quote::expand_quote_item));"}, {"sha": "a4962afff3c010dbc630851acf7cfab22d746d32", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -386,23 +386,23 @@ impl<'a> TraitDef<'a> {\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n                            generics: &Generics,\n-                           methods: Vec<ast::Method>) -> P<ast::Item> {\n+                           methods: Vec<P<ast::ImplItem>>) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n-        // Transform associated types from `deriving::ty::Ty` into `ast::Typedef`\n+        // Transform associated types from `deriving::ty::Ty` into `ast::ImplItem`\n         let associated_types = self.associated_types.iter().map(|&(ident, ref type_def)| {\n-            ast::Typedef {\n+            P(ast::ImplItem {\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.span,\n                 ident: ident,\n                 vis: ast::Inherited,\n                 attrs: Vec::new(),\n-                typ: type_def.to_ty(cx,\n+                node: ast::TypeImplItem(type_def.to_ty(cx,\n                     self.span,\n                     type_ident,\n                     generics\n-                ),\n-            }\n+                )),\n+            })\n         });\n \n         let Generics { mut lifetimes, ty_params, mut where_clause } =\n@@ -510,14 +510,7 @@ impl<'a> TraitDef<'a> {\n                           trait_generics,\n                           opt_trait_ref,\n                           self_type,\n-                          methods.into_iter()\n-                                 .map(|method| {\n-                                     ast::MethodImplItem(method)\n-                                 }).chain(\n-                                     associated_types.map(|type_| {\n-                                         ast::TypeImplItem(type_)\n-                                     })\n-                                 ).map(P).collect()))\n+                          methods.into_iter().chain(associated_types).collect()))\n     }\n \n     fn expand_struct_def(&self,\n@@ -702,7 +695,7 @@ impl<'a> MethodDef<'a> {\n                      abi: Abi,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n-                     body: P<Expr>) -> ast::Method {\n+                     body: P<Expr>) -> P<ast::ImplItem> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -725,19 +718,20 @@ impl<'a> MethodDef<'a> {\n         let body_block = cx.block_expr(body);\n \n         // Create the method.\n-        ast::Method {\n-            attrs: self.attributes.clone(),\n+        P(ast::ImplItem {\n             id: ast::DUMMY_NODE_ID,\n+            attrs: self.attributes.clone(),\n             span: trait_.span,\n-            node: ast::MethDecl(method_ident,\n-                                fn_generics,\n-                                abi,\n-                                explicit_self,\n-                                ast::Unsafety::Normal,\n-                                fn_decl,\n-                                body_block,\n-                                ast::Inherited)\n-        }\n+            vis: ast::Inherited,\n+            ident: method_ident,\n+            node: ast::MethodImplItem(\n+                ast::MethDecl(fn_generics,\n+                              abi,\n+                              explicit_self,\n+                              ast::Unsafety::Normal,\n+                              fn_decl,\n+                              body_block))\n+        })\n     }\n \n     /// ```"}, {"sha": "5fb0126cdd09cfb922d1e901f3e34fde70252371", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 70, "deletions": 75, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -25,6 +25,7 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n+use owned_slice::OwnedSlice;\n use parse;\n use parse::token::{fresh_mark, fresh_name, intern};\n use parse::token;\n@@ -1174,51 +1175,49 @@ fn expand_annotatable(a: Annotatable,\n                 noop_fold_item(it, fld).into_iter().map(|i| Annotatable::Item(i)).collect()\n             }\n         },\n-        Annotatable::TraitItem(it) => match it {\n-            ast::TraitItem::ProvidedMethod(m) => {\n-                expand_method(m, fld).into_iter().map(|m|\n-                    Annotatable::TraitItem(ast::TraitItem::ProvidedMethod(m))).collect()\n-            }\n-            ast::TraitItem::RequiredMethod(m) => {\n-                SmallVector::one(Annotatable::TraitItem(\n-                    ast::TraitItem::RequiredMethod(fld.fold_type_method(m))))\n+        Annotatable::TraitItem(it) => match it.node {\n+            ast::ProvidedMethod(ast::MethMac(_)) => {\n+                // HACK(eddyb): Expand method macros in a trait as if they were in an impl.\n+                let ii = it.and_then(|ti| match ti.node {\n+                    ast::ProvidedMethod(m) => P(ast::ImplItem {\n+                        id: ti.id,\n+                        ident: ti.ident,\n+                        attrs: ti.attrs,\n+                        vis: ast::Inherited,\n+                        node: ast::MethodImplItem(m),\n+                        span: ti.span\n+                    }),\n+                    _ => unreachable!()\n+                });\n+                expand_method(ii, fld).into_iter().map(|ii| {\n+                    Annotatable::TraitItem(ii.and_then(|ii| P(ast::TraitItem {\n+                        id: ii.id,\n+                        ident: ii.ident,\n+                        attrs: ii.attrs,\n+                        node: match ii.node {\n+                            ast::MethodImplItem(m) => ast::ProvidedMethod(m),\n+                            ast::TypeImplItem(ty) => {\n+                                ast::TypeTraitItem(OwnedSlice::empty(), Some(ty))\n+                            }\n+                        },\n+                        span: ii.span\n+                    })))\n+                }).collect()\n             }\n-            ast::TraitItem::TypeTraitItem(t) => {\n-                SmallVector::one(Annotatable::TraitItem(\n-                    ast::TraitItem::TypeTraitItem(fld.fold_associated_type(t))))\n+            _ => {\n+                fold::noop_fold_trait_item(it, fld).into_iter()\n+                    .map(|ti| Annotatable::TraitItem(ti)).collect()\n             }\n         },\n-        Annotatable::ImplItem(it) => match it {\n-            ast::ImplItem::MethodImplItem(m) => {\n-                expand_method(m, fld).into_iter().map(|m|\n-                    Annotatable::ImplItem(ast::ImplItem::MethodImplItem(m))).collect()\n-            }\n-            ast::ImplItem::TypeImplItem(t) => {\n-                SmallVector::one(Annotatable::ImplItem(\n-                    ast::ImplItem::TypeImplItem(fld.fold_typedef(t))))\n-            }\n+        Annotatable::ImplItem(ii) => {\n+            expand_method(ii, fld).into_iter().map(Annotatable::ImplItem).collect()\n         }\n     };\n \n     new_items.push_all(decorator_items.into_iter().map(|i| Annotatable::Item(i)).collect());\n     new_items\n }\n \n-fn expand_trait_item(i: ast::TraitItem,\n-                     fld: &mut MacroExpander)\n-                     -> SmallVector<ast::TraitItem> {\n-    expand_annotatable(Annotatable::TraitItem(i), fld)\n-        .into_iter().map(|i| i.expect_trait_item()).collect()\n-\n-}\n-\n-fn expand_impl_item(i: ast::ImplItem,\n-                    fld: &mut MacroExpander)\n-                    -> SmallVector<ast::ImplItem> {\n-    expand_annotatable(Annotatable::ImplItem(i), fld)\n-        .into_iter().map(|i| i.expect_impl_item()).collect()\n-}\n-\n // partition the attributes into ItemModifiers and others\n fn modifiers(attrs: &Vec<ast::Attribute>,\n              fld: &MacroExpander)\n@@ -1292,37 +1291,18 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     expand_item_multi_modifier(it, fld)\n }\n \n-// expand a method\n-fn expand_method(m: ast::Method, fld: &mut MacroExpander) -> SmallVector<ast::Method> {\n-    match m.node {\n-        ast::MethDecl(ident,\n-                      generics,\n-                      abi,\n-                      explicit_self,\n-                      fn_style,\n-                      decl,\n-                      body,\n-                      vis) => {\n-            let id = fld.new_id(m.id);\n-            let (rewritten_fn_decl, rewritten_body)\n-                = expand_and_rename_fn_decl_and_block(decl, body, fld);\n-            SmallVector::one(ast::Method {\n-                    attrs: fold::fold_attrs(m.attrs, fld),\n-                    id: id,\n-                    span: fld.new_span(m.span),\n-                    node: ast::MethDecl(fld.fold_ident(ident),\n-                                        noop_fold_generics(generics, fld),\n-                                        abi,\n-                                        fld.fold_explicit_self(explicit_self),\n-                                        fn_style,\n-                                        rewritten_fn_decl,\n-                                        rewritten_body,\n-                                        vis)\n-                })\n-        },\n-        ast::MethMac(mac) => {\n+// expand an impl item if it's a method macro\n+fn expand_method(ii: P<ast::ImplItem>, fld: &mut MacroExpander)\n+                 -> SmallVector<P<ast::ImplItem>> {\n+    let ii = fold::noop_fold_impl_item(ii, fld).expect_one(\"expected one impl item\");\n+    match ii.node {\n+        ast::MethodImplItem(ast::MethMac(_)) => {\n+            let (span, mac) = ii.and_then(|ii| match ii.node {\n+                ast::MethodImplItem(ast::MethMac(mac)) => (ii.span, mac),\n+                _ => unreachable!()\n+            });\n             let maybe_new_methods =\n-                expand_mac_invoc(mac, m.span,\n+                expand_mac_invoc(mac, span,\n                                  |r| r.make_methods(),\n                                  |meths, mark| meths.move_map(|m| mark_method(m, mark)),\n                                  fld);\n@@ -1331,14 +1311,15 @@ fn expand_method(m: ast::Method, fld: &mut MacroExpander) -> SmallVector<ast::Me\n                 Some(methods) => {\n                     // expand again if necessary\n                     let new_methods = methods.into_iter()\n-                                             .flat_map(|m| fld.fold_method(m).into_iter())\n+                                             .flat_map(|m| expand_method(m, fld).into_iter())\n                                              .collect();\n                     fld.cx.bt_pop();\n                     new_methods\n                 }\n                 None => SmallVector::zero()\n             }\n         }\n+        _ => SmallVector::one(ii)\n     }\n }\n \n@@ -1410,16 +1391,30 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_arm(arm, self)\n     }\n \n-    fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n-        expand_trait_item(i, self)\n+    fn fold_method(&mut self, m: ast::Method) -> ast::Method {\n+        match m {\n+            ast::MethDecl(generics, abi, explicit_self, fn_style, decl, body) => {\n+                let (rewritten_fn_decl, rewritten_body)\n+                    = expand_and_rename_fn_decl_and_block(decl, body, self);\n+                ast::MethDecl(self.fold_generics(generics),\n+                              abi,\n+                              self.fold_explicit_self(explicit_self),\n+                              fn_style,\n+                              rewritten_fn_decl,\n+                              rewritten_body)\n+            }\n+            ast::MethMac(mac) => ast::MethMac(mac)\n+        }\n     }\n \n-    fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n-        expand_impl_item(i, self)\n+    fn fold_trait_item(&mut self, i: P<ast::TraitItem>) -> SmallVector<P<ast::TraitItem>> {\n+        expand_annotatable(Annotatable::TraitItem(i), self)\n+            .into_iter().map(|i| i.expect_trait_item()).collect()\n     }\n \n-    fn fold_method(&mut self, method: ast::Method) -> SmallVector<ast::Method> {\n-        expand_method(method, self)\n+    fn fold_impl_item(&mut self, i: P<ast::ImplItem>) -> SmallVector<P<ast::ImplItem>> {\n+        expand_annotatable(Annotatable::ImplItem(i), self)\n+            .into_iter().map(|i| i.expect_impl_item()).collect()\n     }\n \n     fn fold_ty(&mut self, t: P<ast::Ty>) -> P<ast::Ty> {\n@@ -1565,9 +1560,9 @@ fn mark_item(expr: P<ast::Item>, m: Mrk) -> P<ast::Item> {\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_method(expr: ast::Method, m: Mrk) -> ast::Method {\n-    Marker{mark:m}.fold_method(expr)\n-        .expect_one(\"marking an item didn't return exactly one method\")\n+fn mark_method(ii: P<ast::ImplItem>, m: Mrk) -> P<ast::ImplItem> {\n+    Marker{mark:m}.fold_impl_item(ii)\n+        .expect_one(\"marking an impl item didn't return exactly one method\")\n }\n \n /// Check that there are no macro invocations left in the AST:"}, {"sha": "48c045ee4f98f7b86568a8056e0ee374a99d4c41", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -176,7 +176,6 @@ pub mod rt {\n     impl_to_source! { ast::Arg, arg_to_string }\n     impl_to_source! { Generics, generics_to_string }\n     impl_to_source! { P<ast::Item>, item_to_string }\n-    impl_to_source! { P<ast::Method>, method_to_string }\n     impl_to_source! { P<ast::Stmt>, stmt_to_string }\n     impl_to_source! { P<ast::Expr>, expr_to_string }\n     impl_to_source! { P<ast::Pat>, pat_to_string }\n@@ -311,7 +310,6 @@ pub mod rt {\n     impl_to_tokens! { P<ast::Item> }\n     impl_to_tokens! { P<ast::Pat> }\n     impl_to_tokens! { ast::Arm }\n-    impl_to_tokens! { P<ast::Method> }\n     impl_to_tokens_lifetime! { &'a [P<ast::Item>] }\n     impl_to_tokens! { ast::Ty }\n     impl_to_tokens_lifetime! { &'a [ast::Ty] }\n@@ -446,15 +444,6 @@ pub fn expand_quote_ty(cx: &mut ExtCtxt,\n     base::MacEager::expr(expanded)\n }\n \n-pub fn expand_quote_method(cx: &mut ExtCtxt,\n-                           sp: Span,\n-                           tts: &[ast::TokenTree])\n-                           -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_method_with_outer_attributes\",\n-                                     vec!(), tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree])"}, {"sha": "dad50af9a9192e15e0d98d87e451f84a9fb8413a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -82,7 +82,8 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n-    fn make_methods(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<ast::Method>> {\n+    fn make_methods(self: Box<ParserAnyMacro<'a>>)\n+                    -> Option<SmallVector<P<ast::ImplItem>>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();"}, {"sha": "d99f1600cb3887fec3a1f7ef9abe487fdb6b3444", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 47, "deletions": 118, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -110,11 +110,7 @@ pub trait Folder : Sized {\n         noop_fold_fn_decl(d, self)\n     }\n \n-    fn fold_type_method(&mut self, m: TypeMethod) -> TypeMethod {\n-        noop_fold_type_method(m, self)\n-    }\n-\n-    fn fold_method(&mut self, m: Method) -> SmallVector<Method> {\n+    fn fold_method(&mut self, m: Method) -> Method {\n         noop_fold_method(m, self)\n     }\n \n@@ -315,15 +311,6 @@ pub trait Folder : Sized {\n         noop_fold_where_predicate(where_predicate, self)\n     }\n \n-    fn fold_typedef(&mut self, typedef: Typedef) -> Typedef {\n-        noop_fold_typedef(typedef, self)\n-    }\n-\n-    fn fold_associated_type(&mut self, associated_type: AssociatedType)\n-                            -> AssociatedType {\n-        noop_fold_associated_type(associated_type, self)\n-    }\n-\n     fn new_id(&mut self, i: NodeId) -> NodeId {\n         i\n     }\n@@ -829,41 +816,6 @@ pub fn noop_fold_where_predicate<T: Folder>(\n     }\n }\n \n-pub fn noop_fold_typedef<T>(t: Typedef, folder: &mut T)\n-                            -> Typedef\n-                            where T: Folder {\n-    let new_id = folder.new_id(t.id);\n-    let new_span = folder.new_span(t.span);\n-    let new_attrs = t.attrs.iter().flat_map(|attr| {\n-        folder.fold_attribute((*attr).clone()).into_iter()\n-    }).collect();\n-    let new_ident = folder.fold_ident(t.ident);\n-    let new_type = folder.fold_ty(t.typ);\n-    ast::Typedef {\n-        ident: new_ident,\n-        typ: new_type,\n-        id: new_id,\n-        span: new_span,\n-        vis: t.vis,\n-        attrs: new_attrs,\n-    }\n-}\n-\n-pub fn noop_fold_associated_type<T>(at: AssociatedType, folder: &mut T)\n-                                    -> AssociatedType\n-                                    where T: Folder\n-{\n-    let new_attrs = at.attrs\n-                      .iter()\n-                      .flat_map(|attr| folder.fold_attribute((*attr).clone()).into_iter())\n-                      .collect();\n-    let new_param = folder.fold_ty_param(at.ty_param);\n-    ast::AssociatedType {\n-        attrs: new_attrs,\n-        ty_param: new_param,\n-    }\n-}\n-\n pub fn noop_fold_struct_def<T: Folder>(struct_def: P<StructDef>, fld: &mut T) -> P<StructDef> {\n     struct_def.map(|StructDef { fields, ctor_id }| StructDef {\n         fields: fields.move_map(|f| fld.fold_struct_field(f)),\n@@ -1020,55 +972,43 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n \n pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n                                        -> SmallVector<P<TraitItem>> {\n-    i.map(|i| SmallVector::one(P(match i {\n-        RequiredMethod(m) => RequiredMethod(folder.fold_type_method(m)),\n-        ProvidedMethod(method) => {\n-            return folder.fold_method(method).into_iter()\n-                         .map(|m| P(ProvidedMethod(m))).collect();\n-        }\n-        TypeTraitItem(at) => {\n-            TypeTraitItem(folder.fold_associated_type(at))\n-        }\n-    })))\n+    SmallVector::one(i.map(|TraitItem {id, ident, attrs, node, span}| TraitItem {\n+        id: folder.new_id(id),\n+        ident: folder.fold_ident(ident),\n+        attrs: fold_attrs(attrs, folder),\n+        node: match node {\n+            RequiredMethod(TypeMethod { unsafety, abi, decl, generics, explicit_self }) => {\n+                RequiredMethod(TypeMethod {\n+                    unsafety: unsafety,\n+                    abi: abi,\n+                    decl: folder.fold_fn_decl(decl),\n+                    generics: folder.fold_generics(generics),\n+                    explicit_self: folder.fold_explicit_self(explicit_self)\n+                })\n+            }\n+            ProvidedMethod(m) => ProvidedMethod(folder.fold_method(m)),\n+            TypeTraitItem(bounds, default) => {\n+                TypeTraitItem(folder.fold_bounds(bounds),\n+                              default.map(|x| folder.fold_ty(x)))\n+            }\n+        },\n+        span: folder.new_span(span)\n+    }))\n }\n \n pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n                                       -> SmallVector<P<ImplItem>> {\n-    i.and_then(|i| match i {\n-        MethodImplItem(x) => {\n-            folder.fold_method(x).into_iter().map(|m| P(MethodImplItem(m))).collect()\n-        }\n-        TypeImplItem(t) => {\n-            SmallVector::one(TypeImplItem(folder.fold_typedef(t)))\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMethod {\n-    let TypeMethod {\n-        id,\n-        ident,\n-        attrs,\n-        unsafety,\n-        abi,\n-        decl,\n-        generics,\n-        explicit_self,\n-        vis,\n-        span\n-    } = m;\n-    TypeMethod {\n-        id: fld.new_id(id),\n-        ident: fld.fold_ident(ident),\n-        attrs: fold_attrs(attrs, fld),\n-        unsafety: unsafety,\n-        abi: abi,\n-        decl: fld.fold_fn_decl(decl),\n-        generics: fld.fold_generics(generics),\n-        explicit_self: fld.fold_explicit_self(explicit_self),\n+    SmallVector::one(i.map(|ImplItem {id, ident, attrs, node, vis, span}| ImplItem {\n+        id: folder.new_id(id),\n+        ident: folder.fold_ident(ident),\n+        attrs: fold_attrs(attrs, folder),\n         vis: vis,\n-        span: fld.new_span(span)\n-    }\n+        node: match node  {\n+            MethodImplItem(m) => MethodImplItem(folder.fold_method(m)),\n+            TypeImplItem(ty) => TypeImplItem(folder.fold_ty(ty))\n+        },\n+        span: folder.new_span(span)\n+    }))\n }\n \n pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n@@ -1168,34 +1108,23 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n }\n \n // Default fold over a method.\n-// Invariant: produces exactly one method.\n-pub fn noop_fold_method<T: Folder>(Method {id, attrs, node, span}: Method, folder: &mut T)\n-                                   -> SmallVector<Method> {\n-    SmallVector::one(Method {\n-        id: folder.new_id(id),\n-        attrs: fold_attrs(attrs, folder),\n-        node: match node {\n-            MethDecl(ident,\n-                     generics,\n+pub fn noop_fold_method<T: Folder>(method: Method, folder: &mut T) -> Method {\n+    match method {\n+        MethDecl(generics,\n+                 abi,\n+                 explicit_self,\n+                 unsafety,\n+                 decl,\n+                 body) => {\n+            MethDecl(folder.fold_generics(generics),\n                      abi,\n-                     explicit_self,\n+                     folder.fold_explicit_self(explicit_self),\n                      unsafety,\n-                     decl,\n-                     body,\n-                     vis) => {\n-                MethDecl(folder.fold_ident(ident),\n-                         folder.fold_generics(generics),\n-                         abi,\n-                         folder.fold_explicit_self(explicit_self),\n-                         unsafety,\n-                         folder.fold_fn_decl(decl),\n-                         folder.fold_block(body),\n-                         vis)\n-            },\n-            MethMac(mac) => MethMac(folder.fold_mac(mac)),\n+                     folder.fold_fn_decl(decl),\n+                     folder.fold_block(body))\n         },\n-        span: folder.new_span(span)\n-    })\n+        MethMac(mac) => MethMac(folder.fold_mac(mac))\n+    }\n }\n \n pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {"}, {"sha": "a38508d2cf50b8337754ff802cff98642ccf9fea", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 57, "deletions": 64, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -11,7 +11,7 @@\n pub use self::PathParsingMode::*;\n \n use abi;\n-use ast::{AssociatedType, BareFnTy};\n+use ast::{BareFnTy};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::{ProvidedMethod, Public, Unsafety};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n@@ -38,7 +38,7 @@ use ast::{LitBool, LitChar, LitByte, LitBinary};\n use ast::{LitStr, LitInt, Local, LocalLet};\n use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchSource};\n-use ast::{Method, MutTy, BiMul, Mutability};\n+use ast::{MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, NodeId, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n@@ -55,7 +55,7 @@ use ast::{TyFixedLengthVec, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n-use ast::{TypeImplItem, TypeTraitItem, Typedef,};\n+use ast::{TypeImplItem, TypeTraitItem};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n@@ -1275,35 +1275,37 @@ impl<'a> Parser<'a> {\n \n     /// Parses `type Foo;` in a trait declaration only. The `type` keyword has\n     /// already been parsed.\n-    fn parse_associated_type(&mut self, attrs: Vec<Attribute>)\n-                             -> AssociatedType\n-    {\n-        let ty_param = self.parse_ty_param();\n+    fn parse_assoc_ty_in_trait(&mut self, attrs: Vec<Attribute>)\n+                               -> P<TraitItem> {\n+        let TyParam {id, ident, bounds, default, span} = self.parse_ty_param();\n         self.expect(&token::Semi);\n-        AssociatedType {\n+        P(TraitItem {\n+            id: id,\n+            ident: ident,\n             attrs: attrs,\n-            ty_param: ty_param,\n-        }\n+            node: TypeTraitItem(bounds, default),\n+            span: span,\n+        })\n     }\n \n     /// Parses `type Foo = TYPE;` in an implementation declaration only. The\n     /// `type` keyword has already been parsed.\n-    fn parse_typedef(&mut self, attrs: Vec<Attribute>, vis: Visibility)\n-                     -> Typedef {\n+    fn parse_assoc_ty_in_impl(&mut self, attrs: Vec<Attribute>, vis: Visibility)\n+                              -> P<ImplItem> {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         self.expect(&token::Eq);\n         let typ = self.parse_ty_sum();\n         let hi = self.span.hi;\n         self.expect(&token::Semi);\n-        Typedef {\n+        P(ImplItem {\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n             ident: ident,\n             vis: vis,\n             attrs: attrs,\n-            typ: typ,\n-        }\n+            node: TypeImplItem(typ),\n+        })\n     }\n \n     /// Parse the items in a trait declaration\n@@ -1313,14 +1315,13 @@ impl<'a> Parser<'a> {\n             &token::CloseDelim(token::Brace),\n             seq_sep_none(),\n             |p| {\n-            let attrs = p.parse_outer_attributes();\n+            let mut attrs = p.parse_outer_attributes();\n \n             if p.eat_keyword(keywords::Type) {\n-                P(TypeTraitItem(p.parse_associated_type(attrs)))\n+                p.parse_assoc_ty_in_trait(attrs)\n             } else {\n                 let lo = p.span.lo;\n \n-                let vis = p.parse_visibility();\n                 let style = p.parse_unsafety();\n                 let abi = if p.eat_keyword(keywords::Extern) {\n                     p.parse_opt_abi().unwrap_or(abi::C)\n@@ -1342,50 +1343,45 @@ impl<'a> Parser<'a> {\n                 p.parse_where_clause(&mut generics);\n \n                 let hi = p.last_span.hi;\n-                match p.token {\n+                let node = match p.token {\n                   token::Semi => {\n                     p.bump();\n                     debug!(\"parse_trait_methods(): parsing required method\");\n-                    P(RequiredMethod(TypeMethod {\n-                        ident: ident,\n-                        attrs: attrs,\n+                    RequiredMethod(TypeMethod {\n                         unsafety: style,\n                         decl: d,\n                         generics: generics,\n                         abi: abi,\n                         explicit_self: explicit_self,\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: mk_sp(lo, hi),\n-                        vis: vis,\n-                    }))\n+                    })\n                   }\n                   token::OpenDelim(token::Brace) => {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n-                    let mut attrs = attrs;\n                     attrs.push_all(&inner_attrs[..]);\n-                    P(ProvidedMethod(ast::Method {\n-                        attrs: attrs,\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: mk_sp(lo, hi),\n-                        node: ast::MethDecl(ident,\n-                                            generics,\n-                                            abi,\n-                                            explicit_self,\n-                                            style,\n-                                            d,\n-                                            body,\n-                                            vis)\n-                    }))\n+                    ProvidedMethod(ast::MethDecl(generics,\n+                                                 abi,\n+                                                 explicit_self,\n+                                                 style,\n+                                                 d,\n+                                                 body))\n                   }\n \n                   _ => {\n                       let token_str = p.this_token_to_string();\n                       p.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n                                        token_str)[..])\n                   }\n-                }\n+                };\n+\n+                P(TraitItem {\n+                    id: ast::DUMMY_NODE_ID,\n+                    ident: ident,\n+                    attrs: attrs,\n+                    node: node,\n+                    span: mk_sp(lo, hi),\n+                })\n             }\n         })\n     }\n@@ -4692,7 +4688,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a method in a trait impl\n-    pub fn parse_method_with_outer_attributes(&mut self) -> Method {\n+    pub fn parse_method_with_outer_attributes(&mut self) -> P<ImplItem> {\n         let attrs = self.parse_outer_attributes();\n         let visa = self.parse_visibility();\n         self.parse_method(attrs, visa)\n@@ -4712,20 +4708,20 @@ impl<'a> Parser<'a> {\n     /// Parse a method in a trait impl, starting with `attrs` attributes.\n     pub fn parse_method(&mut self,\n                         attrs: Vec<Attribute>,\n-                        visa: Visibility)\n-                        -> Method {\n+                        vis: Visibility)\n+                        -> P<ImplItem> {\n         let lo = self.span.lo;\n \n         // code copied from parse_macro_use_or_failure... abstraction!\n-        let (method_, hi, new_attrs) = {\n+        let (method_, hi, new_attrs, ident) = {\n             if !self.token.is_any_keyword()\n                 && self.look_ahead(1, |t| *t == token::Not)\n                 && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n                     || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n                 // method macro.\n \n                 let last_span = self.last_span;\n-                self.complain_if_pub_macro(visa, last_span);\n+                self.complain_if_pub_macro(vis, last_span);\n \n                 let pth = self.parse_path(NoTypesAllowed);\n                 self.expect(&token::Not);\n@@ -4742,7 +4738,8 @@ impl<'a> Parser<'a> {\n                 if delim != token::Brace {\n                     self.expect(&token::Semi)\n                 }\n-                (ast::MethMac(m), self.span.hi, attrs)\n+                (ast::MethMac(m), self.span.hi, attrs,\n+                 token::special_idents::invalid)\n             } else {\n                 let unsafety = self.parse_unsafety();\n                 let abi = if self.eat_keyword(keywords::Extern) {\n@@ -4761,23 +4758,23 @@ impl<'a> Parser<'a> {\n                 let body_span = body.span;\n                 let mut new_attrs = attrs;\n                 new_attrs.push_all(&inner_attrs[..]);\n-                (ast::MethDecl(ident,\n-                               generics,\n+                (ast::MethDecl(generics,\n                                abi,\n                                explicit_self,\n                                unsafety,\n                                decl,\n-                               body,\n-                               visa),\n-                 body_span.hi, new_attrs)\n+                               body),\n+                 body_span.hi, new_attrs, ident)\n             }\n         };\n-        ast::Method {\n-            attrs: new_attrs,\n+        P(ImplItem {\n             id: ast::DUMMY_NODE_ID,\n+            attrs: new_attrs,\n+            vis: vis,\n+            ident: ident,\n+            node: MethodImplItem(method_),\n             span: mk_sp(lo, hi),\n-            node: method_,\n-        }\n+        })\n     }\n \n     /// Parse trait Foo { ... }\n@@ -4820,15 +4817,11 @@ impl<'a> Parser<'a> {\n             }\n \n             let vis = self.parse_visibility();\n-            if self.eat_keyword(keywords::Type) {\n-                impl_items.push(P(TypeImplItem(self.parse_typedef(\n-                            method_attrs,\n-                            vis))))\n+            impl_items.push(if self.eat_keyword(keywords::Type) {\n+                self.parse_assoc_ty_in_impl(method_attrs, vis)\n             } else {\n-                impl_items.push(P(MethodImplItem(self.parse_method(\n-                            method_attrs,\n-                            vis))));\n-            }\n+                self.parse_method(method_attrs, vis)\n+            });\n             method_attrs = vec![];\n         }\n         (impl_items, inner_attrs)"}, {"sha": "a457355698d1f92f4016c78ef749ce86c5cfe1ab", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 59, "deletions": 56, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -359,14 +359,6 @@ pub fn generics_to_string(generics: &ast::Generics) -> String {\n     $to_string(|s| s.print_generics(generics))\n }\n \n-pub fn ty_method_to_string(p: &ast::TypeMethod) -> String {\n-    $to_string(|s| s.print_ty_method(p))\n-}\n-\n-pub fn method_to_string(p: &ast::Method) -> String {\n-    $to_string(|s| s.print_method(p))\n-}\n-\n pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n     $to_string(|s| s.print_fn_block_args(p))\n }\n@@ -789,23 +781,24 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_associated_type(&mut self, typedef: &ast::AssociatedType)\n-                             -> io::Result<()>\n-    {\n-        try!(self.print_outer_attributes(&typedef.attrs));\n+    fn print_associated_type(&mut self,\n+                             ident: ast::Ident,\n+                             bounds: Option<&ast::TyParamBounds>,\n+                             ty: Option<&ast::Ty>)\n+                             -> io::Result<()> {\n         try!(self.word_space(\"type\"));\n-        try!(self.print_ty_param(&typedef.ty_param));\n+        try!(self.print_ident(ident));\n+        if let Some(bounds) = bounds {\n+            try!(self.print_bounds(\":\", bounds));\n+        }\n+        if let Some(ty) = ty {\n+            try!(space(&mut self.s));\n+            try!(self.word_space(\"=\"));\n+            try!(self.print_type(ty));\n+        }\n         word(&mut self.s, \";\")\n     }\n \n-    fn print_typedef(&mut self, typedef: &ast::Typedef) -> io::Result<()> {\n-        try!(self.word_space(\"type\"));\n-        try!(self.print_ident(typedef.ident));\n-        try!(space(&mut self.s));\n-        try!(self.word_space(\"=\"));\n-        try!(self.print_type(&*typedef.typ));\n-        word(&mut self.s, \";\")\n-    }\n \n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &ast::Item) -> io::Result<()> {\n@@ -976,18 +969,11 @@ impl<'a> State<'a> {\n                 try!(self.bopen());\n                 try!(self.print_inner_attributes(&item.attrs));\n                 for impl_item in impl_items {\n-                    match **impl_item {\n-                        ast::MethodImplItem(ref meth) => {\n-                            try!(self.print_method(meth));\n-                        }\n-                        ast::TypeImplItem(ref typ) => {\n-                            try!(self.print_typedef(typ));\n-                        }\n-                    }\n+                    try!(self.print_impl_item(impl_item));\n                 }\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTrait(unsafety, ref generics, ref bounds, ref methods) => {\n+            ast::ItemTrait(unsafety, ref generics, ref bounds, ref trait_items) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_unsafety(unsafety));\n@@ -1008,8 +994,8 @@ impl<'a> State<'a> {\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n-                for meth in methods {\n-                    try!(self.print_trait_method(meth));\n+                for trait_item in trait_items {\n+                    try!(self.print_trait_item(trait_item));\n                 }\n                 try!(self.bclose(item.span));\n             }\n@@ -1241,48 +1227,65 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_ty_method(&mut self, m: &ast::TypeMethod) -> io::Result<()> {\n-        try!(self.hardbreak_if_not_bol());\n-        try!(self.maybe_print_comment(m.span.lo));\n-        try!(self.print_outer_attributes(&m.attrs));\n+    pub fn print_ty_method(&mut self,\n+                           ident: ast::Ident,\n+                           m: &ast::TypeMethod)\n+                           -> io::Result<()> {\n         try!(self.print_ty_fn(m.abi,\n                               m.unsafety,\n                               &*m.decl,\n-                              Some(m.ident),\n+                              Some(ident),\n                               &m.generics,\n                               Some(&m.explicit_self.node)));\n         word(&mut self.s, \";\")\n     }\n \n-    pub fn print_trait_method(&mut self,\n-                              m: &ast::TraitItem) -> io::Result<()> {\n-        match *m {\n-            ast::RequiredMethod(ref ty_m) => self.print_ty_method(ty_m),\n-            ast::ProvidedMethod(ref m) => self.print_method(m),\n-            ast::TypeTraitItem(ref t) => self.print_associated_type(t),\n+    pub fn print_trait_item(&mut self, ti: &ast::TraitItem)\n+                            -> io::Result<()> {\n+        try!(self.hardbreak_if_not_bol());\n+        try!(self.maybe_print_comment(ti.span.lo));\n+        try!(self.print_outer_attributes(&ti.attrs));\n+        match ti.node {\n+            ast::RequiredMethod(ref ty_m) => {\n+                self.print_ty_method(ti.ident, ty_m)\n+            }\n+            ast::ProvidedMethod(ref m) => {\n+                self.print_method(ti.ident, &ti.attrs, ast::Inherited, m)\n+            }\n+            ast::TypeTraitItem(ref bounds, ref default) => {\n+                self.print_associated_type(ti.ident, Some(bounds),\n+                                           default.as_ref().map(|ty| &**ty))\n+            }\n         }\n     }\n \n     pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> {\n-        match *ii {\n-            ast::MethodImplItem(ref m) => self.print_method(m),\n-            ast::TypeImplItem(ref td) => self.print_typedef(td),\n+        try!(self.hardbreak_if_not_bol());\n+        try!(self.maybe_print_comment(ii.span.lo));\n+        try!(self.print_outer_attributes(&ii.attrs));\n+        match ii.node {\n+            ast::MethodImplItem(ref m) => {\n+                self.print_method(ii.ident, &ii.attrs, ii.vis, m)\n+            }\n+            ast::TypeImplItem(ref ty) => {\n+                self.print_associated_type(ii.ident, None, Some(ty))\n+            }\n         }\n     }\n \n-    pub fn print_method(&mut self, meth: &ast::Method) -> io::Result<()> {\n-        try!(self.hardbreak_if_not_bol());\n-        try!(self.maybe_print_comment(meth.span.lo));\n-        try!(self.print_outer_attributes(&meth.attrs));\n-        match meth.node {\n-            ast::MethDecl(ident,\n-                          ref generics,\n+    pub fn print_method(&mut self,\n+                        ident: ast::Ident,\n+                        attrs: &[ast::Attribute],\n+                        vis: ast::Visibility,\n+                        meth: &ast::Method)\n+                        -> io::Result<()> {\n+        match *meth {\n+            ast::MethDecl(ref generics,\n                           abi,\n                           ref explicit_self,\n                           unsafety,\n                           ref decl,\n-                          ref body,\n-                          vis) => {\n+                          ref body) => {\n                 try!(self.print_fn(&**decl,\n                                    Some(unsafety),\n                                    abi,\n@@ -1291,7 +1294,7 @@ impl<'a> State<'a> {\n                                    Some(&explicit_self.node),\n                                    vis));\n                 try!(word(&mut self.s, \" \"));\n-                self.print_block_with_attrs(&**body, &meth.attrs)\n+                self.print_block_with_attrs(&**body, attrs)\n             },\n             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                             ..}) => {"}, {"sha": "867f98f6077de993ee076eff34f0acbc698562f1", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 63, "deletions": 64, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -38,7 +38,7 @@ pub enum FnKind<'a> {\n     FkItemFn(Ident, &'a Generics, Unsafety, Abi),\n \n     /// fn foo(&self)\n-    FkMethod(Ident, &'a Generics, &'a Method),\n+    FkMethod(Ident, &'a Method),\n \n     /// |x, y| ...\n     /// proc(x, y) ...\n@@ -77,8 +77,8 @@ pub trait Visitor<'v> : Sized {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n         walk_fn(self, fk, fd, b, s)\n     }\n-    fn visit_ty_method(&mut self, t: &'v TypeMethod) { walk_ty_method(self, t) }\n-    fn visit_trait_item(&mut self, t: &'v TraitItem) { walk_trait_item(self, t) }\n+    fn visit_trait_item(&mut self, ti: &'v TraitItem) { walk_trait_item(self, ti) }\n+    fn visit_impl_item(&mut self, ii: &'v ImplItem) { walk_impl_item(self, ii) }\n     fn visit_trait_ref(&mut self, t: &'v TraitRef) { walk_trait_ref(self, t) }\n     fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n         walk_ty_param_bound(self, bounds)\n@@ -143,13 +143,7 @@ pub fn walk_inlined_item<'v,V>(visitor: &mut V, item: &'v InlinedItem)\n         IIItem(ref i) => visitor.visit_item(&**i),\n         IIForeign(ref i) => visitor.visit_foreign_item(&**i),\n         IITraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n-        IIImplItem(_, MethodImplItem(ref m)) => {\n-            walk_method_helper(visitor, m)\n-        }\n-        IIImplItem(_, TypeImplItem(ref typedef)) => {\n-            visitor.visit_ident(typedef.span, typedef.ident);\n-            visitor.visit_ty(&*typedef.typ);\n-        }\n+        IIImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n     }\n }\n \n@@ -202,8 +196,6 @@ pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-/// Like with walk_method_helper this doesn't correspond to a method\n-/// in Visitor, and so it gets a _helper suffix.\n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   trait_ref: &'v PolyTraitRef,\n                                   _modifier: &'v TraitBoundModifier)\n@@ -213,8 +205,6 @@ pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n-/// Like with walk_method_helper this doesn't correspond to a method\n-/// in Visitor, and so it gets a _helper suffix.\n pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n                                    trait_ref: &'v TraitRef)\n     where V: Visitor<'v>\n@@ -294,15 +284,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             }\n             visitor.visit_ty(&**typ);\n             for impl_item in impl_items {\n-                match **impl_item {\n-                    MethodImplItem(ref method) => {\n-                        walk_method_helper(visitor, method)\n-                    }\n-                    TypeImplItem(ref typedef) => {\n-                        visitor.visit_ident(typedef.span, typedef.ident);\n-                        visitor.visit_ty(&*typedef.typ);\n-                    }\n-                }\n+                visitor.visit_impl_item(impl_item);\n             }\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n@@ -561,15 +543,11 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_ty_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v TyParam) {\n-    visitor.visit_ident(param.span, param.ident);\n-    walk_ty_param_bounds_helper(visitor, &param.bounds);\n-    walk_ty_opt(visitor, &param.default);\n-}\n-\n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n-    for type_parameter in &*generics.ty_params {\n-        walk_ty_param(visitor, type_parameter);\n+    for param in &*generics.ty_params {\n+        visitor.visit_ident(param.span, param.ident);\n+        walk_ty_param_bounds_helper(visitor, &param.bounds);\n+        walk_ty_opt(visitor, &param.default);\n     }\n     walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n     for predicate in &generics.where_clause.predicates {\n@@ -618,19 +596,19 @@ pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &\n // visit_fn() and check for FkMethod().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-pub fn walk_method_helper<'v, V: Visitor<'v>>(visitor: &mut V, method: &'v Method) {\n-    match method.node {\n-        MethDecl(ident, ref generics, _, _, _, ref decl, ref body, _) => {\n-            visitor.visit_ident(method.span, ident);\n-            visitor.visit_fn(FkMethod(ident, generics, method),\n+fn walk_method_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                          id: NodeId,\n+                                          ident: Ident,\n+                                          span: Span,\n+                                          method: &'v Method) {\n+    match *method {\n+        MethDecl(_, _, _, _, ref decl, ref body) => {\n+            visitor.visit_ident(span, ident);\n+            visitor.visit_fn(FkMethod(ident, method),\n                              &**decl,\n                              &**body,\n-                             method.span,\n-                             method.id);\n-            for attr in &method.attrs {\n-                visitor.visit_attribute(attr);\n-            }\n-\n+                             span,\n+                             id);\n         },\n         MethMac(ref mac) => visitor.visit_mac(mac)\n     }\n@@ -647,13 +625,13 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n         FkItemFn(_, generics, _, _) => {\n             visitor.visit_generics(generics);\n         }\n-        FkMethod(_, generics, method) => {\n-            visitor.visit_generics(generics);\n-            match method.node {\n-                MethDecl(_, _, _, ref explicit_self, _, _, _, _) =>\n-                    visitor.visit_explicit_self(explicit_self),\n-                MethMac(ref mac) =>\n-                    visitor.visit_mac(mac)\n+        FkMethod(_, method) => {\n+            match *method {\n+                MethDecl(ref generics, _, ref explicit_self, _, _, _) => {\n+                    visitor.visit_generics(generics);\n+                    visitor.visit_explicit_self(explicit_self);\n+                }\n+                MethMac(ref mac) => visitor.visit_mac(mac)\n             }\n         }\n         FkFnBlock(..) => {}\n@@ -662,25 +640,46 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n     visitor.visit_block(function_body)\n }\n \n-pub fn walk_ty_method<'v, V: Visitor<'v>>(visitor: &mut V, method_type: &'v TypeMethod) {\n-    visitor.visit_ident(method_type.span, method_type.ident);\n-    visitor.visit_explicit_self(&method_type.explicit_self);\n-    for argument_type in &method_type.decl.inputs {\n-        visitor.visit_ty(&*argument_type.ty)\n-    }\n-    visitor.visit_generics(&method_type.generics);\n-    walk_fn_ret_ty(visitor, &method_type.decl.output);\n-    for attr in &method_type.attrs {\n+pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n+    visitor.visit_ident(trait_item.span, trait_item.ident);\n+    for attr in &trait_item.attrs {\n         visitor.visit_attribute(attr);\n     }\n+    match trait_item.node {\n+        RequiredMethod(ref method_type) => {\n+            visitor.visit_explicit_self(&method_type.explicit_self);\n+            visitor.visit_generics(&method_type.generics);\n+            walk_fn_decl(visitor, &method_type.decl);\n+        }\n+        ProvidedMethod(ref method) => {\n+            walk_method_helper(visitor,\n+                               trait_item.id,\n+                               trait_item.ident,\n+                               trait_item.span,\n+                               method);\n+        }\n+        TypeTraitItem(ref bounds, ref default) => {\n+            walk_ty_param_bounds_helper(visitor, bounds);\n+            walk_ty_opt(visitor, default);\n+        }\n+    }\n }\n \n-pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_method: &'v TraitItem) {\n-    match *trait_method {\n-        RequiredMethod(ref method_type) => visitor.visit_ty_method(method_type),\n-        ProvidedMethod(ref method) => walk_method_helper(visitor, method),\n-        TypeTraitItem(ref associated_type) => {\n-            walk_ty_param(visitor, &associated_type.ty_param);\n+pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n+    visitor.visit_ident(impl_item.span, impl_item.ident);\n+    for attr in &impl_item.attrs {\n+        visitor.visit_attribute(attr);\n+    }\n+    match impl_item.node {\n+        MethodImplItem(ref method) => {\n+            walk_method_helper(visitor,\n+                               impl_item.id,\n+                               impl_item.ident,\n+                               impl_item.span,\n+                               method);\n+        }\n+        TypeImplItem(ref ty) => {\n+            visitor.visit_ty(ty);\n         }\n     }\n }"}, {"sha": "8218fa0c4892a8c0619dc964fde0ffa10e441933", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -81,16 +81,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n                 ..(*quote_item!(cx, enum Foo2 { Bar2, Baz2 }).unwrap()).clone()\n             }))\n         }\n-        Annotatable::ImplItem(it) => {\n-            Annotatable::ImplItem(ImplItem::MethodImplItem(\n-                quote_method!(cx, fn foo(&self) -> i32 { 42 })\n-            ))\n-        }\n-        Annotatable::TraitItem(it) => {\n-            Annotatable::TraitItem(TraitItem::ProvidedMethod(\n-                quote_method!(cx, fn foo(&self) -> i32 { 0 })\n-            ))\n-        }\n+        it => it\n     }\n }\n "}, {"sha": "788236a27a55ba0a943deccb9de7867fcd97aeab", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -59,8 +59,8 @@ trait B {\n }\n \n pub trait C { //~ ERROR: missing documentation for a trait\n-    fn foo(&self); //~ ERROR: missing documentation for a type method\n-    fn foo_with_impl(&self) {} //~ ERROR: missing documentation for a method\n+    fn foo(&self); //~ ERROR: missing documentation for a trait method\n+    fn foo_with_impl(&self) {} //~ ERROR: missing documentation for a default method\n }\n \n #[allow(missing_docs)]"}, {"sha": "113393490cb6de18fb5c3c60dcdcaeca9a530a01", "filename": "src/test/compile-fail/unnecessary-private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     pub struct A; //~ ERROR: visibility has no effect\n     pub enum B {} //~ ERROR: visibility has no effect\n     pub trait C { //~ ERROR: visibility has no effect\n-        pub fn foo(&self) {} //~ ERROR: visibility has no effect\n+        fn foo(&self) {}\n     }\n     impl A {\n         pub fn foo(&self) {} //~ ERROR: visibility has no effect"}, {"sha": "59964d0df956c83233d3de29ee0e9e784b7fa3ff", "filename": "src/test/compile-fail/useless-priv.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fcompile-fail%2Fuseless-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fcompile-fail%2Fuseless-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuseless-priv.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -12,10 +12,7 @@ struct A { pub i: isize }\n pub enum C { pub Variant }      //~ ERROR: unnecessary `pub`\n \n pub trait E {\n-    pub fn foo(&self) {}         //~ ERROR: unnecessary visibility\n-}\n-trait F {\n-    pub fn foo(&self) {}     //~ ERROR: unnecessary visibility\n+    fn foo(&self);\n }\n \n impl E for A {"}, {"sha": "6496ffebbc849db8e73068b36942851516345dea", "filename": "src/test/parse-fail/issue-21153.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-21153.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n trait MyTrait<T>: Iterator {\n-    Item = T; //~ ERROR expected one of `extern`, `fn`, `pub`, `type`, or `unsafe`, found `Item`\n+    Item = T; //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `Item`\n }"}, {"sha": "02d76234d4e57d97d73d98ee1745b7f6cca84305", "filename": "src/test/parse-fail/trait-pub-assoc-ty.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait E {\n-    pub fn foo(&self);               //~ ERROR: unnecessary visibility\n-}\n-trait F {\n-    pub fn foo(&self);               //~ ERROR: unnecessary visibility\n+trait Foo {\n+    pub type Foo; //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `pub`\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/useless-priv2.rs"}, {"sha": "e76802d2ea0f7bdeb1d5976c8ac10d83368de6ba", "filename": "src/test/parse-fail/trait-pub-method.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    pub fn foo(); //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+}\n+\n+fn main() {}"}, {"sha": "7f7ed586878e545cdee92bbfb88db940dde379ba", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f98b1763140e4c9b0f122bde2f5cbd24227554a2/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=f98b1763140e4c9b0f122bde2f5cbd24227554a2", "patch": "@@ -36,9 +36,6 @@ fn syntax_extension(cx: &ExtCtxt) {\n     let i: Option<P<syntax::ast::Item>> = quote_item!(cx, #[derive(Eq)] struct Foo; );\n     assert!(i.is_some());\n \n-    let _j: P<syntax::ast::Method> = quote_method!(cx, fn foo(&self) {});\n-    let _k: P<syntax::ast::Method> = quote_method!(cx, #[doc = \"hello\"] fn foo(&self) {});\n-\n     let _l: P<syntax::ast::Ty> = quote_ty!(cx, &int);\n \n     let _m: Vec<syntax::ast::TokenTree> = quote_matcher!(cx, $($foo:tt,)* bar);"}]}