{"sha": "8cf6dae0ca66525fcdf519b588896e6cb5576c71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZjZkYWUwY2E2NjUyNWZjZGY1MTliNTg4ODk2ZTZjYjU1NzZjNzE=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-06-07T00:01:14Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-08-16T13:34:42Z"}, "message": "Add `for_each_local_usage`. Switch `LocalUsedVisitor` to a function.", "tree": {"sha": "1f1fa4f8932a0a7d75845a911728a699fdc2dd61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f1fa4f8932a0a7d75845a911728a699fdc2dd61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cf6dae0ca66525fcdf519b588896e6cb5576c71", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmEaaXkACgkQ2lnoZDo37QZCwwD9FcFSPqMv6Nwn5T/6flEEfNAK\nSJKRACBHTQvoQcODgm8BAIiXz61CU+WAVLzxlXiRlZHvrgFb5f5hWG+N4u0PVM8A\n=zLGe\n-----END PGP SIGNATURE-----", "payload": "tree 1f1fa4f8932a0a7d75845a911728a699fdc2dd61\nparent 983e5b877ef82f84bd463d74ba6035d75c456d73\nauthor Jason Newcomb <jsnewcomb@pm.me> 1623024074 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1629120882 -0400\n\nAdd `for_each_local_usage`. Switch `LocalUsedVisitor` to a function.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf6dae0ca66525fcdf519b588896e6cb5576c71", "html_url": "https://github.com/rust-lang/rust/commit/8cf6dae0ca66525fcdf519b588896e6cb5576c71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cf6dae0ca66525fcdf519b588896e6cb5576c71/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "983e5b877ef82f84bd463d74ba6035d75c456d73", "url": "https://api.github.com/repos/rust-lang/rust/commits/983e5b877ef82f84bd463d74ba6035d75c456d73", "html_url": "https://github.com/rust-lang/rust/commit/983e5b877ef82f84bd463d74ba6035d75c456d73"}], "stats": {"total": 195, "additions": 91, "deletions": 104}, "files": [{"sha": "a07cd5e5f4e53940be988f8fe12b8f968174d755", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=8cf6dae0ca66525fcdf519b588896e6cb5576c71", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::match_type;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{path_to_local_id, paths, peel_ref_operators, remove_blocks, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -65,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                 return;\n             };\n             if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n-            if !LocalUsedVisitor::new(cx, arg_id).check_expr(needle);\n+            if !is_local_used(cx, needle, arg_id);\n             then {\n                 let haystack = if let ExprKind::MethodCall(path, _, args, _) =\n                         filter_recv.kind {"}, {"sha": "bd8f9cc7343bfb554b826e59cb9fc5b086c817d4", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=8cf6dae0ca66525fcdf519b588896e6cb5576c71", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n@@ -83,13 +83,12 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n         // the \"wild-like\" branches must be equal\n         if SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, wild_outer_arm.body);\n         // the binding must not be used in the if guard\n-        let mut used_visitor = LocalUsedVisitor::new(cx, binding_id);\n         if match arm.guard {\n             None => true,\n-            Some(Guard::If(expr) | Guard::IfLet(_, expr)) => !used_visitor.check_expr(expr),\n+            Some(Guard::If(expr) | Guard::IfLet(_, expr)) => !is_local_used(cx, expr, binding_id),\n         };\n         // ...or anywhere in the inner match\n-        if !arms_inner.iter().any(|arm| used_visitor.check_arm(arm));\n+        if !arms_inner.iter().any(|arm| is_local_used(cx, arm, binding_id));\n         then {\n             span_lint_and_then(\n                 cx,"}, {"sha": "834440e912dfa88ceb6a027bbd082de42488a43e", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=8cf6dae0ca66525fcdf519b588896e6cb5576c71", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{path_to_local_id, visitors::LocalUsedVisitor};\n+use clippy_utils::{path_to_local_id, visitors::is_local_used};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -65,11 +65,10 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n                 if let hir::StmtKind::Expr(if_) = expr.kind;\n                 if let hir::ExprKind::If(cond, then, ref else_) = if_.kind;\n-                let mut used_visitor = LocalUsedVisitor::new(cx, canonical_id);\n-                if !used_visitor.check_expr(cond);\n+                if !is_local_used(cx, cond, canonical_id);\n                 if let hir::ExprKind::Block(then, _) = then.kind;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n-                if !used_visitor.check_expr(value);\n+                if !is_local_used(cx, value, canonical_id);\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n@@ -148,15 +147,13 @@ fn check_assign<'tcx>(\n         if let hir::ExprKind::Assign(var, value, _) = expr.kind;\n         if path_to_local_id(var, decl);\n         then {\n-            let mut v = LocalUsedVisitor::new(cx, decl);\n-\n-            if block.stmts.iter().take(block.stmts.len()-1).any(|stmt| v.check_stmt(stmt)) {\n-                return None;\n+            if block.stmts.iter().take(block.stmts.len()-1).any(|stmt| is_local_used(cx, stmt, decl)) {\n+                None\n+            } else {\n+                Some(value)\n             }\n-\n-            return Some(value);\n+        } else {\n+            None\n         }\n     }\n-\n-    None\n }"}, {"sha": "68bef2f4c8bbb351e808dcd6c78193e8896a5bc6", "filename": "clippy_lints/src/loops/for_kv_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs?ref=8cf6dae0ca66525fcdf519b588896e6cb5576c71", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n@@ -66,9 +66,7 @@ pub(super) fn check<'tcx>(\n fn pat_is_wild<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => {\n-            !LocalUsedVisitor::new(cx, id).check_expr(body)\n-        },\n+        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => !is_local_used(cx, body, id),\n         _ => false,\n     }\n }"}, {"sha": "2af6cfe35b54a6e48f6a2853c08df0153f9a78b4", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=8cf6dae0ca66525fcdf519b588896e6cb5576c71", "patch": "@@ -1,7 +1,7 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -49,7 +49,7 @@ pub(super) fn check<'tcx>(\n             let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n             if some_ctor || ok_ctor;\n             // Ensure epxr in `if let` is not used afterwards\n-            if !LocalUsedVisitor::new(cx, pat_hir_id).check_arm(true_arm);\n+            if !is_local_used(cx, true_arm, pat_hir_id);\n             then {\n                 let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n                 // Prepare the error message"}, {"sha": "fa33d068d3d88db28b1407161dbe3afee2e90896", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=8cf6dae0ca66525fcdf519b588896e6cb5576c71", "patch": "@@ -2,10 +2,8 @@ use super::NEEDLESS_RANGE_LOOP;\n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::has_iter_method;\n-use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{\n-    contains_name, higher, is_integer_const, match_trait_method, path_to_local_id, paths, sugg, SpanlessEq,\n-};\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{contains_name, higher, is_integer_const, match_trait_method, paths, sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -256,43 +254,36 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n             if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n             if let QPath::Resolved(None, seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n-            let index_used_directly = path_to_local_id(idx, self.var);\n-            let indexed_indirectly = {\n-                let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n-                walk_expr(&mut used_visitor, idx);\n-                used_visitor.used\n-            };\n-            if indexed_indirectly || index_used_directly;\n+            if is_local_used(self.cx, idx, self.var);\n             then {\n                 if self.prefer_mutable {\n                     self.indexed_mut.insert(seqvar.segments[0].ident.name);\n                 }\n+                let index_used_directly = matches!(idx.kind, ExprKind::Path(_));\n                 let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n                         let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n                         let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n-                        if indexed_indirectly {\n-                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n-                        }\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n                                 (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                             );\n+                        } else {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n                         }\n                         return false;  // no need to walk further *on the variable*\n                     }\n                     Res::Def(DefKind::Static | DefKind::Const, ..) => {\n-                        if indexed_indirectly {\n-                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n-                        }\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n                                 (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                             );\n+                        } else {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n                         }\n                         return false;  // no need to walk further *on the variable*\n                     }"}, {"sha": "149c9bee9fbd5f6bc8f7016fe0bbad1cc91854ec", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=8cf6dae0ca66525fcdf519b588896e6cb5576c71", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::diagnostics::{\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n     get_parent_expr, in_macro, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_wild, meets_msrv, msrvs,\n     path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks,\n@@ -953,9 +953,7 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                         // Looking for unused bindings (i.e.: `_e`)\n                         for pat in inner.iter() {\n                             if let PatKind::Binding(_, id, ident, None) = pat.kind {\n-                                if ident.as_str().starts_with('_')\n-                                    && !LocalUsedVisitor::new(cx, id).check_expr(arm.body)\n-                                {\n+                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n                                     ident_bind_name = (&ident.name.as_str()).to_string();\n                                     matching_wild = true;\n                                 }"}, {"sha": "e7e249c79a2fad0f6f97e1a8110d62b41f763029", "filename": "clippy_lints/src/unused_self.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_self.rs?ref=8cf6dae0ca66525fcdf519b588896e6cb5576c71", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use if_chain::if_chain;\n use rustc_hir::{Impl, ImplItem, ImplItemKind, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -50,8 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n             let body = cx.tcx.hir().body(*body_id);\n             if let [self_param, ..] = body.params;\n-            let self_hir_id = self_param.pat.hir_id;\n-            if !LocalUsedVisitor::new(cx, self_hir_id).check_body(body);\n+            if !is_local_used(cx, body, self_param.pat.hir_id);\n             then {\n                 span_lint_and_help(\n                     cx,"}, {"sha": "603e831459d38df6cb13f450a35cefa0bc36d98a", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=8cf6dae0ca66525fcdf519b588896e6cb5576c71", "patch": "@@ -2,6 +2,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(rustc_private)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![allow(clippy::missing_errors_doc, clippy::missing_panics_doc, clippy::must_use_candidate)]"}, {"sha": "52f95ff34f505f46f725d29bdb3b64a44263496d", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 60, "deletions": 56, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6dae0ca66525fcdf519b588896e6cb5576c71/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=8cf6dae0ca66525fcdf519b588896e6cb5576c71", "patch": "@@ -4,6 +4,7 @@ use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visito\n use rustc_hir::{def::Res, Arm, Block, Body, BodyId, Destination, Expr, ExprKind, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use std::ops::ControlFlow;\n \n /// returns `true` if expr contains match expr desugared from try\n fn contains_try(expr: &hir::Expr<'_>) -> bool {\n@@ -133,62 +134,6 @@ where\n     }\n }\n \n-pub struct LocalUsedVisitor<'hir> {\n-    hir: Map<'hir>,\n-    pub local_hir_id: HirId,\n-    pub used: bool,\n-}\n-\n-impl<'hir> LocalUsedVisitor<'hir> {\n-    pub fn new(cx: &LateContext<'hir>, local_hir_id: HirId) -> Self {\n-        Self {\n-            hir: cx.tcx.hir(),\n-            local_hir_id,\n-            used: false,\n-        }\n-    }\n-\n-    fn check<T>(&mut self, t: T, visit: fn(&mut Self, T)) -> bool {\n-        visit(self, t);\n-        std::mem::replace(&mut self.used, false)\n-    }\n-\n-    pub fn check_arm(&mut self, arm: &'hir Arm<'_>) -> bool {\n-        self.check(arm, Self::visit_arm)\n-    }\n-\n-    pub fn check_body(&mut self, body: &'hir Body<'_>) -> bool {\n-        self.check(body, Self::visit_body)\n-    }\n-\n-    pub fn check_expr(&mut self, expr: &'hir Expr<'_>) -> bool {\n-        self.check(expr, Self::visit_expr)\n-    }\n-\n-    pub fn check_stmt(&mut self, stmt: &'hir Stmt<'_>) -> bool {\n-        self.check(stmt, Self::visit_stmt)\n-    }\n-}\n-\n-impl<'v> Visitor<'v> for LocalUsedVisitor<'v> {\n-    type Map = Map<'v>;\n-\n-    fn visit_expr(&mut self, expr: &'v Expr<'v>) {\n-        if self.used {\n-            return;\n-        }\n-        if path_to_local_id(expr, self.local_hir_id) {\n-            self.used = true;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.hir)\n-    }\n-}\n-\n /// A type which can be visited.\n pub trait Visitable<'tcx> {\n     /// Calls the corresponding `visit_*` function on the visitor.\n@@ -202,8 +147,22 @@ macro_rules! visitable_ref {\n             }\n         }\n     };\n+    ([$t:ident], $f:ident) => {\n+        impl Visitable<'tcx> for &'tcx [$t<'tcx>] {\n+            fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n+                for x in self {\n+                    visitor.$f(x);\n+                }\n+            }\n+        }\n+    };\n }\n+visitable_ref!(Arm, visit_arm);\n visitable_ref!(Block, visit_block);\n+visitable_ref!(Body, visit_body);\n+visitable_ref!(Expr, visit_expr);\n+visitable_ref!(Stmt, visit_stmt);\n+visitable_ref!([Stmt], visit_stmt);\n \n /// Calls the given function for each break expression.\n pub fn visit_break_exprs<'tcx>(\n@@ -260,3 +219,48 @@ pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n     v.visit_expr(&cx.tcx.hir().body(body).value);\n     v.found\n }\n+\n+/// Calls the given function for each usage of the given local.\n+pub fn for_each_local_usage<'tcx, B>(\n+    cx: &LateContext<'tcx>,\n+    visitable: impl Visitable<'tcx>,\n+    id: HirId,\n+    f: impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    struct V<'tcx, B, F> {\n+        map: Map<'tcx>,\n+        id: HirId,\n+        f: F,\n+        res: ControlFlow<B>,\n+    }\n+    impl<'tcx, B, F: FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>> Visitor<'tcx> for V<'tcx, B, F> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.map)\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.res.is_continue() {\n+                if path_to_local_id(e, self.id) {\n+                    self.res = (self.f)(e);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut v = V {\n+        map: cx.tcx.hir(),\n+        id,\n+        f,\n+        res: ControlFlow::CONTINUE,\n+    };\n+    visitable.visit(&mut v);\n+    v.res\n+}\n+\n+/// Checks if the given local is used.\n+pub fn is_local_used(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id: HirId) -> bool {\n+    for_each_local_usage(cx, visitable, id, |_| ControlFlow::BREAK).is_break()\n+}"}]}