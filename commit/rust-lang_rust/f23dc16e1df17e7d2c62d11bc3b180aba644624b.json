{"sha": "f23dc16e1df17e7d2c62d11bc3b180aba644624b", "node_id": "C_kwDOAAsO6NoAKGYyM2RjMTZlMWRmMTdlN2QyYzYyZDExYmMzYjE4MGFiYTY0NDYyNGI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T19:18:00Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:22:26Z"}, "message": "Split out `single_match`", "tree": {"sha": "ae131da3145713d6054d53a5fa6ffb46a442147a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae131da3145713d6054d53a5fa6ffb46a442147a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f23dc16e1df17e7d2c62d11bc3b180aba644624b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f23dc16e1df17e7d2c62d11bc3b180aba644624b", "html_url": "https://github.com/rust-lang/rust/commit/f23dc16e1df17e7d2c62d11bc3b180aba644624b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f23dc16e1df17e7d2c62d11bc3b180aba644624b/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2b6ed7cb243b482803e23494a56f9d7ddc19453", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b6ed7cb243b482803e23494a56f9d7ddc19453", "html_url": "https://github.com/rust-lang/rust/commit/f2b6ed7cb243b482803e23494a56f9d7ddc19453"}], "stats": {"total": 541, "additions": 277, "deletions": 264}, "files": [{"sha": "5173102a9e55aaceb849a15c13d6c98e2e7ad37e", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 8, "deletions": 264, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/f23dc16e1df17e7d2c62d11bc3b180aba644624b/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23dc16e1df17e7d2c62d11bc3b180aba644624b/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=f23dc16e1df17e7d2c62d11bc3b180aba644624b", "patch": "@@ -3,15 +3,14 @@ use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n use clippy_utils::macros::{is_panic, root_macro_call};\n-use clippy_utils::paths;\n use clippy_utils::peel_blocks_with_stmt;\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n+use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n-    get_parent_expr, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n-    path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, strip_pat_refs,\n+    get_parent_expr, is_lang_ctor, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs, path_to_local_id,\n+    peel_blocks, peel_hir_pat_refs, recurse_or_patterns, strip_pat_refs,\n };\n use core::iter::once;\n use if_chain::if_chain;\n@@ -20,19 +19,20 @@ use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n-    self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat,\n+    self as hir, Arm, BindingAnnotation, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat,\n     PatKind, PathSegment, QPath, RangeEnd, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty, TyS, VariantDef};\n+use rustc_middle::ty::{self, Ty, VariantDef};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, symbol::kw, Span};\n-use std::cmp::{max, Ordering};\n+use std::cmp::Ordering;\n \n mod match_like_matches;\n mod match_same_arms;\n mod redundant_pattern_match;\n+mod single_match;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -630,7 +630,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         }\n \n         if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n-            check_single_match(cx, ex, arms, expr);\n+            single_match::check(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n             check_overlapping_arms(cx, ex, arms);\n             check_wild_err_arm(cx, ex, arms);\n@@ -710,262 +710,6 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n     extract_msrv_attr!(LateContext);\n }\n \n-#[rustfmt::skip]\n-fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        if expr.span.from_expansion() {\n-            // Don't lint match expressions present in\n-            // macro_rules! block\n-            return;\n-        }\n-        if let PatKind::Or(..) = arms[0].pat.kind {\n-            // don't lint for or patterns for now, this makes\n-            // the lint noisy in unnecessary situations\n-            return;\n-        }\n-        let els = arms[1].body;\n-        let els = if is_unit_expr(peel_blocks(els)) {\n-            None\n-        } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n-            if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n-                // single statement/expr \"else\" block, don't lint\n-                return;\n-            }\n-            // block with 2+ statements or 1 expr and 1+ statement\n-            Some(els)\n-        } else {\n-            // not a block, don't lint\n-            return;\n-        };\n-\n-        let ty = cx.typeck_results().expr_ty(ex);\n-        if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n-            check_single_match_single_pattern(cx, ex, arms, expr, els);\n-            check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n-        }\n-    }\n-}\n-\n-fn check_single_match_single_pattern(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    if is_wild(arms[1].pat) {\n-        report_single_match_single_pattern(cx, ex, arms, expr, els);\n-    }\n-}\n-\n-fn report_single_match_single_pattern(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n-    let els_str = els.map_or(String::new(), |els| {\n-        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n-    });\n-\n-    let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n-    let (msg, sugg) = if_chain! {\n-        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n-        let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n-        if let Some(spe_trait_id) = cx.tcx.lang_items().structural_peq_trait();\n-        if let Some(pe_trait_id) = cx.tcx.lang_items().eq_trait();\n-        if ty.is_integral() || ty.is_char() || ty.is_str()\n-            || (implements_trait(cx, ty, spe_trait_id, &[])\n-                && implements_trait(cx, ty, pe_trait_id, &[ty.into()]));\n-        then {\n-            // scrutinee derives PartialEq and the pattern is a constant.\n-            let pat_ref_count = match pat.kind {\n-                // string literals are already a reference.\n-                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n-                _ => pat_ref_count,\n-            };\n-            // References are only implicitly added to the pattern, so no overflow here.\n-            // e.g. will work: match &Some(_) { Some(_) => () }\n-            // will not: match Some(_) { &Some(_) => () }\n-            let ref_count_diff = ty_ref_count - pat_ref_count;\n-\n-            // Try to remove address of expressions first.\n-            let (ex, removed) = peel_n_hir_expr_refs(ex, ref_count_diff);\n-            let ref_count_diff = ref_count_diff - removed;\n-\n-            let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n-            let sugg = format!(\n-                \"if {} == {}{} {}{}\",\n-                snippet(cx, ex.span, \"..\"),\n-                // PartialEq for different reference counts may not exist.\n-                \"&\".repeat(ref_count_diff),\n-                snippet(cx, arms[0].pat.span, \"..\"),\n-                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n-                els_str,\n-            );\n-            (msg, sugg)\n-        } else {\n-            let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n-            let sugg = format!(\n-                \"if let {} = {} {}{}\",\n-                snippet(cx, arms[0].pat.span, \"..\"),\n-                snippet(cx, ex.span, \"..\"),\n-                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n-                els_str,\n-            );\n-            (msg, sugg)\n-        }\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        lint,\n-        expr.span,\n-        msg,\n-        \"try this\",\n-        sugg,\n-        Applicability::HasPlaceholders,\n-    );\n-}\n-\n-fn check_single_match_opt_like<'a>(\n-    cx: &LateContext<'a>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    ty: Ty<'a>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    // list of candidate `Enum`s we know will never get any more members\n-    let candidates = &[\n-        (&paths::COW, \"Borrowed\"),\n-        (&paths::COW, \"Cow::Borrowed\"),\n-        (&paths::COW, \"Cow::Owned\"),\n-        (&paths::COW, \"Owned\"),\n-        (&paths::OPTION, \"None\"),\n-        (&paths::RESULT, \"Err\"),\n-        (&paths::RESULT, \"Ok\"),\n-    ];\n-\n-    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n-    // match with the second branch, without enum variants in matches.\n-    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n-        return;\n-    }\n-\n-    let mut paths_and_types = Vec::new();\n-    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n-        return;\n-    }\n-\n-    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n-        let (path, ty) = path_info;\n-        for &(ty_path, pat_path) in candidates {\n-            if path == pat_path && match_type(cx, ty, ty_path) {\n-                return true;\n-            }\n-        }\n-        false\n-    };\n-    if paths_and_types.iter().all(in_candidate_enum) {\n-        report_single_match_single_pattern(cx, ex, arms, expr, els);\n-    }\n-}\n-\n-/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n-/// be simplified, false otherwise.\n-fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n-    match pat.kind {\n-        PatKind::Wild => true,\n-        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n-            let p_ty = cx.typeck_results().pat_ty(p);\n-            collect_pat_paths(acc, cx, p, p_ty)\n-        }),\n-        PatKind::TupleStruct(ref path, ..) => {\n-            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n-                s.print_qpath(path, false);\n-            });\n-            acc.push((path, ty));\n-            true\n-        },\n-        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n-            acc.push((ident.to_string(), ty));\n-            true\n-        },\n-        PatKind::Path(ref path) => {\n-            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n-                s.print_qpath(path, false);\n-            });\n-            acc.push((path, ty));\n-            true\n-        },\n-        _ => false,\n-    }\n-}\n-\n-/// Returns true if the given arm of pattern matching contains wildcard patterns.\n-fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n-    match pat.kind {\n-        PatKind::Wild => true,\n-        PatKind::Tuple(inner, _) | PatKind::TupleStruct(_, inner, ..) => inner.iter().all(contains_only_wilds),\n-        _ => false,\n-    }\n-}\n-\n-/// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n-/// patterns without a wildcard.\n-fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n-    match (&left.kind, &right.kind) {\n-        (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n-        (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n-            // We don't actually know the position and the presence of the `..` (dotdot) operator\n-            // in the arms, so we need to evaluate the correct offsets here in order to iterate in\n-            // both arms at the same time.\n-            let len = max(\n-                left_in.len() + {\n-                    if left_pos.is_some() { 1 } else { 0 }\n-                },\n-                right_in.len() + {\n-                    if right_pos.is_some() { 1 } else { 0 }\n-                },\n-            );\n-            let mut left_pos = left_pos.unwrap_or(usize::MAX);\n-            let mut right_pos = right_pos.unwrap_or(usize::MAX);\n-            let mut left_dot_space = 0;\n-            let mut right_dot_space = 0;\n-            for i in 0..len {\n-                let mut found_dotdot = false;\n-                if i == left_pos {\n-                    left_dot_space += 1;\n-                    if left_dot_space < len - left_in.len() {\n-                        left_pos += 1;\n-                    }\n-                    found_dotdot = true;\n-                }\n-                if i == right_pos {\n-                    right_dot_space += 1;\n-                    if right_dot_space < len - right_in.len() {\n-                        right_pos += 1;\n-                    }\n-                    found_dotdot = true;\n-                }\n-                if found_dotdot {\n-                    continue;\n-                }\n-                if !contains_only_wilds(&left_in[i - left_dot_space])\n-                    && !contains_only_wilds(&right_in[i - right_dot_space])\n-                {\n-                    return false;\n-                }\n-            }\n-            true\n-        },\n-        _ => false,\n-    }\n-}\n-\n fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     // Type of expression is `bool`.\n     if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {"}, {"sha": "6ba279eaf122433885b17e8dcf592dd88876bf09", "filename": "clippy_lints/src/matches/single_match.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/f23dc16e1df17e7d2c62d11bc3b180aba644624b/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23dc16e1df17e7d2c62d11bc3b180aba644624b/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=f23dc16e1df17e7d2c62d11bc3b180aba644624b", "patch": "@@ -0,0 +1,269 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{expr_block, snippet};\n+use clippy_utils::ty::{implements_trait, match_type, peel_mid_ty_refs};\n+use clippy_utils::{\n+    is_lint_allowed, is_unit_expr, is_wild, paths, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs,\n+};\n+use core::cmp::max;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, TyS};\n+\n+use super::{MATCH_BOOL, SINGLE_MATCH, SINGLE_MATCH_ELSE};\n+\n+#[rustfmt::skip]\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n+        if expr.span.from_expansion() {\n+            // Don't lint match expressions present in\n+            // macro_rules! block\n+            return;\n+        }\n+        if let PatKind::Or(..) = arms[0].pat.kind {\n+            // don't lint for or patterns for now, this makes\n+            // the lint noisy in unnecessary situations\n+            return;\n+        }\n+        let els = arms[1].body;\n+        let els = if is_unit_expr(peel_blocks(els)) {\n+            None\n+        } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n+            if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n+                // single statement/expr \"else\" block, don't lint\n+                return;\n+            }\n+            // block with 2+ statements or 1 expr and 1+ statement\n+            Some(els)\n+        } else {\n+            // not a block, don't lint\n+            return;\n+        };\n+\n+        let ty = cx.typeck_results().expr_ty(ex);\n+        if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n+            check_single_pattern(cx, ex, arms, expr, els);\n+            check_opt_like(cx, ex, arms, expr, ty, els);\n+        }\n+    }\n+}\n+\n+fn check_single_pattern(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    if is_wild(arms[1].pat) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+fn report_single_pattern(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n+    let els_str = els.map_or(String::new(), |els| {\n+        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n+    });\n+\n+    let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n+    let (msg, sugg) = if_chain! {\n+        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n+        let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n+        if let Some(spe_trait_id) = cx.tcx.lang_items().structural_peq_trait();\n+        if let Some(pe_trait_id) = cx.tcx.lang_items().eq_trait();\n+        if ty.is_integral() || ty.is_char() || ty.is_str()\n+            || (implements_trait(cx, ty, spe_trait_id, &[])\n+                && implements_trait(cx, ty, pe_trait_id, &[ty.into()]));\n+        then {\n+            // scrutinee derives PartialEq and the pattern is a constant.\n+            let pat_ref_count = match pat.kind {\n+                // string literals are already a reference.\n+                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n+                _ => pat_ref_count,\n+            };\n+            // References are only implicitly added to the pattern, so no overflow here.\n+            // e.g. will work: match &Some(_) { Some(_) => () }\n+            // will not: match Some(_) { &Some(_) => () }\n+            let ref_count_diff = ty_ref_count - pat_ref_count;\n+\n+            // Try to remove address of expressions first.\n+            let (ex, removed) = peel_n_hir_expr_refs(ex, ref_count_diff);\n+            let ref_count_diff = ref_count_diff - removed;\n+\n+            let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n+            let sugg = format!(\n+                \"if {} == {}{} {}{}\",\n+                snippet(cx, ex.span, \"..\"),\n+                // PartialEq for different reference counts may not exist.\n+                \"&\".repeat(ref_count_diff),\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        } else {\n+            let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n+            let sugg = format!(\n+                \"if let {} = {} {}{}\",\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                snippet(cx, ex.span, \"..\"),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        }\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        lint,\n+        expr.span,\n+        msg,\n+        \"try this\",\n+        sugg,\n+        Applicability::HasPlaceholders,\n+    );\n+}\n+\n+fn check_opt_like<'a>(\n+    cx: &LateContext<'a>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    ty: Ty<'a>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    // list of candidate `Enum`s we know will never get any more members\n+    let candidates = &[\n+        (&paths::COW, \"Borrowed\"),\n+        (&paths::COW, \"Cow::Borrowed\"),\n+        (&paths::COW, \"Cow::Owned\"),\n+        (&paths::COW, \"Owned\"),\n+        (&paths::OPTION, \"None\"),\n+        (&paths::RESULT, \"Err\"),\n+        (&paths::RESULT, \"Ok\"),\n+    ];\n+\n+    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n+    // match with the second branch, without enum variants in matches.\n+    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n+        return;\n+    }\n+\n+    let mut paths_and_types = Vec::new();\n+    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n+        return;\n+    }\n+\n+    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n+        let (path, ty) = path_info;\n+        for &(ty_path, pat_path) in candidates {\n+            if path == pat_path && match_type(cx, ty, ty_path) {\n+                return true;\n+            }\n+        }\n+        false\n+    };\n+    if paths_and_types.iter().all(in_candidate_enum) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n+/// be simplified, false otherwise.\n+fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n+            let p_ty = cx.typeck_results().pat_ty(p);\n+            collect_pat_paths(acc, cx, p, p_ty)\n+        }),\n+        PatKind::TupleStruct(ref path, ..) => {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            });\n+            acc.push((path, ty));\n+            true\n+        },\n+        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n+            acc.push((ident.to_string(), ty));\n+            true\n+        },\n+        PatKind::Path(ref path) => {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            });\n+            acc.push((path, ty));\n+            true\n+        },\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true if the given arm of pattern matching contains wildcard patterns.\n+fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) | PatKind::TupleStruct(_, inner, ..) => inner.iter().all(contains_only_wilds),\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n+/// patterns without a wildcard.\n+fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+    match (&left.kind, &right.kind) {\n+        (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n+        (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n+            // We don't actually know the position and the presence of the `..` (dotdot) operator\n+            // in the arms, so we need to evaluate the correct offsets here in order to iterate in\n+            // both arms at the same time.\n+            let len = max(\n+                left_in.len() + {\n+                    if left_pos.is_some() { 1 } else { 0 }\n+                },\n+                right_in.len() + {\n+                    if right_pos.is_some() { 1 } else { 0 }\n+                },\n+            );\n+            let mut left_pos = left_pos.unwrap_or(usize::MAX);\n+            let mut right_pos = right_pos.unwrap_or(usize::MAX);\n+            let mut left_dot_space = 0;\n+            let mut right_dot_space = 0;\n+            for i in 0..len {\n+                let mut found_dotdot = false;\n+                if i == left_pos {\n+                    left_dot_space += 1;\n+                    if left_dot_space < len - left_in.len() {\n+                        left_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if i == right_pos {\n+                    right_dot_space += 1;\n+                    if right_dot_space < len - right_in.len() {\n+                        right_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if found_dotdot {\n+                    continue;\n+                }\n+                if !contains_only_wilds(&left_in[i - left_dot_space])\n+                    && !contains_only_wilds(&right_in[i - right_dot_space])\n+                {\n+                    return false;\n+                }\n+            }\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}]}