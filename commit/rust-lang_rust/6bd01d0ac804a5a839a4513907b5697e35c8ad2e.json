{"sha": "6bd01d0ac804a5a839a4513907b5697e35c8ad2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZDAxZDBhYzgwNGE1YTgzOWE0NTEzOTA3YjU2OTdlMzVjOGFkMmU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-06T23:10:56Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-06T23:37:18Z"}, "message": "In resolve, forbid duplicate value, type, and module items\n\nCloses #3099", "tree": {"sha": "18ecaa2c5f5303ff7ed6af0d97d1b9bbe92c19f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18ecaa2c5f5303ff7ed6af0d97d1b9bbe92c19f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bd01d0ac804a5a839a4513907b5697e35c8ad2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bd01d0ac804a5a839a4513907b5697e35c8ad2e", "html_url": "https://github.com/rust-lang/rust/commit/6bd01d0ac804a5a839a4513907b5697e35c8ad2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0308884416867110aa713b1daa10d12ff44a275a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0308884416867110aa713b1daa10d12ff44a275a", "html_url": "https://github.com/rust-lang/rust/commit/0308884416867110aa713b1daa10d12ff44a275a"}], "stats": {"total": 205, "additions": 167, "deletions": 38}, "files": [{"sha": "61350c1739daa084776b74163d5ea8ddda583f95", "filename": "src/libcore/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=6bd01d0ac804a5a839a4513907b5697e35c8ad2e", "patch": "@@ -1872,7 +1872,7 @@ fn test_avoid_copying_the_body_task_spawn() {\n }\n \n #[test]\n-fn test_avoid_copying_the_body_spawn_listener() {\n+fn test_avoid_copying_the_body_spawn_listener_1() {\n     do avoid_copying_the_body |f| {\n         task().spawn_listener(fn~(move f, _po: comm::port<int>) {\n             f();"}, {"sha": "f5286758a02b3e6b8ffe605ed426fff1f441e0a0", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 145, "deletions": 37, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=6bd01d0ac804a5a839a4513907b5697e35c8ad2e", "patch": "@@ -497,29 +497,41 @@ class NameBindings {\n     let mut value_def: option<def>;     //< Meaning in the value namespace.\n     let mut impl_defs: ~[@Impl];        //< Meaning in the impl namespace.\n \n+    // For error reporting\n+    let mut module_span: option<span>;\n+    let mut type_span: option<span>;\n+    let mut value_span: option<span>;\n+\n     new() {\n         self.module_def = NoModuleDef;\n         self.type_def = none;\n         self.value_def = none;\n         self.impl_defs = ~[];\n+        self.module_span = none;\n+        self.type_span = none;\n+        self.value_span = none;\n     }\n \n     /// Creates a new module in this set of name bindings.\n-    fn define_module(parent_link: ParentLink, def_id: option<def_id>) {\n+    fn define_module(parent_link: ParentLink, def_id: option<def_id>,\n+                     sp: span) {\n         if self.module_def == NoModuleDef {\n             let module_ = @Module(parent_link, def_id);\n             self.module_def = ModuleDef(module_);\n+            self.module_span = some(sp);\n         }\n     }\n \n     /// Records a type definition.\n-    fn define_type(def: def) {\n+    fn define_type(def: def, sp: span) {\n         self.type_def = some(def);\n+        self.type_span = some(sp);\n     }\n \n     /// Records a value definition.\n-    fn define_value(def: def) {\n+    fn define_value(def: def, sp: span) {\n         self.value_def = some(def);\n+        self.value_span = some(sp);\n     }\n \n     /// Records an impl definition.\n@@ -582,6 +594,20 @@ class NameBindings {\n           }\n         }\n     }\n+\n+    fn span_for_namespace(namespace: Namespace) -> option<span> {\n+        match self.def_for_namespace(namespace) {\n+          some(d) => {\n+            match namespace {\n+              TypeNS   => self.type_span,\n+              ValueNS  => self.value_span,\n+              ModuleNS => self.module_span,\n+              _        => none\n+            }\n+          }\n+          none => none\n+        }\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -616,6 +642,15 @@ class PrimitiveTypeTable {\n     }\n }\n \n+fn namespace_to_str(ns: Namespace) -> ~str {\n+    match ns {\n+      TypeNS   => ~\"type\",\n+      ValueNS  => ~\"value\",\n+      ModuleNS => ~\"module\",\n+      ImplNS   => ~\"implementation\"\n+    }\n+}\n+\n /// The main resolver class.\n class Resolver {\n     let session: session;\n@@ -678,7 +713,8 @@ class Resolver {\n \n         self.graph_root = @NameBindings();\n         (*self.graph_root).define_module(NoParentLink,\n-                                         some({ crate: 0, node: 0 }));\n+                                         some({ crate: 0, node: 0 }),\n+                                         crate.span);\n \n         self.unused_import_lint_level = unused_import_lint_level(session);\n \n@@ -780,7 +816,12 @@ class Resolver {\n      * a block, fails.\n      */\n     fn add_child(name: Atom,\n-                 reduced_graph_parent: ReducedGraphParent)\n+                 reduced_graph_parent: ReducedGraphParent,\n+                 // Pass in the namespaces for the child item so that we can\n+                 // check for duplicate items in the same namespace\n+                 ns: ~[Namespace],\n+                 // For printing errors\n+                 sp: span)\n               -> (@NameBindings, ReducedGraphParent) {\n \n         // If this is the immediate descendant of a module, then we add the\n@@ -798,12 +839,30 @@ class Resolver {\n         let new_parent = ModuleReducedGraphParent(module_);\n         match module_.children.find(name) {\n             none => {\n-                let child = @NameBindings();\n-                module_.children.insert(name, child);\n-                return (child, new_parent);\n+              let child = @NameBindings();\n+              module_.children.insert(name, child);\n+              return (child, new_parent);\n             }\n             some(child) => {\n-                return (child, new_parent);\n+              // We don't want to complain if the multiple definitions\n+              // are in different namespaces. (unless it's the impl namespace,\n+              // since impls can share a name)\n+              match ns.find(|n| n != ImplNS && child.defined_in_namespace(n)) {\n+                some(ns) => {\n+                  self.session.span_err(sp,\n+                       #fmt(\"Duplicate definition of %s %s\",\n+                            namespace_to_str(ns),\n+                            *(*self.atom_table).atom_to_str(name)));\n+                  do child.span_for_namespace(ns).iter() |sp| {\n+                      self.session.span_note(sp,\n+                           #fmt(\"First definition of %s %s here:\",\n+                            namespace_to_str(ns),\n+                            *(*self.atom_table).atom_to_str(name)));\n+                  }\n+                }\n+                _ => {}\n+              }\n+              return (child, new_parent);\n             }\n         }\n     }\n@@ -853,23 +912,31 @@ class Resolver {\n                                     &&visitor: vt<ReducedGraphParent>) {\n \n         let atom = (*self.atom_table).intern(item.ident);\n-        let (name_bindings, new_parent) = self.add_child(atom, parent);\n+        let sp = item.span;\n \n         match item.node {\n             item_mod(module_) => {\n+              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+                                                       ~[ModuleNS], sp);\n+\n                 let parent_link = self.get_parent_link(new_parent, atom);\n                 let def_id = { crate: 0, node: item.id };\n-                (*name_bindings).define_module(parent_link, some(def_id));\n+              (*name_bindings).define_module(parent_link, some(def_id),\n+                                             sp);\n \n                 let new_parent =\n                     ModuleReducedGraphParent((*name_bindings).get_module());\n \n-                visit_mod(module_, item.span, item.id, new_parent, visitor);\n+                visit_mod(module_, sp, item.id, new_parent, visitor);\n             }\n             item_foreign_mod(foreign_module) => {\n+              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+                                                           ~[ModuleNS], sp);\n+\n                 let parent_link = self.get_parent_link(new_parent, atom);\n                 let def_id = { crate: 0, node: item.id };\n-                (*name_bindings).define_module(parent_link, some(def_id));\n+                (*name_bindings).define_module(parent_link, some(def_id),\n+                                               sp);\n \n                 let new_parent =\n                     ModuleReducedGraphParent((*name_bindings).get_module());\n@@ -879,22 +946,35 @@ class Resolver {\n \n             // These items live in the value namespace.\n             item_const(*) => {\n-                (*name_bindings).define_value(def_const(local_def(item.id)));\n+              let (name_bindings, _) = self.add_child(atom, parent,\n+                                                      ~[ValueNS], sp);\n+\n+                (*name_bindings).define_value(def_const(local_def(item.id)),\n+                                              sp);\n             }\n             item_fn(decl, _, _) => {\n+              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+                                                        ~[ValueNS], sp);\n+\n                 let def = def_fn(local_def(item.id), decl.purity);\n-                (*name_bindings).define_value(def);\n+                (*name_bindings).define_value(def, sp);\n                 visit_item(item, new_parent, visitor);\n             }\n \n             // These items live in the type namespace.\n             item_ty(*) => {\n-                (*name_bindings).define_type(def_ty(local_def(item.id)));\n+              let (name_bindings, _) = self.add_child(atom, parent,\n+                                                      ~[TypeNS], sp);\n+\n+                (*name_bindings).define_type(def_ty(local_def(item.id)), sp);\n             }\n \n             // These items live in both the type and value namespaces.\n             item_enum(variants, _) => {\n-                (*name_bindings).define_type(def_ty(local_def(item.id)));\n+              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+                                                     ~[ValueNS, TypeNS], sp);\n+\n+                (*name_bindings).define_type(def_ty(local_def(item.id)), sp);\n \n                 for variants.each |variant| {\n                     self.build_reduced_graph_for_variant(variant,\n@@ -904,7 +984,10 @@ class Resolver {\n                 }\n             }\n             item_class(_, _, class_members, optional_ctor, _) => {\n-                (*name_bindings).define_type(def_ty(local_def(item.id)));\n+              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+                                              ~[ValueNS, TypeNS], sp);\n+\n+                (*name_bindings).define_type(def_ty(local_def(item.id)), sp);\n \n                 match optional_ctor {\n                     none => {\n@@ -914,7 +997,7 @@ class Resolver {\n                         let purity = ctor.node.dec.purity;\n                         let ctor_def = def_fn(local_def(ctor.node.id),\n                                               purity);\n-                        (*name_bindings).define_value(ctor_def);\n+                        (*name_bindings).define_value(ctor_def, sp);\n                     }\n                 }\n \n@@ -963,6 +1046,8 @@ class Resolver {\n                 // implementation scopes (ImplScopes) need and write it into\n                 // the implementation definition list for this set of name\n                 // bindings.\n+              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+                                                               ~[ImplNS], sp);\n \n                 let mut method_infos = ~[];\n                 for methods.each |method| {\n@@ -986,7 +1071,10 @@ class Resolver {\n                 visit_item(item, new_parent, visitor);\n             }\n \n-            item_trait(_, _, methods) => {\n+          item_trait(_, _, methods) => {\n+              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+                                                               ~[TypeNS], sp);\n+\n                 // Add the names of all the methods to the trait info.\n                 let method_names = @atom_hashmap();\n                 for methods.each |method| {\n@@ -1007,7 +1095,7 @@ class Resolver {\n                 let def_id = local_def(item.id);\n                 self.trait_info.insert(def_id, method_names);\n \n-                (*name_bindings).define_type(def_ty(def_id));\n+                (*name_bindings).define_type(def_ty(def_id), sp);\n                 visit_item(item, new_parent, visitor);\n             }\n \n@@ -1027,10 +1115,11 @@ class Resolver {\n                                        &&_visitor: vt<ReducedGraphParent>) {\n \n         let atom = (*self.atom_table).intern(variant.node.name);\n-        let (child, _) = self.add_child(atom, parent);\n+        let (child, _) = self.add_child(atom, parent, ~[ValueNS],\n+                                        variant.span);\n \n         (*child).define_value(def_variant(item_id,\n-                                          local_def(variant.node.id)));\n+                                local_def(variant.node.id)), variant.span);\n     }\n \n     /**\n@@ -1173,14 +1262,17 @@ class Resolver {\n                     some(crate_id) => {\n                         let atom = (*self.atom_table).intern(name);\n                         let (child_name_bindings, new_parent) =\n-                            self.add_child(atom, parent);\n+                            // should this be in ModuleNS? --tjc\n+                            self.add_child(atom, parent, ~[ModuleNS],\n+                                           view_item.span);\n \n                         let def_id = { crate: crate_id, node: 0 };\n                         let parent_link = ModuleParentLink\n                             (self.get_module_from_parent(new_parent), atom);\n \n                         (*child_name_bindings).define_module(parent_link,\n-                                                             some(def_id));\n+                                                             some(def_id),\n+                                                             view_item.span);\n                         self.build_reduced_graph_for_external_crate\n                             ((*child_name_bindings).get_module());\n                     }\n@@ -1199,12 +1291,14 @@ class Resolver {\n                                                 vt<ReducedGraphParent>) {\n \n         let name = (*self.atom_table).intern(foreign_item.ident);\n-        let (name_bindings, new_parent) = self.add_child(name, parent);\n \n         match foreign_item.node {\n             foreign_item_fn(fn_decl, type_parameters) => {\n+              let (name_bindings, new_parent) = self.add_child(name, parent,\n+                                              ~[ValueNS], foreign_item.span);\n+\n                 let def = def_fn(local_def(foreign_item.id), fn_decl.purity);\n-                (*name_bindings).define_value(def);\n+                (*name_bindings).define_value(def, foreign_item.span);\n \n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(&type_parameters,\n@@ -1271,7 +1365,9 @@ class Resolver {\n                 let atom = (*self.atom_table).intern(@copy ident);\n                 let (child_name_bindings, new_parent) =\n                     self.add_child(atom,\n-                                   ModuleReducedGraphParent(current_module));\n+                                   ModuleReducedGraphParent(current_module),\n+                                   // May want a better span\n+                                   ~[], dummy_sp());\n \n                 // Define or reuse the module node.\n                 match child_name_bindings.module_def {\n@@ -1281,7 +1377,7 @@ class Resolver {\n                         let parent_link = self.get_parent_link(new_parent,\n                                                                atom);\n                         (*child_name_bindings).define_module(parent_link,\n-                                                             none);\n+                                                       none, dummy_sp());\n                     }\n                     ModuleDef(_) => { /* Fall through. */ }\n                 }\n@@ -1293,7 +1389,8 @@ class Resolver {\n             let atom = (*self.atom_table).intern(@copy final_ident);\n             let (child_name_bindings, new_parent) =\n                 self.add_child(atom,\n-                               ModuleReducedGraphParent(current_module));\n+                               ModuleReducedGraphParent(current_module),\n+                              ~[], dummy_sp());\n \n             match path_entry.def_like {\n                 dl_def(def) => {\n@@ -1312,7 +1409,8 @@ class Resolver {\n                                         none => {\n                                             (*child_name_bindings).\n                                                 define_module(parent_link,\n-                                                              some(def_id));\n+                                                              some(def_id),\n+                                                             dummy_sp());\n                                             modules.insert(def_id,\n                                                 (*child_name_bindings).\n                                                     get_module());\n@@ -1373,7 +1471,9 @@ class Resolver {\n                         def_variant(_, def_id) => {\n                             debug!{\"(building reduced graph for external \\\n                                     crate) building value %s\", final_ident};\n-                            (*child_name_bindings).define_value(def);\n+                            // Might want a better span\n+                            (*child_name_bindings).define_value(def,\n+                                                                dummy_sp());\n                         }\n                         def_ty(def_id) => {\n                             debug!{\"(building reduced graph for external \\\n@@ -1407,17 +1507,23 @@ class Resolver {\n                                 }\n                             }\n \n-                            (*child_name_bindings).define_type(def);\n+                            // Might want a better span\n+                            (*child_name_bindings).define_type(def,\n+                                                               dummy_sp());\n                         }\n                         def_class(def_id, has_constructor) => {\n                             debug!{\"(building reduced graph for external \\\n                                     crate) building type %s (value? %d)\",\n                                     final_ident,\n                                     if has_constructor { 1 } else { 0 }};\n-                            (*child_name_bindings).define_type(def);\n+                            // Might want a better span\n+                            (*child_name_bindings).define_type(def,\n+                                                               dummy_sp());\n \n+                            // Might want a better span\n                             if has_constructor {\n-                                (*child_name_bindings).define_value(def);\n+                                (*child_name_bindings).define_value(def,\n+                                                              dummy_sp());\n                             }\n                         }\n                         def_self(*) | def_arg(*) | def_local(*) |\n@@ -1513,7 +1619,9 @@ class Resolver {\n             let name = (*self.atom_table).intern(implementation.ident);\n \n             let (name_bindings, _) =\n-                self.add_child(name, ModuleReducedGraphParent(module_));\n+                    // Might want a better span\n+                self.add_child(name, ModuleReducedGraphParent(module_),\n+                              ~[ImplNS], dummy_sp());\n \n             name_bindings.impl_defs += ~[implementation];\n         }\n@@ -3779,7 +3887,7 @@ class Resolver {\n                     // The meaning of pat_ident with no type parameters\n                     // depends on whether an enum variant with that name is in\n                     // scope. The probing lookup has to be careful not to emit\n-                    // spurious errors. Only matching patterns (alt) can match\n+                    // spurious errors. Only matching patterns (match) can match\n                     // nullary variants. For binding patterns (let), matching\n                     // such a variant is simply disallowed (since it's rarely\n                     // what you want)."}, {"sha": "2721186585bce4d69e8eeb5cac1a91f0dac82e4a", "filename": "src/test/compile-fail/issue-3099-a.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/src%2Ftest%2Fcompile-fail%2Fissue-3099-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/src%2Ftest%2Fcompile-fail%2Fissue-3099-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3099-a.rs?ref=6bd01d0ac804a5a839a4513907b5697e35c8ad2e", "patch": "@@ -0,0 +1,5 @@\n+enum a { b, c }\n+\n+enum a { d, e } //~ ERROR Duplicate definition of type a\n+\n+fn main() {}"}, {"sha": "b11a843233f10a1ac9faa66e4f15cf6502f4c57f", "filename": "src/test/compile-fail/issue-3099-b.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/src%2Ftest%2Fcompile-fail%2Fissue-3099-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/src%2Ftest%2Fcompile-fail%2Fissue-3099-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3099-b.rs?ref=6bd01d0ac804a5a839a4513907b5697e35c8ad2e", "patch": "@@ -0,0 +1,5 @@\n+module a {}\n+\n+module a {} //~ ERROR Duplicate definition of module a\n+\n+fn main() {}"}, {"sha": "4f3bd89e7ef911bf153ca57c2fb28a13758c7f00", "filename": "src/test/compile-fail/issue-3099.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd01d0ac804a5a839a4513907b5697e35c8ad2e/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs?ref=6bd01d0ac804a5a839a4513907b5697e35c8ad2e", "patch": "@@ -0,0 +1,11 @@\n+fn a(x: ~str) -> ~str {\n+    #fmt(\"First function with %s\", x)\n+}\n+\n+fn a(x: ~str, y: ~str) -> ~str { //~ ERROR Duplicate definition of value a\n+    #fmt(\"Second function with %s and %s\", x, y)\n+}\n+\n+fn main() {\n+    #info(\"Result: \");\n+}"}]}