{"sha": "06073c9dfc15dd07b611e3497539dcab547ce185", "node_id": "C_kwDOAAsO6NoAKDA2MDczYzlkZmMxNWRkMDdiNjExZTM0OTc1MzlkY2FiNTQ3Y2UxODU", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-16T00:55:51Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-06-07T02:08:07Z"}, "message": "Add more SIMD", "tree": {"sha": "bd282d899e94a441203269ce193169b6541ce916", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd282d899e94a441203269ce193169b6541ce916"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06073c9dfc15dd07b611e3497539dcab547ce185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06073c9dfc15dd07b611e3497539dcab547ce185", "html_url": "https://github.com/rust-lang/rust/commit/06073c9dfc15dd07b611e3497539dcab547ce185", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06073c9dfc15dd07b611e3497539dcab547ce185/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fa6a9080b5c3bc963f649832f1fdf9fbcd8abd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa6a9080b5c3bc963f649832f1fdf9fbcd8abd2", "html_url": "https://github.com/rust-lang/rust/commit/2fa6a9080b5c3bc963f649832f1fdf9fbcd8abd2"}], "stats": {"total": 447, "additions": 363, "deletions": 84}, "files": [{"sha": "b23d12cb0b6ba071cba921b550d0a798be1448db", "filename": "src/builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06073c9dfc15dd07b611e3497539dcab547ce185/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06073c9dfc15dd07b611e3497539dcab547ce185/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=06073c9dfc15dd07b611e3497539dcab547ce185", "patch": "@@ -286,10 +286,12 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n-            let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n             let func_name = format!(\"{:?}\", func_ptr);\n             let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args, &func_name);\n-            self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            let return_value = self.cx.context.new_call_through_ptr(None, func_ptr, &args);\n+            let return_value = llvm::adjust_intrinsic_return_value(&self, return_value, &func_name, &args);\n+            let result = current_func.new_local(None, return_value.get_type(), &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            self.block.add_assignment(None, result, return_value);\n             result.to_rvalue()\n         }\n         else {"}, {"sha": "0e75724122cfb5bffbd036b3d4dc24d0022f182b", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 208, "deletions": 5, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/06073c9dfc15dd07b611e3497539dcab547ce185/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06073c9dfc15dd07b611e3497539dcab547ce185/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=06073c9dfc15dd07b611e3497539dcab547ce185", "patch": "@@ -15,7 +15,17 @@ pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc\n                 | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\"\n                 | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n                 | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\"\n-                | \"__builtin_ia32_prolq512_mask\" | \"__builtin_ia32_prorq512_mask\"\n+                | \"__builtin_ia32_prolq512_mask\" | \"__builtin_ia32_prorq512_mask\" | \"__builtin_ia32_pslldi512_mask\"\n+                | \"__builtin_ia32_psrldi512_mask\" | \"__builtin_ia32_psllqi512_mask\" | \"__builtin_ia32_psrlqi512_mask\"\n+                | \"__builtin_ia32_pslld512_mask\" | \"__builtin_ia32_psrld512_mask\" | \"__builtin_ia32_psllq512_mask\"\n+                | \"__builtin_ia32_psrlq512_mask\" | \"__builtin_ia32_psrad512_mask\" | \"__builtin_ia32_psraq512_mask\"\n+                | \"__builtin_ia32_psradi512_mask\" | \"__builtin_ia32_psraqi512_mask\" | \"__builtin_ia32_psrav16si_mask\"\n+                | \"__builtin_ia32_psrav8di_mask\" | \"__builtin_ia32_prolvd512_mask\" | \"__builtin_ia32_prorvd512_mask\"\n+                | \"__builtin_ia32_prolvq512_mask\" | \"__builtin_ia32_prorvq512_mask\" | \"__builtin_ia32_psllv16si_mask\"\n+                | \"__builtin_ia32_psrlv16si_mask\" | \"__builtin_ia32_psllv8di_mask\" | \"__builtin_ia32_psrlv8di_mask\"\n+                | \"__builtin_ia32_permvarsi512_mask\" | \"__builtin_ia32_vpermilvarps512_mask\"\n+                | \"__builtin_ia32_vpermilvarpd512_mask\" | \"__builtin_ia32_permvardi512_mask\"\n+                | \"__builtin_ia32_permvarsf512_mask\"\n                 => {\n                 let mut new_args = args.to_vec();\n                 let arg3_type = gcc_func.get_param_type(2);\n@@ -30,7 +40,12 @@ pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc\n                 | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_prold256_mask\" | \"__builtin_ia32_prold128_mask\"\n                 | \"__builtin_ia32_prord512_mask\" | \"__builtin_ia32_prord256_mask\" | \"__builtin_ia32_prord128_mask\"\n                 | \"__builtin_ia32_prolq256_mask\" | \"__builtin_ia32_prolq128_mask\" | \"__builtin_ia32_prorq256_mask\"\n-                | \"__builtin_ia32_prorq128_mask\"\n+                | \"__builtin_ia32_prorq128_mask\" | \"__builtin_ia32_psraq256_mask\" | \"__builtin_ia32_psraq128_mask\"\n+                | \"__builtin_ia32_psraqi256_mask\" | \"__builtin_ia32_psraqi128_mask\" | \"__builtin_ia32_psravq256_mask\"\n+                | \"__builtin_ia32_psravq128_mask\" | \"__builtin_ia32_prolvd256_mask\" | \"__builtin_ia32_prolvd128_mask\"\n+                | \"__builtin_ia32_prorvd256_mask\" | \"__builtin_ia32_prorvd128_mask\" | \"__builtin_ia32_prolvq256_mask\"\n+                | \"__builtin_ia32_prolvq128_mask\" | \"__builtin_ia32_prorvq256_mask\" | \"__builtin_ia32_prorvq128_mask\"\n+                | \"__builtin_ia32_permvardi256_mask\" | \"__builtin_ia32_permvardf512_mask\" | \"__builtin_ia32_permvardf256_mask\"\n                 => {\n                 let mut new_args = args.to_vec();\n                 let arg3_type = gcc_func.get_param_type(2);\n@@ -105,6 +120,18 @@ pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc\n                 new_args.push(last_arg);\n                 args = new_args.into();\n             },\n+            \"__builtin_ia32_vpermi2vard512_mask\" | \"__builtin_ia32_vpermi2vard256_mask\"\n+                | \"__builtin_ia32_vpermi2vard128_mask\" | \"__builtin_ia32_vpermi2varq512_mask\"\n+                | \"__builtin_ia32_vpermi2varq256_mask\" | \"__builtin_ia32_vpermi2varq128_mask\"\n+                | \"__builtin_ia32_vpermi2varps512_mask\" | \"__builtin_ia32_vpermi2varps256_mask\"\n+                | \"__builtin_ia32_vpermi2varps128_mask\" | \"__builtin_ia32_vpermi2varpd512_mask\"\n+                | \"__builtin_ia32_vpermi2varpd256_mask\" | \"__builtin_ia32_vpermi2varpd128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n             \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\"\n                 | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => {\n                 let mut new_args = args.to_vec();\n@@ -118,18 +145,83 @@ pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc\n                 new_args.push(last_arg);\n                 args = new_args.into();\n             },\n+            \"__builtin_ia32_stmxcsr\" => {\n+                args = vec![].into();\n+            },\n+            \"__builtin_ia32_addcarryx_u64\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let variable = builder.current_func().new_local(None, arg2_type, \"addcarryResult\");\n+                new_args.push(variable.get_address(None));\n+                args = new_args.into();\n+            },\n+            _ => (),\n+        }\n+    }\n+    else {\n+        match &*func_name {\n+            \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+                let new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let arg3 = builder.context.new_cast(None, new_args[4], arg3_type);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let arg4 = builder.context.new_bitcast(None, new_args[2], arg4_type);\n+                args = vec![new_args[0], new_args[1], arg3, arg4, new_args[3], new_args[5]].into();\n+            },\n+            // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+            // FIXME: the intrinsics like _mm_mask_fmadd_sd should probably directly call the GCC\n+            // instrinsic to avoid this.\n+            \"__builtin_ia32_vfmaddss3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 4]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 4]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 4]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsd3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 2]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 2]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 2]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n             _ => (),\n         }\n     }\n \n     args\n }\n \n+pub fn adjust_intrinsic_return_value<'a, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, mut return_value: RValue<'gcc>, func_name: &str, args: &[RValue<'gcc>]) -> RValue<'gcc> {\n+    match func_name {\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => {\n+            let zero = builder.context.new_rvalue_zero(builder.int_type);\n+            return_value = builder.context.new_vector_access(None, return_value, zero).to_rvalue();\n+        },\n+        \"__builtin_ia32_addcarryx_u64\" => {\n+            let last_arg = args.last().expect(\"last arg\");\n+            let field1 = builder.context.new_field(None, builder.u8_type, \"carryFlag\");\n+            let field2 = builder.context.new_field(None, builder.ulonglong_type, \"carryResult\");\n+            let struct_type = builder.context.new_struct_type(None, \"addcarryResult\", &[field1, field2]);\n+            return_value = builder.context.new_struct_constructor(None, struct_type.as_type(), None, &[return_value, last_arg.dereference(None).to_rvalue()]);\n+        },\n+        _ => (),\n+    }\n+\n+    return_value\n+}\n+\n pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n-    // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n-    // last argument type check.\n     // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n     match func_name {\n+        // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n+        // last argument type check.\n         \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n             | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n             | \"__builtin_ia32_sqrtpd512_mask\" | \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n@@ -142,6 +234,11 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n                     return true;\n                 }\n             },\n+        \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+            if index == 2 || index == 3 {\n+                return true;\n+            }\n+        },\n         \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n             // Since there are two LLVM intrinsics that map to each of these GCC builtins and only\n             // one of them has a missing parameter before the last one, we check the number of\n@@ -150,6 +247,8 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n                 return true;\n             }\n         },\n+        // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => return true,\n         _ => (),\n     }\n \n@@ -203,6 +302,47 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx512.vfmadd.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n         \"llvm.x86.avx512.sitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtdq2ps512_mask\",\n         \"llvm.x86.avx512.uitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtudq2ps512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.512\" => \"__builtin_ia32_ucmpd512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.256\" => \"__builtin_ia32_ucmpd256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.128\" => \"__builtin_ia32_ucmpd128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.512\" => \"__builtin_ia32_cmpd512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.256\" => \"__builtin_ia32_cmpd256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.128\" => \"__builtin_ia32_cmpd128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.512\" => \"__builtin_ia32_ucmpq512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.256\" => \"__builtin_ia32_ucmpq256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.128\" => \"__builtin_ia32_ucmpq128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.512\" => \"__builtin_ia32_cmpq512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.256\" => \"__builtin_ia32_cmpq256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.128\" => \"__builtin_ia32_cmpq128_mask\",\n+        \"llvm.x86.avx512.mask.max.ss.round\" => \"__builtin_ia32_maxss_mask_round\",\n+        \"llvm.x86.avx512.mask.max.sd.round\" => \"__builtin_ia32_maxsd_mask_round\",\n+        \"llvm.x86.avx512.mask.min.ss.round\" => \"__builtin_ia32_minss_mask_round\",\n+        \"llvm.x86.avx512.mask.min.sd.round\" => \"__builtin_ia32_minsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.ss\" => \"__builtin_ia32_sqrtss_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.sd\" => \"__builtin_ia32_sqrtsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.ss\" => \"__builtin_ia32_getexpss_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.sd\" => \"__builtin_ia32_getexpsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.ss\" => \"__builtin_ia32_getmantss_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.sd\" => \"__builtin_ia32_getmantsd_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.ss\" => \"__builtin_ia32_rndscaless_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.sd\" => \"__builtin_ia32_rndscalesd_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.ss\" => \"__builtin_ia32_scalefss_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.sd\" => \"__builtin_ia32_scalefsd_mask_round\",\n+        \"llvm.x86.avx512.vfmadd.f32\" => \"__builtin_ia32_vfmaddss3_round\",\n+        \"llvm.x86.avx512.vfmadd.f64\" => \"__builtin_ia32_vfmaddsd3_round\",\n+        \"llvm.ceil.v4f64\" => \"__builtin_ia32_ceilpd256\",\n+        \"llvm.ceil.v8f32\" => \"__builtin_ia32_ceilps256\",\n+        \"llvm.floor.v4f64\" => \"__builtin_ia32_floorpd256\",\n+        \"llvm.floor.v8f32\" => \"__builtin_ia32_floorps256\",\n+        \"llvm.sqrt.v4f64\" => \"__builtin_ia32_sqrtpd256\",\n+        \"llvm.x86.sse.stmxcsr\" => \"__builtin_ia32_stmxcsr\",\n+        \"llvm.x86.sse.ldmxcsr\" => \"__builtin_ia32_ldmxcsr\",\n+        \"llvm.ctpop.v16i32\" => \"__builtin_ia32_vpopcountd_v16si\",\n+        \"llvm.ctpop.v8i32\" => \"__builtin_ia32_vpopcountd_v8si\",\n+        \"llvm.ctpop.v4i32\" => \"__builtin_ia32_vpopcountd_v4si\",\n+        \"llvm.ctpop.v8i64\" => \"__builtin_ia32_vpopcountq_v8di\",\n+        \"llvm.ctpop.v4i64\" => \"__builtin_ia32_vpopcountq_v4di\",\n+        \"llvm.ctpop.v2i64\" => \"__builtin_ia32_vpopcountq_v2di\",\n \n         // The above doc points to unknown builtins for the following, so override them:\n         \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\",\n@@ -221,7 +361,70 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx2.gather.q.q.256\" => \"__builtin_ia32_gatherdiv4di\",\n         \"llvm.x86.avx2.gather.q.pd\" => \"__builtin_ia32_gatherdiv2df\",\n         \"llvm.x86.avx2.gather.q.pd.256\" => \"__builtin_ia32_gatherdiv4df\",\n-        \"\" => \"\",\n+        \"llvm.x86.avx512.pslli.d.512\" => \"__builtin_ia32_pslldi512_mask\",\n+        \"llvm.x86.avx512.psrli.d.512\" => \"__builtin_ia32_psrldi512_mask\",\n+        \"llvm.x86.avx512.pslli.q.512\" => \"__builtin_ia32_psllqi512_mask\",\n+        \"llvm.x86.avx512.psrli.q.512\" => \"__builtin_ia32_psrlqi512_mask\",\n+        \"llvm.x86.avx512.psll.d.512\" => \"__builtin_ia32_pslld512_mask\",\n+        \"llvm.x86.avx512.psrl.d.512\" => \"__builtin_ia32_psrld512_mask\",\n+        \"llvm.x86.avx512.psll.q.512\" => \"__builtin_ia32_psllq512_mask\",\n+        \"llvm.x86.avx512.psrl.q.512\" => \"__builtin_ia32_psrlq512_mask\",\n+        \"llvm.x86.avx512.psra.d.512\" => \"__builtin_ia32_psrad512_mask\",\n+        \"llvm.x86.avx512.psra.q.512\" => \"__builtin_ia32_psraq512_mask\",\n+        \"llvm.x86.avx512.psra.q.256\" => \"__builtin_ia32_psraq256_mask\",\n+        \"llvm.x86.avx512.psra.q.128\" => \"__builtin_ia32_psraq128_mask\",\n+        \"llvm.x86.avx512.psrai.d.512\" => \"__builtin_ia32_psradi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.512\" => \"__builtin_ia32_psraqi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.256\" => \"__builtin_ia32_psraqi256_mask\",\n+        \"llvm.x86.avx512.psrai.q.128\" => \"__builtin_ia32_psraqi128_mask\",\n+        \"llvm.x86.avx512.psrav.d.512\" => \"__builtin_ia32_psrav16si_mask\",\n+        \"llvm.x86.avx512.psrav.q.512\" => \"__builtin_ia32_psrav8di_mask\",\n+        \"llvm.x86.avx512.psrav.q.256\" => \"__builtin_ia32_psravq256_mask\",\n+        \"llvm.x86.avx512.psrav.q.128\" => \"__builtin_ia32_psravq128_mask\",\n+        \"llvm.x86.avx512.psllv.d.512\" => \"__builtin_ia32_psllv16si_mask\",\n+        \"llvm.x86.avx512.psrlv.d.512\" => \"__builtin_ia32_psrlv16si_mask\",\n+        \"llvm.x86.avx512.psllv.q.512\" => \"__builtin_ia32_psllv8di_mask\",\n+        \"llvm.x86.avx512.psrlv.q.512\" => \"__builtin_ia32_psrlv8di_mask\",\n+        \"llvm.x86.avx512.permvar.si.512\" => \"__builtin_ia32_permvarsi512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.ps.512\" => \"__builtin_ia32_vpermilvarps512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.pd.512\" => \"__builtin_ia32_vpermilvarpd512_mask\",\n+        \"llvm.x86.avx512.permvar.di.512\" => \"__builtin_ia32_permvardi512_mask\",\n+        \"llvm.x86.avx512.permvar.di.256\" => \"__builtin_ia32_permvardi256_mask\",\n+        \"llvm.x86.avx512.permvar.sf.512\" => \"__builtin_ia32_permvarsf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.512\" => \"__builtin_ia32_permvardf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.256\" => \"__builtin_ia32_permvardf256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.512\" => \"__builtin_ia32_vpermi2vard512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.256\" => \"__builtin_ia32_vpermi2vard256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.128\" => \"__builtin_ia32_vpermi2vard128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.512\" => \"__builtin_ia32_vpermi2varq512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.256\" => \"__builtin_ia32_vpermi2varq256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.128\" => \"__builtin_ia32_vpermi2varq128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.512\" => \"__builtin_ia32_vpermi2varps512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.256\" => \"__builtin_ia32_vpermi2varps256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.128\" => \"__builtin_ia32_vpermi2varps128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.512\" => \"__builtin_ia32_vpermi2varpd512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.256\" => \"__builtin_ia32_vpermi2varpd256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.128\" => \"__builtin_ia32_vpermi2varpd128_mask\",\n+        \"llvm.x86.avx512.mask.add.ss.round\" => \"__builtin_ia32_addss_mask_round\",\n+        \"llvm.x86.avx512.mask.add.sd.round\" => \"__builtin_ia32_addsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.ss.round\" => \"__builtin_ia32_subss_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.sd.round\" => \"__builtin_ia32_subsd_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.ss.round\" => \"__builtin_ia32_mulss_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.sd.round\" => \"__builtin_ia32_mulsd_mask_round\",\n+        \"llvm.x86.avx512.mask.div.ss.round\" => \"__builtin_ia32_divss_mask_round\",\n+        \"llvm.x86.avx512.mask.div.sd.round\" => \"__builtin_ia32_divsd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtss2sd.round\" => \"__builtin_ia32_cvtss2sd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtsd2ss.round\" => \"__builtin_ia32_cvtsd2ss_mask_round\",\n+        \"llvm.x86.aesni.aesenc.256\" => \"__builtin_ia32_vaesenc_v32qi\",\n+        \"llvm.x86.aesni.aesenclast.256\" => \"__builtin_ia32_vaesenclast_v32qi\",\n+        \"llvm.x86.aesni.aesdec.256\" => \"__builtin_ia32_vaesdec_v32qi\",\n+        \"llvm.x86.aesni.aesdeclast.256\" => \"__builtin_ia32_vaesdeclast_v32qi\",\n+        \"llvm.x86.aesni.aesenc.512\" => \"__builtin_ia32_vaesenc_v64qi\",\n+        \"llvm.x86.aesni.aesenclast.512\" => \"__builtin_ia32_vaesenclast_v64qi\",\n+        \"llvm.x86.aesni.aesdec.512\" => \"__builtin_ia32_vaesdec_v64qi\",\n+        \"llvm.x86.aesni.aesdeclast.512\" => \"__builtin_ia32_vaesdeclast_v64qi\",\n+        \"llvm.x86.addcarry.64\" => \"__builtin_ia32_addcarryx_u64\",\n+\n         // NOTE: this file is generated by https://github.com/GuillaumeGomez/llvmint/blob/master/generate_list.py\n         _ => include!(\"archs.rs\"),\n     };"}, {"sha": "bf5d555736ae27e1a4da964325fe81e00ad3993e", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 151, "deletions": 77, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/06073c9dfc15dd07b611e3497539dcab547ce185/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06073c9dfc15dd07b611e3497539dcab547ce185/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=06073c9dfc15dd07b611e3497539dcab547ce185", "patch": "@@ -1,4 +1,4 @@\n-use gccjit::{BinaryOp, RValue, Type, ToRValue};\n+use gccjit::{BinaryOp, RValue, Type, ToRValue, ComparisonOp, UnaryOp};\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n@@ -213,48 +213,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n         let value = args[2].immediate();\n-        // TODO(antoyo): use a recursive unqualified() here.\n-        let vector_type = vector.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n-        let element_type = vector_type.get_element_type();\n-        // NOTE: we cannot cast to an array and assign to its element here because the value might\n-        // not be an l-value. So, call a builtin to set the element.\n-        // TODO(antoyo): perhaps we could create a new vector or maybe there's a GIMPLE instruction for that?\n-        // TODO(antoyo): don't use target specific builtins here.\n-        let func_name =\n-            match in_len {\n-                2 => {\n-                    if element_type == bx.i64_type {\n-                        \"__builtin_ia32_vec_set_v2di\"\n-                    }\n-                    else {\n-                        unimplemented!();\n-                    }\n-                },\n-                4 => {\n-                    if element_type == bx.i32_type {\n-                        \"__builtin_ia32_vec_set_v4si\"\n-                    }\n-                    else {\n-                        unimplemented!();\n-                    }\n-                },\n-                8 => {\n-                    if element_type == bx.i16_type {\n-                        \"__builtin_ia32_vec_set_v8hi\"\n-                    }\n-                    else {\n-                        unimplemented!();\n-                    }\n-                },\n-                _ => unimplemented!(\"Len: {}\", in_len),\n-            };\n-        let builtin = bx.context.get_target_builtin_function(func_name);\n-        let param1_type = builtin.get_param(0).to_rvalue().get_type();\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        let vector = bx.cx.bitcast_if_needed(vector, param1_type);\n-        let result = bx.context.new_call(None, builtin, &[vector, value, bx.context.new_cast(None, index, bx.int_type)]);\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n+        let variable = bx.current_func().new_local(None, vector.get_type(), \"new_vector\");\n+        bx.llbb().add_assignment(None, variable, vector);\n+        let lvalue = bx.context.new_vector_access(None, variable.to_rvalue(), index);\n+        // TODO: si simd_insert est constant, utiliser BIT_REF\u2026\n+        bx.llbb().add_assignment(None, lvalue, value);\n+        return Ok(variable.to_rvalue());\n     }\n \n     #[cfg(feature=\"master\")]\n@@ -357,6 +321,67 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         }\n     }\n \n+    if name == sym::simd_bitmask {\n+        // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n+        // vector mask and returns the most significant bit (MSB) of each lane in the form\n+        // of either:\n+        // * an unsigned integer\n+        // * an array of `u8`\n+        // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+        //\n+        // The bit order of the result depends on the byte endianness, LSB-first for little\n+        // endian and MSB-first for big endian.\n+\n+        let vector = args[0].immediate();\n+        let vector_type = vector.get_type().dyncast_vector().expect(\"vector type\");\n+        let elem_type = vector_type.get_element_type();\n+        let mut shifts = vec![];\n+        let mut masks = vec![];\n+        let mut mask = 1;\n+        for i in 0..in_len {\n+            shifts.push(bx.context.new_rvalue_from_int(elem_type, i as i32));\n+            masks.push(bx.context.new_rvalue_from_int(elem_type, mask));\n+            mask <<= 1;\n+        }\n+        masks.reverse();\n+        let shifts = bx.context.new_rvalue_from_vector(None, vector.get_type(), &shifts);\n+        let shifted = vector >> shifts;\n+        let masks = bx.context.new_rvalue_from_vector(None, vector.get_type(), &masks);\n+        let masked = shifted & masks;\n+        let reduced = bx.vector_reduce_op(masked, BinaryOp::BitwiseOr);\n+\n+        let expected_int_bits = in_len.max(8);\n+        let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n+\n+        match ret_ty.kind() {\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {\n+                // Zero-extend iN to the bitmask type:\n+                return Ok(bx.zext(reduced, bx.type_ix(expected_int_bits)));\n+            }\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                // Zero-extend iN to the array length:\n+                let ze = bx.zext(reduced, bx.type_ix(expected_bytes * 8));\n+\n+                // Convert the integer to a byte array\n+                let ptr = bx.alloca(bx.type_ix(expected_bytes * 8), Align::ONE);\n+                bx.store(ze, ptr, Align::ONE);\n+                let array_ty = bx.type_array(bx.type_i8(), expected_bytes);\n+                let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n+                return Ok(bx.load(array_ty, ptr, Align::ONE));\n+            }\n+            _ => return_error!(\n+                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+                ret_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            ),\n+        }\n+    }\n+\n     fn simd_simple_float_intrinsic<'gcc, 'tcx>(\n         name: Symbol,\n         in_elem: Ty<'_>,\n@@ -496,42 +521,91 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let rhs = args[1].immediate();\n         let is_add = name == sym::simd_saturating_add;\n         let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n-        let (signed, elem_width, elem_ty) = match *in_elem.kind() {\n-            ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n-            ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n-            _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n+        let (signed, elem_width, elem_ty) =\n+            match *in_elem.kind() {\n+                ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_int_from_ty(i)),\n+                ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_uint_from_ty(i)),\n+                _ => {\n+                    return_error!(\n+                        \"expected element type `{}` of vector type `{}` \\\n                      to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n-            }\n-        };\n-        // TODO(antoyo): don't use target specific builtins here.\n-        // Not sure how easy it would be to avoid theme here.\n-        let builtin_name =\n-            match (signed, is_add, in_len, elem_width) {\n-                (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned.\n-                (false, true, 32, 8) => \"__builtin_ia32_paddusb256\",\n-                (true, true, 16, 16) => \"__builtin_ia32_paddsw256\",\n-                (false, true, 16, 16) => \"__builtin_ia32_paddusw256\",\n-                (true, false, 16, 16) => \"__builtin_ia32_psubsw256\",\n-                (false, false, 16, 16) => \"__builtin_ia32_psubusw256\",\n-                (true, false, 32, 8) => \"__builtin_ia32_psubsb256\",\n-                (false, false, 32, 8) => \"__builtin_ia32_psubusb256\",\n-                _ => unimplemented!(\"signed: {}, is_add: {}, in_len: {}, elem_width: {}\", signed, is_add, in_len, elem_width),\n+                     arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                     arg_tys[0]\n+                    );\n+                }\n             };\n-        let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n-\n-        let func = bx.context.get_target_builtin_function(builtin_name);\n-        let param1_type = func.get_param(0).to_rvalue().get_type();\n-        let param2_type = func.get_param(1).to_rvalue().get_type();\n-        let lhs = bx.cx.bitcast_if_needed(lhs, param1_type);\n-        let rhs = bx.cx.bitcast_if_needed(rhs, param2_type);\n-        let result = bx.context.new_call(None, func, &[lhs, rhs]);\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vec_ty));\n+\n+        let result =\n+            match (signed, is_add) {\n+                (false, true) => {\n+                    let res = lhs + rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThan, res, lhs);\n+                    res | cmp\n+                },\n+                (true, true) => {\n+                    // Algorithm from: https://codereview.stackexchange.com/questions/115869/saturated-signed-addition\n+                    // TODO: improve using conditional operators if possible.\n+                    let arg_type = lhs.get_type();\n+                    // TODO: convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                },\n+                (false, false) => {\n+                    let res = lhs - rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThanEquals, res, lhs);\n+                    res & cmp\n+                },\n+                (true, false) => {\n+                    let arg_type = lhs.get_type();\n+                    // TODO(antoyo): this uses the same algorithm from saturating add, but add the\n+                    // negative of the right operand. Find a proper subtraction algorithm.\n+                    let rhs = bx.context.new_unary_op(None, UnaryOp::Minus, arg_type, rhs);\n+\n+                    // TODO: convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                }\n+            };\n+\n+        return Ok(result);\n     }\n \n     macro_rules! arith_red {"}]}