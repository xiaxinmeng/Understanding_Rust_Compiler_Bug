{"sha": "8e9d5db8392c44a2e94008168fa3506ecddaa357", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOWQ1ZGI4MzkyYzQ0YTJlOTQwMDgxNjhmYTM1MDZlY2RkYWEzNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-19T11:29:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-19T11:29:00Z"}, "message": "Auto merge of #76912 - RalfJung:rollup-q9ur56h, r=RalfJung\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #73963 (deny(unsafe_op_in_unsafe_fn) in libstd/path.rs)\n - #75099 (lint/ty: move fns to avoid abstraction violation)\n - #75502 (Use implicit (not explicit) rules for promotability by default in `const fn`)\n - #75580 (Add test for checking duplicated branch or-patterns)\n - #76310 (Add `[T; N]: TryFrom<Vec<T>>` (insta-stable))\n - #76400 (Clean up vec benches bench_in_place style)\n - #76434 (do not inline black_box when building for Miri)\n - #76492 (Add associated constant `BITS` to all integer types)\n - #76525 (Add as_str() to string::Drain.)\n - #76636 (assert ScalarMaybeUninit size)\n - #76749 (give *even better* suggestion when matching a const range)\n - #76757 (don't convert types to the same type with try_into (clippy::useless_conversion))\n - #76796 (Give a better error message when x.py uses the wrong stage for CI)\n - #76798 (Build fixes for RISC-V 32-bit Linux support)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "472f315c893af1563360259b2389760df6df9aeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/472f315c893af1563360259b2389760df6df9aeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e9d5db8392c44a2e94008168fa3506ecddaa357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9d5db8392c44a2e94008168fa3506ecddaa357", "html_url": "https://github.com/rust-lang/rust/commit/8e9d5db8392c44a2e94008168fa3506ecddaa357", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e9d5db8392c44a2e94008168fa3506ecddaa357/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd702d2919fe23eeaf59574040d0b29853d44289", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd702d2919fe23eeaf59574040d0b29853d44289", "html_url": "https://github.com/rust-lang/rust/commit/fd702d2919fe23eeaf59574040d0b29853d44289"}, {"sha": "b4c3f409af031a4bcc2cf1bb693789201a33ec1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c3f409af031a4bcc2cf1bb693789201a33ec1c", "html_url": "https://github.com/rust-lang/rust/commit/b4c3f409af031a4bcc2cf1bb693789201a33ec1c"}], "stats": {"total": 637, "additions": 456, "deletions": 181}, "files": [{"sha": "06718cc9803127f2e9e50a4011963c2eaf0db16a", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -14,6 +14,7 @@\n #![feature(generators)]\n #![feature(generator_trait)]\n #![feature(fn_traits)]\n+#![feature(int_bits_const)]\n #![feature(min_specialization)]\n #![feature(optin_builtin_traits)]\n #![feature(nll)]"}, {"sha": "d63bcdb3c2b0425d4993010dccc6fb0aee679cab", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -48,7 +48,7 @@ where\n     P: Pointer,\n     T: Tag,\n {\n-    const TAG_BIT_SHIFT: usize = (8 * std::mem::size_of::<usize>()) - T::BITS;\n+    const TAG_BIT_SHIFT: usize = usize::BITS as usize - T::BITS;\n     const ASSERTION: () = {\n         assert!(T::BITS <= P::BITS);\n         // Used for the transmute_copy's below"}, {"sha": "8c8487dc8a17f327640cd426367017a4e7c9aae0", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -21,7 +21,8 @@\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n use crate::{\n-    types::CItemKind, EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n+    types::{transparent_newtype_field, CItemKind},\n+    EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n };\n use rustc_ast::attr::{self, HasAttrs};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n@@ -2688,8 +2689,7 @@ impl ClashingExternDeclarations {\n                         if is_transparent && !is_non_null {\n                             debug_assert!(def.variants.len() == 1);\n                             let v = &def.variants[VariantIdx::new(0)];\n-                            ty = v\n-                                .transparent_newtype_field(tcx)\n+                            ty = transparent_newtype_field(tcx, v)\n                                 .expect(\n                                     \"single-variant transparent structure with zero-sized field\",\n                                 )"}, {"sha": "ccbe9f80e25b73a3b086644c696727b2d76779b5", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -639,6 +639,26 @@ crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: &ty::AdtD\n         .any(|a| tcx.sess.check_name(a, sym::rustc_nonnull_optimization_guaranteed))\n }\n \n+/// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n+/// field.\n+pub fn transparent_newtype_field<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    variant: &'a ty::VariantDef,\n+) -> Option<&'a ty::FieldDef> {\n+    let param_env = tcx.param_env(variant.def_id);\n+    for field in &variant.fields {\n+        let field_ty = tcx.type_of(field.did);\n+        let is_zst =\n+            tcx.layout_of(param_env.and(field_ty)).map(|layout| layout.is_zst()).unwrap_or(false);\n+\n+        if !is_zst {\n+            return Some(field);\n+        }\n+    }\n+\n+    None\n+}\n+\n /// Is type known to be non-null?\n crate fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKind) -> bool {\n     let tcx = cx.tcx;\n@@ -654,7 +674,7 @@ crate fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: C\n             }\n \n             for variant in &def.variants {\n-                if let Some(field) = variant.transparent_newtype_field(tcx) {\n+                if let Some(field) = transparent_newtype_field(cx.tcx, variant) {\n                     if ty_is_known_nonnull(cx, field.ty(tcx, substs), mode) {\n                         return true;\n                     }\n@@ -675,7 +695,7 @@ fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n         ty::Adt(field_def, field_substs) => {\n             let inner_field_ty = {\n                 let first_non_zst_ty =\n-                    field_def.variants.iter().filter_map(|v| v.transparent_newtype_field(tcx));\n+                    field_def.variants.iter().filter_map(|v| transparent_newtype_field(cx.tcx, v));\n                 debug_assert_eq!(\n                     first_non_zst_ty.clone().count(),\n                     1,\n@@ -816,7 +836,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         if def.repr.transparent() {\n             // Can assume that only one field is not a ZST, so only check\n             // that field's type for FFI-safety.\n-            if let Some(field) = variant.transparent_newtype_field(self.cx.tcx) {\n+            if let Some(field) = transparent_newtype_field(self.cx.tcx, variant) {\n                 self.check_field_type_for_ffi(cache, field, substs)\n             } else {\n                 bug!(\"malformed transparent type\");"}, {"sha": "7741c76ff3e4517bfe23deba370d05727d619d69", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -578,6 +578,9 @@ pub enum ScalarMaybeUninit<Tag = ()> {\n     Uninit,\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(ScalarMaybeUninit, 24);\n+\n impl<Tag> From<Scalar<Tag>> for ScalarMaybeUninit<Tag> {\n     #[inline(always)]\n     fn from(s: Scalar<Tag>) -> Self {"}, {"sha": "f23d666cfcfdd4f63c0aa2e138224385499f8639", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -1999,7 +1999,7 @@ pub struct VariantDef {\n     flags: VariantFlags,\n }\n \n-impl<'tcx> VariantDef {\n+impl VariantDef {\n     /// Creates a new `VariantDef`.\n     ///\n     /// `variant_did` is the `DefId` that identifies the enum variant (if this `VariantDef`\n@@ -2065,19 +2065,6 @@ impl<'tcx> VariantDef {\n     pub fn is_recovered(&self) -> bool {\n         self.flags.intersects(VariantFlags::IS_RECOVERED)\n     }\n-\n-    /// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n-    /// field.\n-    pub fn transparent_newtype_field(&self, tcx: TyCtxt<'tcx>) -> Option<&FieldDef> {\n-        for field in &self.fields {\n-            let field_ty = field.ty(tcx, InternalSubsts::identity_for_item(tcx, self.def_id));\n-            if !field_ty.is_zst(tcx, self.def_id) {\n-                return Some(field);\n-            }\n-        }\n-\n-        None\n-    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]"}, {"sha": "724ec101b23b71a388f914dcdf9f7bdb0da1dd43", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -2322,9 +2322,4 @@ impl<'tcx> TyS<'tcx> {\n             }\n         }\n     }\n-\n-    /// Is this a zero-sized type?\n-    pub fn is_zst(&'tcx self, tcx: TyCtxt<'tcx>, did: DefId) -> bool {\n-        tcx.layout_of(tcx.param_env(did).and(self)).map(|layout| layout.is_zst()).unwrap_or(false)\n-    }\n }"}, {"sha": "5c3e3538401801993de42ebe832fdd8423fba66b", "filename": "compiler/rustc_mir/src/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -4,7 +4,6 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n use smallvec::{smallvec, SmallVec};\n \n-use std::convert::TryInto;\n use std::mem;\n \n use super::abs_domain::Lift;\n@@ -481,12 +480,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             };\n             let base_ty = base_place.ty(self.builder.body, self.builder.tcx).ty;\n             let len: u64 = match base_ty.kind() {\n-                ty::Array(_, size) => {\n-                    let length = size.eval_usize(self.builder.tcx, self.builder.param_env);\n-                    length\n-                        .try_into()\n-                        .expect(\"slice pattern of array with more than u32::MAX elements\")\n-                }\n+                ty::Array(_, size) => size.eval_usize(self.builder.tcx, self.builder.param_env),\n                 _ => bug!(\"from_end: false slice pattern of non-array type\"),\n             };\n             for offset in from..to {"}, {"sha": "3b22eb5d98719c18097843ca627414834061416f", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -551,7 +551,7 @@ where\n                 let n = base.len(self)?;\n                 if n < min_length {\n                     // This can only be reached in ConstProp and non-rustc-MIR.\n-                    throw_ub!(BoundsCheckFailed { len: min_length.into(), index: n });\n+                    throw_ub!(BoundsCheckFailed { len: min_length, index: n });\n                 }\n \n                 let index = if from_end {\n@@ -565,9 +565,7 @@ where\n                 self.mplace_index(base, index)?\n             }\n \n-            Subslice { from, to, from_end } => {\n-                self.mplace_subslice(base, u64::from(from), u64::from(to), from_end)?\n-            }\n+            Subslice { from, to, from_end } => self.mplace_subslice(base, from, to, from_end)?,\n         })\n     }\n "}, {"sha": "b6124049579fd92b65ce4c1a47644c7d45c28b3f", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -734,7 +734,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n     ) -> Result<(), Unpromotable> {\n         let fn_ty = callee.ty(self.body, self.tcx);\n \n-        if !self.explicit && self.const_kind.is_none() {\n+        // `const` and `static` use the explicit rules for promotion regardless of the `Candidate`,\n+        // meaning calls to `const fn` can be promoted.\n+        let context_uses_explicit_promotion_rules = matches!(\n+            self.const_kind,\n+            Some(hir::ConstContext::Static(_) | hir::ConstContext::Const)\n+        );\n+\n+        if !self.explicit && !context_uses_explicit_promotion_rules {\n             if let ty::FnDef(def_id, _) = *fn_ty.kind() {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`."}, {"sha": "4ef88c25cadf3393663ba6a6b90b236a7d2b2857", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let tcx = self.hir.tcx();\n         let (min_length, exact_size) = match place.ty(&self.local_decls, tcx).ty.kind() {\n             ty::Array(_, length) => {\n-                (length.eval_usize(tcx, self.hir.param_env).try_into().unwrap(), true)\n+                (length.eval_usize(tcx, self.hir.param_env), true)\n             }\n             _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n         };"}, {"sha": "321472b8fe8d36332fbf7f29305c95d38e6e1704", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -1,5 +1,6 @@\n use crate::check::FnCtxt;\n use rustc_ast as ast;\n+\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n@@ -740,6 +741,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat_ty\n     }\n \n+    fn maybe_suggest_range_literal(\n+        &self,\n+        e: &mut DiagnosticBuilder<'_>,\n+        opt_def_id: Option<hir::def_id::DefId>,\n+        ident: Ident,\n+    ) -> bool {\n+        match opt_def_id {\n+            Some(def_id) => match self.tcx.hir().get_if_local(def_id) {\n+                Some(hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Const(_, body_id), ..\n+                })) => match self.tcx.hir().get(body_id.hir_id) {\n+                    hir::Node::Expr(expr) => {\n+                        if hir::is_range_literal(expr) {\n+                            let span = self.tcx.hir().span(body_id.hir_id);\n+                            if let Ok(snip) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                                e.span_suggestion_verbose(\n+                                    ident.span,\n+                                    \"you may want to move the range into the match block\",\n+                                    snip,\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                    _ => (),\n+                },\n+                _ => (),\n+            },\n+            _ => (),\n+        }\n+        false\n+    }\n+\n     fn emit_bad_pat_path(\n         &self,\n         mut e: DiagnosticBuilder<'_>,\n@@ -772,12 +807,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         );\n                     }\n                     _ => {\n-                        let const_def_id = match pat_ty.kind() {\n+                        let (type_def_id, item_def_id) = match pat_ty.kind() {\n                             Adt(def, _) => match res {\n-                                Res::Def(DefKind::Const, _) => Some(def.did),\n-                                _ => None,\n+                                Res::Def(DefKind::Const, def_id) => (Some(def.did), Some(def_id)),\n+                                _ => (None, None),\n                             },\n-                            _ => None,\n+                            _ => (None, None),\n                         };\n \n                         let ranges = &[\n@@ -788,11 +823,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.tcx.lang_items().range_inclusive_struct(),\n                             self.tcx.lang_items().range_to_inclusive_struct(),\n                         ];\n-                        if const_def_id != None && ranges.contains(&const_def_id) {\n-                            let msg = \"constants only support matching by type, \\\n-                                if you meant to match against a range of values, \\\n-                                consider using a range pattern like `min ..= max` in the match block\";\n-                            e.note(msg);\n+                        if type_def_id != None && ranges.contains(&type_def_id) {\n+                            if !self.maybe_suggest_range_literal(&mut e, item_def_id, *ident) {\n+                                let msg = \"constants only support matching by type, \\\n+                                    if you meant to match against a range of values, \\\n+                                    consider using a range pattern like `min ..= max` in the match block\";\n+                                e.note(msg);\n+                            }\n                         } else {\n                             let msg = \"introduce a new binding instead\";\n                             let sugg = format!(\"other_{}\", ident.as_str().to_lowercase());"}, {"sha": "6703a99b15155683008ef24d88474ea40b00befe", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -457,17 +457,16 @@ fn bench_clone_from_10_1000_0100(b: &mut Bencher) {\n }\n \n macro_rules! bench_in_place {\n-    (\n-        $($fname:ident, $type:ty , $count:expr, $init: expr);*\n-    ) => {\n+    ($($fname:ident, $type:ty, $count:expr, $init:expr);*) => {\n         $(\n             #[bench]\n             fn $fname(b: &mut Bencher) {\n                 b.iter(|| {\n                     let src: Vec<$type> = black_box(vec![$init; $count]);\n                     let mut sink = src.into_iter()\n                         .enumerate()\n-                        .map(|(idx, e)| { (idx as $type) ^ e }).collect::<Vec<$type>>();\n+                        .map(|(idx, e)| idx as $type ^ e)\n+                        .collect::<Vec<$type>>();\n                     black_box(sink.as_mut_ptr())\n                 });\n             }\n@@ -476,24 +475,24 @@ macro_rules! bench_in_place {\n }\n \n bench_in_place![\n-    bench_in_place_xxu8_i0_0010,     u8,     10, 0;\n-    bench_in_place_xxu8_i0_0100,     u8,    100, 0;\n-    bench_in_place_xxu8_i0_1000,     u8,   1000, 0;\n-    bench_in_place_xxu8_i1_0010,     u8,     10, 1;\n-    bench_in_place_xxu8_i1_0100,     u8,    100, 1;\n-    bench_in_place_xxu8_i1_1000,     u8,   1000, 1;\n-    bench_in_place_xu32_i0_0010,    u32,     10, 0;\n-    bench_in_place_xu32_i0_0100,    u32,    100, 0;\n-    bench_in_place_xu32_i0_1000,    u32,   1000, 0;\n-    bench_in_place_xu32_i1_0010,    u32,     10, 1;\n-    bench_in_place_xu32_i1_0100,    u32,    100, 1;\n-    bench_in_place_xu32_i1_1000,    u32,   1000, 1;\n-    bench_in_place_u128_i0_0010,   u128,     10, 0;\n-    bench_in_place_u128_i0_0100,   u128,    100, 0;\n-    bench_in_place_u128_i0_1000,   u128,   1000, 0;\n-    bench_in_place_u128_i1_0010,   u128,     10, 1;\n-    bench_in_place_u128_i1_0100,   u128,    100, 1;\n-    bench_in_place_u128_i1_1000,   u128,   1000, 1\n+    bench_in_place_xxu8_0010_i0,   u8,   10, 0;\n+    bench_in_place_xxu8_0100_i0,   u8,  100, 0;\n+    bench_in_place_xxu8_1000_i0,   u8, 1000, 0;\n+    bench_in_place_xxu8_0010_i1,   u8,   10, 1;\n+    bench_in_place_xxu8_0100_i1,   u8,  100, 1;\n+    bench_in_place_xxu8_1000_i1,   u8, 1000, 1;\n+    bench_in_place_xu32_0010_i0,  u32,   10, 0;\n+    bench_in_place_xu32_0100_i0,  u32,  100, 0;\n+    bench_in_place_xu32_1000_i0,  u32, 1000, 0;\n+    bench_in_place_xu32_0010_i1,  u32,   10, 1;\n+    bench_in_place_xu32_0100_i1,  u32,  100, 1;\n+    bench_in_place_xu32_1000_i1,  u32, 1000, 1;\n+    bench_in_place_u128_0010_i0, u128,   10, 0;\n+    bench_in_place_u128_0100_i0, u128,  100, 0;\n+    bench_in_place_u128_1000_i0, u128, 1000, 0;\n+    bench_in_place_u128_0010_i1, u128,   10, 1;\n+    bench_in_place_u128_0100_i1, u128,  100, 1;\n+    bench_in_place_u128_1000_i1, u128, 1000, 1\n ];\n \n #[bench]"}, {"sha": "8a7dd9d4249a8b66a802cdb2e30db6abee59213e", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -146,7 +146,7 @@\n \n use core::fmt;\n use core::iter::{FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen};\n-use core::mem::{self, size_of, swap, ManuallyDrop};\n+use core::mem::{self, swap, ManuallyDrop};\n use core::ops::{Deref, DerefMut};\n use core::ptr;\n \n@@ -617,7 +617,7 @@ impl<T: Ord> BinaryHeap<T> {\n \n         #[inline(always)]\n         fn log2_fast(x: usize) -> usize {\n-            8 * size_of::<usize>() - (x.leading_zeros() as usize) - 1\n+            (usize::BITS - x.leading_zeros() - 1) as usize\n         }\n \n         // `rebuild` takes O(len1 + len2) operations"}, {"sha": "f3c1eee47c7216ac1d1036e8b4d858326738e2e8", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -101,6 +101,7 @@\n #![feature(fn_traits)]\n #![feature(fundamental)]\n #![feature(inplace_iteration)]\n+#![feature(int_bits_const)]\n #![feature(lang_items)]\n #![feature(layout_for_ptr)]\n #![feature(libc)]"}, {"sha": "62675665f037f39da3c680db2e7338f6fdc83071", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -528,7 +528,7 @@ unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n-    if mem::size_of::<usize>() < 8 && alloc_size > isize::MAX as usize {\n+    if usize::BITS < 64 && alloc_size > isize::MAX as usize {\n         Err(CapacityOverflow)\n     } else {\n         Ok(())"}, {"sha": "d3598ccfce81f341e319dc7ccb61489de0b7c8a8", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -2440,7 +2440,7 @@ pub struct Drain<'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl fmt::Debug for Drain<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.pad(\"Drain { .. }\")\n+        f.debug_tuple(\"Drain\").field(&self.as_str()).finish()\n     }\n }\n \n@@ -2463,6 +2463,40 @@ impl Drop for Drain<'_> {\n     }\n }\n \n+impl<'a> Drain<'a> {\n+    /// Returns the remaining (sub)string of this iterator as a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(string_drain_as_str)]\n+    /// let mut s = String::from(\"abc\");\n+    /// let mut drain = s.drain(..);\n+    /// assert_eq!(drain.as_str(), \"abc\");\n+    /// let _ = drain.next().unwrap();\n+    /// assert_eq!(drain.as_str(), \"bc\");\n+    /// ```\n+    #[unstable(feature = \"string_drain_as_str\", issue = \"76905\")] // Note: uncomment AsRef impls below when stabilizing.\n+    pub fn as_str(&self) -> &str {\n+        self.iter.as_str()\n+    }\n+}\n+\n+// Uncomment when stabilizing `string_drain_as_str`.\n+// #[unstable(feature = \"string_drain_as_str\", issue = \"76905\")]\n+// impl<'a> AsRef<str> for Drain<'a> {\n+//     fn as_ref(&self) -> &str {\n+//         self.as_str()\n+//     }\n+// }\n+//\n+// #[unstable(feature = \"string_drain_as_str\", issue = \"76905\")]\n+// impl<'a> AsRef<[u8]> for Drain<'a> {\n+//     fn as_ref(&self) -> &[u8] {\n+//         self.as_str().as_bytes()\n+//     }\n+// }\n+\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl Iterator for Drain<'_> {\n     type Item = char;"}, {"sha": "8c0b6af54829b4cbfc1a224bbd51b94cfd03fc20", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -55,6 +55,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::cmp::{self, Ordering};\n+use core::convert::TryFrom;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::{arith_offset, assume};\n@@ -2754,6 +2755,57 @@ impl From<&str> for Vec<u8> {\n     }\n }\n \n+#[stable(feature = \"array_try_from_vec\", since = \"1.48.0\")]\n+impl<T, const N: usize> TryFrom<Vec<T>> for [T; N] {\n+    type Error = Vec<T>;\n+\n+    /// Gets the entire contents of the `Vec<T>` as an array,\n+    /// if its size exactly matches that of the requested array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::convert::TryInto;\n+    /// assert_eq!(vec![1, 2, 3].try_into(), Ok([1, 2, 3]));\n+    /// assert_eq!(<Vec<i32>>::new().try_into(), Ok([]));\n+    /// ```\n+    ///\n+    /// If the length doesn't match, the input comes back in `Err`:\n+    /// ```\n+    /// use std::convert::TryInto;\n+    /// let r: Result<[i32; 4], _> = (0..10).collect::<Vec<_>>().try_into();\n+    /// assert_eq!(r, Err(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]));\n+    /// ```\n+    ///\n+    /// If you're fine with just getting a prefix of the `Vec<T>`,\n+    /// you can call [`.truncate(N)`](Vec::truncate) first.\n+    /// ```\n+    /// use std::convert::TryInto;\n+    /// let mut v = String::from(\"hello world\").into_bytes();\n+    /// v.sort();\n+    /// v.truncate(2);\n+    /// let [a, b]: [_; 2] = v.try_into().unwrap();\n+    /// assert_eq!(a, b' ');\n+    /// assert_eq!(b, b'd');\n+    /// ```\n+    fn try_from(mut vec: Vec<T>) -> Result<[T; N], Vec<T>> {\n+        if vec.len() != N {\n+            return Err(vec);\n+        }\n+\n+        // SAFETY: `.set_len(0)` is always sound.\n+        unsafe { vec.set_len(0) };\n+\n+        // SAFETY: A `Vec`'s pointer is always aligned properly, and\n+        // the alignment the array needs is the same as the items.\n+        // We checked earlier that we have sufficient items.\n+        // The items will not double-drop as the `set_len`\n+        // tells the `Vec` not to also drop them.\n+        let array = unsafe { ptr::read(vec.as_ptr() as *const [T; N]) };\n+        Ok(array)\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "3ee0cfbe74759862a6da591141abb1b85a931808", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -18,6 +18,7 @@\n #![feature(deque_range)]\n #![feature(inplace_iteration)]\n #![feature(iter_map_while)]\n+#![feature(int_bits_const)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "a6e41b21b618c8d841d510c73fcba95e24028993", "filename": "library/alloc/tests/string.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstring.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -1,6 +1,5 @@\n use std::borrow::Cow;\n use std::collections::TryReserveError::*;\n-use std::mem::size_of;\n use std::ops::Bound::*;\n \n pub trait IntoCow<'a, B: ?Sized>\n@@ -605,7 +604,7 @@ fn test_try_reserve() {\n     // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n     // Any platform that succeeds for these requests is technically broken with\n     // ptr::offset because LLVM is the worst.\n-    let guards_against_isize = size_of::<usize>() < 8;\n+    let guards_against_isize = usize::BITS < 64;\n \n     {\n         // Note: basic stuff is checked by test_reserve\n@@ -686,7 +685,7 @@ fn test_try_reserve_exact() {\n     const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n-    let guards_against_isize = size_of::<usize>() < 8;\n+    let guards_against_isize = usize::BITS < 64;\n \n     {\n         let mut empty_string: String = String::new();"}, {"sha": "a49ca7c256a75697ff19c6c7aad7738e730a7cfa", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -1341,7 +1341,7 @@ fn test_try_reserve() {\n     // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n     // Any platform that succeeds for these requests is technically broken with\n     // ptr::offset because LLVM is the worst.\n-    let guards_against_isize = size_of::<usize>() < 8;\n+    let guards_against_isize = usize::BITS < 64;\n \n     {\n         // Note: basic stuff is checked by test_reserve"}, {"sha": "8558cb5a5e8a32ebadc1f8c3becb89f78f73f3c5", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -2086,7 +2086,7 @@ impl<T: ?Sized> Pointer for *const T {\n             f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n \n             if f.width.is_none() {\n-                f.width = Some(((mem::size_of::<usize>() * 8) / 4) + 2);\n+                f.width = Some((usize::BITS / 4) as usize + 2);\n             }\n         }\n         f.flags |= 1 << (FlagV1::Alternate as u32);"}, {"sha": "e53682ece1d7f55d47704bc6e638097fc985f07e", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -108,7 +108,8 @@ pub fn spin_loop() {\n /// Note however, that `black_box` is only (and can only be) provided on a \"best-effort\" basis. The\n /// extent to which it can block optimisations may vary depending upon the platform and code-gen\n /// backend used. Programs cannot rely on `black_box` for *correctness* in any way.\n-#[inline]\n+#[cfg_attr(not(miri), inline)]\n+#[cfg_attr(miri, inline(never))]\n #[unstable(feature = \"test\", issue = \"50297\")]\n #[allow(unreachable_code)] // this makes #[cfg] a bit easier below.\n pub fn black_box<T>(mut dummy: T) -> T {"}, {"sha": "6a1a1e1976160077f340cf17664a8a8f4434cf85", "filename": "library/core/src/num/bignum.rs", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -20,7 +20,6 @@\n #![macro_use]\n \n use crate::intrinsics;\n-use crate::mem;\n \n /// Arithmetic operations required by bignums.\n pub trait FullOps: Sized {\n@@ -58,25 +57,22 @@ macro_rules! impl_full_ops {\n                     // This cannot overflow;\n                     // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n                     // FIXME: will LLVM optimize this into ADC or similar?\n-                    let nbits = mem::size_of::<$ty>() * 8;\n                     let v = (self as $bigty) * (other as $bigty) + (carry as $bigty);\n-                    ((v >> nbits) as $ty, v as $ty)\n+                    ((v >> <$ty>::BITS) as $ty, v as $ty)\n                 }\n \n                 fn full_mul_add(self, other: $ty, other2: $ty, carry: $ty) -> ($ty, $ty) {\n                     // This cannot overflow;\n                     // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n-                    let nbits = mem::size_of::<$ty>() * 8;\n                     let v = (self as $bigty) * (other as $bigty) + (other2 as $bigty) +\n                             (carry as $bigty);\n-                    ((v >> nbits) as $ty, v as $ty)\n+                    ((v >> <$ty>::BITS) as $ty, v as $ty)\n                 }\n \n                 fn full_div_rem(self, other: $ty, borrow: $ty) -> ($ty, $ty) {\n                     debug_assert!(borrow < other);\n                     // This cannot overflow; the output is between `0` and `other * (2^nbits - 1)`.\n-                    let nbits = mem::size_of::<$ty>() * 8;\n-                    let lhs = ((borrow as $bigty) << nbits) | (self as $bigty);\n+                    let lhs = ((borrow as $bigty) << <$ty>::BITS) | (self as $bigty);\n                     let rhs = other as $bigty;\n                     ((lhs / rhs) as $ty, (lhs % rhs) as $ty)\n                 }\n@@ -128,13 +124,11 @@ macro_rules! define_bignum {\n \n             /// Makes a bignum from `u64` value.\n             pub fn from_u64(mut v: u64) -> $name {\n-                use crate::mem;\n-\n                 let mut base = [0; $n];\n                 let mut sz = 0;\n                 while v > 0 {\n                     base[sz] = v as $ty;\n-                    v >>= mem::size_of::<$ty>() * 8;\n+                    v >>= <$ty>::BITS;\n                     sz += 1;\n                 }\n                 $name { size: sz, base: base }\n@@ -150,9 +144,7 @@ macro_rules! define_bignum {\n             /// Returns the `i`-th bit where bit 0 is the least significant one.\n             /// In other words, the bit with weight `2^i`.\n             pub fn get_bit(&self, i: usize) -> u8 {\n-                use crate::mem;\n-\n-                let digitbits = mem::size_of::<$ty>() * 8;\n+                let digitbits = <$ty>::BITS as usize;\n                 let d = i / digitbits;\n                 let b = i % digitbits;\n                 ((self.base[d] >> b) & 1) as u8\n@@ -166,8 +158,6 @@ macro_rules! define_bignum {\n             /// Returns the number of bits necessary to represent this value. Note that zero\n             /// is considered to need 0 bits.\n             pub fn bit_length(&self) -> usize {\n-                use crate::mem;\n-\n                 // Skip over the most significant digits which are zero.\n                 let digits = self.digits();\n                 let zeros = digits.iter().rev().take_while(|&&x| x == 0).count();\n@@ -180,7 +170,7 @@ macro_rules! define_bignum {\n                 }\n                 // This could be optimized with leading_zeros() and bit shifts, but that's\n                 // probably not worth the hassle.\n-                let digitbits = mem::size_of::<$ty>() * 8;\n+                let digitbits = <$ty>::BITS as usize;\n                 let mut i = nonzero.len() * digitbits - 1;\n                 while self.get_bit(i) == 0 {\n                     i -= 1;\n@@ -265,9 +255,7 @@ macro_rules! define_bignum {\n \n             /// Multiplies itself by `2^bits` and returns its own mutable reference.\n             pub fn mul_pow2(&mut self, bits: usize) -> &mut $name {\n-                use crate::mem;\n-\n-                let digitbits = mem::size_of::<$ty>() * 8;\n+                let digitbits = <$ty>::BITS as usize;\n                 let digits = bits / digitbits;\n                 let bits = bits % digitbits;\n \n@@ -393,13 +381,11 @@ macro_rules! define_bignum {\n             /// Divide self by another bignum, overwriting `q` with the quotient and `r` with the\n             /// remainder.\n             pub fn div_rem(&self, d: &$name, q: &mut $name, r: &mut $name) {\n-                use crate::mem;\n-\n                 // Stupid slow base-2 long division taken from\n                 // https://en.wikipedia.org/wiki/Division_algorithm\n                 // FIXME use a greater base ($ty) for the long division.\n                 assert!(!d.is_zero());\n-                let digitbits = mem::size_of::<$ty>() * 8;\n+                let digitbits = <$ty>::BITS as usize;\n                 for digit in &mut q.base[..] {\n                     *digit = 0;\n                 }\n@@ -462,10 +448,8 @@ macro_rules! define_bignum {\n \n         impl crate::fmt::Debug for $name {\n             fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n-                use crate::mem;\n-\n                 let sz = if self.size < 1 { 1 } else { self.size };\n-                let digitlen = mem::size_of::<$ty>() * 2;\n+                let digitlen = <$ty>::BITS as usize / 4;\n \n                 write!(f, \"{:#x}\", self.base[sz - 1])?;\n                 for &v in self.base[..sz - 1].iter().rev() {"}, {"sha": "eec149cc3e8014276661f328046d3b9c1e6b1bf7", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -348,6 +348,20 @@ $EndFeature, \"\n             pub const MAX: Self = !Self::MIN;\n         }\n \n+        doc_comment! {\n+            concat!(\"The size of this integer type in bits.\n+\n+# Examples\n+\n+```\n+\", $Feature, \"#![feature(int_bits_const)]\n+assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"int_bits_const\", issue = \"76904\")]\n+            pub const BITS: u32 = $BITS;\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts a string slice in a given base to an integer.\n \n@@ -2601,6 +2615,20 @@ $EndFeature, \"\n             pub const MAX: Self = !0;\n         }\n \n+        doc_comment! {\n+            concat!(\"The size of this integer type in bits.\n+\n+# Examples\n+\n+```\n+\", $Feature, \"#![feature(int_bits_const)]\n+assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"int_bits_const\", issue = \"76904\")]\n+            pub const BITS: u32 = $BITS;\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts a string slice in a given base to an integer.\n "}, {"sha": "71d2c2c9b2f4c2f3be43c3f9754ceec87f56c8dc", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -565,7 +565,7 @@ fn break_patterns<T>(v: &mut [T]) {\n             random\n         };\n         let mut gen_usize = || {\n-            if mem::size_of::<usize>() <= 4 {\n+            if usize::BITS <= 32 {\n                 gen_u32() as usize\n             } else {\n                 (((gen_u32() as u64) << 32) | (gen_u32() as u64)) as usize\n@@ -667,7 +667,7 @@ where\n ///\n /// `limit` is the number of allowed imbalanced partitions before switching to `heapsort`. If zero,\n /// this function will immediately switch to heapsort.\n-fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: usize)\n+fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: u32)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n@@ -763,7 +763,7 @@ where\n     }\n \n     // Limit the number of imbalanced partitions to `floor(log2(len)) + 1`.\n-    let limit = mem::size_of::<usize>() * 8 - v.len().leading_zeros() as usize;\n+    let limit = usize::BITS - v.len().leading_zeros();\n \n     recurse(v, &mut is_less, None, limit);\n }"}, {"sha": "0eb9af3f454e986adb2eb73e2161a447eab939f8", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -474,7 +474,7 @@ fn test_iterator_step_by_nth_overflow() {\n     }\n \n     let mut it = Test(0);\n-    let root = usize::MAX >> (::std::mem::size_of::<usize>() * 8 / 2);\n+    let root = usize::MAX >> (usize::BITS / 2);\n     let n = root + 20;\n     (&mut it).step_by(n).nth(n);\n     assert_eq!(it.0, n as Bigger * n as Bigger);"}, {"sha": "4db391f3e567eb69c962c40b7c53264320c5057e", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -52,6 +52,7 @@\n #![feature(partition_point)]\n #![feature(once_cell)]\n #![feature(unsafe_block_in_unsafe_fn)]\n+#![feature(int_bits_const)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}, {"sha": "27e6760e7cbb9175e667dc50941b4828dec8ec0f", "filename": "library/core/tests/num/int_macros.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -2,7 +2,6 @@ macro_rules! int_module {\n     ($T:ident, $T_i:ident) => {\n         #[cfg(test)]\n         mod tests {\n-            use core::mem;\n             use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n             use core::$T_i::*;\n \n@@ -82,30 +81,27 @@ macro_rules! int_module {\n \n             #[test]\n             fn test_count_zeros() {\n-                let bits = mem::size_of::<$T>() * 8;\n-                assert_eq!(A.count_zeros(), bits as u32 - 3);\n-                assert_eq!(B.count_zeros(), bits as u32 - 2);\n-                assert_eq!(C.count_zeros(), bits as u32 - 5);\n+                assert_eq!(A.count_zeros(), $T::BITS - 3);\n+                assert_eq!(B.count_zeros(), $T::BITS - 2);\n+                assert_eq!(C.count_zeros(), $T::BITS - 5);\n             }\n \n             #[test]\n             fn test_leading_trailing_ones() {\n-                let bits = (mem::size_of::<$T>() * 8) as u32;\n-\n                 let a: $T = 0b0101_1111;\n                 assert_eq!(a.trailing_ones(), 5);\n-                assert_eq!((!a).leading_ones(), bits - 7);\n+                assert_eq!((!a).leading_ones(), $T::BITS - 7);\n \n                 assert_eq!(a.reverse_bits().leading_ones(), 5);\n \n-                assert_eq!(_1.leading_ones(), bits);\n-                assert_eq!(_1.trailing_ones(), bits);\n+                assert_eq!(_1.leading_ones(), $T::BITS);\n+                assert_eq!(_1.trailing_ones(), $T::BITS);\n \n                 assert_eq!((_1 << 1).trailing_ones(), 0);\n                 assert_eq!(MAX.leading_ones(), 0);\n \n-                assert_eq!((_1 << 1).leading_ones(), bits - 1);\n-                assert_eq!(MAX.trailing_ones(), bits - 1);\n+                assert_eq!((_1 << 1).leading_ones(), $T::BITS - 1);\n+                assert_eq!(MAX.trailing_ones(), $T::BITS - 1);\n \n                 assert_eq!(_0.leading_ones(), 0);\n                 assert_eq!(_0.trailing_ones(), 0);"}, {"sha": "952ec188dc1385f9911e4665c237db2935feb2f4", "filename": "library/core/tests/num/uint_macros.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -4,7 +4,6 @@ macro_rules! uint_module {\n         mod tests {\n             use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n             use core::$T_i::*;\n-            use std::mem;\n             use std::str::FromStr;\n \n             use crate::num;\n@@ -47,30 +46,27 @@ macro_rules! uint_module {\n \n             #[test]\n             fn test_count_zeros() {\n-                let bits = mem::size_of::<$T>() * 8;\n-                assert!(A.count_zeros() == bits as u32 - 3);\n-                assert!(B.count_zeros() == bits as u32 - 2);\n-                assert!(C.count_zeros() == bits as u32 - 5);\n+                assert!(A.count_zeros() == $T::BITS - 3);\n+                assert!(B.count_zeros() == $T::BITS - 2);\n+                assert!(C.count_zeros() == $T::BITS - 5);\n             }\n \n             #[test]\n             fn test_leading_trailing_ones() {\n-                let bits = (mem::size_of::<$T>() * 8) as u32;\n-\n                 let a: $T = 0b0101_1111;\n                 assert_eq!(a.trailing_ones(), 5);\n-                assert_eq!((!a).leading_ones(), bits - 7);\n+                assert_eq!((!a).leading_ones(), $T::BITS - 7);\n \n                 assert_eq!(a.reverse_bits().leading_ones(), 5);\n \n-                assert_eq!(_1.leading_ones(), bits);\n-                assert_eq!(_1.trailing_ones(), bits);\n+                assert_eq!(_1.leading_ones(), $T::BITS);\n+                assert_eq!(_1.trailing_ones(), $T::BITS);\n \n                 assert_eq!((_1 << 1).trailing_ones(), 0);\n                 assert_eq!((_1 >> 1).leading_ones(), 0);\n \n-                assert_eq!((_1 << 1).leading_ones(), bits - 1);\n-                assert_eq!((_1 >> 1).trailing_ones(), bits - 1);\n+                assert_eq!((_1 << 1).leading_ones(), $T::BITS - 1);\n+                assert_eq!((_1 >> 1).trailing_ones(), $T::BITS - 1);\n \n                 assert_eq!(_0.leading_ones(), 0);\n                 assert_eq!(_0.trailing_ones(), 0);"}, {"sha": "652fbe95a14d195f39281a727d056b5f78aede60", "filename": "library/panic_unwind/src/dwarf/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Fmod.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -53,7 +53,7 @@ impl DwarfReader {\n     }\n \n     pub unsafe fn read_sleb128(&mut self) -> i64 {\n-        let mut shift: usize = 0;\n+        let mut shift: u32 = 0;\n         let mut result: u64 = 0;\n         let mut byte: u8;\n         loop {\n@@ -65,7 +65,7 @@ impl DwarfReader {\n             }\n         }\n         // sign-extend\n-        if shift < 8 * mem::size_of::<u64>() && (byte & 0x40) != 0 {\n+        if shift < u64::BITS && (byte & 0x40) != 0 {\n             result |= (!0 as u64) << shift;\n         }\n         result as i64"}, {"sha": "1cfd527b5841aed3339bcc2534ca0663586ed5cc", "filename": "library/panic_unwind/src/gcc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -120,7 +120,7 @@ const UNWIND_DATA_REG: (i32, i32) = (24, 25); // I0, I1\n #[cfg(target_arch = \"hexagon\")]\n const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1\n \n-#[cfg(target_arch = \"riscv64\")]\n+#[cfg(any(target_arch = \"riscv64\", target_arch = \"riscv32\"))]\n const UNWIND_DATA_REG: (i32, i32) = (10, 11); // x10, x11\n \n // The following code is based on GCC's C and C++ personality routines.  For reference, see:"}, {"sha": "162f0386b6692c757e845c91f55e70babad28995", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -18,6 +18,7 @@\n     issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\"\n )]\n #![feature(core_intrinsics)]\n+#![feature(int_bits_const)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(nll)]"}, {"sha": "4ff3a6e578984cc0bb36da0d4f6e7b3c36648200", "filename": "library/std/src/os/linux/raw.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -234,7 +234,8 @@ mod arch {\n     target_arch = \"mips64\",\n     target_arch = \"s390x\",\n     target_arch = \"sparc64\",\n-    target_arch = \"riscv64\"\n+    target_arch = \"riscv64\",\n+    target_arch = \"riscv32\"\n ))]\n mod arch {\n     pub use libc::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};"}, {"sha": "16272aa05712f7bab6a717e74ea078d24f9061b3", "filename": "library/std/src/os/raw/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -22,7 +22,8 @@ mod tests;\n             target_arch = \"powerpc\",\n             target_arch = \"powerpc64\",\n             target_arch = \"s390x\",\n-            target_arch = \"riscv64\"\n+            target_arch = \"riscv64\",\n+            target_arch = \"riscv32\"\n         )\n     ),\n     all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n@@ -65,7 +66,8 @@ pub type c_char = u8;\n             target_arch = \"powerpc\",\n             target_arch = \"powerpc64\",\n             target_arch = \"s390x\",\n-            target_arch = \"riscv64\"\n+            target_arch = \"riscv64\",\n+            target_arch = \"riscv32\"\n         )\n     ),\n     all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),"}, {"sha": "b83c1e9628dc646f482366862ebbc4a4ebe86f4e", "filename": "library/std/src/path.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -58,6 +58,7 @@\n //! [`push`]: PathBuf::push\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n #[cfg(test)]\n mod tests;\n@@ -294,7 +295,8 @@ fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n     unsafe { &*(s as *const OsStr as *const [u8]) }\n }\n unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n-    &*(s as *const [u8] as *const OsStr)\n+    // SAFETY: see the comment of `os_str_as_u8_slice`\n+    unsafe { &*(s as *const [u8] as *const OsStr) }\n }\n \n // Detect scheme on Redox\n@@ -314,24 +316,21 @@ fn has_physical_root(s: &[u8], prefix: Option<Prefix<'_>>) -> bool {\n \n // basic workhorse for splitting stem and extension\n fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n-    unsafe {\n-        if os_str_as_u8_slice(file) == b\"..\" {\n-            return (Some(file), None);\n-        }\n-\n-        // The unsafety here stems from converting between &OsStr and &[u8]\n-        // and back. This is safe to do because (1) we only look at ASCII\n-        // contents of the encoding and (2) new &OsStr values are produced\n-        // only from ASCII-bounded slices of existing &OsStr values.\n+    if os_str_as_u8_slice(file) == b\"..\" {\n+        return (Some(file), None);\n+    }\n \n-        let mut iter = os_str_as_u8_slice(file).rsplitn(2, |b| *b == b'.');\n-        let after = iter.next();\n-        let before = iter.next();\n-        if before == Some(b\"\") {\n-            (Some(file), None)\n-        } else {\n-            (before.map(|s| u8_slice_as_os_str(s)), after.map(|s| u8_slice_as_os_str(s)))\n-        }\n+    // The unsafety here stems from converting between &OsStr and &[u8]\n+    // and back. This is safe to do because (1) we only look at ASCII\n+    // contents of the encoding and (2) new &OsStr values are produced\n+    // only from ASCII-bounded slices of existing &OsStr values.\n+    let mut iter = os_str_as_u8_slice(file).rsplitn(2, |b| *b == b'.');\n+    let after = iter.next();\n+    let before = iter.next();\n+    if before == Some(b\"\") {\n+        (Some(file), None)\n+    } else {\n+        unsafe { (before.map(|s| u8_slice_as_os_str(s)), after.map(|s| u8_slice_as_os_str(s))) }\n     }\n }\n \n@@ -1702,7 +1701,7 @@ impl Path {\n     // The following (private!) function allows construction of a path from a u8\n     // slice, which is only safe when it is known to follow the OsStr encoding.\n     unsafe fn from_u8_slice(s: &[u8]) -> &Path {\n-        Path::new(u8_slice_as_os_str(s))\n+        unsafe { Path::new(u8_slice_as_os_str(s)) }\n     }\n     // The following (private!) function reveals the byte encoding used for OsStr.\n     fn as_u8_slice(&self) -> &[u8] {"}, {"sha": "f22476be325603039fcecd71728d7569acd545dc", "filename": "library/std/src/sys_common/alloc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fstd%2Fsrc%2Fsys_common%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Fstd%2Fsrc%2Fsys_common%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Falloc.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -14,7 +14,8 @@ use crate::ptr;\n     target_arch = \"powerpc64\",\n     target_arch = \"asmjs\",\n     target_arch = \"wasm32\",\n-    target_arch = \"hexagon\"\n+    target_arch = \"hexagon\",\n+    target_arch = \"riscv32\"\n )))]\n pub const MIN_ALIGN: usize = 8;\n #[cfg(all(any("}, {"sha": "dcf4fcd4e5aabeb6105b66c2d10c6ab8b35ec8b9", "filename": "library/unwind/src/libunwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Funwind%2Fsrc%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/library%2Funwind%2Fsrc%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flibunwind.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -54,7 +54,7 @@ pub const unwinder_private_data_size: usize = 2;\n #[cfg(target_arch = \"sparc64\")]\n pub const unwinder_private_data_size: usize = 2;\n \n-#[cfg(target_arch = \"riscv64\")]\n+#[cfg(any(target_arch = \"riscv64\", target_arch = \"riscv32\"))]\n pub const unwinder_private_data_size: usize = 2;\n \n #[cfg(target_os = \"emscripten\")]"}, {"sha": "6de4388495bafd29e9f5cc7c268d292d3d7c3fcd", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -617,7 +617,13 @@ impl Config {\n                 | Subcommand::Build { .. }\n                 | Subcommand::Bench { .. }\n                 | Subcommand::Dist { .. }\n-                | Subcommand::Install { .. } => assert_eq!(config.stage, 2),\n+                | Subcommand::Install { .. } => {\n+                    assert_eq!(\n+                        config.stage, 2,\n+                        \"x.py should be run with `--stage 2` on CI, but was run with `--stage {}`\",\n+                        config.stage,\n+                    );\n+                }\n                 Subcommand::Clean { .. }\n                 | Subcommand::Check { .. }\n                 | Subcommand::Clippy { .. }"}, {"sha": "44d6bc619d3bbfa09b207b3d1be395418d054ef5", "filename": "src/test/mir-opt/issues/issue-75439.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fmir-opt%2Fissues%2Fissue-75439.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fmir-opt%2Fissues%2Fissue-75439.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissues%2Fissue-75439.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -0,0 +1,21 @@\n+// EMIT_MIR issue_75439.foo.MatchBranchSimplification.diff\n+\n+#![feature(const_fn_transmute)]\n+#![feature(or_patterns)]\n+\n+use std::mem::transmute;\n+\n+pub fn foo(bytes: [u8; 16]) -> Option<[u8; 4]> {\n+    // big endian `u32`s\n+    let dwords: [u32; 4] = unsafe { transmute(bytes) };\n+    const FF: u32 = 0x0000_ffff_u32.to_be();\n+    if let [0, 0, 0 | FF, ip] = dwords {\n+        Some(unsafe { transmute(ip) })\n+    } else {\n+        None\n+    }\n+}\n+\n+fn main() {\n+  let _ = foo([0; 16]);\n+}"}, {"sha": "43422b36e1e5283894f3f923a390167d31158560", "filename": "src/test/mir-opt/issues/issue_75439.foo.MatchBranchSimplification.diff", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -0,0 +1,87 @@\n+- // MIR for `foo` before MatchBranchSimplification\n++ // MIR for `foo` after MatchBranchSimplification\n+  \n+  fn foo(_1: [u8; 16]) -> Option<[u8; 4]> {\n+      debug bytes => _1;                   // in scope 0 at $DIR/issue-75439.rs:8:12: 8:17\n+      let mut _0: std::option::Option<[u8; 4]>; // return place in scope 0 at $DIR/issue-75439.rs:8:32: 8:47\n+      let _2: [u32; 4];                    // in scope 0 at $DIR/issue-75439.rs:10:9: 10:15\n+      let mut _3: [u8; 16];                // in scope 0 at $DIR/issue-75439.rs:10:47: 10:52\n+      let mut _5: [u8; 4];                 // in scope 0 at $DIR/issue-75439.rs:13:14: 13:38\n+      let mut _6: u32;                     // in scope 0 at $DIR/issue-75439.rs:13:33: 13:35\n+      scope 1 {\n+          debug dwords => _2;              // in scope 1 at $DIR/issue-75439.rs:10:9: 10:15\n+          let _4: u32;                     // in scope 1 at $DIR/issue-75439.rs:12:27: 12:29\n+          scope 3 {\n+              debug ip => _4;              // in scope 3 at $DIR/issue-75439.rs:12:27: 12:29\n+              scope 4 {\n+              }\n+          }\n+      }\n+      scope 2 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/issue-75439.rs:10:9: 10:15\n+          StorageLive(_3);                 // scope 2 at $DIR/issue-75439.rs:10:47: 10:52\n+          _3 = _1;                         // scope 2 at $DIR/issue-75439.rs:10:47: 10:52\n+          _2 = transmute::<[u8; 16], [u32; 4]>(move _3) -> bb1; // scope 2 at $DIR/issue-75439.rs:10:37: 10:53\n+                                           // mir::Constant\n+                                           // + span: $DIR/issue-75439.rs:10:37: 10:46\n+                                           // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn([u8; 16]) -> [u32; 4] {std::intrinsics::transmute::<[u8; 16], [u32; 4]>}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_3);                 // scope 2 at $DIR/issue-75439.rs:10:52: 10:53\n+          switchInt(_2[0 of 4]) -> [0_u32: bb2, otherwise: bb4]; // scope 1 at $DIR/issue-75439.rs:12:13: 12:14\n+      }\n+  \n+      bb2: {\n+          switchInt(_2[1 of 4]) -> [0_u32: bb3, otherwise: bb4]; // scope 1 at $DIR/issue-75439.rs:12:16: 12:17\n+      }\n+  \n+      bb3: {\n+          switchInt(_2[2 of 4]) -> [0_u32: bb6, 4294901760_u32: bb7, otherwise: bb4]; // scope 1 at $DIR/issue-75439.rs:12:19: 12:20\n+      }\n+  \n+      bb4: {\n+          discriminant(_0) = 0;            // scope 1 at $DIR/issue-75439.rs:15:9: 15:13\n+          goto -> bb9;                     // scope 1 at $DIR/issue-75439.rs:12:5: 16:6\n+      }\n+  \n+      bb5: {\n+          StorageLive(_5);                 // scope 3 at $DIR/issue-75439.rs:13:14: 13:38\n+          StorageLive(_6);                 // scope 4 at $DIR/issue-75439.rs:13:33: 13:35\n+          _6 = _4;                         // scope 4 at $DIR/issue-75439.rs:13:33: 13:35\n+          _5 = transmute::<u32, [u8; 4]>(move _6) -> bb8; // scope 4 at $DIR/issue-75439.rs:13:23: 13:36\n+                                           // mir::Constant\n+                                           // + span: $DIR/issue-75439.rs:13:23: 13:32\n+                                           // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) -> [u8; 4] {std::intrinsics::transmute::<u32, [u8; 4]>}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb6: {\n+          StorageLive(_4);                 // scope 1 at $DIR/issue-75439.rs:12:27: 12:29\n+          _4 = _2[3 of 4];                 // scope 1 at $DIR/issue-75439.rs:12:27: 12:29\n+          goto -> bb5;                     // scope 1 at $DIR/issue-75439.rs:12:5: 16:6\n+      }\n+  \n+      bb7: {\n+          StorageLive(_4);                 // scope 1 at $DIR/issue-75439.rs:12:27: 12:29\n+          _4 = _2[3 of 4];                 // scope 1 at $DIR/issue-75439.rs:12:27: 12:29\n+          goto -> bb5;                     // scope 1 at $DIR/issue-75439.rs:12:5: 16:6\n+      }\n+  \n+      bb8: {\n+          StorageDead(_6);                 // scope 4 at $DIR/issue-75439.rs:13:35: 13:36\n+          ((_0 as Some).0: [u8; 4]) = move _5; // scope 3 at $DIR/issue-75439.rs:13:9: 13:39\n+          discriminant(_0) = 1;            // scope 3 at $DIR/issue-75439.rs:13:9: 13:39\n+          StorageDead(_5);                 // scope 3 at $DIR/issue-75439.rs:13:38: 13:39\n+          StorageDead(_4);                 // scope 1 at $DIR/issue-75439.rs:14:5: 14:6\n+          goto -> bb9;                     // scope 1 at $DIR/issue-75439.rs:12:5: 16:6\n+      }\n+  \n+      bb9: {\n+          StorageDead(_2);                 // scope 0 at $DIR/issue-75439.rs:17:1: 17:2\n+          return;                          // scope 0 at $DIR/issue-75439.rs:17:2: 17:2\n+      }\n+  }\n+  "}, {"sha": "9c02d232e134b1a9ea5afeff0fd2f526b5f32c36", "filename": "src/test/ui/consts/cast-discriminant-zst-enum.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fui%2Fconsts%2Fcast-discriminant-zst-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fui%2Fconsts%2Fcast-discriminant-zst-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcast-discriminant-zst-enum.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -1,5 +1,7 @@\n // run-pass\n // Test a ZST enum whose dicriminant is ~0i128. This caused an ICE when casting to a i32.\n+#![feature(test)]\n+use std::hint::black_box;\n \n #[derive(Copy, Clone)]\n enum Nums {\n@@ -12,9 +14,6 @@ const NEG_ONE_I32: i32 = Nums::NegOne as i32;\n const NEG_ONE_I64: i64 = Nums::NegOne as i64;\n const NEG_ONE_I128: i128 = Nums::NegOne as i128;\n \n-#[inline(never)]\n-fn identity<T>(t: T) -> T { t }\n-\n fn test_as_arg(n: Nums) {\n     assert_eq!(-1i8, n as i8);\n     assert_eq!(-1i16, n as i16);\n@@ -31,11 +30,11 @@ fn main() {\n     assert_eq!(-1i64, kind as i64);\n     assert_eq!(-1i128, kind as i128);\n \n-    assert_eq!(-1i8, identity(kind) as i8);\n-    assert_eq!(-1i16, identity(kind) as i16);\n-    assert_eq!(-1i32, identity(kind) as i32);\n-    assert_eq!(-1i64, identity(kind) as i64);\n-    assert_eq!(-1i128, identity(kind) as i128);\n+    assert_eq!(-1i8, black_box(kind) as i8);\n+    assert_eq!(-1i16, black_box(kind) as i16);\n+    assert_eq!(-1i32, black_box(kind) as i32);\n+    assert_eq!(-1i64, black_box(kind) as i64);\n+    assert_eq!(-1i128, black_box(kind) as i128);\n \n     test_as_arg(Nums::NegOne);\n "}, {"sha": "d016d236dbf81a5e24127f33099d13585c1078cf", "filename": "src/test/ui/consts/const_discriminant.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fui%2Fconsts%2Fconst_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fui%2Fconsts%2Fconst_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_discriminant.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -1,14 +1,10 @@\n // run-pass\n #![feature(const_discriminant)]\n+#![feature(test)]\n #![allow(dead_code)]\n \n use std::mem::{discriminant, Discriminant};\n-\n-// `discriminant(const_expr)` may get const-propagated.\n-// As we want to check that const-eval is equal to ordinary exection,\n-// we wrap `const_expr` with a function which is not const to prevent this.\n-#[inline(never)]\n-fn identity<T>(x: T) -> T { x }\n+use std::hint::black_box;\n \n enum Test {\n     A(u8),\n@@ -31,10 +27,10 @@ const TEST_V: Discriminant<SingleVariant> = discriminant(&SingleVariant::V);\n \n fn main() {\n     assert_eq!(TEST_A, TEST_A_OTHER);\n-    assert_eq!(TEST_A, discriminant(identity(&Test::A(17))));\n-    assert_eq!(TEST_B, discriminant(identity(&Test::B)));\n+    assert_eq!(TEST_A, discriminant(black_box(&Test::A(17))));\n+    assert_eq!(TEST_B, discriminant(black_box(&Test::B)));\n     assert_ne!(TEST_A, TEST_B);\n-    assert_ne!(TEST_B, discriminant(identity(&Test::C { a: 42, b: 7 })));\n+    assert_ne!(TEST_B, discriminant(black_box(&Test::C { a: 42, b: 7 })));\n \n-    assert_eq!(TEST_V, discriminant(identity(&SingleVariant::V)));\n+    assert_eq!(TEST_V, discriminant(black_box(&SingleVariant::V)));\n }"}, {"sha": "d9790d2b56e2895fed4a1ec169ed63fd8bfa07f1", "filename": "src/test/ui/issues/issue-76191.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fui%2Fissues%2Fissue-76191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fui%2Fissues%2Fissue-76191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-76191.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -2,13 +2,18 @@\n #![allow(non_snake_case)]\n \n use std::ops::RangeInclusive;\n+\n const RANGE: RangeInclusive<i32> = 0..=255;\n \n+const RANGE2: RangeInclusive<i32> = panic!();\n+\n fn main() {\n     let n: i32 = 1;\n     match n {\n         RANGE => {}\n         //~^ ERROR mismatched types\n+        RANGE2 => {}\n+        //~^ ERROR mismatched types\n         _ => {}\n     }\n }"}, {"sha": "bdcd2fe1adc5a727636cea40fc055b4a0687ad3d", "filename": "src/test/ui/issues/issue-76191.stderr", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fui%2Fissues%2Fissue-76191.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftest%2Fui%2Fissues%2Fissue-76191.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-76191.stderr?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-76191.rs:10:9\n+  --> $DIR/issue-76191.rs:13:9\n    |\n LL | const RANGE: RangeInclusive<i32> = 0..=255;\n    | ------------------------------------------- constant defined here\n@@ -14,8 +14,30 @@ LL |         RANGE => {}\n    |\n    = note: expected type `i32`\n             found struct `RangeInclusive<i32>`\n+help: you may want to move the range into the match block\n+   |\n+LL |         0..=255 => {}\n+   |         ^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-76191.rs:15:9\n+   |\n+LL | const RANGE2: RangeInclusive<i32> = panic!();\n+   | --------------------------------------------- constant defined here\n+...\n+LL |     match n {\n+   |           - this expression has type `i32`\n+...\n+LL |         RANGE2 => {}\n+   |         ^^^^^^\n+   |         |\n+   |         expected `i32`, found struct `RangeInclusive`\n+   |         `RANGE2` is interpreted as a constant, not a new binding\n+   |\n+   = note: expected type `i32`\n+            found struct `RangeInclusive<i32>`\n    = note: constants only support matching by type, if you meant to match against a range of values, consider using a range pattern like `min ..= max` in the match block\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "125f2d1f76cce75649fd990d02bf3d24a38d3e75", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9d5db8392c44a2e94008168fa3506ecddaa357/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=8e9d5db8392c44a2e94008168fa3506ecddaa357", "patch": "@@ -111,6 +111,7 @@ static TARGETS: &[&str] = &[\n     \"riscv32i-unknown-none-elf\",\n     \"riscv32imc-unknown-none-elf\",\n     \"riscv32imac-unknown-none-elf\",\n+    \"riscv32gc-unknown-linux-gnu\",\n     \"riscv64imac-unknown-none-elf\",\n     \"riscv64gc-unknown-none-elf\",\n     \"riscv64gc-unknown-linux-gnu\","}]}