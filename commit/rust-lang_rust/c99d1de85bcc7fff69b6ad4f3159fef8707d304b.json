{"sha": "c99d1de85bcc7fff69b6ad4f3159fef8707d304b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5OWQxZGU4NWJjYzdmZmY2OWI2YWQ0ZjMxNTlmZWY4NzA3ZDMwNGI=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-05-16T00:35:43Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-05-17T00:59:06Z"}, "message": "Update to modern rust", "tree": {"sha": "de0baa9dc42463bba48a046f78c33912dc2e08cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de0baa9dc42463bba48a046f78c33912dc2e08cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c99d1de85bcc7fff69b6ad4f3159fef8707d304b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c99d1de85bcc7fff69b6ad4f3159fef8707d304b", "html_url": "https://github.com/rust-lang/rust/commit/c99d1de85bcc7fff69b6ad4f3159fef8707d304b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c99d1de85bcc7fff69b6ad4f3159fef8707d304b/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5948d8a8260e0c3da4f58f7bd1081add1fd63e58", "url": "https://api.github.com/repos/rust-lang/rust/commits/5948d8a8260e0c3da4f58f7bd1081add1fd63e58", "html_url": "https://github.com/rust-lang/rust/commit/5948d8a8260e0c3da4f58f7bd1081add1fd63e58"}], "stats": {"total": 50, "additions": 21, "deletions": 29}, "files": [{"sha": "4ad8ff05191526b17fd228ae2f2f8a1b99b57b87", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c99d1de85bcc7fff69b6ad4f3159fef8707d304b/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c99d1de85bcc7fff69b6ad4f3159fef8707d304b/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=c99d1de85bcc7fff69b6ad4f3159fef8707d304b", "patch": "@@ -1479,7 +1479,7 @@ pub fn reverse_part<T>(v: &mut [T], start: uint, end : uint) {\n     let mut i = start;\n     let mut j = end - 1;\n     while i < j {\n-        v[i] <-> v[j];\n+        vec::swap(v, i, j);\n         i += 1;\n         j -= 1;\n     }\n@@ -1790,7 +1790,6 @@ pub fn each2_mut<U, T>(v1: &mut [U], v2: &mut [T], f: &fn(u: &mut U, t: &mut T)\n  *\n  *  * `fun` - The function to iterate over the combinations\n  */\n-#[cfg(not(stage0))]\n pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) {\n     let length = values.len();\n     let mut permutation = vec::from_fn(length, |i| values[i]);\n@@ -1816,16 +1815,13 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) {\n         }\n         // swap indices[k] and indices[l]; sort indices[k+1..]\n         // (they're just reversed)\n-        indices[k] <-> indices[l];\n-        unsafe {\n-            reverse_part(indices, k+1, length);\n-        }\n+        vec::swap(indices, k, l);\n+        reverse_part(indices, k+1, length);\n         // fixup permutation based on indices\n         for uint::range(k, length) |i| {\n             permutation[i] = values[indices[i]];\n         }\n     }\n-    return true;\n }\n \n /**\n@@ -1844,7 +1840,7 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) {\n  * * `fun` - The function to iterate over the permutations\n  */\n #[cfg(not(stage0))]\n-pub fn each_permutation_ref<T>(values : &'v[T], fun : &fn(perm : &[&'v T]) -> bool) {\n+pub fn each_permutation_ref<T>(values : &[T], fun : &fn(perm : &[&T]) -> bool) {\n     each_permutation(vec::from_fn(values.len(), |i| &values[i]), fun);\n }\n \n@@ -4814,95 +4810,91 @@ mod tests {\n         }\n     }\n \n-    fn dup<T:Copy>(values : &[&T]) -> ~[T] {\n-        from_fn(values.len(), |i| *values[i])\n-    }\n-\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1,2,3,4,5];\n         reverse_part(values,1,4);\n-        assert values == [1,4,3,2,5];\n+        assert_eq!(values, [1,4,3,2,5]);\n     }\n \n     #[test]\n     fn test_permutations0() {\n         let values = [];\n         let mut v : ~[~[int]] = ~[];\n         for each_permutation(values) |p| {\n-            v.push(vec::from_slice(p));\n+            v.push(p.to_owned());\n         }\n-        assert v == ~[~[]];\n+        assert_eq!(v, ~[~[]]);\n     }\n \n     #[test]\n     fn test_permutations0_ref() {\n         let values = [];\n         let mut v : ~[~[int]] = ~[];\n         for each_permutation_ref(values) |p| {\n-            v.push(dup(p));\n+            v.push(p.to_owned());\n         }\n-        assert v == ~[~[]];\n+        assert_eq!(v, ~[~[]]);\n     }\n \n     #[test]\n     fn test_permutations1() {\n         let values = [1];\n         let mut v : ~[~[int]] = ~[];\n         for each_permutation(values) |p| {\n-            v.push(vec::from_slice(p));\n+            v.push(p.to_owned());\n         }\n-        assert v == ~[~[1]];\n+        assert_eq!(v, ~[~[1]]);\n     }\n \n     #[test]\n     fn test_permutations1_ref() {\n         let values = [1];\n         let mut v : ~[~[int]] = ~[];\n         for each_permutation_ref(values) |p| {\n-            v.push(dup(p));\n+            v.push(p.to_owned());\n         }\n-        assert v == ~[~[1]];\n+        assert_eq!(v, ~[~[1]]);\n     }\n \n     #[test]\n     fn test_permutations2() {\n         let values = [1,2];\n         let mut v : ~[~[int]] = ~[];\n         for each_permutation(values) |p| {\n-            v.push(vec::from_slice(p));\n+            v.push(p.to_owned());\n         }\n-        assert v == ~[~[1,2],~[2,1]];\n+        assert_eq!(v, ~[~[1,2],~[2,1]]);\n     }\n \n     #[test]\n     fn test_permutations2_ref() {\n         let values = [1,2];\n         let mut v : ~[~[int]] = ~[];\n         for each_permutation_ref(values) |p| {\n-            v.push(dup(p));\n+            v.push(p.to_owned());\n         }\n-        assert v == ~[~[1,2],~[2,1]];\n+        assert_eq!(v, ~[~[1,2],~[2,1]]);\n     }\n \n     #[test]\n     fn test_permutations3() {\n         let values = [1,2,3];\n         let mut v : ~[~[int]] = ~[];\n         for each_permutation(values) |p| {\n-            v.push(vec::from_slice(p));\n+            v.push(p.to_owned());\n         }\n-        assert v == ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]];\n+        assert_eq!(v, ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]]);\n     }\n \n     #[test]\n     fn test_permutations3_ref() {\n         let values = [1,2,3];\n         let mut v : ~[~[int]] = ~[];\n         for each_permutation_ref(values) |p| {\n-            v.push(dup(p));\n+            v.push(p.to_owned());\n         }\n-        assert v == ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]];\n+        assert_eq!(v, ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]]);\n     }\n \n     #[test]"}]}