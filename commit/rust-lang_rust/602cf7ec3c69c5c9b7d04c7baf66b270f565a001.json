{"sha": "602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMmNmN2VjM2M2OWM1YzliN2QwNGM3YmFmNjZiMjcwZjU2NWEwMDE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-09T00:16:19Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-13T20:47:02Z"}, "message": "MIR: implement fat raw pointer comparisons\n\nThe implementation itself only requires changes to trans, but\na few additional bugs concerning the handling of fat pointers\nhad to be fixed.", "tree": {"sha": "39b2a2dd227538efd633aa3d1454a9b0dd1bbe5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39b2a2dd227538efd633aa3d1454a9b0dd1bbe5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "html_url": "https://github.com/rust-lang/rust/commit/602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3beb159809d2f1c9daf9c73d8fd62a4383742bc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3beb159809d2f1c9daf9c73d8fd62a4383742bc4", "html_url": "https://github.com/rust-lang/rust/commit/3beb159809d2f1c9daf9c73d8fd62a4383742bc4"}], "stats": {"total": 340, "additions": 279, "deletions": 61}, "files": [{"sha": "be4758581e98e0d962be46405e27fe46973d6a53", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "patch": "@@ -336,6 +336,46 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::TyRawPtr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n             ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n         }\n+        ty::TyRawPtr(_) => {\n+            let lhs_addr = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_ADDR]));\n+            let lhs_extra = Load(bcx, GEPi(bcx, lhs, &[0, abi::FAT_PTR_EXTRA]));\n+\n+            let rhs_addr = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_ADDR]));\n+            let rhs_extra = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_EXTRA]));\n+\n+            match op {\n+                hir::BiEq => {\n+                    let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n+                    let extra_eq = ICmp(bcx, llvm::IntEQ, lhs_extra, rhs_extra, debug_loc);\n+                    And(bcx, addr_eq, extra_eq, debug_loc)\n+                }\n+                hir::BiNe => {\n+                    let addr_eq = ICmp(bcx, llvm::IntNE, lhs_addr, rhs_addr, debug_loc);\n+                    let extra_eq = ICmp(bcx, llvm::IntNE, lhs_extra, rhs_extra, debug_loc);\n+                    Or(bcx, addr_eq, extra_eq, debug_loc)\n+                }\n+                hir::BiLe | hir::BiLt | hir::BiGe | hir::BiGt => {\n+                    // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n+                    let (op, strict_op) = match op {\n+                        hir::BiLt => (llvm::IntULT, llvm::IntULT),\n+                        hir::BiLe => (llvm::IntULE, llvm::IntULT),\n+                        hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n+                        hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n+                        _ => unreachable!()\n+                    };\n+\n+                    let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n+                    let extra_op = ICmp(bcx, op, lhs_extra, rhs_extra, debug_loc);\n+                    let addr_eq_extra_op = And(bcx, addr_eq, extra_op, debug_loc);\n+\n+                    let addr_strict = ICmp(bcx, strict_op, lhs_addr, rhs_addr, debug_loc);\n+                    Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n+                }\n+                _ => {\n+                    bcx.tcx().sess.bug(\"unexpected fat ptr binop\");\n+                }\n+            }\n+        }\n         ty::TyInt(_) => {\n             ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, true), lhs, rhs, debug_loc)\n         }\n@@ -828,6 +868,10 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n         return;\n     }\n \n+    debug!(\"store_ty: {} : {:?} <- {}\",\n+           cx.val_to_string(dst), t,\n+           cx.val_to_string(v));\n+\n     if common::type_is_fat_ptr(cx.tcx(), t) {\n         Store(cx, ExtractValue(cx, v, abi::FAT_PTR_ADDR), expr::get_dataptr(cx, dst));\n         Store(cx, ExtractValue(cx, v, abi::FAT_PTR_EXTRA), expr::get_meta(cx, dst));"}, {"sha": "eb9635066f3b5528ddbd4cafc6760b28c063f25c", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 53, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "patch": "@@ -1725,58 +1725,6 @@ fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn trans_fat_ptr_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   binop_expr: &hir::Expr,\n-                                   binop_ty: Ty<'tcx>,\n-                                   op: hir::BinOp,\n-                                   lhs: Datum<'tcx, Rvalue>,\n-                                   rhs: Datum<'tcx, Rvalue>)\n-                                   -> DatumBlock<'blk, 'tcx, Expr>\n-{\n-    let debug_loc = binop_expr.debug_loc();\n-\n-    let lhs_addr = Load(bcx, GEPi(bcx, lhs.val, &[0, abi::FAT_PTR_ADDR]));\n-    let lhs_extra = Load(bcx, GEPi(bcx, lhs.val, &[0, abi::FAT_PTR_EXTRA]));\n-\n-    let rhs_addr = Load(bcx, GEPi(bcx, rhs.val, &[0, abi::FAT_PTR_ADDR]));\n-    let rhs_extra = Load(bcx, GEPi(bcx, rhs.val, &[0, abi::FAT_PTR_EXTRA]));\n-\n-    let val = match op.node {\n-        hir::BiEq => {\n-            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-            let extra_eq = ICmp(bcx, llvm::IntEQ, lhs_extra, rhs_extra, debug_loc);\n-            And(bcx, addr_eq, extra_eq, debug_loc)\n-        }\n-        hir::BiNe => {\n-            let addr_eq = ICmp(bcx, llvm::IntNE, lhs_addr, rhs_addr, debug_loc);\n-            let extra_eq = ICmp(bcx, llvm::IntNE, lhs_extra, rhs_extra, debug_loc);\n-            Or(bcx, addr_eq, extra_eq, debug_loc)\n-        }\n-        hir::BiLe | hir::BiLt | hir::BiGe | hir::BiGt => {\n-            // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n-            let (op, strict_op) = match op.node {\n-                hir::BiLt => (llvm::IntULT, llvm::IntULT),\n-                hir::BiLe => (llvm::IntULE, llvm::IntULT),\n-                hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n-                hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n-                _ => unreachable!()\n-            };\n-\n-            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-            let extra_op = ICmp(bcx, op, lhs_extra, rhs_extra, debug_loc);\n-            let addr_eq_extra_op = And(bcx, addr_eq, extra_op, debug_loc);\n-\n-            let addr_strict = ICmp(bcx, strict_op, lhs_addr, rhs_addr, debug_loc);\n-            Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n-        }\n-        _ => {\n-            bcx.tcx().sess.span_bug(binop_expr.span, \"unexpected binop\");\n-        }\n-    };\n-\n-    immediate_rvalue_bcx(bcx, val, binop_ty).to_expr_datumblock()\n-}\n-\n fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   binop_expr: &hir::Expr,\n                                   binop_ty: Ty<'tcx>,\n@@ -2005,7 +1953,15 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if type_is_fat_ptr(ccx.tcx(), lhs.ty) {\n                 assert!(type_is_fat_ptr(ccx.tcx(), rhs.ty),\n                         \"built-in binary operators on fat pointers are homogeneous\");\n-                trans_fat_ptr_binop(bcx, expr, binop_ty, op, lhs, rhs)\n+                assert_eq!(binop_ty, bcx.tcx().types.bool);\n+                let val = base::compare_scalar_types(\n+                    bcx,\n+                    lhs.val,\n+                    rhs.val,\n+                    lhs.ty,\n+                    op.node,\n+                    expr.debug_loc());\n+                immediate_rvalue_bcx(bcx, val, binop_ty).to_expr_datumblock()\n             } else {\n                 assert!(!type_is_fat_ptr(ccx.tcx(), rhs.ty),\n                         \"built-in binary operators on fat pointers are homogeneous\");"}, {"sha": "cf1ecc4d6daaa2d7c893d7635c210f9061d1e962", "filename": "src/librustc_trans/trans/mir/analyze.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs?ref=602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "patch": "@@ -28,10 +28,11 @@ pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n         let ty = bcx.monomorphize(&temp_decl.ty);\n         debug!(\"temp {:?} has type {:?}\", index, ty);\n         if\n-            ty.is_scalar() ||\n-            ty.is_unique() ||\n-            (ty.is_region_ptr() && !common::type_is_fat_ptr(bcx.tcx(), ty)) ||\n-            ty.is_simd()\n+            (ty.is_scalar() ||\n+             ty.is_unique() ||\n+             ty.is_region_ptr() ||\n+             ty.is_simd())\n+            && !common::type_is_fat_ptr(bcx.tcx(), ty)\n         {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca."}, {"sha": "c21103fde964457bfb466bbb73f504baf046b3e1", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "patch": "@@ -192,4 +192,3 @@ mod lvalue;\n mod rvalue;\n mod operand;\n mod statement;\n-"}, {"sha": "65fb0d91e4dc55c9c6d2d794e7c3e61c73461623", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::middle::ty::Ty;\n+use rustc::middle::ty::{self, Ty};\n use rustc_front::hir;\n use rustc_mir::repr as mir;\n \n@@ -45,6 +45,19 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 bcx\n             }\n \n+            mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, cast_ty) => {\n+                let expr_ty =\n+                    bcx.monomorphize(&self.mir.operand_ty(bcx.tcx(), operand));\n+                let cast_ty =\n+                    bcx.monomorphize(&cast_ty);\n+                if expr_ty == cast_ty {\n+                    debug!(\"trans_rvalue: trivial unsize at {:?}\", expr_ty);\n+                    self.trans_operand_into(bcx, lldest, operand);\n+                    return bcx;\n+                }\n+                unimplemented!()\n+            }\n+\n             mir::Rvalue::Cast(..) => {\n                 unimplemented!()\n             }\n@@ -93,7 +106,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                build::Store(bcx, temp.llval, lldest);\n+                base::store_ty(bcx, temp.llval, lldest, temp.ty);\n                 bcx\n             }\n         }\n@@ -112,6 +125,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 (bcx, operand)\n             }\n \n+            mir::Rvalue::Cast(mir::CastKind::Unsize, _, _) => {\n+                unimplemented!()\n+            }\n+\n             mir::Rvalue::Cast(..) => {\n                 unimplemented!()\n             }\n@@ -240,7 +257,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n                 (bcx, OperandRef {\n                     llval: llval,\n-                    ty: lhs.ty,\n+                    ty: type_of_binop(bcx.tcx(), op, lhs.ty, rhs.ty),\n                 })\n             }\n \n@@ -311,3 +328,31 @@ pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n \n     // (*) this is only true if the type is suitable\n }\n+\n+/// FIXME(nikomatsakis): I don't think this function should go here\n+fn type_of_binop<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    op: mir::BinOp,\n+    lhs_ty: Ty<'tcx>,\n+    rhs_ty: Ty<'tcx>)\n+    -> Ty<'tcx>\n+{\n+    match op {\n+        mir::BinOp::Add | mir::BinOp::Sub |\n+        mir::BinOp::Mul | mir::BinOp::Div | mir::BinOp::Rem |\n+        mir::BinOp::BitXor | mir::BinOp::BitAnd | mir::BinOp::BitOr => {\n+            // these should be integers or floats of the same size. We\n+            // probably want to dump all ops in some intrinsics framework\n+            // someday.\n+            assert_eq!(lhs_ty, rhs_ty);\n+            lhs_ty\n+        }\n+        mir::BinOp::Shl | mir::BinOp::Shr => {\n+            lhs_ty // lhs_ty can be != rhs_ty\n+        }\n+        mir::BinOp::Eq | mir::BinOp::Lt | mir::BinOp::Le |\n+        mir::BinOp::Ne | mir::BinOp::Ge | mir::BinOp::Gt => {\n+            tcx.types.bool\n+        }\n+    }\n+}"}, {"sha": "20c3357d7d232ed5f5c87ed5411cfa803149b343", "filename": "src/test/run-pass/mir_raw_fat_ptr.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602cf7ec3c69c5c9b7d04c7baf66b270f565a001/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs?ref=602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+// check raw fat pointer ops in mir\n+// FIXME: please improve this when we get monomorphization support\n+\n+use std::mem;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct ComparisonResults {\n+    lt: bool,\n+    le: bool,\n+    gt: bool,\n+    ge: bool,\n+    eq: bool,\n+    ne: bool\n+}\n+\n+const LT: ComparisonResults = ComparisonResults {\n+    lt: true,\n+    le: true,\n+    gt: false,\n+    ge: false,\n+    eq: false,\n+    ne: true\n+};\n+\n+const EQ: ComparisonResults = ComparisonResults {\n+    lt: false,\n+    le: true,\n+    gt: false,\n+    ge: true,\n+    eq: true,\n+    ne: false\n+};\n+\n+const GT: ComparisonResults = ComparisonResults {\n+    lt: false,\n+    le: false,\n+    gt: true,\n+    ge: true,\n+    eq: false,\n+    ne: true\n+};\n+\n+#[rustc_mir]\n+fn compare_su8(a: *const S<[u8]>, b: *const S<[u8]>) -> ComparisonResults {\n+    ComparisonResults {\n+        lt: a < b,\n+        le: a <= b,\n+        gt: a > b,\n+        ge: a >= b,\n+        eq: a == b,\n+        ne: a != b\n+    }\n+}\n+\n+#[rustc_mir]\n+fn compare_au8(a: *const [u8], b: *const [u8]) -> ComparisonResults {\n+    ComparisonResults {\n+        lt: a < b,\n+        le: a <= b,\n+        gt: a > b,\n+        ge: a >= b,\n+        eq: a == b,\n+        ne: a != b\n+    }\n+}\n+\n+#[rustc_mir(graphviz=\"comparefoo.gv\")]\n+fn compare_foo<'a>(a: *const (Foo+'a), b: *const (Foo+'a)) -> ComparisonResults {\n+    ComparisonResults {\n+        lt: a < b,\n+        le: a <= b,\n+        gt: a > b,\n+        ge: a >= b,\n+        eq: a == b,\n+        ne: a != b\n+    }\n+}\n+\n+#[rustc_mir(graphviz=\"simpleeq.gv\")]\n+fn simple_eq<'a>(a: *const (Foo+'a), b: *const (Foo+'a)) -> bool {\n+    let result = a == b;\n+    result\n+}\n+\n+fn assert_inorder<T: Copy>(a: &[T],\n+                           compare: fn(T, T) -> ComparisonResults) {\n+    for i in 0..a.len() {\n+        for j in 0..a.len() {\n+            let cres = compare(a[i], a[j]);\n+            if i < j {\n+                assert_eq!(cres, LT);\n+            } else if i == j {\n+                assert_eq!(cres, EQ);\n+            } else {\n+                assert_eq!(cres, GT);\n+            }\n+        }\n+    }\n+}\n+\n+trait Foo { fn foo(&self) -> usize; }\n+impl<T> Foo for T {\n+    fn foo(&self) -> usize {\n+        mem::size_of::<T>()\n+    }\n+}\n+\n+struct S<T:?Sized>(u32, T);\n+\n+fn main() {\n+    let array = [0,1,2,3,4];\n+    let array2 = [5,6,7,8,9];\n+\n+    // fat ptr comparison: addr then extra\n+\n+    // check ordering for arrays\n+    let mut ptrs: Vec<*const [u8]> = vec![\n+        &array[0..0], &array[0..1], &array, &array[1..]\n+    ];\n+\n+    let array_addr = &array as *const [u8] as *const u8 as usize;\n+    let array2_addr = &array2 as *const [u8] as *const u8 as usize;\n+    if array2_addr < array_addr {\n+        ptrs.insert(0, &array2);\n+    } else {\n+        ptrs.push(&array2);\n+    }\n+    assert_inorder(&ptrs, compare_au8);\n+\n+    let u8_ = (0u8, 1u8);\n+    let u32_ = (4u32, 5u32);\n+\n+    // check ordering for ptrs\n+    let buf: &mut [*const Foo] = &mut [\n+        &u8_, &u8_.0,\n+        &u32_, &u32_.0,\n+    ];\n+    buf.sort_by(|u,v| {\n+        let u : [*const (); 2] = unsafe { mem::transmute(*u) };\n+        let v : [*const (); 2] = unsafe { mem::transmute(*v) };\n+        u.cmp(&v)\n+    });\n+    assert_inorder(buf, compare_foo);\n+\n+    // check ordering for structs containing arrays\n+    let ss: (S<[u8; 2]>,\n+             S<[u8; 3]>,\n+             S<[u8; 2]>) = (\n+        S(7, [8, 9]),\n+        S(10, [11, 12, 13]),\n+        S(4, [5, 6])\n+    );\n+    assert_inorder(&[\n+        &ss.0 as *const S<[u8]>,\n+        &ss.1 as *const S<[u8]>,\n+        &ss.2 as *const S<[u8]>\n+            ], compare_su8);\n+\n+    assert!(simple_eq(&0u8 as *const _, &0u8 as *const _));\n+    assert!(!simple_eq(&0u8 as *const _, &1u8 as *const _));\n+}"}]}