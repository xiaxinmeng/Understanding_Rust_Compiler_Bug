{"sha": "e970db37a9bba47bd46ff2755b042f830641e5f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NzBkYjM3YTliYmE0N2JkNDZmZjI3NTViMDQyZjgzMDY0MWU1ZjE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-03T00:33:54Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-06T21:49:00Z"}, "message": "Remove old slicing hacks and make new slicing work", "tree": {"sha": "7d81e3d9b0e625eb41f85f2ad3edc7a063559a41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d81e3d9b0e625eb41f85f2ad3edc7a063559a41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e970db37a9bba47bd46ff2755b042f830641e5f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e970db37a9bba47bd46ff2755b042f830641e5f1", "html_url": "https://github.com/rust-lang/rust/commit/e970db37a9bba47bd46ff2755b042f830641e5f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e970db37a9bba47bd46ff2755b042f830641e5f1/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "html_url": "https://github.com/rust-lang/rust/commit/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08"}], "stats": {"total": 540, "additions": 137, "deletions": 403}, "files": [{"sha": "f71d020a1b86f349c3667932223c30c0fc23fd5c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e970db37a9bba47bd46ff2755b042f830641e5f1", "patch": "@@ -441,28 +441,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n-                match rhs.node {\n-                    ast::ExprRange(ref start, ref end) => {\n-                        // Hacked slicing syntax (KILLME).\n-                        let args = match (start, end) {\n-                            (&Some(ref e1), &Some(ref e2)) => vec![&**e1, &**e2],\n-                            (&Some(ref e), &None) => vec![&**e],\n-                            (&None, &Some(ref e)) => vec![&**e],\n-                            (&None, &None) => Vec::new()\n-                        };\n-                        let overloaded =\n-                            self.walk_overloaded_operator(expr, &**lhs, args, PassArgs::ByRef);\n-                        assert!(overloaded);\n-                    }\n-                    _ => {\n-                        if !self.walk_overloaded_operator(expr,\n-                                                          &**lhs,\n-                                                          vec![&**rhs],\n-                                                          PassArgs::ByRef) {\n-                            self.select_from_expr(&**lhs);\n-                            self.consume_expr(&**rhs);\n-                        }\n-                    }\n+                if !self.walk_overloaded_operator(expr,\n+                                                  &**lhs,\n+                                                  vec![&**rhs],\n+                                                  PassArgs::ByRef) {\n+                    self.select_from_expr(&**lhs);\n+                    self.consume_expr(&**rhs);\n                 }\n             }\n "}, {"sha": "2f81d8c0f701e4f10611bd0374e6e524a3343ae0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e970db37a9bba47bd46ff2755b042f830641e5f1", "patch": "@@ -266,8 +266,6 @@ lets_do_this! {\n     ShrTraitLangItem,                \"shr\",                     shr_trait;\n     IndexTraitLangItem,              \"index\",                   index_trait;\n     IndexMutTraitLangItem,           \"index_mut\",               index_mut_trait;\n-    SliceTraitLangItem,              \"slice\",                   slice_trait;\n-    SliceMutTraitLangItem,           \"slice_mut\",               slice_mut_trait;\n     RangeStructLangItem,             \"range\",                   range_struct;\n     RangeFromStructLangItem,         \"range_from\",              range_from_struct;\n     RangeToStructLangItem,           \"range_to\",                range_to_struct;"}, {"sha": "99c2fad0e500f37e37f62c8bab3a48af93da9352", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e970db37a9bba47bd46ff2755b042f830641e5f1", "patch": "@@ -482,28 +482,20 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n           }\n \n-          ast::ExprIndex(ref base, ref idx) => {\n-            match idx.node {\n-                ast::ExprRange(..) => {\n-                    // Slicing syntax special case (KILLME).\n-                    Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n+          ast::ExprIndex(ref base, _) => {\n+            let method_call = ty::MethodCall::expr(expr.id());\n+            match self.typer.node_method_ty(method_call) {\n+                Some(method_ty) => {\n+                    // If this is an index implemented by a method call, then it will\n+                    // include an implicit deref of the result.\n+                    let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n+                    self.cat_deref(expr,\n+                                   self.cat_rvalue_node(expr.id(),\n+                                                        expr.span(),\n+                                                        ret_ty), 1, true)\n                 }\n-                _ => {\n-                    let method_call = ty::MethodCall::expr(expr.id());\n-                    match self.typer.node_method_ty(method_call) {\n-                        Some(method_ty) => {\n-                            // If this is an index implemented by a method call, then it will\n-                            // include an implicit deref of the result.\n-                            let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n-                            self.cat_deref(expr,\n-                                           self.cat_rvalue_node(expr.id(),\n-                                                                expr.span(),\n-                                                                ret_ty), 1, true)\n-                        }\n-                        None => {\n-                            self.cat_index(expr, try!(self.cat_expr(&**base)))\n-                        }\n-                    }\n+                None => {\n+                    self.cat_index(expr, self.cat_expr(&**base))\n                 }\n             }\n           }"}, {"sha": "d954495055d121c9d8bafb6d76f32d4c21763d05", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e970db37a9bba47bd46ff2755b042f830641e5f1", "patch": "@@ -1047,7 +1047,7 @@ pub struct ClosureTy<'tcx> {\n     pub abi: abi::Abi,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum FnOutput<'tcx> {\n     FnConverging(Ty<'tcx>),\n     FnDiverging\n@@ -1699,8 +1699,7 @@ impl fmt::Show for RegionVid {\n \n impl<'tcx> fmt::Show for FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // grr, without tcx not much we can do.\n-        write!(f, \"(...)\")\n+        write!(f, \"({}; variadic: {})->{}\", self.inputs, self.variadic, self.output)\n     }\n }\n "}, {"sha": "561391400a1c03dc820bbb59939a5a3d34577032", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=e970db37a9bba47bd46ff2755b042f830641e5f1", "patch": "@@ -24,8 +24,7 @@ use trans::common;\n use trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n use trans::debuginfo;\n use trans::glue;\n-// Temporary due to slicing syntax hacks (KILLME)\n-//use middle::region;\n+use middle::region;\n use trans::type_::Type;\n use middle::ty::{self, Ty};\n use std::fmt;\n@@ -129,16 +128,15 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         // excluding id's that correspond to closure bodies only). For\n         // now we just say that if there is already an AST scope on the stack,\n         // this new AST scope had better be its immediate child.\n-        // Temporarily removed due to slicing syntax hacks (KILLME).\n-        /*let top_scope = self.top_ast_scope();\n+        let top_scope = self.top_ast_scope();\n         if top_scope.is_some() {\n             assert_eq!(self.ccx\n                            .tcx()\n                            .region_maps\n                            .opt_encl_scope(region::CodeExtent::from_node_id(debug_loc.id))\n                            .map(|s|s.node_id()),\n                        top_scope);\n-        }*/\n+        }\n \n         self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n                                           Some(debug_loc)));"}, {"sha": "24feb579a0674fb2475084dcb9c1cb8c096f0a78", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=e970db37a9bba47bd46ff2755b042f830641e5f1", "patch": "@@ -573,40 +573,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_rec_tup_field(bcx, &**base, idx.node)\n         }\n         ast::ExprIndex(ref base, ref idx) => {\n-            match idx.node {\n-                ast::ExprRange(ref start, ref end) => {\n-                    // Special case for slicing syntax (KILLME).\n-                    let _icx = push_ctxt(\"trans_slice\");\n-                    let ccx = bcx.ccx();\n-\n-                    let method_call = MethodCall::expr(expr.id);\n-                    let method_ty = ccx.tcx()\n-                                       .method_map\n-                                       .borrow()\n-                                       .get(&method_call)\n-                                       .map(|method| method.ty);\n-                    let base_datum = unpack_datum!(bcx, trans(bcx, &**base));\n-\n-                    let mut args = vec![];\n-                    start.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n-                    end.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n-\n-                    let result_ty = ty::ty_fn_ret(monomorphize_type(bcx,\n-                                                                    method_ty.unwrap())).unwrap();\n-                    let scratch = rvalue_scratch_datum(bcx, result_ty, \"trans_slice\");\n-\n-                    unpack_result!(bcx,\n-                                   trans_overloaded_op(bcx,\n-                                                       expr,\n-                                                       method_call,\n-                                                       base_datum,\n-                                                       args,\n-                                                       Some(SaveIn(scratch.val)),\n-                                                       true));\n-                    DatumBlock::new(bcx, scratch.to_expr_datum())\n-                }\n-                _ => trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n-            }\n+            trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n         }\n         ast::ExprBox(_, ref contents) => {\n             // Special case for `Box<T>`"}, {"sha": "24d2907e953d78f66a443f8e820b09ef46cb6f05", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 43, "deletions": 172, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e970db37a9bba47bd46ff2755b042f830641e5f1", "patch": "@@ -2377,90 +2377,6 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-/// Checks for a `Slice` (or `SliceMut`) impl at the relevant level of autoderef. If it finds one,\n-/// installs method info and returns type of method (else None).\n-fn try_overloaded_slice_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                       method_call: MethodCall,\n-                                       expr: &ast::Expr,\n-                                       base_expr: &ast::Expr,\n-                                       base_ty: Ty<'tcx>, // autoderef'd type\n-                                       autoderefref: ty::AutoDerefRef<'tcx>,\n-                                       lvalue_pref: LvaluePreference,\n-                                       start_expr: &Option<P<ast::Expr>>,\n-                                       end_expr: &Option<P<ast::Expr>>)\n-                                       -> Option<(Ty<'tcx>, /* index type */\n-                                                  Ty<'tcx>)> /* return type */\n-{\n-    let input_ty = fcx.infcx().next_ty_var();\n-    let return_ty = fcx.infcx().next_ty_var();\n-\n-    let method = match lvalue_pref {\n-        PreferMutLvalue => {\n-            // Try `SliceMut` first, if preferred.\n-            match fcx.tcx().lang_items.slice_mut_trait() {\n-                Some(trait_did) => {\n-                    let method_name = match (start_expr, end_expr) {\n-                        (&Some(_), &Some(_)) => \"slice_or_fail_mut\",\n-                        (&Some(_), &None) => \"slice_from_or_fail_mut\",\n-                        (&None, &Some(_)) => \"slice_to_or_fail_mut\",\n-                        (&None, &None) => \"as_mut_slice_\",\n-                    };\n-\n-                    method::lookup_in_trait_adjusted(fcx,\n-                                                     expr.span,\n-                                                     Some(&*base_expr),\n-                                                     token::intern(method_name),\n-                                                     trait_did,\n-                                                     autoderefref,\n-                                                     base_ty,\n-                                                     Some(vec![input_ty, return_ty]))\n-                }\n-                _ => None,\n-            }\n-        }\n-        NoPreference => {\n-            // Otherwise, fall back to `Slice`.\n-            match fcx.tcx().lang_items.slice_trait() {\n-                Some(trait_did) => {\n-                    let method_name = match (start_expr, end_expr) {\n-                        (&Some(_), &Some(_)) => \"slice_or_fail\",\n-                        (&Some(_), &None) => \"slice_from_or_fail\",\n-                        (&None, &Some(_)) => \"slice_to_or_fail\",\n-                        (&None, &None) => \"as_slice_\",\n-                    };\n-\n-                    method::lookup_in_trait_adjusted(fcx,\n-                                                     expr.span,\n-                                                     Some(&*base_expr),\n-                                                     token::intern(method_name),\n-                                                     trait_did,\n-                                                     autoderefref,\n-                                                     base_ty,\n-                                                     Some(vec![input_ty, return_ty]))\n-                }\n-                _ => None,\n-            }\n-        }\n-    };\n-\n-    // If some lookup succeeded, install method in table\n-    method.map(|method| {\n-        let method_ty = method.ty;\n-        make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method));\n-\n-        let result_ty = ty::ty_fn_ret(method_ty);\n-        let result_ty = match result_ty {\n-            ty::FnConverging(result_ty) => result_ty,\n-            ty::FnDiverging => {\n-                fcx.tcx().sess.span_bug(expr.span,\n-                \"slice trait does not define a `!` return\")\n-            }\n-        };\n-\n-        (input_ty, result_ty)\n-    })\n-}\n-\n /// To type-check `base_expr[index_expr]`, we progressively autoderef (and otherwise adjust)\n /// `base_expr`, looking for a type which either supports builtin indexing or overloaded indexing.\n /// This loop implements one step in that search; the autoderef loop is implemented by\n@@ -2474,26 +2390,17 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             lvalue_pref: LvaluePreference)\n                             -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n {\n+    let tcx = fcx.tcx();\n     debug!(\"try_index_step(expr={}, base_expr.id={}, adjusted_ty={}, adjustment={})\",\n-           expr.repr(fcx.tcx()),\n-           base_expr.repr(fcx.tcx()),\n-           adjusted_ty.repr(fcx.tcx()),\n+           expr.repr(tcx),\n+           base_expr.repr(tcx),\n+           adjusted_ty.repr(tcx),\n            adjustment);\n \n-    // Try built-in indexing first.\n-    match ty::index(adjusted_ty) {\n-        Some(ty) => {\n-            fcx.write_adjustment(base_expr.id, base_expr.span, ty::AdjustDerefRef(adjustment));\n-            return Some((fcx.tcx().types.uint, ty));\n-        }\n-\n-        None => { }\n-    }\n-\n     let input_ty = fcx.infcx().next_ty_var();\n \n     // Try `IndexMut` first, if preferred.\n-    let method = match (lvalue_pref, fcx.tcx().lang_items.index_mut_trait()) {\n+    let method = match (lvalue_pref, tcx.lang_items.index_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n             method::lookup_in_trait_adjusted(fcx,\n                                              expr.span,\n@@ -2508,24 +2415,37 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     };\n \n     // Otherwise, fall back to `Index`.\n-    let method = match (method, fcx.tcx().lang_items.index_trait()) {\n+    let method = match (method, tcx.lang_items.index_trait()) {\n         (None, Some(trait_did)) => {\n             method::lookup_in_trait_adjusted(fcx,\n                                              expr.span,\n                                              Some(&*base_expr),\n                                              token::intern(\"index\"),\n                                              trait_did,\n-                                             adjustment,\n+                                             adjustment.clone(),\n                                              adjusted_ty,\n                                              Some(vec![input_ty]))\n         }\n         (method, _) => method,\n     };\n \n+    if method.is_none() {\n+        // If there are no overridden index impls, use built-in indexing.\n+        match ty::index(adjusted_ty) {\n+            Some(ty) => {\n+                debug!(\"try_index_step: success, using built-in indexing\");\n+                fcx.write_adjustment(base_expr.id, base_expr.span, ty::AdjustDerefRef(adjustment));\n+                return Some((tcx.types.uint, ty));\n+            }\n+            None => {}\n+        }\n+    }\n+\n     // If some lookup succeeds, write callee into table and extract index/element\n     // type from the method signature.\n     // If some lookup succeeded, install method in table\n     method.and_then(|method| {\n+        debug!(\"try_index_step: success, using overloaded indexing\");\n         make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method)).\n             map(|ret| (input_ty, ret.ty))\n     })\n@@ -4270,91 +4190,42 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           if ty::type_is_error(base_t) {\n               fcx.write_ty(id, base_t);\n           } else {\n-              match idx.node {\n-                ast::ExprRange(ref start, ref end) => {\n-                  // A slice, rather than an index. Special cased for now (KILLME).\n+              check_expr(fcx, &**idx);\n+              let idx_t = fcx.expr_ty(&**idx);\n+              if ty::type_is_error(idx_t) {\n+                  fcx.write_ty(id, idx_t);\n+              } else {\n                   let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n \n                   let result =\n                       autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n-                          try_overloaded_slice_step(fcx,\n-                                                    MethodCall::expr(expr.id),\n-                                                    expr,\n-                                                    &**base,\n-                                                    adj_ty,\n-                                                    adj,\n-                                                    lvalue_pref,\n-                                                    start,\n-                                                    end)\n+                          try_index_step(fcx,\n+                                         MethodCall::expr(expr.id),\n+                                         expr,\n+                                         &**base,\n+                                         adj_ty,\n+                                         adj,\n+                                         lvalue_pref)\n                       });\n \n-                  let mut args = vec![];\n-                  start.as_ref().map(|x| args.push(x));\n-                  end.as_ref().map(|x| args.push(x));\n-\n                   match result {\n                       Some((index_ty, element_ty)) => {\n-                          for a in args.iter() {\n-                            check_expr_has_type(fcx, &***a, index_ty);\n-                          }\n-                          fcx.write_ty(idx.id, element_ty);\n-                          fcx.write_ty(id, element_ty)\n+                          check_expr_has_type(fcx, &**idx, index_ty);\n+                          fcx.write_ty(id, element_ty);\n                       }\n                       _ => {\n-                          for a in args.iter() {\n-                            check_expr(fcx, &***a);\n-                          }\n-                          fcx.type_error_message(expr.span,\n-                             |actual| {\n-                                  format!(\"cannot take a slice of a value with type `{}`\",\n+                          check_expr_has_type(fcx, &**idx, fcx.tcx().types.err);\n+                          fcx.type_error_message(\n+                              expr.span,\n+                              |actual| {\n+                                  format!(\"cannot index a value of type `{}`\",\n                                           actual)\n-                             },\n-                             base_t,\n-                             None);\n-                          fcx.write_ty(idx.id, fcx.tcx().types.err);\n+                              },\n+                              base_t,\n+                              None);\n                           fcx.write_ty(id, fcx.tcx().types.err);\n                       }\n                   }\n-                }\n-                _ => {\n-                  check_expr(fcx, &**idx);\n-                  let idx_t = fcx.expr_ty(&**idx);\n-                  if ty::type_is_error(idx_t) {\n-                      fcx.write_ty(id, idx_t);\n-                  } else {\n-                      let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n-\n-                      let result =\n-                          autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n-                              try_index_step(fcx,\n-                                             MethodCall::expr(expr.id),\n-                                             expr,\n-                                             &**base,\n-                                             adj_ty,\n-                                             adj,\n-                                             lvalue_pref)\n-                          });\n-\n-                      match result {\n-                          Some((index_ty, element_ty)) => {\n-                              check_expr_has_type(fcx, &**idx, index_ty);\n-                              fcx.write_ty(id, element_ty);\n-                          }\n-                          _ => {\n-                              check_expr_has_type(fcx, &**idx, fcx.tcx().types.err);\n-                              fcx.type_error_message(\n-                                  expr.span,\n-                                  |actual| {\n-                                      format!(\"cannot index a value of type `{}`\",\n-                                              actual)\n-                                  },\n-                                  base_t,\n-                                  None);\n-                              fcx.write_ty(id, fcx.tcx().types.err);\n-                          }\n-                      }\n-                  }\n-                }\n               }\n           }\n        }\n@@ -4387,7 +4258,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           };\n \n           // Note that we don't check the type of start/end satisfy any\n-          // bounds because right the range structs do not have any. If we add\n+          // bounds because right now the range structs do not have any. If we add\n           // some bounds, then we'll need to check `t_start` against them here.\n \n           let range_type = match idx_type {"}, {"sha": "7824dacd3a1648a99963d3b2df9091aba2727b31", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 20, "deletions": 95, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e970db37a9bba47bd46ff2755b042f830641e5f1", "patch": "@@ -63,7 +63,7 @@ use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast;\n use ast_util::{self, as_prec, ident_to_path, operator_prec};\n-use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, DUMMY_SP};\n+use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp};\n use diagnostic;\n use ext::tt::macro_parser;\n use parse;\n@@ -2103,22 +2103,6 @@ impl<'a> Parser<'a> {\n         ExprIndex(expr, idx)\n     }\n \n-    pub fn mk_slice(&mut self,\n-                    expr: P<Expr>,\n-                    start: Option<P<Expr>>,\n-                    end: Option<P<Expr>>,\n-                    _mutbl: Mutability)\n-                    -> ast::Expr_ {\n-        // FIXME: we could give more accurate span info here.\n-        let (lo, hi) = match (&start, &end) {\n-            (&Some(ref s), &Some(ref e)) => (s.span.lo, e.span.hi),\n-            (&Some(ref s), &None) => (s.span.lo, s.span.hi),\n-            (&None, &Some(ref e)) => (e.span.lo, e.span.hi),\n-            (&None, &None) => (DUMMY_SP.lo, DUMMY_SP.hi),\n-        };\n-        ExprIndex(expr, self.mk_expr(lo, hi, ExprRange(start, end)))\n-    }\n-\n     pub fn mk_range(&mut self,\n                     start: Option<P<Expr>>,\n                     end: Option<P<Expr>>)\n@@ -2550,87 +2534,28 @@ impl<'a> Parser<'a> {\n               }\n \n               // expr[...]\n-              // Could be either an index expression or a slicing expression.\n-              // Any slicing non-terminal can have a mutable version with `mut`\n-              // after the opening square bracket.\n+              // An index expression.\n               token::OpenDelim(token::Bracket) => {\n+                let bracket_pos = self.span.lo;\n                 self.bump();\n-                let mutbl = if self.eat_keyword(keywords::Mut) {\n-                    MutMutable\n+                if self.eat(&token::CloseDelim(token::Bracket)) {\n+                    // No expression, expand to a FullRange\n+                    let ix = {\n+                        hi = self.last_span.hi;\n+                        let range = ExprStruct(ident_to_path(mk_sp(lo, hi),\n+                                                             token::special_idents::FullRange),\n+                                               vec![],\n+                                               None);\n+                        self.mk_expr(bracket_pos, hi, range)\n+                    };\n+                    let index = self.mk_index(e, ix);\n+                    e = self.mk_expr(lo, hi, index)\n                 } else {\n-                    MutImmutable\n-                };\n-                match self.token {\n-                    // e.index(&FullRange)\n-                    token::CloseDelim(token::Bracket) => {\n-                        self.bump();\n-                        hi = self.span.hi;\n-                        let slice = self.mk_slice(e, None, None, mutbl);\n-                        e = self.mk_expr(lo, hi, slice)\n-                    }\n-                    // e.index(&(0..e))\n-                    token::DotDot => {\n-                        self.bump();\n-                        match self.token {\n-                            // e.index(&(..))\n-                            token::CloseDelim(token::Bracket) => {\n-                                self.bump();\n-                                hi = self.span.hi;\n-                                let slice = self.mk_slice(e, None, None, mutbl);\n-                                e = self.mk_expr(lo, hi, slice);\n-\n-                                self.span_err(e.span, \"incorrect slicing expression: `[..]`\");\n-                                self.span_note(e.span,\n-                                    \"use `expr.index(&FullRange)` to construct a slice of the whole of expr\");\n-                            }\n-                            // e.index(&(0..e))\n-                            _ => {\n-                                hi = self.span.hi;\n-                                let e2 = self.parse_expr();\n-                                self.commit_expr_expecting(&*e2, token::CloseDelim(token::Bracket));\n-                                let slice = self.mk_slice(e, None, Some(e2), mutbl);\n-                                e = self.mk_expr(lo, hi, slice)\n-                            }\n-                        }\n-                    }\n-                    // e[e] | e.index(&(e..)) | e.index(&(e..e))\n-                    _ => {\n-                        let ix = self.parse_expr_res(RESTRICTION_NO_DOTS);\n-                        match self.token {\n-                            // e.index(&(e..)) | e.index(&(e..e))\n-                            token::DotDot => {\n-                                self.bump();\n-                                let e2 = match self.token {\n-                                    // e.index(&(e..))\n-                                    token::CloseDelim(token::Bracket) => {\n-                                        self.bump();\n-                                        None\n-                                    }\n-                                    // e.index(&(e..e))\n-                                    _ => {\n-                                        let e2 = self.parse_expr_res(RESTRICTION_NO_DOTS);\n-                                        self.commit_expr_expecting(&*e2,\n-                                            token::CloseDelim(token::Bracket));\n-                                        Some(e2)\n-                                    }\n-                                };\n-                                hi = self.span.hi;\n-                                let slice = self.mk_slice(e, Some(ix), e2, mutbl);\n-                                e = self.mk_expr(lo, hi, slice)\n-                            }\n-                            // e[e]\n-                            _ => {\n-                                if mutbl == ast::MutMutable {\n-                                    self.span_err(e.span,\n-                                                  \"`mut` keyword is invalid in index expressions\");\n-                                }\n-                                hi = self.span.hi;\n-                                self.commit_expr_expecting(&*ix, token::CloseDelim(token::Bracket));\n-                                let index = self.mk_index(e, ix);\n-                                e = self.mk_expr(lo, hi, index)\n-                            }\n-                        }\n-                    }\n+                    let ix = self.parse_expr();\n+                    hi = self.span.hi;\n+                    self.commit_expr_expecting(&*ix, token::CloseDelim(token::Bracket));\n+                    let index = self.mk_index(e, ix);\n+                    e = self.mk_expr(lo, hi, index)\n                 }\n               }\n "}, {"sha": "ada463a40cbc269d11db086e758b8c4821ace0ad", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e970db37a9bba47bd46ff2755b042f830641e5f1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e970db37a9bba47bd46ff2755b042f830641e5f1", "patch": "@@ -515,66 +515,66 @@ declare_special_idents_and_keywords! {\n         (9,                          unnamed_field,          \"<unnamed_field>\");\n         (10,                         type_self,              \"Self\");\n         (11,                         prelude_import,         \"prelude_import\");\n+        (12,                         FullRange,              \"FullRange\");\n     }\n \n     pub mod keywords {\n         // These ones are variants of the Keyword enum\n \n         'strict:\n-        (12,                         As,         \"as\");\n-        (13,                         Break,      \"break\");\n-        (14,                         Crate,      \"crate\");\n-        (15,                         Else,       \"else\");\n-        (16,                         Enum,       \"enum\");\n-        (17,                         Extern,     \"extern\");\n-        (18,                         False,      \"false\");\n-        (19,                         Fn,         \"fn\");\n-        (20,                         For,        \"for\");\n-        (21,                         If,         \"if\");\n-        (22,                         Impl,       \"impl\");\n-        (23,                         In,         \"in\");\n-        (24,                         Let,        \"let\");\n-        (25,                         Loop,       \"loop\");\n-        (26,                         Match,      \"match\");\n-        (27,                         Mod,        \"mod\");\n-        (28,                         Move,       \"move\");\n-        (29,                         Mut,        \"mut\");\n-        (30,                         Pub,        \"pub\");\n-        (31,                         Ref,        \"ref\");\n-        (32,                         Return,     \"return\");\n+        (13,                         As,         \"as\");\n+        (14,                         Break,      \"break\");\n+        (15,                         Crate,      \"crate\");\n+        (16,                         Else,       \"else\");\n+        (17,                         Enum,       \"enum\");\n+        (18,                         Extern,     \"extern\");\n+        (19,                         False,      \"false\");\n+        (20,                         Fn,         \"fn\");\n+        (21,                         For,        \"for\");\n+        (22,                         If,         \"if\");\n+        (23,                         Impl,       \"impl\");\n+        (24,                         In,         \"in\");\n+        (25,                         Let,        \"let\");\n+        (26,                         Loop,       \"loop\");\n+        (27,                         Match,      \"match\");\n+        (28,                         Mod,        \"mod\");\n+        (29,                         Move,       \"move\");\n+        (30,                         Mut,        \"mut\");\n+        (31,                         Pub,        \"pub\");\n+        (32,                         Ref,        \"ref\");\n+        (33,                         Return,     \"return\");\n         // Static and Self are also special idents (prefill de-dupes)\n         (super::STATIC_KEYWORD_NAME_NUM, Static, \"static\");\n         (super::SELF_KEYWORD_NAME_NUM,   Self,   \"self\");\n-        (33,                         Struct,     \"struct\");\n+        (34,                         Struct,     \"struct\");\n         (super::SUPER_KEYWORD_NAME_NUM, Super,   \"super\");\n-        (34,                         True,       \"true\");\n-        (35,                         Trait,      \"trait\");\n-        (36,                         Type,       \"type\");\n-        (37,                         Unsafe,     \"unsafe\");\n-        (38,                         Use,        \"use\");\n-        (39,                         Virtual,    \"virtual\");\n-        (40,                         While,      \"while\");\n-        (41,                         Continue,   \"continue\");\n-        (42,                         Proc,       \"proc\");\n-        (43,                         Box,        \"box\");\n-        (44,                         Const,      \"const\");\n-        (45,                         Where,      \"where\");\n-\n+        (35,                         True,       \"true\");\n+        (36,                         Trait,      \"trait\");\n+        (37,                         Type,       \"type\");\n+        (38,                         Unsafe,     \"unsafe\");\n+        (39,                         Use,        \"use\");\n+        (40,                         Virtual,    \"virtual\");\n+        (41,                         While,      \"while\");\n+        (42,                         Continue,   \"continue\");\n+        (43,                         Proc,       \"proc\");\n+        (44,                         Box,        \"box\");\n+        (45,                         Const,      \"const\");\n+        (46,                         Where,      \"where\");\n         'reserved:\n-        (46,                         Alignof,    \"alignof\");\n-        (47,                         Be,         \"be\");\n-        (48,                         Offsetof,   \"offsetof\");\n-        (49,                         Priv,       \"priv\");\n-        (50,                         Pure,       \"pure\");\n-        (51,                         Sizeof,     \"sizeof\");\n-        (52,                         Typeof,     \"typeof\");\n-        (53,                         Unsized,    \"unsized\");\n-        (54,                         Yield,      \"yield\");\n-        (55,                         Do,         \"do\");\n-        (56,                         Abstract,   \"abstract\");\n-        (57,                         Final,      \"final\");\n-        (58,                         Override,   \"override\");\n-        (59,                         Macro,      \"macro\");\n+        (47,                         Alignof,    \"alignof\");\n+        (48,                         Be,         \"be\");\n+        (49,                         Offsetof,   \"offsetof\");\n+        (50,                         Priv,       \"priv\");\n+        (51,                         Pure,       \"pure\");\n+        (52,                         Sizeof,     \"sizeof\");\n+        (53,                         Typeof,     \"typeof\");\n+        (54,                         Unsized,    \"unsized\");\n+        (55,                         Yield,      \"yield\");\n+        (56,                         Do,         \"do\");\n+        (57,                         Abstract,   \"abstract\");\n+        (58,                         Final,      \"final\");\n+        (59,                         Override,   \"override\");\n+        (60,                         Macro,      \"macro\");\n     }\n }\n "}]}