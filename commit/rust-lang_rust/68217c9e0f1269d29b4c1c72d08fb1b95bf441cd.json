{"sha": "68217c9e0f1269d29b4c1c72d08fb1b95bf441cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MjE3YzllMGYxMjY5ZDI5YjRjMWM3MmQwOGZiMWI5NWJmNDQxY2Q=", "commit": {"author": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2020-08-16T23:25:39Z"}, "committer": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2020-08-30T18:58:03Z"}, "message": "ignore zst offsets instead", "tree": {"sha": "05c7e3f6c8b21b89ac73a89eab0f91744e8004a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05c7e3f6c8b21b89ac73a89eab0f91744e8004a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68217c9e0f1269d29b4c1c72d08fb1b95bf441cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68217c9e0f1269d29b4c1c72d08fb1b95bf441cd", "html_url": "https://github.com/rust-lang/rust/commit/68217c9e0f1269d29b4c1c72d08fb1b95bf441cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68217c9e0f1269d29b4c1c72d08fb1b95bf441cd/comments", "author": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9bc3ddb073f2261ac46832d985efe8db863ed6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9bc3ddb073f2261ac46832d985efe8db863ed6a", "html_url": "https://github.com/rust-lang/rust/commit/e9bc3ddb073f2261ac46832d985efe8db863ed6a"}], "stats": {"total": 163, "additions": 76, "deletions": 87}, "files": [{"sha": "7c0eddea5229b289c5024504b4db480212c8aea3", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/68217c9e0f1269d29b4c1c72d08fb1b95bf441cd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68217c9e0f1269d29b4c1c72d08fb1b95bf441cd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=68217c9e0f1269d29b4c1c72d08fb1b95bf441cd", "patch": "@@ -93,15 +93,29 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         let effective_field_align = self.align.restrict_for_offset(offset);\n \n         let mut simple = || {\n-            // Unions and newtypes only use an offset of 0.\n-            let llval = if offset.bytes() == 0 {\n-                self.llval\n-            } else if let Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n-                // Offsets have to match either first or second field.\n-                assert_eq!(offset, a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi));\n-                bx.struct_gep(self.llval, 1)\n-            } else {\n-                bx.struct_gep(self.llval, bx.cx().backend_field_index(self.layout, ix))\n+            let llval = match self.layout.abi {\n+                _ if offset.bytes() == 0 => {\n+                    // Unions and newtypes only use an offset of 0.\n+                    // Also handles the first field of Scalar and ScalarPair layouts.\n+                    self.llval\n+                }\n+                Abi::ScalarPair(ref a, ref b)\n+                    if offset == a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi) =>\n+                {\n+                    // Offset matches second field.\n+                    bx.struct_gep(self.llval, 1)\n+                }\n+                Abi::ScalarPair(..) | Abi::Scalar(_) => {\n+                    // ZST fields are not included in Scalar and ScalarPair layouts, so manually offset the pointer.\n+                    assert!(\n+                        field.is_zst(),\n+                        \"non-ZST field offset does not match layout: {:?}\",\n+                        field\n+                    );\n+                    let byte_ptr = bx.pointercast(self.llval, bx.cx().type_i8p());\n+                    bx.gep(byte_ptr, &[bx.const_usize(offset.bytes())])\n+                }\n+                _ => bx.struct_gep(self.llval, bx.cx().backend_field_index(self.layout, ix)),\n             };\n             PlaceRef {\n                 // HACK(eddyb): have to bitcast pointers until LLVM removes pointee types."}, {"sha": "3ec084234721729b3ede640e45d10a7edd751684", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 53, "deletions": 78, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/68217c9e0f1269d29b4c1c72d08fb1b95bf441cd/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68217c9e0f1269d29b4c1c72d08fb1b95bf441cd/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=68217c9e0f1269d29b4c1c72d08fb1b95bf441cd", "patch": "@@ -289,32 +289,25 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         let optimize = !repr.inhibit_struct_field_reordering_opt();\n         if optimize {\n+            let end =\n+                if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n+            let optimizing = &mut inverse_memory_index[..end];\n             let field_align = |f: &TyAndLayout<'_>| {\n                 if let Some(pack) = pack { f.align.abi.min(pack) } else { f.align.abi }\n             };\n             match kind {\n-                StructKind::AlwaysSized => {\n-                    inverse_memory_index.sort_by_key(|&x| {\n+                StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n+                    optimizing.sort_by_key(|&x| {\n                         // Place ZSTs first to avoid \"interesting offsets\",\n                         // especially with only one or two non-ZST fields.\n                         let f = &fields[x as usize];\n                         (!f.is_zst(), cmp::Reverse(field_align(f)))\n                     });\n                 }\n-                StructKind::MaybeUnsized => {\n-                    // Sort in descending alignment, except for the last field,\n-                    // which may be accessed through an unsized type.\n-                    inverse_memory_index[..fields.len() - 1]\n-                        .sort_by_key(|&x| cmp::Reverse(field_align(&fields[x as usize])));\n-                    // Place ZSTs first to avoid \"interesting offsets\".\n-                    // This will reorder the last field if it is a ZST, which is okay because\n-                    // there's nothing in memory that could be accessed through an unsized type.\n-                    inverse_memory_index.sort_by_key(|&x| !fields[x as usize].is_zst());\n-                }\n                 StructKind::Prefixed(..) => {\n                     // Sort in ascending alignment so that the layout stay optimal\n                     // regardless of the prefix\n-                    inverse_memory_index.sort_by_key(|&x| field_align(&fields[x as usize]));\n+                    optimizing.sort_by_key(|&x| field_align(&fields[x as usize]));\n                 }\n             }\n         }\n@@ -397,78 +390,60 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         // Unpack newtype ABIs and find scalar pairs.\n         if sized && size.bytes() > 0 {\n-            // All other fields must be ZSTs, and we need them to all start at 0.\n-            let mut zst_offsets = offsets.iter().enumerate().filter(|&(i, _)| fields[i].is_zst());\n-            if zst_offsets.all(|(_, o)| o.bytes() == 0) {\n-                let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n-\n-                match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n-                    // We have exactly one non-ZST field.\n-                    (Some((i, field)), None, None) => {\n-                        // Field fills the struct and it has a scalar or scalar pair ABI.\n-                        if offsets[i].bytes() == 0\n-                            && align.abi == field.align.abi\n-                            && size == field.size\n-                        {\n-                            match field.abi {\n-                                // For plain scalars, or vectors of them, we can't unpack\n-                                // newtypes for `#[repr(C)]`, as that affects C ABIs.\n-                                Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n-                                    abi = field.abi.clone();\n-                                }\n-                                // But scalar pairs are Rust-specific and get\n-                                // treated as aggregates by C ABIs anyway.\n-                                Abi::ScalarPair(..) => {\n-                                    abi = field.abi.clone();\n-                                }\n-                                _ => {}\n+            // All other fields must be ZSTs.\n+            let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n+\n+            match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n+                // We have exactly one non-ZST field.\n+                (Some((i, field)), None, None) => {\n+                    // Field fills the struct and it has a scalar or scalar pair ABI.\n+                    if offsets[i].bytes() == 0 && align.abi == field.align.abi && size == field.size\n+                    {\n+                        match field.abi {\n+                            // For plain scalars, or vectors of them, we can't unpack\n+                            // newtypes for `#[repr(C)]`, as that affects C ABIs.\n+                            Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n+                                abi = field.abi.clone();\n+                            }\n+                            // But scalar pairs are Rust-specific and get\n+                            // treated as aggregates by C ABIs anyway.\n+                            Abi::ScalarPair(..) => {\n+                                abi = field.abi.clone();\n                             }\n+                            _ => {}\n                         }\n                     }\n+                }\n \n-                    // Two non-ZST fields, and they're both scalars.\n-                    (\n-                        Some((\n-                            i,\n-                            &TyAndLayout {\n-                                layout: &Layout { abi: Abi::Scalar(ref a), .. }, ..\n-                            },\n-                        )),\n-                        Some((\n-                            j,\n-                            &TyAndLayout {\n-                                layout: &Layout { abi: Abi::Scalar(ref b), .. }, ..\n-                            },\n-                        )),\n-                        None,\n-                    ) => {\n-                        // Order by the memory placement, not source order.\n-                        let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n-                            ((i, a), (j, b))\n-                        } else {\n-                            ((j, b), (i, a))\n-                        };\n-                        let pair = self.scalar_pair(a.clone(), b.clone());\n-                        let pair_offsets = match pair.fields {\n-                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n-                                assert_eq!(memory_index, &[0, 1]);\n-                                offsets\n-                            }\n-                            _ => bug!(),\n-                        };\n-                        if offsets[i] == pair_offsets[0]\n-                            && offsets[j] == pair_offsets[1]\n-                            && align == pair.align\n-                            && size == pair.size\n-                        {\n-                            // We can use `ScalarPair` only when it matches our\n-                            // already computed layout (including `#[repr(C)]`).\n-                            abi = pair.abi;\n+                // Two non-ZST fields, and they're both scalars.\n+                (\n+                    Some((i, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(ref a), .. }, .. })),\n+                    Some((j, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(ref b), .. }, .. })),\n+                    None,\n+                ) => {\n+                    // Order by the memory placement, not source order.\n+                    let ((i, a), (j, b)) =\n+                        if offsets[i] < offsets[j] { ((i, a), (j, b)) } else { ((j, b), (i, a)) };\n+                    let pair = self.scalar_pair(a.clone(), b.clone());\n+                    let pair_offsets = match pair.fields {\n+                        FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                            assert_eq!(memory_index, &[0, 1]);\n+                            offsets\n                         }\n+                        _ => bug!(),\n+                    };\n+                    if offsets[i] == pair_offsets[0]\n+                        && offsets[j] == pair_offsets[1]\n+                        && align == pair.align\n+                        && size == pair.size\n+                    {\n+                        // We can use `ScalarPair` only when it matches our\n+                        // already computed layout (including `#[repr(C)]`).\n+                        abi = pair.abi;\n                     }\n-\n-                    _ => {}\n                 }\n+\n+                _ => {}\n             }\n         }\n "}]}