{"sha": "7129e8815e3203ceae5bb85b0faa8e8753e520e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMjllODgxNWUzMjAzY2VhZTViYjg1YjBmYWE4ZTg3NTNlNTIwZTM=", "commit": {"author": {"name": "Sean Patrick Santos", "email": "SeanPatrickSantos@gmail.com", "date": "2015-03-16T01:35:25Z"}, "committer": {"name": "Sean Patrick Santos", "email": "SeanPatrickSantos@gmail.com", "date": "2015-04-24T03:02:26Z"}, "message": "Functional changes for associated constants. Cross-crate usage of associated constants is not yet working.", "tree": {"sha": "973676209c72727da017d909d5d06228503bdd62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/973676209c72727da017d909d5d06228503bdd62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7129e8815e3203ceae5bb85b0faa8e8753e520e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7129e8815e3203ceae5bb85b0faa8e8753e520e3", "html_url": "https://github.com/rust-lang/rust/commit/7129e8815e3203ceae5bb85b0faa8e8753e520e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7129e8815e3203ceae5bb85b0faa8e8753e520e3/comments", "author": {"login": "quantheory", "id": 1740206, "node_id": "MDQ6VXNlcjE3NDAyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1740206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quantheory", "html_url": "https://github.com/quantheory", "followers_url": "https://api.github.com/users/quantheory/followers", "following_url": "https://api.github.com/users/quantheory/following{/other_user}", "gists_url": "https://api.github.com/users/quantheory/gists{/gist_id}", "starred_url": "https://api.github.com/users/quantheory/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quantheory/subscriptions", "organizations_url": "https://api.github.com/users/quantheory/orgs", "repos_url": "https://api.github.com/users/quantheory/repos", "events_url": "https://api.github.com/users/quantheory/events{/privacy}", "received_events_url": "https://api.github.com/users/quantheory/received_events", "type": "User", "site_admin": false}, "committer": {"login": "quantheory", "id": 1740206, "node_id": "MDQ6VXNlcjE3NDAyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1740206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quantheory", "html_url": "https://github.com/quantheory", "followers_url": "https://api.github.com/users/quantheory/followers", "following_url": "https://api.github.com/users/quantheory/following{/other_user}", "gists_url": "https://api.github.com/users/quantheory/gists{/gist_id}", "starred_url": "https://api.github.com/users/quantheory/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quantheory/subscriptions", "organizations_url": "https://api.github.com/users/quantheory/orgs", "repos_url": "https://api.github.com/users/quantheory/repos", "events_url": "https://api.github.com/users/quantheory/events{/privacy}", "received_events_url": "https://api.github.com/users/quantheory/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5499775d6bee080b3f46539d59d238de2c1726f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5499775d6bee080b3f46539d59d238de2c1726f", "html_url": "https://github.com/rust-lang/rust/commit/b5499775d6bee080b3f46539d59d238de2c1726f"}], "stats": {"total": 1681, "additions": 1387, "deletions": 294}, "files": [{"sha": "27e15bc2f0eeaa044a8e7a8dd301e232c28e3b3e", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -505,10 +505,20 @@ trait_items\n ;\n \n trait_item\n-: trait_type\n+: trait_const\n+| trait_type\n | trait_method\n ;\n \n+trait_const\n+: maybe_outer_attrs CONST ident maybe_const_default ';' { $$ = mk_node(\"ConstTraitItem\", 3, $1, $3, $4); }\n+;\n+\n+maybe_const_default\n+: '=' expr { $$ = mk_node(\"ConstDefault\", 1, $2); }\n+| %empty   { $$ = mk_none(); }\n+;\n+\n trait_type\n : maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(\"TypeTraitItem\", 2, $1, $3); }\n ;\n@@ -611,7 +621,16 @@ impl_items\n impl_item\n : impl_method\n | item_macro\n-| trait_type\n+| impl_const\n+| impl_type\n+;\n+\n+impl_const\n+: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n+;\n+\n+impl_type\n+: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n ;\n \n item_fn"}, {"sha": "93056d949dbb07bfde8188d0823058ae0899c788", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -175,6 +175,13 @@ pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n     decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n+pub fn get_associated_consts<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+                                   -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.node, tcx)\n+}\n+\n pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);"}, {"sha": "00a7fe68f2fb0733013f73dc58833621a157fd60", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -305,7 +305,25 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n-        Constant  => DlDef(def::DefConst(did)),\n+        Constant  => {\n+            // Check whether we have an associated const item.\n+            if item_sort(item) == Some('C') {\n+                // Check whether the associated const is from a trait or impl.\n+                // See the comment for methods below.\n+                let provenance = if reader::maybe_get_doc(\n+                      item, tag_item_trait_parent_sort).is_some() {\n+                    def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n+                                                                        item))\n+                } else {\n+                    def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n+                                                                       item))\n+                };\n+                DlDef(def::DefAssociatedConst(did, provenance))\n+            } else {\n+                // Regular const item.\n+                DlDef(def::DefConst(did))\n+            }\n+        }\n         ImmStatic => DlDef(def::DefStatic(did, false)),\n         MutStatic => DlDef(def::DefStatic(did, true)),\n         Struct    => DlDef(def::DefStruct(did)),\n@@ -826,6 +844,7 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n                         tag_item_impl_item, |doc| {\n         let def_id = item_def_id(doc, cdata);\n         match item_sort(doc) {\n+            Some('C') => impl_items.push(ty::ConstTraitItemId(def_id)),\n             Some('r') | Some('p') => {\n                 impl_items.push(ty::MethodTraitItemId(def_id))\n             }\n@@ -877,6 +896,18 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n     let vis = item_visibility(method_doc);\n \n     match item_sort(method_doc) {\n+        Some('C') => {\n+            let ty = doc_type(method_doc, tcx, cdata);\n+            let default = get_provided_source(method_doc, cdata);\n+            ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n+                name: name,\n+                ty: ty,\n+                vis: vis,\n+                def_id: def_id,\n+                container: container,\n+                default: default,\n+            }))\n+        }\n         Some('r') | Some('p') => {\n             let generics = doc_generics(method_doc, tcx, cdata, tag_method_ty_generics);\n             let predicates = doc_predicates(method_doc, tcx, cdata, tag_method_ty_generics);\n@@ -914,6 +945,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n     reader::tagged_docs(item, tag_item_trait_item, |mth| {\n         let def_id = item_def_id(mth, cdata);\n         match item_sort(mth) {\n+            Some('C') => result.push(ty::ConstTraitItemId(def_id)),\n             Some('r') | Some('p') => {\n                 result.push(ty::MethodTraitItemId(def_id));\n             }\n@@ -961,6 +993,34 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n     return result;\n }\n \n+pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n+                                   cdata: Cmd,\n+                                   id: ast::NodeId,\n+                                   tcx: &ty::ctxt<'tcx>)\n+                                   -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+    let data = cdata.data();\n+    let item = lookup_item(id, data);\n+    let mut result = Vec::new();\n+\n+    reader::tagged_docs(item, tag_item_trait_item, |ac_id| {\n+        let did = item_def_id(ac_id, cdata);\n+        let ac_doc = lookup_item(did.node, data);\n+\n+        if item_sort(ac_doc) == Some('C') {\n+            let trait_item = get_impl_or_trait_item(intr.clone(),\n+                                                    cdata,\n+                                                    did.node,\n+                                                    tcx);\n+            if let ty::ConstTraitItem(ref ac) = trait_item {\n+                result.push((*ac).clone())\n+            }\n+        }\n+        true\n+    });\n+\n+    return result;\n+}\n+\n pub fn get_type_name_if_impl(cdata: Cmd,\n                              node_id: ast::NodeId) -> Option<ast::Name> {\n     let item = lookup_item(node_id, cdata.data());"}, {"sha": "bcbb350fc34ee7b12489c9d0ee23dd771865d7a1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 75, "deletions": 8, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -799,6 +799,43 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_provided_source(rbml_w, method_ty.provided_source);\n }\n \n+fn encode_info_for_associated_const(ecx: &EncodeContext,\n+                                    rbml_w: &mut Encoder,\n+                                    associated_const: &ty::AssociatedConst,\n+                                    impl_path: PathElems,\n+                                    parent_id: NodeId,\n+                                    impl_item_opt: Option<&ast::ImplItem>) {\n+    debug!(\"encode_info_for_associated_const({:?},{:?})\",\n+           associated_const.def_id,\n+           token::get_name(associated_const.name));\n+\n+    rbml_w.start_tag(tag_items_data_item);\n+\n+    encode_def_id(rbml_w, associated_const.def_id);\n+    encode_name(rbml_w, associated_const.name);\n+    encode_visibility(rbml_w, associated_const.vis);\n+    encode_family(rbml_w, 'C');\n+    encode_provided_source(rbml_w, associated_const.default);\n+\n+    encode_parent_item(rbml_w, local_def(parent_id));\n+    encode_item_sort(rbml_w, 'C');\n+\n+    encode_bounds_and_type_for_item(rbml_w, ecx, associated_const.def_id.local_id());\n+\n+    let stab = stability::lookup(ecx.tcx, associated_const.def_id);\n+    encode_stability(rbml_w, stab);\n+\n+    let elem = ast_map::PathName(associated_const.name);\n+    encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n+\n+    if let Some(ii) = impl_item_opt {\n+        encode_attributes(rbml_w, &ii.attrs);\n+        encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id), ii));\n+    }\n+\n+    rbml_w.end_tag();\n+}\n+\n fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w: &mut Encoder,\n                                     m: &ty::Method<'tcx>,\n@@ -1192,7 +1229,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for &item_def_id in items {\n             rbml_w.start_tag(tag_item_impl_item);\n             match item_def_id {\n-                ty::ConstTraitItemId(_) => {}\n+                ty::ConstTraitItemId(item_def_id) => {\n+                    encode_def_id(rbml_w, item_def_id);\n+                    encode_item_sort(rbml_w, 'C');\n+                }\n                 ty::MethodTraitItemId(item_def_id) => {\n                     encode_def_id(rbml_w, item_def_id);\n                     encode_item_sort(rbml_w, 'r');\n@@ -1230,7 +1270,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             });\n \n             match ty::impl_or_trait_item(tcx, trait_item_def_id.def_id()) {\n-                ty::ConstTraitItem(_) => {}\n+                ty::ConstTraitItem(ref associated_const) => {\n+                    encode_info_for_associated_const(ecx,\n+                                                     rbml_w,\n+                                                     &*associated_const,\n+                                                     path.clone(),\n+                                                     item.id,\n+                                                     ast_item)\n+                }\n                 ty::MethodTraitItem(ref method_type) => {\n                     encode_info_for_method(ecx,\n                                            rbml_w,\n@@ -1275,7 +1322,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for &method_def_id in &*ty::trait_item_def_ids(tcx, def_id) {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n-                ty::ConstTraitItemId(_) => {}\n+                ty::ConstTraitItemId(const_def_id) => {\n+                    encode_def_id(rbml_w, const_def_id);\n+                    encode_item_sort(rbml_w, 'C');\n+                }\n                 ty::MethodTraitItemId(method_def_id) => {\n                     encode_def_id(rbml_w, method_def_id);\n                     encode_item_sort(rbml_w, 'r');\n@@ -1321,7 +1371,23 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 ty::impl_or_trait_item(tcx, item_def_id.def_id());\n             let is_nonstatic_method;\n             match trait_item_type {\n-                ty::ConstTraitItem(_) => {\n+                ty::ConstTraitItem(associated_const) => {\n+                    encode_name(rbml_w, associated_const.name);\n+                    encode_def_id(rbml_w, associated_const.def_id);\n+                    encode_visibility(rbml_w, associated_const.vis);\n+\n+                    encode_provided_source(rbml_w, associated_const.default);\n+\n+                    let elem = ast_map::PathName(associated_const.name);\n+                    encode_path(rbml_w,\n+                                path.clone().chain(Some(elem).into_iter()));\n+\n+                    encode_item_sort(rbml_w, 'C');\n+                    encode_family(rbml_w, 'C');\n+\n+                    encode_bounds_and_type_for_item(rbml_w, ecx,\n+                                                    associated_const.def_id.local_id());\n+\n                     is_nonstatic_method = false;\n                 }\n                 ty::MethodTraitItem(method_ty) => {\n@@ -1368,7 +1434,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_item = &*ms[i];\n             encode_attributes(rbml_w, &trait_item.attrs);\n             match trait_item.node {\n-                ast::ConstTraitItem(_, _) => {}\n+                ast::ConstTraitItem(_, _) => {\n+                    encode_inlined_item(ecx, rbml_w,\n+                                        IITraitItemRef(def_id, trait_item));\n+                }\n                 ast::MethodTraitItem(ref sig, ref body) => {\n                     // If this is a static method, we've already\n                     // encoded this.\n@@ -1388,9 +1457,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_method_argument_names(rbml_w, &sig.decl);\n                 }\n \n-                ast::TypeTraitItem(..) => {\n-                    encode_item_sort(rbml_w, 't');\n-                }\n+                ast::TypeTraitItem(..) => {}\n             }\n \n             rbml_w.end_tag();"}, {"sha": "80326229618c23d05a28312c194c8506cc6675a6", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -223,6 +223,28 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, t: &'v ast::TraitItem) {\n+        match t.node {\n+            ast::ConstTraitItem(_, ref default) => {\n+                if let Some(ref expr) = *default {\n+                    self.global_expr(Mode::Const, &*expr);\n+                } else {\n+                    visit::walk_trait_item(self, t);\n+                }\n+            }\n+            _ => self.with_mode(Mode::Var, |v| visit::walk_trait_item(v, t)),\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, i: &'v ast::ImplItem) {\n+        match i.node {\n+            ast::ConstImplItem(_, ref expr) => {\n+                self.global_expr(Mode::Const, &*expr);\n+            }\n+            _ => self.with_mode(Mode::Var, |v| visit::walk_impl_item(v, i)),\n+        }\n+    }\n+\n     fn visit_fn(&mut self,\n                 fk: visit::FnKind<'v>,\n                 fd: &'v ast::FnDecl,\n@@ -468,13 +490,16 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         Mode::Var => v.add_qualif(NOT_CONST)\n                     }\n                 }\n-                Some(def::DefConst(did)) => {\n-                    if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did) {\n+                Some(def::DefConst(did)) |\n+                Some(def::DefAssociatedConst(did, _)) => {\n+                    if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did,\n+                                                                       Some(e.id)) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n                     } else {\n-                        v.tcx.sess.span_bug(e.span, \"DefConst doesn't point \\\n-                                                     to an ItemConst\");\n+                        v.tcx.sess.span_bug(e.span,\n+                                            \"DefConst or DefAssociatedConst \\\n+                                             doesn't point to a constant\");\n                     }\n                 }\n                 def => {"}, {"sha": "13be6d0cb7d9b0d73476150f9bbeeb8c00c7f055", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -442,7 +442,8 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n             ast::PatIdent(..) | ast::PatEnum(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n-                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n+                    Some(DefAssociatedConst(did, _)) |\n+                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did, Some(pat.id)) {\n                         Some(const_expr) => {\n                             const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n \n@@ -746,7 +747,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         ast::PatIdent(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefStruct(_)) => vec!(Single),\n@@ -755,15 +756,15 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n             },\n         ast::PatEnum(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         ast::PatStruct(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n@@ -861,7 +862,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         ast::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n             match opt_def {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => if *constructor == Variant(id) {\n@@ -876,7 +877,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         ast::PatEnum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n-                DefConst(..) =>\n+                DefConst(..) | DefAssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 DefVariant(_, id, _) if *constructor != Variant(id) => None,\n@@ -894,7 +895,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let class_id = match def {\n-                DefConst(..) =>\n+                DefConst(..) | DefAssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 DefVariant(_, variant_id, _) => if *constructor == Variant(variant_id) {"}, {"sha": "a521c4531c9a7e50e932eb81596c520754e0618d", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 75, "deletions": 37, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -12,10 +12,11 @@\n // recursively.\n \n use session::Session;\n-use middle::def::{DefStatic, DefConst, DefMap};\n+use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefMap};\n \n use syntax::ast;\n use syntax::{ast_util, ast_map};\n+use syntax::codemap::Span;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n@@ -26,8 +27,43 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n }\n \n impl<'v, 'a, 'ast> Visitor<'v> for CheckCrateVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n-        check_item(self, i);\n+    fn visit_item(&mut self, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemStatic(_, _, ref expr) |\n+            ast::ItemConst(_, ref expr) => {\n+                let mut recursion_visitor =\n+                    CheckItemRecursionVisitor::new(self, &it.span);\n+                recursion_visitor.visit_item(it);\n+                visit::walk_expr(self, &*expr)\n+            },\n+            _ => visit::walk_item(self, it)\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        match ti.node {\n+            ast::ConstTraitItem(_, ref default) => {\n+                if let Some(ref expr) = *default {\n+                    let mut recursion_visitor =\n+                        CheckItemRecursionVisitor::new(self, &ti.span);\n+                    recursion_visitor.visit_trait_item(ti);\n+                    visit::walk_expr(self, &*expr)\n+                }\n+            }\n+            _ => visit::walk_trait_item(self, ti)\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        match ii.node {\n+            ast::ConstImplItem(_, ref expr) => {\n+                let mut recursion_visitor =\n+                    CheckItemRecursionVisitor::new(self, &ii.span);\n+                recursion_visitor.visit_impl_item(ii);\n+                visit::walk_expr(self, &*expr)\n+            }\n+            _ => visit::walk_impl_item(self, ii)\n+        }\n     }\n }\n \n@@ -44,63 +80,65 @@ pub fn check_crate<'ast>(sess: &Session,\n     sess.abort_if_errors();\n }\n \n-fn check_item(v: &mut CheckCrateVisitor, it: &ast::Item) {\n-    match it.node {\n-        ast::ItemStatic(_, _, ref ex) |\n-        ast::ItemConst(_, ref ex) => {\n-            check_item_recursion(v.sess, v.ast_map, v.def_map, it);\n-            visit::walk_expr(v, &**ex)\n-        },\n-        _ => visit::walk_item(v, it)\n-    }\n-}\n-\n struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n-    root_it: &'a ast::Item,\n+    root_span: &'a Span,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n     def_map: &'a DefMap,\n     idstack: Vec<ast::NodeId>\n }\n \n-// Make sure a const item doesn't recursively refer to itself\n-// FIXME: Should use the dependency graph when it's available (#1356)\n-pub fn check_item_recursion<'a>(sess: &'a Session,\n-                                ast_map: &'a ast_map::Map,\n-                                def_map: &'a DefMap,\n-                                it: &'a ast::Item) {\n-\n-    let mut visitor = CheckItemRecursionVisitor {\n-        root_it: it,\n-        sess: sess,\n-        ast_map: ast_map,\n-        def_map: def_map,\n-        idstack: Vec::new()\n-    };\n-    visitor.visit_item(it);\n+impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n+    fn new(v: &CheckCrateVisitor<'a, 'ast>, span: &'a Span)\n+           -> CheckItemRecursionVisitor<'a, 'ast> {\n+        CheckItemRecursionVisitor {\n+            root_span: span,\n+            sess: v.sess,\n+            ast_map: v.ast_map,\n+            def_map: v.def_map,\n+            idstack: Vec::new()\n+        }\n+    }\n+    fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F)\n+          where F: Fn(&mut Self) {\n+        if self.idstack.iter().any(|x| x == &(id)) {\n+            span_err!(self.sess, *self.root_span, E0265, \"recursive constant\");\n+            return;\n+        }\n+        self.idstack.push(id);\n+        f(self);\n+        self.idstack.pop();\n+    }\n }\n \n impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        if self.idstack.iter().any(|x| x == &(it.id)) {\n-            span_err!(self.sess, self.root_it.span, E0265, \"recursive constant\");\n-            return;\n-        }\n-        self.idstack.push(it.id);\n-        visit::walk_item(self, it);\n-        self.idstack.pop();\n+        self.with_item_id_pushed(it.id, |v| visit::walk_item(v, it));\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        self.with_item_id_pushed(ti.id, |v| visit::walk_trait_item(v, ti));\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        self.with_item_id_pushed(ii.id, |v| visit::walk_impl_item(v, ii));\n     }\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprPath(..) => {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n+                    Some(DefAssociatedConst(def_id, _)) |\n                     Some(DefConst(def_id)) if\n                             ast_util::is_local(def_id) => {\n                         match self.ast_map.get(def_id.node) {\n                           ast_map::NodeItem(item) =>\n                             self.visit_item(item),\n+                          ast_map::NodeTraitItem(item) =>\n+                            self.visit_trait_item(item),\n+                          ast_map::NodeImplItem(item) =>\n+                            self.visit_impl_item(item),\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n                             span_err!(self.sess, e.span, E0266,"}, {"sha": "b5a173a569f45100d2bb6d61d9020a3f8ec5330f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 152, "deletions": 9, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -16,11 +16,12 @@ pub use self::const_val::*;\n use self::ErrKind::*;\n \n use metadata::csearch;\n-use middle::{astencode, def};\n+use middle::{astencode, def, infer, subst, traits};\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n use util::num::ToPrimitive;\n+use util::ppaux::Repr;\n \n use syntax::ast::{self, Expr};\n use syntax::codemap::Span;\n@@ -39,8 +40,9 @@ use std::rc::Rc;\n fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n     let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n     match opt_def {\n-        Some(def::DefConst(def_id)) => {\n-            lookup_const_by_id(tcx, def_id)\n+        Some(def::DefConst(def_id)) |\n+        Some(def::DefAssociatedConst(def_id, _)) => {\n+            lookup_const_by_id(tcx, def_id, Some(e.id))\n         }\n         Some(def::DefVariant(enum_def, variant_def, _)) => {\n             lookup_variant_by_id(tcx, enum_def, variant_def)\n@@ -101,14 +103,36 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n     }\n }\n \n-pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n-                          -> Option<&'a Expr> {\n+pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n+                                        def_id: ast::DefId,\n+                                        maybe_ref_id: Option<ast::NodeId>)\n+                                        -> Option<&'tcx Expr> {\n     if ast_util::is_local(def_id) {\n         match tcx.map.find(def_id.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemConst(_, ref const_expr) => {\n-                    Some(&**const_expr)\n+                    Some(&*const_expr)\n+                }\n+                _ => None\n+            },\n+            Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n+                ast::ConstTraitItem(_, ref default) => {\n+                    match maybe_ref_id {\n+                        Some(ref_id) => {\n+                            let trait_id = ty::trait_of_item(tcx, def_id)\n+                                              .unwrap();\n+                            resolve_trait_associated_const(tcx, ti, trait_id,\n+                                                           ref_id)\n+                        }\n+                        None => default.as_ref().map(|expr| &**expr),\n+                    }\n+                }\n+                _ => None\n+            },\n+            Some(ast_map::NodeImplItem(ii)) => match ii.node {\n+                ast::ConstImplItem(_, ref expr) => {\n+                    Some(&*expr)\n                 }\n                 _ => None\n             },\n@@ -122,16 +146,42 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n             }\n             None => {}\n         }\n+        let mut used_ref_id = false;\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n             csearch::FoundAst::Found(&ast::IIItem(ref item)) => match item.node {\n                 ast::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n+            csearch::FoundAst::Found(&ast::IITraitItem(_, ref ti)) => match ti.node {\n+                ast::ConstTraitItem(_, ref default) => {\n+                    used_ref_id = true;\n+                    match maybe_ref_id {\n+                        Some(ref_id) => {\n+                            let trait_id = ty::trait_of_item(tcx, def_id)\n+                                              .unwrap();\n+                            resolve_trait_associated_const(tcx, ti, trait_id,\n+                                                           ref_id).map(|e| e.id)\n+                        }\n+                        None => default.as_ref().map(|expr| expr.id),\n+                    }\n+                }\n+                _ => None\n+            },\n+            csearch::FoundAst::Found(&ast::IIImplItem(_, ref ii)) => match ii.node {\n+                ast::ConstImplItem(_, ref expr) => Some(expr.id),\n+                _ => None\n+            },\n             _ => None\n         };\n-        tcx.extern_const_statics.borrow_mut().insert(def_id,\n-                                                     expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+        // If we used the reference expression, particularly to choose an impl\n+        // of a trait-associated const, don't cache that, because the next\n+        // lookup with the same def_id may yield a different result.\n+        if used_ref_id {\n+            tcx.extern_const_statics\n+               .borrow_mut().insert(def_id,\n+                                    expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+        }\n         expr_id.map(|id| tcx.map.expect_expr(id))\n     }\n }\n@@ -755,7 +805,35 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           _ => (None, None)\n                       }\n                   } else {\n-                      (lookup_const_by_id(tcx, def_id), None)\n+                      (lookup_const_by_id(tcx, def_id, Some(e.id)), None)\n+                  }\n+              }\n+              Some(def::DefAssociatedConst(def_id, provenance)) => {\n+                  if ast_util::is_local(def_id) {\n+                      match provenance {\n+                          def::FromTrait(trait_id) => match tcx.map.find(def_id.node) {\n+                              Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n+                                  ast::ConstTraitItem(ref ty, _) => {\n+                                      (resolve_trait_associated_const(tcx, ti,\n+                                                                      trait_id, e.id),\n+                                       Some(&**ty))\n+                                  }\n+                                  _ => (None, None)\n+                              },\n+                              _ => (None, None)\n+                          },\n+                          def::FromImpl(_) => match tcx.map.find(def_id.node) {\n+                              Some(ast_map::NodeImplItem(ii)) => match ii.node {\n+                                  ast::ConstImplItem(ref ty, ref expr) => {\n+                                      (Some(&**expr), Some(&**ty))\n+                                  }\n+                                  _ => (None, None)\n+                              },\n+                              _ => (None, None)\n+                          },\n+                      }\n+                  } else {\n+                      (lookup_const_by_id(tcx, def_id, Some(e.id)), None)\n                   }\n               }\n               Some(def::DefVariant(enum_def, variant_def, _)) => {\n@@ -833,6 +911,71 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n     Ok(result)\n }\n \n+fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n+                                                ti: &'tcx ast::TraitItem,\n+                                                trait_id: ast::DefId,\n+                                                ref_id: ast::NodeId)\n+                                                -> Option<&'tcx Expr>\n+{\n+    let rcvr_substs = ty::node_id_item_substs(tcx, ref_id).substs;\n+    let subst::SeparateVecsPerParamSpace {\n+        types: rcvr_type,\n+        selfs: rcvr_self,\n+        fns: _,\n+    } = rcvr_substs.types.split();\n+    let trait_substs =\n+        subst::Substs::erased(subst::VecPerParamSpace::new(rcvr_type,\n+                                                           rcvr_self,\n+                                                           Vec::new()));\n+    let trait_substs = tcx.mk_substs(trait_substs);\n+    debug!(\"resolve_trait_associated_const: trait_substs={}\",\n+           trait_substs.repr(tcx));\n+    let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: trait_id,\n+                                                      substs: trait_substs }));\n+\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n+    let infcx = infer::new_infer_ctxt(tcx);\n+\n+    let param_env = ty::empty_parameter_environment(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &param_env);\n+    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                             trait_ref.to_poly_trait_predicate());\n+    let selection = match selcx.select(&obligation) {\n+        Ok(Some(vtable)) => vtable,\n+        // Still ambiguous, so give up and let the caller decide whether this\n+        // expression is really needed yet. Some associated constant values\n+        // can't be evaluated until monomorphization is done in trans.\n+        Ok(None) => {\n+            return None\n+        }\n+        Err(e) => {\n+            tcx.sess.span_bug(ti.span,\n+                              &format!(\"Encountered error `{}` when trying \\\n+                                        to select an implementation for \\\n+                                        constant trait item reference.\",\n+                                       e.repr(tcx)))\n+        }\n+    };\n+\n+    match selection {\n+        traits::VtableImpl(ref impl_data) => {\n+            match ty::associated_consts(tcx, impl_data.impl_def_id)\n+                     .iter().find(|ic| ic.name == ti.ident.name) {\n+                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n+                None => match ti.node {\n+                    ast::ConstTraitItem(_, Some(ref expr)) => Some(&*expr),\n+                    _ => None,\n+                },\n+            }\n+        }\n+        _ => {\n+            tcx.sess.span_bug(\n+                ti.span,\n+                &format!(\"resolve_trait_associated_const: unexpected vtable type\"))\n+        }\n+    }\n+}\n+\n fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult {\n     macro_rules! convert_val {\n         ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {"}, {"sha": "1b5e31f61d8ae628dca8fa01244d087c8a79ce86", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -78,7 +78,7 @@ use std::vec::IntoIter;\n use collections::enum_set::{EnumSet, CLike};\n use std::collections::{HashMap, HashSet};\n use syntax::abi;\n-use syntax::ast::{CrateNum, DefId, ItemTrait, LOCAL_CRATE};\n+use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n use syntax::ast_util::{self, is_local, lit_is_str, local_def};\n@@ -5125,6 +5125,53 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n     }\n }\n \n+pub fn associated_consts<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n+                               -> Vec<Rc<AssociatedConst<'tcx>>> {\n+    if is_local(id) {\n+        match cx.map.expect_item(id.node).node {\n+            ItemTrait(_, _, _, ref tis) => {\n+                tis.iter().filter_map(|ti| {\n+                    if let ast::ConstTraitItem(_, _) = ti.node {\n+                        match impl_or_trait_item(cx, ast_util::local_def(ti.id)) {\n+                            ConstTraitItem(ac) => Some(ac),\n+                            _ => {\n+                                cx.sess.bug(\"associated_consts(): \\\n+                                             non-const item found from \\\n+                                             looking up a constant?!\")\n+                            }\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                }).collect()\n+            }\n+            ItemImpl(_, _, _, _, _, ref iis) => {\n+                iis.iter().filter_map(|ii| {\n+                    if let ast::ConstImplItem(_, _) = ii.node {\n+                        match impl_or_trait_item(cx, ast_util::local_def(ii.id)) {\n+                            ConstTraitItem(ac) => Some(ac),\n+                            _ => {\n+                                cx.sess.bug(\"associated_consts(): \\\n+                                             non-const item found from \\\n+                                             looking up a constant?!\")\n+                            }\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                }).collect()\n+            }\n+            _ => {\n+                cx.sess.bug(&format!(\"associated_consts: `{:?}` is not a trait \\\n+                                      or impl\", id))\n+            }\n+        }\n+    } else {\n+        let acs = csearch::get_associated_consts(cx, id);\n+        acs.iter().map(|ac| (*ac).clone()).collect()\n+    }\n+}\n+\n /// Helper for looking things up in the various maps that are populated during\n /// typeck::collect (e.g., `cx.impl_or_trait_items`, `cx.tcache`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded"}, {"sha": "19cdc194153374e13edf1b2f362787242e767a0e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -62,6 +62,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         borrowck_item(self, item);\n     }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        if let ast::ConstTraitItem(_, Some(ref expr)) = ti.node {\n+            gather_loans::gather_loans_in_static_initializer(self, &*expr);\n+        }\n+        visit::walk_trait_item(self, ti);\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        if let ast::ConstImplItem(_, ref expr) = ii.node {\n+            gather_loans::gather_loans_in_static_initializer(self, &*expr);\n+        }\n+        visit::walk_impl_item(self, ii);\n+    }\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {"}, {"sha": "b8032bda8d070ede99791322e5f2ba00c49abc14", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -35,6 +35,7 @@ use syntax::codemap;\n use syntax::fold::{self, Folder};\n use syntax::print::{pp, pprust};\n use syntax::ptr::P;\n+use syntax::util::small_vector::SmallVector;\n \n use graphviz as dot;\n \n@@ -475,6 +476,29 @@ impl fold::Folder for ReplaceBodyWithLoop {\n         }\n     }\n \n+    fn fold_trait_item(&mut self, i: P<ast::TraitItem>) -> SmallVector<P<ast::TraitItem>> {\n+        match i.node {\n+            ast::ConstTraitItem(..) => {\n+                self.within_static_or_const = true;\n+                let ret = fold::noop_fold_trait_item(i, self);\n+                self.within_static_or_const = false;\n+                return ret;\n+            }\n+            _ => fold::noop_fold_trait_item(i, self),\n+        }\n+    }\n+\n+    fn fold_impl_item(&mut self, i: P<ast::ImplItem>) -> SmallVector<P<ast::ImplItem>> {\n+        match i.node {\n+            ast::ConstImplItem(..) => {\n+                self.within_static_or_const = true;\n+                let ret = fold::noop_fold_impl_item(i, self);\n+                self.within_static_or_const = false;\n+                return ret;\n+            }\n+            _ => fold::noop_fold_impl_item(i, self),\n+        }\n+    }\n \n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n         fn expr_to_block(rules: ast::BlockCheckMode,"}, {"sha": "902e9ffca1f6441b066ade9383390994e3e5c826", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -1068,9 +1068,30 @@ impl LintPass for NonUpperCaseGlobals {\n         }\n     }\n \n+    fn check_trait_item(&mut self, cx: &Context, ti: &ast::TraitItem) {\n+        match ti.node {\n+            ast::ConstTraitItem(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ti.ident, ti.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &Context, ii: &ast::ImplItem) {\n+        match ii.node {\n+            ast::ConstImplItem(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ii.ident, ii.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n+            (&ast::PatIdent(_, ref path1, _), Some(def::DefAssociatedConst(..))) |\n             (&ast::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n                                                       path1.node, p.span);"}, {"sha": "128e29ee76e7d6ec17acc19c8b9216cacef514b2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -119,6 +119,15 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         visit::walk_fn(self, a, b, c, d);\n     }\n \n+    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+        // visit_fn handles methods, but associated consts have to be handled\n+        // here.\n+        if !self.parents.contains_key(&ii.id) {\n+            self.parents.insert(ii.id, self.curparent);\n+        }\n+        visit::walk_impl_item(self, ii);\n+    }\n+\n     fn visit_struct_def(&mut self, s: &ast::StructDef, _: ast::Ident,\n                         _: &'v ast::Generics, n: ast::NodeId) {\n         // Struct constructors are parented to their struct definitions because\n@@ -272,7 +281,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 if public_ty || public_trait {\n                     for impl_item in impl_items {\n                         match impl_item.node {\n-                            ast::ConstImplItem(_, _) => {}\n+                            ast::ConstImplItem(..) => {\n+                                if (public_ty && impl_item.vis == ast::Public)\n+                                    || tr.is_some() {\n+                                    self.exported_items.insert(impl_item.id);\n+                                }\n+                            }\n                             ast::MethodImplItem(ref sig, _) => {\n                                 let meth_public = match sig.explicit_self.node {\n                                     ast::SelfStatic => public_ty,\n@@ -400,7 +414,33 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             debug!(\"privacy - is {:?} a public method\", did);\n \n             return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n-                Some(&ty::ConstTraitItem(_)) => ExternallyDenied,\n+                Some(&ty::ConstTraitItem(ref ac)) => {\n+                    debug!(\"privacy - it's a const: {:?}\", *ac);\n+                    match ac.container {\n+                        ty::TraitContainer(id) => {\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n+                            self.def_privacy(id)\n+                        }\n+                        ty::ImplContainer(id) => {\n+                            match ty::impl_trait_ref(self.tcx, id) {\n+                                Some(t) => {\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n+                                    self.def_privacy(t.def_id)\n+                                }\n+                                None => {\n+                                    debug!(\"privacy - found inherent \\\n+                                            associated constant {:?}\",\n+                                            ac.vis);\n+                                    if ac.vis == ast::Public {\n+                                        Allowable\n+                                    } else {\n+                                        ExternallyDenied\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n                 Some(&ty::MethodTraitItem(ref meth)) => {\n                     debug!(\"privacy - well at least it's a method: {:?}\",\n                            *meth);\n@@ -794,6 +834,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             def::DefFn(..) => ck(\"function\"),\n             def::DefStatic(..) => ck(\"static\"),\n             def::DefConst(..) => ck(\"const\"),\n+            def::DefAssociatedConst(..) => ck(\"associated const\"),\n             def::DefVariant(..) => ck(\"variant\"),\n             def::DefTy(_, false) => ck(\"type\"),\n             def::DefTy(_, true) => ck(\"enum\"),"}, {"sha": "41a6f4adfe0383e43774f77c9db60273759adbb0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -1831,22 +1831,36 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             //\n                             // FIXME #4951: Do we need a node ID here?\n \n-                            let type_parameters = match trait_item.node {\n-                                ast::ConstTraitItem(..) => NoTypeParameters,\n+                            match trait_item.node {\n+                                ast::ConstTraitItem(_, ref default) => {\n+                                    // Only impose the restrictions of\n+                                    // ConstRibKind if there's an actual constant\n+                                    // expression in a provided default.\n+                                    if default.is_some() {\n+                                        this.with_constant_rib(|this| {\n+                                            visit::walk_trait_item(this, trait_item)\n+                                        });\n+                                    } else {\n+                                        visit::walk_trait_item(this, trait_item)\n+                                    }\n+                                }\n                                 ast::MethodTraitItem(ref sig, _) => {\n-                                    HasTypeParameters(&sig.generics,\n-                                                      FnSpace,\n-                                                      MethodRibKind)\n+                                    let type_parameters =\n+                                        HasTypeParameters(&sig.generics,\n+                                                          FnSpace,\n+                                                          MethodRibKind);\n+                                    this.with_type_parameter_rib(type_parameters, |this| {\n+                                        visit::walk_trait_item(this, trait_item)\n+                                    });\n                                 }\n                                 ast::TypeTraitItem(..) => {\n                                     this.check_if_primitive_type_name(trait_item.ident.name,\n                                                                       trait_item.span);\n-                                    NoTypeParameters\n+                                    this.with_type_parameter_rib(NoTypeParameters, |this| {\n+                                        visit::walk_trait_item(this, trait_item)\n+                                    });\n                                 }\n                             };\n-                            this.with_type_parameter_rib(type_parameters, |this| {\n-                                visit::walk_trait_item(this, trait_item)\n-                            });\n                         }\n                     });\n                 });\n@@ -2096,7 +2110,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n                             match impl_item.node {\n-                                ConstImplItem(_, _) => {}\n+                                ConstImplItem(..) => {\n+                                    // If this is a trait impl, ensure the method\n+                                    // exists in trait\n+                                    this.check_trait_item(impl_item.ident.name,\n+                                                          impl_item.span);\n+                                    this.with_constant_rib(|this| {\n+                                        visit::walk_impl_item(this, impl_item);\n+                                    });\n+                                }\n                                 MethodImplItem(ref sig, _) => {\n                                     // If this is a trait impl, ensure the method\n                                     // exists in trait"}, {"sha": "dc14ef3696f5f2e47824d6ea85300ba8d57d27dd", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -539,25 +539,27 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     fn process_const(&mut self,\n-                      item: &ast::Item,\n-                      typ: &ast::Ty,\n-                      expr: &ast::Expr)\n+                     id: ast::NodeId,\n+                     ident: &ast::Ident,\n+                     span: Span,\n+                     typ: &ast::Ty,\n+                     expr: &ast::Expr)\n     {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(id));\n \n-        let sub_span = self.span.sub_span_after_keyword(item.span,\n+        let sub_span = self.span.sub_span_after_keyword(span,\n                                                         keywords::Const);\n-        self.fmt.static_str(item.span,\n+        self.fmt.static_str(span,\n                             sub_span,\n-                            item.id,\n-                            &get_ident(item.ident),\n+                            id,\n+                            &get_ident((*ident).clone()),\n                             &qualname[..],\n                             \"\",\n                             &ty_to_string(&*typ),\n                             self.cur_scope);\n \n         // walk type and init value\n-        self.visit_ty(&*typ);\n+        self.visit_ty(typ);\n         self.visit_expr(expr);\n     }\n \n@@ -1188,7 +1190,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             ast::ItemStatic(ref typ, mt, ref expr) =>\n                 self.process_static(item, &**typ, mt, &**expr),\n             ast::ItemConst(ref typ, ref expr) =>\n-                self.process_const(item, &**typ, &**expr),\n+                self.process_const(item.id, &item.ident, item.span, &*typ, &*expr),\n             ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n             ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n             ast::ItemImpl(_, _,\n@@ -1238,18 +1240,25 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n         match trait_item.node {\n-            ast::ConstTraitItem(..) => {}\n+            ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n+                self.process_const(trait_item.id, &trait_item.ident,\n+                                   trait_item.span, &*ty, &*expr);\n+            }\n             ast::MethodTraitItem(ref sig, ref body) => {\n                 self.process_method(sig, body.as_ref().map(|x| &**x),\n                                     trait_item.id, trait_item.ident.name, trait_item.span);\n             }\n+            ast::ConstTraitItem(_, None) |\n             ast::TypeTraitItem(..) => {}\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n         match impl_item.node {\n-            ast::ConstImplItem(..) => {}\n+            ast::ConstImplItem(ref ty, ref expr) => {\n+                self.process_const(impl_item.id, &impl_item.ident,\n+                                   impl_item.span, &*ty, &*expr);\n+            }\n             ast::MethodImplItem(ref sig, ref body) => {\n                 self.process_method(sig, Some(body), impl_item.id,\n                                     impl_item.ident.name, impl_item.span);"}, {"sha": "9932899ed8f0f64da56f4075ceeb3f6553418892", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -173,13 +173,11 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             \"cross crate constant could not be inlined\");\n     }\n \n-    let item = ccx.tcx().map.expect_item(def_id.node);\n-    if let ast::ItemConst(_, ref expr) = item.node {\n-        &**expr\n-    } else {\n-        ccx.sess().span_bug(ref_expr.span,\n-                            &format!(\"get_const_expr given non-constant item {}\",\n-                                     item.repr(ccx.tcx())));\n+    match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(ref_expr.id)) {\n+        Some(ref expr) => expr,\n+        None => {\n+            ccx.sess().span_bug(ref_expr.span, \"constant item not found\")\n+        }\n     }\n }\n \n@@ -201,7 +199,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast::ExprPath(..) => {\n             let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             match def {\n-                def::DefConst(def_id) => {\n+                def::DefConst(def_id) | def::DefAssociatedConst(def_id, _) => {\n                     if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n                         return get_const_val(ccx, def_id, expr);\n                     }\n@@ -774,7 +772,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n-                def::DefConst(def_id) => {\n+                def::DefConst(def_id) | def::DefAssociatedConst(def_id, _) => {\n                     const_deref_ptr(cx, get_const_val(cx, def_id, e))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {"}, {"sha": "9f0a03878be79ecf2e7d0868fb47d6306df75264", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -401,3 +401,85 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return true;\n     }\n }\n+\n+pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                impl_c: &ty::AssociatedConst<'tcx>,\n+                                impl_c_span: Span,\n+                                trait_c: &ty::AssociatedConst<'tcx>,\n+                                impl_trait_ref: &ty::TraitRef<'tcx>) {\n+    debug!(\"compare_const_impl(impl_trait_ref={})\",\n+           impl_trait_ref.repr(tcx));\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+\n+    // The below is for the most part highly similar to the procedure\n+    // for methods above. It is simpler in many respects, especially\n+    // because we shouldn't really have to deal with lifetimes or\n+    // predicates. In fact some of this should probably be put into\n+    // shared functions because of DRY violations...\n+    let trait_to_impl_substs = &impl_trait_ref.substs;\n+\n+    // Create a parameter environment that represents the implementation's\n+    // method.\n+    let impl_param_env =\n+        ty::ParameterEnvironment::for_item(tcx, impl_c.def_id.node);\n+\n+    // Create mapping from impl to skolemized.\n+    let impl_to_skol_substs = &impl_param_env.free_substs;\n+\n+    // Create mapping from trait to skolemized.\n+    let trait_to_skol_substs =\n+        trait_to_impl_substs\n+        .subst(tcx, impl_to_skol_substs)\n+        .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n+                     impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n+    debug!(\"compare_const_impl: trait_to_skol_substs={}\",\n+           trait_to_skol_substs.repr(tcx));\n+\n+    // Compute skolemized form of impl and trait const tys.\n+    let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n+    let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n+\n+    let err = infcx.commit_if_ok(|_| {\n+        let origin = infer::Misc(impl_c_span);\n+\n+        // There is no \"body\" here, so just pass dummy id.\n+        let impl_ty =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &impl_param_env,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_c_span,\n+                                                 0,\n+                                                 &impl_ty);\n+        debug!(\"compare_const_impl: impl_ty={}\",\n+               impl_ty.repr(tcx));\n+\n+        let trait_ty =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &impl_param_env,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_c_span,\n+                                                 0,\n+                                                 &trait_ty);\n+        debug!(\"compare_const_impl: trait_ty={}\",\n+               trait_ty.repr(tcx));\n+\n+        infer::mk_subty(&infcx, false, origin, impl_ty, trait_ty)\n+    });\n+\n+    match err {\n+        Ok(()) => { }\n+        Err(terr) => {\n+            debug!(\"checking associated const for compatibility: impl ty {}, trait ty {}\",\n+                   impl_ty.repr(tcx),\n+                   trait_ty.repr(tcx));\n+            span_err!(tcx.sess, impl_c_span, E0326,\n+                      \"implemented const `{}` has an incompatible type for \\\n+                      trait: {}\",\n+                      token::get_name(trait_c.name),\n+                      ty::type_err_to_str(tcx, &terr));\n+            return;\n+        }\n+    }\n+}"}, {"sha": "cf1323e71bd0e94806d8ab03db4b9ff273af31db", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -109,10 +109,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         self.add_obligations(&pick, &all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n+        let method_ty = pick.item.as_opt_method().unwrap();\n         let fty = ty::mk_bare_fn(self.tcx(), None, self.tcx().mk_bare_fn(ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n-            unsafety: pick.method_ty.fty.unsafety,\n-            abi: pick.method_ty.fty.abi.clone(),\n+            unsafety: method_ty.fty.unsafety,\n+            abi: method_ty.fty.abi.clone(),\n         }));\n         let callee = MethodCallee {\n             origin: method_origin,\n@@ -204,7 +205,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         \"impl {:?} is not an inherent impl\", impl_def_id);\n                 let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n \n-                (impl_polytype.substs, MethodStatic(pick.method_ty.def_id))\n+                (impl_polytype.substs, MethodStatic(pick.item.def_id()))\n             }\n \n             probe::ObjectPick(trait_def_id, method_num, vtable_index) => {\n@@ -336,7 +337,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let num_method_types = pick.method_ty.generics.types.len(subst::FnSpace);\n+        let num_method_types = pick.item.as_opt_method().unwrap()\n+                                   .generics.types.len(subst::FnSpace);\n         let method_types = {\n             if num_supplied_types == 0 {\n                 self.fcx.infcx().next_ty_vars(num_method_types)\n@@ -360,7 +362,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let method_regions =\n             self.fcx.infcx().region_vars_for_defs(\n                 self.span,\n-                pick.method_ty.generics.regions.get_slice(subst::FnSpace));\n+                pick.item.as_opt_method().unwrap()\n+                    .generics.regions.get_slice(subst::FnSpace));\n \n         (method_types, method_regions)\n     }\n@@ -397,7 +400,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n-        let method_predicates = pick.method_ty.predicates.instantiate(self.tcx(), &all_substs);\n+        let method_predicates = pick.item.as_opt_method().unwrap()\n+                                    .predicates.instantiate(self.tcx(), &all_substs);\n         let method_predicates = self.fcx.normalize_associated_types_in(self.span,\n                                                                        &method_predicates);\n \n@@ -410,7 +414,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(&pick.method_ty.fty.sig);\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(\n+            &pick.item.as_opt_method().unwrap().fty.sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n                method_sig.repr(self.tcx()));\n \n@@ -616,7 +621,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n-        match pick.method_ty.container {\n+        match pick.item.container() {\n             ty::TraitContainer(trait_def_id) => {\n                 callee::check_legal_trait_for_method_call(self.fcx.ccx, self.span, trait_def_id)\n             }\n@@ -625,7 +630,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 // potential calls to it will wind up in the other\n                 // arm. But just to be sure, check that the method id\n                 // does not appear in the list of destructors.\n-                assert!(!self.tcx().destructors.borrow().contains(&pick.method_ty.def_id));\n+                assert!(!self.tcx().destructors.borrow().contains(&pick.item.def_id()));\n             }\n         }\n     }"}, {"sha": "c5d8e2758ba5c6a9c3538538862bc261c6646470", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -58,7 +58,7 @@ pub enum CandidateSource {\n     TraitSource(/* trait id */ ast::DefId),\n }\n \n-type MethodIndex = usize; // just for doc purposes\n+type ItemIndex = usize; // just for doc purposes\n \n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -312,18 +312,25 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     let mode = probe::Mode::Path;\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n-    let def_id = pick.method_ty.def_id;\n+    let def_id = pick.item.def_id();\n     let mut lp = LastMod(AllPublic);\n     let provenance = match pick.kind {\n         probe::InherentImplPick(impl_def_id) => {\n-            if pick.method_ty.vis != ast::Public {\n+            if pick.item.vis() != ast::Public {\n                 lp = LastMod(DependsOn(def_id));\n             }\n             def::FromImpl(impl_def_id)\n         }\n-        _ => def::FromTrait(pick.method_ty.container.id())\n+        _ => def::FromTrait(pick.item.container().id())\n     };\n-    Ok((def::DefMethod(def_id, provenance), lp))\n+    let def_result = match pick.item {\n+        ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id, provenance),\n+        ImplOrTraitItem::ConstTraitItem(..) => def::DefAssociatedConst(def_id, provenance),\n+        ImplOrTraitItem::TypeTraitItem(..) => {\n+            fcx.tcx().sess.span_bug(span, \"resolve_ufcs: probe picked associated type\");\n+        }\n+    };\n+    Ok((def_result, lp))\n }\n \n "}, {"sha": "7ff1355184b56ade0e49fc903c3b849dc06e7cdb", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 142, "deletions": 134, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::MethodError;\n-use super::MethodIndex;\n+use super::ItemIndex;\n use super::{CandidateSource,ImplSource,TraitSource};\n use super::suggest;\n \n@@ -37,7 +37,7 @@ struct ProbeContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n     mode: Mode,\n-    method_name: ast::Name,\n+    item_name: ast::Name,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n     opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n@@ -54,22 +54,22 @@ struct CandidateStep<'tcx> {\n \n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n-    method_ty: Rc<ty::Method<'tcx>>,\n+    item: ty::ImplOrTraitItem<'tcx>,\n     kind: CandidateKind<'tcx>,\n }\n \n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n     ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ usize, /* vtable index */ usize),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n-                           subst::Substs<'tcx>, MethodIndex),\n-    ClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClauseCandidate(ty::PolyTraitRef<'tcx>, MethodIndex),\n-    ProjectionCandidate(ast::DefId, MethodIndex),\n+                           subst::Substs<'tcx>, ItemIndex),\n+    ClosureCandidate(/* Trait */ ast::DefId, ItemIndex),\n+    WhereClauseCandidate(ty::PolyTraitRef<'tcx>, ItemIndex),\n+    ProjectionCandidate(ast::DefId, ItemIndex),\n }\n \n pub struct Pick<'tcx> {\n-    pub method_ty: Rc<ty::Method<'tcx>>,\n+    pub item: ty::ImplOrTraitItem<'tcx>,\n     pub kind: PickKind<'tcx>,\n \n     // Indicates that the source expression should be autoderef'd N times\n@@ -94,20 +94,20 @@ pub struct Pick<'tcx> {\n pub enum PickKind<'tcx> {\n     InherentImplPick(/* Impl */ ast::DefId),\n     ObjectPick(/* Trait */ ast::DefId, /* method_num */ usize, /* real_index */ usize),\n-    ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n-    TraitPick(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, MethodIndex),\n+    ExtensionImplPick(/* Impl */ ast::DefId, ItemIndex),\n+    TraitPick(/* Trait */ ast::DefId, ItemIndex),\n+    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, ItemIndex),\n }\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n \n-#[derive(PartialEq, Eq, Copy, Clone)]\n+#[derive(PartialEq, Eq, Copy, Clone, Debug)]\n pub enum Mode {\n     // An expression of the form `receiver.method_name(...)`.\n     // Autoderefs are performed on `receiver`, lookup is done based on the\n     // `self` argument  of the method, and static methods aren't considered.\n     MethodCall,\n-    // An expression of the form `Type::method` or `<T>::method`.\n+    // An expression of the form `Type::item` or `<T>::item`.\n     // No autoderefs are performed, lookup is done based on the type each\n     // implementation is for, and static methods are included.\n     Path\n@@ -116,14 +116,14 @@ pub enum Mode {\n pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                        span: Span,\n                        mode: Mode,\n-                       method_name: ast::Name,\n+                       item_name: ast::Name,\n                        self_ty: Ty<'tcx>,\n                        scope_expr_id: ast::NodeId)\n                        -> PickResult<'tcx>\n {\n-    debug!(\"probe(self_ty={}, method_name={}, scope_expr_id={})\",\n+    debug!(\"probe(self_ty={}, item_name={}, scope_expr_id={})\",\n            self_ty.repr(fcx.tcx()),\n-           method_name,\n+           item_name,\n            scope_expr_id);\n \n     // FIXME(#18741) -- right now, creating the steps involves evaluating the\n@@ -171,7 +171,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let mut probe_cx = ProbeContext::new(fcx,\n                                              span,\n                                              mode,\n-                                             method_name,\n+                                             item_name,\n                                              steps,\n                                              opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n@@ -221,7 +221,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>,\n            span: Span,\n            mode: Mode,\n-           method_name: ast::Name,\n+           item_name: ast::Name,\n            steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>)\n            -> ProbeContext<'a,'tcx>\n@@ -230,7 +230,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             fcx: fcx,\n             span: span,\n             mode: mode,\n-            method_name: method_name,\n+            item_name: item_name,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: HashSet::new(),\n@@ -387,12 +387,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let method = match impl_method(self.tcx(), impl_def_id, self.method_name) {\n+        let item = match impl_item(self.tcx(), impl_def_id, self.item_name) {\n             Some(m) => m,\n             None => { return; } // No method with correct name on this impl\n         };\n \n-        if !self.has_applicable_self(&*method) {\n+        if !self.has_applicable_self(&item) {\n             // No receiver declared. Not a candidate.\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n@@ -402,11 +402,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // Determine the receiver type that the method itself expects.\n         let xform_self_ty =\n-            self.xform_self_ty(&method, impl_ty, &impl_substs);\n+            self.xform_self_ty(&item, impl_ty, &impl_substs);\n \n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n-            method_ty: method,\n+            item: item,\n             kind: InherentImplCandidate(impl_def_id, impl_substs)\n         });\n     }\n@@ -427,23 +427,23 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n-        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, item, item_num| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n             let vtable_index =\n                 traits::get_vtable_index_of_object_method(tcx,\n                                                           trait_ref.clone(),\n                                                           new_trait_ref.def_id,\n-                                                          method_num);\n+                                                          item_num);\n \n-            let xform_self_ty = this.xform_self_ty(&m,\n+            let xform_self_ty = this.xform_self_ty(&item,\n                                                    new_trait_ref.self_ty(),\n                                                    new_trait_ref.substs);\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: m,\n-                kind: ObjectCandidate(new_trait_ref.def_id, method_num, vtable_index)\n+                item: item,\n+                kind: ObjectCandidate(new_trait_ref.def_id, item_num, vtable_index)\n             });\n         });\n     }\n@@ -476,27 +476,29 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(&bounds, |this, poly_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&bounds, |this, poly_trait_ref, item, item_num| {\n             let trait_ref =\n                 this.erase_late_bound_regions(&poly_trait_ref);\n \n             let xform_self_ty =\n-                this.xform_self_ty(&m,\n+                this.xform_self_ty(&item,\n                                    trait_ref.self_ty(),\n                                    trait_ref.substs);\n \n-            debug!(\"found match: trait_ref={} substs={} m={}\",\n-                   trait_ref.repr(this.tcx()),\n-                   trait_ref.substs.repr(this.tcx()),\n-                   m.repr(this.tcx()));\n-            assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n-            assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n-            assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n-            assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+            if let Some(ref m) = item.as_opt_method() {\n+                debug!(\"found match: trait_ref={} substs={} m={}\",\n+                       trait_ref.repr(this.tcx()),\n+                       trait_ref.substs.repr(this.tcx()),\n+                       m.repr(this.tcx()));\n+                assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n+                           trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n+                assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n+                           trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n+                assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n+                           trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n+                assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n+                           trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+            }\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n@@ -507,8 +509,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: m,\n-                kind: WhereClauseCandidate(poly_trait_ref, method_num)\n+                item: item,\n+                kind: WhereClauseCandidate(poly_trait_ref, item_num)\n             });\n         });\n     }\n@@ -523,25 +525,25 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         F: for<'b> FnMut(\n             &mut ProbeContext<'b, 'tcx>,\n             ty::PolyTraitRef<'tcx>,\n-            Rc<ty::Method<'tcx>>,\n+            ty::ImplOrTraitItem<'tcx>,\n             usize,\n         ),\n     {\n         debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n \n         let tcx = self.tcx();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let (pos, method) = match trait_method(tcx,\n-                                                   bound_trait_ref.def_id(),\n-                                                   self.method_name) {\n+            let (pos, item) = match trait_item(tcx,\n+                                               bound_trait_ref.def_id(),\n+                                               self.item_name) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n \n-            if !self.has_applicable_self(&*method) {\n+            if !self.has_applicable_self(&item) {\n                 self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n             } else {\n-                mk_cand(self, bound_trait_ref, method, pos);\n+                mk_cand(self, bound_trait_ref, item, pos);\n             }\n         }\n     }\n@@ -584,46 +586,43 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             ty::trait_items(self.tcx(), trait_def_id);\n         let matching_index =\n             trait_items.iter()\n-                       .position(|item| item.name() == self.method_name);\n+                       .position(|item| item.name() == self.item_name);\n         let matching_index = match matching_index {\n             Some(i) => i,\n             None => { return Ok(()); }\n         };\n-        let method = match (&*trait_items)[matching_index].as_opt_method() {\n-            Some(m) => m,\n-            None => { return Ok(()); }\n-        };\n+        let ref item = (&*trait_items)[matching_index];\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n-        if !self.has_applicable_self(&*method) {\n+        if !self.has_applicable_self(item) {\n             debug!(\"method has inapplicable self\");\n             self.record_static_candidate(TraitSource(trait_def_id));\n             return Ok(());\n         }\n \n         self.assemble_extension_candidates_for_trait_impls(trait_def_id,\n-                                                           method.clone(),\n+                                                           item.clone(),\n                                                            matching_index);\n \n         try!(self.assemble_closure_candidates(trait_def_id,\n-                                              method.clone(),\n+                                              item.clone(),\n                                               matching_index));\n \n         self.assemble_projection_candidates(trait_def_id,\n-                                            method.clone(),\n+                                            item.clone(),\n                                             matching_index);\n \n         self.assemble_where_clause_candidates(trait_def_id,\n-                                              method,\n+                                              item.clone(),\n                                               matching_index);\n \n         Ok(())\n     }\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: ast::DefId,\n-                                                     method: Rc<ty::Method<'tcx>>,\n-                                                     method_index: usize)\n+                                                     item: ty::ImplOrTraitItem<'tcx>,\n+                                                     item_index: usize)\n     {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n                                                             trait_def_id);\n@@ -657,16 +656,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n-                self.xform_self_ty(&method,\n+                self.xform_self_ty(&item,\n                                    impl_trait_ref.self_ty(),\n                                    impl_trait_ref.substs);\n \n             debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: method.clone(),\n-                kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, method_index)\n+                item: item.clone(),\n+                kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, item_index)\n             });\n         }\n     }\n@@ -689,8 +688,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_closure_candidates(&mut self,\n                                    trait_def_id: ast::DefId,\n-                                   method_ty: Rc<ty::Method<'tcx>>,\n-                                   method_index: usize)\n+                                   item: ty::ImplOrTraitItem<'tcx>,\n+                                   item_index: usize)\n                                    -> Result<(),MethodError>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n@@ -736,13 +735,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                              &trait_def.generics,\n                                                              step.self_ty);\n \n-            let xform_self_ty = self.xform_self_ty(&method_ty,\n+            let xform_self_ty = self.xform_self_ty(&item,\n                                                    step.self_ty,\n                                                    &substs);\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: method_ty.clone(),\n-                kind: ClosureCandidate(trait_def_id, method_index)\n+                item: item.clone(),\n+                kind: ClosureCandidate(trait_def_id, item_index)\n             });\n         }\n \n@@ -751,16 +750,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_projection_candidates(&mut self,\n                                       trait_def_id: ast::DefId,\n-                                      method: Rc<ty::Method<'tcx>>,\n-                                      method_index: usize)\n+                                      item: ty::ImplOrTraitItem<'tcx>,\n+                                      item_index: usize)\n     {\n         debug!(\"assemble_projection_candidates(\\\n                trait_def_id={}, \\\n-               method={}, \\\n-               method_index={})\",\n+               item={}, \\\n+               item_index={})\",\n                trait_def_id.repr(self.tcx()),\n-               method.repr(self.tcx()),\n-               method_index);\n+               item.repr(self.tcx()),\n+               item_index);\n \n         for step in &*self.steps {\n             debug!(\"assemble_projection_candidates: step={}\",\n@@ -792,7 +791,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                        bound.repr(self.tcx()));\n \n                 if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n-                    let xform_self_ty = self.xform_self_ty(&method,\n+                    let xform_self_ty = self.xform_self_ty(&item,\n                                                            bound.self_ty(),\n                                                            bound.substs);\n \n@@ -802,8 +801,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n                     self.extension_candidates.push(Candidate {\n                         xform_self_ty: xform_self_ty,\n-                        method_ty: method.clone(),\n-                        kind: ProjectionCandidate(trait_def_id, method_index)\n+                        item: item.clone(),\n+                        kind: ProjectionCandidate(trait_def_id, item_index)\n                     });\n                 }\n             }\n@@ -812,8 +811,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: ast::DefId,\n-                                        method_ty: Rc<ty::Method<'tcx>>,\n-                                        method_index: usize)\n+                                        item: ty::ImplOrTraitItem<'tcx>,\n+                                        item_index: usize)\n     {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n@@ -824,7 +823,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                           .filter(|b| b.def_id() == trait_def_id)\n         {\n             let bound = self.erase_late_bound_regions(&poly_bound);\n-            let xform_self_ty = self.xform_self_ty(&method_ty,\n+            let xform_self_ty = self.xform_self_ty(&item,\n                                                    bound.self_ty(),\n                                                    bound.substs);\n \n@@ -834,8 +833,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: method_ty.clone(),\n-                kind: WhereClauseCandidate(poly_bound, method_index)\n+                item: item.clone(),\n+                kind: WhereClauseCandidate(poly_bound, item_index)\n             });\n         }\n     }\n@@ -860,7 +859,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         try!(self.assemble_extension_candidates_for_all_traits());\n \n         let out_of_scope_traits = match self.pick_core() {\n-            Some(Ok(p)) => vec![p.method_ty.container.id()],\n+            Some(Ok(p)) => vec![p.item.container().id()],\n             Some(Err(MethodError::Ambiguity(v))) => v.into_iter().map(|source| {\n                 match source {\n                     TraitSource(id) => id,\n@@ -1099,11 +1098,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         // If so, just use this trait and call it a day.\n-        let (trait_def_id, method_num) = trait_data;\n-        let method_ty = probes[0].method_ty.clone();\n+        let (trait_def_id, item_num) = trait_data;\n+        let item = probes[0].item.clone();\n         Some(Pick {\n-            method_ty: method_ty,\n-            kind: TraitPick(trait_def_id, method_num),\n+            item: item,\n+            kind: TraitPick(trait_def_id, item_num),\n             autoderefs: 0,\n             autoref: None,\n             unsize: None\n@@ -1117,39 +1116,49 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.infcx().sub_types(false, infer::Misc(DUMMY_SP), sub, sup)\n     }\n \n-    fn has_applicable_self(&self, method: &ty::Method) -> bool {\n+    fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {\n         // \"fast track\" -- check for usage of sugar\n-        match method.explicit_self {\n-            ty::StaticExplicitSelfCategory => {\n-                if self.mode == Mode::Path {\n-                    return true;\n-                }\n-            }\n-            ty::ByValueExplicitSelfCategory |\n-            ty::ByReferenceExplicitSelfCategory(..) |\n-            ty::ByBoxExplicitSelfCategory => {\n-                return true;\n-            }\n+        match *item {\n+            ty::ImplOrTraitItem::MethodTraitItem(ref method) =>\n+                match method.explicit_self {\n+                    ty::StaticExplicitSelfCategory => self.mode == Mode::Path,\n+                    ty::ByValueExplicitSelfCategory |\n+                    ty::ByReferenceExplicitSelfCategory(..) |\n+                    ty::ByBoxExplicitSelfCategory => true,\n+                },\n+            ty::ImplOrTraitItem::ConstTraitItem(..) => self.mode == Mode::Path,\n+            _ => false,\n         }\n-\n         // FIXME -- check for types that deref to `Self`,\n         // like `Rc<Self>` and so on.\n         //\n         // Note also that the current code will break if this type\n         // includes any of the type parameters defined on the method\n         // -- but this could be overcome.\n-        return false;\n     }\n \n     fn record_static_candidate(&mut self, source: CandidateSource) {\n         self.static_candidates.push(source);\n     }\n \n     fn xform_self_ty(&self,\n-                     method: &Rc<ty::Method<'tcx>>,\n+                     item: &ty::ImplOrTraitItem<'tcx>,\n                      impl_ty: Ty<'tcx>,\n                      substs: &subst::Substs<'tcx>)\n                      -> Ty<'tcx>\n+    {\n+        match item.as_opt_method() {\n+            Some(ref method) => self.xform_method_self_ty(method, impl_ty,\n+                                                          substs),\n+            None => impl_ty,\n+        }\n+    }\n+\n+    fn xform_method_self_ty(&self,\n+                            method: &Rc<ty::Method<'tcx>>,\n+                            impl_ty: Ty<'tcx>,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> Ty<'tcx>\n     {\n         debug!(\"xform_self_ty(impl_ty={}, self_ty={}, substs={})\",\n                impl_ty.repr(self.tcx()),\n@@ -1245,46 +1254,45 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n }\n \n-fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                     impl_def_id: ast::DefId,\n-                     method_name: ast::Name)\n-                     -> Option<Rc<ty::Method<'tcx>>>\n+fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                   impl_def_id: ast::DefId,\n+                   item_name: ast::Name)\n+                   -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n     let impl_items = tcx.impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n         .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n-        .find(|m| m.name() == method_name)\n-        .and_then(|item| item.as_opt_method())\n+        .find(|item| item.name() == item_name)\n }\n \n-/// Find method with name `method_name` defined in `trait_def_id` and return it, along with its\n-/// index (or `None`, if no such method).\n-fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                      trait_def_id: ast::DefId,\n-                      method_name: ast::Name)\n-                      -> Option<(usize, Rc<ty::Method<'tcx>>)>\n+/// Find item with name `item_name` defined in `trait_def_id` and return it,\n+/// along with its index (or `None`, if no such item).\n+fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                    trait_def_id: ast::DefId,\n+                    item_name: ast::Name)\n+                    -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);\n     trait_items\n         .iter()\n         .enumerate()\n-        .find(|&(_, ref item)| item.name() == method_name)\n-        .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+        .find(|&(_, ref item)| item.name() == item_name)\n+        .map(|(num, ref item)| (num, (*item).clone()))\n }\n \n impl<'tcx> Candidate<'tcx> {\n     fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n         Pick {\n-            method_ty: self.method_ty.clone(),\n+            item: self.item.clone(),\n             kind: match self.kind {\n                 InherentImplCandidate(def_id, _) => {\n                     InherentImplPick(def_id)\n                 }\n-                ObjectCandidate(def_id, method_num, real_index) => {\n-                    ObjectPick(def_id, method_num, real_index)\n+                ObjectCandidate(def_id, item_num, real_index) => {\n+                    ObjectPick(def_id, item_num, real_index)\n                 }\n                 ExtensionImplCandidate(def_id, _, _, index) => {\n                     ExtensionImplPick(def_id, index)\n@@ -1323,25 +1331,25 @@ impl<'tcx> Candidate<'tcx> {\n         }\n     }\n \n-    fn to_trait_data(&self) -> Option<(ast::DefId,MethodIndex)> {\n+    fn to_trait_data(&self) -> Option<(ast::DefId, ItemIndex)> {\n         match self.kind {\n             InherentImplCandidate(..) => {\n                 None\n             }\n-            ObjectCandidate(trait_def_id, method_num, _) => {\n-                Some((trait_def_id, method_num))\n+            ObjectCandidate(trait_def_id, item_num, _) => {\n+                Some((trait_def_id, item_num))\n             }\n-            ClosureCandidate(trait_def_id, method_num) => {\n-                Some((trait_def_id, method_num))\n+            ClosureCandidate(trait_def_id, item_num) => {\n+                Some((trait_def_id, item_num))\n             }\n-            ExtensionImplCandidate(_, ref trait_ref, _, method_num) => {\n-                Some((trait_ref.def_id, method_num))\n+            ExtensionImplCandidate(_, ref trait_ref, _, item_num) => {\n+                Some((trait_ref.def_id, item_num))\n             }\n-            WhereClauseCandidate(ref trait_ref, method_num) => {\n-                Some((trait_ref.def_id(), method_num))\n+            WhereClauseCandidate(ref trait_ref, item_num) => {\n+                Some((trait_ref.def_id(), item_num))\n             }\n-            ProjectionCandidate(trait_def_id, method_num) => {\n-                Some((trait_def_id, method_num))\n+            ProjectionCandidate(trait_def_id, item_num) => {\n+                Some((trait_def_id, item_num))\n             }\n         }\n     }\n@@ -1392,9 +1400,9 @@ impl<'tcx> Repr<'tcx> for PickKind<'tcx> {\n \n impl<'tcx> Repr<'tcx> for Pick<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Pick(method_ty={}, autoderefs={},\n+        format!(\"Pick(item={}, autoderefs={},\n                  autoref={}, unsize={}, kind={:?})\",\n-                self.method_ty.repr(tcx),\n+                self.item.repr(tcx),\n                 self.autoderefs,\n                 self.autoref.repr(tcx),\n                 self.unsize.repr(tcx),"}, {"sha": "d04205666f2eae69a1c6604aeb4c7447da117b22", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 100, "deletions": 23, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -78,7 +78,7 @@ type parameter).\n \n pub use self::LvaluePreference::*;\n pub use self::Expectation::*;\n-pub use self::compare_method::compare_impl_method;\n+pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n@@ -808,7 +808,9 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n \n         for impl_item in impl_items {\n             match impl_item.node {\n-                ast::ConstImplItem(_, _) => {}\n+                ast::ConstImplItem(_, ref expr) => {\n+                    check_const(ccx, impl_item.span, &*expr, impl_item.id)\n+                }\n                 ast::MethodImplItem(ref sig, ref body) => {\n                     check_method_body(ccx, &impl_pty.generics, sig, body,\n                                       impl_item.id, impl_item.span);\n@@ -824,15 +826,15 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n-                ast::ConstTraitItem(_, _) => {}\n-                ast::MethodTraitItem(_, None) => {\n-                    // Nothing to do, since required methods don't have\n-                    // bodies to check.\n+                ast::ConstTraitItem(_, Some(ref expr)) => {\n+                    check_const(ccx, trait_item.span, &*expr, trait_item.id)\n                 }\n                 ast::MethodTraitItem(ref sig, Some(ref body)) => {\n                     check_method_body(ccx, &trait_def.generics, sig, body,\n                                       trait_item.id, trait_item.span);\n                 }\n+                ast::ConstTraitItem(_, None) |\n+                ast::MethodTraitItem(_, None) |\n                 ast::TypeTraitItem(..) => {\n                     // Nothing to do.\n                 }\n@@ -922,7 +924,48 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // and compatible with trait signature\n     for impl_item in impl_items {\n         match impl_item.node {\n-            ast::ConstImplItem(_, _) => {}\n+            ast::ConstImplItem(..) => {\n+                let impl_const_def_id = local_def(impl_item.id);\n+                let impl_const_ty = ty::impl_or_trait_item(ccx.tcx,\n+                                                           impl_const_def_id);\n+\n+                // Find associated const definition.\n+                let opt_associated_const =\n+                    trait_items.iter()\n+                               .find(|ac| ac.name() == impl_const_ty.name());\n+                match opt_associated_const {\n+                    Some(associated_const) => {\n+                        match (associated_const, &impl_const_ty) {\n+                            (&ty::ConstTraitItem(ref const_trait),\n+                             &ty::ConstTraitItem(ref const_impl)) => {\n+                                compare_const_impl(ccx.tcx,\n+                                                   &const_impl,\n+                                                   impl_item.span,\n+                                                   &const_trait,\n+                                                   &*impl_trait_ref);\n+                            }\n+                            _ => {\n+                                span_err!(tcx.sess, impl_item.span, E0323,\n+                                          \"item `{}` is an associated const, \\\n+                                          which doesn't match its trait `{}`\",\n+                                          token::get_name(impl_const_ty.name()),\n+                                          impl_trait_ref.repr(tcx))\n+                            }\n+                        }\n+                    }\n+                    None => {\n+                        // This is `span_bug` as it should have already been\n+                        // caught in resolve.\n+                        tcx.sess.span_bug(\n+                            impl_item.span,\n+                            &format!(\n+                                \"associated const `{}` is not a member of \\\n+                                 trait `{}`\",\n+                                token::get_name(impl_const_ty.name()),\n+                                impl_trait_ref.repr(tcx)));\n+                    }\n+                }\n+            }\n             ast::MethodImplItem(_, ref body) => {\n                 let impl_method_def_id = local_def(impl_item.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n@@ -946,13 +989,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     &*impl_trait_ref);\n                             }\n                             _ => {\n-                                // This is span_bug as it should have already been\n-                                // caught in resolve.\n-                                tcx.sess.span_bug(\n-                                    impl_item.span,\n-                                    &format!(\"item `{}` is of a different kind from its trait `{}`\",\n-                                             token::get_name(impl_item_ty.name()),\n-                                             impl_trait_ref.repr(tcx)));\n+                                span_err!(tcx.sess, impl_item.span, E0324,\n+                                          \"item `{}` is an associated method, \\\n+                                          which doesn't match its trait `{}`\",\n+                                          token::get_name(impl_item_ty.name()),\n+                                          impl_trait_ref.repr(tcx))\n                             }\n                         }\n                     }\n@@ -982,11 +1023,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         match (associated_type, &typedef_ty) {\n                             (&ty::TypeTraitItem(_), &ty::TypeTraitItem(_)) => {}\n                             _ => {\n-                                // Formerly `span_bug`, but it turns out that\n-                                // this is not checked in resolve, so this is\n-                                // the first place where we'll notice the\n-                                // mismatch.\n-                                span_err!(tcx.sess, impl_item.span, E0323,\n+                                span_err!(tcx.sess, impl_item.span, E0325,\n                                           \"item `{}` is an associated type, \\\n                                           which doesn't match its trait `{}`\",\n                                           token::get_name(typedef_ty.name()),\n@@ -1014,10 +1051,27 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Check for missing items from trait\n     let provided_methods = ty::provided_trait_methods(tcx, impl_trait_ref.def_id);\n+    let associated_consts = ty::associated_consts(tcx, impl_trait_ref.def_id);\n     let mut missing_methods = Vec::new();\n     for trait_item in &*trait_items {\n         match *trait_item {\n-            ty::ConstTraitItem(_) => {}\n+            ty::ConstTraitItem(ref associated_const) => {\n+                let is_implemented = impl_items.iter().any(|ii| {\n+                    match ii.node {\n+                        ast::ConstImplItem(..) => {\n+                            ii.ident.name == associated_const.name\n+                        }\n+                        _ => false,\n+                    }\n+                });\n+                let is_provided =\n+                    associated_consts.iter().any(|ac| ac.default.is_some() &&\n+                                                 ac.name == associated_const.name);\n+                if !is_implemented && !is_provided {\n+                    missing_methods.push(format!(\"`{}`\",\n+                                                 token::get_name(associated_const.name)));\n+                }\n+            }\n             ty::MethodTraitItem(ref trait_method) => {\n                 let is_implemented =\n                     impl_items.iter().any(|ii| {\n@@ -4254,7 +4308,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Luckily, we can (at least for now) deduce the intermediate steps\n     // just from the end-point.\n     //\n-    // There are basically three cases to consider:\n+    // There are basically four cases to consider:\n     //\n     // 1. Reference to a *type*, such as a struct or enum:\n     //\n@@ -4304,6 +4358,16 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n     //    final segment, `foo::<B>` contains parameters in fn space.\n     //\n+    // 4. Reference to an *associated const*:\n+    //\n+    // impl<A> AnotherStruct<A> {\n+    // const FOO: B = BAR;\n+    // }\n+    //\n+    // The path in this case will look like\n+    // `a::b::AnotherStruct::<A>::FOO`, so the penultimate segment\n+    // only will have parameters in TypeSpace.\n+    //\n     // The first step then is to categorize the segments appropriately.\n \n     assert!(!segments.is_empty());\n@@ -4355,8 +4419,21 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         }\n \n-        def::DefAssociatedConst(..) => {\n-            segment_spaces = repeat(None).take(segments.len()).collect();\n+        def::DefAssociatedConst(_, provenance) => {\n+            match provenance {\n+                def::FromTrait(trait_did) => {\n+                    callee::check_legal_trait_for_method_call(fcx.ccx, span, trait_did)\n+                }\n+                def::FromImpl(_) => {}\n+            }\n+\n+            if segments.len() >= 2 {\n+                segment_spaces = repeat(None).take(segments.len() - 2).collect();\n+                segment_spaces.push(Some(subst::TypeSpace));\n+                segment_spaces.push(None);\n+            } else {\n+                segment_spaces = vec![None];\n+            }\n         }\n \n         // Other cases. Various nonsense that really shouldn't show up"}, {"sha": "8bb0596753c7b1fb00a1b0afdf8985c1dac0d47f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -691,11 +691,37 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n+fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                      container: ImplOrTraitItemContainer,\n+                                      ident: ast::Ident,\n+                                      id: ast::NodeId,\n+                                      vis: ast::Visibility,\n+                                      ty: ty::Ty<'tcx>,\n+                                      default: Option<&ast::Expr>)\n+{\n+    ccx.tcx.predicates.borrow_mut().insert(local_def(id),\n+                                           ty::GenericPredicates::empty());\n+\n+    write_ty_to_tcx(ccx.tcx, id, ty);\n+    let default_id = default.map(|expr| local_def(expr.id));\n+\n+    let associated_const = Rc::new(ty::AssociatedConst {\n+        name: ident.name,\n+        vis: vis,\n+        def_id: local_def(id),\n+        container: container,\n+        ty: ty,\n+        default: default_id,\n+    });\n+    ccx.tcx.impl_or_trait_items.borrow_mut()\n+       .insert(local_def(id), ty::ConstTraitItem(associated_const));\n+}\n+\n fn as_refsociated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                     container: ImplOrTraitItemContainer,\n-                                     ident: ast::Ident,\n-                                     id: ast::NodeId,\n-                                     vis: ast::Visibility)\n+                                 container: ImplOrTraitItemContainer,\n+                                 ident: ast::Ident,\n+                                 id: ast::NodeId,\n+                                 vis: ast::Visibility)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: ident.name,\n@@ -828,6 +854,23 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n+            // Convert all the associated consts.\n+            for impl_item in impl_items {\n+                if let ast::ConstImplItem(ref ty, ref expr) = impl_item.node {\n+                    let ty = ccx.icx(&ty_predicates)\n+                                .to_ty(&ExplicitRscope, &*ty);\n+                    tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n+                                                   TypeScheme {\n+                                                       generics: ty_generics.clone(),\n+                                                       ty: ty,\n+                                                   });\n+                    convert_associated_const(ccx, ImplContainer(local_def(it.id)),\n+                                             impl_item.ident, impl_item.id,\n+                                             impl_item.vis.inherit_from(parent_visibility),\n+                                             ty, Some(&*expr));\n+                }\n+            }\n+\n             // Convert all the associated types.\n             for impl_item in impl_items {\n                 if let ast::TypeImplItem(ref ty) = impl_item.node {\n@@ -906,6 +949,25 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n+            // Convert all the associated types.\n+            for trait_item in trait_items {\n+                match trait_item.node {\n+                    ast::ConstTraitItem(ref ty, ref default) => {\n+                        let ty = ccx.icx(&trait_predicates)\n+                                    .to_ty(&ExplicitRscope, ty);\n+                        tcx.tcache.borrow_mut().insert(local_def(trait_item.id),\n+                                                       TypeScheme {\n+                                                           generics: trait_def.generics.clone(),\n+                                                           ty: ty,\n+                                                       });\n+                        convert_associated_const(ccx, TraitContainer(local_def(it.id)),\n+                                                 trait_item.ident, trait_item.id,\n+                                                 ast::Public, ty, default.as_ref().map(|d| &**d));\n+                    }\n+                    _ => {}\n+                }\n+            };\n+\n             // Convert all the associated types.\n             for trait_item in trait_items {\n                 match trait_item.node {"}, {"sha": "a4814b36fe5b100977cb23ca7f6cb3cc4abb1ccb", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -176,7 +176,10 @@ register_diagnostics! {\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n     E0322, // cannot implement Sized explicitly\n-    E0323, // implemented trait where method should have been provided\n+    E0323, // implemented an associated const when another trait item expected\n+    E0324, // implemented a method when another trait item expected\n+    E0325, // implemented an associated type when another trait item expected\n+    E0326, // associated const implemented with different type from trait\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0368, // binary operation `<op>=` cannot be applied to types"}, {"sha": "0d59577a6d802ce1552cd45cf9267dad1c06f9f5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -22,12 +22,13 @@ use rustc::middle::def;\n use rustc::middle::ty;\n use rustc::middle::subst;\n use rustc::middle::stability;\n+use rustc::middle::const_eval;\n \n use core::DocContext;\n use doctree;\n use clean;\n \n-use super::Clean;\n+use super::{Clean, ToSource};\n \n /// Attempt to inline the definition of a local node id into this AST.\n ///\n@@ -106,7 +107,7 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n             record_extern_fqn(cx, did, clean::TypeStatic);\n             clean::StaticItem(build_static(cx, tcx, did, mtbl))\n         }\n-        def::DefConst(did) => {\n+        def::DefConst(did) | def::DefAssociatedConst(did, _) => {\n             record_extern_fqn(cx, did, clean::TypeConst);\n             clean::ConstantItem(build_const(cx, tcx, did))\n         }\n@@ -312,7 +313,27 @@ pub fn build_impl(cx: &DocContext,\n         let did = did.def_id();\n         let impl_item = ty::impl_or_trait_item(tcx, did);\n         match impl_item {\n-            ty::ConstTraitItem(_) => { return None }\n+            ty::ConstTraitItem(ref assoc_const) => {\n+                let did = assoc_const.def_id;\n+                let type_scheme = ty::lookup_item_type(tcx, did);\n+                let default = match assoc_const.default {\n+                    Some(_) => Some(const_eval::lookup_const_by_id(tcx, did, None)\n+                                               .unwrap().span.to_src(cx)),\n+                    None => None,\n+                };\n+                Some(clean::Item {\n+                    name: Some(assoc_const.name.clean(cx)),\n+                    inner: clean::AssociatedConstItem(\n+                        type_scheme.ty.clean(cx),\n+                        default,\n+                    ),\n+                    source: clean::Span::empty(),\n+                    attrs: vec![],\n+                    visibility: None,\n+                    stability: stability::lookup(tcx, did).clean(cx),\n+                    def_id: did\n+                })\n+            }\n             ty::MethodTraitItem(method) => {\n                 if method.vis != ast::Public && associated_trait.is_none() {\n                     return None\n@@ -444,7 +465,7 @@ fn build_const(cx: &DocContext, tcx: &ty::ctxt,\n     use rustc::middle::const_eval;\n     use syntax::print::pprust;\n \n-    let expr = const_eval::lookup_const_by_id(tcx, did).unwrap_or_else(|| {\n+    let expr = const_eval::lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n     debug!(\"converting constant expr {:?} to snippet\", expr);"}, {"sha": "3d1e47345d42fd61fa9ae7881c147d4f4e4322c5", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -1904,6 +1904,17 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     Ok(())\n }\n \n+fn assoc_const(w: &mut fmt::Formatter, it: &clean::Item,\n+               ty: &clean::Type, default: &Option<String>)\n+               -> fmt::Result {\n+    try!(write!(w, \"const {}\", it.name.as_ref().unwrap()));\n+    try!(write!(w, \": {}\", ty));\n+    if let Some(ref default) = *default {\n+        try!(write!(w, \" = {}\", default));\n+    }\n+    Ok(())\n+}\n+\n fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n               bounds: &Vec<clean::TyParamBound>,\n               default: &Option<clean::Type>)\n@@ -1959,7 +1970,9 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n             method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl,\n                    link)\n         }\n-        clean::AssociatedConstItem(_, _) => Ok(()),\n+        clean::AssociatedConstItem(ref ty, ref default) => {\n+            assoc_const(w, meth, ty, default)\n+        }\n         clean::AssociatedTypeItem(ref bounds, ref default) => {\n             assoc_type(w, meth, bounds, default)\n         }\n@@ -2319,7 +2332,14 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n-            clean::AssociatedConstItem(_, _) => {}\n+            clean::AssociatedConstItem(ref ty, ref default) => {\n+                let name = item.name.as_ref().unwrap();\n+                try!(write!(w, \"<h4 id='assoc_const.{}' class='{}'><code>\",\n+                            *name,\n+                            shortty(item)));\n+                try!(assoc_const(w, item, ty, default));\n+                try!(write!(w, \"</code></h4>\\n\"));\n+            }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let name = item.name.as_ref().unwrap();\n                 try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'><code>\","}, {"sha": "9a1c963b8eb0b805bc2b0b50e59ecc5f8151d51d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -17,8 +17,8 @@ use ast::{Public, Unsafety};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, BiGt, Block};\n use ast::{BlockCheckMode, CaptureByRef, CaptureByValue, CaptureClause};\n-use ast::{Crate, CrateConfig, Decl, DeclItem};\n-use ast::{DeclLocal, DefaultBlock, DefaultReturn};\n+use ast::{ConstImplItem, ConstTraitItem, Crate, CrateConfig};\n+use ast::{Decl, DeclItem, DeclLocal, DefaultBlock, DefaultReturn};\n use ast::{UnDeref, BiDiv, EMPTY_CTXT, EnumDef, ExplicitSelf};\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n@@ -1158,6 +1158,20 @@ impl<'a> Parser<'a> {\n                 let TyParam {ident, bounds, default, ..} = try!(p.parse_ty_param());\n                 try!(p.expect(&token::Semi));\n                 (ident, TypeTraitItem(bounds, default))\n+            } else if try!(p.eat_keyword(keywords::Const)) {\n+                let ident = try!(p.parse_ident());\n+                try!(p.expect(&token::Colon));\n+                let ty = try!(p.parse_ty_sum());\n+                let default = if p.check(&token::Eq) {\n+                    try!(p.bump());\n+                    let expr = try!(p.parse_expr_nopanic());\n+                    try!(p.commit_expr_expecting(&expr, token::Semi));\n+                    Some(expr)\n+                } else {\n+                    try!(p.expect(&token::Semi));\n+                    None\n+                };\n+                (ident, ConstTraitItem(ty, default))\n             } else {\n                 let style = try!(p.parse_unsafety());\n                 let abi = if try!(p.eat_keyword(keywords::Extern)) {\n@@ -4313,6 +4327,14 @@ impl<'a> Parser<'a> {\n             let typ = try!(self.parse_ty_sum());\n             try!(self.expect(&token::Semi));\n             (name, TypeImplItem(typ))\n+        } else if try!(self.eat_keyword(keywords::Const)) {\n+            let name = try!(self.parse_ident());\n+            try!(self.expect(&token::Colon));\n+            let typ = try!(self.parse_ty_sum());\n+            try!(self.expect(&token::Eq));\n+            let expr = try!(self.parse_expr_nopanic());\n+            try!(self.commit_expr_expecting(&expr, token::Semi));\n+            (name, ConstImplItem(typ, expr))\n         } else {\n             let (name, inner_attrs, node) = try!(self.parse_impl_method(vis));\n             attrs.extend(inner_attrs.into_iter());"}, {"sha": "4cfb9e4147a9550d7288e8cd145d3ae22dd8b77e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -796,6 +796,26 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    fn print_associated_const(&mut self,\n+                              ident: ast::Ident,\n+                              ty: &ast::Ty,\n+                              default: Option<&ast::Expr>,\n+                              vis: ast::Visibility)\n+                              -> io::Result<()>\n+    {\n+        try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n+        try!(self.word_space(\"const\"));\n+        try!(self.print_ident(ident));\n+        try!(self.word_space(\":\"));\n+        try!(self.print_type(ty));\n+        if let Some(expr) = default {\n+            try!(space(&mut self.s));\n+            try!(self.word_space(\"=\"));\n+            try!(self.print_expr(expr));\n+        }\n+        word(&mut self.s, \";\")\n+    }\n+\n     fn print_associated_type(&mut self,\n                              ident: ast::Ident,\n                              bounds: Option<&ast::TyParamBounds>,\n@@ -1269,7 +1289,11 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ti.span.lo));\n         try!(self.print_outer_attributes(&ti.attrs));\n         match ti.node {\n-            ast::ConstTraitItem(_, _) => Ok(()),\n+            ast::ConstTraitItem(ref ty, ref default) => {\n+                try!(self.print_associated_const(ti.ident, &ty,\n+                                                 default.as_ref().map(|expr| &**expr),\n+                                                 ast::Inherited));\n+            }\n             ast::MethodTraitItem(ref sig, ref body) => {\n                 if body.is_some() {\n                     try!(self.head(\"\"));\n@@ -1296,7 +1320,9 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ii.span.lo));\n         try!(self.print_outer_attributes(&ii.attrs));\n         match ii.node {\n-            ast::ConstImplItem(_, _) => Ok(()),\n+            ast::ConstImplItem(ref ty, ref expr) => {\n+                try!(self.print_associated_const(ii.ident, &ty, Some(&expr), ii.vis));\n+            }\n             ast::MethodImplItem(ref sig, ref body) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_method_sig(ii.ident, sig, ii.vis));"}, {"sha": "1d74873a5d50bb53dc7c06283553d20d27892dae", "filename": "src/test/compile-fail/associated-const-private-impl.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+mod bar1 {\n+    pub use self::bar2::Foo;\n+    mod bar2 {\n+        pub struct Foo;\n+\n+        impl Foo {\n+            const ID: i32 = 1;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(1, bar1::Foo::ID);\n+    //~^ERROR associated const `ID` is private\n+}"}, {"sha": "eb75b82424d71167b71d97dc68389a3159cb0b9a", "filename": "src/test/compile-fail/impl-type-where-trait-has-method.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fcompile-fail%2Fimpl-type-where-trait-has-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fcompile-fail%2Fimpl-type-where-trait-has-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-type-where-trait-has-method.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+impl Foo for u32 {\n+    //~^ ERROR not all trait items implemented, missing: `bar`\n+    type bar = u64;\n+    //~^ ERROR item `bar` is an associated type, which doesn't match its trait `Foo`\n+}\n+\n+fn main () {}"}, {"sha": "be6bd516d6fe439388160260d61fc3c4f824d302", "filename": "src/test/parse-fail/issue-20711-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -16,6 +16,6 @@ impl Foo {\n     fn foo() {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n+} //~ ERROR expected one of `const`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n \n fn main() {}"}, {"sha": "d1d8d3acf91871bc581d3799380a47aca6d1126f", "filename": "src/test/parse-fail/issue-20711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-20711.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -14,6 +14,6 @@ struct Foo;\n \n impl Foo {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n+} //~ ERROR expected one of `const`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n \n fn main() {}"}, {"sha": "76a4687f544da3578a553d654818dd5783e9506e", "filename": "src/test/parse-fail/issue-21153.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-21153.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -11,5 +11,5 @@\n // compile-flags: -Z parse-only\n \n trait MyTrait<T>: Iterator {\n-    Item = T; //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `Item`\n+    Item = T; //~ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `Item`\n }"}, {"sha": "7b6caad86b6ccc0b6005dc41c869648a065650ec", "filename": "src/test/parse-fail/removed-syntax-static-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -14,5 +14,5 @@ struct S;\n \n impl S {\n     static fn f() {}\n-    //~^ ERROR expected one of `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `static`\n }\n+//~^^ ERROR expected one of `const`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `static`"}, {"sha": "adce0d7bbf4b62cee86f61ce85758ea11d468aa0", "filename": "src/test/parse-fail/trait-pub-assoc-const.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    pub const Foo: u32;\n+     //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+}\n+\n+fn main() {}"}, {"sha": "dab6c433aba4c187fac25a0323d0438332d4af96", "filename": "src/test/parse-fail/trait-pub-assoc-ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n trait Foo {\n-    pub type Foo; //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+    pub type Foo;\n+    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n }\n \n fn main() {}"}, {"sha": "7cb9363830c43ab28b3d9f3089ba3b86d583d0b4", "filename": "src/test/parse-fail/trait-pub-method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n trait Foo {\n-    pub fn foo(); //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+    pub fn foo();\n+    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n }\n \n fn main() {}"}, {"sha": "71f7a925d55d94681d8c32779281a1724da9f07e", "filename": "src/test/run-pass/associated-const-inherent-impl.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-inherent-impl.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+impl Foo {\n+    const ID: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, Foo::ID);\n+}"}, {"sha": "26ece859e143d4ea655c8c916c81d322c8f90661", "filename": "src/test/run-pass/associated-const-overwrite-default.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-overwrite-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-overwrite-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-overwrite-default.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+trait Foo: MarkerTrait {\n+    const ID: i32 = 2;\n+}\n+\n+impl Foo for i32 {\n+    const ID: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, <i32 as Foo>::ID);\n+}"}, {"sha": "08676425a514d0bb103926ed168a8151aeccc7ff", "filename": "src/test/run-pass/associated-const-public-impl.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-public-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-public-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-public-impl.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+mod bar1 {\n+    pub use self::bar2::Foo;\n+    mod bar2 {\n+        pub struct Foo;\n+\n+        impl Foo {\n+            pub const ID: i32 = 1;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(1, bar1::Foo::ID);\n+}"}, {"sha": "b4fb452e020032f108a95110ef739aa43f7f398b", "filename": "src/test/run-pass/associated-const-self-type.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-self-type.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+trait MyInt: MarkerTrait {\n+    const ONE: Self;\n+}\n+\n+impl MyInt for i32 {\n+    const ONE: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, <i32>::ONE);\n+}"}, {"sha": "21e1159366d5aaf7827b1579ff48fbf5347d171a", "filename": "src/test/run-pass/associated-const-ufcs-infer-trait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-ufcs-infer-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-ufcs-infer-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-ufcs-infer-trait.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+trait Foo: MarkerTrait {\n+    const ID: i32;\n+}\n+\n+impl Foo for i32 {\n+    const ID: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, <i32>::ID);\n+}"}, {"sha": "59c83e267dbe1ec7b5f87c5247deed9f4d6787b5", "filename": "src/test/run-pass/associated-const-use-default.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-use-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const-use-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-use-default.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+trait Foo: MarkerTrait {\n+    const ID: i32 = 1;\n+}\n+\n+impl Foo for i32 {}\n+\n+fn main() {\n+    assert_eq!(1, <i32 as Foo>::ID);\n+}"}, {"sha": "5e7cc12cf485b41005e79aceea0a295a4561e37d", "filename": "src/test/run-pass/associated-const.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7129e8815e3203ceae5bb85b0faa8e8753e520e3/src%2Ftest%2Frun-pass%2Fassociated-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const.rs?ref=7129e8815e3203ceae5bb85b0faa8e8753e520e3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+trait Foo: MarkerTrait {\n+    const ID: i32;\n+}\n+\n+impl Foo for i32 {\n+    const ID: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, <i32 as Foo>::ID);\n+}"}]}