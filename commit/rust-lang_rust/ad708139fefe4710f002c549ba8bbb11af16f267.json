{"sha": "ad708139fefe4710f002c549ba8bbb11af16f267", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNzA4MTM5ZmVmZTQ3MTBmMDAyYzU0OWJhOGJiYjExYWYxNmYyNjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-12T12:46:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-12T12:46:42Z"}, "message": "auto merge of #7706 : sanxiyn/rust/qualification-lint, r=pcwalton\n\nFix #2551.\r\n\r\nLint is off by default because I didn't bother to fix all of std and extra.", "tree": {"sha": "928eb90035b457fc241f1998dfdea84bb140db6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/928eb90035b457fc241f1998dfdea84bb140db6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad708139fefe4710f002c549ba8bbb11af16f267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad708139fefe4710f002c549ba8bbb11af16f267", "html_url": "https://github.com/rust-lang/rust/commit/ad708139fefe4710f002c549ba8bbb11af16f267", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad708139fefe4710f002c549ba8bbb11af16f267/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f67935257b19b0904b282c949770d85089fdcf3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f67935257b19b0904b282c949770d85089fdcf3c", "html_url": "https://github.com/rust-lang/rust/commit/f67935257b19b0904b282c949770d85089fdcf3c"}, {"sha": "f20c78c984d0e93d94420c9bddf17c06303de6e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f20c78c984d0e93d94420c9bddf17c06303de6e7", "html_url": "https://github.com/rust-lang/rust/commit/f20c78c984d0e93d94420c9bddf17c06303de6e7"}], "stats": {"total": 89, "additions": 63, "deletions": 26}, "files": [{"sha": "8074b5b3b40abec9138f58bc53a985c0c4fd9c29", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad708139fefe4710f002c549ba8bbb11af16f267/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad708139fefe4710f002c549ba8bbb11af16f267/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=ad708139fefe4710f002c549ba8bbb11af16f267", "patch": "@@ -71,6 +71,7 @@ use syntax::{ast, visit, ast_util};\n pub enum lint {\n     ctypes,\n     unused_imports,\n+    unnecessary_qualification,\n     while_true,\n     path_statement,\n     implicit_copies,\n@@ -148,6 +149,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n      }),\n \n+    (\"unnecessary_qualification\",\n+     LintSpec {\n+        lint: unnecessary_qualification,\n+        desc: \"detects unnecessarily qualified names\",\n+        default: allow\n+     }),\n+\n     (\"while_true\",\n      LintSpec {\n         lint: while_true,\n@@ -557,11 +565,7 @@ fn item_stopping_visitor<E: Copy>(outer: visit::vt<E>) -> visit::vt<E> {\n                 _ => (outer.visit_fn)(fk, fd, b, s, id, (e, v))\n             }\n         },\n-    .. **(ty_stopping_visitor(outer))})\n-}\n-\n-fn ty_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n-    visit::mk_vt(@visit::Visitor {visit_ty: |_t, (_e, _v)| { },.. **v})\n+    .. **outer})\n }\n \n fn lint_while_true() -> visit::vt<@mut Context> {"}, {"sha": "619bfbdb5478415bad9e5e8b289c89b04ff57d47", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ad708139fefe4710f002c549ba8bbb11af16f267/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad708139fefe4710f002c549ba8bbb11af16f267/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ad708139fefe4710f002c549ba8bbb11af16f267", "patch": "@@ -17,7 +17,7 @@ use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n use middle::lang_items::LanguageItems;\n-use middle::lint::unused_imports;\n+use middle::lint::{unnecessary_qualification, unused_imports};\n use middle::pat_util::pat_bindings;\n \n use syntax::ast::*;\n@@ -3561,7 +3561,7 @@ impl Resolver {\n \n                     // Resolve derived traits.\n                     for traits.iter().advance |trt| {\n-                        self.resolve_trait_reference(trt, visitor, TraitDerivation);\n+                        self.resolve_trait_reference(item.id, trt, visitor, TraitDerivation);\n                     }\n \n                     for (*methods).iter().advance |method| {\n@@ -3802,27 +3802,29 @@ impl Resolver {\n                                    visitor: ResolveVisitor) {\n         for type_parameters.iter().advance |type_parameter| {\n             for type_parameter.bounds.iter().advance |bound| {\n-                self.resolve_type_parameter_bound(bound, visitor);\n+                self.resolve_type_parameter_bound(type_parameter.id, bound, visitor);\n             }\n         }\n     }\n \n     pub fn resolve_type_parameter_bound(@mut self,\n+                                        id: node_id,\n                                         type_parameter_bound: &TyParamBound,\n                                         visitor: ResolveVisitor) {\n         match *type_parameter_bound {\n             TraitTyParamBound(ref tref) => {\n-                self.resolve_trait_reference(tref, visitor, TraitBoundingTypeParameter)\n+                self.resolve_trait_reference(id, tref, visitor, TraitBoundingTypeParameter)\n             }\n             RegionTyParamBound => {}\n         }\n     }\n \n     pub fn resolve_trait_reference(@mut self,\n+                                   id: node_id,\n                                    trait_reference: &trait_ref,\n                                    visitor: ResolveVisitor,\n                                    reference_type: TraitReferenceType) {\n-        match self.resolve_path(&trait_reference.path, TypeNS, true, visitor) {\n+        match self.resolve_path(id, &trait_reference.path, TypeNS, true, visitor) {\n             None => {\n                 let path_str = self.idents_to_str(trait_reference.path.idents);\n \n@@ -3930,7 +3932,8 @@ impl Resolver {\n             let original_trait_refs;\n             match opt_trait_reference {\n                 &Some(ref trait_reference) => {\n-                    self.resolve_trait_reference(trait_reference, visitor, TraitImplementation);\n+                    self.resolve_trait_reference(id, trait_reference, visitor,\n+                        TraitImplementation);\n \n                     // Record the current set of trait references.\n                     let mut new_trait_refs = ~[];\n@@ -4142,7 +4145,7 @@ impl Resolver {\n \n                 match result_def {\n                     None => {\n-                        match self.resolve_path(path, TypeNS, true, visitor) {\n+                        match self.resolve_path(ty.id, path, TypeNS, true, visitor) {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `%s` to \\\n                                         type %?\",\n@@ -4179,15 +4182,15 @@ impl Resolver {\n \n                 do bounds.map |bound_vec| {\n                     for bound_vec.iter().advance |bound| {\n-                        self.resolve_type_parameter_bound(bound, visitor);\n+                        self.resolve_type_parameter_bound(ty.id, bound, visitor);\n                     }\n                 };\n             }\n \n             ty_closure(c) => {\n                 do c.bounds.map |bounds| {\n                     for bounds.iter().advance |bound| {\n-                        self.resolve_type_parameter_bound(bound, visitor);\n+                        self.resolve_type_parameter_bound(ty.id, bound, visitor);\n                     }\n                 };\n                 visit_ty(ty, ((), visitor));\n@@ -4340,7 +4343,7 @@ impl Resolver {\n \n                 pat_ident(binding_mode, ref path, _) => {\n                     // This must be an enum variant, struct, or constant.\n-                    match self.resolve_path(path, ValueNS, false, visitor) {\n+                    match self.resolve_path(pat_id, path, ValueNS, false, visitor) {\n                         Some(def @ def_variant(*)) |\n                                 Some(def @ def_struct(*)) => {\n                             self.record_def(pattern.id, def);\n@@ -4373,7 +4376,7 @@ impl Resolver {\n \n                 pat_enum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n-                    match self.resolve_path(path, ValueNS, false, visitor) {\n+                    match self.resolve_path(pat_id, path, ValueNS, false, visitor) {\n                         Some(def @ def_fn(*))      |\n                         Some(def @ def_variant(*)) |\n                         Some(def @ def_struct(*))  |\n@@ -4410,7 +4413,7 @@ impl Resolver {\n                 }\n \n                 pat_struct(ref path, _, _) => {\n-                    match self.resolve_path(path, TypeNS, false, visitor) {\n+                    match self.resolve_path(pat_id, path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n                                 if self.structs.contains(&class_id) => {\n                             let class_def = def_struct(class_id);\n@@ -4484,6 +4487,7 @@ impl Resolver {\n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n     pub fn resolve_path(@mut self,\n+                        id: node_id,\n                         path: &Path,\n                         namespace: Namespace,\n                         check_ribs: bool,\n@@ -4500,16 +4504,24 @@ impl Resolver {\n                                                     namespace);\n         }\n \n+        let unqualified_def = self.resolve_identifier(\n+            *path.idents.last(), namespace, check_ribs, path.span);\n+\n         if path.idents.len() > 1 {\n-            return self.resolve_module_relative_path(path,\n-                                                     self.xray_context,\n-                                                     namespace);\n+            let def = self.resolve_module_relative_path(\n+                path, self.xray_context, namespace);\n+            match (def, unqualified_def) {\n+                (Some(d), Some(ud)) if d == ud => {\n+                    self.session.add_lint(unnecessary_qualification,\n+                                          id, path.span,\n+                                          ~\"unnecessary qualification\");\n+                }\n+                _ => ()\n+            }\n+            return def;\n         }\n \n-        return self.resolve_identifier(*path.idents.last(),\n-                                       namespace,\n-                                       check_ribs,\n-                                       path.span);\n+        return unqualified_def;\n     }\n \n     pub fn resolve_identifier(@mut self,\n@@ -4920,7 +4932,7 @@ impl Resolver {\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n \n-                match self.resolve_path(path, ValueNS, true, visitor) {\n+                match self.resolve_path(expr.id, path, ValueNS, true, visitor) {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `%s`\",\n@@ -4987,7 +4999,7 @@ impl Resolver {\n \n             expr_struct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to.\n-                match self.resolve_path(path, TypeNS, false, visitor) {\n+                match self.resolve_path(expr.id, path, TypeNS, false, visitor) {\n                     Some(def_ty(class_id)) | Some(def_struct(class_id))\n                             if self.structs.contains(&class_id) => {\n                         let class_def = def_struct(class_id);"}, {"sha": "35ae45af392530b7e5a5bec9569a2bc2b3289d72", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad708139fefe4710f002c549ba8bbb11af16f267/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad708139fefe4710f002c549ba8bbb11af16f267/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ad708139fefe4710f002c549ba8bbb11af16f267", "patch": "@@ -462,6 +462,7 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n         },\n \n         visit_ty: |ty, (t, vt)| {\n+            vfn(ty.id, copy t);\n             match ty.node {\n               ty_path(_, _, id) => vfn(id, copy t),\n               _ => { /* fall through */ }"}, {"sha": "a6775c51c456ebb958035544935f0ea7119d26d2", "filename": "src/test/compile-fail/lint-qualification.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad708139fefe4710f002c549ba8bbb11af16f267/src%2Ftest%2Fcompile-fail%2Flint-qualification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad708139fefe4710f002c549ba8bbb11af16f267/src%2Ftest%2Fcompile-fail%2Flint-qualification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-qualification.rs?ref=ad708139fefe4710f002c549ba8bbb11af16f267", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deny(unnecessary_qualification)];\n+\n+mod foo {\n+    pub fn bar() {}\n+}\n+\n+fn main() {\n+    use foo::bar;\n+    foo::bar(); //~ ERROR: unnecessary qualification\n+}"}]}