{"sha": "47425e476b8fd087799d1229a23f7aa81c1835bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NDI1ZTQ3NmI4ZmQwODc3OTlkMTIyOWEyM2Y3YWE4MWMxODM1YmY=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-07-01T00:53:45Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-07-01T00:53:45Z"}, "message": "Rewrite a few manual index loops with while-let\n\nThere were a few instances of this pattern:\n\n```rust\nwhile index < vec.len() {\n    let item = &vec[index];\n    // ...\n}\n```\n\nThese can be indexed at once:\n\n```rust\nwhile let Some(item) = vec.get(index) {\n    // ...\n}\n```\n\nParticularly in `ObligationForest::process_obligations`, this mitigates\na codegen regression found with LLVM 11 (#73526).", "tree": {"sha": "09c2227687eb29116de902a17b9970ccd7ed3f2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09c2227687eb29116de902a17b9970ccd7ed3f2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47425e476b8fd087799d1229a23f7aa81c1835bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47425e476b8fd087799d1229a23f7aa81c1835bf", "html_url": "https://github.com/rust-lang/rust/commit/47425e476b8fd087799d1229a23f7aa81c1835bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47425e476b8fd087799d1229a23f7aa81c1835bf/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ca7f74dbd23a3e8ec491cd3438f490a3ac22741", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca7f74dbd23a3e8ec491cd3438f490a3ac22741", "html_url": "https://github.com/rust-lang/rust/commit/0ca7f74dbd23a3e8ec491cd3438f490a3ac22741"}], "stats": {"total": 16, "additions": 6, "deletions": 10}, "files": [{"sha": "7cf5202d919f8269ee500813568cb12e77627d9b", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47425e476b8fd087799d1229a23f7aa81c1835bf/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47425e476b8fd087799d1229a23f7aa81c1835bf/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=47425e476b8fd087799d1229a23f7aa81c1835bf", "patch": "@@ -412,9 +412,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         // be computed with the initial length, and we would miss the appended\n         // nodes. Therefore we use a `while` loop.\n         let mut index = 0;\n-        while index < self.nodes.len() {\n-            let node = &mut self.nodes[index];\n-\n+        while let Some(node) = self.nodes.get_mut(index) {\n             // `processor.process_obligation` can modify the predicate within\n             // `node.obligation`, and that predicate is the key used for\n             // `self.active_cache`. This means that `self.active_cache` can get\n@@ -666,16 +664,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         for node in &mut self.nodes {\n             let mut i = 0;\n-            while i < node.dependents.len() {\n-                let new_index = node_rewrites[node.dependents[i]];\n+            while let Some(dependent) = node.dependents.get_mut(i) {\n+                let new_index = node_rewrites[*dependent];\n                 if new_index >= orig_nodes_len {\n                     node.dependents.swap_remove(i);\n                     if i == 0 && node.has_parent {\n                         // We just removed the parent.\n                         node.has_parent = false;\n                     }\n                 } else {\n-                    node.dependents[i] = new_index;\n+                    *dependent = new_index;\n                     i += 1;\n                 }\n             }"}, {"sha": "189da3395ad1b32999e43db90bd67b6e1ebc33f9", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47425e476b8fd087799d1229a23f7aa81c1835bf/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47425e476b8fd087799d1229a23f7aa81c1835bf/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=47425e476b8fd087799d1229a23f7aa81c1835bf", "patch": "@@ -391,14 +391,12 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n /// - Input: `[a, x, b, y]`. Output: `[a, x]`.\n fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix<usize, usize>) {\n     let mut i = 0;\n-    while i < candidates.len() {\n-        let candidate_i = candidates[i];\n+    while let Some(&candidate_i) = candidates.get(i) {\n         i += 1;\n \n         let mut j = i;\n         let mut dead = 0;\n-        while j < candidates.len() {\n-            let candidate_j = candidates[j];\n+        while let Some(&candidate_j) = candidates.get(j) {\n             if closure.contains(candidate_i, candidate_j) {\n                 // If `i` can reach `j`, then we can remove `j`. So just\n                 // mark it as dead and move on; subsequent indices will be"}]}