{"sha": "b841152a4007d9251803bbbb7e4f9d7633f3c51d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NDExNTJhNDAwN2Q5MjUxODAzYmJiYjdlNGY5ZDc2MzNmM2M1MWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-29T21:54:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-30T18:35:05Z"}, "message": "rustc: Use interior vectors for tuple types", "tree": {"sha": "f71cd8c7f83b542c43f9e67975b3755a2d17f02d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f71cd8c7f83b542c43f9e67975b3755a2d17f02d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b841152a4007d9251803bbbb7e4f9d7633f3c51d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b841152a4007d9251803bbbb7e4f9d7633f3c51d", "html_url": "https://github.com/rust-lang/rust/commit/b841152a4007d9251803bbbb7e4f9d7633f3c51d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b841152a4007d9251803bbbb7e4f9d7633f3c51d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be50cdd24ad3a47413d8cacfcdcdb5b293201490", "url": "https://api.github.com/repos/rust-lang/rust/commits/be50cdd24ad3a47413d8cacfcdcdb5b293201490", "html_url": "https://github.com/rust-lang/rust/commit/be50cdd24ad3a47413d8cacfcdcdb5b293201490"}], "stats": {"total": 50, "additions": 27, "deletions": 23}, "files": [{"sha": "2a0af99bfc3167b3e697e76adfcf6e53c105e0bc", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b841152a4007d9251803bbbb7e4f9d7633f3c51d/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841152a4007d9251803bbbb7e4f9d7633f3c51d/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=b841152a4007d9251803bbbb7e4f9d7633f3c51d", "patch": "@@ -191,8 +191,8 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         case ('C') { ret ty::mk_chan(st.tcx, parse_ty(st, sd)); }\n         case ('T') {\n             assert (next(st) as char == '[');\n-            let vec[ty::mt] params = [];\n-            while (peek(st) as char != ']') { params += [parse_mt(st, sd)]; }\n+            let ty::mt[] params = ~[];\n+            while (peek(st) as char != ']') { params += ~[parse_mt(st, sd)]; }\n             st.pos = st.pos + 1u;\n             ret ty::mk_tup(st.tcx, params);\n         }"}, {"sha": "df9c110cfa46b2aaaed09d8e41b8679de6eb2b46", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b841152a4007d9251803bbbb7e4f9d7633f3c51d/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841152a4007d9251803bbbb7e4f9d7633f3c51d/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b841152a4007d9251803bbbb7e4f9d7633f3c51d", "patch": "@@ -1,5 +1,6 @@\n \n import std::int;\n+import std::ivec;\n import std::str;\n import std::uint;\n import std::vec;\n@@ -263,7 +264,7 @@ tag sty {\n     ty_port(t);\n     ty_chan(t);\n     ty_task;\n-    ty_tup(vec[mt]);\n+    ty_tup(mt[]);\n     ty_rec(vec[field]);\n     ty_fn(ast::proto, vec[arg], t, controlflow, vec[@constr_def]);\n     ty_native_fn(ast::native_abi, vec[arg], t);\n@@ -584,13 +585,13 @@ fn mk_chan(&ctxt cx, &t ty) -> t { ret gen_ty(cx, ty_chan(ty)); }\n \n fn mk_task(&ctxt cx) -> t { ret gen_ty(cx, ty_task); }\n \n-fn mk_tup(&ctxt cx, &vec[mt] tms) -> t { ret gen_ty(cx, ty_tup(tms)); }\n+fn mk_tup(&ctxt cx, &mt[] tms) -> t { ret gen_ty(cx, ty_tup(tms)); }\n \n fn mk_imm_tup(&ctxt cx, &vec[t] tys) -> t {\n     // TODO: map\n \n-    let vec[ty::mt] mts = [];\n-    for (t typ in tys) { mts += [rec(ty=typ, mut=ast::imm)]; }\n+    let ty::mt[] mts = ~[];\n+    for (t typ in tys) { mts += ~[rec(ty=typ, mut=ast::imm)]; }\n     ret mk_tup(cx, mts);\n }\n \n@@ -775,10 +776,10 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n             ty = copy_cname(cx, mk_tag(cx, tid, new_subtys), ty);\n         }\n         case (ty_tup(?mts)) {\n-            let vec[mt] new_mts = [];\n+            let mt[] new_mts = ~[];\n             for (mt tm in mts) {\n                 auto new_subty = fold_ty(cx, fld, tm.ty);\n-                new_mts += [rec(ty=new_subty, mut=tm.mut)];\n+                new_mts += ~[rec(ty=new_subty, mut=tm.mut)];\n             }\n             ty = copy_cname(cx, mk_tup(cx, new_mts), ty);\n         }\n@@ -1111,7 +1112,7 @@ fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n         case (ty_task) { ret false; }\n         case (ty_tup(?mts)) {\n             auto i = 0u;\n-            while (i < vec::len[mt](mts)) {\n+            while (i < ivec::len[mt](mts)) {\n                 if (type_has_dynamic_size(cx, mts.(i).ty)) { ret true; }\n                 i += 1u;\n             }\n@@ -1551,8 +1552,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_tup(?mts_a)) {\n             alt (b) {\n                 case (ty_tup(?mts_b)) {\n-                    auto len = vec::len[mt](mts_a);\n-                    if (len != vec::len[mt](mts_b)) { ret false; }\n+                    auto len = ivec::len[mt](mts_a);\n+                    if (len != ivec::len[mt](mts_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         if (!equal_mt(mts_a.(i), mts_b.(i))) { ret false; }\n@@ -2477,8 +2478,8 @@ mod unify {\n             case (ty::ty_tup(?expected_elems)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty::ty_tup(?actual_elems)) {\n-                        auto expected_len = vec::len[ty::mt](expected_elems);\n-                        auto actual_len = vec::len[ty::mt](actual_elems);\n+                        auto expected_len = ivec::len[ty::mt](expected_elems);\n+                        auto actual_len = ivec::len[ty::mt](actual_elems);\n                         if (expected_len != actual_len) {\n                             auto err =\n                                 terr_tuple_size(expected_len, actual_len);\n@@ -2487,7 +2488,7 @@ mod unify {\n                         // TODO: implement an iterator that can iterate over\n                         // two arrays simultaneously.\n \n-                        let vec[ty::mt] result_elems = [];\n+                        let ty::mt[] result_elems = ~[];\n                         auto i = 0u;\n                         while (i < expected_len) {\n                             auto expected_elem = expected_elems.(i);\n@@ -2507,7 +2508,7 @@ mod unify {\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n                                     auto mt = rec(ty=rty, mut=mut);\n-                                    result_elems += [mt];\n+                                    result_elems += ~[mt];\n                                 }\n                                 case (_) { ret result; }\n                             }"}, {"sha": "e588c1e0811934f891fd84db6c72030abe663cfa", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b841152a4007d9251803bbbb7e4f9d7633f3c51d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841152a4007d9251803bbbb7e4f9d7633f3c51d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b841152a4007d9251803bbbb7e4f9d7633f3c51d", "patch": "@@ -33,6 +33,7 @@ import middle::ty::unify::fixup_result;\n import middle::ty::unify::fix_ok;\n import middle::ty::unify::fix_err;\n import std::int;\n+import std::ivec;\n import std::str;\n import std::ufind;\n import std::uint;\n@@ -293,9 +294,10 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             typ = ty::mk_chan(tcx, ast_ty_to_ty(tcx, getter, t));\n         }\n         case (ast::ty_tup(?fields)) {\n-            let vec[ty::mt] flds = [];\n+            let ty::mt[] flds = ~[];\n+            ivec::reserve(flds, vec::len(fields));\n             for (ast::mt field in fields) {\n-                vec::push[ty::mt](flds, ast_mt_to_mt(tcx, getter, field));\n+                flds += ~[ast_mt_to_mt(tcx, getter, field)];\n             }\n             typ = ty::mk_tup(tcx, flds);\n         }\n@@ -1937,11 +1939,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             write::ty_only_fixup(fcx, id, typ);\n         }\n         case (ast::expr_tup(?elts)) {\n-            let vec[ty::mt] elts_mt = [];\n+            let ty::mt[] elts_mt = ~[];\n+            ivec::reserve(elts_mt, vec::len(elts));\n             for (ast::elt e in elts) {\n                 check_expr(fcx, e.expr);\n                 auto ety = expr_ty(fcx.ccx.tcx, e.expr);\n-                elts_mt += [rec(ty=ety, mut=e.mut)];\n+                elts_mt += ~[rec(ty=ety, mut=e.mut)];\n             }\n             auto typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n             write::ty_only_fixup(fcx, id, typ);\n@@ -2004,7 +2007,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (ty::ty_tup(?args)) {\n                     let uint ix =\n                         ty::field_num(fcx.ccx.tcx.sess, expr.span, field);\n-                    if (ix >= vec::len[ty::mt](args)) {\n+                    if (ix >= ivec::len[ty::mt](args)) {\n                         fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"bad index on tuple\");\n                     }"}, {"sha": "9ff6a57e0cea05b60cf8f51d11bc3ef28d58fd5f", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b841152a4007d9251803bbbb7e4f9d7633f3c51d/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841152a4007d9251803bbbb7e4f9d7633f3c51d/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=b841152a4007d9251803bbbb7e4f9d7633f3c51d", "patch": "@@ -107,8 +107,8 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         case (ty_type) { s += \"type\"; }\n         case (ty_task) { s += \"task\"; }\n         case (ty_tup(?elems)) {\n-            auto f = bind mt_to_str(cx, _);\n-            auto strs = vec::map[mt, str](f, elems);\n+            let vec[str] strs = [];\n+            for (mt tm in elems) { strs += [mt_to_str(cx, tm)]; }\n             s += \"tup(\" + str::connect(strs, \",\") + \")\";\n         }\n         case (ty_rec(?elems)) {"}, {"sha": "5ff3cf686780929fd8ae0d6b6fb5d9a73984f681", "filename": "src/comp/util/data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b841152a4007d9251803bbbb7e4f9d7633f3c51d/src%2Fcomp%2Futil%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b841152a4007d9251803bbbb7e4f9d7633f3c51d/src%2Fcomp%2Futil%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fdata.rs?ref=b841152a4007d9251803bbbb7e4f9d7633f3c51d", "patch": "@@ -36,4 +36,4 @@ mod interner {\n         }\n     }\n     fn get[T](&interner[T] itr, uint idx) -> T { ret itr.vect.(idx); }\n-}\n\\ No newline at end of file\n+}"}]}