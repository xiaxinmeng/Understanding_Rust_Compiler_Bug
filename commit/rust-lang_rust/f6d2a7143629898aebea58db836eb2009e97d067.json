{"sha": "f6d2a7143629898aebea58db836eb2009e97d067", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZDJhNzE0MzYyOTg5OGFlYmVhNThkYjgzNmViMjAwOWU5N2QwNjc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-23T00:45:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-23T21:21:15Z"}, "message": "core: Remove the unused Notification enum", "tree": {"sha": "054a2942983df884dcfc93813c1e7fd887054cf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/054a2942983df884dcfc93813c1e7fd887054cf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6d2a7143629898aebea58db836eb2009e97d067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d2a7143629898aebea58db836eb2009e97d067", "html_url": "https://github.com/rust-lang/rust/commit/f6d2a7143629898aebea58db836eb2009e97d067", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6d2a7143629898aebea58db836eb2009e97d067/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6bde885dc276b2fab3dd0b2de98627dcc304026", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6bde885dc276b2fab3dd0b2de98627dcc304026", "html_url": "https://github.com/rust-lang/rust/commit/b6bde885dc276b2fab3dd0b2de98627dcc304026"}], "stats": {"total": 49, "additions": 11, "deletions": 38}, "files": [{"sha": "3bfa41f1c482a9ae4a05052a878643f97350d20c", "filename": "src/libcore/task.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f6d2a7143629898aebea58db836eb2009e97d067/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d2a7143629898aebea58db836eb2009e97d067/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=f6d2a7143629898aebea58db836eb2009e97d067", "patch": "@@ -73,25 +73,6 @@ impl TaskResult : Eq {\n     pure fn ne(other: &TaskResult) -> bool { !self.eq(other) }\n }\n \n-/// A message type for notifying of task lifecycle events\n-pub enum Notification {\n-    /// Sent when a task exits with the task handle and result\n-    Exit(Task, TaskResult)\n-}\n-\n-impl Notification : cmp::Eq {\n-    pure fn eq(other: &Notification) -> bool {\n-        match self {\n-            Exit(e0a, e1a) => {\n-                match (*other) {\n-                    Exit(e0b, e1b) => e0a == e0b && e1a == e1b\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(other: &Notification) -> bool { !self.eq(other) }\n-}\n-\n /// Scheduler modes\n pub enum SchedMode {\n     /// All tasks run in the same OS thread\n@@ -201,7 +182,7 @@ pub type SchedOpts = {\n pub type TaskOpts = {\n     linked: bool,\n     supervised: bool,\n-    mut notify_chan: Option<Chan<Notification>>,\n+    mut notify_chan: Option<Chan<TaskResult>>,\n     sched: Option<SchedOpts>,\n };\n \n@@ -344,12 +325,10 @@ impl TaskBuilder {\n         }\n \n         // Construct the future and give it to the caller.\n-        let (notify_pipe_ch, notify_pipe_po) = stream::<Notification>();\n+        let (notify_pipe_ch, notify_pipe_po) = stream::<TaskResult>();\n \n         blk(do future::from_fn |move notify_pipe_po| {\n-            match notify_pipe_po.recv() {\n-              Exit(_, result) => result\n-            }\n+            notify_pipe_po.recv()\n         });\n \n         // Reconfigure self to use a notify channel."}, {"sha": "ea66776d22d66a8acb97c1e1eefc43a020e540ed", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6d2a7143629898aebea58db836eb2009e97d067/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d2a7143629898aebea58db836eb2009e97d067/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=f6d2a7143629898aebea58db836eb2009e97d067", "patch": "@@ -320,15 +320,15 @@ fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n }\n \n struct AutoNotify {\n-    notify_chan: Chan<Notification>,\n+    notify_chan: Chan<TaskResult>,\n     mut failed:  bool,\n     drop {\n         let result = if self.failed { Failure } else { Success };\n-        self.notify_chan.send(Exit(get_task(), result));\n+        self.notify_chan.send(result);\n     }\n }\n \n-fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n+fn AutoNotify(chan: Chan<TaskResult>) -> AutoNotify {\n     AutoNotify {\n         notify_chan: move chan,\n         failed: true // Un-set above when taskgroup successfully made.\n@@ -532,7 +532,7 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n     // (4) ...and runs the provided body function.\n     fn make_child_wrapper(child: *rust_task, child_arc: TaskGroupArc,\n                           ancestors: AncestorList, is_main: bool,\n-                          notify_chan: Option<Chan<Notification>>,\n+                          notify_chan: Option<Chan<TaskResult>>,\n                           f: fn~()) -> fn~() {\n         let child_data = ~mut Some((move child_arc, move ancestors));\n         return fn~(move notify_chan, move child_data, move f) {\n@@ -660,36 +660,30 @@ fn test_spawn_raw_unsupervise() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_spawn_raw_notify_success() {\n-    let (task_ch, task_po) = pipes::stream();\n     let (notify_ch, notify_po) = pipes::stream();\n \n     let opts = {\n         notify_chan: Some(move notify_ch),\n         .. default_task_opts()\n     };\n-    do spawn_raw(move opts) |move task_ch| {\n-        task_ch.send(get_task());\n+    do spawn_raw(move opts) {\n     }\n-    let task_ = task_po.recv();\n-    assert notify_po.recv() == Exit(task_, Success);\n+    assert notify_po.recv() == Success;\n }\n \n #[test]\n #[ignore(cfg(windows))]\n fn test_spawn_raw_notify_failure() {\n     // New bindings for these\n-    let (task_ch, task_po) = pipes::stream();\n     let (notify_ch, notify_po) = pipes::stream();\n \n     let opts = {\n         linked: false,\n         notify_chan: Some(move notify_ch),\n         .. default_task_opts()\n     };\n-    do spawn_raw(move opts) |move task_ch| {\n-        task_ch.send(get_task());\n+    do spawn_raw(move opts) {\n         fail;\n     }\n-    let task_ = task_po.recv();\n-    assert notify_po.recv() == Exit(task_, Failure);\n+    assert notify_po.recv() == Failure;\n }"}]}