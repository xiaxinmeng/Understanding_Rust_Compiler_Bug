{"sha": "0614a94d67a5dadc8b7e8aba451cb4cee45c9192", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MTRhOTRkNjdhNWRhZGM4YjdlOGFiYTQ1MWNiNGNlZTQ1YzkxOTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-26T16:56:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-26T16:56:59Z"}, "message": "Rollup merge of #62983 - Mark-Simulacrum:remove-needless-rc, r=petrochenkov\n\nRemove needless indirection through Rc\n\nNamedMatch is already cheap to clone due to Lrc's inside.", "tree": {"sha": "ece01de3a51035488e29fca1cd7d3ea269c6ad46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ece01de3a51035488e29fca1cd7d3ea269c6ad46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0614a94d67a5dadc8b7e8aba451cb4cee45c9192", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdOzDcCRBK7hj4Ov3rIwAAdHIIAEndY/RwgwJnDAPG9Cluc82/\nptTakl5GQJ5ah+N3igDrVRQFmpKdj9g0+HEwFdzU27vNocarrEAJc2ltYRexADIe\nA15GqvhGEfkmxraGmsV+88aXpz/PaqBZLNGuvIh9qnrnO0Trz2P6KI546dTEf63V\nMz6w66cp5qXZqBKSyI1FLk2Emp5MOWU926ngJUw7YmKOBNG5y/AsmeWxS+P2XlWb\nxWeVFnUbIROZEVHAd0UpHD7R9AIhkuX1PKRbmoytDsDLgyxD1QuyglZiDkmU4XpC\nsMBEBQ/kiFJLbPuogHgU00i/HlgcmnEzHlfC7NTYhq5UggJQNv5n9XEHJIBqeoc=\n=oHz0\n-----END PGP SIGNATURE-----\n", "payload": "tree ece01de3a51035488e29fca1cd7d3ea269c6ad46\nparent 15398b6b358b8585d5ab23ae95bbcd3330e5fdb4\nparent 0e022f87e7103fcb4b62ae32a467b92503abb178\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564160219 +0200\ncommitter GitHub <noreply@github.com> 1564160219 +0200\n\nRollup merge of #62983 - Mark-Simulacrum:remove-needless-rc, r=petrochenkov\n\nRemove needless indirection through Rc\n\nNamedMatch is already cheap to clone due to Lrc's inside.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0614a94d67a5dadc8b7e8aba451cb4cee45c9192", "html_url": "https://github.com/rust-lang/rust/commit/0614a94d67a5dadc8b7e8aba451cb4cee45c9192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0614a94d67a5dadc8b7e8aba451cb4cee45c9192/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15398b6b358b8585d5ab23ae95bbcd3330e5fdb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/15398b6b358b8585d5ab23ae95bbcd3330e5fdb4", "html_url": "https://github.com/rust-lang/rust/commit/15398b6b358b8585d5ab23ae95bbcd3330e5fdb4"}, {"sha": "0e022f87e7103fcb4b62ae32a467b92503abb178", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e022f87e7103fcb4b62ae32a467b92503abb178", "html_url": "https://github.com/rust-lang/rust/commit/0e022f87e7103fcb4b62ae32a467b92503abb178"}], "stats": {"total": 36, "additions": 16, "deletions": 20}, "files": [{"sha": "dbf14daa30e75e51bae34fd3a78a63dc1302e3e6", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0614a94d67a5dadc8b7e8aba451cb4cee45c9192/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0614a94d67a5dadc8b7e8aba451cb4cee45c9192/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=0614a94d67a5dadc8b7e8aba451cb4cee45c9192", "patch": "@@ -92,7 +92,6 @@ use rustc_data_structures::sync::Lrc;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n use std::ops::{Deref, DerefMut};\n-use std::rc::Rc;\n \n // To avoid costly uniqueness checks, we require that `MatchSeq` always has a nonempty body.\n \n@@ -280,7 +279,7 @@ pub enum ParseResult<T> {\n \n /// A `ParseResult` where the `Success` variant contains a mapping of `Ident`s to `NamedMatch`es.\n /// This represents the mapping of metavars to the token trees they bind to.\n-pub type NamedParseResult = ParseResult<FxHashMap<Ident, Rc<NamedMatch>>>;\n+pub type NamedParseResult = ParseResult<FxHashMap<Ident, NamedMatch>>;\n \n /// Count how many metavars are named in the given matcher `ms`.\n pub fn count_names(ms: &[TokenTree]) -> usize {\n@@ -373,7 +372,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n         sess: &ParseSess,\n         m: &TokenTree,\n         res: &mut I,\n-        ret_val: &mut FxHashMap<Ident, Rc<NamedMatch>>,\n+        ret_val: &mut FxHashMap<Ident, NamedMatch>,\n     ) -> Result<(), (syntax_pos::Span, String)> {\n         match *m {\n             TokenTree::Sequence(_, ref seq) => for next_m in &seq.tts {\n@@ -390,8 +389,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n             TokenTree::MetaVarDecl(sp, bind_name, _) => {\n                 match ret_val.entry(bind_name) {\n                     Vacant(spot) => {\n-                        // FIXME(simulacrum): Don't construct Rc here\n-                        spot.insert(Rc::new(res.next().unwrap()));\n+                        spot.insert(res.next().unwrap());\n                     }\n                     Occupied(..) => {\n                         return Err((sp, format!(\"duplicated bind name: {}\", bind_name)))"}, {"sha": "817d8547e87600aab902744571bed9c34f79aade", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0614a94d67a5dadc8b7e8aba451cb4cee45c9192/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0614a94d67a5dadc8b7e8aba451cb4cee45c9192/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0614a94d67a5dadc8b7e8aba451cb4cee45c9192", "patch": "@@ -308,7 +308,7 @@ pub fn compile(\n     let mut valid = true;\n \n     // Extract the arguments:\n-    let lhses = match *argument_map[&lhs_nm] {\n+    let lhses = match argument_map[&lhs_nm] {\n         MatchedSeq(ref s, _) => s\n             .iter()\n             .map(|m| {\n@@ -335,7 +335,7 @@ pub fn compile(\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n-    let rhses = match *argument_map[&rhs_nm] {\n+    let rhses = match argument_map[&rhs_nm] {\n         MatchedSeq(ref s, _) => s\n             .iter()\n             .map(|m| {"}, {"sha": "214e721fd1506dc838f2c0b28b19390f6271e774", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0614a94d67a5dadc8b7e8aba451cb4cee45c9192/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0614a94d67a5dadc8b7e8aba451cb4cee45c9192/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=0614a94d67a5dadc8b7e8aba451cb4cee45c9192", "patch": "@@ -12,7 +12,6 @@ use smallvec::{smallvec, SmallVec};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use std::mem;\n-use std::rc::Rc;\n \n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n@@ -65,9 +64,9 @@ impl Iterator for Frame {\n /// `transcribe` would return a `TokenStream` containing `println!(\"{}\", stringify!(bar));`.\n ///\n /// Along the way, we do some additional error checking.\n-pub fn transcribe(\n+pub(super) fn transcribe(\n     cx: &ExtCtxt<'_>,\n-    interp: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    interp: &FxHashMap<Ident, NamedMatch>,\n     src: Vec<quoted::TokenTree>,\n ) -> TokenStream {\n     // Nothing for us to transcribe...\n@@ -212,7 +211,7 @@ pub fn transcribe(\n                 // Find the matched nonterminal from the macro invocation, and use it to replace\n                 // the meta-var.\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n-                    if let MatchedNonterminal(ref nt) = *cur_matched {\n+                    if let MatchedNonterminal(ref nt) = cur_matched {\n                         // FIXME #2887: why do we apply a mark when matching a token tree meta-var\n                         // (e.g. `$x:tt`), but not when we are matching any other type of token\n                         // tree?\n@@ -273,18 +272,17 @@ pub fn transcribe(\n /// See the definition of `repeats` in the `transcribe` function. `repeats` is used to descend\n /// into the right place in nested matchers. If we attempt to descend too far, the macro writer has\n /// made a mistake, and we return `None`.\n-fn lookup_cur_matched(\n+fn lookup_cur_matched<'a>(\n     ident: Ident,\n-    interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    interpolations: &'a FxHashMap<Ident, NamedMatch>,\n     repeats: &[(usize, usize)],\n-) -> Option<Rc<NamedMatch>> {\n+) -> Option<&'a NamedMatch> {\n     interpolations.get(&ident).map(|matched| {\n-        let mut matched = matched.clone();\n+        let mut matched = matched;\n         for &(idx, _) in repeats {\n-            let m = matched.clone();\n-            match *m {\n+            match matched {\n                 MatchedNonterminal(_) => break,\n-                MatchedSeq(ref ads, _) => matched = Rc::new(ads[idx].clone()),\n+                MatchedSeq(ref ads, _) => matched = ads.get(idx).unwrap(),\n             }\n         }\n \n@@ -343,7 +341,7 @@ impl LockstepIterSize {\n /// multiple nested matcher sequences.\n fn lockstep_iter_size(\n     tree: &quoted::TokenTree,\n-    interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    interpolations: &FxHashMap<Ident, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> LockstepIterSize {\n     use quoted::TokenTree;\n@@ -360,7 +358,7 @@ fn lockstep_iter_size(\n         }\n         TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) => {\n             match lookup_cur_matched(name, interpolations, repeats) {\n-                Some(matched) => match *matched {\n+                Some(matched) => match matched {\n                     MatchedNonterminal(_) => LockstepIterSize::Unconstrained,\n                     MatchedSeq(ref ads, _) => LockstepIterSize::Constraint(ads.len(), name),\n                 },"}]}