{"sha": "5cf9905e257ddeeadaf493a705a230081a6c7da3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZjk5MDVlMjU3ZGRlZWFkYWY0OTNhNzA1YTIzMDA4MWE2YzdkYTM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-01T04:24:36Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-03T20:51:12Z"}, "message": "std: Add `io` module again\n\nThis commit is an implementation of [RFC 576][rfc] which adds back the `std::io`\nmodule to the standard library. No functionality in `std::old_io` has been\ndeprecated just yet, and the new `std::io` module is behind the same `io`\nfeature gate.\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/576\n\nA good bit of functionality was copied over from `std::old_io`, but many tweaks\nwere required for the new method signatures. Behavior such as precisely when\nbuffered objects call to the underlying object may have been tweaked slightly in\nthe transition. All implementations were audited to use composition wherever\npossible. For example the custom `pos` and `cap` cursors in `BufReader` were\nremoved in favor of just using `Cursor<Vec<u8>>`.\n\nA few liberties were taken during this implementation which were not explicitly\nspelled out in the RFC:\n\n* The old `LineBufferedWriter` is now named `LineWriter`\n* The internal representation of `Error` now favors OS error codes (a\n  0-allocation path) and contains a `Box` for extra semantic data.\n* The io prelude currently reexports `Seek` as `NewSeek` to prevent conflicts\n  with the real prelude reexport of `old_io::Seek`\n* The `chars` method was moved from `BufReadExt` to `ReadExt`.\n* The `chars` iterator returns a custom error with a variant that explains that\n  the data was not valid UTF-8.", "tree": {"sha": "bd6a619395cc46871abdda33e3d6c87328fa585b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd6a619395cc46871abdda33e3d6c87328fa585b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cf9905e257ddeeadaf493a705a230081a6c7da3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cf9905e257ddeeadaf493a705a230081a6c7da3", "html_url": "https://github.com/rust-lang/rust/commit/5cf9905e257ddeeadaf493a705a230081a6c7da3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cf9905e257ddeeadaf493a705a230081a6c7da3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7858cb432d3f2efc0374424cb2b51518f697c172", "url": "https://api.github.com/repos/rust-lang/rust/commits/7858cb432d3f2efc0374424cb2b51518f697c172", "html_url": "https://github.com/rust-lang/rust/commit/7858cb432d3f2efc0374424cb2b51518f697c172"}], "stats": {"total": 2550, "additions": 2546, "deletions": 4}, "files": [{"sha": "2fd6631ecc4371fec61b516fab453d9cf05c8d7f", "filename": "src/libstd/io/buffered.rs", "status": "added", "additions": 676, "deletions": 0, "changes": 676, "blob_url": "https://github.com/rust-lang/rust/blob/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=5cf9905e257ddeeadaf493a705a230081a6c7da3", "patch": "@@ -0,0 +1,676 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15883\n+\n+//! Buffering wrappers for I/O traits\n+\n+use prelude::v1::*;\n+use io::prelude::*;\n+\n+use cmp;\n+use error::Error as StdError;\n+use error::FromError;\n+use fmt;\n+use io::{self, Cursor, DEFAULT_BUF_SIZE, Error, ErrorKind};\n+use ptr;\n+\n+/// Wraps a `Read` and buffers input from it\n+///\n+/// It can be excessively inefficient to work directly with a `Read` instance.\n+/// For example, every call to `read` on `TcpStream` results in a system call.\n+/// A `BufReader` performs large, infrequent reads on the underlying `Read`\n+/// and maintains an in-memory buffer of the results.\n+pub struct BufReader<R> {\n+    inner: R,\n+    buf: Cursor<Vec<u8>>,\n+}\n+\n+impl<R: Read> BufReader<R> {\n+    /// Creates a new `BufReader` with a default buffer capacity\n+    pub fn new(inner: R) -> BufReader<R> {\n+        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n+    }\n+\n+    /// Creates a new `BufReader` with the specified buffer capacity\n+    pub fn with_capacity(cap: usize, inner: R) -> BufReader<R> {\n+        BufReader {\n+            inner: inner,\n+            buf: Cursor::new(Vec::with_capacity(cap)),\n+        }\n+    }\n+\n+    /// Gets a reference to the underlying reader.\n+    pub fn get_ref<'a>(&self) -> &R { &self.inner }\n+\n+    /// Gets a mutable reference to the underlying reader.\n+    ///\n+    /// # Warning\n+    ///\n+    /// It is inadvisable to directly read from the underlying reader.\n+    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }\n+\n+    /// Unwraps this `BufReader`, returning the underlying reader.\n+    ///\n+    /// Note that any leftover data in the internal buffer is lost.\n+    pub fn into_inner(self) -> R { self.inner }\n+}\n+\n+impl<R: Read> Read for BufReader<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        // If we don't have any buffered data and we're doing a massive read\n+        // (larger than our internal buffer), bypass our internal buffer\n+        // entirely.\n+        if self.buf.get_ref().len() == self.buf.position() as usize &&\n+            buf.len() >= self.buf.get_ref().capacity() {\n+            return self.inner.read(buf);\n+        }\n+        try!(self.fill_buf());\n+        self.buf.read(buf)\n+    }\n+}\n+\n+impl<R: Read> BufRead for BufReader<R> {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        // If we've reached the end of our internal buffer then we need to fetch\n+        // some more data from the underlying reader.\n+        if self.buf.position() as usize == self.buf.get_ref().len() {\n+            self.buf.set_position(0);\n+            let v = self.buf.get_mut();\n+            v.truncate(0);\n+            let inner = &mut self.inner;\n+            try!(super::with_end_to_cap(v, |b| inner.read(b)));\n+        }\n+        self.buf.fill_buf()\n+    }\n+\n+    fn consume(&mut self, amt: uint) {\n+        self.buf.consume(amt)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"BufReader {{ reader: {:?}, buffer: {}/{} }}\",\n+               self.inner, self.buf.position(), self.buf.get_ref().len())\n+    }\n+}\n+\n+/// Wraps a Writer and buffers output to it\n+///\n+/// It can be excessively inefficient to work directly with a `Write`. For\n+/// example, every call to `write` on `TcpStream` results in a system call. A\n+/// `BufWriter` keeps an in memory buffer of data and writes it to the\n+/// underlying `Write` in large, infrequent batches.\n+///\n+/// This writer will be flushed when it is dropped.\n+pub struct BufWriter<W> {\n+    inner: Option<W>,\n+    buf: Vec<u8>,\n+}\n+\n+/// An error returned by `into_inner` which indicates whether a flush error\n+/// happened or not.\n+#[derive(Debug)]\n+pub struct IntoInnerError<W>(W, Error);\n+\n+impl<W: Write> BufWriter<W> {\n+    /// Creates a new `BufWriter` with a default buffer capacity\n+    pub fn new(inner: W) -> BufWriter<W> {\n+        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n+    }\n+\n+    /// Creates a new `BufWriter` with the specified buffer capacity\n+    pub fn with_capacity(cap: usize, inner: W) -> BufWriter<W> {\n+        BufWriter {\n+            inner: Some(inner),\n+            buf: Vec::with_capacity(cap),\n+        }\n+    }\n+\n+    fn flush_buf(&mut self) -> io::Result<()> {\n+        let mut written = 0;\n+        let len = self.buf.len();\n+        let mut ret = Ok(());\n+        while written < len {\n+            match self.inner.as_mut().unwrap().write(&self.buf[written..]) {\n+                Ok(0) => {\n+                    ret = Err(Error::new(ErrorKind::WriteZero,\n+                                         \"failed to flush\", None));\n+                    break;\n+                }\n+                Ok(n) => written += n,\n+                Err(e) => { ret = Err(e); break }\n+\n+            }\n+        }\n+        if written > 0 {\n+            // NB: would be better expressed as .remove(0..n) if it existed\n+            unsafe {\n+                ptr::copy_memory(self.buf.as_mut_ptr(),\n+                                 self.buf.as_ptr().offset(written as isize),\n+                                 len - written);\n+            }\n+        }\n+        self.buf.truncate(len - written);\n+        ret\n+    }\n+\n+    /// Gets a reference to the underlying writer.\n+    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n+\n+    /// Gets a mutable reference to the underlying write.\n+    ///\n+    /// # Warning\n+    ///\n+    /// It is inadvisable to directly read from the underlying writer.\n+    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n+\n+    /// Unwraps this `BufWriter`, returning the underlying writer.\n+    ///\n+    /// The buffer is flushed before returning the writer.\n+    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n+        match self.flush_buf() {\n+            Err(e) => Err(IntoInnerError(self, e)),\n+            Ok(()) => Ok(self.inner.take().unwrap())\n+        }\n+    }\n+}\n+\n+impl<W: Write> Write for BufWriter<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        if self.buf.len() + buf.len() > self.buf.capacity() {\n+            try!(self.flush_buf());\n+        }\n+        if buf.len() >= self.buf.capacity() {\n+            self.inner.as_mut().unwrap().write(buf)\n+        } else {\n+            let amt = cmp::min(buf.len(), self.buf.capacity());\n+            Write::write(&mut self.buf, &buf[..amt])\n+        }\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.flush_buf().and_then(|()| self.get_mut().flush())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"BufWriter {{ writer: {:?}, buffer: {}/{} }}\",\n+               self.inner.as_ref().unwrap(), self.buf.len(), self.buf.capacity())\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<W: Write> Drop for BufWriter<W> {\n+    fn drop(&mut self) {\n+        if self.inner.is_some() {\n+            // dtors should not panic, so we ignore a failed flush\n+            let _r = self.flush_buf();\n+        }\n+    }\n+}\n+\n+impl<W> IntoInnerError<W> {\n+    /// Returns the error which caused the call to `into_inner` to fail.\n+    ///\n+    /// This error was returned when attempting to flush the internal buffer.\n+    pub fn error(&self) -> &Error { &self.1 }\n+\n+    /// Returns the underlying `BufWriter` instance which generated the error.\n+    ///\n+    /// The returned object can be used to retry a flush or re-inspect the\n+    /// buffer.\n+    pub fn into_inner(self) -> W { self.0 }\n+}\n+\n+impl<W> FromError<IntoInnerError<W>> for Error {\n+    fn from_error(iie: IntoInnerError<W>) -> Error { iie.1 }\n+}\n+\n+impl<W> StdError for IntoInnerError<W> {\n+    fn description(&self) -> &str { self.error().description() }\n+}\n+\n+impl<W> fmt::Display for IntoInnerError<W> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.error().fmt(f)\n+    }\n+}\n+\n+/// Wraps a Writer and buffers output to it, flushing whenever a newline\n+/// (`0x0a`, `'\\n'`) is detected.\n+///\n+/// This writer will be flushed when it is dropped.\n+pub struct LineWriter<W> {\n+    inner: BufWriter<W>,\n+}\n+\n+impl<W: Write> LineWriter<W> {\n+    /// Creates a new `LineWriter`\n+    pub fn new(inner: W) -> LineWriter<W> {\n+        // Lines typically aren't that long, don't use a giant buffer\n+        LineWriter { inner: BufWriter::with_capacity(1024, inner) }\n+    }\n+\n+    /// Gets a reference to the underlying writer.\n+    ///\n+    /// This type does not expose the ability to get a mutable reference to the\n+    /// underlying reader because that could possibly corrupt the buffer.\n+    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }\n+\n+    /// Unwraps this `LineWriter`, returning the underlying writer.\n+    ///\n+    /// The internal buffer is flushed before returning the writer.\n+    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n+        self.inner.into_inner().map_err(|IntoInnerError(buf, e)| {\n+            IntoInnerError(LineWriter { inner: buf }, e)\n+        })\n+    }\n+}\n+\n+impl<W: Write> Write for LineWriter<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        match buf.rposition_elem(&b'\\n') {\n+            Some(i) => {\n+                let n = try!(self.inner.write(&buf[..i + 1]));\n+                if n != i + 1 { return Ok(n) }\n+                try!(self.inner.flush());\n+                self.inner.write(&buf[i + 1..]).map(|i| n + i)\n+            }\n+            None => self.inner.write(buf),\n+        }\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"LineWriter {{ writer: {:?}, buffer: {}/{} }}\",\n+               self.inner.inner, self.inner.buf.len(),\n+               self.inner.buf.capacity())\n+    }\n+}\n+\n+struct InternalBufWriter<W>(BufWriter<W>);\n+\n+impl<W> InternalBufWriter<W> {\n+    fn get_mut(&mut self) -> &mut BufWriter<W> {\n+        let InternalBufWriter(ref mut w) = *self;\n+        return w;\n+    }\n+}\n+\n+impl<W: Read> Read for InternalBufWriter<W> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.get_mut().inner.as_mut().unwrap().read(buf)\n+    }\n+}\n+\n+/// Wraps a Stream and buffers input and output to and from it.\n+///\n+/// It can be excessively inefficient to work directly with a `Stream`. For\n+/// example, every call to `read` or `write` on `TcpStream` results in a system\n+/// call. A `BufStream` keeps in memory buffers of data, making large,\n+/// infrequent calls to `read` and `write` on the underlying `Stream`.\n+///\n+/// The output half will be flushed when this stream is dropped.\n+pub struct BufStream<S> {\n+    inner: BufReader<InternalBufWriter<S>>\n+}\n+\n+impl<S: Read + Write> BufStream<S> {\n+    /// Creates a new buffered stream with explicitly listed capacities for the\n+    /// reader/writer buffer.\n+    pub fn with_capacities(reader_cap: usize, writer_cap: usize, inner: S)\n+                           -> BufStream<S> {\n+        let writer = BufWriter::with_capacity(writer_cap, inner);\n+        let internal_writer = InternalBufWriter(writer);\n+        let reader = BufReader::with_capacity(reader_cap, internal_writer);\n+        BufStream { inner: reader }\n+    }\n+\n+    /// Creates a new buffered stream with the default reader/writer buffer\n+    /// capacities.\n+    pub fn new(inner: S) -> BufStream<S> {\n+        BufStream::with_capacities(DEFAULT_BUF_SIZE, DEFAULT_BUF_SIZE, inner)\n+    }\n+\n+    /// Gets a reference to the underlying stream.\n+    pub fn get_ref(&self) -> &S {\n+        let InternalBufWriter(ref w) = self.inner.inner;\n+        w.get_ref()\n+    }\n+\n+    /// Gets a mutable reference to the underlying stream.\n+    ///\n+    /// # Warning\n+    ///\n+    /// It is inadvisable to read directly from or write directly to the\n+    /// underlying stream.\n+    pub fn get_mut(&mut self) -> &mut S {\n+        let InternalBufWriter(ref mut w) = self.inner.inner;\n+        w.get_mut()\n+    }\n+\n+    /// Unwraps this `BufStream`, returning the underlying stream.\n+    ///\n+    /// The internal buffer is flushed before returning the stream. Any leftover\n+    /// data in the read buffer is lost.\n+    pub fn into_inner(self) -> Result<S, IntoInnerError<BufStream<S>>> {\n+        let BufReader { inner: InternalBufWriter(w), buf } = self.inner;\n+        w.into_inner().map_err(|IntoInnerError(w, e)| {\n+            IntoInnerError(BufStream {\n+                inner: BufReader { inner: InternalBufWriter(w), buf: buf },\n+            }, e)\n+        })\n+    }\n+}\n+\n+impl<S: Read + Write> BufRead for BufStream<S> {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n+    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n+}\n+\n+impl<S: Read + Write> Read for BufStream<S> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.read(buf)\n+    }\n+}\n+\n+impl<S: Read + Write> Write for BufStream<S> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.inner.inner.get_mut().write(buf)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.inner.get_mut().flush()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<S> fmt::Debug for BufStream<S> where S: fmt::Debug {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let reader = &self.inner;\n+        let writer = &self.inner.inner.0;\n+        write!(fmt, \"BufStream {{ stream: {:?}, write_buffer: {}/{}, read_buffer: {}/{} }}\",\n+               writer.inner,\n+               writer.buf.len(), writer.buf.capacity(),\n+               reader.buf.position(), reader.buf.get_ref().len())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io::prelude::*;\n+    use io::{self, BufReader, BufWriter, BufStream, Cursor, LineWriter};\n+    use test;\n+\n+    /// A dummy reader intended at testing short-reads propagation.\n+    pub struct ShortReader {\n+        lengths: Vec<usize>,\n+    }\n+\n+    impl Read for ShortReader {\n+        fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n+            if self.lengths.is_empty() {\n+                Ok(0)\n+            } else {\n+                Ok(self.lengths.remove(0))\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_buffered_reader() {\n+        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n+        let mut reader = BufReader::with_capacity(2, inner);\n+\n+        let mut buf = [0, 0, 0];\n+        let nread = reader.read(&mut buf);\n+        assert_eq!(Ok(3), nread);\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(buf, b);\n+\n+        let mut buf = [0, 0];\n+        let nread = reader.read(&mut buf);\n+        assert_eq!(Ok(2), nread);\n+        let b: &[_] = &[0, 1];\n+        assert_eq!(buf, b);\n+\n+        let mut buf = [0];\n+        let nread = reader.read(&mut buf);\n+        assert_eq!(Ok(1), nread);\n+        let b: &[_] = &[2];\n+        assert_eq!(buf, b);\n+\n+        let mut buf = [0, 0, 0];\n+        let nread = reader.read(&mut buf);\n+        assert_eq!(Ok(1), nread);\n+        let b: &[_] = &[3, 0, 0];\n+        assert_eq!(buf, b);\n+\n+        let nread = reader.read(&mut buf);\n+        assert_eq!(Ok(1), nread);\n+        let b: &[_] = &[4, 0, 0];\n+        assert_eq!(buf, b);\n+\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+    }\n+\n+    #[test]\n+    fn test_buffered_writer() {\n+        let inner = Vec::new();\n+        let mut writer = BufWriter::with_capacity(2, inner);\n+\n+        writer.write(&[0, 1]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1]);\n+\n+        writer.write(&[2]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1]);\n+\n+        writer.write(&[3]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1]);\n+\n+        writer.flush().unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n+\n+        writer.write(&[4]).unwrap();\n+        writer.write(&[5]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n+\n+        writer.write(&[6]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5]);\n+\n+        writer.write(&[7, 8]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8]);\n+\n+        writer.write(&[9, 10, 11]).unwrap();\n+        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n+\n+        writer.flush().unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n+    }\n+\n+    #[test]\n+    fn test_buffered_writer_inner_flushes() {\n+        let mut w = BufWriter::with_capacity(3, Vec::new());\n+        w.write(&[0, 1]).unwrap();\n+        assert_eq!(*w.get_ref(), []);\n+        let w = w.into_inner().unwrap();\n+        assert_eq!(w, [0, 1]);\n+    }\n+\n+    // This is just here to make sure that we don't infinite loop in the\n+    // newtype struct autoderef weirdness\n+    #[test]\n+    fn test_buffered_stream() {\n+        struct S;\n+\n+        impl Write for S {\n+            fn write(&mut self, b: &[u8]) -> io::Result<usize> { Ok(b.len()) }\n+            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+        }\n+\n+        impl Read for S {\n+            fn read(&mut self, _: &mut [u8]) -> io::Result<usize> { Ok(0) }\n+        }\n+\n+        let mut stream = BufStream::new(S);\n+        assert_eq!(stream.read(&mut [0; 10]), Ok(0));\n+        stream.write(&[0; 10]).unwrap();\n+        stream.flush().unwrap();\n+    }\n+\n+    #[test]\n+    fn test_read_until() {\n+        let inner: &[u8] = &[0, 1, 2, 1, 0];\n+        let mut reader = BufReader::with_capacity(2, inner);\n+        let mut v = Vec::new();\n+        reader.read_until(0, &mut v).unwrap();\n+        assert_eq!(v, [0]);\n+        v.truncate(0);\n+        reader.read_until(2, &mut v).unwrap();\n+        assert_eq!(v, [1, 2]);\n+        v.truncate(0);\n+        reader.read_until(1, &mut v).unwrap();\n+        assert_eq!(v, [1]);\n+        v.truncate(0);\n+        reader.read_until(8, &mut v).unwrap();\n+        assert_eq!(v, [0]);\n+        v.truncate(0);\n+        reader.read_until(9, &mut v).unwrap();\n+        assert_eq!(v, []);\n+    }\n+\n+    #[test]\n+    fn test_line_buffer() {\n+        let mut writer = LineWriter::new(Vec::new());\n+        writer.write(&[0]).unwrap();\n+        assert_eq!(*writer.get_ref(), []);\n+        writer.write(&[1]).unwrap();\n+        assert_eq!(*writer.get_ref(), []);\n+        writer.flush().unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1]);\n+        writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n']);\n+        writer.flush().unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2]);\n+        writer.write(&[3, b'\\n']).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n+    }\n+\n+    #[test]\n+    fn test_read_line() {\n+        let in_buf = b\"a\\nb\\nc\";\n+        let mut reader = BufReader::with_capacity(2, in_buf);\n+        let mut s = String::new();\n+        reader.read_line(&mut s).unwrap();\n+        assert_eq!(s, \"a\\n\");\n+        s.truncate(0);\n+        reader.read_line(&mut s).unwrap();\n+        assert_eq!(s, \"b\\n\");\n+        s.truncate(0);\n+        reader.read_line(&mut s).unwrap();\n+        assert_eq!(s, \"c\");\n+        s.truncate(0);\n+        reader.read_line(&mut s).unwrap();\n+        assert_eq!(s, \"\");\n+    }\n+\n+    #[test]\n+    fn test_lines() {\n+        let in_buf = b\"a\\nb\\nc\";\n+        let mut reader = BufReader::with_capacity(2, in_buf);\n+        let mut it = reader.lines();\n+        assert_eq!(it.next(), Some(Ok(\"a\".to_string())));\n+        assert_eq!(it.next(), Some(Ok(\"b\".to_string())));\n+        assert_eq!(it.next(), Some(Ok(\"c\".to_string())));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_short_reads() {\n+        let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n+        let mut reader = BufReader::new(inner);\n+        let mut buf = [0, 0];\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf), Ok(2));\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+    }\n+\n+    #[test]\n+    fn read_char_buffered() {\n+        let buf = [195u8, 159u8];\n+        let mut reader = BufReader::with_capacity(1, &buf[]);\n+        assert_eq!(reader.chars().next(), Some(Ok('\u00df')));\n+    }\n+\n+    #[test]\n+    fn test_chars() {\n+        let buf = [195u8, 159u8, b'a'];\n+        let mut reader = BufReader::with_capacity(1, &buf[]);\n+        let mut it = reader.chars();\n+        assert_eq!(it.next(), Some(Ok('\u00df')));\n+        assert_eq!(it.next(), Some(Ok('a')));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn dont_panic_in_drop_on_panicked_flush() {\n+        struct FailFlushWriter;\n+\n+        impl Write for FailFlushWriter {\n+            fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n+            fn flush(&mut self) -> io::Result<()> {\n+                Err(io::Error::last_os_error())\n+            }\n+        }\n+\n+        let writer = FailFlushWriter;\n+        let _writer = BufWriter::new(writer);\n+\n+        // If writer panics *again* due to the flush error then the process will\n+        // abort.\n+        panic!();\n+    }\n+\n+    #[bench]\n+    fn bench_buffered_reader(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            BufReader::new(io::empty())\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_buffered_writer(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            BufWriter::new(io::sink())\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_buffered_stream(b: &mut test::Bencher) {\n+        let mut buf = Cursor::new(Vec::new());\n+        b.iter(|| {\n+            BufStream::new(&mut buf);\n+        });\n+    }\n+}"}, {"sha": "9f3655de20fc245c91bbd9b79527bdc58bc6b5bc", "filename": "src/libstd/io/cursor.rs", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=5cf9905e257ddeeadaf493a705a230081a6c7da3", "patch": "@@ -0,0 +1,408 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_copy_implementations)]\n+\n+use prelude::v1::*;\n+use io::prelude::*;\n+\n+use cmp;\n+use io::{self, SeekFrom, Error, ErrorKind};\n+use iter::repeat;\n+use num::Int;\n+use slice;\n+\n+/// A `Cursor` is a type which wraps another I/O object to provide a `Seek`\n+/// implementation.\n+///\n+/// Cursors are currently typically used with memory buffer objects in order to\n+/// allow `Seek` plus `Read` and `Write` implementations. For example, common\n+/// cursor types include:\n+///\n+/// * `Cursor<Vec<u8>>`\n+/// * `Cursor<&[u8]>`\n+///\n+/// Implementations of the I/O traits for `Cursor<T>` are not currently generic\n+/// over `T` itself. Instead, specific implementations are provided for various\n+/// in-memory buffer types like `Vec<u8>` and `&[u8]`.\n+pub struct Cursor<T> {\n+    inner: T,\n+    pos: u64,\n+}\n+\n+impl<T> Cursor<T> {\n+    /// Create a new cursor wrapping the provided underlying I/O object.\n+    pub fn new(inner: T) -> Cursor<T> {\n+        Cursor { pos: 0, inner: inner }\n+    }\n+\n+    /// Consume this cursor, returning the underlying value.\n+    pub fn into_inner(self) -> T { self.inner }\n+\n+    /// Get a reference to the underlying value in this cursor.\n+    pub fn get_ref(&self) -> &T { &self.inner }\n+\n+    /// Get a mutable reference to the underlying value in this cursor.\n+    ///\n+    /// Care should be taken to avoid modifying the internal I/O state of the\n+    /// underlying value as it may corrupt this cursor's position.\n+    pub fn get_mut(&mut self) -> &mut T { &mut self.inner }\n+\n+    /// Returns the current value of this cursor\n+    pub fn position(&self) -> u64 { self.pos }\n+\n+    /// Sets the value of this cursor\n+    pub fn set_position(&mut self, pos: u64) { self.pos = pos; }\n+}\n+\n+macro_rules! seek {\n+    () => {\n+        fn seek(&mut self, style: SeekFrom) -> io::Result<u64> {\n+            let pos = match style {\n+                SeekFrom::Start(n) => { self.pos = n; return Ok(n) }\n+                SeekFrom::End(n) => self.inner.len() as i64 + n,\n+                SeekFrom::Current(n) => self.pos as i64 + n,\n+            };\n+\n+            if pos < 0 {\n+                Err(Error::new(ErrorKind::InvalidInput,\n+                               \"invalid seek to a negative position\",\n+                               None))\n+            } else {\n+                self.pos = pos as u64;\n+                Ok(self.pos)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> io::Seek for Cursor<&'a [u8]> { seek!(); }\n+impl<'a> io::Seek for Cursor<&'a mut [u8]> { seek!(); }\n+impl io::Seek for Cursor<Vec<u8>> { seek!(); }\n+\n+macro_rules! read {\n+    () => {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let n = try!(Read::read(&mut try!(self.fill_buf()), buf));\n+            self.pos += n as u64;\n+            Ok(n)\n+        }\n+    }\n+}\n+\n+impl<'a> Read for Cursor<&'a [u8]> { read!(); }\n+impl<'a> Read for Cursor<&'a mut [u8]> { read!(); }\n+impl Read for Cursor<Vec<u8>> { read!(); }\n+\n+macro_rules! buffer {\n+    () => {\n+        fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+            let amt = cmp::min(self.pos, self.inner.len() as u64);\n+            Ok(&self.inner[(amt as usize)..])\n+        }\n+        fn consume(&mut self, amt: usize) { self.pos += amt as u64; }\n+    }\n+}\n+\n+impl<'a> BufRead for Cursor<&'a [u8]> { buffer!(); }\n+impl<'a> BufRead for Cursor<&'a mut [u8]> { buffer!(); }\n+impl<'a> BufRead for Cursor<Vec<u8>> { buffer!(); }\n+\n+impl<'a> Write for Cursor<&'a mut [u8]> {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        let pos = cmp::min(self.pos, self.inner.len() as u64);\n+        let amt = try!((&mut self.inner[(pos as usize)..]).write(data));\n+        self.pos += amt as u64;\n+        Ok(amt)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+impl Write for Cursor<Vec<u8>> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        // Make sure the internal buffer is as least as big as where we\n+        // currently are\n+        let pos = self.position();\n+        let amt = pos.saturating_sub(self.inner.len() as u64);\n+        self.inner.extend(repeat(0).take(amt as usize));\n+\n+        // Figure out what bytes will be used to overwrite what's currently\n+        // there (left), and what will be appended on the end (right)\n+        let space = self.inner.len() - pos as usize;\n+        let (left, right) = buf.split_at(cmp::min(space, buf.len()));\n+        slice::bytes::copy_memory(&mut self.inner[(pos as usize)..], left);\n+        self.inner.push_all(right);\n+\n+        // Bump us forward\n+        self.set_position(pos + buf.len() as u64);\n+        Ok(buf.len())\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use core::prelude::*;\n+\n+    use io::prelude::*;\n+    use io::{Cursor, SeekFrom};\n+    use vec::Vec;\n+\n+    #[test]\n+    fn test_vec_writer() {\n+        let mut writer = Vec::new();\n+        assert_eq!(writer.write(&[0]), Ok(1));\n+        assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n+        assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer, b);\n+    }\n+\n+    #[test]\n+    fn test_mem_writer() {\n+        let mut writer = Cursor::new(Vec::new());\n+        assert_eq!(writer.write(&[0]), Ok(1));\n+        assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n+        assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(&writer.get_ref()[], b);\n+    }\n+\n+    #[test]\n+    fn test_buf_writer() {\n+        let mut buf = [0 as u8; 9];\n+        {\n+            let mut writer = Cursor::new(&mut buf[]);\n+            assert_eq!(writer.position(), 0);\n+            assert_eq!(writer.write(&[0]), Ok(1));\n+            assert_eq!(writer.position(), 1);\n+            assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n+            assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+            assert_eq!(writer.position(), 8);\n+            assert_eq!(writer.write(&[]), Ok(0));\n+            assert_eq!(writer.position(), 8);\n+\n+            assert_eq!(writer.write(&[8, 9]), Ok(1));\n+            assert_eq!(writer.write(&[10]), Ok(0));\n+        }\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n+        assert_eq!(buf, b);\n+    }\n+\n+    #[test]\n+    fn test_buf_writer_seek() {\n+        let mut buf = [0 as u8; 8];\n+        {\n+            let mut writer = Cursor::new(&mut buf[]);\n+            assert_eq!(writer.position(), 0);\n+            assert_eq!(writer.write(&[1]), Ok(1));\n+            assert_eq!(writer.position(), 1);\n+\n+            assert_eq!(writer.seek(SeekFrom::Start(2)), Ok(2));\n+            assert_eq!(writer.position(), 2);\n+            assert_eq!(writer.write(&[2]), Ok(1));\n+            assert_eq!(writer.position(), 3);\n+\n+            assert_eq!(writer.seek(SeekFrom::Current(-2)), Ok(1));\n+            assert_eq!(writer.position(), 1);\n+            assert_eq!(writer.write(&[3]), Ok(1));\n+            assert_eq!(writer.position(), 2);\n+\n+            assert_eq!(writer.seek(SeekFrom::End(-1)), Ok(7));\n+            assert_eq!(writer.position(), 7);\n+            assert_eq!(writer.write(&[4]), Ok(1));\n+            assert_eq!(writer.position(), 8);\n+\n+        }\n+        let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n+        assert_eq!(buf, b);\n+    }\n+\n+    #[test]\n+    fn test_buf_writer_error() {\n+        let mut buf = [0 as u8; 2];\n+        let mut writer = Cursor::new(&mut buf[]);\n+        assert_eq!(writer.write(&[0]), Ok(1));\n+        assert_eq!(writer.write(&[0, 0]), Ok(1));\n+        assert_eq!(writer.write(&[0, 0]), Ok(0));\n+    }\n+\n+    #[test]\n+    fn test_mem_reader() {\n+        let mut reader = Cursor::new(vec!(0u8, 1, 2, 3, 4, 5, 6, 7));\n+        let mut buf = [];\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.position(), 0);\n+        let mut buf = [0];\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.position(), 1);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf, b);\n+        let mut buf = [0; 4];\n+        assert_eq!(reader.read(&mut buf), Ok(4));\n+        assert_eq!(reader.position(), 5);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf, b);\n+        assert_eq!(reader.read(&mut buf), Ok(3));\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(&buf[..3], b);\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+    }\n+\n+    #[test]\n+    fn read_to_end() {\n+        let mut reader = Cursor::new(vec!(0u8, 1, 2, 3, 4, 5, 6, 7));\n+        let mut v = Vec::new();\n+        reader.read_to_end(&mut v).ok().unwrap();\n+        assert_eq!(v, [0, 1, 2, 3, 4, 5, 6, 7]);\n+    }\n+\n+    #[test]\n+    fn test_slice_reader() {\n+        let in_buf = vec![0u8, 1, 2, 3, 4, 5, 6, 7];\n+        let mut reader = &mut in_buf.as_slice();\n+        let mut buf = [];\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        let mut buf = [0];\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.len(), 7);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf.as_slice(), b);\n+        let mut buf = [0; 4];\n+        assert_eq!(reader.read(&mut buf), Ok(4));\n+        assert_eq!(reader.len(), 3);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(reader.read(&mut buf), Ok(3));\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(&buf[..3], b);\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+    }\n+\n+    #[test]\n+    fn test_buf_reader() {\n+        let in_buf = vec![0u8, 1, 2, 3, 4, 5, 6, 7];\n+        let mut reader = Cursor::new(in_buf.as_slice());\n+        let mut buf = [];\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.position(), 0);\n+        let mut buf = [0];\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.position(), 1);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf, b);\n+        let mut buf = [0; 4];\n+        assert_eq!(reader.read(&mut buf), Ok(4));\n+        assert_eq!(reader.position(), 5);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf, b);\n+        assert_eq!(reader.read(&mut buf), Ok(3));\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(&buf[..3], b);\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+    }\n+\n+    #[test]\n+    fn test_read_char() {\n+        let b = b\"Vi\\xE1\\xBB\\x87t\";\n+        let mut c = Cursor::new(b).chars();\n+        assert_eq!(c.next(), Some(Ok('V')));\n+        assert_eq!(c.next(), Some(Ok('i')));\n+        assert_eq!(c.next(), Some(Ok('\u1ec7')));\n+        assert_eq!(c.next(), Some(Ok('t')));\n+        assert_eq!(c.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_read_bad_char() {\n+        let b = b\"\\x80\";\n+        let mut c = Cursor::new(b).chars();\n+        assert!(c.next().unwrap().is_err());\n+    }\n+\n+    #[test]\n+    fn seek_past_end() {\n+        let buf = [0xff];\n+        let mut r = Cursor::new(&buf[]);\n+        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n+        assert_eq!(r.read(&mut [0]), Ok(0));\n+\n+        let mut r = Cursor::new(vec!(10u8));\n+        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n+        assert_eq!(r.read(&mut [0]), Ok(0));\n+\n+        let mut buf = [0];\n+        let mut r = Cursor::new(&mut buf[]);\n+        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n+        assert_eq!(r.write(&[3]), Ok(0));\n+    }\n+\n+    #[test]\n+    fn seek_before_0() {\n+        let buf = [0xff_u8];\n+        let mut r = Cursor::new(&buf[]);\n+        assert!(r.seek(SeekFrom::End(-2)).is_err());\n+\n+        let mut r = Cursor::new(vec!(10u8));\n+        assert!(r.seek(SeekFrom::End(-2)).is_err());\n+\n+        let mut buf = [0];\n+        let mut r = Cursor::new(&mut buf[]);\n+        assert!(r.seek(SeekFrom::End(-2)).is_err());\n+    }\n+\n+    #[test]\n+    fn test_seekable_mem_writer() {\n+        let mut writer = Cursor::new(Vec::<u8>::new());\n+        assert_eq!(writer.position(), 0);\n+        assert_eq!(writer.write(&[0]), Ok(1));\n+        assert_eq!(writer.position(), 1);\n+        assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n+        assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+        assert_eq!(writer.position(), 8);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(&writer.get_ref()[], b);\n+\n+        assert_eq!(writer.seek(SeekFrom::Start(0)), Ok(0));\n+        assert_eq!(writer.position(), 0);\n+        assert_eq!(writer.write(&[3, 4]), Ok(2));\n+        let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(&writer.get_ref()[], b);\n+\n+        assert_eq!(writer.seek(SeekFrom::Current(1)), Ok(3));\n+        assert_eq!(writer.write(&[0, 1]), Ok(2));\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n+        assert_eq!(&writer.get_ref()[], b);\n+\n+        assert_eq!(writer.seek(SeekFrom::End(-1)), Ok(7));\n+        assert_eq!(writer.write(&[1, 2]), Ok(2));\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n+        assert_eq!(&writer.get_ref()[], b);\n+\n+        assert_eq!(writer.seek(SeekFrom::End(1)), Ok(10));\n+        assert_eq!(writer.write(&[1]), Ok(1));\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n+        assert_eq!(&writer.get_ref()[], b);\n+    }\n+\n+    #[test]\n+    fn vec_seek_past_end() {\n+        let mut r = Cursor::new(Vec::new());\n+        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n+        assert_eq!(r.write(&[3]), Ok(1));\n+    }\n+\n+    #[test]\n+    fn vec_seek_before_0() {\n+        let mut r = Cursor::new(Vec::new());\n+        assert!(r.seek(SeekFrom::End(-2)).is_err());\n+    }\n+}"}, {"sha": "9f3cd8c8b15deb4b68978d0df8c8343fe8486831", "filename": "src/libstd/io/error.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=5cf9905e257ddeeadaf493a705a230081a6c7da3", "patch": "@@ -0,0 +1,183 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use boxed::Box;\n+use clone::Clone;\n+use error::Error as StdError;\n+use fmt;\n+use option::Option::{self, Some, None};\n+use result;\n+use string::String;\n+use sys;\n+\n+/// A type for results generated by I/O related functions where the `Err` type\n+/// is hard-wired to `io::Error`.\n+///\n+/// This typedef is generally used to avoid writing out `io::Error` directly and\n+/// is otherwise a direct mapping to `std::result::Result`.\n+pub type Result<T> = result::Result<T, Error>;\n+\n+/// The error type for I/O operations of the `Read`, `Write`, `Seek`, and\n+/// associated traits.\n+///\n+/// Errors mostly originate from the underlying OS, but custom instances of\n+/// `Error` can be created with crafted error messages and a particular value of\n+/// `ErrorKind`.\n+#[derive(PartialEq, Eq, Clone, Debug)]\n+pub struct Error {\n+    repr: Repr,\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Debug)]\n+enum Repr {\n+    Os(i32),\n+    Custom(Box<Custom>),\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Debug)]\n+struct Custom {\n+    kind: ErrorKind,\n+    desc: &'static str,\n+    detail: Option<String>\n+}\n+\n+/// A list specifying general categories of I/O error.\n+#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n+pub enum ErrorKind {\n+    /// The file was not found.\n+    FileNotFound,\n+    /// The file permissions disallowed access to this file.\n+    PermissionDenied,\n+    /// The connection was refused by the remote server.\n+    ConnectionRefused,\n+    /// The connection was reset by the remote server.\n+    ConnectionReset,\n+    /// The connection was aborted (terminated) by the remote server.\n+    ConnectionAborted,\n+    /// The network operation failed because it was not connected yet.\n+    NotConnected,\n+    /// The operation failed because a pipe was closed.\n+    BrokenPipe,\n+    /// A file already existed with that name.\n+    PathAlreadyExists,\n+    /// No file exists at that location.\n+    PathDoesntExist,\n+    /// The path did not specify the type of file that this operation required.\n+    /// For example, attempting to copy a directory with the `fs::copy()`\n+    /// operation will fail with this error.\n+    MismatchedFileTypeForOperation,\n+    /// The operation temporarily failed (for example, because a signal was\n+    /// received), and retrying may succeed.\n+    ResourceUnavailable,\n+    /// A parameter was incorrect in a way that caused an I/O error not part of\n+    /// this list.\n+    InvalidInput,\n+    /// The I/O operation's timeout expired, causing it to be canceled.\n+    TimedOut,\n+    /// An error returned when an operation could not be completed because a\n+    /// call to `write` returned `Ok(0)`.\n+    ///\n+    /// This typically means that an operation could only succeed if it wrote a\n+    /// particular number of bytes but only a smaller number of bytes could be\n+    /// written.\n+    WriteZero,\n+    /// This operation was interrupted\n+    Interrupted,\n+    /// Any I/O error not part of this list.\n+    Other,\n+}\n+\n+impl Error {\n+    /// Creates a new custom error from a specified kind/description/detail.\n+    pub fn new(kind: ErrorKind,\n+               description: &'static str,\n+               detail: Option<String>) -> Error {\n+        Error {\n+            repr: Repr::Custom(Box::new(Custom {\n+                kind: kind,\n+                desc: description,\n+                detail: detail,\n+            }))\n+        }\n+    }\n+\n+    /// Returns an error representing the last OS error which occurred.\n+    ///\n+    /// This function reads the value of `errno` for the target platform (e.g.\n+    /// `GetLastError` on Windows) and will return a corresponding instance of\n+    /// `Error` for the error code.\n+    pub fn last_os_error() -> Error {\n+        Error::from_os_error(sys::os::errno() as i32)\n+    }\n+\n+    /// Creates a new instance of an `Error` from a particular OS error code.\n+    pub fn from_os_error(code: i32) -> Error {\n+        Error { repr: Repr::Os(code) }\n+    }\n+\n+    /// Return the corresponding `ErrorKind` for this error.\n+    pub fn kind(&self) -> ErrorKind {\n+        match self.repr {\n+            Repr::Os(code) => sys::decode_error_kind(code),\n+            Repr::Custom(ref c) => c.kind,\n+        }\n+    }\n+\n+    /// Returns a short description for this error message\n+    pub fn description(&self) -> &str {\n+        match self.repr {\n+            Repr::Os(..) => \"os error\",\n+            Repr::Custom(ref c) => c.desc,\n+        }\n+    }\n+\n+    /// Returns a detailed error message for this error (if one is available)\n+    pub fn detail(&self) -> Option<String> {\n+        match self.repr {\n+            Repr::Os(code) => Some(sys::os::error_string(code)),\n+            Repr::Custom(ref s) => s.detail.clone(),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match self.repr {\n+            Repr::Os(code) => {\n+                let detail = sys::os::error_string(code);\n+                write!(fmt, \"{} (os error {})\", detail, code)\n+            }\n+            Repr::Custom(ref c) => {\n+                match **c {\n+                    Custom {\n+                        kind: ErrorKind::Other,\n+                        desc: \"unknown error\",\n+                        detail: Some(ref detail)\n+                    } => {\n+                        write!(fmt, \"{}\", detail)\n+                    }\n+                    Custom { detail: None, desc, .. } =>\n+                        write!(fmt, \"{}\", desc),\n+                    Custom { detail: Some(ref detail), desc, .. } =>\n+                        write!(fmt, \"{} ({})\", desc, detail)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl StdError for Error {\n+    fn description(&self) -> &str {\n+        match self.repr {\n+            Repr::Os(..) => \"os error\",\n+            Repr::Custom(ref c) => c.desc,\n+        }\n+    }\n+}"}, {"sha": "7f3ce7924c1caaa0fe8bfefdcf4968c80e95d201", "filename": "src/libstd/io/impls.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=5cf9905e257ddeeadaf493a705a230081a6c7da3", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use cmp;\n+use io::{self, SeekFrom, Read, Write, Seek, BufRead};\n+use mem;\n+use slice;\n+use vec::Vec;\n+\n+// =============================================================================\n+// Forwarding implementations\n+\n+impl<'a, R: Read + ?Sized> Read for &'a mut R {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { (**self).read(buf) }\n+}\n+impl<'a, W: Write + ?Sized> Write for &'a mut W {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n+    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n+}\n+impl<'a, S: Seek + ?Sized> Seek for &'a mut S {\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n+}\n+impl<'a, B: BufRead + ?Sized> BufRead for &'a mut B {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n+    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n+}\n+\n+impl<R: Read + ?Sized> Read for Box<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { (**self).read(buf) }\n+}\n+impl<W: Write + ?Sized> Write for Box<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n+    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n+}\n+impl<S: Seek + ?Sized> Seek for Box<S> {\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n+}\n+impl<B: BufRead + ?Sized> BufRead for Box<B> {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n+    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n+}\n+\n+// =============================================================================\n+// In-memory buffer implementations\n+\n+impl<'a> Read for &'a [u8] {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        let amt = cmp::min(buf.len(), self.len());\n+        let (a, b) = self.split_at(amt);\n+        slice::bytes::copy_memory(buf, a);\n+        *self = b;\n+        Ok(amt)\n+    }\n+}\n+\n+impl<'a> BufRead for &'a [u8] {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(*self) }\n+    fn consume(&mut self, amt: usize) { *self = &self[amt..]; }\n+}\n+\n+impl<'a> Write for &'a mut [u8] {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        let amt = cmp::min(data.len(), self.len());\n+        let (a, b) = mem::replace(self, &mut []).split_at_mut(amt);\n+        slice::bytes::copy_memory(a, &data[..amt]);\n+        *self = b;\n+        Ok(amt)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+impl Write for Vec<u8> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.push_all(buf);\n+        Ok(buf.len())\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}"}, {"sha": "0832206a48b6086bf77b0e5cca1fdb2f87a9c88b", "filename": "src/libstd/io/mod.rs", "status": "added", "additions": 948, "deletions": 0, "changes": 948, "blob_url": "https://github.com/rust-lang/rust/blob/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5cf9905e257ddeeadaf493a705a230081a6c7da3", "patch": "@@ -0,0 +1,948 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Traits, helpers, and type definitions for core I/O functionality.\n+//!\n+//! > **NOTE**: This module is very much a work in progress and is under active\n+//! > development. At this time it is still recommended to use the `old_io`\n+//! > module while the details of this module shake out.\n+\n+#![unstable(feature = \"io\",\n+            reason = \"this new I/O module is still under active deveopment and \\\n+                      APIs are subject to tweaks fairly regularly\")]\n+\n+use cmp;\n+use unicode::str as core_str;\n+use error::Error as StdError;\n+use fmt;\n+use iter::Iterator;\n+use marker::Sized;\n+use mem;\n+use ops::{Drop, FnOnce};\n+use option::Option::{self, Some, None};\n+use ptr::PtrExt;\n+use result::Result::{Ok, Err};\n+use result;\n+use slice::{self, SliceExt};\n+use string::String;\n+use str::{self, StrExt};\n+use vec::Vec;\n+\n+pub use self::buffered::{BufReader, BufWriter, BufStream, LineWriter};\n+pub use self::buffered::IntoInnerError;\n+pub use self::cursor::Cursor;\n+pub use self::error::{Result, Error, ErrorKind};\n+pub use self::util::{copy, sink, Sink, empty, Empty, repeat, Repeat};\n+\n+pub mod prelude;\n+mod buffered;\n+mod cursor;\n+mod error;\n+mod impls;\n+mod util;\n+\n+const DEFAULT_BUF_SIZE: usize = 64 * 1024;\n+\n+// Acquires a slice of the vector `v` from its length to its capacity\n+// (uninitialized data), reads into it, and then updates the length.\n+//\n+// This function is leveraged to efficiently read some bytes into a destination\n+// vector without extra copying and taking advantage of the space that's already\n+// in `v`.\n+//\n+// The buffer we're passing down, however, is pointing at uninitialized data\n+// (the end of a `Vec`), and many operations will be *much* faster if we don't\n+// have to zero it out. In order to prevent LLVM from generating an `undef`\n+// value when reads happen from this uninitialized memory, we force LLVM to\n+// think it's initialized by sending it through a black box. This should prevent\n+// actual undefined behavior after optimizations.\n+fn with_end_to_cap<F>(v: &mut Vec<u8>, f: F) -> Result<usize>\n+    where F: FnOnce(&mut [u8]) -> Result<usize>\n+{\n+    unsafe {\n+        let n = try!(f({\n+            let base = v.as_mut_ptr().offset(v.len() as isize);\n+            black_box(slice::from_raw_mut_buf(mem::copy_lifetime(v, &base),\n+                                              v.capacity() - v.len()))\n+        }));\n+\n+        // If the closure (typically a `read` implementation) reported that it\n+        // read a larger number of bytes than the vector actually has, we need\n+        // to be sure to clamp the vector to at most its capacity.\n+        let new_len = cmp::min(v.capacity(), v.len() + n);\n+        v.set_len(new_len);\n+        return Ok(n);\n+    }\n+\n+    // Semi-hack used to prevent LLVM from retaining any assumptions about\n+    // `dummy` over this function call\n+    unsafe fn black_box<T>(mut dummy: T) -> T {\n+        asm!(\"\" :: \"r\"(&mut dummy) : \"memory\");\n+        dummy\n+    }\n+}\n+\n+// A few methods below (read_to_string, read_line) will append data into a\n+// `String` buffer, but we need to be pretty careful when doing this. The\n+// implementation will just call `.as_mut_vec()` and then delegate to a\n+// byte-oriented reading method, but we must ensure that when returning we never\n+// leave `buf` in a state such that it contains invalid UTF-8 in its bounds.\n+//\n+// To this end, we use an RAII guard (to protect against panics) which updates\n+// the length of the string when it is dropped. This guard initially truncates\n+// the string to the prior length and only afer we've validated that the\n+// new contents are valid UTF-8 do we allow it to set a longer length.\n+//\n+// The unsafety in this function is twofold:\n+//\n+// 1. We're looking at the raw bytes of `buf`, so we take on the burden of UTF-8\n+//    checks.\n+// 2. We're passing a raw buffer to the function `f`, and it is expected that\n+//    the function only *appends* bytes to the buffer. We'll get undefined\n+//    behavior if existing bytes are overwritten to have non-UTF-8 data.\n+fn append_to_string<F>(buf: &mut String, f: F) -> Result<()>\n+    where F: FnOnce(&mut Vec<u8>) -> Result<()>\n+{\n+    struct Guard<'a> { s: &'a mut Vec<u8>, len: usize }\n+    #[unsafe_destructor]\n+    impl<'a> Drop for Guard<'a> {\n+        fn drop(&mut self) {\n+            unsafe { self.s.set_len(self.len); }\n+        }\n+    }\n+\n+    unsafe {\n+        let mut g = Guard { len: buf.len(), s: buf.as_mut_vec() };\n+        let ret = f(g.s);\n+        if str::from_utf8(&g.s[g.len..]).is_err() {\n+            ret.and_then(|()| {\n+                Err(Error::new(ErrorKind::InvalidInput,\n+                               \"stream did not contain valid UTF-8\", None))\n+            })\n+        } else {\n+            g.len = g.s.len();\n+            ret\n+        }\n+    }\n+}\n+\n+fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<()> {\n+    loop {\n+        if buf.capacity() == buf.len() {\n+            buf.reserve(DEFAULT_BUF_SIZE);\n+        }\n+        match with_end_to_cap(buf, |b| r.read(b)) {\n+            Ok(0) => return Ok(()),\n+            Ok(_) => {}\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+            Err(e) => return Err(e),\n+        }\n+    }\n+}\n+\n+/// A trait for objects which are byte-oriented sources.\n+///\n+/// Readers are defined by one method, `read`. Each call to `read` will attempt\n+/// to pull bytes from this source into a provided buffer.\n+///\n+/// Readers are intended to be composable with one another. Many objects\n+/// throughout the I/O and related libraries take and provide types which\n+/// implement the `Read` trait.\n+pub trait Read {\n+    /// Pull some bytes from this source into the specified buffer, returning\n+    /// how many bytes were read.\n+    ///\n+    /// This function does not provide any guarantees about whether it blocks\n+    /// waiting for data, but if an object needs to block for a read but cannot\n+    /// it will typically signal this via an `Err` return value.\n+    ///\n+    /// If the return value of this method is `Ok(n)`, then it must be\n+    /// guaranteed that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n+    /// that the buffer `buf` has ben filled in with `n` bytes of data from this\n+    /// source. If `n` is `0`, then it can indicate one of two scenarios:\n+    ///\n+    /// 1. This reader has reached its \"end of file\" and will likely no longer\n+    ///    be able to produce bytes. Note that this does not mean that the\n+    ///    reader will *always* no longer be able to produce bytes.\n+    /// 2. The buffer specified was 0 bytes in length.\n+    ///\n+    /// No guarantees are provided about the contents of `buf` when this\n+    /// function is called, implementations cannot rely on any property of the\n+    /// contents of `buf` being true. It is recommended that implementations\n+    /// only write data to `buf` instead of reading its contents.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters any form of I/O or other error, an error\n+    /// variant will be returned. If an error is returned then it must be\n+    /// guaranteed that no bytes were read.\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n+\n+    /// Read all bytes until EOF in this source, placing them into `buf`.\n+    ///\n+    /// All bytes read from this source will be appended to the specified buffer\n+    /// `buf`. This function will return a call to `read` either:\n+    ///\n+    /// 1. Returns `Ok(0)`.\n+    /// 2. Returns an error which is not of the kind `ErrorKind::Interrupted`.\n+    ///\n+    /// Until one of these conditions is met the function will continuously\n+    /// invoke `read` to append more data to `buf`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind\n+    /// `ErrorKind::Interrupted` then the error is ignored and the operation\n+    /// will continue.\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns. Any bytes which have already been read will be appended to\n+    /// `buf`.\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<()> {\n+        read_to_end(self, buf)\n+    }\n+\n+    /// Read all bytes until EOF in this source, placing them into `buf`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the data in this stream is *not* valid UTF-8 then an error is\n+    /// returned and `buf` is unchanged.\n+    ///\n+    /// See `read_to_end` for other error semantics.\n+    fn read_to_string(&mut self, buf: &mut String) -> Result<()> {\n+        // Note that we do *not* call `.read_to_end()` here. We are passing\n+        // `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end`\n+        // method to fill it up. An arbitrary implementation could overwrite the\n+        // entire contents of the vector, not just append to it (which is what\n+        // we are expecting).\n+        //\n+        // To prevent extraneously checking the UTF-8-ness of the entire buffer\n+        // we pass it to our hardcoded `read_to_end` implementation which we\n+        // know is guaranteed to only read data into the end of the buffer.\n+        append_to_string(buf, |b| read_to_end(self, b))\n+    }\n+}\n+\n+/// Extension methods for all instances of `Read`, typically imported through\n+/// `std::io::prelude::*`.\n+pub trait ReadExt: Read + Sized {\n+    /// Create a \"by reference\" adaptor for this instance of `Read`.\n+    ///\n+    /// The returned adaptor also implements `Read` and will simply borrow this\n+    /// current reader.\n+    fn by_ref(&mut self) -> &mut Self { self }\n+\n+    /// Transform this `Read` instance to an `Iterator` over its bytes.\n+    ///\n+    /// The returned type implements `Iterator` where the `Item` is `Result<u8,\n+    /// R::Err>`.  The yielded item is `Ok` if a byte was successfully read and\n+    /// `Err` otherwise for I/O errors. EOF is mapped to returning `None` from\n+    /// this iterator.\n+    fn bytes(self) -> Bytes<Self> {\n+        Bytes { inner: self }\n+    }\n+\n+    /// Transform this `Read` instance to an `Iterator` over `char`s.\n+    ///\n+    /// This adaptor will attempt to interpret this reader as an UTF-8 encoded\n+    /// sequence of characters. The returned iterator will return `None` once\n+    /// EOF is reached for this reader. Otherwise each element yielded will be a\n+    /// `Result<char, E>` where `E` may contain information about what I/O error\n+    /// occurred or where decoding failed.\n+    ///\n+    /// Currently this adaptor will discard intermediate data read, and should\n+    /// be avoided if this is not desired.\n+    fn chars(self) -> Chars<Self> {\n+        Chars { inner: self }\n+    }\n+\n+    /// Create an adaptor which will chain this stream with another.\n+    ///\n+    /// The returned `Read` instance will first read all bytes from this object\n+    /// until EOF is encountered. Afterwards the output is equivalent to the\n+    /// output of `next`.\n+    fn chain<R: Read>(self, next: R) -> Chain<Self, R> {\n+        Chain { first: self, second: next, done_first: false }\n+    }\n+\n+    /// Create an adaptor which will read at most `limit` bytes from it.\n+    ///\n+    /// This function returns a new instance of `Read` which will read at most\n+    /// `limit` bytes, after which it will always return EOF (`Ok(0)`). Any\n+    /// read errors will not count towards the number of bytes read and future\n+    /// calls to `read` may succeed.\n+    fn take(self, limit: u64) -> Take<Self> {\n+        Take { inner: self, limit: limit }\n+    }\n+\n+    /// Creates a reader adaptor which will write all read data into the given\n+    /// output stream.\n+    ///\n+    /// Whenever the returned `Read` instance is read it will write the read\n+    /// data to `out`. The current semantics of this implementation imply that\n+    /// a `write` error will not report how much data was initially read.\n+    fn tee<W: Write>(self, out: W) -> Tee<Self, W> {\n+        Tee { reader: self, writer: out }\n+    }\n+}\n+\n+impl<T: Read> ReadExt for T {}\n+\n+/// A trait for objects which are byte-oriented sinks.\n+///\n+/// The `write` method will attempt to write some data into the object,\n+/// returning how many bytes were successfully written.\n+///\n+/// The `flush` method is useful for adaptors and explicit buffers themselves\n+/// for ensuring that all buffered data has been pushed out to the \"true sink\".\n+///\n+/// Writers are intended to be composable with one another. Many objects\n+/// throughout the I/O and related libraries take and provide types which\n+/// implement the `Write` trait.\n+pub trait Write {\n+    /// Write a buffer into this object, returning how many bytes were written.\n+    ///\n+    /// This function will attempt to write the entire contents of `buf`, but\n+    /// the entire write may not succeed, or the write may also generate an\n+    /// error. A call to `write` represents *at most one* attempt to write to\n+    /// any wrapped object.\n+    ///\n+    /// Calls to `write` are not guaranteed to block waiting for data to be\n+    /// written, and a write which would otherwise block can indicated through\n+    /// an `Err` variant.\n+    ///\n+    /// If the return value is `Ok(n)` then it must be guaranteed that\n+    /// `0 <= n <= buf.len()`. A return value of `0` typically means that the\n+    /// underlying object is no longer able to accept bytes and will likely not\n+    /// be able to in the future as well, or that the buffer provided is empty.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Each call to `write` may generate an I/O error indicating that the\n+    /// operation could not be completed. If an error is returned then no bytes\n+    /// in the buffer were written to this writer.\n+    ///\n+    /// It is **not** considered an error if the entire buffer could not be\n+    /// written to this writer.\n+    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n+\n+    /// Flush this output stream, ensuring that all intermediately buffered\n+    /// contents reach their destination.\n+    ///\n+    /// # Errors\n+    ///\n+    /// It is considered an error if not all bytes could be written due to\n+    /// I/O errors or EOF being reached.\n+    fn flush(&mut self) -> Result<()>;\n+\n+    /// Attempts to write an entire buffer into this write.\n+    ///\n+    /// This method will continuously call `write` while there is more data to\n+    /// write. This method will not return until the entire buffer has been\n+    /// successfully written or an error occurs. The first error generated from\n+    /// this method will be returned.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return the first error that `write` returns.\n+    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n+        while buf.len() > 0 {\n+            match self.write(buf) {\n+                Ok(0) => return Err(Error::new(ErrorKind::WriteZero,\n+                                               \"failed to write whole buffer\",\n+                                               None)),\n+                Ok(n) => buf = &buf[n..],\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Writes a formatted string into this writer, returning any error\n+    /// encountered.\n+    ///\n+    /// This method is primarily used to interface with the `format_args!`\n+    /// macro, but it is rare that this should explicitly be called. The\n+    /// `write!` macro should be favored to invoke this method instead.\n+    ///\n+    /// This function internally uses the `write_all` method on this trait and\n+    /// hence will continuously write data so long as no errors are received.\n+    /// This also means that partial writes are not indicated in this signature.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return any I/O error reported while formatting.\n+    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> {\n+        // Create a shim which translates a Writer to a fmt::Writer and saves\n+        // off I/O errors. instead of discarding them\n+        struct Adaptor<'a, T: ?Sized + 'a> {\n+            inner: &'a mut T,\n+            error: Result<()>,\n+        }\n+\n+        impl<'a, T: Write + ?Sized> fmt::Writer for Adaptor<'a, T> {\n+            fn write_str(&mut self, s: &str) -> fmt::Result {\n+                match self.inner.write_all(s.as_bytes()) {\n+                    Ok(()) => Ok(()),\n+                    Err(e) => {\n+                        self.error = Err(e);\n+                        Err(fmt::Error)\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut output = Adaptor { inner: self, error: Ok(()) };\n+        match fmt::write(&mut output, fmt) {\n+            Ok(()) => Ok(()),\n+            Err(..) => output.error\n+        }\n+    }\n+}\n+\n+/// Extension methods for all instances of `Write`, typically imported through\n+/// `std::io::prelude::*`.\n+pub trait WriteExt: Write + Sized {\n+    /// Create a \"by reference\" adaptor for this instance of `Write`.\n+    ///\n+    /// The returned adaptor also implements `Write` and will simply borrow this\n+    /// current writer.\n+    fn by_ref(&mut self) -> &mut Self { self }\n+\n+    /// Creates a new writer which will write all data to both this writer and\n+    /// another writer.\n+    ///\n+    /// All data written to the returned writer will both be written to `self`\n+    /// as well as `other`. Note that the error semantics of the current\n+    /// implementation do not precisely track where errors happen. For example\n+    /// an error on the second call to `write` will not report that the first\n+    /// call to `write` succeeded.\n+    fn broadcast<W: Write>(self, other: W) -> Broadcast<Self, W> {\n+        Broadcast { first: self, second: other }\n+    }\n+}\n+\n+impl<T: Write> WriteExt for T {}\n+\n+/// An object implementing `Seek` internally has some form of cursor which can\n+/// be moved within a stream of bytes.\n+///\n+/// The stream typically has a fixed size, allowing seeking relative to either\n+/// end or the current offset.\n+pub trait Seek {\n+    /// Seek to an offset, in bytes, in a stream\n+    ///\n+    /// A seek beyond the end of a stream is allowed, but seeking before offset\n+    /// 0 is an error.\n+    ///\n+    /// Seeking past the end of the stream does not modify the underlying\n+    /// stream, but the next write may cause the previous data to be filled in\n+    /// with a bit pattern.\n+    ///\n+    /// This method returns the new position within the stream if the seek\n+    /// operation completed successfully.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Seeking to a negative offset is considered an error\n+    fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n+}\n+\n+/// Enumeration of possible methods to seek within an I/O object.\n+#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n+pub enum SeekFrom {\n+    /// Set the offset to the provided number of bytes.\n+    Start(u64),\n+\n+    /// Set the offset to the size of this object plus the specified number of\n+    /// bytes.\n+    ///\n+    /// It is possible to seek beyond the end of an object, but is an error to\n+    /// seek before byte 0.\n+    End(i64),\n+\n+    /// Set the offset to the current position plus the specified number of\n+    /// bytes.\n+    ///\n+    /// It is possible to seek beyond the end of an object, but is an error to\n+    /// seek before byte 0.\n+    Current(i64),\n+}\n+\n+fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n+                                   -> Result<()> {\n+    loop {\n+        let (done, used) = {\n+            let available = match r.fill_buf() {\n+                Ok(n) => n,\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+                Err(e) => return Err(e)\n+            };\n+            match available.position_elem(&delim) {\n+                Some(i) => {\n+                    buf.push_all(&available[..i + 1]);\n+                    (true, i + 1)\n+                }\n+                None => {\n+                    buf.push_all(available);\n+                    (false, available.len())\n+                }\n+            }\n+        };\n+        r.consume(used);\n+        if done || used == 0 {\n+            return Ok(());\n+        }\n+    }\n+}\n+\n+/// A Buffer is a type of reader which has some form of internal buffering to\n+/// allow certain kinds of reading operations to be more optimized than others.\n+///\n+/// This type extends the `Read` trait with a few methods that are not\n+/// possible to reasonably implement with purely a read interface.\n+pub trait BufRead: Read {\n+    /// Fills the internal buffer of this object, returning the buffer contents.\n+    ///\n+    /// None of the contents will be \"read\" in the sense that later calling\n+    /// `read` may return the same contents.\n+    ///\n+    /// The `consume` function must be called with the number of bytes that are\n+    /// consumed from this buffer returned to ensure that the bytes are never\n+    /// returned twice.\n+    ///\n+    /// An empty buffer returned indicates that the stream has reached EOF.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return an I/O error if the underlying reader was\n+    /// read, but returned an error.\n+    fn fill_buf(&mut self) -> Result<&[u8]>;\n+\n+    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n+    /// so they should no longer be returned in calls to `read`.\n+    fn consume(&mut self, amt: usize);\n+\n+    /// Read all bytes until the delimiter `byte` is reached.\n+    ///\n+    /// This function will continue to read (and buffer) bytes from the\n+    /// underlying stream until the delimiter or EOF is found. Once found, all\n+    /// bytes up to, and including, the delimiter (if found) will be appended to\n+    /// `buf`.\n+    ///\n+    /// If this buffered reader is currently at EOF, then this function will not\n+    /// place any more bytes into `buf` and will return `Ok(())`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will ignore all instances of `ErrorKind::Interrupted` and\n+    /// will otherwise return any errors returned by `fill_buf`.\n+    ///\n+    /// If an I/O error is encountered then all bytes read so far will be\n+    /// present in `buf` and its length will have been adjusted appropriately.\n+    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<()> {\n+        read_until(self, byte, buf)\n+    }\n+\n+    /// Read all bytes until a newline byte (the 0xA byte) is reached.\n+    ///\n+    /// This function will continue to read (and buffer) bytes from the\n+    /// underlying stream until the newline delimiter (the 0xA byte) or EOF is\n+    /// found. Once found, all bytes up to, and including, the delimiter (if\n+    /// found) will be appended to `buf`.\n+    ///\n+    /// If this reader is currently at EOF then this function will not modify\n+    /// `buf` and will return `Ok(())`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function has the same error semantics as `read_until` and will also\n+    /// return an error if the read bytes are not valid UTF-8. If an I/O error\n+    /// is encountered then `buf` may contain some bytes already read in the\n+    /// event that all data read so far was valid UTF-8.\n+    fn read_line(&mut self, buf: &mut String) -> Result<()> {\n+        // Note that we are not calling the `.read_until` method here, but\n+        // rather our hardcoded implementation. For more details as to why, see\n+        // the comments in `read_to_end`.\n+        append_to_string(buf, |b| read_until(self, b'\\n', b))\n+    }\n+}\n+\n+/// Extension methods for all instances of `BufRead`, typically imported through\n+/// `std::io::prelude::*`.\n+pub trait BufReadExt: BufRead + Sized {\n+    /// Returns an iterator over the contents of this reader split on the byte\n+    /// `byte`.\n+    ///\n+    /// The iterator returned from this function will return instances of\n+    /// `io::Result<Vec<u8>>`. Each vector returned will *not* have the\n+    /// delimiter byte at the end.\n+    ///\n+    /// This function will yield errors whenever `read_until` would have also\n+    /// yielded an error.\n+    fn split(self, byte: u8) -> Split<Self> {\n+        Split { buf: self, delim: byte }\n+    }\n+\n+    /// Returns an iterator over the lines of this reader.\n+    ///\n+    /// The iterator returned from this function will yield instances of\n+    /// `io::Result<String>`. Each string returned will *not* have a newline\n+    /// byte (the 0xA byte) at the end.\n+    ///\n+    /// This function will yield errors whenever `read_string` would have also\n+    /// yielded an error.\n+    fn lines(self) -> Lines<Self> {\n+        Lines { buf: self }\n+    }\n+}\n+\n+impl<T: BufRead> BufReadExt for T {}\n+\n+/// A `Write` adaptor which will write data to multiple locations.\n+///\n+/// For more information, see `WriteExt::broadcast`.\n+pub struct Broadcast<T, U> {\n+    first: T,\n+    second: U,\n+}\n+\n+impl<T: Write, U: Write> Write for Broadcast<T, U> {\n+    fn write(&mut self, data: &[u8]) -> Result<usize> {\n+        let n = try!(self.first.write(data));\n+        // FIXME: what if the write fails? (we wrote something)\n+        try!(self.second.write_all(&data[..n]));\n+        Ok(n)\n+    }\n+\n+    fn flush(&mut self) -> Result<()> {\n+        self.first.flush().and(self.second.flush())\n+    }\n+}\n+\n+/// Adaptor to chain together two instances of `Read`.\n+///\n+/// For more information, see `ReadExt::chain`.\n+pub struct Chain<T, U> {\n+    first: T,\n+    second: U,\n+    done_first: bool,\n+}\n+\n+impl<T: Read, U: Read> Read for Chain<T, U> {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        if !self.done_first {\n+            match try!(self.first.read(buf)) {\n+                0 => { self.done_first = true; }\n+                n => return Ok(n),\n+            }\n+        }\n+        self.second.read(buf)\n+    }\n+}\n+\n+/// Reader adaptor which limits the bytes read from an underlying reader.\n+///\n+/// For more information, see `ReadExt::take`.\n+pub struct Take<T> {\n+    inner: T,\n+    limit: u64,\n+}\n+\n+impl<T> Take<T> {\n+    /// Returns the number of bytes that can be read before this instance will\n+    /// return EOF.\n+    ///\n+    /// # Note\n+    ///\n+    /// This instance may reach EOF after reading fewer bytes than indiccated by\n+    /// this method if the underlying `Read` instance reaches EOF.\n+    pub fn limit(&self) -> u64 { self.limit }\n+}\n+\n+impl<T: Read> Read for Take<T> {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        let max = cmp::min(buf.len() as u64, self.limit) as usize;\n+        let n = try!(self.inner.read(&mut buf[..max]));\n+        self.limit -= n as u64;\n+        Ok(n)\n+    }\n+}\n+\n+/// An adaptor which will emit all read data to a specified writer as well.\n+///\n+/// For more information see `ReadExt::tee`\n+pub struct Tee<R, W> {\n+    reader: R,\n+    writer: W,\n+}\n+\n+impl<R: Read, W: Write> Read for Tee<R, W> {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        let n = try!(self.reader.read(buf));\n+        // FIXME: what if the write fails? (we read something)\n+        try!(self.writer.write_all(&buf[..n]));\n+        Ok(n)\n+    }\n+}\n+\n+/// A bridge from implementations of `Read` to an `Iterator` of `u8`.\n+///\n+/// See `ReadExt::bytes` for more information.\n+pub struct Bytes<R> {\n+    inner: R,\n+}\n+\n+impl<R: Read> Iterator for Bytes<R> {\n+    type Item = Result<u8>;\n+\n+    fn next(&mut self) -> Option<Result<u8>> {\n+        let mut buf = [0];\n+        match self.inner.read(&mut buf) {\n+            Ok(0) => None,\n+            Ok(..) => Some(Ok(buf[0])),\n+            Err(e) => Some(Err(e)),\n+        }\n+    }\n+}\n+\n+/// A bridge from implementations of `Read` to an `Iterator` of `char`.\n+///\n+/// See `ReadExt::chars` for more information.\n+pub struct Chars<R> {\n+    inner: R,\n+}\n+\n+/// An enumeration of possible errors that can be generated from the `Chars`\n+/// adapter.\n+#[derive(PartialEq, Clone, Debug)]\n+pub enum CharsError {\n+    /// Variant representing that the underlying stream was read successfully\n+    /// but it did not contain valid utf8 data.\n+    NotUtf8,\n+\n+    /// Variant representing that an I/O error occurred.\n+    Other(Error),\n+}\n+\n+impl<R: Read> Iterator for Chars<R> {\n+    type Item = result::Result<char, CharsError>;\n+\n+    fn next(&mut self) -> Option<result::Result<char, CharsError>> {\n+        let mut buf = [0];\n+        let first_byte = match self.inner.read(&mut buf) {\n+            Ok(0) => return None,\n+            Ok(..) => buf[0],\n+            Err(e) => return Some(Err(CharsError::Other(e))),\n+        };\n+        let width = core_str::utf8_char_width(first_byte);\n+        if width == 1 { return Some(Ok(first_byte as char)) }\n+        if width == 0 { return Some(Err(CharsError::NotUtf8)) }\n+        let mut buf = [first_byte, 0, 0, 0];\n+        {\n+            let mut start = 1;\n+            while start < width {\n+                match self.inner.read(&mut buf[start..width]) {\n+                    Ok(0) => return Some(Err(CharsError::NotUtf8)),\n+                    Ok(n) => start += n,\n+                    Err(e) => return Some(Err(CharsError::Other(e))),\n+                }\n+            }\n+        }\n+        Some(match str::from_utf8(&buf[..width]).ok() {\n+            Some(s) => Ok(s.char_at(0)),\n+            None => Err(CharsError::NotUtf8),\n+        })\n+    }\n+}\n+\n+impl StdError for CharsError {\n+    fn description(&self) -> &str {\n+        match *self {\n+            CharsError::NotUtf8 => \"invalid utf8 encoding\",\n+            CharsError::Other(ref e) => e.description(),\n+        }\n+    }\n+    fn cause(&self) -> Option<&StdError> {\n+        match *self {\n+            CharsError::NotUtf8 => None,\n+            CharsError::Other(ref e) => e.cause(),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for CharsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            CharsError::NotUtf8 => {\n+                \"byte stream did not contain valid utf8\".fmt(f)\n+            }\n+            CharsError::Other(ref e) => e.fmt(f),\n+        }\n+    }\n+}\n+\n+/// An iterator over the contents of an instance of `BufRead` split on a\n+/// particular byte.\n+///\n+/// See `BufReadExt::split` for more information.\n+pub struct Split<B> {\n+    buf: B,\n+    delim: u8,\n+}\n+\n+impl<B: BufRead> Iterator for Split<B> {\n+    type Item = Result<Vec<u8>>;\n+\n+    fn next(&mut self) -> Option<Result<Vec<u8>>> {\n+        let mut buf = Vec::new();\n+        match self.buf.read_until(self.delim, &mut buf) {\n+            Ok(()) if buf.len() == 0 => None,\n+            Ok(()) => {\n+                if buf[buf.len() - 1] == self.delim {\n+                    buf.pop();\n+                }\n+                Some(Ok(buf))\n+            }\n+            Err(e) => Some(Err(e))\n+        }\n+    }\n+}\n+\n+/// An iterator over the lines of an instance of `BufRead` split on a newline\n+/// byte.\n+///\n+/// See `BufReadExt::lines` for more information.\n+pub struct Lines<B> {\n+    buf: B,\n+}\n+\n+impl<B: BufRead> Iterator for Lines<B> {\n+    type Item = Result<String>;\n+\n+    fn next(&mut self) -> Option<Result<String>> {\n+        let mut buf = String::new();\n+        match self.buf.read_line(&mut buf) {\n+            Ok(()) if buf.len() == 0 => None,\n+            Ok(()) => {\n+                if buf.ends_with(\"\\n\") {\n+                    buf.pop();\n+                }\n+                Some(Ok(buf))\n+            }\n+            Err(e) => Some(Err(e))\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io::prelude::*;\n+    use super::Cursor;\n+\n+    #[test]\n+    fn read_until() {\n+        let mut buf = Cursor::new(b\"12\");\n+        let mut v = Vec::new();\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(v, b\"12\");\n+\n+        let mut buf = Cursor::new(b\"1233\");\n+        let mut v = Vec::new();\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(v, b\"123\");\n+        v.truncate(0);\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(v, b\"3\");\n+        v.truncate(0);\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(v, []);\n+    }\n+\n+    #[test]\n+    fn split() {\n+        let mut buf = Cursor::new(b\"12\");\n+        let mut s = buf.split(b'3');\n+        assert_eq!(s.next(), Some(Ok(vec![b'1', b'2'])));\n+        assert_eq!(s.next(), None);\n+\n+        let mut buf = Cursor::new(b\"1233\");\n+        let mut s = buf.split(b'3');\n+        assert_eq!(s.next(), Some(Ok(vec![b'1', b'2'])));\n+        assert_eq!(s.next(), Some(Ok(vec![])));\n+        assert_eq!(s.next(), None);\n+    }\n+\n+    #[test]\n+    fn read_line() {\n+        let mut buf = Cursor::new(b\"12\");\n+        let mut v = String::new();\n+        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(v, \"12\");\n+\n+        let mut buf = Cursor::new(b\"12\\n\\n\");\n+        let mut v = String::new();\n+        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(v, \"12\\n\");\n+        v.truncate(0);\n+        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(v, \"\\n\");\n+        v.truncate(0);\n+        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(v, \"\");\n+    }\n+\n+    #[test]\n+    fn lines() {\n+        let mut buf = Cursor::new(b\"12\");\n+        let mut s = buf.lines();\n+        assert_eq!(s.next(), Some(Ok(\"12\".to_string())));\n+        assert_eq!(s.next(), None);\n+\n+        let mut buf = Cursor::new(b\"12\\n\\n\");\n+        let mut s = buf.lines();\n+        assert_eq!(s.next(), Some(Ok(\"12\".to_string())));\n+        assert_eq!(s.next(), Some(Ok(String::new())));\n+        assert_eq!(s.next(), None);\n+    }\n+\n+    #[test]\n+    fn read_to_end() {\n+        let mut c = Cursor::new(b\"\");\n+        let mut v = Vec::new();\n+        assert_eq!(c.read_to_end(&mut v), Ok(()));\n+        assert_eq!(v, []);\n+\n+        let mut c = Cursor::new(b\"1\");\n+        let mut v = Vec::new();\n+        assert_eq!(c.read_to_end(&mut v), Ok(()));\n+        assert_eq!(v, b\"1\");\n+    }\n+\n+    #[test]\n+    fn read_to_string() {\n+        let mut c = Cursor::new(b\"\");\n+        let mut v = String::new();\n+        assert_eq!(c.read_to_string(&mut v), Ok(()));\n+        assert_eq!(v, \"\");\n+\n+        let mut c = Cursor::new(b\"1\");\n+        let mut v = String::new();\n+        assert_eq!(c.read_to_string(&mut v), Ok(()));\n+        assert_eq!(v, \"1\");\n+\n+        let mut c = Cursor::new(b\"\\xff\");\n+        let mut v = String::new();\n+        assert!(c.read_to_string(&mut v).is_err());\n+    }\n+}"}, {"sha": "475ada2ff84b891102ba96ada6868fb84b51fc0f", "filename": "src/libstd/io/prelude.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprelude.rs?ref=5cf9905e257ddeeadaf493a705a230081a6c7da3", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The I/O Prelude\n+//!\n+//! The purpose of this module is to alleviate imports of many common I/O traits\n+//! by adding a glob import to the top of I/O heavy modules:\n+//!\n+//! ```\n+//! use std::io::prelude::*;\n+//! ```\n+//!\n+//! This module contains reexports of many core I/O traits such as `Read`,\n+//! `Write`, `ReadExt`, and `WriteExt`. Structures and functions are not\n+//! contained in this module.\n+\n+pub use super::{Read, ReadExt, Write, WriteExt, BufRead, BufReadExt};\n+\n+// FIXME: pub use as `Seek` when the name isn't in the actual prelude any more\n+pub use super::Seek as NewSeek;"}, {"sha": "3d342137c62ddd3d3a340811384d1dc2e166efd8", "filename": "src/libstd/io/util.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=5cf9905e257ddeeadaf493a705a230081a6c7da3", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_copy_implementations)]\n+\n+use prelude::v1::*;\n+\n+use io::{self, Read, Write, ErrorKind};\n+\n+/// Copies the entire contents of a reader into a writer.\n+///\n+/// This function will continuously read data from `r` and then write it into\n+/// `w` in a streaming fashion until `r` returns EOF.\n+///\n+/// On success the total number of bytes that were copied from `r` to `w` is\n+/// returned.\n+///\n+/// # Errors\n+///\n+/// This function will return an error immediately if any call to `read` or\n+/// `write` returns an error. All instances of `ErrorKind::Interrupted` are\n+/// handled by this function and the underlying operation is retried.\n+pub fn copy<R: Read, W: Write>(r: &mut R, w: &mut W) -> io::Result<u64> {\n+    let mut buf = [0; super::DEFAULT_BUF_SIZE];\n+    let mut written = 0;\n+    loop {\n+        let len = match r.read(&mut buf) {\n+            Ok(0) => return Ok(written),\n+            Ok(len) => len,\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+            Err(e) => return Err(e),\n+        };\n+        try!(w.write_all(&buf[..len]));\n+        written += len as u64;\n+    }\n+}\n+\n+/// A reader which is always at EOF.\n+pub struct Empty { _priv: () }\n+\n+/// Creates an instance of an empty reader.\n+///\n+/// All reads from the returned reader will return `Ok(0)`.\n+pub fn empty() -> Empty { Empty { _priv: () } }\n+\n+impl Read for Empty {\n+    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> { Ok(0) }\n+}\n+\n+/// A reader which infinitely yields one byte.\n+pub struct Repeat { byte: u8 }\n+\n+/// Creates an instance of a reader that infinitely repeats one byte.\n+///\n+/// All reads from this reader will succeed by filling the specified buffer with\n+/// the given byte.\n+pub fn repeat(byte: u8) -> Repeat { Repeat { byte: byte } }\n+\n+impl Read for Repeat {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        for slot in buf.iter_mut() {\n+            *slot = self.byte;\n+        }\n+        Ok(buf.len())\n+    }\n+}\n+\n+/// A writer which will move data into the void.\n+pub struct Sink { _priv: () }\n+\n+/// Creates an instance of a writer which will successfully consume all data.\n+///\n+/// All calls to `write` on the returned instance will return `Ok(buf.len())`\n+/// and the contents of the buffer will not be inspected.\n+pub fn sink() -> Sink { Sink { _priv: () } }\n+\n+impl Write for Sink {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::v1::*;\n+\n+    use io::prelude::*;\n+    use io::{sink, empty, repeat};\n+\n+    #[test]\n+    fn sink_sinks() {\n+        let mut s = sink();\n+        assert_eq!(s.write(&[]), Ok(0));\n+        assert_eq!(s.write(&[0]), Ok(1));\n+        assert_eq!(s.write(&[0; 1024]), Ok(1024));\n+        assert_eq!(s.by_ref().write(&[0; 1024]), Ok(1024));\n+    }\n+\n+    #[test]\n+    fn empty_reads() {\n+        let mut e = empty();\n+        assert_eq!(e.read(&mut []), Ok(0));\n+        assert_eq!(e.read(&mut [0]), Ok(0));\n+        assert_eq!(e.read(&mut [0; 1024]), Ok(0));\n+        assert_eq!(e.by_ref().read(&mut [0; 1024]), Ok(0));\n+    }\n+\n+    #[test]\n+    fn repeat_repeats() {\n+        let mut r = repeat(4);\n+        let mut b = [0; 1024];\n+        assert_eq!(r.read(&mut b), Ok(1024));\n+        assert!(b.iter().all(|b| *b == 4));\n+    }\n+\n+    #[test]\n+    fn take_some_bytes() {\n+        assert_eq!(repeat(4).take(100).bytes().count(), 100);\n+        assert_eq!(repeat(4).take(100).bytes().next(), Some(Ok(4)));\n+        assert_eq!(repeat(1).take(10).chain(repeat(2).take(10)).bytes().count(), 20);\n+    }\n+\n+    #[test]\n+    fn tee() {\n+        let mut buf = [0; 10];\n+        {\n+            let mut ptr: &mut [u8] = &mut buf;\n+            assert_eq!(repeat(4).tee(&mut ptr).take(5).read(&mut [0; 10]), Ok(5));\n+        }\n+        assert_eq!(buf, [4, 4, 4, 4, 4, 0, 0, 0, 0, 0]);\n+    }\n+\n+    #[test]\n+    fn broadcast() {\n+        let mut buf1 = [0; 10];\n+        let mut buf2 = [0; 10];\n+        {\n+            let mut ptr1: &mut [u8] = &mut buf1;\n+            let mut ptr2: &mut [u8] = &mut buf2;\n+\n+            assert_eq!((&mut ptr1).broadcast(&mut ptr2)\n+                                  .write(&[1, 2, 3]), Ok(3));\n+        }\n+        assert_eq!(buf1, buf2);\n+        assert_eq!(buf1, [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]);\n+    }\n+}"}, {"sha": "9efb6fa4247aa832e6586488e39a26dfdd1fce9e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5cf9905e257ddeeadaf493a705a230081a6c7da3", "patch": "@@ -128,9 +128,8 @@\n \n #![deny(missing_docs)]\n \n-#[cfg(test)]\n-#[macro_use]\n-extern crate log;\n+#[cfg(test)] extern crate test;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n #[macro_use]\n #[macro_reexport(assert, assert_eq, debug_assert, debug_assert_eq,\n@@ -248,6 +247,7 @@ pub mod dynamic_lib;\n pub mod ffi;\n pub mod fmt;\n pub mod old_io;\n+pub mod io;\n pub mod os;\n pub mod env;\n pub mod path;"}, {"sha": "427cf21ac70a9cc86021597c2b5570a755fa0875", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=5cf9905e257ddeeadaf493a705a230081a6c7da3", "patch": "@@ -18,10 +18,11 @@\n use prelude::v1::*;\n \n use ffi;\n-use old_io::{self, IoResult, IoError};\n+use io::ErrorKind;\n use libc;\n use num::{Int, SignedInt};\n use num;\n+use old_io::{self, IoResult, IoError};\n use str;\n use sys_common::mkerr_libc;\n \n@@ -133,6 +134,35 @@ pub fn decode_error_detailed(errno: i32) -> IoError {\n     err\n }\n \n+pub fn decode_error_kind(errno: i32) -> ErrorKind {\n+    match errno as libc::c_int {\n+        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n+        libc::ECONNRESET => ErrorKind::ConnectionReset,\n+        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n+        libc::EPIPE => ErrorKind::BrokenPipe,\n+        libc::ENOTCONN => ErrorKind::NotConnected,\n+        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n+        libc::EADDRNOTAVAIL => ErrorKind::ConnectionRefused,\n+        libc::EADDRINUSE => ErrorKind::ConnectionRefused,\n+        libc::ENOENT => ErrorKind::FileNotFound,\n+        libc::EISDIR => ErrorKind::InvalidInput,\n+        libc::EINTR => ErrorKind::Interrupted,\n+        libc::EINVAL => ErrorKind::InvalidInput,\n+        libc::ENOTTY => ErrorKind::MismatchedFileTypeForOperation,\n+        libc::ETIMEDOUT => ErrorKind::TimedOut,\n+        libc::ECANCELED => ErrorKind::TimedOut,\n+        libc::consts::os::posix88::EEXIST => ErrorKind::PathAlreadyExists,\n+\n+        // These two constants can have the same value on some systems,\n+        // but different values on others, so we can't use a match\n+        // clause\n+        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+            ErrorKind::ResourceUnavailable,\n+\n+        _ => ErrorKind::Other,\n+    }\n+}\n+\n #[inline]\n pub fn retry<T, F> (mut f: F) -> T where\n     T: SignedInt,"}, {"sha": "f1af70e2cf7d1eb341bc87ff5bee89d0133bbca1", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf9905e257ddeeadaf493a705a230081a6c7da3/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=5cf9905e257ddeeadaf493a705a230081a6c7da3", "patch": "@@ -15,6 +15,7 @@\n use prelude::v1::*;\n \n use ffi::OsStr;\n+use io::ErrorKind;\n use libc;\n use mem;\n use old_io::{self, IoResult, IoError};\n@@ -143,6 +144,34 @@ pub fn decode_error_detailed(errno: i32) -> IoError {\n     err\n }\n \n+pub fn decode_error_kind(errno: i32) -> ErrorKind {\n+    match errno as libc::c_int {\n+        libc::ERROR_ACCESS_DENIED => ErrorKind::PermissionDenied,\n+        libc::ERROR_ALREADY_EXISTS => ErrorKind::PathAlreadyExists,\n+        libc::ERROR_BROKEN_PIPE => ErrorKind::BrokenPipe,\n+        libc::ERROR_FILE_NOT_FOUND => ErrorKind::FileNotFound,\n+        libc::ERROR_INVALID_FUNCTION => ErrorKind::InvalidInput,\n+        libc::ERROR_INVALID_HANDLE => ErrorKind::MismatchedFileTypeForOperation,\n+        libc::ERROR_INVALID_NAME => ErrorKind::InvalidInput,\n+        libc::ERROR_NOTHING_TO_TERMINATE => ErrorKind::InvalidInput,\n+        libc::ERROR_NO_DATA => ErrorKind::BrokenPipe,\n+        libc::ERROR_OPERATION_ABORTED => ErrorKind::TimedOut,\n+\n+        libc::WSAEACCES => ErrorKind::PermissionDenied,\n+        libc::WSAEADDRINUSE => ErrorKind::ConnectionRefused,\n+        libc::WSAEADDRNOTAVAIL => ErrorKind::ConnectionRefused,\n+        libc::WSAECONNABORTED => ErrorKind::ConnectionAborted,\n+        libc::WSAECONNREFUSED => ErrorKind::ConnectionRefused,\n+        libc::WSAECONNRESET => ErrorKind::ConnectionReset,\n+        libc::WSAEINVAL => ErrorKind::InvalidInput,\n+        libc::WSAENOTCONN => ErrorKind::NotConnected,\n+        libc::WSAEWOULDBLOCK => ErrorKind::ResourceUnavailable,\n+\n+        _ => ErrorKind::Other,\n+    }\n+}\n+\n+\n #[inline]\n pub fn retry<I, F>(f: F) -> I where F: FnOnce() -> I { f() } // PR rust-lang/rust/#17020\n "}]}