{"sha": "4af427881405f95b8d87efea844cbd695fb55986", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZjQyNzg4MTQwNWY5NWI4ZDg3ZWZlYTg0NGNiZDY5NWZiNTU5ODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-16T22:53:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-16T22:53:19Z"}, "message": "Auto merge of #30341 - pnkfelix:call-site-scope, r=nikomatsakis\n\nEnsure borrows of fn/closure params do not outlive invocations.\n\nDoes this by adding a new CallSiteScope to the region (or rather code extent) hierarchy, which outlives even the ParameterScope (which in turn outlives the DestructionScope of a fn/closure's body).\n\nFix #29793\n\nr? @nikomatsakis", "tree": {"sha": "919c4c9a0d414809dfb1227197df7249db06594a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/919c4c9a0d414809dfb1227197df7249db06594a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4af427881405f95b8d87efea844cbd695fb55986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4af427881405f95b8d87efea844cbd695fb55986", "html_url": "https://github.com/rust-lang/rust/commit/4af427881405f95b8d87efea844cbd695fb55986", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4af427881405f95b8d87efea844cbd695fb55986/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38da1a406472cf3c675c70fe2c0b1c665fce4b16", "url": "https://api.github.com/repos/rust-lang/rust/commits/38da1a406472cf3c675c70fe2c0b1c665fce4b16", "html_url": "https://github.com/rust-lang/rust/commit/38da1a406472cf3c675c70fe2c0b1c665fce4b16"}, {"sha": "5299441954b4678f23f3c0c0b2080b3430a2d028", "url": "https://api.github.com/repos/rust-lang/rust/commits/5299441954b4678f23f3c0c0b2080b3430a2d028", "html_url": "https://github.com/rust-lang/rust/commit/5299441954b4678f23f3c0c0b2080b3430a2d028"}], "stats": {"total": 573, "additions": 477, "deletions": 96}, "files": [{"sha": "e894878e43ce1fecd7445e523e3475bc76a0ed99", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -148,6 +148,9 @@ impl<'tcx> ty::ctxt<'tcx> {\n                 };\n                 let scope_decorated_tag = match self.region_maps.code_extent_data(scope) {\n                     region::CodeExtentData::Misc(_) => tag,\n+                    region::CodeExtentData::CallSiteScope { .. } => {\n+                        \"scope of call-site for function\"\n+                    }\n                     region::CodeExtentData::ParameterScope { .. } => {\n                         \"scope of parameters for function\"\n                     }"}, {"sha": "4a75309f1a65c4757fd4b76ba953b7719930b2a7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -1475,10 +1475,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  entry_ln: LiveNode,\n                  body: &hir::Block)\n     {\n-        // within the fn body, late-bound regions are liberated:\n+        // within the fn body, late-bound regions are liberated\n+        // and must outlive the *call-site* of the function.\n         let fn_ret =\n             self.ir.tcx.liberate_late_bound_regions(\n-                self.ir.tcx.region_maps.item_extent(body.id),\n+                self.ir.tcx.region_maps.call_site_extent(id, body.id),\n                 &self.fn_ret(id));\n \n         match fn_ret {"}, {"sha": "543b218a2bc05f128699755cd9c388d3b7a25d46", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -125,6 +125,10 @@ pub const DUMMY_CODE_EXTENT : CodeExtent = CodeExtent(1);\n pub enum CodeExtentData {\n     Misc(ast::NodeId),\n \n+    // extent of the call-site for a function or closure (outlives\n+    // the parameters as well as the body).\n+    CallSiteScope { fn_id: ast::NodeId, body_id: ast::NodeId },\n+\n     // extent of parameters passed to a function or closure (they\n     // outlive its body)\n     ParameterScope { fn_id: ast::NodeId, body_id: ast::NodeId },\n@@ -136,20 +140,20 @@ pub enum CodeExtentData {\n     Remainder(BlockRemainder)\n }\n \n-/// extent of destructors for temporaries of node-id\n+/// extent of call-site for a function/method.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n            RustcDecodable, Debug, Copy)]\n-pub struct DestructionScopeData {\n-    pub node_id: ast::NodeId\n+pub struct CallSiteScopeData {\n+    pub fn_id: ast::NodeId, pub body_id: ast::NodeId,\n }\n \n-impl DestructionScopeData {\n-    pub fn new(node_id: ast::NodeId) -> DestructionScopeData {\n-        DestructionScopeData { node_id: node_id }\n-    }\n+impl CallSiteScopeData {\n     pub fn to_code_extent(&self, region_maps: &RegionMaps) -> CodeExtent {\n         region_maps.lookup_code_extent(\n-            CodeExtentData::DestructionScope(self.node_id))\n+            match *self {\n+                CallSiteScopeData { fn_id, body_id } =>\n+                    CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id },\n+            })\n     }\n }\n \n@@ -190,6 +194,7 @@ impl CodeExtentData {\n             // precise extent denoted by `self`.\n             CodeExtentData::Remainder(br) => br.block,\n             CodeExtentData::DestructionScope(node_id) => node_id,\n+            CodeExtentData::CallSiteScope { fn_id: _, body_id } |\n             CodeExtentData::ParameterScope { fn_id: _, body_id } => body_id,\n         }\n     }\n@@ -215,6 +220,7 @@ impl CodeExtent {\n         match ast_map.find(self.node_id(region_maps)) {\n             Some(ast_map::NodeBlock(ref blk)) => {\n                 match region_maps.code_extent_data(*self) {\n+                    CodeExtentData::CallSiteScope { .. } |\n                     CodeExtentData::ParameterScope { .. } |\n                     CodeExtentData::Misc(_) |\n                     CodeExtentData::DestructionScope(_) => Some(blk.span),\n@@ -346,6 +352,10 @@ impl RegionMaps {\n     pub fn item_extent(&self, n: ast::NodeId) -> CodeExtent {\n         self.lookup_code_extent(CodeExtentData::DestructionScope(n))\n     }\n+    pub fn call_site_extent(&self, fn_id: ast::NodeId, body_id: ast::NodeId) -> CodeExtent {\n+        assert!(fn_id != body_id);\n+        self.lookup_code_extent(CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id })\n+    }\n     pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent> {\n         self.code_extent_interner.borrow().get(&CodeExtentData::DestructionScope(n)).cloned()\n     }\n@@ -1101,6 +1111,9 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n            body.id,\n            visitor.cx.parent);\n \n+    visitor.cx.parent = visitor.new_code_extent(\n+        CodeExtentData::CallSiteScope { fn_id: id, body_id: body.id });\n+\n     let fn_decl_scope = visitor.new_code_extent(\n         CodeExtentData::ParameterScope { fn_id: id, body_id: body.id });\n "}, {"sha": "89fa76f2fa769d5b9f181fc44b1bd0ba0324abe9", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -42,7 +42,7 @@ pub enum DefRegion {\n                         /* lifetime decl */ ast::NodeId),\n     DefLateBoundRegion(ty::DebruijnIndex,\n                        /* lifetime decl */ ast::NodeId),\n-    DefFreeRegion(/* block scope */ region::DestructionScopeData,\n+    DefFreeRegion(region::CallSiteScopeData,\n                   /* lifetime decl */ ast::NodeId),\n }\n \n@@ -83,9 +83,9 @@ enum ScopeChain<'a> {\n     /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n     LateScope(&'a Vec<hir::LifetimeDef>, Scope<'a>),\n-    /// lifetimes introduced by items within a code block are scoped\n-    /// to that block.\n-    BlockScope(region::DestructionScopeData, Scope<'a>),\n+\n+    /// lifetimes introduced by a fn are scoped to the call-site for that fn.\n+    FnScope { fn_id: ast::NodeId, body_id: ast::NodeId, s: Scope<'a> },\n     RootScope\n }\n \n@@ -173,20 +173,20 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, _: ast::NodeId) {\n+                b: &'v hir::Block, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, _, _, _, _) => {\n                 self.visit_early_late(subst::FnSpace, generics, |this| {\n-                    this.walk_fn(fk, fd, b, s)\n+                    this.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n                 })\n             }\n             FnKind::Method(_, sig, _) => {\n                 self.visit_early_late(subst::FnSpace, &sig.generics, |this| {\n-                    this.walk_fn(fk, fd, b, s)\n+                    this.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n                 })\n             }\n             FnKind::Closure => {\n-                self.walk_fn(fk, fd, b, s)\n+                self.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n             }\n         }\n     }\n@@ -237,12 +237,6 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_block(&mut self, b: &hir::Block) {\n-        self.with(BlockScope(region::DestructionScopeData::new(b.id),\n-                             self.scope),\n-                  |_, this| intravisit::walk_block(this, b));\n-    }\n-\n     fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n         if lifetime_ref.name == special_idents::static_lifetime.name {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n@@ -438,7 +432,7 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n                                            label_span: Span) {\n         loop {\n             match *scope {\n-                BlockScope(_, s) => { scope = s; }\n+                FnScope { s, .. } => { scope = s; }\n                 RootScope => { return; }\n \n                 EarlyScope(_, lifetimes, s) |\n@@ -462,14 +456,13 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n }\n \n impl<'a> LifetimeContext<'a> {\n-    // This is just like intravisit::walk_fn, except that it extracts the\n-    // labels of the function body and swaps them in before visiting\n-    // the function body itself.\n-    fn walk_fn<'b>(&mut self,\n-                   fk: FnKind,\n-                   fd: &hir::FnDecl,\n-                   fb: &'b hir::Block,\n-                   _span: Span) {\n+    fn add_scope_and_walk_fn<'b>(&mut self,\n+                                 fk: FnKind,\n+                                 fd: &hir::FnDecl,\n+                                 fb: &'b hir::Block,\n+                                 _span: Span,\n+                                 fn_id: ast::NodeId) {\n+\n         match fk {\n             FnKind::ItemFn(_, generics, _, _, _, _) => {\n                 intravisit::walk_fn_decl(self, fd);\n@@ -489,7 +482,8 @@ impl<'a> LifetimeContext<'a> {\n         // `self.labels_in_fn`.\n         extract_labels(self, fb);\n \n-        self.visit_block(fb);\n+        self.with(FnScope { fn_id: fn_id, body_id: fb.id, s: self.scope },\n+                  |_old_scope, this| this.visit_block(fb))\n     }\n \n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n@@ -560,8 +554,11 @@ impl<'a> LifetimeContext<'a> {\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n-                BlockScope(blk_scope, s) => {\n-                    return self.resolve_free_lifetime_ref(blk_scope, lifetime_ref, s);\n+                FnScope {fn_id, body_id, s } => {\n+                    return self.resolve_free_lifetime_ref(\n+                        region::CallSiteScopeData { fn_id: fn_id, body_id: body_id },\n+                        lifetime_ref,\n+                        s);\n                 }\n \n                 RootScope => {\n@@ -605,7 +602,7 @@ impl<'a> LifetimeContext<'a> {\n     }\n \n     fn resolve_free_lifetime_ref(&mut self,\n-                                 scope_data: region::DestructionScopeData,\n+                                 scope_data: region::CallSiteScopeData,\n                                  lifetime_ref: &hir::Lifetime,\n                                  scope: Scope) {\n         debug!(\"resolve_free_lifetime_ref \\\n@@ -623,8 +620,10 @@ impl<'a> LifetimeContext<'a> {\n                     scope_data: {:?} scope: {:?} search_result: {:?}\",\n                    scope_data, scope, search_result);\n             match *scope {\n-                BlockScope(blk_scope_data, s) => {\n-                    scope_data = blk_scope_data;\n+                FnScope { fn_id, body_id, s } => {\n+                    scope_data = region::CallSiteScopeData {\n+                        fn_id: fn_id, body_id: body_id\n+                    };\n                     scope = s;\n                 }\n \n@@ -712,7 +711,7 @@ impl<'a> LifetimeContext<'a> {\n \n         loop {\n             match *old_scope {\n-                BlockScope(_, s) => {\n+                FnScope { s, .. } => {\n                     old_scope = s;\n                 }\n \n@@ -865,7 +864,7 @@ impl<'a> fmt::Debug for ScopeChain<'a> {\n         match *self {\n             EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({:?}, {:?})\", space, defs),\n             LateScope(defs, _) => write!(fmt, \"LateScope({:?})\", defs),\n-            BlockScope(id, _) => write!(fmt, \"BlockScope({:?})\", id),\n+            FnScope { fn_id, body_id, s: _ } => write!(fmt, \"FnScope({:?}, {:?})\", fn_id, body_id),\n             RootScope => write!(fmt, \"RootScope\"),\n         }\n     }"}, {"sha": "bd60d0a212252f549ba9c54d5437bf1a74a30ee3", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -192,7 +192,8 @@ fn generics_require_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n     };\n \n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-    let free_substs = tcx.construct_free_substs(generics, ast::DUMMY_NODE_ID);\n+    let free_substs = tcx.construct_free_substs(generics,\n+                                                tcx.region_maps.node_extent(ast::DUMMY_NODE_ID));\n     let predicates = predicates.instantiate(tcx, &free_substs).predicates.into_vec();\n     elaborate_predicates(tcx, predicates)\n         .any(|predicate| {"}, {"sha": "54fe1a9bc8ef0ad56f52475608736c88cb6134ed", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -26,6 +26,7 @@ use middle::cstore::{self, CrateStore, LOCAL_CRATE};\n use middle::def::{self, ExportMap};\n use middle::def_id::DefId;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n+use middle::region::{CodeExtent};\n use middle::subst::{self, ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n use middle::ty;\n@@ -1117,7 +1118,7 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     /// FIXME(#3696). It would be nice to refactor so that free\n     /// regions don't have this implicit scope and instead introduce\n     /// relationships in the environment.\n-    pub free_id: ast::NodeId,\n+    pub free_id_outlive: CodeExtent,\n }\n \n impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n@@ -1132,7 +1133,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             caller_bounds: caller_bounds,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            free_id: self.free_id,\n+            free_id_outlive: self.free_id_outlive,\n         }\n     }\n \n@@ -1150,7 +1151,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         cx.construct_parameter_environment(impl_item.span,\n                                                            &scheme.generics,\n                                                            &predicates,\n-                                                           id)\n+                                                           cx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Const(_, _) => {\n                         let def_id = cx.map.local_def_id(id);\n@@ -1159,7 +1160,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         cx.construct_parameter_environment(impl_item.span,\n                                                            &scheme.generics,\n                                                            &predicates,\n-                                                           id)\n+                                                           cx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n                         let method_def_id = cx.map.local_def_id(id);\n@@ -1171,7 +1172,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     impl_item.span,\n                                     method_generics,\n                                     method_bounds,\n-                                    body.id)\n+                                    cx.region_maps.call_site_extent(id, body.id))\n                             }\n                             _ => {\n                                 cx.sess\n@@ -1194,7 +1195,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         cx.construct_parameter_environment(trait_item.span,\n                                                            &trait_def.generics,\n                                                            &predicates,\n-                                                           id)\n+                                                           cx.region_maps.item_extent(id))\n                     }\n                     hir::ConstTraitItem(..) => {\n                         let def_id = cx.map.local_def_id(id);\n@@ -1203,23 +1204,29 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         cx.construct_parameter_environment(trait_item.span,\n                                                            &scheme.generics,\n                                                            &predicates,\n-                                                           id)\n+                                                           cx.region_maps.item_extent(id))\n                     }\n                     hir::MethodTraitItem(_, ref body) => {\n-                        // for the body-id, use the id of the body\n-                        // block, unless this is a trait method with\n-                        // no default, then fallback to the method id.\n-                        let body_id = body.as_ref().map(|b| b.id).unwrap_or(id);\n+                        // Use call-site for extent (unless this is a\n+                        // trait method with no default; then fallback\n+                        // to the method id).\n                         let method_def_id = cx.map.local_def_id(id);\n                         match cx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n                                 let method_bounds = &method_ty.predicates;\n+                                let extent = if let Some(ref body) = *body {\n+                                    // default impl: use call_site extent as free_id_outlive bound.\n+                                    cx.region_maps.call_site_extent(id, body.id)\n+                                } else {\n+                                    // no default impl: use item extent as free_id_outlive bound.\n+                                    cx.region_maps.item_extent(id)\n+                                };\n                                 cx.construct_parameter_environment(\n                                     trait_item.span,\n                                     method_generics,\n                                     method_bounds,\n-                                    body_id)\n+                                    extent)\n                             }\n                             _ => {\n                                 cx.sess\n@@ -1242,7 +1249,8 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         cx.construct_parameter_environment(item.span,\n                                                            &fn_scheme.generics,\n                                                            &fn_predicates,\n-                                                           body.id)\n+                                                           cx.region_maps.call_site_extent(id,\n+                                                                                           body.id))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n@@ -1255,7 +1263,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         cx.construct_parameter_environment(item.span,\n                                                            &scheme.generics,\n                                                            &predicates,\n-                                                           id)\n+                                                           cx.region_maps.item_extent(id))\n                     }\n                     hir::ItemTrait(..) => {\n                         let def_id = cx.map.local_def_id(id);\n@@ -1264,7 +1272,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         cx.construct_parameter_environment(item.span,\n                                                            &trait_def.generics,\n                                                            &predicates,\n-                                                           id)\n+                                                           cx.region_maps.item_extent(id))\n                     }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n@@ -2611,18 +2619,17 @@ impl<'tcx> ctxt<'tcx> {\n     /// are no free type/lifetime parameters in scope.\n     pub fn empty_parameter_environment<'a>(&'a self)\n                                            -> ParameterEnvironment<'a,'tcx> {\n+\n+        // for an empty parameter environment, there ARE no free\n+        // regions, so it shouldn't matter what we use for the free id\n+        let free_id_outlive = self.region_maps.node_extent(ast::DUMMY_NODE_ID);\n         ty::ParameterEnvironment { tcx: self,\n                                    free_substs: Substs::empty(),\n                                    caller_bounds: Vec::new(),\n                                    implicit_region_bound: ty::ReEmpty,\n                                    selection_cache: traits::SelectionCache::new(),\n                                    evaluation_cache: traits::EvaluationCache::new(),\n-\n-                                   // for an empty parameter\n-                                   // environment, there ARE no free\n-                                   // regions, so it shouldn't matter\n-                                   // what we use for the free id\n-                                   free_id: ast::DUMMY_NODE_ID }\n+                                   free_id_outlive: free_id_outlive }\n     }\n \n     /// Constructs and returns a substitution that can be applied to move from\n@@ -2631,7 +2638,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n     pub fn construct_free_substs(&self, generics: &Generics<'tcx>,\n-                                 free_id: NodeId) -> Substs<'tcx> {\n+                                 free_id_outlive: CodeExtent) -> Substs<'tcx> {\n         // map T => T\n         let mut types = VecPerParamSpace::empty();\n         for def in generics.types.as_slice() {\n@@ -2640,8 +2647,6 @@ impl<'tcx> ctxt<'tcx> {\n             types.push(def.space, self.mk_param_from_def(def));\n         }\n \n-        let free_id_outlive = self.region_maps.item_extent(free_id);\n-\n         // map bound 'a => free 'a\n         let mut regions = VecPerParamSpace::empty();\n         for def in generics.regions.as_slice() {\n@@ -2658,20 +2663,21 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    /// See `ParameterEnvironment` struct def'n for details\n+    /// See `ParameterEnvironment` struct def'n for details.\n+    /// If you were using `free_id: NodeId`, you might try `self.region_maps.item_extent(free_id)`\n+    /// for the `free_id_outlive` parameter. (But note that that is not always quite right.)\n     pub fn construct_parameter_environment<'a>(&'a self,\n                                                span: Span,\n                                                generics: &ty::Generics<'tcx>,\n                                                generic_predicates: &ty::GenericPredicates<'tcx>,\n-                                               free_id: NodeId)\n+                                               free_id_outlive: CodeExtent)\n                                                -> ParameterEnvironment<'a, 'tcx>\n     {\n         //\n         // Construct the free substs.\n         //\n \n-        let free_substs = self.construct_free_substs(generics, free_id);\n-        let free_id_outlive = self.region_maps.item_extent(free_id);\n+        let free_substs = self.construct_free_substs(generics, free_id_outlive);\n \n         //\n         // Compute the bounds on Self and the type parameters.\n@@ -2681,12 +2687,6 @@ impl<'tcx> ctxt<'tcx> {\n         let bounds = self.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n         let predicates = bounds.predicates.into_vec();\n \n-        debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} predicates={:?}\",\n-               free_id,\n-               free_substs,\n-               predicates);\n-\n-        //\n         // Finally, we have to normalize the bounds in the environment, in\n         // case they contain any associated type projections. This process\n         // can yield errors if the put in illegal associated types, like\n@@ -2707,10 +2707,10 @@ impl<'tcx> ctxt<'tcx> {\n             caller_bounds: predicates,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            free_id: free_id,\n+            free_id_outlive: free_id_outlive,\n         };\n \n-        let cause = traits::ObligationCause::misc(span, free_id);\n+        let cause = traits::ObligationCause::misc(span, free_id_outlive.node_id(&self.region_maps));\n         traits::normalize_param_env_or_error(unnormalized_env, cause)\n     }\n "}, {"sha": "e6007809af5e90e9a218cfd60f385c5619c9b82a", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -823,7 +823,7 @@ impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where '\n             caller_bounds: self.caller_bounds.fold_with(folder),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            free_id: self.free_id,\n+            free_id_outlive: self.free_id_outlive,\n         }\n     }\n }"}, {"sha": "4d4db062329e07c60cc2c7ba23b6e9cb9449ecf6", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -237,6 +237,17 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             // doesn't care about regions.\n             //\n             // May still be worth fixing though.\n+            'C' => {\n+                assert_eq!(self.next(), '[');\n+                let fn_id = self.parse_uint() as ast::NodeId;\n+                assert_eq!(self.next(), '|');\n+                let body_id = self.parse_uint() as ast::NodeId;\n+                assert_eq!(self.next(), ']');\n+                region::CodeExtentData::CallSiteScope {\n+                    fn_id: fn_id, body_id: body_id\n+                }\n+            }\n+            // This creates scopes with the wrong NodeId. (See note above.)\n             'P' => {\n                 assert_eq!(self.next(), '[');\n                 let fn_id = self.parse_uint() as ast::NodeId;"}, {"sha": "c1910e3f249db3a74d5674d14257bb3aedf19da3", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -286,6 +286,8 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n \n fn enc_scope(w: &mut Encoder, cx: &ctxt, scope: region::CodeExtent) {\n     match cx.tcx.region_maps.code_extent_data(scope) {\n+        region::CodeExtentData::CallSiteScope {\n+            fn_id, body_id } => mywrite!(w, \"C[{}|{}]\", fn_id, body_id),\n         region::CodeExtentData::ParameterScope {\n             fn_id, body_id } => mywrite!(w, \"P[{}|{}]\", fn_id, body_id),\n         region::CodeExtentData::Misc(node_id) => mywrite!(w, \"M{}\", node_id),"}, {"sha": "feea38acdc7ef08d3eea278c103840fcb58bdc4c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -181,7 +181,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &hir::Lifetime)\n \n         Some(&rl::DefFreeRegion(scope, id)) => {\n             ty::ReFree(ty::FreeRegion {\n-                    scope: tcx.region_maps.item_extent(scope.node_id),\n+                    scope: scope.to_code_extent(&tcx.region_maps),\n                     bound_region: ty::BrNamed(tcx.map.local_def_id(id),\n                                               lifetime.name)\n                 })"}, {"sha": "7792169d3eb46788f9d1b3f1af5da4622d663387", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -75,7 +75,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     fcx.write_ty(expr.id, closure_type);\n \n     let fn_sig = fcx.tcx().liberate_late_bound_regions(\n-        fcx.tcx().region_maps.item_extent(body.id), &fn_ty.sig);\n+        fcx.tcx().region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n \n     check_fn(fcx.ccx,\n              hir::Unsafety::Normal,"}, {"sha": "b4434a56fffe0b930d7389d3b461b3fa8f4d826c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -455,7 +455,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let inh = Inherited::new(ccx.tcx, &tables, param_env);\n \n             // Compute the fty from point of view of inside fn.\n-            let fn_scope = ccx.tcx.region_maps.item_extent(body.id);\n+            let fn_scope = ccx.tcx.region_maps.call_site_extent(fn_id, body.id);\n             let fn_sig =\n                 fn_ty.sig.subst(ccx.tcx, &inh.infcx.parameter_environment.free_substs);\n             let fn_sig ="}, {"sha": "3ecb9468ef47a7a3d766df2db2de6d331871e9f5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -89,7 +89,7 @@ use middle::free_region::FreeRegionMap;\n use middle::implicator::{self, Implication};\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n-use middle::region::CodeExtent;\n+use middle::region::{self, CodeExtent};\n use middle::subst::Substs;\n use middle::traits;\n use middle::ty::{self, RegionEscape, ReScope, Ty, MethodCall, HasTypeFlags};\n@@ -180,6 +180,9 @@ pub struct Rcx<'a, 'tcx: 'a> {\n     // id of innermost fn body id\n     body_id: ast::NodeId,\n \n+    // call_site scope of innermost fn\n+    call_site_scope: Option<CodeExtent>,\n+\n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n \n@@ -200,6 +203,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n               body_id: initial_body_id,\n+              call_site_scope: None,\n               subject: subject,\n               region_bound_pairs: Vec::new(),\n               free_region_map: FreeRegionMap::new(),\n@@ -214,6 +218,10 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         self.fcx.infcx()\n     }\n \n+    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent>) -> Option<CodeExtent> {\n+        mem::replace(&mut self.call_site_scope, call_site_scope)\n+    }\n+\n     fn set_body_id(&mut self, body_id: ast::NodeId) -> ast::NodeId {\n         mem::replace(&mut self.body_id, body_id)\n     }\n@@ -275,14 +283,18 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n \n     fn visit_fn_body(&mut self,\n-                     id: ast::NodeId,\n+                     id: ast::NodeId, // the id of the fn itself\n                      fn_decl: &hir::FnDecl,\n                      body: &hir::Block,\n                      span: Span)\n     {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n+        let call_site = self.fcx.tcx().region_maps.lookup_code_extent(\n+            region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body.id });\n+        let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n+\n         let fn_sig = {\n             let fn_sig_map = &self.infcx().tables.borrow().liberated_fn_sigs;\n             match fn_sig_map.get(&id) {\n@@ -300,7 +312,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         // For the return type, if diverging, substitute `bool` just\n         // because it will have no effect.\n         //\n-        // FIXME(#25759) return types should not be implied bounds\n+        // FIXME(#27579) return types should not be implied bounds\n         let fn_sig_tys: Vec<_> =\n             fn_sig.inputs.iter()\n                          .cloned()\n@@ -315,9 +327,18 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n \n+        let call_site_scope = self.call_site_scope.unwrap();\n+        debug!(\"visit_fn_body body.id {} call_site_scope: {:?}\",\n+               body.id, call_site_scope);\n+        type_of_node_must_outlive(self,\n+                                  infer::CallReturn(span),\n+                                  body.id,\n+                                  ty::ReScope(call_site_scope));\n+\n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n \n         self.set_body_id(old_body_id);\n+        self.set_call_site_scope(old_call_site_scope);\n     }\n \n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n@@ -834,6 +855,17 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n+        hir::ExprRet(Some(ref ret_expr)) => {\n+            let call_site_scope = rcx.call_site_scope;\n+            debug!(\"visit_expr ExprRet ret_expr.id {} call_site_scope: {:?}\",\n+                   ret_expr.id, call_site_scope);\n+            type_of_node_must_outlive(rcx,\n+                                      infer::CallReturn(ret_expr.span),\n+                                      ret_expr.id,\n+                                      ty::ReScope(call_site_scope.unwrap()));\n+            intravisit::walk_expr(rcx, expr);\n+        }\n+\n         _ => {\n             intravisit::walk_expr(rcx, expr);\n         }"}, {"sha": "ee2845c824e3b59493a19a8946ef6ba98a90e38c", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -137,10 +137,11 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let type_scheme = ccx.tcx.lookup_item_type(item_def_id);\n         let type_predicates = ccx.tcx.lookup_predicates(item_def_id);\n         reject_non_type_param_bounds(ccx.tcx, item.span, &type_predicates);\n+        let free_id_outlive = ccx.tcx.region_maps.item_extent(item.id);\n         let param_env = ccx.tcx.construct_parameter_environment(item.span,\n                                                                 &type_scheme.generics,\n                                                                 &type_predicates,\n-                                                                item.id);\n+                                                                free_id_outlive);\n         let tables = RefCell::new(ty::Tables::empty());\n         let inh = Inherited::new(ccx.tcx, &tables, param_env);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);"}, {"sha": "ffe55c9b29b99140babe46c4b48acb2897805cfb", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -13,6 +13,7 @@ use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use middle::def_id::DefId;\n+use middle::region::{CodeExtent};\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n use middle::ty::{self, Ty};\n@@ -133,7 +134,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let code = self.code.clone();\n         self.with_fcx(item_id, span, |fcx, this| {\n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let free_id = fcx.inh.infcx.parameter_environment.free_id;\n+            let free_id_outlive = fcx.inh.infcx.parameter_environment.free_id_outlive;\n \n             let item = fcx.tcx().impl_or_trait_item(fcx.tcx().map.local_def_id(item_id));\n \n@@ -152,7 +153,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n                     let predicates = fcx.instantiate_bounds(span, free_substs, &method.predicates);\n                     this.check_fn_or_method(fcx, span, &method_ty, &predicates,\n-                                            free_id, &mut implied_bounds);\n+                                            free_id_outlive, &mut implied_bounds);\n                 }\n                 ty::TypeTraitItem(assoc_type) => {\n                     if let Some(ref ty) = assoc_type.ty {\n@@ -262,8 +263,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n \n             let mut implied_bounds = vec![];\n+            let free_id_outlive = fcx.tcx().region_maps.call_site_extent(item.id, body.id);\n             this.check_fn_or_method(fcx, item.span, bare_fn_ty, &predicates,\n-                                    body.id, &mut implied_bounds);\n+                                    free_id_outlive, &mut implied_bounds);\n             implied_bounds\n         })\n     }\n@@ -354,12 +356,11 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                 span: Span,\n                                 fty: &ty::BareFnTy<'tcx>,\n                                 predicates: &ty::InstantiatedPredicates<'tcx>,\n-                                free_id: ast::NodeId,\n+                                free_id_outlive: CodeExtent,\n                                 implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n         let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n         let fty = fcx.instantiate_type_scheme(span, free_substs, fty);\n-        let free_id_outlive = fcx.tcx().region_maps.item_extent(free_id);\n         let sig = fcx.tcx().liberate_late_bound_regions(free_id_outlive, &fty.sig);\n \n         for &input_ty in &sig.inputs {"}, {"sha": "bfe4151da5c91c3c99cff4b6b722ed057b9a47a9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -889,11 +889,13 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             for impl_item in impl_items {\n                 if let hir::ImplItemKind::Method(ref sig, ref body) = impl_item.node {\n                     let body_id = body.id;\n+                    let body_scope = ccx.tcx.region_maps.call_site_extent(impl_item.id, body_id);\n                     check_method_self_type(ccx,\n                                            &BindingRscope::new(),\n                                            ccx.method_ty(impl_item.id),\n                                            selfty,\n                                            &sig.explicit_self,\n+                                           body_scope,\n                                            body_id);\n                 }\n             }\n@@ -988,16 +990,25 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // This must be done after `collect_trait_methods` so that\n             // we have a method type stored for every method.\n             for trait_item in trait_items {\n-                let sig = match trait_item.node {\n-                    hir::MethodTraitItem(ref sig, _) => sig,\n+                let (sig, the_scope, the_id) = match trait_item.node {\n+                    hir::MethodTraitItem(ref sig, Some(ref body)) => {\n+                        let body_scope =\n+                            ccx.tcx.region_maps.call_site_extent(trait_item.id, body.id);\n+                        (sig, body_scope, body.id)\n+                    }\n+                    hir::MethodTraitItem(ref sig, None) => {\n+                        let item_scope = ccx.tcx.region_maps.item_extent(trait_item.id);\n+                        (sig, item_scope, it.id)\n+                    }\n                     _ => continue\n                 };\n                 check_method_self_type(ccx,\n                                        &BindingRscope::new(),\n                                        ccx.method_ty(trait_item.id),\n                                        tcx.mk_self_type(),\n                                        &sig.explicit_self,\n-                                       it.id)\n+                                       the_scope,\n+                                       the_id)\n             }\n         },\n         hir::ItemStruct(ref struct_def, _) => {\n@@ -2282,6 +2293,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n     method_type: Rc<ty::Method<'tcx>>,\n     required_type: Ty<'tcx>,\n     explicit_self: &hir::ExplicitSelf,\n+    body_scope: region::CodeExtent,\n     body_id: ast::NodeId)\n {\n     let tcx = ccx.tcx;\n@@ -2293,8 +2305,6 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n             _ => typ,\n         };\n \n-        let body_scope = tcx.region_maps.item_extent(body_id);\n-\n         // \"Required type\" comes from the trait definition. It may\n         // contain late-bound regions from the method, but not the\n         // trait (since traits only have early-bound region"}, {"sha": "887f7836ee143e933d0d10cd0d29cd8b2f64e813", "filename": "src/test/compile-fail/region-borrow-params-issue-29793-big.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-big.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #29793, big regression test: do not let borrows of\n+// parameters to ever be returned (expanded with exploration of\n+// variations).\n+//\n+// This is the version of the test that actually exposed unsound\n+// behavior (because the improperly accepted closure was actually\n+// able to be invoked).\n+\n+struct WrapA<F>(Option<F>);\n+\n+impl<F> WrapA<F> {\n+    fn new() -> WrapA<F> {\n+        WrapA(None)\n+    }\n+    fn set(mut self, f: F) -> Self {\n+        self.0 = Some(f);\n+        self\n+    }\n+}\n+\n+struct WrapB<F>(Option<F>);\n+\n+impl<F> WrapB<F> {\n+    fn new() -> WrapB<F> {\n+        WrapB(None)\n+    }\n+    fn set(mut self, f: F) -> Self {\n+        self.0 = Some(f);\n+        self\n+    }\n+}\n+\n+trait DoStuff : Sized {\n+    fn handle(self);\n+}\n+\n+impl<F, T> DoStuff for WrapA<F>\n+    where F: FnMut(usize, usize) -> T, T: DoStuff {\n+        fn handle(mut self) {\n+            if let Some(ref mut f) = self.0 {\n+                let x = f(1, 2);\n+                let _foo = [0usize; 16];\n+                x.handle();\n+            }\n+        }\n+    }\n+\n+impl<F> DoStuff for WrapB<F> where F: FnMut(bool) -> usize {\n+    fn handle(mut self) {\n+        if let Some(ref mut f) = self.0 {\n+            println!(\"{}\", f(true));\n+        }\n+    }\n+}\n+\n+impl<F, T> WrapA<F>\n+    where F: FnMut(usize, usize) -> T, T: DoStuff {\n+        fn handle_ref(&mut self) {\n+            if let Some(ref mut f) = self.0 {\n+                let x = f(1, 2);\n+            }\n+        }\n+    }\n+\n+fn main() {\n+    let mut w = WrapA::new().set(|x: usize, y: usize| {\n+        WrapB::new().set(|t: bool| if t { x } else { y }) // (separate errors for `x` vs `y`)\n+            //~^ ERROR `x` does not live long enough\n+            //~| ERROR `y` does not live long enough\n+    });\n+\n+    w.handle(); // This works\n+    // w.handle_ref(); // This doesn't\n+}"}, {"sha": "4fda8ec3f384ebaa2185e6c365d1bbefd54730be", "filename": "src/test/compile-fail/region-borrow-params-issue-29793-small.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/4af427881405f95b8d87efea844cbd695fb55986/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af427881405f95b8d87efea844cbd695fb55986/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-small.rs?ref=4af427881405f95b8d87efea844cbd695fb55986", "patch": "@@ -0,0 +1,223 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #29793, small regression tests: do not let borrows of\n+// parameters to ever be returned (expanded with exploration of\n+// variations).\n+\n+// CLOSURES\n+\n+fn escaping_borrow_of_closure_params_1() {\n+    let g = |x: usize, y:usize| {\n+        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n+        //~^ ERROR `x` does not live long enough\n+        //~| ERROR `y` does not live long enough\n+        return f;\n+    };\n+\n+    // We delberately do not call `g`; this small version of the test,\n+    // after adding such a call, was (properly) rejected even when the\n+    // system still suffered from issue #29793.\n+\n+    // g(10, 20)(true);\n+}\n+\n+fn escaping_borrow_of_closure_params_2() {\n+    let g = |x: usize, y:usize| {\n+        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n+        //~^ ERROR `x` does not live long enough\n+        //~| ERROR `y` does not live long enough\n+        f\n+    };\n+\n+    // (we don't call `g`; see above)\n+}\n+\n+fn move_of_closure_params() {\n+    let g = |x: usize, y:usize| {\n+        let f = move |t: bool| if t { x } else { y };\n+        f;\n+    };\n+    // (this code is fine, so lets go ahead and ensure rustc accepts call of `g`)\n+    (g(1,2));\n+}\n+\n+fn ok_borrow_of_fn_params(a: usize, b:usize) {\n+    let g = |x: usize, y:usize| {\n+        let f = |t: bool| if t { a } else { b };\n+        return f;\n+    };\n+    // (this code is fine, so lets go ahead and ensure rustc accepts call of `g`)\n+    (g(1,2))(true);\n+}\n+\n+// TOP-LEVEL FN'S\n+\n+fn escaping_borrow_of_fn_params_1() {\n+    fn g<'a>(x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n+        //~^ ERROR E0373\n+        //~| ERROR E0373\n+        return Box::new(f);\n+    };\n+\n+    // (we don't call `g`; see above)\n+}\n+\n+fn escaping_borrow_of_fn_params_2() {\n+    fn g<'a>(x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+        let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n+        //~^ ERROR E0373\n+        //~| ERROR E0373\n+        Box::new(f)\n+    };\n+\n+    // (we don't call `g`; see above)\n+}\n+\n+fn move_of_fn_params() {\n+    fn g<'a>(x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+        let f = move |t: bool| if t { x } else { y };\n+        return Box::new(f);\n+    };\n+    // (this code is fine, so lets go ahead and ensure rustc accepts call of `g`)\n+    (g(1,2))(true);\n+}\n+\n+// INHERENT METHODS\n+\n+fn escaping_borrow_of_method_params_1() {\n+    struct S;\n+    impl S {\n+        fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n+            //~^ ERROR E0373\n+            //~| ERROR E0373\n+            return Box::new(f);\n+        }\n+    }\n+\n+    // (we don't call `g`; see above)\n+}\n+\n+fn escaping_borrow_of_method_params_2() {\n+    struct S;\n+    impl S {\n+        fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n+            //~^ ERROR E0373\n+            //~| ERROR E0373\n+            Box::new(f)\n+        }\n+    }\n+    // (we don't call `g`; see above)\n+}\n+\n+fn move_of_method_params() {\n+    struct S;\n+    impl S {\n+        fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+            let f = move |t: bool| if t { x } else { y };\n+            return Box::new(f);\n+        }\n+    }\n+    // (this code is fine, so lets go ahead and ensure rustc accepts call of `g`)\n+    (S.g(1,2))(true);\n+}\n+\n+// TRAIT IMPL METHODS\n+\n+fn escaping_borrow_of_trait_impl_params_1() {\n+    trait T { fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a>; }\n+    struct S;\n+    impl T for S {\n+        fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n+            //~^ ERROR E0373\n+            //~| ERROR E0373\n+            return Box::new(f);\n+        }\n+    }\n+\n+    // (we don't call `g`; see above)\n+}\n+\n+fn escaping_borrow_of_trait_impl_params_2() {\n+    trait T { fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a>; }\n+    struct S;\n+    impl T for S {\n+        fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n+            //~^ ERROR E0373\n+            //~| ERROR E0373\n+            Box::new(f)\n+        }\n+    }\n+    // (we don't call `g`; see above)\n+}\n+\n+fn move_of_trait_impl_params() {\n+    trait T { fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a>; }\n+    struct S;\n+    impl T for S {\n+        fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+            let f = move |t: bool| if t { x } else { y };\n+            return Box::new(f);\n+        }\n+    }\n+    // (this code is fine, so lets go ahead and ensure rustc accepts call of `g`)\n+    (S.g(1,2))(true);\n+}\n+\n+// TRAIT DEFAULT METHODS\n+\n+fn escaping_borrow_of_trait_default_params_1() {\n+    struct S;\n+    trait T {\n+        fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n+            //~^ ERROR E0373\n+            //~| ERROR E0373\n+            return Box::new(f);\n+        }\n+    }\n+    impl T for S {}\n+    // (we don't call `g`; see above)\n+}\n+\n+fn escaping_borrow_of_trait_default_params_2() {\n+    struct S;\n+    trait T {\n+        fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+            let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n+            //~^ ERROR E0373\n+            //~| ERROR E0373\n+            Box::new(f)\n+        }\n+    }\n+    impl T for S {}\n+    // (we don't call `g`; see above)\n+}\n+\n+fn move_of_trait_default_params() {\n+    struct S;\n+    trait T {\n+        fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n+            let f = move |t: bool| if t { x } else { y };\n+            return Box::new(f);\n+        }\n+    }\n+    impl T for S {}\n+    // (this code is fine, so lets go ahead and ensure rustc accepts call of `g`)\n+    (S.g(1,2))(true);\n+}\n+\n+fn main() { }\n+"}]}