{"sha": "7a2670e3078aecd0422a00f658f9d26fd1da39f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMjY3MGUzMDc4YWVjZDA0MjJhMDBmNjU4ZjlkMjZmZDFkYTM5ZjU=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-08-23T13:23:48Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Use real type names rather than Self::", "tree": {"sha": "3ae556d5091d610499fce899c854e609c90d73bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ae556d5091d610499fce899c854e609c90d73bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a2670e3078aecd0422a00f658f9d26fd1da39f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a2670e3078aecd0422a00f658f9d26fd1da39f5", "html_url": "https://github.com/rust-lang/rust/commit/7a2670e3078aecd0422a00f658f9d26fd1da39f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a2670e3078aecd0422a00f658f9d26fd1da39f5/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a16d85bbae5e5ef94c750548c4bbd64bf540065f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a16d85bbae5e5ef94c750548c4bbd64bf540065f", "html_url": "https://github.com/rust-lang/rust/commit/a16d85bbae5e5ef94c750548c4bbd64bf540065f"}], "stats": {"total": 326, "additions": 163, "deletions": 163}, "files": [{"sha": "35d0bb9e05481cee3aac27b002d5d80187c5a327", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 163, "deletions": 163, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/7a2670e3078aecd0422a00f658f9d26fd1da39f5/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a2670e3078aecd0422a00f658f9d26fd1da39f5/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=7a2670e3078aecd0422a00f658f9d26fd1da39f5", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n-use llvm::{self, False, OperandBundleDef};\n+use llvm::{self, False, OperandBundleDef, BasicBlock};\n use common::*;\n use type_;\n-use value;\n+use value::Value;\n use libc::{c_uint, c_char};\n use rustc::ty::TyCtxt;\n use rustc::ty::layout::{Align, Size};\n@@ -27,7 +27,7 @@ use std::ptr;\n \n // All Builders must have an llfn associated with them\n #[must_use]\n-pub struct Builder<'a, 'll: 'a, 'tcx: 'll, V: 'll = &'ll value::Value> {\n+pub struct Builder<'a, 'll: 'a, 'tcx: 'll, V: 'll = &'ll Value> {\n     pub llbuilder: &'ll mut llvm::Builder<'ll>,\n     pub cx: &'a CodegenCx<'ll, 'tcx, V>,\n }\n@@ -56,13 +56,13 @@ bitflags! {\n }\n \n impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n-    type Value = &'ll value::Value;\n-    type BasicBlock = &'ll llvm::BasicBlock;\n+    type Value = &'ll Value;\n+    type BasicBlock = &'ll BasicBlock;\n     type Type = &'ll type_::Type;\n \n     fn new_block<'b>(\n         cx: &'a CodegenCx<'ll, 'tcx>,\n-        llfn: Self::Value,\n+        llfn: &'ll Value,\n         name: &'b str\n     ) -> Self {\n         let bx = Builder::with_cx(cx);\n@@ -101,13 +101,13 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         self.cx.tcx\n     }\n \n-    fn llfn(&self) -> Self::Value {\n+    fn llfn(&self) -> &'ll Value {\n         unsafe {\n             llvm::LLVMGetBasicBlockParent(self.llbb())\n         }\n     }\n \n-    fn llbb(&self) -> Self::BasicBlock {\n+    fn llbb(&self) -> &'ll BasicBlock {\n         unsafe {\n             llvm::LLVMGetInsertBlock(self.llbuilder)\n         }\n@@ -126,20 +126,20 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn set_value_name(&self, value: Self::Value, name: &str) {\n+    fn set_value_name(&self, value: &'ll Value, name: &str) {\n         let cname = SmallCStr::new(name);\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }\n     }\n \n-    fn position_at_end(&self, llbb: Self::BasicBlock) {\n+    fn position_at_end(&self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n         }\n     }\n \n-    fn position_at_start(&self, llbb: Self::BasicBlock) {\n+    fn position_at_start(&self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n         }\n@@ -152,14 +152,14 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn ret(&self, v: Self::Value) {\n+    fn ret(&self, v: &'ll Value) {\n         self.count_insn(\"ret\");\n         unsafe {\n             llvm::LLVMBuildRet(self.llbuilder, v);\n         }\n     }\n \n-    fn br(&self, dest: Self::BasicBlock) {\n+    fn br(&self, dest: &'ll BasicBlock) {\n         self.count_insn(\"br\");\n         unsafe {\n             llvm::LLVMBuildBr(self.llbuilder, dest);\n@@ -168,9 +168,9 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn cond_br(\n         &self,\n-        cond: Self::Value,\n-        then_llbb: Self::BasicBlock,\n-        else_llbb: Self::BasicBlock,\n+        cond: &'ll Value,\n+        then_llbb: &'ll BasicBlock,\n+        else_llbb: &'ll BasicBlock,\n     ) {\n         self.count_insn(\"condbr\");\n         unsafe {\n@@ -180,21 +180,21 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn switch(\n         &self,\n-        v: Self::Value,\n-        else_llbb: Self::BasicBlock,\n+        v: &'ll Value,\n+        else_llbb: &'ll BasicBlock,\n         num_cases: usize,\n-    ) -> Self::Value {\n+    ) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, num_cases as c_uint)\n         }\n     }\n \n     fn invoke(&self,\n-                  llfn: Self::Value,\n-                  args: &[Self::Value],\n-                  then: Self::BasicBlock,\n-                  catch: Self::BasicBlock,\n-                  bundle: Option<&traits::OperandBundleDef<'ll, Self::Value>>) -> Self::Value {\n+                  llfn: &'ll Value,\n+                  args: &[&'ll Value],\n+                  then: &'ll BasicBlock,\n+                  catch: &'ll BasicBlock,\n+                  bundle: Option<&traits::OperandBundleDef<'ll, &'ll Value>>) -> &'ll Value {\n         self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {:?} with args ({:?})\",\n@@ -225,21 +225,21 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     /* Arithmetic */\n-    fn add(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn add(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"add\");\n         unsafe {\n             llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fadd(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn fadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fadd_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn fadd_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n@@ -248,21 +248,21 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn sub(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn sub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"sub\");\n         unsafe {\n             llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fsub(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn fsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fsub_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn fsub_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n@@ -271,21 +271,21 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn mul(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn mul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"mul\");\n         unsafe {\n             llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fmul(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn fmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fmul_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn fmul_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n@@ -295,42 +295,42 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n \n-    fn udiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn udiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"udiv\");\n         unsafe {\n             llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn exactudiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn exactudiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"exactudiv\");\n         unsafe {\n             llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn sdiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn sdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"sdiv\");\n         unsafe {\n             llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn exactsdiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn exactsdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"exactsdiv\");\n         unsafe {\n             llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fdiv(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn fdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn fdiv_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn fdiv_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n@@ -339,28 +339,28 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn urem(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn urem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"urem\");\n         unsafe {\n             llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn srem(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn srem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"srem\");\n         unsafe {\n             llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn frem(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn frem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn frem_fast(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn frem_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n@@ -369,78 +369,78 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn shl(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn shl(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"shl\");\n         unsafe {\n             llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn lshr(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn lshr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"lshr\");\n         unsafe {\n             llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn ashr(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn ashr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"ashr\");\n         unsafe {\n             llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn and(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn and(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"and\");\n         unsafe {\n             llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn or(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn or(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"or\");\n         unsafe {\n             llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn xor(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn xor(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"xor\");\n         unsafe {\n             llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    fn neg(&self, v: Self::Value) -> Self::Value {\n+    fn neg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"neg\");\n         unsafe {\n             llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    fn fneg(&self, v: Self::Value) -> Self::Value {\n+    fn fneg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fneg\");\n         unsafe {\n             llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    fn not(&self, v: Self::Value) -> Self::Value {\n+    fn not(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"not\");\n         unsafe {\n             llvm::LLVMBuildNot(self.llbuilder, v, noname())\n         }\n     }\n \n-    fn alloca(&self, ty: Self::Type, name: &str, align: Align) -> Self::Value {\n+    fn alloca(&self, ty: Self::Type, name: &str, align: Align) -> &'ll Value {\n         let bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         bx.dynamic_alloca(ty, name, align)\n     }\n \n-    fn dynamic_alloca(&self, ty: Self::Type, name: &str, align: Align) -> Self::Value {\n+    fn dynamic_alloca(&self, ty: Self::Type, name: &str, align: Align) -> &'ll Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -457,9 +457,9 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn array_alloca(&self,\n                         ty: Self::Type,\n-                        len: Self::Value,\n+                        len: &'ll Value,\n                         name: &str,\n-                        align: Align) -> Self::Value {\n+                        align: Align) -> &'ll Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -474,7 +474,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn load(&self, ptr: Self::Value, align: Align) -> Self::Value {\n+    fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -483,7 +483,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn volatile_load(&self, ptr: Self::Value) -> Self::Value {\n+    fn volatile_load(&self, ptr: &'ll Value) -> &'ll Value {\n         self.count_insn(\"load.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -494,10 +494,10 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn atomic_load(\n         &self,\n-        ptr: Self::Value,\n+        ptr: &'ll Value,\n         order: traits::AtomicOrdering,\n         size: Size,\n-    ) -> Self::Value {\n+    ) -> &'ll Value {\n         self.count_insn(\"load.atomic\");\n         unsafe {\n             let load = llvm::LLVMRustBuildAtomicLoad(\n@@ -513,7 +513,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n \n-    fn range_metadata(&self, load: Self::Value, range: Range<u128>) {\n+    fn range_metadata(&self, load: &'ll Value, range: Range<u128>) {\n         if self.sess().target.target.arch == \"amdgpu\" {\n             // amdgpu/LLVM does something weird and thinks a i64 value is\n             // split into a v2i32, halving the bitwidth LLVM expects,\n@@ -536,24 +536,24 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn nonnull_metadata(&self, load: Self::Value) {\n+    fn nonnull_metadata(&self, load: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n-    fn store(&self, val: Self::Value, ptr: Self::Value, align: Align) -> Self::Value {\n+    fn store(&self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }\n \n     fn store_with_flags(\n         &self,\n-        val: Self::Value,\n-        ptr: Self::Value,\n+        val: &'ll Value,\n+        ptr: &'ll Value,\n         align: Align,\n         flags: MemFlags,\n-    ) -> Self::Value {\n+    ) -> &'ll Value {\n         debug!(\"Store {:?} -> {:?} ({:?})\", val, ptr, flags);\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n@@ -581,7 +581,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-   fn atomic_store(&self, val: Self::Value, ptr: Self::Value,\n+   fn atomic_store(&self, val: &'ll Value, ptr: &'ll Value,\n                    order: traits::AtomicOrdering, size: Size) {\n         debug!(\"Store {:?} -> {:?}\", val, ptr);\n         self.count_insn(\"store.atomic\");\n@@ -598,15 +598,15 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn gep(&self, ptr: Self::Value, indices: &[Self::Value]) -> Self::Value {\n+    fn gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"gep\");\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n \n-    fn inbounds_gep(&self, ptr: Self::Value, indices: &[Self::Value]) -> Self::Value {\n+    fn inbounds_gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n@@ -615,123 +615,123 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     /* Casts */\n-    fn trunc(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn trunc(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"trunc\");\n         unsafe {\n             llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn sext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn sext(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"sext\");\n         unsafe {\n             llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fptoui(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn fptoui(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"fptoui\");\n         unsafe {\n             llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fptosi(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn fptosi(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"fptosi\");\n         unsafe {\n             llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n-    fn uitofp(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn uitofp(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"uitofp\");\n         unsafe {\n             llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn sitofp(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn sitofp(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"sitofp\");\n         unsafe {\n             llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fptrunc(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn fptrunc(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"fptrunc\");\n         unsafe {\n             llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fpext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn fpext(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"fpext\");\n         unsafe {\n             llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn ptrtoint(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn ptrtoint(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"ptrtoint\");\n         unsafe {\n             llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn inttoptr(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn inttoptr(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"inttoptr\");\n         unsafe {\n             llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn bitcast(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn bitcast(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"bitcast\");\n         unsafe {\n             llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n \n-    fn intcast(&self, val: Self::Value, dest_ty: Self::Type, is_signed: bool) -> Self::Value {\n+    fn intcast(&self, val: &'ll Value, dest_ty: Self::Type, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"intcast\");\n         unsafe {\n             llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n-    fn pointercast(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn pointercast(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"pointercast\");\n         unsafe {\n             llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     /* Comparisons */\n-    fn icmp(&self, op: traits::IntPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn icmp(&self, op: traits::IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"icmp\");\n         let op = llvm::IntPredicate::from_generic(op);\n         unsafe {\n             llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n-    fn fcmp(&self, op: traits::RealPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn fcmp(&self, op: traits::RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fcmp\");\n         unsafe {\n             llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n     /* Miscellaneous instructions */\n-    fn empty_phi(&self, ty: Self::Type) -> Self::Value {\n+    fn empty_phi(&self, ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"emptyphi\");\n         unsafe {\n             llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n         }\n     }\n \n-    fn phi(&self, ty: Self::Type, vals: &[Self::Value], bbs: &[Self::BasicBlock]) -> Self::Value {\n+    fn phi(&self, ty: Self::Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n@@ -744,9 +744,9 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n-                       inputs: &[Self::Value], output: Self::Type,\n+                       inputs: &[&'ll Value], output: Self::Type,\n                        volatile: bool, alignstack: bool,\n-                       dia: syntax::ast::AsmDialect) -> Option<Self::Value> {\n+                       dia: syntax::ast::AsmDialect) -> Option<&'ll Value> {\n         self.count_insn(\"inlineasm\");\n \n         let volatile = if volatile { llvm::True }\n@@ -776,32 +776,32 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn memcpy(&self, dst: Self::Value, dst_align: u64,\n-                  src: Self::Value, src_align: u64,\n-                  size: Self::Value, is_volatile: bool) -> Self::Value {\n+    fn memcpy(&self, dst: &'ll Value, dst_align: u64,\n+                  src: &'ll Value, src_align: u64,\n+                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n         unsafe {\n             llvm::LLVMRustBuildMemCpy(self.llbuilder, dst, dst_align as c_uint,\n                                       src, src_align as c_uint, size, is_volatile)\n         }\n     }\n \n-    fn memmove(&self, dst: Self::Value, dst_align: u64,\n-                  src: Self::Value, src_align: u64,\n-                  size: Self::Value, is_volatile: bool) -> Self::Value {\n+    fn memmove(&self, dst: &'ll Value, dst_align: u64,\n+                  src: &'ll Value, src_align: u64,\n+                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n         unsafe {\n             llvm::LLVMRustBuildMemMove(self.llbuilder, dst, dst_align as c_uint,\n                                       src, src_align as c_uint, size, is_volatile)\n         }\n     }\n \n-    fn minnum(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"minnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs);\n             instr.expect(\"LLVMRustBuildMinNum is not available in LLVM version < 6.0\")\n         }\n     }\n-    fn maxnum(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value {\n+    fn maxnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"maxnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs);\n@@ -810,50 +810,50 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn select(\n-        &self, cond: Self::Value,\n-        then_val: Self::Value,\n-        else_val: Self::Value,\n-    ) -> Self::Value {\n+        &self, cond: &'ll Value,\n+        then_val: &'ll Value,\n+        else_val: &'ll Value,\n+    ) -> &'ll Value {\n         self.count_insn(\"select\");\n         unsafe {\n             llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n         }\n     }\n \n     #[allow(dead_code)]\n-    fn va_arg(&self, list: Self::Value, ty: Self::Type) -> Self::Value {\n+    fn va_arg(&self, list: &'ll Value, ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n-    fn extract_element(&self, vec: Self::Value, idx: Self::Value) -> Self::Value {\n+    fn extract_element(&self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n         self.count_insn(\"extractelement\");\n         unsafe {\n             llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n         }\n     }\n \n     fn insert_element(\n-        &self, vec: Self::Value,\n-        elt: Self::Value,\n-        idx: Self::Value,\n-    ) -> Self::Value {\n+        &self, vec: &'ll Value,\n+        elt: &'ll Value,\n+        idx: &'ll Value,\n+    ) -> &'ll Value {\n         self.count_insn(\"insertelement\");\n         unsafe {\n             llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n         }\n     }\n \n-    fn shuffle_vector(&self, v1: Self::Value, v2: Self::Value, mask: Self::Value) -> Self::Value {\n+    fn shuffle_vector(&self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value {\n         self.count_insn(\"shufflevector\");\n         unsafe {\n             llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n         }\n     }\n \n-    fn vector_splat(&self, num_elts: usize, elt: Self::Value) -> Self::Value {\n+    fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n             let elt_ty = val_ty(elt);\n             let undef = llvm::LLVMGetUndef(type_::Type::vector(elt_ty, num_elts as u64));\n@@ -863,7 +863,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn vector_reduce_fadd_fast(&self, acc: Self::Value, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_fadd_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fadd_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n@@ -874,7 +874,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n             instr\n         }\n     }\n-    fn vector_reduce_fmul_fast(&self, acc: Self::Value, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_fmul_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmul_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n@@ -885,69 +885,69 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n             instr\n         }\n     }\n-    fn vector_reduce_add(&self, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_add(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.add\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n     }\n-    fn vector_reduce_mul(&self, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_mul(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.mul\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n     }\n-    fn vector_reduce_and(&self, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_and(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.and\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n     }\n-    fn vector_reduce_or(&self, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_or(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.or\");\n         unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n     }\n-    fn vector_reduce_xor(&self, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_xor(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.xor\");\n         unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n     }\n-    fn vector_reduce_fmin(&self, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_fmin(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n-    fn vector_reduce_fmax(&self, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_fmax(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n-    fn vector_reduce_fmin_fast(&self, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_fmin_fast(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    fn vector_reduce_fmax_fast(&self, src: Self::Value) -> Self::Value {\n+    fn vector_reduce_fmax_fast(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    fn vector_reduce_min(&self, src: Self::Value, is_signed: bool) -> Self::Value {\n+    fn vector_reduce_min(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.min\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n     }\n-    fn vector_reduce_max(&self, src: Self::Value, is_signed: bool) -> Self::Value {\n+    fn vector_reduce_max(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.max\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n     }\n \n-    fn extract_value(&self, agg_val: Self::Value, idx: u64) -> Self::Value {\n+    fn extract_value(&self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n         }\n     }\n \n-    fn insert_value(&self, agg_val: Self::Value, elt: Self::Value,\n-                       idx: u64) -> Self::Value {\n+    fn insert_value(&self, agg_val: &'ll Value, elt: &'ll Value,\n+                       idx: u64) -> &'ll Value {\n         self.count_insn(\"insertvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n@@ -956,38 +956,38 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn landing_pad(&self, ty: Self::Type, pers_fn: Self::Value,\n-                       num_clauses: usize) -> Self::Value {\n+    fn landing_pad(&self, ty: Self::Type, pers_fn: &'ll Value,\n+                       num_clauses: usize) -> &'ll Value {\n         self.count_insn(\"landingpad\");\n         unsafe {\n             llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn,\n                                       num_clauses as c_uint, noname())\n         }\n     }\n \n-    fn add_clause(&self, landing_pad: Self::Value, clause: Self::Value) {\n+    fn add_clause(&self, landing_pad: &'ll Value, clause: &'ll Value) {\n         unsafe {\n             llvm::LLVMAddClause(landing_pad, clause);\n         }\n     }\n \n-    fn set_cleanup(&self, landing_pad: Self::Value) {\n+    fn set_cleanup(&self, landing_pad: &'ll Value) {\n         self.count_insn(\"setcleanup\");\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n     }\n \n-    fn resume(&self, exn: Self::Value) -> Self::Value {\n+    fn resume(&self, exn: &'ll Value) -> &'ll Value {\n         self.count_insn(\"resume\");\n         unsafe {\n             llvm::LLVMBuildResume(self.llbuilder, exn)\n         }\n     }\n \n     fn cleanup_pad(&self,\n-                       parent: Option<Self::Value>,\n-                       args: &[Self::Value]) -> Self::Value {\n+                       parent: Option<&'ll Value>,\n+                       args: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"cleanuppad\");\n         let name = const_cstr!(\"cleanuppad\");\n         let ret = unsafe {\n@@ -1001,9 +1001,9 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn cleanup_ret(\n-        &self, cleanup: Self::Value,\n-        unwind: Option<Self::BasicBlock>,\n-    ) -> Self::Value {\n+        &self, cleanup: &'ll Value,\n+        unwind: Option<&'ll BasicBlock>,\n+    ) -> &'ll Value {\n         self.count_insn(\"cleanupret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupRet(self.llbuilder, cleanup, unwind)\n@@ -1012,8 +1012,8 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn catch_pad(&self,\n-                     parent: Self::Value,\n-                     args: &[Self::Value]) -> Self::Value {\n+                     parent: &'ll Value,\n+                     args: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"catchpad\");\n         let name = const_cstr!(\"catchpad\");\n         let ret = unsafe {\n@@ -1024,7 +1024,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for catchpad\")\n     }\n \n-    fn catch_ret(&self, pad: Self::Value, unwind: Self::BasicBlock) -> Self::Value {\n+    fn catch_ret(&self, pad: &'ll Value, unwind: &'ll BasicBlock) -> &'ll Value {\n         self.count_insn(\"catchret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchRet(self.llbuilder, pad, unwind)\n@@ -1034,10 +1034,10 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn catch_switch(\n         &self,\n-        parent: Option<Self::Value>,\n-        unwind: Option<Self::BasicBlock>,\n+        parent: Option<&'ll Value>,\n+        unwind: Option<&'ll BasicBlock>,\n         num_handlers: usize,\n-    ) -> Self::Value {\n+    ) -> &'ll Value {\n         self.count_insn(\"catchswitch\");\n         let name = const_cstr!(\"catchswitch\");\n         let ret = unsafe {\n@@ -1048,13 +1048,13 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for catchswitch\")\n     }\n \n-    fn add_handler(&self, catch_switch: Self::Value, handler: Self::BasicBlock) {\n+    fn add_handler(&self, catch_switch: &'ll Value, handler: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustAddHandler(catch_switch, handler);\n         }\n     }\n \n-    fn set_personality_fn(&self, personality: Self::Value) {\n+    fn set_personality_fn(&self, personality: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetPersonalityFn(self.llfn(), personality);\n         }\n@@ -1063,13 +1063,13 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     // Atomic Operations\n     fn atomic_cmpxchg(\n         &self,\n-        dst: Self::Value,\n-        cmp: Self::Value,\n-        src: Self::Value,\n+        dst: &'ll Value,\n+        cmp: &'ll Value,\n+        src: &'ll Value,\n         order: traits::AtomicOrdering,\n         failure_order: traits::AtomicOrdering,\n         weak: bool,\n-    ) -> Self::Value {\n+    ) -> &'ll Value {\n         let weak = if weak { llvm::True } else { llvm::False };\n         unsafe {\n             llvm::LLVMRustBuildAtomicCmpXchg(\n@@ -1086,10 +1086,10 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn atomic_rmw(\n         &self,\n         op: traits::AtomicRmwBinOp,\n-        dst: Self::Value,\n-        src: Self::Value,\n+        dst: &'ll Value,\n+        src: &'ll Value,\n         order: traits::AtomicOrdering,\n-    ) -> Self::Value {\n+    ) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildAtomicRMW(\n                 self.llbuilder,\n@@ -1111,20 +1111,20 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn add_case(&self, s: Self::Value, on_val: Self::Value, dest: Self::BasicBlock) {\n+    fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMAddCase(s, on_val, dest)\n         }\n     }\n \n-    fn add_incoming_to_phi(&self, phi: Self::Value, val: Self::Value, bb: Self::BasicBlock) {\n+    fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n         self.count_insn(\"addincoming\");\n         unsafe {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }\n     }\n \n-    fn set_invariant_load(&self, load: Self::Value) {\n+    fn set_invariant_load(&self, load: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n@@ -1133,8 +1133,8 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     /// Returns the ptr value that should be used for storing `val`.\n     fn check_store<'b>(&self,\n-                       val: Self::Value,\n-                       ptr: Self::Value) -> Self::Value {\n+                       val: &'ll Value,\n+                       ptr: &'ll Value) -> &'ll Value {\n         let dest_ptr_ty = val_ty(ptr);\n         let stored_ty = val_ty(val);\n         let stored_ptr_ty = stored_ty.ptr_to();\n@@ -1154,8 +1154,8 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     /// Returns the args that should be used for a call to `llfn`.\n     fn check_call<'b>(&self,\n                       typ: &str,\n-                      llfn: Self::Value,\n-                      args: &'b [Self::Value]) -> Cow<'b, [Self::Value]> {\n+                      llfn: &'ll Value,\n+                      args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n         let mut fn_ty = val_ty(llfn);\n         // Strip off pointers\n         while fn_ty.kind() == llvm::TypeKind::Pointer {\n@@ -1194,11 +1194,11 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         Cow::Owned(casted_args)\n     }\n \n-    fn lifetime_start(&self, ptr: Self::Value, size: Size) {\n+    fn lifetime_start(&self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n     }\n \n-    fn lifetime_end(&self, ptr: Self::Value, size: Size) {\n+    fn lifetime_end(&self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n     }\n \n@@ -1210,7 +1210,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     ///\n     /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n     /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n-    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: Self::Value, size: Size) {\n+    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n         if self.cx.sess().opts.optimize == config::OptLevel::No {\n             return;\n         }\n@@ -1226,8 +1226,8 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(lifetime_intrinsic, &[C_u64(self.cx, size), ptr], None);\n     }\n \n-    fn call(&self, llfn: Self::Value, args: &[Self::Value],\n-                bundle: Option<&traits::OperandBundleDef<'ll, Self::Value>>) -> Self::Value {\n+    fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n+                bundle: Option<&traits::OperandBundleDef<'ll, &'ll Value>>) -> &'ll Value {\n         self.count_insn(\"call\");\n \n         debug!(\"Call {:?} with args ({:?})\",\n@@ -1249,14 +1249,14 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn zext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value {\n+    fn zext(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n         self.count_insn(\"zext\");\n         unsafe {\n             llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn struct_gep(&self, ptr: Self::Value, idx: u64) -> Self::Value {\n+    fn struct_gep(&self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n         self.count_insn(\"structgep\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {"}]}