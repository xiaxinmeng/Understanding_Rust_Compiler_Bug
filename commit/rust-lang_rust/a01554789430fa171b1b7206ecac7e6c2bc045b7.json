{"sha": "a01554789430fa171b1b7206ecac7e6c2bc045b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMTU1NDc4OTQzMGZhMTcxYjFiNzIwNmVjYWM3ZTZjMmJjMDQ1Yjc=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-24T03:36:43Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-29T05:26:22Z"}, "message": "debuginfo: extract utils.rs", "tree": {"sha": "550bf6b1dd10290aee3e52bccc12d391bedf5da4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/550bf6b1dd10290aee3e52bccc12d391bedf5da4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a01554789430fa171b1b7206ecac7e6c2bc045b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a01554789430fa171b1b7206ecac7e6c2bc045b7", "html_url": "https://github.com/rust-lang/rust/commit/a01554789430fa171b1b7206ecac7e6c2bc045b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a01554789430fa171b1b7206ecac7e6c2bc045b7/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5753c8d6ca7aeaab27cfcc85e42fc7b6f9a37bd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5753c8d6ca7aeaab27cfcc85e42fc7b6f9a37bd8", "html_url": "https://github.com/rust-lang/rust/commit/5753c8d6ca7aeaab27cfcc85e42fc7b6f9a37bd8"}], "stats": {"total": 1152, "additions": 589, "deletions": 563}, "files": [{"sha": "306bed6785a2c373cf436c4518ce3b705feef743", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 5, "deletions": 563, "changes": 568, "blob_url": "https://github.com/rust-lang/rust/blob/a01554789430fa171b1b7206ecac7e6c2bc045b7/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01554789430fa171b1b7206ecac7e6c2bc045b7/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=a01554789430fa171b1b7206ecac7e6c2bc045b7", "patch": "@@ -12,6 +12,11 @@\n mod doc;\n \n pub mod gdb;\n+mod utils;\n+\n+use self::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n+                  assert_type_for_node_id, get_namespace_and_span_for_item, fn_should_be_ignored,\n+                  contains_nodebug_attribute, create_scope_map};\n \n use self::VariableAccess::*;\n use self::VariableKind::*;\n@@ -2978,569 +2983,6 @@ fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation)\n     debug_context(cx).current_debug_location.set(debug_location);\n }\n \n-//=-----------------------------------------------------------------------------\n-//  Utility Functions\n-//=-----------------------------------------------------------------------------\n-\n-fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n-    attributes.iter().any(|attr| {\n-        let meta_item: &ast::MetaItem = &*attr.node.value;\n-        match meta_item.node {\n-            ast::MetaWord(ref value) => &value[..] == \"no_debug\",\n-            _ => false\n-        }\n-    })\n-}\n-\n-/// Return codemap::Loc corresponding to the beginning of the span\n-fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n-    cx.sess().codemap().lookup_char_pos(span.lo)\n-}\n-\n-fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n-    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type) as u64)\n-}\n-\n-fn bytes_to_bits(bytes: u64) -> u64 {\n-    bytes * 8\n-}\n-\n-#[inline]\n-fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n-                           -> &'a CrateDebugContext<'tcx> {\n-    let debug_context: &'a CrateDebugContext<'tcx> = cx.dbg_cx().as_ref().unwrap();\n-    debug_context\n-}\n-\n-#[inline]\n-#[allow(non_snake_case)]\n-fn DIB(cx: &CrateContext) -> DIBuilderRef {\n-    cx.dbg_cx().as_ref().unwrap().builder\n-}\n-\n-fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n-    match fcx.debug_context {\n-        FunctionDebugContext::RegularContext(_) => false,\n-        _ => true\n-    }\n-}\n-\n-fn assert_type_for_node_id(cx: &CrateContext,\n-                           node_id: ast::NodeId,\n-                           error_reporting_span: Span) {\n-    if !cx.tcx().node_types().contains_key(&node_id) {\n-        cx.sess().span_bug(error_reporting_span,\n-                           \"debuginfo: Could not find type for node id!\");\n-    }\n-}\n-\n-fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n-                                   -> (DIScope, Span) {\n-    let containing_scope = namespace_for_item(cx, def_id).scope;\n-    let definition_span = if def_id.krate == ast::LOCAL_CRATE {\n-        cx.tcx().map.span(def_id.node)\n-    } else {\n-        // For external items there is no span information\n-        codemap::DUMMY_SP\n-    };\n-\n-    (containing_scope, definition_span)\n-}\n-\n-// This procedure builds the *scope map* for a given function, which maps any\n-// given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n-//\n-// This builder procedure walks the AST in execution order and keeps track of\n-// what belongs to which scope, creating DIScope DIEs along the way, and\n-// introducing *artificial* lexical scope descriptors where necessary. These\n-// artificial scopes allow GDB to correctly handle name shadowing.\n-fn create_scope_map(cx: &CrateContext,\n-                    args: &[ast::Arg],\n-                    fn_entry_block: &ast::Block,\n-                    fn_metadata: DISubprogram,\n-                    fn_ast_id: ast::NodeId)\n-                 -> NodeMap<DIScope> {\n-    let mut scope_map = NodeMap();\n-\n-    let def_map = &cx.tcx().def_map;\n-\n-    struct ScopeStackEntry {\n-        scope_metadata: DIScope,\n-        name: Option<ast::Name>\n-    }\n-\n-    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n-    scope_map.insert(fn_ast_id, fn_metadata);\n-\n-    // Push argument identifiers onto the stack so arguments integrate nicely\n-    // with variable shadowing.\n-    for arg in args {\n-        pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n-            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n-                                               name: Some(path1.node.name) });\n-            scope_map.insert(node_id, fn_metadata);\n-        })\n-    }\n-\n-    // Clang creates a separate scope for function bodies, so let's do this too.\n-    with_new_scope(cx,\n-                   fn_entry_block.span,\n-                   &mut scope_stack,\n-                   &mut scope_map,\n-                   |cx, scope_stack, scope_map| {\n-        walk_block(cx, fn_entry_block, scope_stack, scope_map);\n-    });\n-\n-    return scope_map;\n-\n-\n-    // local helper functions for walking the AST.\n-    fn with_new_scope<F>(cx: &CrateContext,\n-                         scope_span: Span,\n-                         scope_stack: &mut Vec<ScopeStackEntry> ,\n-                         scope_map: &mut NodeMap<DIScope>,\n-                         inner_walk: F) where\n-        F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n-    {\n-        // Create a new lexical scope and push it onto the stack\n-        let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, &loc.file.name);\n-        let parent_scope = scope_stack.last().unwrap().scope_metadata;\n-\n-        let scope_metadata = unsafe {\n-            llvm::LLVMDIBuilderCreateLexicalBlock(\n-                DIB(cx),\n-                parent_scope,\n-                file_metadata,\n-                loc.line as c_uint,\n-                loc.col.to_usize() as c_uint)\n-        };\n-\n-        scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, name: None });\n-\n-        inner_walk(cx, scope_stack, scope_map);\n-\n-        // pop artificial scopes\n-        while scope_stack.last().unwrap().name.is_some() {\n-            scope_stack.pop();\n-        }\n-\n-        if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n-            cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n-        }\n-\n-        scope_stack.pop();\n-    }\n-\n-    fn walk_block(cx: &CrateContext,\n-                  block: &ast::Block,\n-                  scope_stack: &mut Vec<ScopeStackEntry> ,\n-                  scope_map: &mut NodeMap<DIScope>) {\n-        scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n-\n-        // The interesting things here are statements and the concluding expression.\n-        for statement in &block.stmts {\n-            scope_map.insert(ast_util::stmt_id(&**statement),\n-                             scope_stack.last().unwrap().scope_metadata);\n-\n-            match statement.node {\n-                ast::StmtDecl(ref decl, _) =>\n-                    walk_decl(cx, &**decl, scope_stack, scope_map),\n-                ast::StmtExpr(ref exp, _) |\n-                ast::StmtSemi(ref exp, _) =>\n-                    walk_expr(cx, &**exp, scope_stack, scope_map),\n-                ast::StmtMac(..) => () // Ignore macros (which should be expanded anyway).\n-            }\n-        }\n-\n-        if let Some(ref exp) = block.expr {\n-            walk_expr(cx, &**exp, scope_stack, scope_map);\n-        }\n-    }\n-\n-    fn walk_decl(cx: &CrateContext,\n-                 decl: &ast::Decl,\n-                 scope_stack: &mut Vec<ScopeStackEntry> ,\n-                 scope_map: &mut NodeMap<DIScope>) {\n-        match *decl {\n-            codemap::Spanned { node: ast::DeclLocal(ref local), .. } => {\n-                scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n-\n-                if let Some(ref exp) = local.init {\n-                    walk_expr(cx, &**exp, scope_stack, scope_map);\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    fn walk_pattern(cx: &CrateContext,\n-                    pat: &ast::Pat,\n-                    scope_stack: &mut Vec<ScopeStackEntry> ,\n-                    scope_map: &mut NodeMap<DIScope>) {\n-\n-        let def_map = &cx.tcx().def_map;\n-\n-        // Unfortunately, we cannot just use pat_util::pat_bindings() or\n-        // ast_util::walk_pat() here because we have to visit *all* nodes in\n-        // order to put them into the scope map. The above functions don't do that.\n-        match pat.node {\n-            ast::PatIdent(_, ref path1, ref sub_pat_opt) => {\n-\n-                // Check if this is a binding. If so we need to put it on the\n-                // scope stack and maybe introduce an artificial scope\n-                if pat_util::pat_is_binding(def_map, &*pat) {\n-\n-                    let name = path1.node.name;\n-\n-                    // LLVM does not properly generate 'DW_AT_start_scope' fields\n-                    // for variable DIEs. For this reason we have to introduce\n-                    // an artificial scope at bindings whenever a variable with\n-                    // the same name is declared in *any* parent scope.\n-                    //\n-                    // Otherwise the following error occurs:\n-                    //\n-                    // let x = 10;\n-                    //\n-                    // do_something(); // 'gdb print x' correctly prints 10\n-                    //\n-                    // {\n-                    //     do_something(); // 'gdb print x' prints 0, because it\n-                    //                     // already reads the uninitialized 'x'\n-                    //                     // from the next line...\n-                    //     let x = 100;\n-                    //     do_something(); // 'gdb print x' correctly prints 100\n-                    // }\n-\n-                    // Is there already a binding with that name?\n-                    // N.B.: this comparison must be UNhygienic... because\n-                    // gdb knows nothing about the context, so any two\n-                    // variables with the same name will cause the problem.\n-                    let need_new_scope = scope_stack\n-                        .iter()\n-                        .any(|entry| entry.name == Some(name));\n-\n-                    if need_new_scope {\n-                        // Create a new lexical scope and push it onto the stack\n-                        let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx, &loc.file.name);\n-                        let parent_scope = scope_stack.last().unwrap().scope_metadata;\n-\n-                        let scope_metadata = unsafe {\n-                            llvm::LLVMDIBuilderCreateLexicalBlock(\n-                                DIB(cx),\n-                                parent_scope,\n-                                file_metadata,\n-                                loc.line as c_uint,\n-                                loc.col.to_usize() as c_uint)\n-                        };\n-\n-                        scope_stack.push(ScopeStackEntry {\n-                            scope_metadata: scope_metadata,\n-                            name: Some(name)\n-                        });\n-\n-                    } else {\n-                        // Push a new entry anyway so the name can be found\n-                        let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n-                        scope_stack.push(ScopeStackEntry {\n-                            scope_metadata: prev_metadata,\n-                            name: Some(name)\n-                        });\n-                    }\n-                }\n-\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                if let Some(ref sub_pat) = *sub_pat_opt {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::PatWild(_) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            }\n-\n-            ast::PatEnum(_, ref sub_pats_opt) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                if let Some(ref sub_pats) = *sub_pats_opt {\n-                    for p in sub_pats {\n-                        walk_pattern(cx, &**p, scope_stack, scope_map);\n-                    }\n-                }\n-            }\n-\n-            ast::PatQPath(..) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            }\n-\n-            ast::PatStruct(_, ref field_pats, _) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                for &codemap::Spanned {\n-                    node: ast::FieldPat { pat: ref sub_pat, .. },\n-                    ..\n-                } in field_pats.iter() {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::PatTup(ref sub_pats) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                for sub_pat in sub_pats {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat, _) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-            }\n-\n-            ast::PatLit(ref exp) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_expr(cx, &**exp, scope_stack, scope_map);\n-            }\n-\n-            ast::PatRange(ref exp1, ref exp2) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_expr(cx, &**exp1, scope_stack, scope_map);\n-                walk_expr(cx, &**exp2, scope_stack, scope_map);\n-            }\n-\n-            ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                for sub_pat in front_sub_pats {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-\n-                if let Some(ref sub_pat) = *middle_sub_pats {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-\n-                for sub_pat in back_sub_pats {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::PatMac(_) => {\n-                cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n-                                              Found unexpanded macro.\");\n-            }\n-        }\n-    }\n-\n-    fn walk_expr(cx: &CrateContext,\n-                 exp: &ast::Expr,\n-                 scope_stack: &mut Vec<ScopeStackEntry> ,\n-                 scope_map: &mut NodeMap<DIScope>) {\n-\n-        scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n-\n-        match exp.node {\n-            ast::ExprLit(_)   |\n-            ast::ExprBreak(_) |\n-            ast::ExprAgain(_) |\n-            ast::ExprPath(..) => {}\n-\n-            ast::ExprCast(ref sub_exp, _)     |\n-            ast::ExprAddrOf(_, ref sub_exp)  |\n-            ast::ExprField(ref sub_exp, _) |\n-            ast::ExprTupField(ref sub_exp, _) |\n-            ast::ExprParen(ref sub_exp) =>\n-                walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n-\n-            ast::ExprBox(ref place, ref sub_expr) => {\n-                place.as_ref().map(\n-                    |e| walk_expr(cx, &**e, scope_stack, scope_map));\n-                walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n-            }\n-\n-            ast::ExprRet(ref exp_opt) => match *exp_opt {\n-                Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n-                None => ()\n-            },\n-\n-            ast::ExprUnary(_, ref sub_exp) => {\n-                walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n-            }\n-\n-            ast::ExprAssignOp(_, ref lhs, ref rhs) |\n-            ast::ExprIndex(ref lhs, ref rhs) |\n-            ast::ExprBinary(_, ref lhs, ref rhs)    => {\n-                walk_expr(cx, &**lhs, scope_stack, scope_map);\n-                walk_expr(cx, &**rhs, scope_stack, scope_map);\n-            }\n-\n-            ast::ExprRange(ref start, ref end) => {\n-                start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n-                end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n-            }\n-\n-            ast::ExprVec(ref init_expressions) |\n-            ast::ExprTup(ref init_expressions) => {\n-                for ie in init_expressions {\n-                    walk_expr(cx, &**ie, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::ExprAssign(ref sub_exp1, ref sub_exp2) |\n-            ast::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n-                walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n-                walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n-            }\n-\n-            ast::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n-                walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n-\n-                with_new_scope(cx,\n-                               then_block.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    walk_block(cx, &**then_block, scope_stack, scope_map);\n-                });\n-\n-                match *opt_else_exp {\n-                    Some(ref else_exp) =>\n-                        walk_expr(cx, &**else_exp, scope_stack, scope_map),\n-                    _ => ()\n-                }\n-            }\n-\n-            ast::ExprIfLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n-                                              Found unexpanded if-let.\");\n-            }\n-\n-            ast::ExprWhile(ref cond_exp, ref loop_body, _) => {\n-                walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n-\n-                with_new_scope(cx,\n-                               loop_body.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    walk_block(cx, &**loop_body, scope_stack, scope_map);\n-                })\n-            }\n-\n-            ast::ExprWhileLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n-                                              Found unexpanded while-let.\");\n-            }\n-\n-            ast::ExprForLoop(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n-                                              Found unexpanded for loop.\");\n-            }\n-\n-            ast::ExprMac(_) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n-                                              Found unexpanded macro.\");\n-            }\n-\n-            ast::ExprLoop(ref block, _) |\n-            ast::ExprBlock(ref block)   => {\n-                with_new_scope(cx,\n-                               block.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    walk_block(cx, &**block, scope_stack, scope_map);\n-                })\n-            }\n-\n-            ast::ExprClosure(_, ref decl, ref block) => {\n-                with_new_scope(cx,\n-                               block.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    for &ast::Arg { pat: ref pattern, .. } in &decl.inputs {\n-                        walk_pattern(cx, &**pattern, scope_stack, scope_map);\n-                    }\n-\n-                    walk_block(cx, &**block, scope_stack, scope_map);\n-                })\n-            }\n-\n-            ast::ExprCall(ref fn_exp, ref args) => {\n-                walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n-\n-                for arg_exp in args {\n-                    walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::ExprMethodCall(_, _, ref args) => {\n-                for arg_exp in args {\n-                    walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::ExprMatch(ref discriminant_exp, ref arms, _) => {\n-                walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n-\n-                // For each arm we have to first walk the pattern as these might\n-                // introduce new artificial scopes. It should be sufficient to\n-                // walk only one pattern per arm, as they all must contain the\n-                // same binding names.\n-\n-                for arm_ref in arms {\n-                    let arm_span = arm_ref.pats[0].span;\n-\n-                    with_new_scope(cx,\n-                                   arm_span,\n-                                   scope_stack,\n-                                   scope_map,\n-                                   |cx, scope_stack, scope_map| {\n-                        for pat in &arm_ref.pats {\n-                            walk_pattern(cx, &**pat, scope_stack, scope_map);\n-                        }\n-\n-                        if let Some(ref guard_exp) = arm_ref.guard {\n-                            walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n-                        }\n-\n-                        walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n-                    })\n-                }\n-            }\n-\n-            ast::ExprStruct(_, ref fields, ref base_exp) => {\n-                for &ast::Field { expr: ref exp, .. } in fields {\n-                    walk_expr(cx, &**exp, scope_stack, scope_map);\n-                }\n-\n-                match *base_exp {\n-                    Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n-                    None => ()\n-                }\n-            }\n-\n-            ast::ExprInlineAsm(ast::InlineAsm { ref inputs,\n-                                                ref outputs,\n-                                                .. }) => {\n-                // inputs, outputs: Vec<(String, P<Expr>)>\n-                for &(_, ref exp) in inputs {\n-                    walk_expr(cx, &**exp, scope_stack, scope_map);\n-                }\n-\n-                for &(_, ref exp, _) in outputs {\n-                    walk_expr(cx, &**exp, scope_stack, scope_map);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-\n //=-----------------------------------------------------------------------------\n // Type Names for Debug Info\n //=-----------------------------------------------------------------------------"}, {"sha": "161128279fed1b4cf0517a9571a648c6b1bc38f5", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "added", "additions": 584, "deletions": 0, "changes": 584, "blob_url": "https://github.com/rust-lang/rust/blob/a01554789430fa171b1b7206ecac7e6c2bc045b7/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01554789430fa171b1b7206ecac7e6c2bc045b7/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=a01554789430fa171b1b7206ecac7e6c2bc045b7", "patch": "@@ -0,0 +1,584 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://!rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://!www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://!opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Utility Functions.\n+\n+use super::{FunctionDebugContext, CrateDebugContext, namespace_for_item, file_metadata};\n+\n+use llvm;\n+use llvm::debuginfo::{DIScope, DISubprogram, DIBuilderRef};\n+use trans::machine;\n+use trans::common::{CrateContext, FunctionContext};\n+use trans::type_::Type;\n+use middle::pat_util;\n+use util::nodemap::NodeMap;\n+\n+use libc::c_uint;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap, ast_util};\n+\n+\n+pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n+    attributes.iter().any(|attr| {\n+        let meta_item: &ast::MetaItem = &*attr.node.value;\n+        match meta_item.node {\n+            ast::MetaWord(ref value) => &value[..] == \"no_debug\",\n+            _ => false\n+        }\n+    })\n+}\n+\n+/// Return codemap::Loc corresponding to the beginning of the span\n+pub fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n+    cx.sess().codemap().lookup_char_pos(span.lo)\n+}\n+\n+pub fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n+    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type) as u64)\n+}\n+\n+pub fn bytes_to_bits(bytes: u64) -> u64 {\n+    bytes * 8\n+}\n+\n+#[inline]\n+pub fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n+                           -> &'a CrateDebugContext<'tcx> {\n+    let debug_context: &'a CrateDebugContext<'tcx> = cx.dbg_cx().as_ref().unwrap();\n+    debug_context\n+}\n+\n+#[inline]\n+#[allow(non_snake_case)]\n+pub fn DIB(cx: &CrateContext) -> DIBuilderRef {\n+    cx.dbg_cx().as_ref().unwrap().builder\n+}\n+\n+pub fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(_) => false,\n+        _ => true\n+    }\n+}\n+\n+pub fn assert_type_for_node_id(cx: &CrateContext,\n+                           node_id: ast::NodeId,\n+                           error_reporting_span: Span) {\n+    if !cx.tcx().node_types().contains_key(&node_id) {\n+        cx.sess().span_bug(error_reporting_span,\n+                           \"debuginfo: Could not find type for node id!\");\n+    }\n+}\n+\n+pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n+                                   -> (DIScope, Span) {\n+    let containing_scope = namespace_for_item(cx, def_id).scope;\n+    let definition_span = if def_id.krate == ast::LOCAL_CRATE {\n+        cx.tcx().map.span(def_id.node)\n+    } else {\n+        // For external items there is no span information\n+        codemap::DUMMY_SP\n+    };\n+\n+    (containing_scope, definition_span)\n+}\n+\n+// This procedure builds the *scope map* for a given function, which maps any\n+// given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n+//\n+// This builder procedure walks the AST in execution order and keeps track of\n+// what belongs to which scope, creating DIScope DIEs along the way, and\n+// introducing *artificial* lexical scope descriptors where necessary. These\n+// artificial scopes allow GDB to correctly handle name shadowing.\n+pub fn create_scope_map(cx: &CrateContext,\n+                        args: &[ast::Arg],\n+                        fn_entry_block: &ast::Block,\n+                        fn_metadata: DISubprogram,\n+                        fn_ast_id: ast::NodeId)\n+                        -> NodeMap<DIScope> {\n+    let mut scope_map = NodeMap();\n+\n+    let def_map = &cx.tcx().def_map;\n+\n+    struct ScopeStackEntry {\n+        scope_metadata: DIScope,\n+        name: Option<ast::Name>\n+    }\n+\n+    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n+    scope_map.insert(fn_ast_id, fn_metadata);\n+\n+    // Push argument identifiers onto the stack so arguments integrate nicely\n+    // with variable shadowing.\n+    for arg in args {\n+        pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n+            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n+                                               name: Some(path1.node.name) });\n+            scope_map.insert(node_id, fn_metadata);\n+        })\n+    }\n+\n+    // Clang creates a separate scope for function bodies, so let's do this too.\n+    with_new_scope(cx,\n+                   fn_entry_block.span,\n+                   &mut scope_stack,\n+                   &mut scope_map,\n+                   |cx, scope_stack, scope_map| {\n+        walk_block(cx, fn_entry_block, scope_stack, scope_map);\n+    });\n+\n+    return scope_map;\n+\n+\n+    // local helper functions for walking the AST.\n+    fn with_new_scope<F>(cx: &CrateContext,\n+                         scope_span: Span,\n+                         scope_stack: &mut Vec<ScopeStackEntry> ,\n+                         scope_map: &mut NodeMap<DIScope>,\n+                         inner_walk: F) where\n+        F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n+    {\n+        // Create a new lexical scope and push it onto the stack\n+        let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n+        let file_metadata = file_metadata(cx, &loc.file.name);\n+        let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+        let scope_metadata = unsafe {\n+            llvm::LLVMDIBuilderCreateLexicalBlock(\n+                DIB(cx),\n+                parent_scope,\n+                file_metadata,\n+                loc.line as c_uint,\n+                loc.col.to_usize() as c_uint)\n+        };\n+\n+        scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, name: None });\n+\n+        inner_walk(cx, scope_stack, scope_map);\n+\n+        // pop artificial scopes\n+        while scope_stack.last().unwrap().name.is_some() {\n+            scope_stack.pop();\n+        }\n+\n+        if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n+            cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n+        }\n+\n+        scope_stack.pop();\n+    }\n+\n+    fn walk_block(cx: &CrateContext,\n+                  block: &ast::Block,\n+                  scope_stack: &mut Vec<ScopeStackEntry> ,\n+                  scope_map: &mut NodeMap<DIScope>) {\n+        scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n+\n+        // The interesting things here are statements and the concluding expression.\n+        for statement in &block.stmts {\n+            scope_map.insert(ast_util::stmt_id(&**statement),\n+                             scope_stack.last().unwrap().scope_metadata);\n+\n+            match statement.node {\n+                ast::StmtDecl(ref decl, _) =>\n+                    walk_decl(cx, &**decl, scope_stack, scope_map),\n+                ast::StmtExpr(ref exp, _) |\n+                ast::StmtSemi(ref exp, _) =>\n+                    walk_expr(cx, &**exp, scope_stack, scope_map),\n+                ast::StmtMac(..) => () // Ignore macros (which should be expanded anyway).\n+            }\n+        }\n+\n+        if let Some(ref exp) = block.expr {\n+            walk_expr(cx, &**exp, scope_stack, scope_map);\n+        }\n+    }\n+\n+    fn walk_decl(cx: &CrateContext,\n+                 decl: &ast::Decl,\n+                 scope_stack: &mut Vec<ScopeStackEntry> ,\n+                 scope_map: &mut NodeMap<DIScope>) {\n+        match *decl {\n+            codemap::Spanned { node: ast::DeclLocal(ref local), .. } => {\n+                scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n+\n+                walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n+\n+                if let Some(ref exp) = local.init {\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    fn walk_pattern(cx: &CrateContext,\n+                    pat: &ast::Pat,\n+                    scope_stack: &mut Vec<ScopeStackEntry> ,\n+                    scope_map: &mut NodeMap<DIScope>) {\n+\n+        let def_map = &cx.tcx().def_map;\n+\n+        // Unfortunately, we cannot just use pat_util::pat_bindings() or\n+        // ast_util::walk_pat() here because we have to visit *all* nodes in\n+        // order to put them into the scope map. The above functions don't do that.\n+        match pat.node {\n+            ast::PatIdent(_, ref path1, ref sub_pat_opt) => {\n+\n+                // Check if this is a binding. If so we need to put it on the\n+                // scope stack and maybe introduce an artificial scope\n+                if pat_util::pat_is_binding(def_map, &*pat) {\n+\n+                    let name = path1.node.name;\n+\n+                    // LLVM does not properly generate 'DW_AT_start_scope' fields\n+                    // for variable DIEs. For this reason we have to introduce\n+                    // an artificial scope at bindings whenever a variable with\n+                    // the same name is declared in *any* parent scope.\n+                    //\n+                    // Otherwise the following error occurs:\n+                    //\n+                    // let x = 10;\n+                    //\n+                    // do_something(); // 'gdb print x' correctly prints 10\n+                    //\n+                    // {\n+                    //     do_something(); // 'gdb print x' prints 0, because it\n+                    //                     // already reads the uninitialized 'x'\n+                    //                     // from the next line...\n+                    //     let x = 100;\n+                    //     do_something(); // 'gdb print x' correctly prints 100\n+                    // }\n+\n+                    // Is there already a binding with that name?\n+                    // N.B.: this comparison must be UNhygienic... because\n+                    // gdb knows nothing about the context, so any two\n+                    // variables with the same name will cause the problem.\n+                    let need_new_scope = scope_stack\n+                        .iter()\n+                        .any(|entry| entry.name == Some(name));\n+\n+                    if need_new_scope {\n+                        // Create a new lexical scope and push it onto the stack\n+                        let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n+                        let file_metadata = file_metadata(cx, &loc.file.name);\n+                        let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+                        let scope_metadata = unsafe {\n+                            llvm::LLVMDIBuilderCreateLexicalBlock(\n+                                DIB(cx),\n+                                parent_scope,\n+                                file_metadata,\n+                                loc.line as c_uint,\n+                                loc.col.to_usize() as c_uint)\n+                        };\n+\n+                        scope_stack.push(ScopeStackEntry {\n+                            scope_metadata: scope_metadata,\n+                            name: Some(name)\n+                        });\n+\n+                    } else {\n+                        // Push a new entry anyway so the name can be found\n+                        let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n+                        scope_stack.push(ScopeStackEntry {\n+                            scope_metadata: prev_metadata,\n+                            name: Some(name)\n+                        });\n+                    }\n+                }\n+\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+                if let Some(ref sub_pat) = *sub_pat_opt {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::PatWild(_) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            }\n+\n+            ast::PatEnum(_, ref sub_pats_opt) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+                if let Some(ref sub_pats) = *sub_pats_opt {\n+                    for p in sub_pats {\n+                        walk_pattern(cx, &**p, scope_stack, scope_map);\n+                    }\n+                }\n+            }\n+\n+            ast::PatQPath(..) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            }\n+\n+            ast::PatStruct(_, ref field_pats, _) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+                for &codemap::Spanned {\n+                    node: ast::FieldPat { pat: ref sub_pat, .. },\n+                    ..\n+                } in field_pats.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::PatTup(ref sub_pats) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+                for sub_pat in sub_pats {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat, _) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+\n+            ast::PatLit(ref exp) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+\n+            ast::PatRange(ref exp1, ref exp2) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+                walk_expr(cx, &**exp1, scope_stack, scope_map);\n+                walk_expr(cx, &**exp2, scope_stack, scope_map);\n+            }\n+\n+            ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+                for sub_pat in front_sub_pats {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                }\n+\n+                if let Some(ref sub_pat) = *middle_sub_pats {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                }\n+\n+                for sub_pat in back_sub_pats {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::PatMac(_) => {\n+                cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n+                                              Found unexpanded macro.\");\n+            }\n+        }\n+    }\n+\n+    fn walk_expr(cx: &CrateContext,\n+                 exp: &ast::Expr,\n+                 scope_stack: &mut Vec<ScopeStackEntry> ,\n+                 scope_map: &mut NodeMap<DIScope>) {\n+\n+        scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n+\n+        match exp.node {\n+            ast::ExprLit(_)   |\n+            ast::ExprBreak(_) |\n+            ast::ExprAgain(_) |\n+            ast::ExprPath(..) => {}\n+\n+            ast::ExprCast(ref sub_exp, _)     |\n+            ast::ExprAddrOf(_, ref sub_exp)  |\n+            ast::ExprField(ref sub_exp, _) |\n+            ast::ExprTupField(ref sub_exp, _) |\n+            ast::ExprParen(ref sub_exp) =>\n+                walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+\n+            ast::ExprBox(ref place, ref sub_expr) => {\n+                place.as_ref().map(\n+                    |e| walk_expr(cx, &**e, scope_stack, scope_map));\n+                walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n+            }\n+\n+            ast::ExprRet(ref exp_opt) => match *exp_opt {\n+                Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+                None => ()\n+            },\n+\n+            ast::ExprUnary(_, ref sub_exp) => {\n+                walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n+            }\n+\n+            ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+            ast::ExprIndex(ref lhs, ref rhs) |\n+            ast::ExprBinary(_, ref lhs, ref rhs)    => {\n+                walk_expr(cx, &**lhs, scope_stack, scope_map);\n+                walk_expr(cx, &**rhs, scope_stack, scope_map);\n+            }\n+\n+            ast::ExprRange(ref start, ref end) => {\n+                start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+                end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            }\n+\n+            ast::ExprVec(ref init_expressions) |\n+            ast::ExprTup(ref init_expressions) => {\n+                for ie in init_expressions {\n+                    walk_expr(cx, &**ie, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::ExprAssign(ref sub_exp1, ref sub_exp2) |\n+            ast::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n+                walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n+                walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n+            }\n+\n+            ast::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n+                walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+\n+                with_new_scope(cx,\n+                               then_block.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n+                    walk_block(cx, &**then_block, scope_stack, scope_map);\n+                });\n+\n+                match *opt_else_exp {\n+                    Some(ref else_exp) =>\n+                        walk_expr(cx, &**else_exp, scope_stack, scope_map),\n+                    _ => ()\n+                }\n+            }\n+\n+            ast::ExprIfLet(..) => {\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                              Found unexpanded if-let.\");\n+            }\n+\n+            ast::ExprWhile(ref cond_exp, ref loop_body, _) => {\n+                walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+\n+                with_new_scope(cx,\n+                               loop_body.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n+                    walk_block(cx, &**loop_body, scope_stack, scope_map);\n+                })\n+            }\n+\n+            ast::ExprWhileLet(..) => {\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                              Found unexpanded while-let.\");\n+            }\n+\n+            ast::ExprForLoop(..) => {\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                              Found unexpanded for loop.\");\n+            }\n+\n+            ast::ExprMac(_) => {\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                              Found unexpanded macro.\");\n+            }\n+\n+            ast::ExprLoop(ref block, _) |\n+            ast::ExprBlock(ref block)   => {\n+                with_new_scope(cx,\n+                               block.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n+                    walk_block(cx, &**block, scope_stack, scope_map);\n+                })\n+            }\n+\n+            ast::ExprClosure(_, ref decl, ref block) => {\n+                with_new_scope(cx,\n+                               block.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n+                    for &ast::Arg { pat: ref pattern, .. } in &decl.inputs {\n+                        walk_pattern(cx, &**pattern, scope_stack, scope_map);\n+                    }\n+\n+                    walk_block(cx, &**block, scope_stack, scope_map);\n+                })\n+            }\n+\n+            ast::ExprCall(ref fn_exp, ref args) => {\n+                walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n+\n+                for arg_exp in args {\n+                    walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::ExprMethodCall(_, _, ref args) => {\n+                for arg_exp in args {\n+                    walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::ExprMatch(ref discriminant_exp, ref arms, _) => {\n+                walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n+\n+                // For each arm we have to first walk the pattern as these might\n+                // introduce new artificial scopes. It should be sufficient to\n+                // walk only one pattern per arm, as they all must contain the\n+                // same binding names.\n+\n+                for arm_ref in arms {\n+                    let arm_span = arm_ref.pats[0].span;\n+\n+                    with_new_scope(cx,\n+                                   arm_span,\n+                                   scope_stack,\n+                                   scope_map,\n+                                   |cx, scope_stack, scope_map| {\n+                        for pat in &arm_ref.pats {\n+                            walk_pattern(cx, &**pat, scope_stack, scope_map);\n+                        }\n+\n+                        if let Some(ref guard_exp) = arm_ref.guard {\n+                            walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n+                        }\n+\n+                        walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n+                    })\n+                }\n+            }\n+\n+            ast::ExprStruct(_, ref fields, ref base_exp) => {\n+                for &ast::Field { expr: ref exp, .. } in fields {\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n+                }\n+\n+                match *base_exp {\n+                    Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n+                    None => ()\n+                }\n+            }\n+\n+            ast::ExprInlineAsm(ast::InlineAsm { ref inputs,\n+                                                ref outputs,\n+                                                .. }) => {\n+                // inputs, outputs: Vec<(String, P<Expr>)>\n+                for &(_, ref exp) in inputs {\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n+                }\n+\n+                for &(_, ref exp, _) in outputs {\n+                    walk_expr(cx, &**exp, scope_stack, scope_map);\n+                }\n+            }\n+        }\n+    }\n+}"}]}