{"sha": "395256a5dd74ccef046083d6e025a6d046379040", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NTI1NmE1ZGQ3NGNjZWYwNDYwODNkNmUwMjVhNmQwNDYzNzkwNDA=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-15T23:44:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-15T23:44:23Z"}, "message": "Merge pull request #3 from rust-lang/master\n\nupdate from origin 2020-06-15", "tree": {"sha": "b5cfdca90f9475d68f44b52f0df8b8d417733287", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5cfdca90f9475d68f44b52f0df8b8d417733287"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/395256a5dd74ccef046083d6e025a6d046379040", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe6AfXCRBK7hj4Ov3rIwAAdHIIAF4qEQcyqYFEQSGSrQp8P8S5\nr44j5alVsNq3q1dMMSw+CfKj+tHHTbP6HIzmbp+16FxDMN60CqE9Fzo5N5lR55Ss\nQm0xYJBl2THcqfwShDALmhJ4S2MdkR2rHCP1b1oW/UksK/X5PatXBgJ0YSfxOJCU\ns+wnYGnONNNIdcKzwhIwbvGJsxHkh8QT0u+cgfVRM4OhvzN4s0oIykmTtHmxseIn\nisMXjfKEc9eTz+Vmd5+k+KYpz81qSKlQPv01oeKZ7Lda7mxIcs/gFaGQ0ofCqmnU\n9+qYYIvUs+WiKiSawx6qsP5Q972tS6H0za5qTF1wWRVzQltTejKt7BCh36wr71s=\n=+AvP\n-----END PGP SIGNATURE-----\n", "payload": "tree b5cfdca90f9475d68f44b52f0df8b8d417733287\nparent d139a720a2c0ad7066c43edad6ec6c2aa9613740\nparent f315c35a77e40bd11ce81fedc0556be0f410bbf4\nauthor Rich Kadel <richkadel@google.com> 1592264663 -0700\ncommitter GitHub <noreply@github.com> 1592264663 -0700\n\nMerge pull request #3 from rust-lang/master\n\nupdate from origin 2020-06-15"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/395256a5dd74ccef046083d6e025a6d046379040", "html_url": "https://github.com/rust-lang/rust/commit/395256a5dd74ccef046083d6e025a6d046379040", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/395256a5dd74ccef046083d6e025a6d046379040/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d139a720a2c0ad7066c43edad6ec6c2aa9613740", "url": "https://api.github.com/repos/rust-lang/rust/commits/d139a720a2c0ad7066c43edad6ec6c2aa9613740", "html_url": "https://github.com/rust-lang/rust/commit/d139a720a2c0ad7066c43edad6ec6c2aa9613740"}, {"sha": "f315c35a77e40bd11ce81fedc0556be0f410bbf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f315c35a77e40bd11ce81fedc0556be0f410bbf4", "html_url": "https://github.com/rust-lang/rust/commit/f315c35a77e40bd11ce81fedc0556be0f410bbf4"}], "stats": {"total": 21160, "additions": 15725, "deletions": 5435}, "files": [{"sha": "bf3c22744f1650c1a8aa2ef06dee11e2be7a8652", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -102,9 +102,6 @@ jobs:\n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install MSYS2 packages\n-        run: src/ci/scripts/install-msys2-packages.sh\n-        if: success() && !env.SKIP_JOB\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n         if: success() && !env.SKIP_JOB\n@@ -212,9 +209,6 @@ jobs:\n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install MSYS2 packages\n-        run: src/ci/scripts/install-msys2-packages.sh\n-        if: success() && !env.SKIP_JOB\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n         if: success() && !env.SKIP_JOB\n@@ -434,11 +428,6 @@ jobs:\n               NO_DEBUG_ASSERTIONS: 1\n               NO_LLVM_ASSERTIONS: 1\n             os: windows-latest-xl\n-          - name: x86_64-msvc-aux\n-            env:\n-              RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc\"\n-            os: windows-latest-xl\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n@@ -564,9 +553,6 @@ jobs:\n       - name: install MSYS2\n         run: src/ci/scripts/install-msys2.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install MSYS2 packages\n-        run: src/ci/scripts/install-msys2-packages.sh\n-        if: success() && !env.SKIP_JOB\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n         if: success() && !env.SKIP_JOB"}, {"sha": "009767934d447c0853ceacf5d089f0ac3e7ef6a9", "filename": "Cargo.lock", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -282,7 +282,7 @@ checksum = \"716960a18f978640f25101b5cbf1c6f6b0d3192fab36a2d98ca96f0ecbe41010\"\n \n [[package]]\n name = \"cargo\"\n-version = \"0.46.0\"\n+version = \"0.47.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -1434,9 +1434,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.13\"\n+version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"91780f809e750b0a89f5544be56617ff6b1227ee485bcb06ebe10cdf89bd3b71\"\n+checksum = \"b9586eedd4ce6b3c498bc3b4dd92fc9f11166aa908a914071953768066c67909\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -1848,9 +1848,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.12.5+1.0.0\"\n+version = \"0.12.7+1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3eadeec65514971355bf7134967a543f71372f35b53ac6c7143e7bd157f07535\"\n+checksum = \"bcd07968649bcb7b9351ecfde53ca4d27673cccfdf57c84255ec18710f3153e0\"\n dependencies = [\n  \"cc\",\n  \"libc\","}, {"sha": "d995554913f8429927581cba17291d5ac9c02ef1", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -69,7 +69,7 @@\n # the same format as above, but since these targets are experimental, they are\n # not built by default and the experimental Rust compilation targets that depend\n # on them will not work unless the user opts in to building them.\n-#experimental-targets = \"\"\n+#experimental-targets = \"AVR\"\n \n # Cap the number of parallel linker invocations when compiling LLVM.\n # This can be useful when building LLVM with debug info, which significantly"}, {"sha": "ea5300bdfc04cbf26add156fe37a0793aef19198", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -52,6 +52,8 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// it's been assembled.\n     type Output: Clone;\n \n+    /// Whether this step is run by default as part of its respective phase.\n+    /// `true` here can still be overwritten by `should_run` calling `default_condition`.\n     const DEFAULT: bool = false;\n \n     /// If true, then this rule should be skipped if --target was specified, but --host was not\n@@ -371,7 +373,6 @@ impl<'a> Builder<'a> {\n                 test::UiFullDeps,\n                 test::Rustdoc,\n                 test::Pretty,\n-                test::RunPassValgrindPretty,\n                 test::Crate,\n                 test::CrateLibrustc,\n                 test::CrateRustdoc,"}, {"sha": "c09b73b042013ca77f3105bda1528fe40cc71a37", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -983,7 +983,13 @@ pub fn stream_cargo(\n     for line in stdout.lines() {\n         let line = t!(line);\n         match serde_json::from_str::<CargoMessage<'_>>(&line) {\n-            Ok(msg) => cb(msg),\n+            Ok(msg) => {\n+                if builder.config.json_output {\n+                    // Forward JSON to stdout.\n+                    println!(\"{}\", line);\n+                }\n+                cb(msg)\n+            }\n             // If this was informational, just print it out and continue\n             Err(_) => println!(\"{}\", line),\n         }"}, {"sha": "a752d8045f7b4c8f0472030363a2d633afb008f7", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -619,19 +619,21 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"natvis/libcore.natvis\");\n             cp_debugger_script(\"natvis/libstd.natvis\");\n         } else {\n-            cp_debugger_script(\"debugger_pretty_printers_common.py\");\n+            cp_debugger_script(\"rust_types.py\");\n \n             // gdb debugger scripts\n             builder.install(&builder.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"), 0o755);\n             builder.install(&builder.src.join(\"src/etc/rust-gdbgui\"), &sysroot.join(\"bin\"), 0o755);\n \n             cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n-            cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n+            cp_debugger_script(\"gdb_lookup.py\");\n+            cp_debugger_script(\"gdb_providers.py\");\n \n             // lldb debugger scripts\n             builder.install(&builder.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"), 0o755);\n \n-            cp_debugger_script(\"lldb_rust_formatters.py\");\n+            cp_debugger_script(\"lldb_lookup.py\");\n+            cp_debugger_script(\"lldb_providers.py\");\n         }\n     }\n }"}, {"sha": "12a1734e21c7e165eea70f8ff3742cac2fe55889", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -6,12 +6,6 @@ Q := @\n BOOTSTRAP_ARGS :=\n endif\n \n-ifdef EXCLUDE_CARGO\n-AUX_ARGS :=\n-else\n-AUX_ARGS := src/tools/cargo src/tools/cargotest\n-endif\n-\n BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n@@ -48,8 +42,8 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/test/run-pass-valgrind/pretty \\\n-\t\t$(AUX_ARGS) \\\n+\t\tsrc/tools/cargo \\\n+\t\tsrc/tools/cargotest \\\n \t\t$(BOOTSTRAP_ARGS)\n check-bootstrap:\n \t$(Q)$(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap_test.py"}, {"sha": "252a6316e574b99cdf440b6b90d7ee2b155daa58", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -144,7 +144,7 @@ impl Step for Llvm {\n \n         let llvm_exp_targets = match builder.config.llvm_experimental_targets {\n             Some(ref s) => s,\n-            None => \"\",\n+            None => \"AVR\",\n         };\n \n         let assertions = if builder.config.llvm_assertions { \"ON\" } else { \"OFF\" };"}, {"sha": "b8c57515658383e1bcb16c60d8f52fb1e5d4855b", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -154,6 +154,7 @@ impl Step for Cargotest {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n         builder.ensure(compile::Rustc { compiler, target: compiler.host });\n+        let cargo = builder.ensure(tool::Cargo { compiler, target: compiler.host });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n         // is currently to minimize the length of path on Windows where we otherwise\n@@ -165,7 +166,7 @@ impl Step for Cargotest {\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n         try_run(\n             builder,\n-            cmd.arg(&builder.initial_cargo)\n+            cmd.arg(&cargo)\n                 .arg(&out_dir)\n                 .env(\"RUSTC\", builder.rustc(compiler))\n                 .env(\"RUSTDOC\", builder.rustdoc(compiler)),\n@@ -553,7 +554,7 @@ impl Step for Clippy {\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-        try_run(builder, &mut cargo.into());\n+        builder.run(&mut cargo.into());\n     }\n }\n \n@@ -929,13 +930,6 @@ host_test!(UiFullDeps { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-ful\n host_test!(Rustdoc { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" });\n \n host_test!(Pretty { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" });\n-test!(RunPassValgrindPretty {\n-    path: \"src/test/run-pass-valgrind/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-pass-valgrind\",\n-    default: false,\n-    host: true\n-});\n \n default_test!(RunMake { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" });\n "}, {"sha": "9c95de0a81eae7ff53db0368a960e0eb9f9a6041", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -595,6 +595,7 @@ macro_rules! tool_extended {\n        $toolstate:ident,\n        $path:expr,\n        $tool_name:expr,\n+       stable = $stable:expr,\n        $extra_deps:block;)+) => {\n         $(\n             #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n@@ -606,17 +607,22 @@ macro_rules! tool_extended {\n \n         impl Step for $name {\n             type Output = Option<PathBuf>;\n-            const DEFAULT: bool = true;\n+            const DEFAULT: bool = true; // Overwritten below\n             const ONLY_HOSTS: bool = true;\n \n             fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let builder = run.builder;\n                 run.path($path).default_condition(\n                     builder.config.extended\n-                        && builder.config.tools.as_ref().map_or(true, |tools| {\n-                            tools.iter().any(|tool| match tool.as_ref() {\n-                                \"clippy\" => $tool_name == \"clippy-driver\",\n-                                x => $tool_name == x,\n+                        && builder.config.tools.as_ref().map_or(\n+                            // By default, on nightly/dev enable all tools, else only\n+                            // build stable tools.\n+                            $stable || builder.build.unstable_features(),\n+                            // If `tools` is set, search list for this tool.\n+                            |tools| {\n+                                tools.iter().any(|tool| match tool.as_ref() {\n+                                    \"clippy\" => $tool_name == \"clippy-driver\",\n+                                    x => $tool_name == x,\n                             })\n                         }),\n                 )\n@@ -652,20 +658,20 @@ macro_rules! tool_extended {\n // Note: tools need to be also added to `Builder::get_step_descriptions` in `build.rs`\n // to make `./x.py build <tool>` work.\n tool_extended!((self, builder),\n-    Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n-    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {};\n-    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {};\n-    Miri, miri, \"src/tools/miri\", \"miri\", {};\n-    CargoMiri, miri, \"src/tools/miri/cargo-miri\", \"cargo-miri\", {};\n-    Rls, rls, \"src/tools/rls\", \"rls\", {\n+    Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", stable=true, {};\n+    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", stable=true, {};\n+    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", stable=true, {};\n+    Miri, miri, \"src/tools/miri\", \"miri\", stable=false, {};\n+    CargoMiri, miri, \"src/tools/miri/cargo-miri\", \"cargo-miri\", stable=false, {};\n+    Rls, rls, \"src/tools/rls\", \"rls\", stable=true, {\n         builder.ensure(Clippy {\n             compiler: self.compiler,\n             target: self.target,\n             extra_features: Vec::new(),\n         });\n         self.extra_features.push(\"clippy\".to_owned());\n     };\n-    Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n+    Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", stable=true, {};\n );\n \n impl<'a> Builder<'a> {"}, {"sha": "3de27bc54c5c0b08b113b0587df78c5c851590da", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -142,10 +142,6 @@ jobs:\n         # FIXME(#59637)\n         NO_DEBUG_ASSERTIONS: 1\n         NO_LLVM_ASSERTIONS: 1\n-      # MSVC aux tests\n-      x86_64-msvc-aux:\n-        RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-        INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n       x86_64-msvc-cargo:\n         SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n         INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-lld"}, {"sha": "e43116c06b6b7f3718abd2c1348617f0f59c367c", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -82,10 +82,6 @@ steps:\n   displayName: Install msys2\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-- bash: src/ci/scripts/install-msys2-packages.sh\n-  displayName: Install msys2 packages\n-  condition: and(succeeded(), not(variables.SKIP_JOB))\n-\n - bash: src/ci/scripts/install-mingw.sh\n   displayName: Install MinGW\n   condition: and(succeeded(), not(variables.SKIP_JOB))"}, {"sha": "1ae412340cb114e09c675b2ad92521d108a0526e", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -3,7 +3,7 @@\n #\n # Versions of the toolchain components are configurable in `musl-cross-make/Makefile` and\n # musl unlike GLIBC is forward compatible so upgrading it shouldn't break old distributions.\n-# Right now we have: Binutils 2.27, GCC 6.4.0, musl 1.1.22.\n+# Right now we have: Binutils 2.31.1, GCC 9.2.0, musl 1.1.24.\n set -ex\n \n hide_output() {\n@@ -33,11 +33,13 @@ shift\n # Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-git clone https://github.com/richfelker/musl-cross-make -b v0.9.8\n+git clone https://github.com/richfelker/musl-cross-make # -b v0.9.9\n cd musl-cross-make\n+# A few commits ahead of v0.9.9 to include the cowpatch fix:\n+git checkout a54eb56f33f255dfca60be045f12a5cfaf5a72a9\n \n-hide_output make -j$(nproc) TARGET=$TARGET\n-hide_output make install TARGET=$TARGET OUTPUT=$OUTPUT\n+hide_output make -j$(nproc) TARGET=$TARGET MUSL_VER=1.1.24\n+hide_output make install TARGET=$TARGET MUSL_VER=1.1.24 OUTPUT=$OUTPUT\n \n cd -\n "}, {"sha": "58393a5719a10d4854eaf7ce5aa151c3608df13a", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -24,7 +24,7 @@ shift\n # Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-MUSL=musl-1.1.22\n+MUSL=musl-1.1.24\n \n # may have been downloaded in a previous run\n if [ ! -d $MUSL ]; then"}, {"sha": "8232539edda7743d7a929f30830cbe0abee9d1f2", "filename": "src/ci/docker/wasm32/Dockerfile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -27,6 +27,9 @@ ENV PATH=$PATH:/emsdk-portable\n ENV PATH=$PATH:/emsdk-portable/upstream/emscripten/\n ENV PATH=$PATH:/emsdk-portable/node/12.9.1_64bit/bin/\n ENV BINARYEN_ROOT=/emsdk-portable/upstream/\n+ENV EMSDK=/emsdk-portable\n+ENV EM_CONFIG=/emsdk-portable/.emscripten\n+ENV EM_CACHE=/emsdk-portable/upstream/emscripten/cache\n \n ENV TARGETS=wasm32-unknown-emscripten\n "}, {"sha": "a052d0879a3dbfe1c6aecf1f9077e2dcbfe1ea1a", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -147,10 +147,6 @@ x--expand-yaml-anchors--remove:\n         run: src/ci/scripts/install-msys2.sh\n         <<: *step\n \n-      - name: install MSYS2 packages\n-        run: src/ci/scripts/install-msys2-packages.sh\n-        <<: *step\n-\n       - name: install MinGW\n         run: src/ci/scripts/install-mingw.sh\n         <<: *step\n@@ -496,12 +492,6 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n             <<: *job-windows-xl\n \n-          - name: x86_64-msvc-aux\n-            env:\n-              RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n-            <<: *job-windows-xl\n-\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py test src/tools/cargotest src/tools/cargo"}, {"sha": "ff7479c05d04e5d7821b220646862ea03290bbcf", "filename": "src/ci/scripts/install-msys2-packages.sh", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,27 +0,0 @@\n-#!/bin/bash\n-\n-set -euo pipefail\n-IFS=$'\\n\\t'\n-\n-source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n-\n-if isWindows; then\n-    pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar \\\n-        binutils\n-\n-    # Detect the native Python version installed on the agent. On GitHub\n-    # Actions, the C:\\hostedtoolcache\\windows\\Python directory contains a\n-    # subdirectory for each installed Python version.\n-    #\n-    # The -V flag of the sort command sorts the input by version number.\n-    native_python_version=\"$(ls /c/hostedtoolcache/windows/Python | sort -Vr | head -n 1)\"\n-\n-    # Make sure we use the native python interpreter instead of some msys equivalent\n-    # one way or another. The msys interpreters seem to have weird path conversions\n-    # baked in which break LLVM's build system one way or another, so let's use the\n-    # native version which keeps everything as native as possible.\n-    python_home=\"/c/hostedtoolcache/windows/Python/${native_python_version}/x64\"\n-    cp \"${python_home}/python.exe\" \"${python_home}/python3.exe\"\n-    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\${native_python_version}\\\\x64\"\n-    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\${native_python_version}\\\\x64\\\\Scripts\"\n-fi"}, {"sha": "3a0c965a67710ba45d3e66b5553b50ab83df5c2a", "filename": "src/ci/scripts/install-msys2.sh", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fscripts%2Finstall-msys2.sh", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fci%2Fscripts%2Finstall-msys2.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2.sh?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,28 +1,33 @@\n #!/bin/bash\n # Download and install MSYS2, needed primarily for the test suite (run-make) but\n # also used by the MinGW toolchain for assembling things.\n-#\n-# FIXME: we should probe the default azure image and see if we can use the MSYS2\n-# toolchain there. (if there's even one there). For now though this gets the job\n-# done.\n \n set -euo pipefail\n IFS=$'\\n\\t'\n \n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n if isWindows; then\n-    # Pre-followed the api/v2 URL to the CDN since the API can be a bit flakey\n-    curl -sSL https://packages.chocolatey.org/msys2.20190524.0.0.20191030.nupkg > \\\n-        msys2.nupkg\n-    curl -sSL https://packages.chocolatey.org/chocolatey-core.extension.1.3.5.1.nupkg > \\\n-        chocolatey-core.extension.nupkg\n-    choco install -s . msys2 \\\n-        --params=\"/InstallDir:$(ciCheckoutPath)/msys2 /NoPath\" -y --no-progress\n-    rm msys2.nupkg chocolatey-core.extension.nupkg\n-    mkdir -p \"$(ciCheckoutPath)/msys2/home/${USERNAME}\"\n-    ciCommandAddPath \"$(ciCheckoutPath)/msys2/usr/bin\"\n+    msys2Path=\"c:/msys64\"\n+    mkdir -p \"${msys2Path}/home/${USERNAME}\"\n+    ciCommandAddPath \"${msys2Path}/usr/bin\"\n \n     echo \"switching shell to use our own bash\"\n-    ciCommandSetEnv CI_OVERRIDE_SHELL \"$(ciCheckoutPath)/msys2/usr/bin/bash.exe\"\n+    ciCommandSetEnv CI_OVERRIDE_SHELL \"${msys2Path}/usr/bin/bash.exe\"\n+\n+    # Detect the native Python version installed on the agent. On GitHub\n+    # Actions, the C:\\hostedtoolcache\\windows\\Python directory contains a\n+    # subdirectory for each installed Python version.\n+    #\n+    # The -V flag of the sort command sorts the input by version number.\n+    native_python_version=\"$(ls /c/hostedtoolcache/windows/Python | sort -Vr | head -n 1)\"\n+\n+    # Make sure we use the native python interpreter instead of some msys equivalent\n+    # one way or another. The msys interpreters seem to have weird path conversions\n+    # baked in which break LLVM's build system one way or another, so let's use the\n+    # native version which keeps everything as native as possible.\n+    python_home=\"/c/hostedtoolcache/windows/Python/${native_python_version}/x64\"\n+    cp \"${python_home}/python.exe\" \"${python_home}/python3.exe\"\n+    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\${native_python_version}\\\\x64\"\n+    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\${native_python_version}\\\\x64\\\\Scripts\"\n fi"}, {"sha": "18010bebcf0e773315655165328e48cd1be793d9", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -416,7 +416,7 @@ without including it in your main documentation. For example, you could write th\n `lib.rs` to test your README as part of your doctests:\n \n ```rust,ignore\n-#![feature(extern_doc)]\n+#![feature(external_doc)]\n \n #[doc(include=\"../README.md\")]\n #[cfg(doctest)]"}, {"sha": "fbb40f1d2f3d4b07e8ea1e476f33cfa71af87c54", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -201,7 +201,7 @@ fn mul(a: u64, b: u64) -> u128 {\n         );\n     }\n \n-    (hi as u128) << 64 + lo as u128\n+    ((hi as u128) << 64) + lo as u128\n }\n ```\n \n@@ -382,7 +382,9 @@ The macro will initially be supported only on ARM, AArch64, x86, x86-64 and RISC\n \n The assembler template uses the same syntax as [format strings][format-syntax] (i.e. placeholders are specified by curly braces). The corresponding arguments are accessed in order, by index, or by name. However, implicit named arguments (introduced by [RFC #2795][rfc-2795]) are not supported.\n \n-As with format strings, named arguments must appear after positional arguments. Explicit register operands must appear at the end of the operand list, after any named arguments if any. Explicit register operands cannot be used by placeholders in the template string. All other operands must appear at least once in the template string, otherwise a compiler error is generated.\n+As with format strings, named arguments must appear after positional arguments. Explicit register operands must appear at the end of the operand list, after named arguments if any.\n+\n+Explicit register operands cannot be used by placeholders in the template string. All other named and positional operands must appear at least once in the template string, otherwise a compiler error is generated.\n \n The exact assembly code syntax is target-specific and opaque to the compiler except for the way operands are substituted into the template string to form the code passed to the assembler.\n "}, {"sha": "b3f8f50636bee754b81d0280b505ece3bb9f1a51", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "removed", "additions": 0, "deletions": 401, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,401 +0,0 @@\n-\"\"\"\n-This module provides an abstraction layer over common Rust pretty printing\n-functionality needed by both GDB and LLDB.\n-\"\"\"\n-\n-import re\n-\n-# Type codes that indicate the kind of type as it appears in DWARF debug\n-# information. This code alone is not sufficient to determine the Rust type.\n-# For example structs, tuples, fat pointers, or enum variants will all have\n-# DWARF_TYPE_CODE_STRUCT.\n-DWARF_TYPE_CODE_STRUCT = 1\n-DWARF_TYPE_CODE_UNION  = 2\n-DWARF_TYPE_CODE_PTR    = 3\n-DWARF_TYPE_CODE_ARRAY  = 4\n-DWARF_TYPE_CODE_ENUM   = 5\n-\n-# These constants specify the most specific kind of type that could be\n-# determined for a given value.\n-TYPE_KIND_UNKNOWN           = -1\n-TYPE_KIND_EMPTY             = 0\n-TYPE_KIND_SLICE             = 1\n-TYPE_KIND_REGULAR_STRUCT    = 2\n-TYPE_KIND_TUPLE             = 3\n-TYPE_KIND_TUPLE_STRUCT      = 4\n-TYPE_KIND_CSTYLE_VARIANT    = 5\n-TYPE_KIND_TUPLE_VARIANT     = 6\n-TYPE_KIND_STRUCT_VARIANT    = 7\n-TYPE_KIND_STR_SLICE         = 8\n-TYPE_KIND_STD_VEC           = 9\n-TYPE_KIND_STD_STRING        = 10\n-TYPE_KIND_REGULAR_ENUM      = 11\n-TYPE_KIND_COMPRESSED_ENUM   = 12\n-TYPE_KIND_SINGLETON_ENUM    = 13\n-TYPE_KIND_CSTYLE_ENUM       = 14\n-TYPE_KIND_PTR               = 15\n-TYPE_KIND_FIXED_SIZE_VEC    = 16\n-TYPE_KIND_REGULAR_UNION     = 17\n-TYPE_KIND_OS_STRING         = 18\n-TYPE_KIND_STD_VECDEQUE      = 19\n-TYPE_KIND_STD_BTREESET      = 20\n-TYPE_KIND_STD_BTREEMAP      = 21\n-\n-ENCODED_ENUM_PREFIX = \"RUST$ENCODED$ENUM$\"\n-ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\"\n-\n-# Slice related constants\n-SLICE_FIELD_NAME_DATA_PTR = \"data_ptr\"\n-SLICE_FIELD_NAME_LENGTH = \"length\"\n-SLICE_FIELD_NAMES = [SLICE_FIELD_NAME_DATA_PTR, SLICE_FIELD_NAME_LENGTH]\n-\n-# std::Vec<> related constants\n-STD_VEC_FIELD_NAME_LENGTH = \"len\"\n-STD_VEC_FIELD_NAME_BUF = \"buf\"\n-STD_VEC_FIELD_NAMES = [STD_VEC_FIELD_NAME_BUF,\n-                       STD_VEC_FIELD_NAME_LENGTH]\n-\n-# std::collections::VecDeque<> related constants\n-STD_VECDEQUE_FIELD_NAME_TAIL = \"tail\"\n-STD_VECDEQUE_FIELD_NAME_HEAD = \"head\"\n-STD_VECDEQUE_FIELD_NAME_BUF = \"buf\"\n-STD_VECDEQUE_FIELD_NAMES = [STD_VECDEQUE_FIELD_NAME_TAIL,\n-                            STD_VECDEQUE_FIELD_NAME_HEAD,\n-                            STD_VECDEQUE_FIELD_NAME_BUF]\n-\n-# std::collections::BTreeSet<> related constants\n-STD_BTREESET_FIELD_NAMES = [\"map\"]\n-\n-# std::collections::BTreeMap<> related constants\n-STD_BTREEMAP_FIELD_NAMES = [\"root\", \"length\"]\n-\n-# std::String related constants\n-STD_STRING_FIELD_NAMES = [\"vec\"]\n-\n-# std::ffi::OsString related constants\n-OS_STRING_FIELD_NAMES = [\"inner\"]\n-\n-\n-class Type(object):\n-    \"\"\"\n-    This class provides a common interface for type-oriented operations.\n-    Sub-classes are supposed to wrap a debugger-specific type-object and\n-    provide implementations for the abstract methods in this class.\n-    \"\"\"\n-\n-    def __init__(self):\n-        self.__type_kind = None\n-\n-    def get_unqualified_type_name(self):\n-        \"\"\"\n-        Implementations of this method should return the unqualified name of the\n-        type-object they are wrapping. Some examples:\n-\n-        'int' -> 'int'\n-        'std::vec::Vec<std::string::String>' -> 'Vec<std::string::String>'\n-        '&std::option::Option<std::string::String>' -> '&std::option::Option<std::string::String>'\n-\n-        As you can see, type arguments stay fully qualified.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_dwarf_type_kind(self):\n-        \"\"\"\n-        Implementations of this method should return the correct\n-        DWARF_TYPE_CODE_* value for the wrapped type-object.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_fields(self):\n-        \"\"\"\n-        Implementations of this method should return a list of field-objects of\n-        this type. For Rust-enums (i.e. with DWARF_TYPE_CODE_UNION) these field-\n-        objects represent the variants of the enum. Field-objects must have a\n-        `name` attribute that gives their name as specified in DWARF.\n-        \"\"\"\n-        assert ((self.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT) or\n-                (self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION))\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_wrapped_value(self):\n-        \"\"\"\n-        Returns the debugger-specific type-object wrapped by this object. This\n-        is sometimes needed for doing things like pointer-arithmetic in GDB.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_type_kind(self):\n-        \"\"\"This method returns the TYPE_KIND_* value for this type-object.\"\"\"\n-        if self.__type_kind is None:\n-            dwarf_type_code = self.get_dwarf_type_kind()\n-\n-            if dwarf_type_code == DWARF_TYPE_CODE_STRUCT:\n-                self.__type_kind = self.__classify_struct()\n-            elif dwarf_type_code == DWARF_TYPE_CODE_UNION:\n-                self.__type_kind = self.__classify_union()\n-            elif dwarf_type_code == DWARF_TYPE_CODE_PTR:\n-                self.__type_kind = TYPE_KIND_PTR\n-            elif dwarf_type_code == DWARF_TYPE_CODE_ARRAY:\n-                self.__type_kind = TYPE_KIND_FIXED_SIZE_VEC\n-            else:\n-                self.__type_kind = TYPE_KIND_UNKNOWN\n-        return self.__type_kind\n-\n-    def __classify_struct(self):\n-        assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT\n-\n-        unqualified_type_name = self.get_unqualified_type_name()\n-\n-        # STR SLICE\n-        if unqualified_type_name == \"&str\":\n-            return TYPE_KIND_STR_SLICE\n-\n-        # REGULAR SLICE\n-        if (unqualified_type_name.startswith((\"&[\", \"&mut [\")) and\n-            unqualified_type_name.endswith(\"]\") and\n-            self.__conforms_to_field_layout(SLICE_FIELD_NAMES)):\n-            return TYPE_KIND_SLICE\n-\n-        fields = self.get_fields()\n-        field_count = len(fields)\n-\n-        # EMPTY STRUCT\n-        if field_count == 0:\n-            return TYPE_KIND_EMPTY\n-\n-        # STD VEC\n-        if (unqualified_type_name.startswith(\"Vec<\") and\n-            self.__conforms_to_field_layout(STD_VEC_FIELD_NAMES)):\n-            return TYPE_KIND_STD_VEC\n-\n-        # STD COLLECTION VECDEQUE\n-        if (unqualified_type_name.startswith(\"VecDeque<\") and\n-            self.__conforms_to_field_layout(STD_VECDEQUE_FIELD_NAMES)):\n-            return TYPE_KIND_STD_VECDEQUE\n-\n-        # STD COLLECTION BTREESET\n-        if (unqualified_type_name.startswith(\"BTreeSet<\") and\n-                self.__conforms_to_field_layout(STD_BTREESET_FIELD_NAMES)):\n-            return TYPE_KIND_STD_BTREESET\n-\n-        # STD COLLECTION BTREEMAP\n-        if (unqualified_type_name.startswith(\"BTreeMap<\") and\n-                self.__conforms_to_field_layout(STD_BTREEMAP_FIELD_NAMES)):\n-            return TYPE_KIND_STD_BTREEMAP\n-\n-        # STD STRING\n-        if (unqualified_type_name.startswith(\"String\") and\n-            self.__conforms_to_field_layout(STD_STRING_FIELD_NAMES)):\n-            return TYPE_KIND_STD_STRING\n-\n-        # OS STRING\n-        if (unqualified_type_name == \"OsString\" and\n-            self.__conforms_to_field_layout(OS_STRING_FIELD_NAMES)):\n-            return TYPE_KIND_OS_STRING\n-\n-        # ENUM VARIANTS\n-        if fields[0].name == ENUM_DISR_FIELD_NAME:\n-            if field_count == 1:\n-                return TYPE_KIND_CSTYLE_VARIANT\n-            elif self.__all_fields_conform_to_tuple_field_naming(1):\n-                return TYPE_KIND_TUPLE_VARIANT\n-            else:\n-                return TYPE_KIND_STRUCT_VARIANT\n-\n-        # TUPLE\n-        if self.__all_fields_conform_to_tuple_field_naming(0):\n-            if unqualified_type_name.startswith(\"(\"):\n-                return TYPE_KIND_TUPLE\n-            else:\n-                return TYPE_KIND_TUPLE_STRUCT\n-\n-        # REGULAR STRUCT\n-        return TYPE_KIND_REGULAR_STRUCT\n-\n-    def __classify_union(self):\n-        assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n-\n-        union_members = self.get_fields()\n-        union_member_count = len(union_members)\n-        if union_member_count == 0:\n-            return TYPE_KIND_EMPTY\n-\n-        first_variant_name = union_members[0].name\n-        if first_variant_name is None:\n-            if union_member_count == 1:\n-                return TYPE_KIND_SINGLETON_ENUM\n-            else:\n-                return TYPE_KIND_REGULAR_ENUM\n-        elif first_variant_name.startswith(ENCODED_ENUM_PREFIX):\n-            assert union_member_count == 1\n-            return TYPE_KIND_COMPRESSED_ENUM\n-        else:\n-            return TYPE_KIND_REGULAR_UNION\n-\n-    def __conforms_to_field_layout(self, expected_fields):\n-        actual_fields = self.get_fields()\n-        actual_field_count = len(actual_fields)\n-\n-        if actual_field_count != len(expected_fields):\n-            return False\n-\n-        for i in range(0, actual_field_count):\n-            if actual_fields[i].name != expected_fields[i]:\n-                return False\n-\n-        return True\n-\n-    def __all_fields_conform_to_tuple_field_naming(self, start_index):\n-        fields = self.get_fields()\n-        field_count = len(fields)\n-\n-        for i in range(start_index, field_count):\n-            field_name = fields[i].name\n-            if (field_name is None) or (re.match(r\"__\\d+$\", field_name) is None):\n-                return False\n-        return True\n-\n-\n-class Value(object):\n-    \"\"\"\n-    This class provides a common interface for value-oriented operations.\n-    Sub-classes are supposed to wrap a debugger-specific value-object and\n-    provide implementations for the abstract methods in this class.\n-    \"\"\"\n-    def __init__(self, ty):\n-        self.type = ty\n-\n-    def get_child_at_index(self, index):\n-        \"\"\"Returns the value of the field, array element or variant at the given index\"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def as_integer(self):\n-        \"\"\"\n-        Try to convert the wrapped value into a Python integer. This should\n-        always succeed for values that are pointers or actual integers.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-    def get_wrapped_value(self):\n-        \"\"\"\n-        Returns the debugger-specific value-object wrapped by this object. This\n-        is sometimes needed for doing things like pointer-arithmetic in GDB.\n-        \"\"\"\n-        raise NotImplementedError(\"Override this method\")\n-\n-\n-class EncodedEnumInfo(object):\n-    \"\"\"\n-    This class provides facilities for handling enum values with compressed\n-    encoding where a non-null field in one variant doubles as the discriminant.\n-    \"\"\"\n-\n-    def __init__(self, enum_val):\n-        assert enum_val.type.get_type_kind() == TYPE_KIND_COMPRESSED_ENUM\n-        variant_name = enum_val.type.get_fields()[0].name\n-        last_separator_index = variant_name.rfind(\"$\")\n-        start_index = len(ENCODED_ENUM_PREFIX)\n-        indices_substring = variant_name[start_index:last_separator_index].split(\"$\")\n-        self.__enum_val = enum_val\n-        self.__disr_field_indices = [int(index) for index in indices_substring]\n-        self.__null_variant_name = variant_name[last_separator_index + 1:]\n-\n-    def is_null_variant(self):\n-        ty = self.__enum_val.type\n-        sole_variant_val = self.__enum_val.get_child_at_index(0)\n-        discriminant_val = sole_variant_val\n-        for disr_field_index in self.__disr_field_indices:\n-            discriminant_val = discriminant_val.get_child_at_index(disr_field_index)\n-\n-        # If the discriminant field is a fat pointer we have to consider the\n-        # first word as the true discriminant\n-        if discriminant_val.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT:\n-            discriminant_val = discriminant_val.get_child_at_index(0)\n-\n-        return discriminant_val.as_integer() == 0\n-\n-    def get_non_null_variant_val(self):\n-        return self.__enum_val.get_child_at_index(0)\n-\n-    def get_null_variant_name(self):\n-        return self.__null_variant_name\n-\n-\n-def get_discriminant_value_as_integer(enum_val):\n-    assert enum_val.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n-    # we can take any variant here because the discriminant has to be the same\n-    # for all of them.\n-    variant_val = enum_val.get_child_at_index(0)\n-    disr_val = variant_val.get_child_at_index(0)\n-    return disr_val.as_integer()\n-\n-\n-def extract_length_ptr_and_cap_from_std_vec(vec_val):\n-    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_VEC\n-    length_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_LENGTH)\n-    buf_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_BUF)\n-\n-    length = vec_val.get_child_at_index(length_field_index).as_integer()\n-    buf = vec_val.get_child_at_index(buf_field_index)\n-\n-    vec_ptr_val = buf.get_child_at_index(0)\n-    capacity = buf.get_child_at_index(1).as_integer()\n-    data_ptr = vec_ptr_val.get_child_at_index(0)\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (length, data_ptr, capacity)\n-\n-\n-def extract_tail_head_ptr_and_cap_from_std_vecdeque(vec_val):\n-    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_VECDEQUE\n-    tail_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_TAIL)\n-    head_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_HEAD)\n-    buf_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_BUF)\n-\n-    tail = vec_val.get_child_at_index(tail_field_index).as_integer()\n-    head = vec_val.get_child_at_index(head_field_index).as_integer()\n-    buf = vec_val.get_child_at_index(buf_field_index)\n-\n-    vec_ptr_val = buf.get_child_at_index(0)\n-    capacity = buf.get_child_at_index(1).as_integer()\n-    data_ptr = vec_ptr_val.get_child_at_index(0)\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (tail, head, data_ptr, capacity)\n-\n-\n-def extract_length_and_ptr_from_slice(slice_val):\n-    assert (slice_val.type.get_type_kind() == TYPE_KIND_SLICE or\n-            slice_val.type.get_type_kind() == TYPE_KIND_STR_SLICE)\n-\n-    length_field_index = SLICE_FIELD_NAMES.index(SLICE_FIELD_NAME_LENGTH)\n-    ptr_field_index = SLICE_FIELD_NAMES.index(SLICE_FIELD_NAME_DATA_PTR)\n-\n-    length = slice_val.get_child_at_index(length_field_index).as_integer()\n-    data_ptr = slice_val.get_child_at_index(ptr_field_index)\n-\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (length, data_ptr)\n-\n-\n-UNQUALIFIED_TYPE_MARKERS = frozenset([\"(\", \"[\", \"&\", \"*\"])\n-\n-\n-def extract_type_name(qualified_type_name):\n-    \"\"\"Extracts the type name from a fully qualified path\"\"\"\n-    if qualified_type_name[0] in UNQUALIFIED_TYPE_MARKERS:\n-        return qualified_type_name\n-\n-    end_of_search = qualified_type_name.find(\"<\")\n-    if end_of_search < 0:\n-        end_of_search = len(qualified_type_name)\n-\n-    index = qualified_type_name.rfind(\"::\", 0, end_of_search)\n-    if index < 0:\n-        return qualified_type_name\n-    else:\n-        return qualified_type_name[index + 2:]\n-\n-\n-try:\n-    compat_str = unicode  # Python 2\n-except NameError:\n-    compat_str = str"}, {"sha": "856b5df2de70bff896d5b89e61f9a296b1fd0a8c", "filename": "src/etc/gdb_load_rust_pretty_printers.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_load_rust_pretty_printers.py?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,3 +1,3 @@\n import gdb\n-import gdb_rust_pretty_printing\n-gdb_rust_pretty_printing.register_printers(gdb.current_objfile())\n+import gdb_lookup\n+gdb_lookup.register_printers(gdb.current_objfile())"}, {"sha": "2a46eaadad6f9a1b121b706e77d45882e4690959", "filename": "src/etc/gdb_lookup.py", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Fgdb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Fgdb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_lookup.py?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,92 @@\n+import gdb\n+import re\n+\n+from gdb_providers import *\n+from rust_types import *\n+\n+\n+rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string=True)\n+_gdb_version_matched = re.search('([0-9]+)\\\\.([0-9]+)', gdb.VERSION)\n+gdb_version = [int(num) for num in _gdb_version_matched.groups()] if _gdb_version_matched else []\n+\n+def register_printers(objfile):\n+    objfile.pretty_printers.append(lookup)\n+\n+\n+# BACKCOMPAT: rust 1.35\n+def is_hashbrown_hashmap(hash_map):\n+    return len(hash_map.type.fields()) == 1\n+\n+\n+def classify_rust_type(type):\n+    type_class = type.code\n+    if type_class == gdb.TYPE_CODE_STRUCT:\n+        return classify_struct(type.tag, type.fields())\n+    if type_class == gdb.TYPE_CODE_UNION:\n+        return classify_union(type.fields())\n+\n+    return RustType.OTHER\n+\n+\n+def check_enum_discriminant(valobj):\n+    content = valobj[valobj.type.fields()[0]]\n+    fields = content.type.fields()\n+    if len(fields) > 1:\n+        discriminant = int(content[fields[0]]) + 1\n+        if discriminant > len(fields):\n+            # invalid discriminant\n+            return False\n+    return True\n+\n+\n+def lookup(valobj):\n+    rust_type = classify_rust_type(valobj.type)\n+\n+    if rust_type == RustType.ENUM:\n+        # use enum provider only for GDB <7.12\n+        if gdb_version[0] < 7 or (gdb_version[0] == 7 and gdb_version[1] < 12):\n+            if check_enum_discriminant(valobj):\n+                return EnumProvider(valobj)\n+\n+    if rust_type == RustType.STD_STRING:\n+        return StdStringProvider(valobj)\n+    if rust_type == RustType.STD_OS_STRING:\n+        return StdOsStringProvider(valobj)\n+    if rust_type == RustType.STD_STR and not rust_enabled:\n+        return StdStrProvider(valobj)\n+\n+    if rust_type == RustType.STD_VEC:\n+        return StdVecProvider(valobj)\n+    if rust_type == RustType.STD_VEC_DEQUE:\n+        return StdVecDequeProvider(valobj)\n+    if rust_type == RustType.STD_BTREE_SET:\n+        return StdBTreeSetProvider(valobj)\n+    if rust_type == RustType.STD_BTREE_MAP:\n+        return StdBTreeMapProvider(valobj)\n+    if rust_type == RustType.STD_HASH_MAP:\n+        if is_hashbrown_hashmap(valobj):\n+            return StdHashMapProvider(valobj)\n+        else:\n+            return StdOldHashMapProvider(valobj)\n+    if rust_type == RustType.STD_HASH_SET:\n+        hash_map = valobj[\"map\"]\n+        if is_hashbrown_hashmap(hash_map):\n+            return StdHashMapProvider(hash_map, show_values=False)\n+        else:\n+            return StdOldHashMapProvider(hash_map, show_values=False)\n+\n+    if rust_type == RustType.STD_RC:\n+        return StdRcProvider(valobj)\n+    if rust_type == RustType.STD_ARC:\n+        return StdRcProvider(valobj, is_atomic=True)\n+\n+    if rust_type == RustType.STD_CELL:\n+        return StdCellProvider(valobj)\n+    if rust_type == RustType.STD_REF:\n+        return StdRefProvider(valobj)\n+    if rust_type == RustType.STD_REF_MUT:\n+        return StdRefProvider(valobj)\n+    if rust_type == RustType.STD_REF_CELL:\n+        return StdRefCellProvider(valobj)\n+\n+    return None"}, {"sha": "cec9c56a23522b3ee2dd3feb694ce6c35afa4752", "filename": "src/etc/gdb_providers.py", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,385 @@\n+from sys import version_info\n+\n+import gdb\n+from gdb import lookup_type\n+\n+if version_info[0] >= 3:\n+    xrange = range\n+\n+ZERO_FIELD = \"__0\"\n+FIRST_FIELD = \"__1\"\n+\n+\n+def unwrap_unique_or_non_null(unique_or_nonnull):\n+    # BACKCOMPAT: rust 1.32\n+    # https://github.com/rust-lang/rust/commit/7a0911528058e87d22ea305695f4047572c5e067\n+    ptr = unique_or_nonnull[\"pointer\"]\n+    return ptr if ptr.type.code == gdb.TYPE_CODE_PTR else ptr[ZERO_FIELD]\n+\n+\n+class EnumProvider:\n+    def __init__(self, valobj):\n+        content = valobj[valobj.type.fields()[0]]\n+        fields = content.type.fields()\n+        self.empty = len(fields) == 0\n+        if not self.empty:\n+            if len(fields) == 1:\n+                discriminant = 0\n+            else:\n+                discriminant = int(content[fields[0]]) + 1\n+            self.active_variant = content[fields[discriminant]]\n+            self.name = fields[discriminant].name\n+            self.full_name = \"{}::{}\".format(valobj.type.name, self.name)\n+        else:\n+            self.full_name = valobj.type.name\n+\n+    def to_string(self):\n+        return self.full_name\n+\n+    def children(self):\n+        if not self.empty:\n+            yield self.name, self.active_variant\n+\n+\n+class StdStringProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        vec = valobj[\"vec\"]\n+        self.length = int(vec[\"len\"])\n+        self.data_ptr = unwrap_unique_or_non_null(vec[\"buf\"][\"ptr\"])\n+\n+    def to_string(self):\n+        return self.data_ptr.lazy_string(encoding=\"utf-8\", length=self.length)\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"string\"\n+\n+\n+class StdOsStringProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        buf = self.valobj[\"inner\"][\"inner\"]\n+        is_windows = \"Wtf8Buf\" in buf.type.name\n+        vec = buf[ZERO_FIELD] if is_windows else buf\n+\n+        self.length = int(vec[\"len\"])\n+        self.data_ptr = unwrap_unique_or_non_null(vec[\"buf\"][\"ptr\"])\n+\n+    def to_string(self):\n+        return self.data_ptr.lazy_string(encoding=\"utf-8\", length=self.length)\n+\n+    def display_hint(self):\n+        return \"string\"\n+\n+\n+class StdStrProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        self.length = int(valobj[\"length\"])\n+        self.data_ptr = valobj[\"data_ptr\"]\n+\n+    def to_string(self):\n+        return self.data_ptr.lazy_string(encoding=\"utf-8\", length=self.length)\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"string\"\n+\n+\n+class StdVecProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        self.length = int(valobj[\"len\"])\n+        self.data_ptr = unwrap_unique_or_non_null(valobj[\"buf\"][\"ptr\"])\n+\n+    def to_string(self):\n+        return \"Vec(size={})\".format(self.length)\n+\n+    def children(self):\n+        saw_inaccessible = False\n+        for index in xrange(self.length):\n+            element_ptr = self.data_ptr + index\n+            if saw_inaccessible:\n+                return\n+            try:\n+                # rust-lang/rust#64343: passing deref expr to `str` allows\n+                # catching exception on garbage pointer\n+                str(element_ptr.dereference())\n+                yield \"[{}]\".format(index), element_ptr.dereference()\n+            except RuntimeError:\n+                saw_inaccessible = True\n+                yield str(index), \"inaccessible\"\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+\n+class StdVecDequeProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+        self.head = int(valobj[\"head\"])\n+        self.tail = int(valobj[\"tail\"])\n+        self.cap = int(valobj[\"buf\"][\"cap\"])\n+        self.data_ptr = unwrap_unique_or_non_null(valobj[\"buf\"][\"ptr\"])\n+        if self.head >= self.tail:\n+            self.size = self.head - self.tail\n+        else:\n+            self.size = self.cap + self.head - self.tail\n+\n+    def to_string(self):\n+        return \"VecDeque(size={})\".format(self.size)\n+\n+    def children(self):\n+        for index in xrange(0, self.size):\n+            value = (self.data_ptr + ((self.tail + index) % self.cap)).dereference()\n+            yield \"[{}]\".format(index), value\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+\n+class StdRcProvider:\n+    def __init__(self, valobj, is_atomic=False):\n+        self.valobj = valobj\n+        self.is_atomic = is_atomic\n+        self.ptr = unwrap_unique_or_non_null(valobj[\"ptr\"])\n+        self.value = self.ptr[\"data\" if is_atomic else \"value\"]\n+        self.strong = self.ptr[\"strong\"][\"v\" if is_atomic else \"value\"][\"value\"]\n+        self.weak = self.ptr[\"weak\"][\"v\" if is_atomic else \"value\"][\"value\"] - 1\n+\n+    def to_string(self):\n+        if self.is_atomic:\n+            return \"Arc(strong={}, weak={})\".format(int(self.strong), int(self.weak))\n+        else:\n+            return \"Rc(strong={}, weak={})\".format(int(self.strong), int(self.weak))\n+\n+    def children(self):\n+        yield \"value\", self.value\n+        yield \"strong\", self.strong\n+        yield \"weak\", self.weak\n+\n+\n+class StdCellProvider:\n+    def __init__(self, valobj):\n+        self.value = valobj[\"value\"][\"value\"]\n+\n+    def to_string(self):\n+        return \"Cell\"\n+\n+    def children(self):\n+        yield \"value\", self.value\n+\n+\n+class StdRefProvider:\n+    def __init__(self, valobj):\n+        self.value = valobj[\"value\"].dereference()\n+        self.borrow = valobj[\"borrow\"][\"borrow\"][\"value\"][\"value\"]\n+\n+    def to_string(self):\n+        borrow = int(self.borrow)\n+        if borrow >= 0:\n+            return \"Ref(borrow={})\".format(borrow)\n+        else:\n+            return \"Ref(borrow_mut={})\".format(-borrow)\n+\n+    def children(self):\n+        yield \"*value\", self.value\n+        yield \"borrow\", self.borrow\n+\n+\n+class StdRefCellProvider:\n+    def __init__(self, valobj):\n+        self.value = valobj[\"value\"][\"value\"]\n+        self.borrow = valobj[\"borrow\"][\"value\"][\"value\"]\n+\n+    def to_string(self):\n+        borrow = int(self.borrow)\n+        if borrow >= 0:\n+            return \"RefCell(borrow={})\".format(borrow)\n+        else:\n+            return \"RefCell(borrow_mut={})\".format(-borrow)\n+\n+    def children(self):\n+        yield \"value\", self.value\n+        yield \"borrow\", self.borrow\n+\n+\n+# Yield each key (and optionally value) from a BoxedNode.\n+def children_of_node(boxed_node, height, want_values):\n+    def cast_to_internal(node):\n+        internal_type_name = str(node.type.target()).replace(\"LeafNode\", \"InternalNode\", 1)\n+        internal_type = lookup_type(internal_type_name)\n+        return node.cast(internal_type.pointer())\n+\n+    node_ptr = unwrap_unique_or_non_null(boxed_node[\"ptr\"])\n+    node_ptr = cast_to_internal(node_ptr) if height > 0 else node_ptr\n+    leaf = node_ptr[\"data\"] if height > 0 else node_ptr.dereference()\n+    keys = leaf[\"keys\"]\n+    values = leaf[\"vals\"]\n+    length = int(leaf[\"len\"])\n+\n+    for i in xrange(0, length + 1):\n+        if height > 0:\n+            child_ptr = node_ptr[\"edges\"][i][\"value\"][\"value\"]\n+            for child in children_of_node(child_ptr, height - 1, want_values):\n+                yield child\n+        if i < length:\n+            if want_values:\n+                yield keys[i][\"value\"][\"value\"], values[i][\"value\"][\"value\"]\n+            else:\n+                yield keys[i][\"value\"][\"value\"]\n+\n+\n+class StdBTreeSetProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+\n+    def to_string(self):\n+        return \"BTreeSet(size={})\".format(self.valobj[\"map\"][\"length\"])\n+\n+    def children(self):\n+        inner_map = self.valobj[\"map\"]\n+        if inner_map[\"length\"] > 0:\n+            root = inner_map[\"root\"]\n+            if \"core::option::Option<\" in root.type.name:\n+                type_name = str(root.type.name).replace(\"core::option::Option<\", \"\", 1)[:-1]\n+                root = root.cast(gdb.lookup_type(type_name))\n+\n+            node_ptr = root[\"node\"]\n+            for i, child in enumerate(children_of_node(node_ptr, root[\"height\"], False)):\n+                yield \"[{}]\".format(i), child\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+\n+class StdBTreeMapProvider:\n+    def __init__(self, valobj):\n+        self.valobj = valobj\n+\n+    def to_string(self):\n+        return \"BTreeMap(size={})\".format(self.valobj[\"length\"])\n+\n+    def children(self):\n+        if self.valobj[\"length\"] > 0:\n+            root = self.valobj[\"root\"]\n+            if \"core::option::Option<\" in root.type.name:\n+                type_name = str(root.type.name).replace(\"core::option::Option<\", \"\", 1)[:-1]\n+                root = root.cast(gdb.lookup_type(type_name))\n+\n+            node_ptr = root[\"node\"]\n+            for i, child in enumerate(children_of_node(node_ptr, root[\"height\"], True)):\n+                yield \"key{}\".format(i), child[0]\n+                yield \"val{}\".format(i), child[1]\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"map\"\n+\n+\n+# BACKCOMPAT: rust 1.35\n+class StdOldHashMapProvider:\n+    def __init__(self, valobj, show_values=True):\n+        self.valobj = valobj\n+        self.show_values = show_values\n+\n+        self.table = self.valobj[\"table\"]\n+        self.size = int(self.table[\"size\"])\n+        self.hashes = self.table[\"hashes\"]\n+        self.hash_uint_type = self.hashes.type\n+        self.hash_uint_size = self.hashes.type.sizeof\n+        self.modulo = 2 ** self.hash_uint_size\n+        self.data_ptr = self.hashes[ZERO_FIELD][\"pointer\"]\n+\n+        self.capacity_mask = int(self.table[\"capacity_mask\"])\n+        self.capacity = (self.capacity_mask + 1) % self.modulo\n+\n+        marker = self.table[\"marker\"].type\n+        self.pair_type = marker.template_argument(0)\n+        self.pair_type_size = self.pair_type.sizeof\n+\n+        self.valid_indices = []\n+        for idx in range(self.capacity):\n+            data_ptr = self.data_ptr.cast(self.hash_uint_type.pointer())\n+            address = data_ptr + idx\n+            hash_uint = address.dereference()\n+            hash_ptr = hash_uint[ZERO_FIELD][\"pointer\"]\n+            if int(hash_ptr) != 0:\n+                self.valid_indices.append(idx)\n+\n+    def to_string(self):\n+        if self.show_values:\n+            return \"HashMap(size={})\".format(self.size)\n+        else:\n+            return \"HashSet(size={})\".format(self.size)\n+\n+    def children(self):\n+        start = int(self.data_ptr) & ~1\n+\n+        hashes = self.hash_uint_size * self.capacity\n+        align = self.pair_type_size\n+        len_rounded_up = (((((hashes + align) % self.modulo - 1) % self.modulo) & ~(\n+                (align - 1) % self.modulo)) % self.modulo - hashes) % self.modulo\n+\n+        pairs_offset = hashes + len_rounded_up\n+        pairs_start = gdb.Value(start + pairs_offset).cast(self.pair_type.pointer())\n+\n+        for index in range(self.size):\n+            table_index = self.valid_indices[index]\n+            idx = table_index & self.capacity_mask\n+            element = (pairs_start + idx).dereference()\n+            if self.show_values:\n+                yield \"key{}\".format(index), element[ZERO_FIELD]\n+                yield \"val{}\".format(index), element[FIRST_FIELD]\n+            else:\n+                yield \"[{}]\".format(index), element[ZERO_FIELD]\n+\n+    def display_hint(self):\n+        return \"map\" if self.show_values else \"array\"\n+\n+\n+class StdHashMapProvider:\n+    def __init__(self, valobj, show_values=True):\n+        self.valobj = valobj\n+        self.show_values = show_values\n+\n+        table = self.valobj[\"base\"][\"table\"]\n+        capacity = int(table[\"bucket_mask\"]) + 1\n+        ctrl = table[\"ctrl\"][\"pointer\"]\n+\n+        self.size = int(table[\"items\"])\n+        self.data_ptr = table[\"data\"][\"pointer\"]\n+        self.pair_type = self.data_ptr.dereference().type\n+\n+        self.valid_indices = []\n+        for idx in range(capacity):\n+            address = ctrl + idx\n+            value = address.dereference()\n+            is_presented = value & 128 == 0\n+            if is_presented:\n+                self.valid_indices.append(idx)\n+\n+    def to_string(self):\n+        if self.show_values:\n+            return \"HashMap(size={})\".format(self.size)\n+        else:\n+            return \"HashSet(size={})\".format(self.size)\n+\n+    def children(self):\n+        pairs_start = self.data_ptr\n+\n+        for index in range(self.size):\n+            idx = self.valid_indices[index]\n+            element = (pairs_start + idx).dereference()\n+            if self.show_values:\n+                yield \"key{}\".format(index), element[ZERO_FIELD]\n+                yield \"val{}\".format(index), element[FIRST_FIELD]\n+            else:\n+                yield \"[{}]\".format(index), element[ZERO_FIELD]\n+\n+    def display_hint(self):\n+        return \"map\" if self.show_values else \"array\""}, {"sha": "d580329cb504ed9c6d40ddf36e486e94f9df5670", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "removed", "additions": 0, "deletions": 466, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,466 +0,0 @@\n-import gdb\n-import re\n-import sys\n-import debugger_pretty_printers_common as rustpp\n-\n-# We want a version of `range` which doesn't allocate an intermediate list,\n-# specifically it should use a lazy iterator. In Python 2 this was `xrange`, but\n-# if we're running with Python 3 then we need to use `range` instead.\n-if sys.version_info[0] >= 3:\n-    xrange = range\n-\n-rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string=True)\n-\n-# The btree pretty-printers fail in a confusing way unless\n-# https://sourceware.org/bugzilla/show_bug.cgi?id=21763 is fixed.\n-# This fix went in 8.1, so check for that.\n-# See https://github.com/rust-lang/rust/issues/56730\n-gdb_81 = False\n-_match = re.search('([0-9]+)\\\\.([0-9]+)', gdb.VERSION)\n-if _match:\n-    if int(_match.group(1)) > 8 or (int(_match.group(1)) == 8 and int(_match.group(2)) >= 1):\n-        gdb_81 = True\n-\n-# ===============================================================================\n-# GDB Pretty Printing Module for Rust\n-# ===============================================================================\n-\n-\n-class GdbType(rustpp.Type):\n-\n-    def __init__(self, ty):\n-        super(GdbType, self).__init__()\n-        self.ty = ty\n-        self.fields = None\n-\n-    def get_unqualified_type_name(self):\n-        tag = self.ty.tag\n-\n-        if tag is None:\n-            return tag\n-\n-        return rustpp.extract_type_name(tag).replace(\"&'static \", \"&\")\n-\n-    def get_dwarf_type_kind(self):\n-        if self.ty.code == gdb.TYPE_CODE_STRUCT:\n-            return rustpp.DWARF_TYPE_CODE_STRUCT\n-\n-        if self.ty.code == gdb.TYPE_CODE_UNION:\n-            return rustpp.DWARF_TYPE_CODE_UNION\n-\n-        if self.ty.code == gdb.TYPE_CODE_PTR:\n-            return rustpp.DWARF_TYPE_CODE_PTR\n-\n-        if self.ty.code == gdb.TYPE_CODE_ENUM:\n-            return rustpp.DWARF_TYPE_CODE_ENUM\n-\n-    def get_fields(self):\n-        assert ((self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT) or\n-                (self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION))\n-        if self.fields is None:\n-            self.fields = list(self.ty.fields())\n-        return self.fields\n-\n-    def get_wrapped_value(self):\n-        return self.ty\n-\n-\n-class GdbValue(rustpp.Value):\n-    def __init__(self, gdb_val):\n-        super(GdbValue, self).__init__(GdbType(gdb_val.type))\n-        self.gdb_val = gdb_val\n-        self.children = {}\n-\n-    def get_child_at_index(self, index):\n-        child = self.children.get(index)\n-        if child is None:\n-            gdb_field = get_field_at_index(self.gdb_val, index)\n-            child = GdbValue(self.gdb_val[gdb_field])\n-            self.children[index] = child\n-        return child\n-\n-    def as_integer(self):\n-        if self.gdb_val.type.code == gdb.TYPE_CODE_PTR:\n-            as_str = rustpp.compat_str(self.gdb_val).split()[0]\n-            return int(as_str, 0)\n-        return int(self.gdb_val)\n-\n-    def get_wrapped_value(self):\n-        return self.gdb_val\n-\n-\n-def register_printers(objfile):\n-    \"\"\"Registers Rust pretty printers for the given objfile\"\"\"\n-    objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n-\n-\n-def rust_pretty_printer_lookup_function(gdb_val):\n-    \"\"\"\n-    Returns the correct Rust pretty printer for the given value\n-    if there is one\n-    \"\"\"\n-\n-    val = GdbValue(gdb_val)\n-    type_kind = val.type.get_type_kind()\n-\n-    if type_kind == rustpp.TYPE_KIND_SLICE:\n-        return RustSlicePrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_VEC:\n-        return RustStdVecPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_VECDEQUE:\n-        return RustStdVecDequePrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_BTREESET and gdb_81:\n-        return RustStdBTreeSetPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_BTREEMAP and gdb_81:\n-        return RustStdBTreeMapPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_STRING:\n-        return RustStdStringPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_OS_STRING:\n-        return RustOsStringPrinter(val)\n-\n-    # Checks after this point should only be for \"compiler\" types --\n-    # things that gdb's Rust language support knows about.\n-    if rust_enabled:\n-        return None\n-\n-    if type_kind == rustpp.TYPE_KIND_EMPTY:\n-        return RustEmptyPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=False,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=True,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n-        return RustStringSlicePrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=False,\n-                                 omit_type_name=True,\n-                                 is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=False,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n-        return RustCStyleVariantPrinter(val.get_child_at_index(0))\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field=True,\n-                                 omit_type_name=False,\n-                                 is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n-        variant = get_field_at_index(gdb_val, 0)\n-        return rust_pretty_printer_lookup_function(gdb_val[variant])\n-\n-    if type_kind == rustpp.TYPE_KIND_REGULAR_ENUM:\n-        # This is a regular enum, extract the discriminant\n-        discriminant_val = rustpp.get_discriminant_value_as_integer(val)\n-        variant = get_field_at_index(gdb_val, discriminant_val)\n-        return rust_pretty_printer_lookup_function(gdb_val[variant])\n-\n-    if type_kind == rustpp.TYPE_KIND_COMPRESSED_ENUM:\n-        encoded_enum_info = rustpp.EncodedEnumInfo(val)\n-        if encoded_enum_info.is_null_variant():\n-            return IdentityPrinter(encoded_enum_info.get_null_variant_name())\n-\n-        non_null_val = encoded_enum_info.get_non_null_variant_val()\n-        return rust_pretty_printer_lookup_function(non_null_val.get_wrapped_value())\n-\n-    # No pretty printer has been found\n-    return None\n-\n-\n-# =------------------------------------------------------------------------------\n-# Pretty Printer Classes\n-# =------------------------------------------------------------------------------\n-class RustEmptyPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        return self.__val.type.get_unqualified_type_name()\n-\n-\n-class RustStructPrinter(object):\n-    def __init__(self, val, omit_first_field, omit_type_name, is_tuple_like):\n-        self.__val = val\n-        self.__omit_first_field = omit_first_field\n-        self.__omit_type_name = omit_type_name\n-        self.__is_tuple_like = is_tuple_like\n-\n-    def to_string(self):\n-        if self.__omit_type_name:\n-            return None\n-        return self.__val.type.get_unqualified_type_name()\n-\n-    def children(self):\n-        cs = []\n-        wrapped_value = self.__val.get_wrapped_value()\n-\n-        for number, field in enumerate(self.__val.type.get_fields()):\n-            field_value = wrapped_value[field.name]\n-            if self.__is_tuple_like:\n-                cs.append((str(number), field_value))\n-            else:\n-                cs.append((field.name, field_value))\n-\n-        if self.__omit_first_field:\n-            cs = cs[1:]\n-\n-        return cs\n-\n-    def display_hint(self):\n-        if self.__is_tuple_like:\n-            return \"array\"\n-        else:\n-            return \"\"\n-\n-\n-class RustSlicePrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % length))\n-\n-    def children(self):\n-        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n-        assert data_ptr.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n-        raw_ptr = data_ptr.get_wrapped_value()\n-\n-        for index in xrange(0, length):\n-            yield (str(index), (raw_ptr + index).dereference())\n-\n-\n-class RustStringSlicePrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n-        raw_ptr = data_ptr.get_wrapped_value()\n-        return raw_ptr.lazy_string(encoding=\"utf-8\", length=length)\n-\n-    def display_hint(self):\n-        return \"string\"\n-\n-\n-class RustStdVecPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(self.__val)\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i, cap: %i)\" % (length, cap)))\n-\n-    def children(self):\n-        saw_inaccessible = False\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(self.__val)\n-        gdb_ptr = data_ptr.get_wrapped_value()\n-        for index in xrange(0, length):\n-            if saw_inaccessible:\n-                return\n-            try:\n-                # rust-lang/rust#64343: passing deref expr to `str` allows\n-                # catching exception on garbage pointer\n-                str((gdb_ptr + index).dereference())\n-                yield (str(index), (gdb_ptr + index).dereference())\n-            except RuntimeError:\n-                saw_inaccessible = True\n-                yield (str(index), \"inaccessible\")\n-\n-\n-class RustStdVecDequePrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        (tail, head, data_ptr, cap) = \\\n-            rustpp.extract_tail_head_ptr_and_cap_from_std_vecdeque(self.__val)\n-        if head >= tail:\n-            size = head - tail\n-        else:\n-            size = cap + head - tail\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i, cap: %i)\" % (size, cap)))\n-\n-    def children(self):\n-        (tail, head, data_ptr, cap) = \\\n-            rustpp.extract_tail_head_ptr_and_cap_from_std_vecdeque(self.__val)\n-        gdb_ptr = data_ptr.get_wrapped_value()\n-        if head >= tail:\n-            size = head - tail\n-        else:\n-            size = cap + head - tail\n-        for index in xrange(0, size):\n-            yield (str(index), (gdb_ptr + ((tail + index) % cap)).dereference())\n-\n-\n-# Yield each key (and optionally value) from a BoxedNode.\n-def children_of_node(boxed_node, height, want_values):\n-    node_ptr = boxed_node['ptr']['pointer']\n-    if height > 0:\n-        type_name = str(node_ptr.type.target()).replace('LeafNode', 'InternalNode', 1)\n-        node_type = gdb.lookup_type(type_name)\n-        node_ptr = node_ptr.cast(node_type.pointer())\n-        leaf = node_ptr['data']\n-    else:\n-        leaf = node_ptr.dereference()\n-    keys = leaf['keys']\n-    if want_values:\n-        values = leaf['vals']\n-    length = int(leaf['len'])\n-    for i in xrange(0, length + 1):\n-        if height > 0:\n-            child_ptr = node_ptr['edges'][i]['value']['value']\n-            for child in children_of_node(child_ptr, height - 1, want_values):\n-                yield child\n-        if i < length:\n-            if want_values:\n-                yield (keys[i]['value']['value'], values[i]['value']['value'])\n-            else:\n-                yield keys[i]['value']['value']\n-\n-\n-class RustStdBTreeSetPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"array\"\n-\n-    def to_string(self):\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % self.__val.get_wrapped_value()['map']['length']))\n-\n-    def children(self):\n-        prev_idx = None\n-        innermap = GdbValue(self.__val.get_wrapped_value()['map'])\n-        if innermap.get_wrapped_value()['length'] > 0:\n-            root = GdbValue(innermap.get_wrapped_value()['root'])\n-            type_name = str(root.type.ty.name).replace('core::option::Option<', '', 1)[:-1]\n-            root = root.get_wrapped_value().cast(gdb.lookup_type(type_name))\n-            node_ptr = root['node']\n-            i = 0\n-            for child in children_of_node(node_ptr, root['height'], False):\n-                yield (str(i), child)\n-                i = i + 1\n-\n-\n-class RustStdBTreeMapPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    @staticmethod\n-    def display_hint():\n-        return \"map\"\n-\n-    def to_string(self):\n-        return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % self.__val.get_wrapped_value()['length']))\n-\n-    def children(self):\n-        if self.__val.get_wrapped_value()['length'] > 0:\n-            root = GdbValue(self.__val.get_wrapped_value()['root'])\n-            type_name = str(root.type.ty.name).replace('core::option::Option<', '', 1)[:-1]\n-            root = root.get_wrapped_value().cast(gdb.lookup_type(type_name))\n-            node_ptr = root['node']\n-            i = 0\n-            for child in children_of_node(node_ptr, root['height'], True):\n-                yield (str(i), child[0])\n-                yield (str(i), child[1])\n-                i = i + 1\n-\n-\n-class RustStdStringPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        vec = self.__val.get_child_at_index(0)\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n-        return data_ptr.get_wrapped_value().lazy_string(encoding=\"utf-8\",\n-                                                        length=length)\n-\n-    def display_hint(self):\n-        return \"string\"\n-\n-\n-class RustOsStringPrinter(object):\n-    def __init__(self, val):\n-        self.__val = val\n-\n-    def to_string(self):\n-        buf = self.__val.get_child_at_index(0)\n-        vec = buf.get_child_at_index(0)\n-        if vec.type.get_unqualified_type_name() == \"Wtf8Buf\":\n-            vec = vec.get_child_at_index(0)\n-\n-        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(\n-            vec)\n-        return data_ptr.get_wrapped_value().lazy_string(length=length)\n-\n-    def display_hint(self):\n-        return \"string\"\n-\n-\n-class RustCStyleVariantPrinter(object):\n-    def __init__(self, val):\n-        assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ENUM\n-        self.__val = val\n-\n-    def to_string(self):\n-        return str(self.__val.get_wrapped_value())\n-\n-\n-class IdentityPrinter(object):\n-    def __init__(self, string):\n-        self.string = string\n-\n-    def to_string(self):\n-        return self.string\n-\n-\n-def get_field_at_index(gdb_val, index):\n-    i = 0\n-    for field in gdb_val.type.fields():\n-        if i == index:\n-            return field\n-        i += 1\n-    return None"}, {"sha": "f470c62d8992730b88bdfbba617d411f88a5fb19", "filename": "src/etc/lldb_commands", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Flldb_commands", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Flldb_commands", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_commands?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,19 @@\n+command script import \\\"$RUSTC_SYSROOT/lib/rustlib/etc/lldb_lookup.py\\\"\n+type synthetic add -l lldb_lookup.synthetic_lookup -x \\\".*\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)String$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^&str$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^&\\\\[.+\\\\]$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(std::ffi::([a-z_]+::)+)OsString$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)Vec<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)VecDeque<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)BTreeSet<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)BTreeMap<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(std::collections::([a-z_]+::)+)HashMap<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(std::collections::([a-z_]+::)+)HashSet<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)Rc<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)Arc<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)Cell<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)Ref<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)RefMut<.+>$\\\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(core::([a-z_]+::)+)RefCell<.+>$\\\" --category Rust\n+type category enable Rust"}, {"sha": "13420fbaf0a759fa2aa0973b85d01ccc58fb8de9", "filename": "src/etc/lldb_lookup.py", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Flldb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Flldb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_lookup.py?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,115 @@\n+import lldb\n+\n+from lldb_providers import *\n+from rust_types import RustType, classify_struct, classify_union\n+\n+\n+# BACKCOMPAT: rust 1.35\n+def is_hashbrown_hashmap(hash_map):\n+    return len(hash_map.type.fields) == 1\n+\n+\n+def classify_rust_type(type):\n+    type_class = type.GetTypeClass()\n+    if type_class == lldb.eTypeClassStruct:\n+        return classify_struct(type.name, type.fields)\n+    if type_class == lldb.eTypeClassUnion:\n+        return classify_union(type.fields)\n+\n+    return RustType.OTHER\n+\n+\n+def summary_lookup(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    \"\"\"Returns the summary provider for the given value\"\"\"\n+    rust_type = classify_rust_type(valobj.GetType())\n+\n+    if rust_type == RustType.STD_STRING:\n+        return StdStringSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_OS_STRING:\n+        return StdOsStringSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_STR:\n+        return StdStrSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_VEC:\n+        return SizeSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_VEC_DEQUE:\n+        return SizeSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_SLICE:\n+        return SizeSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_HASH_MAP:\n+        return SizeSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_HASH_SET:\n+        return SizeSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_RC:\n+        return StdRcSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_ARC:\n+        return StdRcSummaryProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_REF:\n+        return StdRefSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_MUT:\n+        return StdRefSummaryProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_CELL:\n+        return StdRefSummaryProvider(valobj, dict)\n+\n+    return \"\"\n+\n+\n+def synthetic_lookup(valobj, dict):\n+    # type: (SBValue, dict) -> object\n+    \"\"\"Returns the synthetic provider for the given value\"\"\"\n+    rust_type = classify_rust_type(valobj.GetType())\n+\n+    if rust_type == RustType.STRUCT:\n+        return StructSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STRUCT_VARIANT:\n+        return StructSyntheticProvider(valobj, dict, is_variant=True)\n+    if rust_type == RustType.TUPLE:\n+        return TupleSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.TUPLE_VARIANT:\n+        return TupleSyntheticProvider(valobj, dict, is_variant=True)\n+    if rust_type == RustType.EMPTY:\n+        return EmptySyntheticProvider(valobj, dict)\n+    if rust_type == RustType.REGULAR_ENUM:\n+        discriminant = valobj.GetChildAtIndex(0).GetChildAtIndex(0).GetValueAsUnsigned()\n+        return synthetic_lookup(valobj.GetChildAtIndex(discriminant), dict)\n+    if rust_type == RustType.SINGLETON_ENUM:\n+        return synthetic_lookup(valobj.GetChildAtIndex(0), dict)\n+\n+    if rust_type == RustType.STD_VEC:\n+        return StdVecSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_VEC_DEQUE:\n+        return StdVecDequeSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_SLICE:\n+        return StdSliceSyntheticProvider(valobj, dict)\n+\n+    if rust_type == RustType.STD_HASH_MAP:\n+        if is_hashbrown_hashmap(valobj):\n+            return StdHashMapSyntheticProvider(valobj, dict)\n+        else:\n+            return StdOldHashMapSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_HASH_SET:\n+        hash_map = valobj.GetChildAtIndex(0)\n+        if is_hashbrown_hashmap(hash_map):\n+            return StdHashMapSyntheticProvider(hash_map, dict, show_values=False)\n+        else:\n+            return StdOldHashMapSyntheticProvider(hash_map, dict, show_values=False)\n+\n+    if rust_type == RustType.STD_RC:\n+        return StdRcSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_ARC:\n+        return StdRcSyntheticProvider(valobj, dict, is_atomic=True)\n+\n+    if rust_type == RustType.STD_CELL:\n+        return StdCellSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF:\n+        return StdRefSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_MUT:\n+        return StdRefSyntheticProvider(valobj, dict)\n+    if rust_type == RustType.STD_REF_CELL:\n+        return StdRefSyntheticProvider(valobj, dict, is_cell=True)\n+\n+    return DefaultSynthteticProvider(valobj, dict)"}, {"sha": "3c7817b3a618d6d33c468d1dbfdd0fd07e308253", "filename": "src/etc/lldb_providers.py", "status": "added", "additions": 715, "deletions": 0, "changes": 715, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,715 @@\n+import sys\n+\n+from lldb import SBValue, SBData, SBError, eBasicTypeLong, eBasicTypeUnsignedLong, \\\n+    eBasicTypeUnsignedChar\n+\n+# from lldb.formatters import Logger\n+\n+####################################################################################################\n+# This file contains two kinds of pretty-printers: summary and synthetic.\n+#\n+# Important classes from LLDB module:\n+#   SBValue: the value of a variable, a register, or an expression\n+#   SBType:  the data type; each SBValue has a corresponding SBType\n+#\n+# Summary provider is a function with the type `(SBValue, dict) -> str`.\n+#   The first parameter is the object encapsulating the actual variable being displayed;\n+#   The second parameter is an internal support parameter used by LLDB, and you should not touch it.\n+#\n+# Synthetic children is the way to provide a children-based representation of the object's value.\n+# Synthetic provider is a class that implements the following interface:\n+#\n+#     class SyntheticChildrenProvider:\n+#         def __init__(self, SBValue, dict)\n+#         def num_children(self)\n+#         def get_child_index(self, str)\n+#         def get_child_at_index(self, int)\n+#         def update(self)\n+#         def has_children(self)\n+#         def get_value(self)\n+#\n+#\n+# You can find more information and examples here:\n+#   1. https://lldb.llvm.org/varformats.html\n+#   2. https://lldb.llvm.org/python-reference.html\n+#   3. https://lldb.llvm.org/python_reference/lldb.formatters.cpp.libcxx-pysrc.html\n+#   4. https://github.com/llvm-mirror/lldb/tree/master/examples/summaries/cocoa\n+####################################################################################################\n+\n+PY3 = sys.version_info[0] == 3\n+\n+\n+class ValueBuilder:\n+    def __init__(self, valobj):\n+        # type: (SBValue) -> ValueBuilder\n+        self.valobj = valobj\n+        process = valobj.GetProcess()\n+        self.endianness = process.GetByteOrder()\n+        self.pointer_size = process.GetAddressByteSize()\n+\n+    def from_int(self, name, value):\n+        # type: (str, int) -> SBValue\n+        type = self.valobj.GetType().GetBasicType(eBasicTypeLong)\n+        data = SBData.CreateDataFromSInt64Array(self.endianness, self.pointer_size, [value])\n+        return self.valobj.CreateValueFromData(name, data, type)\n+\n+    def from_uint(self, name, value):\n+        # type: (str, int) -> SBValue\n+        type = self.valobj.GetType().GetBasicType(eBasicTypeUnsignedLong)\n+        data = SBData.CreateDataFromUInt64Array(self.endianness, self.pointer_size, [value])\n+        return self.valobj.CreateValueFromData(name, data, type)\n+\n+\n+def unwrap_unique_or_non_null(unique_or_nonnull):\n+    # BACKCOMPAT: rust 1.32\n+    # https://github.com/rust-lang/rust/commit/7a0911528058e87d22ea305695f4047572c5e067\n+    ptr = unique_or_nonnull.GetChildMemberWithName(\"pointer\")\n+    return ptr if ptr.TypeIsPointerType() else ptr.GetChildAtIndex(0)\n+\n+\n+class DefaultSynthteticProvider:\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> DefaultSynthteticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"Default synthetic provider for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.valobj.GetNumChildren()\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        return self.valobj.GetIndexOfChildWithName(name)\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        return self.valobj.GetChildAtIndex(index)\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return self.valobj.MightHaveChildren()\n+\n+\n+class EmptySyntheticProvider:\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> EmptySyntheticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"[EmptySyntheticProvider] for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return 0\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        return None\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return False\n+\n+\n+def SizeSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    return 'size=' + str(valobj.GetNumChildren())\n+\n+\n+def vec_to_string(vec):\n+    length = vec.GetNumChildren()\n+    chars = [vec.GetChildAtIndex(i).GetValueAsUnsigned() for i in range(length)]\n+    return bytes(chars).decode(errors='replace') if PY3 else \"\".join(chr(char) for char in chars)\n+\n+\n+def StdStringSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    # logger = Logger.Logger()\n+    # logger >> \"[StdStringSummaryProvider] for \" + str(valobj.GetName())\n+    vec = valobj.GetChildAtIndex(0)\n+    return '\"%s\"' % vec_to_string(vec)\n+\n+\n+def StdOsStringSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    # logger = Logger.Logger()\n+    # logger >> \"[StdOsStringSummaryProvider] for \" + str(valobj.GetName())\n+    buf = valobj.GetChildAtIndex(0).GetChildAtIndex(0)\n+    is_windows = \"Wtf8Buf\" in buf.type.name\n+    vec = buf.GetChildAtIndex(0) if is_windows else buf\n+    return '\"%s\"' % vec_to_string(vec)\n+\n+\n+def StdStrSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    # logger = Logger.Logger()\n+    # logger >> \"[StdStrSummaryProvider] for \" + str(valobj.GetName())\n+\n+    length = valobj.GetChildMemberWithName(\"length\").GetValueAsUnsigned()\n+    if length == 0:\n+        return '\"\"'\n+\n+    data_ptr = valobj.GetChildMemberWithName(\"data_ptr\")\n+\n+    start = data_ptr.GetValueAsUnsigned()\n+    error = SBError()\n+    process = data_ptr.GetProcess()\n+    data = process.ReadMemory(start, length, error)\n+    data = data.decode(encoding='UTF-8') if PY3 else data\n+    return '\"%s\"' % data\n+\n+\n+class StructSyntheticProvider:\n+    \"\"\"Pretty-printer for structs and struct enum variants\"\"\"\n+\n+    def __init__(self, valobj, dict, is_variant=False):\n+        # type: (SBValue, dict, bool) -> StructSyntheticProvider\n+        # logger = Logger.Logger()\n+        self.valobj = valobj\n+        self.is_variant = is_variant\n+        self.type = valobj.GetType()\n+        self.fields = {}\n+\n+        if is_variant:\n+            self.fields_count = self.type.GetNumberOfFields() - 1\n+            real_fields = self.type.fields[1:]\n+        else:\n+            self.fields_count = self.type.GetNumberOfFields()\n+            real_fields = self.type.fields\n+\n+        for number, field in enumerate(real_fields):\n+            self.fields[field.name] = number\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.fields_count\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        return self.fields.get(name, -1)\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if self.is_variant:\n+            field = self.type.GetFieldAtIndex(index + 1)\n+        else:\n+            field = self.type.GetFieldAtIndex(index)\n+        return self.valobj.GetChildMemberWithName(field.name)\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class TupleSyntheticProvider:\n+    \"\"\"Pretty-printer for tuples and tuple enum variants\"\"\"\n+\n+    def __init__(self, valobj, dict, is_variant=False):\n+        # type: (SBValue, dict, bool) -> TupleSyntheticProvider\n+        # logger = Logger.Logger()\n+        self.valobj = valobj\n+        self.is_variant = is_variant\n+        self.type = valobj.GetType()\n+\n+        if is_variant:\n+            self.size = self.type.GetNumberOfFields() - 1\n+        else:\n+            self.size = self.type.GetNumberOfFields()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        if name.isdigit():\n+            return int(name)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if self.is_variant:\n+            field = self.type.GetFieldAtIndex(index + 1)\n+        else:\n+            field = self.type.GetFieldAtIndex(index)\n+        element = self.valobj.GetChildMemberWithName(field.name)\n+        return self.valobj.CreateValueFromData(str(index), element.GetData(), element.GetType())\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdVecSyntheticProvider:\n+    \"\"\"Pretty-printer for alloc::vec::Vec<T>\n+\n+    struct Vec<T> { buf: RawVec<T>, len: usize }\n+    struct RawVec<T> { ptr: Unique<T>, cap: usize, ... }\n+    rust 1.31.1: struct Unique<T: ?Sized> { pointer: NonZero<*const T>, ... }\n+    rust 1.33.0: struct Unique<T: ?Sized> { pointer: *const T, ... }\n+    struct NonZero<T>(T)\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> StdVecSyntheticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"[StdVecSyntheticProvider] for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.length\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        start = self.data_ptr.GetValueAsUnsigned()\n+        address = start + index * self.element_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n+        return element\n+\n+    def update(self):\n+        # type: () -> None\n+        self.length = self.valobj.GetChildMemberWithName(\"len\").GetValueAsUnsigned()\n+        self.buf = self.valobj.GetChildMemberWithName(\"buf\")\n+\n+        self.data_ptr = unwrap_unique_or_non_null(self.buf.GetChildMemberWithName(\"ptr\"))\n+\n+        self.element_type = self.data_ptr.GetType().GetPointeeType()\n+        self.element_type_size = self.element_type.GetByteSize()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdSliceSyntheticProvider:\n+    def __init__(self, valobj, dict):\n+        self.valobj = valobj\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.length\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        start = self.data_ptr.GetValueAsUnsigned()\n+        address = start + index * self.element_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n+        return element\n+\n+    def update(self):\n+        # type: () -> None\n+        self.length = self.valobj.GetChildMemberWithName(\"length\").GetValueAsUnsigned()\n+        self.data_ptr = self.valobj.GetChildMemberWithName(\"data_ptr\")\n+\n+        self.element_type = self.data_ptr.GetType().GetPointeeType()\n+        self.element_type_size = self.element_type.GetByteSize()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdVecDequeSyntheticProvider:\n+    \"\"\"Pretty-printer for alloc::collections::vec_deque::VecDeque<T>\n+\n+    struct VecDeque<T> { tail: usize, head: usize, buf: RawVec<T> }\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> StdVecDequeSyntheticProvider\n+        # logger = Logger.Logger()\n+        # logger >> \"[StdVecDequeSyntheticProvider] for \" + str(valobj.GetName())\n+        self.valobj = valobj\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit() and self.tail <= index and (self.tail + index) % self.cap < self.head:\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        start = self.data_ptr.GetValueAsUnsigned()\n+        address = start + ((index + self.tail) % self.cap) * self.element_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n+        return element\n+\n+    def update(self):\n+        # type: () -> None\n+        self.head = self.valobj.GetChildMemberWithName(\"head\").GetValueAsUnsigned()\n+        self.tail = self.valobj.GetChildMemberWithName(\"tail\").GetValueAsUnsigned()\n+        self.buf = self.valobj.GetChildMemberWithName(\"buf\")\n+        self.cap = self.buf.GetChildMemberWithName(\"cap\").GetValueAsUnsigned()\n+        if self.head >= self.tail:\n+            self.size = self.head - self.tail\n+        else:\n+            self.size = self.cap + self.head - self.tail\n+\n+        self.data_ptr = unwrap_unique_or_non_null(self.buf.GetChildMemberWithName(\"ptr\"))\n+\n+        self.element_type = self.data_ptr.GetType().GetPointeeType()\n+        self.element_type_size = self.element_type.GetByteSize()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+# BACKCOMPAT: rust 1.35\n+class StdOldHashMapSyntheticProvider:\n+    \"\"\"Pretty-printer for std::collections::hash::map::HashMap<K, V, S>\n+\n+    struct HashMap<K, V, S> {..., table: RawTable<K, V>, ... }\n+    struct RawTable<K, V> { capacity_mask: usize, size: usize, hashes: TaggedHashUintPtr, ... }\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict, show_values=True):\n+        # type: (SBValue, dict, bool) -> StdOldHashMapSyntheticProvider\n+        self.valobj = valobj\n+        self.show_values = show_values\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        # logger = Logger.Logger()\n+        start = self.data_ptr.GetValueAsUnsigned() & ~1\n+\n+        # See `libstd/collections/hash/table.rs:raw_bucket_at\n+        hashes = self.hash_uint_size * self.capacity\n+        align = self.pair_type_size\n+        # See `libcore/alloc.rs:padding_needed_for`\n+        len_rounded_up = (((((hashes + align) % self.modulo - 1) % self.modulo) & ~(\n+                (align - 1) % self.modulo)) % self.modulo - hashes) % self.modulo\n+        # len_rounded_up = ((hashes + align - 1) & ~(align - 1)) - hashes\n+\n+        pairs_offset = hashes + len_rounded_up\n+        pairs_start = start + pairs_offset\n+\n+        table_index = self.valid_indices[index]\n+        idx = table_index & self.capacity_mask\n+        address = pairs_start + idx * self.pair_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.pair_type)\n+        if self.show_values:\n+            return element\n+        else:\n+            key = element.GetChildAtIndex(0)\n+            return self.valobj.CreateValueFromData(\"[%s]\" % index, key.GetData(), key.GetType())\n+\n+    def update(self):\n+        # type: () -> None\n+        # logger = Logger.Logger()\n+\n+        self.table = self.valobj.GetChildMemberWithName(\"table\")  # type: SBValue\n+        self.size = self.table.GetChildMemberWithName(\"size\").GetValueAsUnsigned()\n+        self.hashes = self.table.GetChildMemberWithName(\"hashes\")\n+        self.hash_uint_type = self.hashes.GetType()\n+        self.hash_uint_size = self.hashes.GetType().GetByteSize()\n+        self.modulo = 2 ** self.hash_uint_size\n+        self.data_ptr = self.hashes.GetChildAtIndex(0).GetChildAtIndex(0)\n+\n+        self.capacity_mask = self.table.GetChildMemberWithName(\"capacity_mask\").GetValueAsUnsigned()\n+        self.capacity = (self.capacity_mask + 1) % self.modulo\n+\n+        marker = self.table.GetChildMemberWithName(\"marker\").GetType()  # type: SBType\n+        self.pair_type = marker.template_args[0]\n+        self.pair_type_size = self.pair_type.GetByteSize()\n+\n+        self.valid_indices = []\n+        for idx in range(self.capacity):\n+            address = self.data_ptr.GetValueAsUnsigned() + idx * self.hash_uint_size\n+            hash_uint = self.data_ptr.CreateValueFromAddress(\"[%s]\" % idx, address,\n+                                                             self.hash_uint_type)\n+            hash_ptr = hash_uint.GetChildAtIndex(0).GetChildAtIndex(0)\n+            if hash_ptr.GetValueAsUnsigned() != 0:\n+                self.valid_indices.append(idx)\n+\n+        # logger >> \"Valid indices: {}\".format(str(self.valid_indices))\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdHashMapSyntheticProvider:\n+    \"\"\"Pretty-printer for hashbrown's HashMap\"\"\"\n+\n+    def __init__(self, valobj, dict, show_values=True):\n+        # type: (SBValue, dict, bool) -> StdHashMapSyntheticProvider\n+        self.valobj = valobj\n+        self.show_values = show_values\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return self.size\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        index = name.lstrip('[').rstrip(']')\n+        if index.isdigit():\n+            return int(index)\n+        else:\n+            return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        pairs_start = self.data_ptr.GetValueAsUnsigned()\n+        idx = self.valid_indices[index]\n+        address = pairs_start + idx * self.pair_type_size\n+        element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.pair_type)\n+        if self.show_values:\n+            return element\n+        else:\n+            key = element.GetChildAtIndex(0)\n+            return self.valobj.CreateValueFromData(\"[%s]\" % index, key.GetData(), key.GetType())\n+\n+    def update(self):\n+        # type: () -> None\n+        table = self.valobj.GetChildMemberWithName(\"base\").GetChildMemberWithName(\"table\")\n+        capacity = table.GetChildMemberWithName(\"bucket_mask\").GetValueAsUnsigned() + 1\n+        ctrl = table.GetChildMemberWithName(\"ctrl\").GetChildAtIndex(0)\n+\n+        self.size = table.GetChildMemberWithName(\"items\").GetValueAsUnsigned()\n+        self.data_ptr = table.GetChildMemberWithName(\"data\").GetChildAtIndex(0)\n+        self.pair_type = self.data_ptr.Dereference().GetType()\n+        self.pair_type_size = self.pair_type.GetByteSize()\n+\n+        u8_type = self.valobj.GetTarget().GetBasicType(eBasicTypeUnsignedChar)\n+        u8_type_size = self.valobj.GetTarget().GetBasicType(eBasicTypeUnsignedChar).GetByteSize()\n+\n+        self.valid_indices = []\n+        for idx in range(capacity):\n+            address = ctrl.GetValueAsUnsigned() + idx * u8_type_size\n+            value = ctrl.CreateValueFromAddress(\"ctrl[%s]\" % idx, address,\n+                                                u8_type).GetValueAsUnsigned()\n+            is_present = value & 128 == 0\n+            if is_present:\n+                self.valid_indices.append(idx)\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+def StdRcSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    strong = valobj.GetChildMemberWithName(\"strong\").GetValueAsUnsigned()\n+    weak = valobj.GetChildMemberWithName(\"weak\").GetValueAsUnsigned()\n+    return \"strong={}, weak={}\".format(strong, weak)\n+\n+\n+class StdRcSyntheticProvider:\n+    \"\"\"Pretty-printer for alloc::rc::Rc<T> and alloc::sync::Arc<T>\n+\n+    struct Rc<T> { ptr: NonNull<RcBox<T>>, ... }\n+    rust 1.31.1: struct NonNull<T> { pointer: NonZero<*const T> }\n+    rust 1.33.0: struct NonNull<T> { pointer: *const T }\n+    struct NonZero<T>(T)\n+    struct RcBox<T> { strong: Cell<usize>, weak: Cell<usize>, value: T }\n+    struct Cell<T> { value: UnsafeCell<T> }\n+    struct UnsafeCell<T> { value: T }\n+\n+    struct Arc<T> { ptr: NonNull<ArcInner<T>>, ... }\n+    struct ArcInner<T> { strong: atomic::AtomicUsize, weak: atomic::AtomicUsize, data: T }\n+    struct AtomicUsize { v: UnsafeCell<usize> }\n+    \"\"\"\n+\n+    def __init__(self, valobj, dict, is_atomic=False):\n+        # type: (SBValue, dict, bool) -> StdRcSyntheticProvider\n+        self.valobj = valobj\n+\n+        self.ptr = unwrap_unique_or_non_null(self.valobj.GetChildMemberWithName(\"ptr\"))\n+\n+        self.value = self.ptr.GetChildMemberWithName(\"data\" if is_atomic else \"value\")\n+\n+        self.strong = self.ptr.GetChildMemberWithName(\"strong\").GetChildAtIndex(\n+            0).GetChildMemberWithName(\"value\")\n+        self.weak = self.ptr.GetChildMemberWithName(\"weak\").GetChildAtIndex(\n+            0).GetChildMemberWithName(\"value\")\n+\n+        self.value_builder = ValueBuilder(valobj)\n+\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        # Actually there are 3 children, but only the `value` should be shown as a child\n+        return 1\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        if name == \"value\":\n+            return 0\n+        if name == \"strong\":\n+            return 1\n+        if name == \"weak\":\n+            return 2\n+        return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if index == 0:\n+            return self.value\n+        if index == 1:\n+            return self.value_builder.from_uint(\"strong\", self.strong_count)\n+        if index == 2:\n+            return self.value_builder.from_uint(\"weak\", self.weak_count)\n+\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        self.strong_count = self.strong.GetValueAsUnsigned()\n+        self.weak_count = self.weak.GetValueAsUnsigned() - 1\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+class StdCellSyntheticProvider:\n+    \"\"\"Pretty-printer for std::cell::Cell\"\"\"\n+\n+    def __init__(self, valobj, dict):\n+        # type: (SBValue, dict) -> StdCellSyntheticProvider\n+        self.valobj = valobj\n+        self.value = valobj.GetChildMemberWithName(\"value\").GetChildAtIndex(0)\n+\n+    def num_children(self):\n+        # type: () -> int\n+        return 1\n+\n+    def get_child_index(self, name):\n+        # type: (str) -> int\n+        if name == \"value\":\n+            return 0\n+        return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if index == 0:\n+            return self.value\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        pass\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True\n+\n+\n+def StdRefSummaryProvider(valobj, dict):\n+    # type: (SBValue, dict) -> str\n+    borrow = valobj.GetChildMemberWithName(\"borrow\").GetValueAsSigned()\n+    return \"borrow={}\".format(borrow) if borrow >= 0 else \"borrow_mut={}\".format(-borrow)\n+\n+\n+class StdRefSyntheticProvider:\n+    \"\"\"Pretty-printer for std::cell::Ref, std::cell::RefMut, and std::cell::RefCell\"\"\"\n+\n+    def __init__(self, valobj, dict, is_cell=False):\n+        # type: (SBValue, dict, bool) -> StdRefSyntheticProvider\n+        self.valobj = valobj\n+\n+        borrow = valobj.GetChildMemberWithName(\"borrow\")\n+        value = valobj.GetChildMemberWithName(\"value\")\n+        if is_cell:\n+            self.borrow = borrow.GetChildMemberWithName(\"value\").GetChildMemberWithName(\"value\")\n+            self.value = value.GetChildMemberWithName(\"value\")\n+        else:\n+            self.borrow = borrow.GetChildMemberWithName(\"borrow\").GetChildMemberWithName(\n+                \"value\").GetChildMemberWithName(\"value\")\n+            self.value = value.Dereference()\n+\n+        self.value_builder = ValueBuilder(valobj)\n+\n+        self.update()\n+\n+    def num_children(self):\n+        # type: () -> int\n+        # Actually there are 2 children, but only the `value` should be shown as a child\n+        return 1\n+\n+    def get_child_index(self, name):\n+        if name == \"value\":\n+            return 0\n+        if name == \"borrow\":\n+            return 1\n+        return -1\n+\n+    def get_child_at_index(self, index):\n+        # type: (int) -> SBValue\n+        if index == 0:\n+            return self.value\n+        if index == 1:\n+            return self.value_builder.from_int(\"borrow\", self.borrow_count)\n+        return None\n+\n+    def update(self):\n+        # type: () -> None\n+        self.borrow_count = self.borrow.GetValueAsSigned()\n+\n+    def has_children(self):\n+        # type: () -> bool\n+        return True"}, {"sha": "0c4021b36fb6f6ac7435ea2f40873a26584b5c69", "filename": "src/etc/lldb_rust_formatters.py", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/d139a720a2c0ad7066c43edad6ec6c2aa9613740/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=d139a720a2c0ad7066c43edad6ec6c2aa9613740", "patch": "@@ -1,305 +0,0 @@\n-import lldb\n-import debugger_pretty_printers_common as rustpp\n-\n-# ===============================================================================\n-# LLDB Pretty Printing Module for Rust\n-# ===============================================================================\n-\n-\n-class LldbType(rustpp.Type):\n-\n-    def __init__(self, ty):\n-        super(LldbType, self).__init__()\n-        self.ty = ty\n-        self.fields = None\n-\n-    def get_unqualified_type_name(self):\n-        qualified_name = self.ty.GetName()\n-\n-        if qualified_name is None:\n-            return qualified_name\n-\n-        return rustpp.extract_type_name(qualified_name).replace(\"&'static \", \"&\")\n-\n-    def get_dwarf_type_kind(self):\n-        type_class = self.ty.GetTypeClass()\n-\n-        if type_class == lldb.eTypeClassStruct:\n-            return rustpp.DWARF_TYPE_CODE_STRUCT\n-\n-        if type_class == lldb.eTypeClassUnion:\n-            return rustpp.DWARF_TYPE_CODE_UNION\n-\n-        if type_class == lldb.eTypeClassPointer:\n-            return rustpp.DWARF_TYPE_CODE_PTR\n-\n-        if type_class == lldb.eTypeClassArray:\n-            return rustpp.DWARF_TYPE_CODE_ARRAY\n-\n-        if type_class == lldb.eTypeClassEnumeration:\n-            return rustpp.DWARF_TYPE_CODE_ENUM\n-\n-        return None\n-\n-    def get_fields(self):\n-        assert ((self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT) or\n-                (self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION))\n-        if self.fields is None:\n-            self.fields = list(self.ty.fields)\n-        return self.fields\n-\n-    def get_wrapped_value(self):\n-        return self.ty\n-\n-\n-class LldbValue(rustpp.Value):\n-    def __init__(self, lldb_val):\n-        ty = lldb_val.type\n-        wty = LldbType(ty)\n-        super(LldbValue, self).__init__(wty)\n-        self.lldb_val = lldb_val\n-        self.children = {}\n-\n-    def get_child_at_index(self, index):\n-        child = self.children.get(index)\n-        if child is None:\n-            lldb_field = self.lldb_val.GetChildAtIndex(index)\n-            child = LldbValue(lldb_field)\n-            self.children[index] = child\n-        return child\n-\n-    def as_integer(self):\n-        return self.lldb_val.GetValueAsUnsigned()\n-\n-    def get_wrapped_value(self):\n-        return self.lldb_val\n-\n-\n-def print_val(lldb_val, internal_dict):\n-    val = LldbValue(lldb_val)\n-    type_kind = val.type.get_type_kind()\n-\n-    if (type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT or\n-        type_kind == rustpp.TYPE_KIND_REGULAR_UNION or\n-        type_kind == rustpp.TYPE_KIND_EMPTY):\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=False,\n-                                omit_type_name=False,\n-                                is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=True,\n-                                omit_type_name=False,\n-                                is_tuple_like=False)\n-\n-    if type_kind == rustpp.TYPE_KIND_SLICE:\n-        return print_vec_slice_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n-        return print_str_slice_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_VEC:\n-        return print_std_vec_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_STD_STRING:\n-        return print_std_string_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=False,\n-                                omit_type_name=True,\n-                                is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=False,\n-                                omit_type_name=False,\n-                                is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n-        return val.type.get_unqualified_type_name()\n-\n-    if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n-        return print_struct_val(val,\n-                                internal_dict,\n-                                omit_first_field=True,\n-                                omit_type_name=False,\n-                                is_tuple_like=True)\n-\n-    if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n-        return print_val(lldb_val.GetChildAtIndex(0), internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_PTR:\n-        return print_pointer_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_FIXED_SIZE_VEC:\n-        return print_fixed_size_vec_val(val, internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_REGULAR_ENUM:\n-        # This is a regular enum, extract the discriminant\n-        discriminant_val = rustpp.get_discriminant_value_as_integer(val)\n-        return print_val(lldb_val.GetChildAtIndex(discriminant_val), internal_dict)\n-\n-    if type_kind == rustpp.TYPE_KIND_COMPRESSED_ENUM:\n-        encoded_enum_info = rustpp.EncodedEnumInfo(val)\n-        if encoded_enum_info.is_null_variant():\n-            return encoded_enum_info.get_null_variant_name()\n-\n-        non_null_val = encoded_enum_info.get_non_null_variant_val()\n-        return print_val(non_null_val.get_wrapped_value(), internal_dict)\n-\n-    # No pretty printer has been found\n-    return lldb_val.GetValue()\n-\n-\n-# =---------------------------------------------------------------------------------------\n-# Type-Specialized Printing Functions\n-# =---------------------------------------------------------------------------------------\n-\n-def print_struct_val(val, internal_dict, omit_first_field, omit_type_name, is_tuple_like):\n-    \"\"\"\n-    Prints a struct, tuple, or tuple struct value with Rust syntax.\n-    Ignores any fields before field_start_index.\n-    \"\"\"\n-    assert (val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT or\n-            val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION)\n-\n-    if omit_type_name:\n-        type_name = \"\"\n-    else:\n-        type_name = val.type.get_unqualified_type_name()\n-\n-    if is_tuple_like:\n-        template = \"%(type_name)s(%(body)s)\"\n-        separator = \", \"\n-    else:\n-        template = \"%(type_name)s {\\n%(body)s\\n}\"\n-        separator = \", \\n\"\n-\n-    fields = val.type.get_fields()\n-\n-    def render_child(child_index):\n-        this = \"\"\n-        if not is_tuple_like:\n-            field_name = fields[child_index].name\n-            this += field_name + \": \"\n-\n-        field_val = val.get_child_at_index(child_index)\n-\n-        if not field_val.get_wrapped_value().IsValid():\n-            field = fields[child_index]\n-            # LLDB is not good at handling zero-sized values, so we have to help\n-            # it a little\n-            if field.GetType().GetByteSize() == 0:\n-                return this + rustpp.extract_type_name(field.GetType().GetName())\n-            else:\n-                return this + \"<invalid value>\"\n-\n-        return this + print_val(field_val.get_wrapped_value(), internal_dict)\n-\n-    if omit_first_field:\n-        field_start_index = 1\n-    else:\n-        field_start_index = 0\n-\n-    body = separator.join([render_child(idx) for idx in range(field_start_index, len(fields))])\n-\n-    return template % {\"type_name\": type_name,\n-                       \"body\": body}\n-\n-\n-def print_pointer_val(val, internal_dict):\n-    \"\"\"Prints a pointer value with Rust syntax\"\"\"\n-    assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n-    sigil = \"&\"\n-    type_name = val.type.get_unqualified_type_name()\n-    if type_name and type_name[0:1] in [\"&\", \"*\"]:\n-        sigil = type_name[0:1]\n-\n-    return sigil + hex(val.as_integer())\n-\n-\n-def print_fixed_size_vec_val(val, internal_dict):\n-    assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ARRAY\n-    lldb_val = val.get_wrapped_value()\n-\n-    output = \"[\"\n-\n-    for i in range(lldb_val.num_children):\n-        output += print_val(lldb_val.GetChildAtIndex(i), internal_dict)\n-        if i != lldb_val.num_children - 1:\n-            output += \", \"\n-\n-    output += \"]\"\n-    return output\n-\n-\n-def print_vec_slice_val(val, internal_dict):\n-    (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n-    return \"&[%s]\" % print_array_of_values(val.get_wrapped_value().GetName(),\n-                                           data_ptr,\n-                                           length,\n-                                           internal_dict)\n-\n-\n-def print_std_vec_val(val, internal_dict):\n-    (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(val)\n-    return \"vec![%s]\" % print_array_of_values(val.get_wrapped_value().GetName(),\n-                                              data_ptr,\n-                                              length,\n-                                              internal_dict)\n-\n-\n-def print_str_slice_val(val, internal_dict):\n-    (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n-    return read_utf8_string(data_ptr, length)\n-\n-\n-def print_std_string_val(val, internal_dict):\n-    vec = val.get_child_at_index(0)\n-    (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n-    return read_utf8_string(data_ptr, length)\n-\n-# =-----------------------------------------------------------------------\n-# Helper Functions\n-# =-----------------------------------------------------------------------\n-\n-\n-def print_array_of_values(array_name, data_ptr_val, length, internal_dict):\n-    \"\"\"Prints a contiguous memory range, interpreting it as values of the\n-       pointee-type of data_ptr_val.\"\"\"\n-\n-    data_ptr_type = data_ptr_val.type\n-    assert data_ptr_type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n-\n-    element_type = data_ptr_type.get_wrapped_value().GetPointeeType()\n-    element_type_size = element_type.GetByteSize()\n-\n-    start_address = data_ptr_val.as_integer()\n-    raw_value = data_ptr_val.get_wrapped_value()\n-\n-    def render_element(i):\n-        address = start_address + i * element_type_size\n-        element_val = raw_value.CreateValueFromAddress(array_name + (\"[%s]\" % i),\n-                                                       address,\n-                                                       element_type)\n-        return print_val(element_val, internal_dict)\n-\n-    return ', '.join([render_element(i) for i in range(length)])\n-\n-\n-def read_utf8_string(ptr_val, byte_count):\n-    if byte_count == 0:\n-        return '\"\"'\n-    error = lldb.SBError()\n-    process = ptr_val.get_wrapped_value().GetProcess()\n-    data = process.ReadMemory(ptr_val.as_integer(), byte_count, error)\n-    if error.Success():\n-        return '\"%s\"' % data.decode(encoding='UTF-8')\n-    else:\n-        return '<error: %s>' % error.GetCString()"}, {"sha": "28b32ef1ad5328cbef7f3dbc70131d8bbd89906d", "filename": "src/etc/rust-lldb", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Frust-lldb", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Frust-lldb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-lldb?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -30,13 +30,5 @@ EOF\n     fi\n fi\n \n-# Prepare commands that will be loaded before any file on the command line has been loaded\n-script_import=\"command script import \\\"$RUSTC_SYSROOT/lib/rustlib/etc/lldb_rust_formatters.py\\\"\"\n-category_definition=\"type summary add --no-value --python-function lldb_rust_formatters.print_val -x \\\".*\\\" --category Rust\"\n-category_enable=\"type category enable Rust\"\n-\n # Call LLDB with the commands added to the argument list\n-exec \"$lldb\" --one-line-before-file \"$script_import\" \\\n-    --one-line-before-file \"$category_definition\" \\\n-    --one-line-before-file \"$category_enable\" \\\n-    \"$@\"\n+exec \"$lldb\" --source-before-file ./lldb_commands \"$@\""}, {"sha": "b49fd19ed4cbbbe40ba49458037bb4c2fff5e64b", "filename": "src/etc/rust_types.py", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Frust_types.py", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fetc%2Frust_types.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust_types.py?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,113 @@\n+import re\n+\n+\n+class RustType(object):\n+    OTHER = \"Other\"\n+    STRUCT = \"Struct\"\n+    TUPLE = \"Tuple\"\n+    CSTYLE_VARIANT = \"CStyleVariant\"\n+    TUPLE_VARIANT = \"TupleVariant\"\n+    STRUCT_VARIANT = \"StructVariant\"\n+    ENUM = \"Enum\"\n+    EMPTY = \"Empty\"\n+    SINGLETON_ENUM = \"SingletonEnum\"\n+    REGULAR_ENUM = \"RegularEnum\"\n+    COMPRESSED_ENUM = \"CompressedEnum\"\n+    REGULAR_UNION = \"RegularUnion\"\n+\n+    STD_STRING = \"StdString\"\n+    STD_OS_STRING = \"StdOsString\"\n+    STD_STR = \"StdStr\"\n+    STD_SLICE = \"StdSlice\"\n+    STD_VEC = \"StdVec\"\n+    STD_VEC_DEQUE = \"StdVecDeque\"\n+    STD_BTREE_SET = \"StdBTreeSet\"\n+    STD_BTREE_MAP = \"StdBTreeMap\"\n+    STD_HASH_MAP = \"StdHashMap\"\n+    STD_HASH_SET = \"StdHashSet\"\n+    STD_RC = \"StdRc\"\n+    STD_ARC = \"StdArc\"\n+    STD_CELL = \"StdCell\"\n+    STD_REF = \"StdRef\"\n+    STD_REF_MUT = \"StdRefMut\"\n+    STD_REF_CELL = \"StdRefCell\"\n+\n+\n+STD_STRING_REGEX = re.compile(r\"^(alloc::(\\w+::)+)String$\")\n+STD_STR_REGEX = re.compile(r\"^&str$\")\n+STD_SLICE_REGEX = re.compile(r\"^&\\[.+\\]$\")\n+STD_OS_STRING_REGEX = re.compile(r\"^(std::ffi::(\\w+::)+)OsString$\")\n+STD_VEC_REGEX = re.compile(r\"^(alloc::(\\w+::)+)Vec<.+>$\")\n+STD_VEC_DEQUE_REGEX = re.compile(r\"^(alloc::(\\w+::)+)VecDeque<.+>$\")\n+STD_BTREE_SET_REGEX = re.compile(r\"^(alloc::(\\w+::)+)BTreeSet<.+>$\")\n+STD_BTREE_MAP_REGEX = re.compile(r\"^(alloc::(\\w+::)+)BTreeMap<.+>$\")\n+STD_HASH_MAP_REGEX = re.compile(r\"^(std::collections::(\\w+::)+)HashMap<.+>$\")\n+STD_HASH_SET_REGEX = re.compile(r\"^(std::collections::(\\w+::)+)HashSet<.+>$\")\n+STD_RC_REGEX = re.compile(r\"^(alloc::(\\w+::)+)Rc<.+>$\")\n+STD_ARC_REGEX = re.compile(r\"^(alloc::(\\w+::)+)Arc<.+>$\")\n+STD_CELL_REGEX = re.compile(r\"^(core::(\\w+::)+)Cell<.+>$\")\n+STD_REF_REGEX = re.compile(r\"^(core::(\\w+::)+)Ref<.+>$\")\n+STD_REF_MUT_REGEX = re.compile(r\"^(core::(\\w+::)+)RefMut<.+>$\")\n+STD_REF_CELL_REGEX = re.compile(r\"^(core::(\\w+::)+)RefCell<.+>$\")\n+\n+TUPLE_ITEM_REGEX = re.compile(r\"__\\d+$\")\n+\n+ENCODED_ENUM_PREFIX = \"RUST$ENCODED$ENUM$\"\n+ENUM_DISR_FIELD_NAME = \"<<variant>>\"\n+\n+STD_TYPE_TO_REGEX = {\n+    RustType.STD_STRING: STD_STRING_REGEX,\n+    RustType.STD_OS_STRING: STD_OS_STRING_REGEX,\n+    RustType.STD_STR: STD_STR_REGEX,\n+    RustType.STD_SLICE: STD_SLICE_REGEX,\n+    RustType.STD_VEC: STD_VEC_REGEX,\n+    RustType.STD_VEC_DEQUE: STD_VEC_DEQUE_REGEX,\n+    RustType.STD_HASH_MAP: STD_HASH_MAP_REGEX,\n+    RustType.STD_HASH_SET: STD_HASH_SET_REGEX,\n+    RustType.STD_BTREE_SET: STD_BTREE_SET_REGEX,\n+    RustType.STD_BTREE_MAP: STD_BTREE_MAP_REGEX,\n+    RustType.STD_RC: STD_RC_REGEX,\n+    RustType.STD_ARC: STD_ARC_REGEX,\n+    RustType.STD_REF: STD_REF_REGEX,\n+    RustType.STD_REF_MUT: STD_REF_MUT_REGEX,\n+    RustType.STD_REF_CELL: STD_REF_CELL_REGEX,\n+    RustType.STD_CELL: STD_CELL_REGEX,\n+}\n+\n+def is_tuple_fields(fields):\n+    # type: (list) -> bool\n+    return all(TUPLE_ITEM_REGEX.match(str(field.name)) for field in fields)\n+\n+\n+def classify_struct(name, fields):\n+    if len(fields) == 0:\n+        return RustType.EMPTY\n+\n+    for ty, regex in STD_TYPE_TO_REGEX.items():\n+        if regex.match(name):\n+            return ty\n+\n+    if fields[0].name == ENUM_DISR_FIELD_NAME:\n+        return RustType.ENUM\n+\n+    if is_tuple_fields(fields):\n+        return RustType.TUPLE\n+\n+    return RustType.STRUCT\n+\n+\n+def classify_union(fields):\n+    if len(fields) == 0:\n+        return RustType.EMPTY\n+\n+    first_variant_name = fields[0].name\n+    if first_variant_name is None:\n+        if len(fields) == 1:\n+            return RustType.SINGLETON_ENUM\n+        else:\n+            return RustType.REGULAR_ENUM\n+    elif first_variant_name.startswith(ENCODED_ENUM_PREFIX):\n+        assert len(fields) == 1\n+        return RustType.COMPRESSED_ENUM\n+    else:\n+        return RustType.REGULAR_UNION"}, {"sha": "0327a9f9a96e54d89c9dae49955706560faee84e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2034,7 +2034,7 @@ trait RcBoxPtr<T: ?Sized> {\n         // The reference count will never be zero when this is called;\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n-        if strong == 0 || strong == usize::max_value() {\n+        if strong == 0 || strong == usize::MAX {\n             abort();\n         }\n         self.inner().strong.set(strong + 1);\n@@ -2058,7 +2058,7 @@ trait RcBoxPtr<T: ?Sized> {\n         // The reference count will never be zero when this is called;\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n-        if weak == 0 || weak == usize::max_value() {\n+        if weak == 0 || weak == usize::MAX {\n             abort();\n         }\n         self.inner().weak.set(weak + 1);"}, {"sha": "e88385faf4fd4c57283645cf2a25adfe33c71933", "filename": "src/liballoc/rc/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -407,14 +407,14 @@ fn test_from_vec() {\n fn test_downcast() {\n     use std::any::Any;\n \n-    let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n+    let r1: Rc<dyn Any> = Rc::new(i32::MAX);\n     let r2: Rc<dyn Any> = Rc::new(\"abc\");\n \n     assert!(r1.clone().downcast::<u32>().is_err());\n \n     let r1i32 = r1.downcast::<i32>();\n     assert!(r1i32.is_ok());\n-    assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n+    assert_eq!(r1i32.unwrap(), Rc::new(i32::MAX));\n \n     assert!(r2.clone().downcast::<i32>().is_err());\n "}, {"sha": "6f08cd7f123be67c2d036e615f2a5286da21f493", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -465,14 +465,14 @@ fn test_from_vec() {\n fn test_downcast() {\n     use std::any::Any;\n \n-    let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n+    let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::MAX);\n     let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n \n     assert!(r1.clone().downcast::<u32>().is_err());\n \n     let r1i32 = r1.downcast::<i32>();\n     assert!(r1i32.is_ok());\n-    assert_eq!(r1i32.unwrap(), Arc::new(i32::max_value()));\n+    assert_eq!(r1i32.unwrap(), Arc::new(i32::MAX));\n \n     assert!(r2.clone().downcast::<i32>().is_err());\n "}, {"sha": "eee98d45340429f4f759f8bee607e8bd0ca2f5da", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -566,13 +566,13 @@ mod slice_index {\n                 data: \"hello\";\n                 // note: using 0 specifically ensures that the result of overflowing is 0..0,\n                 //       so that `get` doesn't simply return None for the wrong reason.\n-                bad: data[0..=usize::max_value()];\n+                bad: data[0..=usize::MAX];\n                 message: \"maximum usize\";\n             }\n \n             in mod rangetoinclusive {\n                 data: \"hello\";\n-                bad: data[..=usize::max_value()];\n+                bad: data[..=usize::MAX];\n                 message: \"maximum usize\";\n             }\n         }"}, {"sha": "a9813a8704f30e93cfd3a93e695a8b078b75c552", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -68,7 +68,7 @@ fn test_reserve() {\n \n #[test]\n fn test_zst_capacity() {\n-    assert_eq!(Vec::<()>::new().capacity(), usize::max_value());\n+    assert_eq!(Vec::<()>::new().capacity(), usize::MAX);\n }\n \n #[test]\n@@ -563,19 +563,19 @@ fn test_drain_inclusive_range() {\n \n #[test]\n fn test_drain_max_vec_size() {\n-    let mut v = Vec::<()>::with_capacity(usize::max_value());\n+    let mut v = Vec::<()>::with_capacity(usize::MAX);\n     unsafe {\n-        v.set_len(usize::max_value());\n+        v.set_len(usize::MAX);\n     }\n-    for _ in v.drain(usize::max_value() - 1..) {}\n-    assert_eq!(v.len(), usize::max_value() - 1);\n+    for _ in v.drain(usize::MAX - 1..) {}\n+    assert_eq!(v.len(), usize::MAX - 1);\n \n-    let mut v = Vec::<()>::with_capacity(usize::max_value());\n+    let mut v = Vec::<()>::with_capacity(usize::MAX);\n     unsafe {\n-        v.set_len(usize::max_value());\n+        v.set_len(usize::MAX);\n     }\n-    for _ in v.drain(usize::max_value() - 1..=usize::max_value() - 1) {}\n-    assert_eq!(v.len(), usize::max_value() - 1);\n+    for _ in v.drain(usize::MAX - 1..=usize::MAX - 1) {}\n+    assert_eq!(v.len(), usize::MAX - 1);\n }\n \n #[test]"}, {"sha": "06462fd96d9a9d16a2e966bbf1a58677b88887fa", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2779,19 +2779,25 @@ impl<'a, T> Drain<'a, T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(vec_drain_as_slice)]\n     /// let mut vec = vec!['a', 'b', 'c'];\n     /// let mut drain = vec.drain(..);\n     /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n     /// let _ = drain.next().unwrap();\n     /// assert_eq!(drain.as_slice(), &['b', 'c']);\n     /// ```\n-    #[unstable(feature = \"vec_drain_as_slice\", reason = \"recently added\", issue = \"58957\")]\n+    #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n     pub fn as_slice(&self) -> &[T] {\n         self.iter.as_slice()\n     }\n }\n \n+#[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n+impl<'a, T> AsRef<[T]> for Drain<'a, T> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]"}, {"sha": "c4293ed7bcfe2a557f2204175d86fd84d48ed39b", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -778,18 +778,13 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// An example of panic:\n     ///\n-    /// ```\n+    /// ```should_panic\n     /// use std::cell::RefCell;\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(move || {\n-    ///    let c = RefCell::new(5);\n-    ///    let m = c.borrow_mut();\n     ///\n-    ///    let b = c.borrow(); // this causes a panic\n-    /// }).join();\n+    /// let c = RefCell::new(5);\n     ///\n-    /// assert!(result.is_err());\n+    /// let m = c.borrow_mut();\n+    /// let b = c.borrow(); // this causes a panic\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -858,18 +853,13 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// An example of panic:\n     ///\n-    /// ```\n+    /// ```should_panic\n     /// use std::cell::RefCell;\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(move || {\n-    ///    let c = RefCell::new(5);\n-    ///    let m = c.borrow();\n     ///\n-    ///    let b = c.borrow_mut(); // this causes a panic\n-    /// }).join();\n+    /// let c = RefCell::new(5);\n+    /// let m = c.borrow();\n     ///\n-    /// assert!(result.is_err());\n+    /// let b = c.borrow_mut(); // this causes a panic\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1163,16 +1153,16 @@ impl<'b> BorrowRef<'b> {\n             // Incrementing borrow can result in a non-reading value (<= 0) in these cases:\n             // 1. It was < 0, i.e. there are writing borrows, so we can't allow a read borrow\n             //    due to Rust's reference aliasing rules\n-            // 2. It was isize::max_value() (the max amount of reading borrows) and it overflowed\n-            //    into isize::min_value() (the max amount of writing borrows) so we can't allow\n+            // 2. It was isize::MAX (the max amount of reading borrows) and it overflowed\n+            //    into isize::MIN (the max amount of writing borrows) so we can't allow\n             //    an additional read borrow because isize can't represent so many read borrows\n             //    (this can only happen if you mem::forget more than a small constant amount of\n             //    `Ref`s, which is not good practice)\n             None\n         } else {\n             // Incrementing borrow can result in a reading value (> 0) in these cases:\n             // 1. It was = 0, i.e. it wasn't borrowed, and we are taking the first read borrow\n-            // 2. It was > 0 and < isize::max_value(), i.e. there were read borrows, and isize\n+            // 2. It was > 0 and < isize::MAX, i.e. there were read borrows, and isize\n             //    is large enough to represent having one more read borrow\n             borrow.set(b);\n             Some(BorrowRef { borrow })\n@@ -1198,7 +1188,7 @@ impl Clone for BorrowRef<'_> {\n         debug_assert!(is_reading(borrow));\n         // Prevent the borrow counter from overflowing into\n         // a writing borrow.\n-        assert!(borrow != isize::max_value());\n+        assert!(borrow != isize::MAX);\n         self.borrow.set(borrow + 1);\n         BorrowRef { borrow: self.borrow }\n     }\n@@ -1489,7 +1479,7 @@ impl<'b> BorrowRefMut<'b> {\n         let borrow = self.borrow.get();\n         debug_assert!(is_writing(borrow));\n         // Prevent the borrow counter from underflowing.\n-        assert!(borrow != isize::min_value());\n+        assert!(borrow != isize::MIN);\n         self.borrow.set(borrow - 1);\n         BorrowRefMut { borrow: self.borrow }\n     }"}, {"sha": "d7e39946148ed793fd1eb0b175f275305f92df08", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -278,16 +278,11 @@ impl fmt::Display for CharTryFromError {\n ///\n /// Passing a large radix, causing a panic:\n ///\n-/// ```\n-/// use std::thread;\n+/// ```should_panic\n /// use std::char;\n ///\n-/// let result = thread::spawn(|| {\n-///     // this panics\n-///     let c = char::from_digit(1, 37);\n-/// }).join();\n-///\n-/// assert!(result.is_err());\n+/// // this panics\n+/// let c = char::from_digit(1, 37);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "dd2f01c679f7347a33ac6409f1fef7fa1b13d3c0", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 17, "deletions": 45, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -229,16 +229,11 @@ impl char {\n     ///\n     /// Passing a large radix, causing a panic:\n     ///\n-    /// ```\n-    /// use std::thread;\n+    /// ```should_panic\n     /// use std::char;\n     ///\n-    /// let result = thread::spawn(|| {\n-    ///     // this panics\n-    ///     let c = char::from_digit(1, 37);\n-    /// }).join();\n-    ///\n-    /// assert!(result.is_err());\n+    /// // this panics\n+    /// char::from_digit(1, 37);\n     /// ```\n     #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n     #[inline]\n@@ -282,15 +277,9 @@ impl char {\n     ///\n     /// Passing a large radix, causing a panic:\n     ///\n-    /// ```\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(|| {\n-    ///     // this panics\n-    ///     '1'.is_digit(37);\n-    /// }).join();\n-    ///\n-    /// assert!(result.is_err());\n+    /// ```should_panic\n+    /// // this panics\n+    /// '1'.is_digit(37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -337,14 +326,9 @@ impl char {\n     ///\n     /// Passing a large radix, causing a panic:\n     ///\n-    /// ```\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(|| {\n-    ///     '1'.to_digit(37);\n-    /// }).join();\n-    ///\n-    /// assert!(result.is_err());\n+    /// ```should_panic\n+    /// // this panics\n+    /// '1'.to_digit(37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -646,17 +630,11 @@ impl char {\n     ///\n     /// A buffer that's too small:\n     ///\n-    /// ```\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(|| {\n-    ///     let mut b = [0; 1];\n-    ///\n-    ///     // this panics\n-    ///    '\u00df'.encode_utf8(&mut b);\n-    /// }).join();\n+    /// ```should_panic\n+    /// let mut b = [0; 1];\n     ///\n-    /// assert!(result.is_err());\n+    /// // this panics\n+    /// '\u00df'.encode_utf8(&mut b);\n     /// ```\n     #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n     #[inline]\n@@ -687,17 +665,11 @@ impl char {\n     ///\n     /// A buffer that's too small:\n     ///\n-    /// ```\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(|| {\n-    ///     let mut b = [0; 1];\n-    ///\n-    ///     // this panics\n-    ///     '\ud835\udd4a'.encode_utf16(&mut b);\n-    /// }).join();\n+    /// ```should_panic\n+    /// let mut b = [0; 1];\n     ///\n-    /// assert!(result.is_err());\n+    /// // this panics\n+    /// '\ud835\udd4a'.encode_utf16(&mut b);\n     /// ```\n     #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n     #[inline]"}, {"sha": "5ff52a9a11b5a348bd543f2907130f52f63d833e", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -217,7 +217,7 @@ macro_rules! try_from_upper_bounded {\n             /// is outside of the range of the target type.\n             #[inline]\n             fn try_from(u: $source) -> Result<Self, Self::Error> {\n-                if u > (Self::max_value() as $source) {\n+                if u > (Self::MAX as $source) {\n                     Err(TryFromIntError(()))\n                 } else {\n                     Ok(u as Self)\n@@ -239,8 +239,8 @@ macro_rules! try_from_both_bounded {\n             /// is outside of the range of the target type.\n             #[inline]\n             fn try_from(u: $source) -> Result<Self, Self::Error> {\n-                let min = Self::min_value() as $source;\n-                let max = Self::max_value() as $source;\n+                let min = Self::MIN as $source;\n+                let max = Self::MAX as $source;\n                 if u < min || u > max {\n                     Err(TryFromIntError(()))\n                 } else {"}, {"sha": "9dbc23f5c04c5cea9262c56255e2d94727a84491", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -56,6 +56,7 @@ pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n where\n     T: Generator<ResumeTy, Yield = ()>,\n {\n+    #[rustc_diagnostic_item = \"gen_future\"]\n     struct GenFuture<T: Generator<ResumeTy, Yield = ()>>(T);\n \n     // We rely on the fact that async/await futures are immovable in order to create"}, {"sha": "fbfcdc3c1a9ea32177f9ec9735fec79c2d276d42", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2717,12 +2717,12 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// let v_cloned: Vec<_> = a.iter().copied().collect();\n+    /// let v_copied: Vec<_> = a.iter().copied().collect();\n     ///\n     /// // copied is the same as .map(|&x| x)\n     /// let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n     ///\n-    /// assert_eq!(v_cloned, vec![1, 2, 3]);\n+    /// assert_eq!(v_copied, vec![1, 2, 3]);\n     /// assert_eq!(v_map, vec![1, 2, 3]);\n     /// ```\n     #[stable(feature = \"iter_copied\", since = \"1.36.0\")]"}, {"sha": "fe05e914e6d440cccad3964011f5978c49655402", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -145,7 +145,6 @@\n #![feature(associated_type_bounds)]\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n-#![feature(option_zip)]\n #![feature(no_niche)] // rust-lang/rust#68303\n \n #[prelude_import]"}, {"sha": "b1317bc2121f6bb496949ee118f088c96ed0b414", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -750,9 +750,9 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer addition. Computes `self + rhs, assuming overflow\n+            concat!(\"Unchecked integer addition. Computes `self + rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self + rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self + rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -792,9 +792,9 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer subtraction. Computes `self - rhs, assuming overflow\n+            concat!(\"Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self - rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self - rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -834,9 +834,9 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer multiplication. Computes `self * rhs, assuming overflow\n+            concat!(\"Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self * rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self * rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -871,7 +871,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n                     None\n                 } else {\n                     // SAFETY: div by zero and by INT_MIN have been checked above\n@@ -900,7 +900,7 @@ assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n                     None\n                 } else {\n                     Some(self.div_euclid(rhs))\n@@ -929,7 +929,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n                     None\n                 } else {\n                     // SAFETY: div by zero and by INT_MIN have been checked above\n@@ -957,7 +957,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n                     None\n                 } else {\n                     Some(self.rem_euclid(rhs))\n@@ -1236,9 +1236,9 @@ $EndFeature, \"\n                 match self.checked_mul(rhs) {\n                     Some(x) => x,\n                     None => if (self < 0) == (rhs < 0) {\n-                        Self::max_value()\n+                        Self::MAX\n                     } else {\n-                        Self::min_value()\n+                        Self::MIN\n                     }\n                 }\n             }\n@@ -1267,8 +1267,8 @@ $EndFeature, \"\n             pub const fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n                     Some(x) => x,\n-                    None if self < 0 && exp % 2 == 1 => Self::min_value(),\n-                    None => Self::max_value(),\n+                    None if self < 0 && exp % 2 == 1 => Self::MIN,\n+                    None => Self::MAX,\n                 }\n             }\n         }\n@@ -1738,7 +1738,7 @@ $EndFeature, \"\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::min_value() && rhs == -1 {\n+                if self == Self::MIN && rhs == -1 {\n                     (self, true)\n                 } else {\n                     (self / rhs, false)\n@@ -1771,7 +1771,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringi\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::min_value() && rhs == -1 {\n+                if self == Self::MIN && rhs == -1 {\n                     (self, true)\n                 } else {\n                     (self.div_euclid(rhs), false)\n@@ -1805,7 +1805,7 @@ $EndFeature, \"\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::min_value() && rhs == -1 {\n+                if self == Self::MIN && rhs == -1 {\n                     (0, true)\n                 } else {\n                     (self % rhs, false)\n@@ -1838,7 +1838,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n                           without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::min_value() && rhs == -1 {\n+                if self == Self::MIN && rhs == -1 {\n                     (0, true)\n                 } else {\n                     (self.rem_euclid(rhs), false)\n@@ -1869,8 +1869,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($Self\n             #[allow(unused_attributes)]\n             #[allow_internal_unstable(const_if_match)]\n             pub const fn overflowing_neg(self) -> (Self, bool) {\n-                if self == Self::min_value() {\n-                    (Self::min_value(), true)\n+                if self == Self::MIN {\n+                    (Self::MIN, true)\n                 } else {\n                     (-self, false)\n                 }\n@@ -1952,7 +1952,7 @@ $EndFeature, \"\n             #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n             #[inline]\n             pub const fn overflowing_abs(self) -> (Self, bool) {\n-                (self.wrapping_abs(), self == Self::min_value())\n+                (self.wrapping_abs(), self == Self::MIN)\n             }\n         }\n \n@@ -2986,9 +2986,9 @@ assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\", $EndFeat\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer addition. Computes `self + rhs, assuming overflow\n+            concat!(\"Unchecked integer addition. Computes `self + rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self + rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self + rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -3026,9 +3026,9 @@ assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer subtraction. Computes `self - rhs, assuming overflow\n+            concat!(\"Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self - rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self - rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -3066,9 +3066,9 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\", $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Unchecked integer multiplication. Computes `self * rhs, assuming overflow\n+            concat!(\"Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n cannot occur. This results in undefined behavior when `self * rhs > \", stringify!($SelfT),\n-\"::max_value()` or `self * rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+\"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`.\"),\n             #[unstable(\n                 feature = \"unchecked_math\",\n                 reason = \"niche optimization path\",\n@@ -3309,7 +3309,8 @@ Basic usage:\n \n ```\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n-assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n+assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\",\n+$EndFeature, \"\n ```\"),\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -3366,7 +3367,7 @@ assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($Se\n             pub const fn saturating_mul(self, rhs: Self) -> Self {\n                 match self.checked_mul(rhs) {\n                     Some(x) => x,\n-                    None => Self::max_value(),\n+                    None => Self::MAX,\n                 }\n             }\n         }\n@@ -3393,7 +3394,7 @@ $EndFeature, \"\n             pub const fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n                     Some(x) => x,\n-                    None => Self::max_value(),\n+                    None => Self::MAX,\n                 }\n             }\n         }\n@@ -4080,7 +4081,7 @@ Basic usage:\n         }\n     }\n \n-            doc_comment! {\n+        doc_comment! {\n             concat!(\"Performs Euclidean division.\n \n Since, for the positive integers, all common\n@@ -4178,7 +4179,7 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n             // (such as intel pre-haswell) have more efficient ctlz\n             // intrinsics when the argument is non-zero.\n             let z = unsafe { intrinsics::ctlz_nonzero(p) };\n-            <$SelfT>::max_value() >> z\n+            <$SelfT>::MAX >> z\n         }\n \n         doc_comment! {\n@@ -5160,9 +5161,9 @@ trait FromStrRadixHelper: PartialOrd + Copy {\n macro_rules! doit {\n     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n         #[inline]\n-        fn min_value() -> Self { Self::min_value() }\n+        fn min_value() -> Self { Self::MIN }\n         #[inline]\n-        fn max_value() -> Self { Self::max_value() }\n+        fn max_value() -> Self { Self::MAX }\n         #[inline]\n         fn from_u32(u: u32) -> Self { u as Self }\n         #[inline]"}, {"sha": "f6acb8f8b9a9273f3865281c2c47d7cc02f018f6", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -694,7 +694,7 @@ Basic usage:\n #![feature(wrapping_int_impl)]\n use std::num::Wrapping;\n \n-let n = Wrapping(\", stringify!($t), \"::max_value()) >> 2;\n+let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\n \n assert_eq!(n.leading_zeros(), 3);\n ```\"),\n@@ -723,8 +723,7 @@ use std::num::Wrapping;\n \n assert_eq!(Wrapping(100\", stringify!($t), \").abs(), Wrapping(100));\n assert_eq!(Wrapping(-100\", stringify!($t), \").abs(), Wrapping(100));\n-assert_eq!(Wrapping(\", stringify!($t), \"::min_value()).abs(), Wrapping(\", stringify!($t),\n-\"::min_value()));\n+assert_eq!(Wrapping(\", stringify!($t), \"::MIN).abs(), Wrapping(\", stringify!($t), \"::MIN));\n assert_eq!(Wrapping(-128i8).abs().0 as u8, 128u8);\n ```\"),\n                 #[inline]\n@@ -823,7 +822,7 @@ Basic usage:\n #![feature(wrapping_int_impl)]\n use std::num::Wrapping;\n \n-let n = Wrapping(\", stringify!($t), \"::max_value()) >> 2;\n+let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\n \n assert_eq!(n.leading_zeros(), 2);\n ```\"),"}, {"sha": "5f0a12678ff432a00b501a0419670a2540ab1694", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -926,17 +926,19 @@ impl<T> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(option_zip)]\n     /// let x = Some(1);\n     /// let y = Some(\"hi\");\n     /// let z = None::<u8>;\n     ///\n     /// assert_eq!(x.zip(y), Some((1, \"hi\")));\n     /// assert_eq!(x.zip(z), None);\n     /// ```\n-    #[unstable(feature = \"option_zip\", issue = \"70086\")]\n+    #[stable(feature = \"option_zip_option\", since = \"1.46.0\")]\n     pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)> {\n-        self.zip_with(other, |a, b| (a, b))\n+        match (self, other) {\n+            (Some(a), Some(b)) => Some((a, b)),\n+            _ => None,\n+        }\n     }\n \n     /// Zips `self` and another `Option` with function `f`."}, {"sha": "e39d18d7733a239f98f97d7b1257c72e5516fe6c", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -291,7 +291,7 @@ impl<T: ?Sized> *const T {\n         T: Sized,\n     {\n         let pointee_size = mem::size_of::<T>();\n-        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n         intrinsics::ptr_offset_from(self, origin)\n     }\n \n@@ -336,7 +336,7 @@ impl<T: ?Sized> *const T {\n         T: Sized,\n     {\n         let pointee_size = mem::size_of::<T>();\n-        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n \n         let d = isize::wrapping_sub(self as _, origin as _);\n         d.wrapping_div(pointee_size as _)"}, {"sha": "1be05d5effff343658535971dab896c169143a08", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1128,7 +1128,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n                 //\n                 // Note, that we use wrapping operations here intentionally \u2013 the original formula\n                 // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n-                // usize::max_value()` instead, because we take the result `mod n` at the end\n+                // usize::MAX` instead, because we take the result `mod n` at the end\n                 // anyway.\n                 inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)));\n                 if going_mod >= m {\n@@ -1193,7 +1193,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     }\n \n     // Cannot be aligned at all.\n-    usize::max_value()\n+    usize::MAX\n }\n \n /// Compares raw pointers for equality.\n@@ -1345,14 +1345,24 @@ macro_rules! fnptr_impls_safety_abi {\n         #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n         impl<Ret, $($Arg),*> fmt::Pointer for $FnTy {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                fmt::Pointer::fmt(&(*self as *const ()), f)\n+                // HACK: The intermediate cast as usize is required for AVR\n+                // so that the address space of the source function pointer\n+                // is preserved in the final function pointer.\n+                //\n+                // https://github.com/avr-rust/rust/issues/143\n+                fmt::Pointer::fmt(&(*self as usize as *const ()), f)\n             }\n         }\n \n         #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n         impl<Ret, $($Arg),*> fmt::Debug for $FnTy {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                fmt::Pointer::fmt(&(*self as *const ()), f)\n+                // HACK: The intermediate cast as usize is required for AVR\n+                // so that the address space of the source function pointer\n+                // is preserved in the final function pointer.\n+                //\n+                // https://github.com/avr-rust/rust/issues/143\n+                fmt::Pointer::fmt(&(*self as usize as *const ()), f)\n             }\n         }\n     }"}, {"sha": "21ba2b5abcfb672a1c1cfa07b1f39a312884cb7e", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -3043,16 +3043,12 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        if *self.end() == usize::max_value() {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get(slice)\n-        }\n+        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        if *self.end() == usize::max_value() {\n+        if *self.end() == usize::MAX {\n             None\n         } else {\n             (*self.start()..self.end() + 1).get_mut(slice)\n@@ -3071,15 +3067,15 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        if *self.end() == usize::max_value() {\n+        if *self.end() == usize::MAX {\n             slice_index_overflow_fail();\n         }\n         (*self.start()..self.end() + 1).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        if *self.end() == usize::max_value() {\n+        if *self.end() == usize::MAX {\n             slice_index_overflow_fail();\n         }\n         (*self.start()..self.end() + 1).index_mut(slice)"}, {"sha": "6c4b28499a60bb4da70d577daa5ac8b4e3345ef2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1651,7 +1651,7 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             // Ascii case, try to skip forward quickly.\n             // When the pointer is aligned, read 2 words of data per iteration\n             // until we find a word containing a non-ascii byte.\n-            if align != usize::max_value() && align.wrapping_sub(index) % usize_bytes == 0 {\n+            if align != usize::MAX && align.wrapping_sub(index) % usize_bytes == 0 {\n                 let ptr = v.as_ptr();\n                 while index < blocks_end {\n                     // SAFETY: since `align - index` and `ascii_block_size` are\n@@ -2083,15 +2083,15 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if *self.end() == usize::max_value() {\n+            if *self.end() == usize::MAX {\n                 None\n             } else {\n                 (*self.start()..self.end() + 1).get(slice)\n             }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if *self.end() == usize::max_value() {\n+            if *self.end() == usize::MAX {\n                 None\n             } else {\n                 (*self.start()..self.end() + 1).get_mut(slice)\n@@ -2107,14 +2107,14 @@ mod traits {\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            if *self.end() == usize::max_value() {\n+            if *self.end() == usize::MAX {\n                 str_index_overflow_fail();\n             }\n             (*self.start()..self.end() + 1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if *self.end() == usize::max_value() {\n+            if *self.end() == usize::MAX {\n                 str_index_overflow_fail();\n             }\n             (*self.start()..self.end() + 1).index_mut(slice)\n@@ -2140,11 +2140,11 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if self.end == usize::max_value() { None } else { (..self.end + 1).get(slice) }\n+            if self.end == usize::MAX { None } else { (..self.end + 1).get(slice) }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if self.end == usize::max_value() { None } else { (..self.end + 1).get_mut(slice) }\n+            if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n@@ -2156,14 +2156,14 @@ mod traits {\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            if self.end == usize::max_value() {\n+            if self.end == usize::MAX {\n                 str_index_overflow_fail();\n             }\n             (..self.end + 1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if self.end == usize::max_value() {\n+            if self.end == usize::MAX {\n                 str_index_overflow_fail();\n             }\n             (..self.end + 1).index_mut(slice)"}, {"sha": "14f1f293d40d68716fd09e8ba5c6dd04db715114", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -60,6 +60,43 @@ use crate::slice::memchr;\n /// The trait itself acts as a builder for an associated\n /// `Searcher` type, which does the actual work of finding\n /// occurrences of the pattern in a string.\n+///\n+/// Depending on the type of the pattern, the behaviour of methods like\n+/// [`str::find`] and [`str::contains`] can change. The table below describes\n+/// some of those behaviours.\n+///\n+/// | Pattern type             | Match condition                           |\n+/// |--------------------------|-------------------------------------------|\n+/// | `&str`                   | is substring                              |\n+/// | `char`                   | is contained in string                    |\n+/// | `&[char]`                | any char in slice is contained in string  |\n+/// | `F: FnMut(char) -> bool` | `F` returns `true` for a char in string   |\n+/// | `&&str`                  | is substring                              |\n+/// | `&String`                | is substring                              |\n+///\n+/// # Examples\n+/// ```\n+/// // &str\n+/// assert_eq!(\"abaaa\".find(\"ba\"), Some(1));\n+/// assert_eq!(\"abaaa\".find(\"bac\"), None);\n+///\n+/// // char\n+/// assert_eq!(\"abaaa\".find('a'), Some(0));\n+/// assert_eq!(\"abaaa\".find('b'), Some(1));\n+/// assert_eq!(\"abaaa\".find('c'), None);\n+///\n+/// // &[char]\n+/// assert_eq!(\"ab\".find(&['b', 'a'][..]), Some(0));\n+/// assert_eq!(\"abaaa\".find(&['a', 'z'][..]), Some(0));\n+/// assert_eq!(\"abaaa\".find(&['c', 'd'][..]), None);\n+///\n+/// // FnMut(char) -> bool\n+/// assert_eq!(\"abcdef_z\".find(|ch| ch > 'd' && ch < 'y'), Some(4));\n+/// assert_eq!(\"abcddd_z\".find(|ch| ch > 'd' && ch < 'y'), None);\n+/// ```\n+///\n+/// [`str::find`]: ../../../std/primitive.str.html#method.find\n+/// [`str::contains`]: ../../../std/primitive.str.html#method.contains\n pub trait Pattern<'a>: Sized {\n     /// Associated searcher for this pattern\n     type Searcher: Searcher<'a>;\n@@ -80,6 +117,15 @@ pub trait Pattern<'a>: Sized {\n         matches!(self.into_searcher(haystack).next(), SearchStep::Match(0, _))\n     }\n \n+    /// Checks whether the pattern matches at the back of the haystack\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool\n+    where\n+        Self::Searcher: ReverseSearcher<'a>,\n+    {\n+        matches!(self.into_searcher(haystack).next_back(), SearchStep::Match(_, j) if haystack.len() == j)\n+    }\n+\n     /// Removes the pattern from the front of haystack, if it matches.\n     #[inline]\n     fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n@@ -96,15 +142,6 @@ pub trait Pattern<'a>: Sized {\n         }\n     }\n \n-    /// Checks whether the pattern matches at the back of the haystack\n-    #[inline]\n-    fn is_suffix_of(self, haystack: &'a str) -> bool\n-    where\n-        Self::Searcher: ReverseSearcher<'a>,\n-    {\n-        matches!(self.into_searcher(haystack).next_back(), SearchStep::Match(_, j) if haystack.len() == j)\n-    }\n-\n     /// Removes the pattern from the back of haystack, if it matches.\n     #[inline]\n     fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str>"}, {"sha": "1cd68f2881b7c7c3f497c29f980a3360ba08fc47", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2623,15 +2623,7 @@ unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(target_arch = \"wasm32\", allow(unused_variables))]\n pub fn fence(order: Ordering) {\n-    // On wasm32 it looks like fences aren't implemented in LLVM yet in that\n-    // they will cause LLVM to abort. The wasm instruction set doesn't have\n-    // fences right now. There's discussion online about the best way for tools\n-    // to conventionally implement fences at\n-    // https://github.com/WebAssembly/tool-conventions/issues/59. We should\n-    // follow that discussion and implement a solution when one comes about!\n-    #[cfg(not(target_arch = \"wasm32\"))]\n     // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {"}, {"sha": "939f1325c8499a2470722686192794b57d037edf", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -140,8 +140,8 @@ macro_rules! test_impl_from {\n     ($fn_name: ident, $Small: ty, $Large: ty) => {\n         #[test]\n         fn $fn_name() {\n-            let small_max = <$Small>::max_value();\n-            let small_min = <$Small>::min_value();\n+            let small_max = <$Small>::MAX;\n+            let small_min = <$Small>::MIN;\n             let large_max: $Large = small_max.into();\n             let large_min: $Large = small_min.into();\n             assert_eq!(large_max as $Small, small_max);\n@@ -248,8 +248,8 @@ macro_rules! test_impl_try_from_always_ok {\n     ($fn_name:ident, $source:ty, $target: ty) => {\n         #[test]\n         fn $fn_name() {\n-            let max = <$source>::max_value();\n-            let min = <$source>::min_value();\n+            let max = <$source>::MAX;\n+            let min = <$source>::MIN;\n             let zero: $source = 0;\n             assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(), max as $target);\n             assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(), min as $target);\n@@ -361,8 +361,8 @@ macro_rules! test_impl_try_from_signed_to_unsigned_upper_ok {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n         fn $fn_name() {\n-            let max = <$source>::max_value();\n-            let min = <$source>::min_value();\n+            let max = <$source>::MAX;\n+            let min = <$source>::MIN;\n             let zero: $source = 0;\n             let neg_one: $source = -1;\n             assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(), max as $target);\n@@ -426,8 +426,8 @@ macro_rules! test_impl_try_from_unsigned_to_signed_upper_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n         fn $fn_name() {\n-            let max = <$source>::max_value();\n-            let min = <$source>::min_value();\n+            let max = <$source>::MAX;\n+            let min = <$source>::MIN;\n             let zero: $source = 0;\n             assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n             assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(), min as $target);\n@@ -487,11 +487,11 @@ macro_rules! test_impl_try_from_same_sign_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n         fn $fn_name() {\n-            let max = <$source>::max_value();\n-            let min = <$source>::min_value();\n+            let max = <$source>::MAX;\n+            let min = <$source>::MIN;\n             let zero: $source = 0;\n-            let t_max = <$target>::max_value();\n-            let t_min = <$target>::min_value();\n+            let t_max = <$target>::MAX;\n+            let t_min = <$target>::MIN;\n             assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n             if min != 0 {\n                 assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n@@ -576,11 +576,11 @@ macro_rules! test_impl_try_from_signed_to_unsigned_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {\n         #[test]\n         fn $fn_name() {\n-            let max = <$source>::max_value();\n-            let min = <$source>::min_value();\n+            let max = <$source>::MAX;\n+            let min = <$source>::MIN;\n             let zero: $source = 0;\n-            let t_max = <$target>::max_value();\n-            let t_min = <$target>::min_value();\n+            let t_max = <$target>::MAX;\n+            let t_min = <$target>::MIN;\n             assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n             assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n             assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(), zero as $target);"}, {"sha": "9fea34d668fcc77d2e841e2487c2380f23ea4fbf", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -357,7 +357,7 @@ fn align_offset_weird_strides() {\n \n     unsafe fn test_weird_stride<T>(ptr: *const T, align: usize) -> bool {\n         let numptr = ptr as usize;\n-        let mut expected = usize::max_value();\n+        let mut expected = usize::MAX;\n         // Naive but definitely correct way to find the *first* aligned element of stride::<T>.\n         for el in 0..align {\n             if (numptr + el * ::std::mem::size_of::<T>()) % align == 0 {"}, {"sha": "cd46117f76322ad214d6d1acdc50ada453940396", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1691,8 +1691,8 @@ fn test_copy_within_panics_src_inverted() {\n #[should_panic(expected = \"attempted to index slice up to maximum usize\")]\n fn test_copy_within_panics_src_out_of_bounds() {\n     let mut bytes = *b\"Hello, World!\";\n-    // an inclusive range ending at usize::max_value() would make src_end overflow\n-    bytes.copy_within(usize::max_value()..=usize::max_value(), 0);\n+    // an inclusive range ending at usize::MAX would make src_end overflow\n+    bytes.copy_within(usize::MAX..=usize::MAX, 0);\n }\n \n #[test]"}, {"sha": "ba3adc4a135cb3a1e51b64cffe18fcc070799825", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -133,9 +133,9 @@ impl Neg for Round {\n pub type ExpInt = i16;\n \n // \\c ilogb error results.\n-pub const IEK_INF: ExpInt = ExpInt::max_value();\n-pub const IEK_NAN: ExpInt = ExpInt::min_value();\n-pub const IEK_ZERO: ExpInt = ExpInt::min_value() + 1;\n+pub const IEK_INF: ExpInt = ExpInt::MAX;\n+pub const IEK_NAN: ExpInt = ExpInt::MIN;\n+pub const IEK_ZERO: ExpInt = ExpInt::MIN + 1;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct ParseError(pub &'static str);"}, {"sha": "2d8bb7d1e8e03911d0086ea58bbaf4b9a155eb54", "filename": "src/librustc_apfloat/tests/ieee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2997,8 +2997,8 @@ fn scalbn() {\n     assert!(smallest_f64.scalbn(2099).is_infinite());\n \n     // Test for integer overflows when adding to exponent.\n-    assert!(smallest_f64.scalbn(-ExpInt::max_value()).is_pos_zero());\n-    assert!(largest_f64.scalbn(ExpInt::max_value()).is_infinite());\n+    assert!(smallest_f64.scalbn(-ExpInt::MAX).is_pos_zero());\n+    assert!(largest_f64.scalbn(ExpInt::MAX).is_infinite());\n \n     assert!(largest_denormal_f64.bitwise_eq(largest_denormal_f64.scalbn(0),));\n     assert!(neg_largest_denormal_f64.bitwise_eq(neg_largest_denormal_f64.scalbn(0),));"}, {"sha": "4a2a0de0e211ffb7a544d4bc7292339eea5e84c4", "filename": "src/librustc_arena/lib.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_arena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_arena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -602,7 +602,7 @@ macro_rules! which_arena_for_type {\n \n #[macro_export]\n macro_rules! declare_arena {\n-    ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n+    ([], [$($a:tt $name:ident: $ty:ty, $gen_ty:ty;)*], $tcx:lifetime) => {\n         #[derive(Default)]\n         pub struct Arena<$tcx> {\n             pub dropless: $crate::DroplessArena,\n@@ -611,17 +611,17 @@ macro_rules! declare_arena {\n         }\n \n         #[marker]\n-        pub trait ArenaAllocatable {}\n+        pub trait ArenaAllocatable<'tcx> {}\n \n-        impl<T: Copy> ArenaAllocatable for T {}\n+        impl<'tcx, T: Copy> ArenaAllocatable<'tcx> for T {}\n \n-        unsafe trait ArenaField<'tcx>: Sized {\n+        unsafe trait ArenaField<'tcx>: Sized + ArenaAllocatable<'tcx> {\n             /// Returns a specific arena to allocate from.\n             /// If `None` is returned, the `DropArena` will be used.\n             fn arena<'a>(arena: &'a Arena<'tcx>) -> Option<&'a $crate::TypedArena<Self>>;\n         }\n \n-        unsafe impl<'tcx, T> ArenaField<'tcx> for T {\n+        unsafe impl<'tcx, T: ArenaAllocatable<'tcx>> ArenaField<'tcx> for T {\n             #[inline]\n             default fn arena<'a>(_: &'a Arena<'tcx>) -> Option<&'a $crate::TypedArena<Self>> {\n                 panic!()\n@@ -630,18 +630,27 @@ macro_rules! declare_arena {\n \n         $(\n             #[allow(unused_lifetimes)]\n-            impl<$tcx> ArenaAllocatable for $ty {}\n-            unsafe impl<$tcx> ArenaField<$tcx> for $ty {\n+            impl<$tcx> ArenaAllocatable<$tcx> for $ty {}\n+            unsafe impl<$tcx, '_x, '_y, '_z, '_w> ArenaField<$tcx> for $gen_ty where Self: ArenaAllocatable<$tcx> {\n                 #[inline]\n                 fn arena<'a>(_arena: &'a Arena<$tcx>) -> Option<&'a $crate::TypedArena<Self>> {\n-                    $crate::which_arena_for_type!($a[&_arena.$name])\n+                    // SAFETY: We only implement `ArenaAllocatable<$tcx>` for\n+                    // `$ty`, so `$ty` and Self are the same type\n+                    unsafe {\n+                        ::std::mem::transmute::<\n+                            Option<&'a $crate::TypedArena<$ty>>,\n+                            Option<&'a $crate::TypedArena<Self>>,\n+                        >(\n+                            $crate::which_arena_for_type!($a[&_arena.$name])\n+                        )\n+                    }\n                 }\n             }\n         )*\n \n         impl<'tcx> Arena<'tcx> {\n             #[inline]\n-            pub fn alloc<T: ArenaAllocatable>(&self, value: T) -> &mut T {\n+            pub fn alloc<T: ArenaAllocatable<'tcx>>(&self, value: T) -> &mut T {\n                 if !::std::mem::needs_drop::<T>() {\n                     return self.dropless.alloc(value);\n                 }\n@@ -659,7 +668,7 @@ macro_rules! declare_arena {\n                 self.dropless.alloc_slice(value)\n             }\n \n-            pub fn alloc_from_iter<'a, T: ArenaAllocatable>(\n+            pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx>>(\n                 &'a self,\n                 iter: impl ::std::iter::IntoIterator<Item = T>,\n             ) -> &'a mut [T] {"}, {"sha": "62406552e318f1e6a7b07905a5db01acfd2fb0b0", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -362,7 +362,11 @@ impl Default for Generics {\n     fn default() -> Generics {\n         Generics {\n             params: Vec::new(),\n-            where_clause: WhereClause { predicates: Vec::new(), span: DUMMY_SP },\n+            where_clause: WhereClause {\n+                has_where_token: false,\n+                predicates: Vec::new(),\n+                span: DUMMY_SP,\n+            },\n             span: DUMMY_SP,\n         }\n     }\n@@ -371,6 +375,11 @@ impl Default for Generics {\n /// A where-clause in a definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereClause {\n+    /// `true` if we ate a `where` token: this can happen\n+    /// if we parsed no predicates (e.g. `struct Foo where {}\n+    /// This allows us to accurately pretty-print\n+    /// in `nt_to_tokenstream`\n+    pub has_where_token: bool,\n     pub predicates: Vec<WherePredicate>,\n     pub span: Span,\n }\n@@ -1165,7 +1174,9 @@ pub enum ExprKind {\n     /// and the remaining elements are the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n-    MethodCall(PathSegment, Vec<P<Expr>>),\n+    /// This `Span` is the span of the function, without the dot and receiver\n+    /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n+    MethodCall(PathSegment, Vec<P<Expr>>, Span),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(Vec<P<Expr>>),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n@@ -1849,15 +1860,6 @@ impl TyKind {\n     pub fn is_unit(&self) -> bool {\n         if let TyKind::Tup(ref tys) = *self { tys.is_empty() } else { false }\n     }\n-\n-    /// HACK(type_alias_impl_trait, Centril): A temporary crutch used\n-    /// in lowering to avoid making larger changes there and beyond.\n-    pub fn opaque_top_hack(&self) -> Option<&GenericBounds> {\n-        match self {\n-            Self::ImplTrait(_, bounds) => Some(bounds),\n-            _ => None,\n-        }\n-    }\n }\n \n /// Syntax used to declare a trait object."}, {"sha": "2ffef9d48c181685e5cd8e8d6aedeba251691400", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -786,7 +786,7 @@ pub fn noop_visit_generics<T: MutVisitor>(generics: &mut Generics, vis: &mut T)\n }\n \n pub fn noop_visit_where_clause<T: MutVisitor>(wc: &mut WhereClause, vis: &mut T) {\n-    let WhereClause { predicates, span } = wc;\n+    let WhereClause { has_where_token: _, predicates, span } = wc;\n     visit_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n     vis.visit_span(span);\n }\n@@ -1111,11 +1111,12 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_expr(f);\n             visit_exprs(args, vis);\n         }\n-        ExprKind::MethodCall(PathSegment { ident, id, args }, exprs) => {\n+        ExprKind::MethodCall(PathSegment { ident, id, args }, exprs, span) => {\n             vis.visit_ident(ident);\n             vis.visit_id(id);\n             visit_opt(args, |args| vis.visit_generic_args(args));\n             visit_exprs(exprs, vis);\n+            vis.visit_span(span);\n         }\n         ExprKind::Binary(_binop, lhs, rhs) => {\n             vis.visit_expr(lhs);"}, {"sha": "15ae12ebf10e3ac7a2d913f2410d360cae70ea71", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -392,7 +392,7 @@ impl TokenStream {\n                         break;\n                     }\n                 }\n-                token_trees = out.into_iter().map(|t| TokenTree::Token(t)).collect();\n+                token_trees = out.into_iter().map(TokenTree::Token).collect();\n                 if token_trees.len() != 1 {\n                     debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n                 }"}, {"sha": "d8b44a22f2c92b340ea03a3644943e5df358a2e0", "filename": "src/librustc_ast/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fparser.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -394,7 +394,7 @@ pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n             contains_exterior_struct_lit(&x)\n         }\n \n-        ast::ExprKind::MethodCall(.., ref exprs) => {\n+        ast::ExprKind::MethodCall(.., ref exprs, _) => {\n             // X { y: 1 }.bar(...)\n             contains_exterior_struct_lit(&exprs[0])\n         }"}, {"sha": "ccab46703dffe796e65c01f19de9e117f78ffe3a", "filename": "src/librustc_ast/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fvisit.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -726,7 +726,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(ref segment, ref arguments) => {\n+        ExprKind::MethodCall(ref segment, ref arguments, _span) => {\n             visitor.visit_path_segment(expression.span, segment);\n             walk_list!(visitor, visit_expr, arguments);\n         }"}, {"sha": "e59cacfffc9264b60f7e29ee54168771feb29d31", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n+use rustc_span::source_map::{respan, DesugaringKind, ForLoopLoc, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n@@ -25,6 +25,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n+        let mut span = e.span;\n         ensure_sufficient_stack(|| {\n             let kind = match e.kind {\n                 ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n@@ -39,7 +40,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let f = self.lower_expr(f);\n                     hir::ExprKind::Call(f, self.lower_exprs(args))\n                 }\n-                ExprKind::MethodCall(ref seg, ref args) => {\n+                ExprKind::MethodCall(ref seg, ref args, span) => {\n                     let hir_seg = self.arena.alloc(self.lower_path_segment(\n                         e.span,\n                         seg,\n@@ -50,9 +51,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         None,\n                     ));\n                     let args = self.lower_exprs(args);\n-                    hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n+                    hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args, span)\n                 }\n                 ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+                    span = self.mark_span_with_reason(DesugaringKind::Operator, e.span, None);\n                     let binop = self.lower_binop(binop);\n                     let lhs = self.lower_expr(lhs);\n                     let rhs = self.lower_expr(rhs);\n@@ -222,7 +224,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::Expr {\n                 hir_id: self.lower_node_id(e.id),\n                 kind,\n-                span: e.span,\n+                span,\n                 attrs: e.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n             }\n         })\n@@ -237,6 +239,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_binop(&mut self, b: BinOp) -> hir::BinOp {\n+        let span = self.mark_span_with_reason(DesugaringKind::Operator, b.span, None);\n         Spanned {\n             node: match b.node {\n                 BinOpKind::Add => hir::BinOpKind::Add,\n@@ -258,7 +261,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 BinOpKind::Ge => hir::BinOpKind::Ge,\n                 BinOpKind::Gt => hir::BinOpKind::Gt,\n             },\n-            span: b.span,\n+            span,\n         }\n     }\n \n@@ -1237,10 +1240,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                             ) => {\n                                                 assert!(!*late);\n                                                 let out_op_sp = if input { op_sp2 } else { op_sp };\n-                                                let msg = &format!(\n-                                                    \"use `lateout` instead of \\\n-                                                     `out` to avoid conflict\"\n-                                                );\n+                                                let msg = \"use `lateout` instead of \\\n+                                                     `out` to avoid conflict\";\n                                                 err.span_help(out_op_sp, msg);\n                                             }\n                                             _ => {}\n@@ -1362,9 +1363,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::Expr<'hir> {\n+        let orig_head_span = head.span;\n         // expand <head>\n         let mut head = self.lower_expr_mut(head);\n-        let desugared_span = self.mark_span_with_reason(DesugaringKind::ForLoop, head.span, None);\n+        let desugared_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::Head),\n+            orig_head_span,\n+            None,\n+        );\n         head.span = desugared_span;\n \n         let iter = Ident::with_dummy_span(sym::iter);\n@@ -1459,10 +1465,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `mut iter => { ... }`\n         let iter_arm = self.arm(iter_pat, loop_expr);\n \n+        let into_iter_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::IntoIter),\n+            orig_head_span,\n+            None,\n+        );\n+\n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n             let into_iter_path = &[sym::iter, sym::IntoIterator, sym::into_iter];\n-            self.expr_call_std_path(desugared_span, into_iter_path, arena_vec![self; head])\n+            self.expr_call_std_path(into_iter_span, into_iter_path, arena_vec![self; head])\n         };\n \n         let match_expr = self.arena.alloc(self.expr_match("}, {"sha": "8cfbd408e22b3878078f479eb88d249a2cfd929c", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,12 +1,13 @@\n use super::{AnonymousLifetimeMode, LoweringContext, ParamMode};\n-use super::{ImplTraitContext, ImplTraitPosition, ImplTraitTypeIdVisitor};\n+use super::{ImplTraitContext, ImplTraitPosition};\n use crate::Arena;\n \n use rustc_ast::ast::*;\n use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -165,13 +166,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             ItemKind::MacroDef(..) => SmallVec::new(),\n             ItemKind::Fn(..) | ItemKind::Impl { of_trait: None, .. } => smallvec![i.id],\n-            ItemKind::Static(ref ty, ..) | ItemKind::Const(_, ref ty, ..) => {\n-                let mut ids = smallvec![i.id];\n-                if self.sess.features_untracked().impl_trait_in_bindings {\n-                    ImplTraitTypeIdVisitor { ids: &mut ids }.visit_ty(ty);\n-                }\n-                ids\n-            }\n             _ => smallvec![i.id],\n         };\n \n@@ -292,23 +286,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n             ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n-            ItemKind::TyAlias(_, ref gen, _, Some(ref ty)) => match ty.kind.opaque_top_hack() {\n-                None => {\n-                    let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                    let generics = self.lower_generics(gen, ImplTraitContext::disallowed());\n-                    hir::ItemKind::TyAlias(ty, generics)\n-                }\n-                Some(bounds) => {\n-                    let ctx = || ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc);\n-                    let ty = hir::OpaqueTy {\n-                        generics: self.lower_generics(gen, ctx()),\n-                        bounds: self.lower_param_bounds(bounds, ctx()),\n-                        impl_trait_fn: None,\n-                        origin: hir::OpaqueTyOrigin::TypeAlias,\n-                    };\n-                    hir::ItemKind::OpaqueTy(ty)\n-                }\n-            },\n+            ItemKind::TyAlias(_, ref gen, _, Some(ref ty)) => {\n+                // We lower\n+                //\n+                // type Foo = impl Trait\n+                //\n+                // to\n+                //\n+                // type Foo = Foo1\n+                // opaque type Foo1: Trait\n+                let ty = self.lower_ty(\n+                    ty,\n+                    ImplTraitContext::OtherOpaqueTy {\n+                        capturable_lifetimes: &mut FxHashSet::default(),\n+                        origin: hir::OpaqueTyOrigin::Misc,\n+                    },\n+                );\n+                let generics = self.lower_generics(gen, ImplTraitContext::disallowed());\n+                hir::ItemKind::TyAlias(ty, generics)\n+            }\n             ItemKind::TyAlias(_, ref generics, _, None) => {\n                 let ty = self.arena.alloc(self.ty(span, hir::TyKind::Err));\n                 let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n@@ -438,8 +434,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         body: Option<&Expr>,\n     ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n+        let mut capturable_lifetimes;\n         let itctx = if self.sess.features_untracked().impl_trait_in_bindings {\n-            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n+            capturable_lifetimes = FxHashSet::default();\n+            ImplTraitContext::OtherOpaqueTy {\n+                capturable_lifetimes: &mut capturable_lifetimes,\n+                origin: hir::OpaqueTyOrigin::Misc,\n+            }\n         } else {\n             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n         };\n@@ -844,16 +845,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let ty = self.arena.alloc(self.ty(i.span, hir::TyKind::Err));\n                         hir::ImplItemKind::TyAlias(ty)\n                     }\n-                    Some(ty) => match ty.kind.opaque_top_hack() {\n-                        None => {\n-                            let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                            hir::ImplItemKind::TyAlias(ty)\n-                        }\n-                        Some(bs) => {\n-                            let bs = self.lower_param_bounds(bs, ImplTraitContext::disallowed());\n-                            hir::ImplItemKind::OpaqueTy(bs)\n-                        }\n-                    },\n+                    Some(ty) => {\n+                        let ty = self.lower_ty(\n+                            ty,\n+                            ImplTraitContext::OtherOpaqueTy {\n+                                capturable_lifetimes: &mut FxHashSet::default(),\n+                                origin: hir::OpaqueTyOrigin::Misc,\n+                            },\n+                        );\n+                        hir::ImplItemKind::TyAlias(ty)\n+                    }\n                 };\n                 (generics, kind)\n             }\n@@ -887,12 +888,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             defaultness,\n             kind: match &i.kind {\n                 AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n-                AssocItemKind::TyAlias(.., ty) => {\n-                    match ty.as_deref().and_then(|ty| ty.kind.opaque_top_hack()) {\n-                        None => hir::AssocItemKind::Type,\n-                        Some(_) => hir::AssocItemKind::OpaqueTy,\n-                    }\n-                }\n+                AssocItemKind::TyAlias(..) => hir::AssocItemKind::Type,\n                 AssocItemKind::Fn(_, sig, ..) => {\n                     hir::AssocItemKind::Fn { has_self: sig.decl.has_self() }\n                 }"}, {"sha": "a722a88a7a1026a5a8cdfbbdfd9a06da24113869", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 121, "deletions": 29, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -33,7 +33,7 @@\n #![feature(array_value_iter)]\n #![feature(crate_visibility_modifier)]\n #![feature(marker_trait_attr)]\n-#![feature(specialization)] // FIXME: min_specialization does not work\n+#![feature(min_specialization)]\n #![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n@@ -224,11 +224,30 @@ enum ImplTraitContext<'b, 'a> {\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n     /// equivalent to a new opaque type like `type T = impl Debug; fn foo() -> T`.\n     ///\n-    /// We optionally store a `DefId` for the parent item here so we can look up necessary\n-    /// information later. It is `None` when no information about the context should be stored\n-    /// (e.g., for consts and statics).\n-    OpaqueTy(Option<DefId> /* fn def-ID */, hir::OpaqueTyOrigin),\n-\n+    ReturnPositionOpaqueTy {\n+        /// `DefId` for the parent function, used to look up necessary\n+        /// information later.\n+        fn_def_id: DefId,\n+        /// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,\n+        origin: hir::OpaqueTyOrigin,\n+    },\n+    /// Impl trait in type aliases, consts and statics.\n+    OtherOpaqueTy {\n+        /// Set of lifetimes that this opaque type can capture, if it uses\n+        /// them. This includes lifetimes bound since we entered this context.\n+        /// For example, in\n+        ///\n+        /// type A<'b> = impl for<'a> Trait<'a, Out = impl Sized + 'a>;\n+        ///\n+        /// the inner opaque type captures `'a` because it uses it. It doesn't\n+        /// need to capture `'b` because it already inherits the lifetime\n+        /// parameter from `A`.\n+        // FIXME(impl_trait): but `required_region_bounds` will ICE later\n+        // anyway.\n+        capturable_lifetimes: &'b mut FxHashSet<hir::LifetimeName>,\n+        /// Origin: Either OpaqueTyOrigin::Misc or OpaqueTyOrigin::Binding,\n+        origin: hir::OpaqueTyOrigin,\n+    },\n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n }\n@@ -253,7 +272,12 @@ impl<'a> ImplTraitContext<'_, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n-            OpaqueTy(fn_def_id, origin) => OpaqueTy(*fn_def_id, *origin),\n+            ReturnPositionOpaqueTy { fn_def_id, origin } => {\n+                ReturnPositionOpaqueTy { fn_def_id: *fn_def_id, origin: *origin }\n+            }\n+            OtherOpaqueTy { capturable_lifetimes, origin } => {\n+                OtherOpaqueTy { capturable_lifetimes, origin: *origin }\n+            }\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -1001,6 +1025,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::TypeBindingKind::Equality { ty: self.lower_ty(ty, itctx) }\n             }\n             AssocTyConstraintKind::Bound { ref bounds } => {\n+                let mut capturable_lifetimes;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1010,7 +1035,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo() -> impl Iterator<Item = impl Debug>\n-                    ImplTraitContext::OpaqueTy(..) => (true, itctx),\n+                    ImplTraitContext::ReturnPositionOpaqueTy { .. }\n+                    | ImplTraitContext::OtherOpaqueTy { .. } => (true, itctx),\n \n                     // We are in the argument position, but within a dyn type:\n                     //\n@@ -1028,7 +1054,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     //\n                     // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => {\n-                        (true, ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc))\n+                        capturable_lifetimes = FxHashSet::default();\n+                        (\n+                            true,\n+                            ImplTraitContext::OtherOpaqueTy {\n+                                capturable_lifetimes: &mut capturable_lifetimes,\n+                                origin: hir::OpaqueTyOrigin::Misc,\n+                            },\n+                        )\n                     }\n \n                     // We are in the parameter position, but not within a dyn type:\n@@ -1270,10 +1303,31 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::OpaqueTy(fn_def_id, origin) => {\n-                        self.lower_opaque_impl_trait(span, fn_def_id, origin, def_node_id, |this| {\n-                            this.lower_param_bounds(bounds, itctx)\n-                        })\n+                    ImplTraitContext::ReturnPositionOpaqueTy { fn_def_id, origin } => self\n+                        .lower_opaque_impl_trait(\n+                            span,\n+                            Some(fn_def_id),\n+                            origin,\n+                            def_node_id,\n+                            None,\n+                            |this| this.lower_param_bounds(bounds, itctx),\n+                        ),\n+                    ImplTraitContext::OtherOpaqueTy { ref capturable_lifetimes, origin } => {\n+                        // Reset capturable lifetimes, any nested impl trait\n+                        // types will inherit lifetimes from this opaque type,\n+                        // so don't need to capture them again.\n+                        let nested_itctx = ImplTraitContext::OtherOpaqueTy {\n+                            capturable_lifetimes: &mut FxHashSet::default(),\n+                            origin,\n+                        };\n+                        self.lower_opaque_impl_trait(\n+                            span,\n+                            None,\n+                            origin,\n+                            def_node_id,\n+                            Some(capturable_lifetimes),\n+                            |this| this.lower_param_bounds(bounds, nested_itctx),\n+                        )\n                     }\n                     ImplTraitContext::Universal(in_band_ty_params) => {\n                         // Add a definition for the in-band `Param`.\n@@ -1351,6 +1405,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         fn_def_id: Option<DefId>,\n         origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n+        capturable_lifetimes: Option<&FxHashSet<hir::LifetimeName>>,\n         lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n     ) -> hir::TyKind<'hir> {\n         debug!(\n@@ -1371,12 +1426,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let hir_bounds = self.with_hir_id_owner(opaque_ty_node_id, lower_bounds);\n \n-        let (lifetimes, lifetime_defs) =\n-            self.lifetimes_from_impl_trait_bounds(opaque_ty_node_id, opaque_ty_def_id, &hir_bounds);\n+        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n+            opaque_ty_node_id,\n+            opaque_ty_def_id,\n+            &hir_bounds,\n+            capturable_lifetimes,\n+        );\n \n-        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes,);\n+        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes);\n \n-        debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs,);\n+        debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n \n         self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n@@ -1395,7 +1454,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 lctx.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, lifetimes)\n+            hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, lifetimes)\n         })\n     }\n \n@@ -1433,6 +1492,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         opaque_ty_id: NodeId,\n         parent_def_id: LocalDefId,\n         bounds: hir::GenericBounds<'hir>,\n+        lifetimes_to_include: Option<&FxHashSet<hir::LifetimeName>>,\n     ) -> (&'hir [hir::GenericArg<'hir>], &'hir [hir::GenericParam<'hir>]) {\n         debug!(\n             \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n@@ -1453,6 +1513,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n             output_lifetimes: Vec<hir::GenericArg<'hir>>,\n             output_lifetime_params: Vec<hir::GenericParam<'hir>>,\n+            lifetimes_to_include: Option<&'r FxHashSet<hir::LifetimeName>>,\n         }\n \n         impl<'r, 'a, 'v, 'hir> intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n@@ -1538,6 +1599,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 if !self.currently_bound_lifetimes.contains(&name)\n                     && !self.already_defined_lifetimes.contains(&name)\n+                    && self.lifetimes_to_include.map_or(true, |lifetimes| lifetimes.contains(&name))\n                 {\n                     self.already_defined_lifetimes.insert(name);\n \n@@ -1591,6 +1653,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             already_defined_lifetimes: FxHashSet::default(),\n             output_lifetimes: Vec::new(),\n             output_lifetime_params: Vec::new(),\n+            lifetimes_to_include,\n         };\n \n         for bound in bounds {\n@@ -1614,15 +1677,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 visitor.visit_ty(ty);\n             }\n         }\n-        let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n         let ty = l.ty.as_ref().map(|t| {\n+            let mut capturable_lifetimes;\n             self.lower_ty(\n                 t,\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n-                    ImplTraitContext::OpaqueTy(\n-                        Some(parent_def_id.to_def_id()),\n-                        hir::OpaqueTyOrigin::Misc,\n-                    )\n+                    capturable_lifetimes = FxHashSet::default();\n+                    ImplTraitContext::OtherOpaqueTy {\n+                        capturable_lifetimes: &mut capturable_lifetimes,\n+                        origin: hir::OpaqueTyOrigin::Binding,\n+                    }\n                 } else {\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                 },\n@@ -1725,7 +1789,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 FnRetTy::Ty(ref ty) => {\n                     let context = match in_band_ty_params {\n                         Some((def_id, _)) if impl_trait_return_allow => {\n-                            ImplTraitContext::OpaqueTy(Some(def_id), hir::OpaqueTyOrigin::FnReturn)\n+                            ImplTraitContext::ReturnPositionOpaqueTy {\n+                                fn_def_id: def_id,\n+                                origin: hir::OpaqueTyOrigin::FnReturn,\n+                            }\n                         }\n                         _ => ImplTraitContext::disallowed(),\n                     };\n@@ -1944,7 +2011,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Foo = impl Trait` is, internally, created as a child of the\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n-        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args);\n+        let opaque_ty_ref = hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, generic_args);\n         let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n         hir::FnRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n@@ -1962,8 +2029,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // Not `OpaqueTyOrigin::AsyncFn`: that's only used for the\n                 // `impl Future` opaque type that `async fn` implicitly\n                 // generates.\n-                let context =\n-                    ImplTraitContext::OpaqueTy(Some(fn_def_id), hir::OpaqueTyOrigin::FnReturn);\n+                let context = ImplTraitContext::ReturnPositionOpaqueTy {\n+                    fn_def_id,\n+                    origin: hir::OpaqueTyOrigin::FnReturn,\n+                };\n                 self.lower_ty(ty, context)\n             }\n             FnRetTy::Default(ret_ty_span) => self.arena.alloc(self.ty_tup(*ret_ty_span, &[])),\n@@ -2113,7 +2182,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     default: default.as_ref().map(|x| {\n                         self.lower_ty(\n                             x,\n-                            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc),\n+                            ImplTraitContext::OtherOpaqueTy {\n+                                capturable_lifetimes: &mut FxHashSet::default(),\n+                                origin: hir::OpaqueTyOrigin::Misc,\n+                            },\n                         )\n                     }),\n                     synthetic: param\n@@ -2169,8 +2241,28 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             &NodeMap::default(),\n             itctx.reborrow(),\n         );\n+\n         let trait_ref = self.with_in_scope_lifetime_defs(&p.bound_generic_params, |this| {\n-            this.lower_trait_ref(&p.trait_ref, itctx)\n+            // Any impl Trait types defined within this scope can capture\n+            // lifetimes bound on this predicate.\n+            let lt_def_names = p.bound_generic_params.iter().filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => Some(hir::LifetimeName::Param(\n+                    ParamName::Plain(param.ident.normalize_to_macros_2_0()),\n+                )),\n+                _ => None,\n+            });\n+            if let ImplTraitContext::OtherOpaqueTy { ref mut capturable_lifetimes, .. } = itctx {\n+                capturable_lifetimes.extend(lt_def_names.clone());\n+            }\n+\n+            let res = this.lower_trait_ref(&p.trait_ref, itctx.reborrow());\n+\n+            if let ImplTraitContext::OtherOpaqueTy { ref mut capturable_lifetimes, .. } = itctx {\n+                for param in lt_def_names {\n+                    capturable_lifetimes.remove(&param);\n+                }\n+            }\n+            res\n         });\n \n         hir::PolyTraitRef { bound_generic_params, trait_ref, span: p.span }"}, {"sha": "a7b0c9cf81be6706d053ed6a90d6f8a9ddf8e3d4", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -121,6 +121,14 @@ impl<'a> PostExpansionVisitor<'a> {\n                     \"amdgpu-kernel ABI is experimental and subject to change\"\n                 );\n             }\n+            \"avr-interrupt\" | \"avr-non-blocking-interrupt\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    abi_avr_interrupt,\n+                    span,\n+                    \"avr-interrupt and avr-non-blocking-interrupt ABIs are experimental and subject to change\"\n+                );\n+            }\n             \"efiapi\" => {\n                 gate_feature_post!(\n                     &self,"}, {"sha": "b1abc08aa67b0a1a29b4268a45e2575f47da3289", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1818,7 +1818,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Call(ref func, ref args) => {\n                 self.print_expr_call(func, &args[..]);\n             }\n-            ast::ExprKind::MethodCall(ref segment, ref args) => {\n+            ast::ExprKind::MethodCall(ref segment, ref args, _) => {\n                 self.print_expr_method_call(segment, &args[..]);\n             }\n             ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n@@ -2593,7 +2593,7 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_where_clause(&mut self, where_clause: &ast::WhereClause) {\n-        if where_clause.predicates.is_empty() {\n+        if where_clause.predicates.is_empty() && !where_clause.has_where_token {\n             return;\n         }\n \n@@ -2739,7 +2739,11 @@ impl<'a> State<'a> {\n         }\n         let generics = ast::Generics {\n             params: Vec::new(),\n-            where_clause: ast::WhereClause { predicates: Vec::new(), span: rustc_span::DUMMY_SP },\n+            where_clause: ast::WhereClause {\n+                has_where_token: false,\n+                predicates: Vec::new(),\n+                span: rustc_span::DUMMY_SP,\n+            },\n             span: rustc_span::DUMMY_SP,\n         };\n         let header = ast::FnHeader { unsafety, ext, ..ast::FnHeader::default() };"}, {"sha": "480ee97f20552c7e2b2a1d33980859734e3b3c4f", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -391,7 +391,8 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n         used[*pos] = true;\n     }\n \n-    let named_pos: FxHashSet<usize> = args.named_args.values().cloned().collect();\n+    let named_pos: FxHashMap<usize, Symbol> =\n+        args.named_args.iter().map(|(&sym, &idx)| (idx, sym)).collect();\n     let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n     let mut template = vec![];\n     for piece in unverified_pieces {\n@@ -405,7 +406,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n                 let operand_idx = match arg.position {\n                     parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n                         if idx >= args.operands.len()\n-                            || named_pos.contains(&idx)\n+                            || named_pos.contains_key(&idx)\n                             || args.reg_args.contains(&idx)\n                         {\n                             let msg = format!(\"invalid reference to argument at index {}\", idx);\n@@ -426,7 +427,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n                             };\n                             err.note(&msg);\n \n-                            if named_pos.contains(&idx) {\n+                            if named_pos.contains_key(&idx) {\n                                 err.span_label(args.operands[idx].1, \"named argument\");\n                                 err.span_note(\n                                     args.operands[idx].1,\n@@ -457,7 +458,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n \n                 let mut chars = arg.format.ty.chars();\n                 let mut modifier = chars.next();\n-                if !chars.next().is_none() {\n+                if chars.next().is_some() {\n                     let span = arg\n                         .format\n                         .ty_span\n@@ -480,27 +481,31 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n         }\n     }\n \n-    let operands = args.operands;\n-    let unused_operands: Vec<_> = used\n-        .into_iter()\n-        .enumerate()\n-        .filter(|&(_, used)| !used)\n-        .map(|(idx, _)| {\n-            if named_pos.contains(&idx) {\n-                // named argument\n-                (operands[idx].1, \"named argument never used\")\n+    let mut unused_operands = vec![];\n+    let mut help_str = String::new();\n+    for (idx, used) in used.into_iter().enumerate() {\n+        if !used {\n+            let msg = if let Some(sym) = named_pos.get(&idx) {\n+                help_str.push_str(&format!(\" {{{}}}\", sym));\n+                \"named argument never used\"\n             } else {\n-                // positional argument\n-                (operands[idx].1, \"argument never used\")\n-            }\n-        })\n-        .collect();\n+                help_str.push_str(&format!(\" {{{}}}\", idx));\n+                \"argument never used\"\n+            };\n+            unused_operands.push((args.operands[idx].1, msg));\n+        }\n+    }\n     match unused_operands.len() {\n         0 => {}\n         1 => {\n             let (sp, msg) = unused_operands.into_iter().next().unwrap();\n             let mut err = ecx.struct_span_err(sp, msg);\n             err.span_label(sp, msg);\n+            err.help(&format!(\n+                \"if this argument is intentionally unused, \\\n+                 consider using it in an asm comment: `\\\"/*{} */\\\"`\",\n+                help_str\n+            ));\n             err.emit();\n         }\n         _ => {\n@@ -511,6 +516,11 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n             for (sp, msg) in unused_operands {\n                 err.span_label(sp, msg);\n             }\n+            err.help(&format!(\n+                \"if these arguments are intentionally unused, \\\n+                 consider using them in an asm comment: `\\\"/*{} */\\\"`\",\n+                help_str\n+            ));\n             err.emit();\n         }\n     }\n@@ -521,7 +531,8 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n         parser.line_spans.iter().map(|span| template_span.from_inner(*span)).collect()\n     };\n \n-    let inline_asm = ast::InlineAsm { template, operands, options: args.options, line_spans };\n+    let inline_asm =\n+        ast::InlineAsm { template, operands: args.operands, options: args.options, line_spans };\n     P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         kind: ast::ExprKind::InlineAsm(P(inline_asm)),"}, {"sha": "609feb6f259d6a9647de777421155b398b347340", "filename": "src/librustc_builtin_macros/deriving/generic/ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -216,7 +216,11 @@ fn mk_ty_param(\n }\n \n fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n-    Generics { params, where_clause: ast::WhereClause { predicates: Vec::new(), span }, span }\n+    Generics {\n+        params,\n+        where_clause: ast::WhereClause { has_where_token: false, predicates: Vec::new(), span },\n+        span,\n+    }\n }\n \n /// Lifetimes and bounds on type parameters"}, {"sha": "1b164eae5a34594eb10a36d7d3c313cb348020d9", "filename": "src/librustc_builtin_macros/source_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fsource_util.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -122,6 +122,7 @@ pub fn expand_include<'cx>(\n \n     struct ExpandResult<'a> {\n         p: Parser<'a>,\n+        node_id: ast::NodeId,\n     }\n     impl<'a> base::MacResult for ExpandResult<'a> {\n         fn make_expr(mut self: Box<ExpandResult<'a>>) -> Option<P<ast::Expr>> {\n@@ -130,7 +131,7 @@ pub fn expand_include<'cx>(\n                 self.p.sess.buffer_lint(\n                     &INCOMPLETE_INCLUDE,\n                     self.p.token.span,\n-                    ast::CRATE_NODE_ID,\n+                    self.node_id,\n                     \"include macro expected single expression in source\",\n                 );\n             }\n@@ -158,7 +159,7 @@ pub fn expand_include<'cx>(\n         }\n     }\n \n-    Box::new(ExpandResult { p })\n+    Box::new(ExpandResult { p, node_id: cx.resolver.lint_node_id(cx.current_expansion.id) })\n }\n \n // include_str! : read the given file, insert it as a literal string expr"}, {"sha": "099c402703d09f44260df9feab87947654dadcf5", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -375,6 +375,8 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         match self.conv {\n             Conv::C | Conv::Rust => llvm::CCallConv,\n             Conv::AmdGpuKernel => llvm::AmdGpuKernel,\n+            Conv::AvrInterrupt => llvm::AvrInterrupt,\n+            Conv::AvrNonBlockingInterrupt => llvm::AvrNonBlockingInterrupt,\n             Conv::ArmAapcs => llvm::ArmAapcsCallConv,\n             Conv::Msp430Intr => llvm::Msp430Intr,\n             Conv::PtxKernel => llvm::PtxKernel,"}, {"sha": "26f5334668b8fd0d5cb5a5fc57d012ca179696e1", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -16,7 +16,7 @@ use rustc_codegen_ssa::back::write::{BitcodeSection, CodegenContext, EmitObj, Mo\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc_errors::{FatalError, Handler};\n+use rustc_errors::{FatalError, Handler, Level};\n use rustc_fs_util::{link_or_copy, path_to_c_string};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n@@ -242,6 +242,7 @@ impl<'a> Drop for DiagnosticHandlers<'a> {\n fn report_inline_asm(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     msg: String,\n+    level: llvm::DiagnosticLevel,\n     mut cookie: c_uint,\n     source: Option<(String, Vec<InnerSpan>)>,\n ) {\n@@ -251,7 +252,12 @@ fn report_inline_asm(\n     if matches!(cgcx.lto, Lto::Fat | Lto::Thin) {\n         cookie = 0;\n     }\n-    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg, source);\n+    let level = match level {\n+        llvm::DiagnosticLevel::Error => Level::Error,\n+        llvm::DiagnosticLevel::Warning => Level::Warning,\n+        llvm::DiagnosticLevel::Note | llvm::DiagnosticLevel::Remark => Level::Note,\n+    };\n+    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg, level, source);\n }\n \n unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void, cookie: c_uint) {\n@@ -264,6 +270,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void\n     // diagnostics.\n     let mut have_source = false;\n     let mut buffer = String::new();\n+    let mut level = llvm::DiagnosticLevel::Error;\n     let mut loc = 0;\n     let mut ranges = [0; 8];\n     let mut num_ranges = ranges.len() / 2;\n@@ -273,6 +280,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void\n                 diag,\n                 msg,\n                 buffer,\n+                &mut level,\n                 &mut loc,\n                 ranges.as_mut_ptr(),\n                 &mut num_ranges,\n@@ -290,7 +298,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void\n         (buffer, spans)\n     });\n \n-    report_inline_asm(cgcx, msg, cookie, source);\n+    report_inline_asm(cgcx, msg, level, cookie, source);\n }\n \n unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void) {\n@@ -301,7 +309,13 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n-            report_inline_asm(cgcx, llvm::twine_to_string(inline.message), inline.cookie, None);\n+            report_inline_asm(\n+                cgcx,\n+                llvm::twine_to_string(inline.message),\n+                inline.level,\n+                inline.cookie,\n+                None,\n+            );\n         }\n \n         llvm::diagnostic::Optimization(opt) => {"}, {"sha": "47f5c94e70c532fae1269884cc0c69529f0abe26", "filename": "src/librustc_codegen_llvm/llvm/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -88,6 +88,7 @@ impl OptimizationDiagnostic<'ll> {\n \n #[derive(Copy, Clone)]\n pub struct InlineAsmDiagnostic<'ll> {\n+    pub level: super::DiagnosticLevel,\n     pub cookie: c_uint,\n     pub message: &'ll Twine,\n     pub instruction: Option<&'ll Value>,\n@@ -98,10 +99,17 @@ impl InlineAsmDiagnostic<'ll> {\n         let mut cookie = 0;\n         let mut message = None;\n         let mut instruction = None;\n+        let mut level = super::DiagnosticLevel::Error;\n \n-        super::LLVMRustUnpackInlineAsmDiagnostic(di, &mut cookie, &mut message, &mut instruction);\n+        super::LLVMRustUnpackInlineAsmDiagnostic(\n+            di,\n+            &mut level,\n+            &mut cookie,\n+            &mut message,\n+            &mut instruction,\n+        );\n \n-        InlineAsmDiagnostic { cookie, message: message.unwrap(), instruction }\n+        InlineAsmDiagnostic { level, cookie, message: message.unwrap(), instruction }\n     }\n }\n "}, {"sha": "54cf99e1c6d6cfdf5d3b48313bdd4bc6c7774cfb", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -45,6 +45,8 @@ pub enum CallConv {\n     X86_64_Win64 = 79,\n     X86_VectorCall = 80,\n     X86_Intr = 83,\n+    AvrNonBlockingInterrupt = 84,\n+    AvrInterrupt = 85,\n     AmdGpuKernel = 91,\n }\n \n@@ -489,6 +491,17 @@ pub enum DiagnosticKind {\n     Linker,\n }\n \n+/// LLVMRustDiagnosticLevel\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+#[allow(dead_code)] // Variants constructed by C++.\n+pub enum DiagnosticLevel {\n+    Error,\n+    Warning,\n+    Note,\n+    Remark,\n+}\n+\n /// LLVMRustArchiveKind\n #[derive(Copy, Clone)]\n #[repr(C)]\n@@ -2054,6 +2067,7 @@ extern \"C\" {\n \n     pub fn LLVMRustUnpackInlineAsmDiagnostic(\n         DI: &'a DiagnosticInfo,\n+        level_out: &mut DiagnosticLevel,\n         cookie_out: &mut c_uint,\n         message_out: &mut Option<&'a Twine>,\n         instruction_out: &mut Option<&'a Value>,\n@@ -2074,6 +2088,7 @@ extern \"C\" {\n         d: &SMDiagnostic,\n         message_out: &RustString,\n         buffer_out: &RustString,\n+        level_out: &mut DiagnosticLevel,\n         loc_out: &mut c_uint,\n         ranges_out: *mut c_uint,\n         num_ranges: &mut usize,"}, {"sha": "c118e5ebdb72d780d70aea6a90d4cf2feabc509a", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1551,7 +1551,7 @@ fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>\n \n enum SharedEmitterMessage {\n     Diagnostic(Diagnostic),\n-    InlineAsmError(u32, String, Option<(String, Vec<InnerSpan>)>),\n+    InlineAsmError(u32, String, Level, Option<(String, Vec<InnerSpan>)>),\n     AbortIfErrors,\n     Fatal(String),\n }\n@@ -1576,9 +1576,10 @@ impl SharedEmitter {\n         &self,\n         cookie: u32,\n         msg: String,\n+        level: Level,\n         source: Option<(String, Vec<InnerSpan>)>,\n     ) {\n-        drop(self.sender.send(SharedEmitterMessage::InlineAsmError(cookie, msg, source)));\n+        drop(self.sender.send(SharedEmitterMessage::InlineAsmError(cookie, msg, level, source)));\n     }\n \n     pub fn fatal(&self, msg: &str) {\n@@ -1631,16 +1632,21 @@ impl SharedEmitterMain {\n                     }\n                     handler.emit_diagnostic(&d);\n                 }\n-                Ok(SharedEmitterMessage::InlineAsmError(cookie, msg, source)) => {\n+                Ok(SharedEmitterMessage::InlineAsmError(cookie, msg, level, source)) => {\n                     let msg = msg.strip_prefix(\"error: \").unwrap_or(&msg);\n \n+                    let mut err = match level {\n+                        Level::Error => sess.struct_err(&msg),\n+                        Level::Warning => sess.struct_warn(&msg),\n+                        Level::Note => sess.struct_note_without_error(&msg),\n+                        _ => bug!(\"Invalid inline asm diagnostic level\"),\n+                    };\n+\n                     // If the cookie is 0 then we don't have span information.\n-                    let mut err = if cookie == 0 {\n-                        sess.struct_err(&msg)\n-                    } else {\n+                    if cookie != 0 {\n                         let pos = BytePos::from_u32(cookie);\n                         let span = Span::with_root_ctxt(pos, pos);\n-                        sess.struct_span_err(span, &msg)\n+                        err.set_span(span);\n                     };\n \n                     // Point to the generated assembly if it is available."}, {"sha": "ef59ad486eefe5fa12be6cebef0f19de2fc282a1", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -530,6 +530,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         args: &Vec<mir::Operand<'tcx>>,\n         destination: &Option<(mir::Place<'tcx>, mir::BasicBlock)>,\n         cleanup: Option<mir::BasicBlock>,\n+        fn_span: Span,\n     ) {\n         let span = terminator.source_info.span;\n         // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n@@ -634,7 +635,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if intrinsic == Some(\"caller_location\") {\n             if let Some((_, target)) = destination.as_ref() {\n-                let location = self.get_caller_location(&mut bx, span);\n+                let location = self.get_caller_location(&mut bx, fn_span);\n \n                 if let ReturnDest::IndirectOperand(tmp, _) = ret_dest {\n                     location.val.store(&mut bx, tmp);\n@@ -798,7 +799,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 args.len() + 1,\n                 \"#[track_caller] fn's must have 1 more argument in their ABI than in their MIR\",\n             );\n-            let location = self.get_caller_location(&mut bx, span);\n+            let location = self.get_caller_location(&mut bx, fn_span);\n+            debug!(\n+                \"codegen_call_terminator({:?}): location={:?} (fn_span {:?})\",\n+                terminator, location, fn_span\n+            );\n+\n             let last_arg = fn_abi.args.last().unwrap();\n             self.codegen_argument(&mut bx, location, &mut llargs, last_arg);\n         }\n@@ -921,12 +927,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         span_bug!(span, \"invalid type for asm sym (fn)\");\n                     }\n                 }\n-                mir::InlineAsmOperand::SymStatic { ref value } => {\n-                    if let Some(def_id) = value.check_static_ptr(bx.tcx()) {\n-                        InlineAsmOperandRef::SymStatic { def_id }\n-                    } else {\n-                        span_bug!(span, \"invalid type for asm sym (static)\");\n-                    }\n+                mir::InlineAsmOperand::SymStatic { def_id } => {\n+                    InlineAsmOperandRef::SymStatic { def_id }\n                 }\n             })\n             .collect();\n@@ -1016,6 +1018,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 ref destination,\n                 cleanup,\n                 from_hir_call: _,\n+                fn_span,\n             } => {\n                 self.codegen_call_terminator(\n                     helper,\n@@ -1025,6 +1028,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     args,\n                     destination,\n                     cleanup,\n+                    fn_span,\n                 );\n             }\n             mir::TerminatorKind::GeneratorDrop | mir::TerminatorKind::Yield { .. } => {"}, {"sha": "11ec62f96ed38d60179f5c37c357ab74eee9f954", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     .tcx()\n                     .destructure_const(ty::ParamEnv::reveal_all().and(&c))\n                     .fields\n-                    .into_iter()\n+                    .iter()\n                     .map(|field| {\n                         if let Some(prim) = field.val.try_to_scalar() {\n                             let layout = bx.layout_of(field_ty);"}, {"sha": "b68ef1eb7f4c4da88d381afdd2ba2f86c9dfaff2", "filename": "src/librustc_data_structures/base_n/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -12,8 +12,8 @@ fn test_encode() {\n         test(35, base);\n         test(36, base);\n         test(37, base);\n-        test(u64::max_value() as u128, base);\n-        test(u128::max_value(), base);\n+        test(u64::MAX as u128, base);\n+        test(u128::MAX, base);\n \n         for i in 0..1_000 {\n             test(i * 983, base);"}, {"sha": "3fb5e04efc9227953ea9efd18215fc8aac0dc11c", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -409,6 +409,7 @@ E0718: include_str!(\"./error_codes/E0718.md\"),\n E0719: include_str!(\"./error_codes/E0719.md\"),\n E0720: include_str!(\"./error_codes/E0720.md\"),\n E0723: include_str!(\"./error_codes/E0723.md\"),\n+E0724: include_str!(\"./error_codes/E0724.md\"),\n E0725: include_str!(\"./error_codes/E0725.md\"),\n E0727: include_str!(\"./error_codes/E0727.md\"),\n E0728: include_str!(\"./error_codes/E0728.md\"),\n@@ -440,6 +441,7 @@ E0754: include_str!(\"./error_codes/E0754.md\"),\n E0758: include_str!(\"./error_codes/E0758.md\"),\n E0760: include_str!(\"./error_codes/E0760.md\"),\n E0761: include_str!(\"./error_codes/E0761.md\"),\n+E0762: include_str!(\"./error_codes/E0762.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard\n@@ -616,7 +618,6 @@ E0761: include_str!(\"./error_codes/E0761.md\"),\n     E0717, // rustc_promotable without stability attribute\n //  E0721, // `await` keyword\n     E0722, // Malformed `#[optimize]` attribute\n-    E0724, // `#[ffi_returns_twice]` is only allowed in foreign functions\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n     E0755, // `#[ffi_pure]` is only allowed on foreign functions"}, {"sha": "6ec47c4962c06fc50414a955175a039b6ab2f604", "filename": "src/librustc_error_codes/error_codes/E0446.md", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -4,10 +4,10 @@ Erroneous code example:\n \n ```compile_fail,E0446\n #![deny(private_in_public)]\n+struct Bar(u32);\n \n-mod Foo {\n-    struct Bar(u32);\n-\n+mod foo {\n+    use crate::Bar;\n     pub fn bar() -> Bar { // error: private type in public interface\n         Bar(0)\n     }\n@@ -16,15 +16,31 @@ mod Foo {\n fn main() {}\n ```\n \n-To solve this error, please ensure that the type is also public. The type\n-can be made inaccessible if necessary by placing it into a private inner\n-module, but it still has to be marked with `pub`.\n+There are two ways to solve this error. The first is to make the public type\n+signature only public to a module that also has access to the private type.\n+This is done by using pub(crate) or pub(in crate::my_mod::etc)\n Example:\n \n ```\n-mod Foo {\n-    pub struct Bar(u32); // we set the Bar type public\n+struct Bar(u32);\n+\n+mod foo {\n+    use crate::Bar;\n+    pub(crate) fn bar() -> Bar { // only public to crate root\n+        Bar(0)\n+    }\n+}\n \n+fn main() {}\n+```\n+\n+The other way to solve this error is to make the private type public.\n+Example:\n+\n+```\n+pub struct Bar(u32); // we set the Bar type public\n+mod foo {\n+    use crate::Bar;\n     pub fn bar() -> Bar { // ok!\n         Bar(0)\n     }"}, {"sha": "0dcc3b62b4b2f66258b154a8b443989abef6bb49", "filename": "src/librustc_error_codes/error_codes/E0493.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,5 +1,4 @@\n-A type with a `Drop` implementation was destructured when trying to initialize\n-a static item.\n+A value with a custom `Drop` implementation may be dropped during const-eval.\n \n Erroneous code example:\n \n@@ -16,13 +15,14 @@ struct Foo {\n     field1: DropType,\n }\n \n-static FOO: Foo = Foo { ..Foo { field1: DropType::A } }; // error!\n+static FOO: Foo = Foo { field1: (DropType::A, DropType::A).1 }; // error!\n ```\n \n The problem here is that if the given type or one of its fields implements the\n-`Drop` trait, this `Drop` implementation cannot be called during the static\n-type initialization which might cause a memory leak. To prevent this issue,\n-you need to instantiate all the static type's fields by hand.\n+`Drop` trait, this `Drop` implementation cannot be called within a const\n+context since it may run arbitrary, non-const-checked code. To prevent this\n+issue, ensure all values with custom a custom `Drop` implementation escape the\n+initializer.\n \n ```\n enum DropType {"}, {"sha": "c790aa154bde933247e1fed9d5df1a7809dd3794", "filename": "src/librustc_error_codes/error_codes/E0642.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0642.md", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0642.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0642.md?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,6 +1,6 @@\n Trait methods currently cannot take patterns as arguments.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0642\n trait Foo {"}, {"sha": "d99dc19503ddbe557dcca6287190758109b5d226", "filename": "src/librustc_error_codes/error_codes/E0648.md", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0648.md", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0648.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0648.md?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,6 +1,15 @@\n-`export_name` attributes may not contain null characters (`\\0`).\n+An `export_name` attribute contains null characters (`\\0`).\n+\n+Erroneous code example:\n \n ```compile_fail,E0648\n #[export_name=\"\\0foo\"] // error: `export_name` may not contain null characters\n pub fn bar() {}\n ```\n+\n+To fix this error, remove the null characters:\n+\n+```\n+#[export_name=\"foo\"] // ok!\n+pub fn bar() {}\n+```"}, {"sha": "1a0dc5a522962a06d263754e69df94fd8996aeae", "filename": "src/librustc_error_codes/error_codes/E0666.md", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0666.md", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0666.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0666.md?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,21 +1,25 @@\n-`impl Trait` types cannot appear nested in the\n-generic arguments of other `impl Trait` types.\n+`impl Trait` types cannot appear nested in the generic arguments of other\n+`impl Trait` types.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0666\n trait MyGenericTrait<T> {}\n trait MyInnerTrait {}\n \n-fn foo(bar: impl MyGenericTrait<impl MyInnerTrait>) {}\n+fn foo(\n+    bar: impl MyGenericTrait<impl MyInnerTrait>, // error!\n+) {}\n ```\n \n-Type parameters for `impl Trait` types must be\n-explicitly defined as named generic parameters:\n+Type parameters for `impl Trait` types must be explicitly defined as named\n+generic parameters:\n \n ```\n trait MyGenericTrait<T> {}\n trait MyInnerTrait {}\n \n-fn foo<T: MyInnerTrait>(bar: impl MyGenericTrait<T>) {}\n+fn foo<T: MyInnerTrait>(\n+    bar: impl MyGenericTrait<T>, // ok!\n+) {}\n ```"}, {"sha": "7a7ba15485434836c9754da42db925d1a098a5d8", "filename": "src/librustc_error_codes/error_codes/E0724.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0724.md", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0724.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0724.md?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,24 @@\n+`#[ffi_returns_twice]` was used on non-foreign function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0724\n+#![feature(ffi_returns_twice)]\n+#![crate_type = \"lib\"]\n+\n+#[ffi_returns_twice] // error!\n+pub fn foo() {}\n+```\n+\n+`#[ffi_returns_twice]` can only be used on foreign function declarations.\n+For example, we might correct the previous example by declaring\n+the function inside of an\u00a0`extern`\u00a0block.\n+\n+```\n+#![feature(ffi_returns_twice)]\n+\n+extern {\n+   #[ffi_returns_twice] // ok!\n+   pub fn foo();\n+}\n+```"}, {"sha": "b01ded4a86616eba3664c40e47f6da2f2830a78d", "filename": "src/librustc_error_codes/error_codes/E0762.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0762.md", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_error_codes%2Ferror_codes%2FE0762.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0762.md?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,13 @@\n+A character literal wasn't ended with a quote.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0762\n+static C: char = '\u25cf; // error!\n+```\n+\n+To fix this error, add the missing quote:\n+\n+```\n+static C: char = '\u25cf'; // ok!\n+```"}, {"sha": "265ba59cccb2aff70a7ce6449b179805909a3bad", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -159,14 +159,10 @@ impl AnnotateSnippetEmitterWriter {\n                             // FIXME(#59346): Not really sure when `fold` should be true or false\n                             fold: false,\n                             annotations: annotations\n-                                .into_iter()\n+                                .iter()\n                                 .map(|annotation| SourceAnnotation {\n                                     range: (annotation.start_col, annotation.end_col),\n-                                    label: annotation\n-                                        .label\n-                                        .as_ref()\n-                                        .map(|s| s.as_str())\n-                                        .unwrap_or_default(),\n+                                    label: annotation.label.as_deref().unwrap_or_default(),\n                                     annotation_type: annotation_type_for_level(*level),\n                                 })\n                                 .collect(),"}, {"sha": "acaa26c6ad2fc609b72adbc4c8f79761e3ab902e", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -296,6 +296,29 @@ impl Diagnostic {\n         self\n     }\n \n+    pub fn multipart_suggestions(\n+        &mut self,\n+        msg: &str,\n+        suggestions: Vec<Vec<(Span, String)>>,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        self.suggestions.push(CodeSuggestion {\n+            substitutions: suggestions\n+                .into_iter()\n+                .map(|suggestion| Substitution {\n+                    parts: suggestion\n+                        .into_iter()\n+                        .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                        .collect(),\n+                })\n+                .collect(),\n+            msg: msg.to_owned(),\n+            style: SuggestionStyle::ShowCode,\n+            applicability,\n+        });\n+        self\n+    }\n+\n     /// Prints out a message with for a multipart suggestion without showing the suggested code.\n     ///\n     /// This is intended to be used for suggestions that are obvious in what the changes need to"}, {"sha": "22bf8fe34aa155543c72fa41ad11d746ec1c8ee3", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -260,6 +260,19 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    pub fn multipart_suggestions(\n+        &mut self,\n+        msg: &str,\n+        suggestions: Vec<Vec<(Span, String)>>,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        if !self.0.allow_suggestions {\n+            return self;\n+        }\n+        self.0.diagnostic.multipart_suggestions(msg, suggestions, applicability);\n+        self\n+    }\n+\n     pub fn tool_only_multipart_suggestion(\n         &mut self,\n         msg: &str,"}, {"sha": "7261c638ce013985ebda6b92aa7dcf640ec4a56b", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -581,6 +581,11 @@ impl Handler {\n         DiagnosticBuilder::new(self, Level::Help, msg)\n     }\n \n+    /// Construct a builder at the `Note` level with the `msg`.\n+    pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+        DiagnosticBuilder::new(self, Level::Note, msg)\n+    }\n+\n     pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: &str) -> FatalError {\n         self.emit_diag_at_span(Diagnostic::new(Fatal, msg), span);\n         FatalError"}, {"sha": "a57ae798ffcebf34fe6d8bd87ac776c05f195105", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -915,6 +915,9 @@ pub trait Resolver {\n \n     fn check_unused_macros(&mut self);\n \n+    /// Some parent node that is close enough to the given macro call.\n+    fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId;\n+\n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool;\n     fn add_derive_copy(&mut self, expn_id: ExpnId);\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;"}, {"sha": "20d2ea0a215d4ac8ced615dda3f0443944b7a9dd", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -272,7 +272,7 @@ impl<'a> ExtCtxt<'a> {\n     ) -> P<ast::Expr> {\n         args.insert(0, expr);\n         let segment = ast::PathSegment::from_ident(ident.with_span_pos(span));\n-        self.expr(span, ast::ExprKind::MethodCall(segment, args))\n+        self.expr(span, ast::ExprKind::MethodCall(segment, args, span))\n     }\n     pub fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(b.span, ast::ExprKind::Block(b, None))"}, {"sha": "ca3e68fa6706e25972862965cb03b148d9b942c2", "filename": "src/librustc_expand/mbe/macro_check.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -106,7 +106,7 @@\n //! bound.\n use crate::mbe::{KleeneToken, TokenTree};\n \n-use rustc_ast::ast::NodeId;\n+use rustc_ast::ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_session::lint::builtin::META_VARIABLE_MISUSE;\n@@ -626,5 +626,8 @@ fn ops_is_prefix(\n }\n \n fn buffer_lint(sess: &ParseSess, span: MultiSpan, node_id: NodeId, message: &str) {\n-    sess.buffer_lint(&META_VARIABLE_MISUSE, span, node_id, message);\n+    // Macros loaded from other crates have dummy node ids.\n+    if node_id != DUMMY_NODE_ID {\n+        sess.buffer_lint(&META_VARIABLE_MISUSE, span, node_id, message);\n+    }\n }"}, {"sha": "db8258a77863b8c3d3043fa656dd8267f2decdfe", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -383,7 +383,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                 }\n             }\n             TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n-                if sess.missing_fragment_specifiers.borrow_mut().remove(&span) {\n+                if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                     return Err((span, \"missing fragment specifier\".to_string()));\n                 }\n             }\n@@ -566,7 +566,7 @@ fn inner_parse_loop<'root, 'tt>(\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n                 TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n-                    if sess.missing_fragment_specifiers.borrow_mut().remove(&span) {\n+                    if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                         return Error(span, \"missing fragment specifier\".to_string());\n                     }\n                 }"}, {"sha": "8cdb5b09c9e8b3dade6fdab096cc3391df435631", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -474,7 +474,9 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = mbe::quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n+                        let tt = mbe::quoted::parse(tt.clone().into(), true, sess, def.id)\n+                            .pop()\n+                            .unwrap();\n                         valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n@@ -491,7 +493,9 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return mbe::quoted::parse(tt.clone().into(), false, sess).pop().unwrap();\n+                        return mbe::quoted::parse(tt.clone().into(), false, sess, def.id)\n+                            .pop()\n+                            .unwrap();\n                     }\n                 }\n                 sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n@@ -509,9 +513,7 @@ pub fn compile_declarative_macro(\n         valid &= check_lhs_no_empty_seq(sess, slice::from_ref(lhs));\n     }\n \n-    // We use CRATE_NODE_ID instead of `def.id` otherwise we may emit buffered lints for a node id\n-    // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n-    valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n+    valid &= macro_check::check_meta_variables(sess, def.id, def.span, &lhses, &rhses);\n \n     let (transparency, transparency_error) = attr::find_transparency(&def.attrs, macro_rules);\n     match transparency_error {"}, {"sha": "de66c2ada40e62ff32c72272c4f3bce76518b80c", "filename": "src/librustc_expand/mbe/quoted.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,6 +1,7 @@\n use crate::mbe::macro_parser;\n use crate::mbe::{Delimited, KleeneOp, KleeneToken, SequenceRepetition, TokenTree};\n \n+use rustc_ast::ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream;\n use rustc_ast_pretty::pprust;\n@@ -36,6 +37,7 @@ pub(super) fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,\n+    node_id: NodeId,\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n@@ -46,7 +48,7 @@ pub(super) fn parse(\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e., in `$id:ident` this would parse the `:` and `ident`).\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess);\n+        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id);\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -65,7 +67,10 @@ pub(super) fn parse(\n                     }\n                     tree => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(start_sp),\n                 };\n-                sess.missing_fragment_specifiers.borrow_mut().insert(span);\n+                if node_id != DUMMY_NODE_ID {\n+                    // Macros loaded from other crates have dummy node ids.\n+                    sess.missing_fragment_specifiers.borrow_mut().insert(span, node_id);\n+                }\n                 result.push(TokenTree::MetaVarDecl(span, ident, Ident::invalid()));\n             }\n \n@@ -96,6 +101,7 @@ fn parse_tree(\n     trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n+    node_id: NodeId,\n ) -> TokenTree {\n     // Depending on what `tree` is, we could be parsing different parts of a macro\n     match tree {\n@@ -111,7 +117,7 @@ fn parse_tree(\n                     sess.span_diagnostic.span_err(span.entire(), &msg);\n                 }\n                 // Parse the contents of the sequence itself\n-                let sequence = parse(tts, expect_matchers, sess);\n+                let sequence = parse(tts, expect_matchers, sess, node_id);\n                 // Get the Kleene operator and optional separator\n                 let (separator, kleene) = parse_sep_and_kleene_op(trees, span.entire(), sess);\n                 // Count the number of captured \"names\" (i.e., named metavars)\n@@ -158,7 +164,7 @@ fn parse_tree(\n         // descend into the delimited set and further parse it.\n         tokenstream::TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n             span,\n-            Lrc::new(Delimited { delim, tts: parse(tts, expect_matchers, sess) }),\n+            Lrc::new(Delimited { delim, tts: parse(tts, expect_matchers, sess, node_id) }),\n         ),\n     }\n }"}, {"sha": "ea55674045c0f73ed49019ffa94c4693a29c6a58", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -582,10 +582,10 @@ impl server::Literal for Rustc<'_> {\n         };\n \n         // Bounds check the values, preventing addition overflow and OOB spans.\n-        if start > u32::max_value() as usize\n-            || end > u32::max_value() as usize\n-            || (u32::max_value() - start as u32) < span.lo().to_u32()\n-            || (u32::max_value() - end as u32) < span.lo().to_u32()\n+        if start > u32::MAX as usize\n+            || end > u32::MAX as usize\n+            || (u32::MAX - start as u32) < span.lo().to_u32()\n+            || (u32::MAX - end as u32) < span.lo().to_u32()\n             || start >= end\n             || end > length\n         {"}, {"sha": "d186f35a12b5a1f9566ea39b2aa4e05a532af4d0", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -574,6 +574,12 @@ declare_features! (\n     /// No longer treat an unsafe function as an unsafe block.\n     (active, unsafe_block_in_unsafe_fn, \"1.45.0\", Some(71668), None),\n \n+    /// Allows `extern \"avr-interrupt\" fn()` and `extern \"avr-non-blocking-interrupt\" fn()`.\n+    (active, abi_avr_interrupt, \"1.45.0\", Some(69664), None),\n+\n+    /// Be more precise when looking for live drops in a const context.\n+    (active, const_precise_live_drops, \"1.46.0\", Some(73255), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "f439db715310cc1ac204ffffd302786b81e53aaf", "filename": "src/librustc_hir/arena.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Farena.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -12,41 +12,41 @@ macro_rules! arena_types {\n     ($macro:path, $args:tt, $tcx:lifetime) => (\n         $macro!($args, [\n             // HIR types\n-            [few] hir_krate: rustc_hir::Crate<$tcx>,\n-            [] arm: rustc_hir::Arm<$tcx>,\n-            [] asm_operand: rustc_hir::InlineAsmOperand<$tcx>,\n-            [] asm_template: rustc_ast::ast::InlineAsmTemplatePiece,\n-            [] attribute: rustc_ast::ast::Attribute,\n-            [] block: rustc_hir::Block<$tcx>,\n-            [] bare_fn_ty: rustc_hir::BareFnTy<$tcx>,\n-            [few] global_asm: rustc_hir::GlobalAsm,\n-            [] generic_arg: rustc_hir::GenericArg<$tcx>,\n-            [] generic_args: rustc_hir::GenericArgs<$tcx>,\n-            [] generic_bound: rustc_hir::GenericBound<$tcx>,\n-            [] generic_param: rustc_hir::GenericParam<$tcx>,\n-            [] expr: rustc_hir::Expr<$tcx>,\n-            [] field: rustc_hir::Field<$tcx>,\n-            [] field_pat: rustc_hir::FieldPat<$tcx>,\n-            [] fn_decl: rustc_hir::FnDecl<$tcx>,\n-            [] foreign_item: rustc_hir::ForeignItem<$tcx>,\n-            [] impl_item_ref: rustc_hir::ImplItemRef<$tcx>,\n-            [few] inline_asm: rustc_hir::InlineAsm<$tcx>,\n-            [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n-            [] local: rustc_hir::Local<$tcx>,\n-            [few] macro_def: rustc_hir::MacroDef<$tcx>,\n-            [] param: rustc_hir::Param<$tcx>,\n-            [] pat: rustc_hir::Pat<$tcx>,\n-            [] path: rustc_hir::Path<$tcx>,\n-            [] path_segment: rustc_hir::PathSegment<$tcx>,\n-            [] poly_trait_ref: rustc_hir::PolyTraitRef<$tcx>,\n-            [] qpath: rustc_hir::QPath<$tcx>,\n-            [] stmt: rustc_hir::Stmt<$tcx>,\n-            [] struct_field: rustc_hir::StructField<$tcx>,\n-            [] trait_item_ref: rustc_hir::TraitItemRef,\n-            [] ty: rustc_hir::Ty<$tcx>,\n-            [] type_binding: rustc_hir::TypeBinding<$tcx>,\n-            [] variant: rustc_hir::Variant<$tcx>,\n-            [] where_predicate: rustc_hir::WherePredicate<$tcx>,\n+            [few] hir_krate: rustc_hir::Crate<$tcx>, rustc_hir::Crate<'_x>;\n+            [] arm: rustc_hir::Arm<$tcx>, rustc_hir::Arm<'_x>;\n+            [] asm_operand: rustc_hir::InlineAsmOperand<$tcx>, rustc_hir::InlineAsmOperand<'_x>;\n+            [] asm_template: rustc_ast::ast::InlineAsmTemplatePiece, rustc_ast::ast::InlineAsmTemplatePiece;\n+            [] attribute: rustc_ast::ast::Attribute, rustc_ast::ast::Attribute;\n+            [] block: rustc_hir::Block<$tcx>, rustc_hir::Block<'_x>;\n+            [] bare_fn_ty: rustc_hir::BareFnTy<$tcx>, rustc_hir::BareFnTy<'_x>;\n+            [few] global_asm: rustc_hir::GlobalAsm, rustc_hir::GlobalAsm;\n+            [] generic_arg: rustc_hir::GenericArg<$tcx>, rustc_hir::GenericArg<'_x>;\n+            [] generic_args: rustc_hir::GenericArgs<$tcx>, rustc_hir::GenericArgs<'_x>;\n+            [] generic_bound: rustc_hir::GenericBound<$tcx>, rustc_hir::GenericBound<'_x>;\n+            [] generic_param: rustc_hir::GenericParam<$tcx>, rustc_hir::GenericParam<'_x>;\n+            [] expr: rustc_hir::Expr<$tcx>, rustc_hir::Expr<'_x>;\n+            [] field: rustc_hir::Field<$tcx>, rustc_hir::Field<'_x>;\n+            [] field_pat: rustc_hir::FieldPat<$tcx>, rustc_hir::FieldPat<'_x>;\n+            [] fn_decl: rustc_hir::FnDecl<$tcx>, rustc_hir::FnDecl<'_x>;\n+            [] foreign_item: rustc_hir::ForeignItem<$tcx>, rustc_hir::ForeignItem<'_x>;\n+            [] impl_item_ref: rustc_hir::ImplItemRef<$tcx>, rustc_hir::ImplItemRef<'_x>;\n+            [few] inline_asm: rustc_hir::InlineAsm<$tcx>, rustc_hir::InlineAsm<'_x>;\n+            [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>, rustc_hir::LlvmInlineAsm<'_x>;\n+            [] local: rustc_hir::Local<$tcx>, rustc_hir::Local<'_x>;\n+            [few] macro_def: rustc_hir::MacroDef<$tcx>, rustc_hir::MacroDef<'_x>;\n+            [] param: rustc_hir::Param<$tcx>, rustc_hir::Param<'_x>;\n+            [] pat: rustc_hir::Pat<$tcx>, rustc_hir::Pat<'_x>;\n+            [] path: rustc_hir::Path<$tcx>, rustc_hir::Path<'_x>;\n+            [] path_segment: rustc_hir::PathSegment<$tcx>, rustc_hir::PathSegment<'_x>;\n+            [] poly_trait_ref: rustc_hir::PolyTraitRef<$tcx>, rustc_hir::PolyTraitRef<'_x>;\n+            [] qpath: rustc_hir::QPath<$tcx>, rustc_hir::QPath<'_x>;\n+            [] stmt: rustc_hir::Stmt<$tcx>, rustc_hir::Stmt<'_x>;\n+            [] struct_field: rustc_hir::StructField<$tcx>, rustc_hir::StructField<'_x>;\n+            [] trait_item_ref: rustc_hir::TraitItemRef, rustc_hir::TraitItemRef;\n+            [] ty: rustc_hir::Ty<$tcx>, rustc_hir::Ty<'_x>;\n+            [] type_binding: rustc_hir::TypeBinding<$tcx>, rustc_hir::TypeBinding<'_x>;\n+            [] variant: rustc_hir::Variant<$tcx>, rustc_hir::Variant<'_x>;\n+            [] where_predicate: rustc_hir::WherePredicate<$tcx>, rustc_hir::WherePredicate<'_x>;\n         ], $tcx);\n     )\n }"}, {"sha": "af1860ca6bfea962a2f7a96b651aed60f8f5fcf2", "filename": "src/librustc_hir/def.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -54,15 +54,11 @@ pub enum DefKind {\n     /// Refers to the variant itself, `DefKind::Ctor` refers to its constructor if it exists.\n     Variant,\n     Trait,\n-    /// `type Foo = impl Bar;`\n-    OpaqueTy,\n     /// `type Foo = Bar;`\n     TyAlias,\n     ForeignTy,\n     TraitAlias,\n     AssocTy,\n-    /// `type Foo = impl Bar;`\n-    AssocOpaqueTy,\n     TyParam,\n \n     // Value namespace\n@@ -83,6 +79,7 @@ pub enum DefKind {\n     Use,\n     ForeignMod,\n     AnonConst,\n+    OpaqueTy,\n     Field,\n     LifetimeParam,\n     GlobalAsm,\n@@ -115,7 +112,6 @@ impl DefKind {\n             DefKind::TyAlias => \"type alias\",\n             DefKind::TraitAlias => \"trait alias\",\n             DefKind::AssocTy => \"associated type\",\n-            DefKind::AssocOpaqueTy => \"associated opaque type\",\n             DefKind::Union => \"union\",\n             DefKind::Trait => \"trait\",\n             DefKind::ForeignTy => \"foreign type\",\n@@ -143,7 +139,6 @@ impl DefKind {\n         match *self {\n             DefKind::AssocTy\n             | DefKind::AssocConst\n-            | DefKind::AssocOpaqueTy\n             | DefKind::AssocFn\n             | DefKind::Enum\n             | DefKind::OpaqueTy\n@@ -168,7 +163,6 @@ impl DefKind {\n             | DefKind::ForeignTy\n             | DefKind::TraitAlias\n             | DefKind::AssocTy\n-            | DefKind::AssocOpaqueTy\n             | DefKind::TyParam => ns == Namespace::TypeNS,\n \n             DefKind::Fn"}, {"sha": "b63dd653c4dd8a5209447745508ffc1421c8aab2", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -519,6 +519,12 @@ impl Definitions {\n         let old_index = self.placeholder_field_indices.insert(node_id, index);\n         assert!(old_index.is_none(), \"placeholder field index is reset for a node ID\");\n     }\n+\n+    pub fn lint_node_id(&mut self, expn_id: ExpnId) -> ast::NodeId {\n+        self.invocation_parents\n+            .get(&expn_id)\n+            .map_or(ast::CRATE_NODE_ID, |id| self.def_id_to_node_id[*id])\n+    }\n }\n \n impl DefPathData {"}, {"sha": "634ab32a285427f04902a80c12fa165e84b01282", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1371,7 +1371,7 @@ pub struct Expr<'hir> {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Expr<'static>, 64);\n+rustc_data_structures::static_assert_size!(Expr<'static>, 72);\n \n impl Expr<'_> {\n     pub fn precedence(&self) -> ExprPrecedence {\n@@ -1568,12 +1568,14 @@ pub enum ExprKind<'hir> {\n     /// and the remaining elements are the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n+    /// The final `Span` represents the span of the function and arguments\n+    /// (e.g. `foo::<Bar, Baz>(a, b, c, d)` in `x.foo::<Bar, Baz>(a, b, c, d)`\n     ///\n     /// To resolve the called method to a `DefId`, call [`type_dependent_def_id`] with\n     /// the `hir_id` of the `MethodCall` node itself.\n     ///\n     /// [`type_dependent_def_id`]: ../ty/struct.TypeckTables.html#method.type_dependent_def_id\n-    MethodCall(&'hir PathSegment<'hir>, Span, &'hir [Expr<'hir>]),\n+    MethodCall(&'hir PathSegment<'hir>, Span, &'hir [Expr<'hir>], Span),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(&'hir [Expr<'hir>]),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n@@ -1919,14 +1921,12 @@ pub enum ImplItemKind<'hir> {\n     Fn(FnSig<'hir>, BodyId),\n     /// An associated type.\n     TyAlias(&'hir Ty<'hir>),\n-    /// An associated `type = impl Trait`.\n-    OpaqueTy(GenericBounds<'hir>),\n }\n \n impl ImplItemKind<'_> {\n     pub fn namespace(&self) -> Namespace {\n         match self {\n-            ImplItemKind::OpaqueTy(..) | ImplItemKind::TyAlias(..) => Namespace::TypeNS,\n+            ImplItemKind::TyAlias(..) => Namespace::TypeNS,\n             ImplItemKind::Const(..) | ImplItemKind::Fn(..) => Namespace::ValueNS,\n         }\n     }\n@@ -2016,13 +2016,13 @@ pub struct OpaqueTy<'hir> {\n /// From whence the opaque type came.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum OpaqueTyOrigin {\n-    /// `type Foo = impl Trait;`\n-    TypeAlias,\n     /// `-> impl Trait`\n     FnReturn,\n     /// `async fn`\n     AsyncFn,\n-    /// Impl trait in bindings, consts, statics, bounds.\n+    /// `let _: impl Trait = ...`\n+    Binding,\n+    /// Impl trait in type aliases, consts, statics, bounds.\n     Misc,\n }\n \n@@ -2048,12 +2048,12 @@ pub enum TyKind<'hir> {\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath<'hir>),\n-    /// A type definition itself. This is currently only used for the `type Foo = impl Trait`\n-    /// item that `impl Trait` in return position desugars to.\n+    /// A opaque type definition itself. This is currently only used for the\n+    /// `opaque type Foo: Trait` item that `impl Trait` in desugars to.\n     ///\n-    /// The generic argument list contains the lifetimes (and in the future possibly parameters)\n-    /// that are actually bound on the `impl Trait`.\n-    Def(ItemId, &'hir [GenericArg<'hir>]),\n+    /// The generic argument list contains the lifetimes (and in the future\n+    /// possibly parameters) that are actually bound on the `impl Trait`.\n+    OpaqueDef(ItemId, &'hir [GenericArg<'hir>]),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TraitObject(&'hir [PolyTraitRef<'hir>], Lifetime),\n@@ -2614,7 +2614,6 @@ pub enum AssocItemKind {\n     Const,\n     Fn { has_self: bool },\n     Type,\n-    OpaqueTy,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]"}, {"sha": "23d642731da4db4ce1f754596551b4a7dd01dcf8", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -690,7 +690,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n         TyKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n         }\n-        TyKind::Def(item_id, lifetimes) => {\n+        TyKind::OpaqueDef(item_id, lifetimes) => {\n             visitor.visit_nested_item(item_id);\n             walk_list!(visitor, visit_generic_arg, lifetimes);\n         }\n@@ -1007,10 +1007,6 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_id(impl_item.hir_id);\n             visitor.visit_ty(ty);\n         }\n-        ImplItemKind::OpaqueTy(bounds) => {\n-            visitor.visit_id(impl_item.hir_id);\n-            walk_list!(visitor, visit_param_bound, bounds);\n-        }\n     }\n }\n \n@@ -1090,7 +1086,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(ref segment, _, arguments) => {\n+        ExprKind::MethodCall(ref segment, _, arguments, _) => {\n             visitor.visit_path_segment(expression.span, segment);\n             walk_list!(visitor, visit_expr, arguments);\n         }"}, {"sha": "c16b7c63e31471a2303708433f38b110eaa39458", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -227,6 +227,28 @@ pub fn path_to_string(segment: &hir::Path<'_>) -> String {\n     to_string(NO_ANN, |s| s.print_path(segment, false))\n }\n \n+pub fn fn_to_string(\n+    decl: &hir::FnDecl<'_>,\n+    header: hir::FnHeader,\n+    name: Option<Symbol>,\n+    generics: &hir::Generics<'_>,\n+    vis: &hir::Visibility<'_>,\n+    arg_names: &[Ident],\n+    body_id: Option<hir::BodyId>,\n+) -> String {\n+    to_string(NO_ANN, |s| s.print_fn(decl, header, name, generics, vis, arg_names, body_id))\n+}\n+\n+pub fn enum_def_to_string(\n+    enum_definition: &hir::EnumDef<'_>,\n+    generics: &hir::Generics<'_>,\n+    name: Symbol,\n+    span: rustc_span::Span,\n+    visibility: &hir::Visibility<'_>,\n+) -> String {\n+    to_string(NO_ANN, |s| s.print_enum_def(enum_definition, generics, name, span, visibility))\n+}\n+\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) {\n         self.s.cbox(u);\n@@ -385,7 +407,7 @@ impl<'a> State<'a> {\n                     &f.param_names[..],\n                 );\n             }\n-            hir::TyKind::Def(..) => {}\n+            hir::TyKind::OpaqueDef(..) => self.s.word(\"/*impl Trait*/\"),\n             hir::TyKind::Path(ref qpath) => self.print_qpath(qpath, false),\n             hir::TyKind::TraitObject(bounds, ref lifetime) => {\n                 let mut first = true;\n@@ -981,12 +1003,6 @@ impl<'a> State<'a> {\n             hir::ImplItemKind::TyAlias(ref ty) => {\n                 self.print_associated_type(ii.ident, &ii.generics, None, Some(ty));\n             }\n-            hir::ImplItemKind::OpaqueTy(bounds) => {\n-                self.word_space(\"type\");\n-                self.print_ident(ii.ident);\n-                self.print_bounds(\"= impl\", bounds);\n-                self.s.word(\";\");\n-            }\n         }\n         self.ann.post(self, AnnNode::SubItem(ii.hir_id))\n     }\n@@ -1286,7 +1302,7 @@ impl<'a> State<'a> {\n             hir::ExprKind::Call(ref func, ref args) => {\n                 self.print_expr_call(&func, args);\n             }\n-            hir::ExprKind::MethodCall(ref segment, _, ref args) => {\n+            hir::ExprKind::MethodCall(ref segment, _, ref args, _) => {\n                 self.print_expr_method_call(segment, args);\n             }\n             hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n@@ -2469,7 +2485,7 @@ fn contains_exterior_struct_lit(value: &hir::Expr<'_>) -> bool {\n             contains_exterior_struct_lit(&x)\n         }\n \n-        hir::ExprKind::MethodCall(.., ref exprs) => {\n+        hir::ExprKind::MethodCall(.., ref exprs, _) => {\n             // `X { y: 1 }.bar(...)`\n             contains_exterior_struct_lit(&exprs[0])\n         }"}, {"sha": "2ee95174dffe67b089bca3422a34c0eacfa0b4ba", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -336,7 +336,6 @@ impl DirtyCleanVisitor<'tcx> {\n                 ImplItemKind::Fn(..) => (\"Node::ImplItem\", LABELS_FN_IN_IMPL),\n                 ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n                 ImplItemKind::TyAlias(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n-                ImplItemKind::OpaqueTy(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n             },\n             _ => self.tcx.sess.span_fatal(\n                 attr.span,"}, {"sha": "8af526e3ad31b31171753d27693d72764ac624d1", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -56,7 +56,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n     where\n         T: Debug + TypeFoldable<'tcx>,\n-        Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable,\n+        Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n     {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n         let canonical_result = self.canonicalize_response(&query_response);"}, {"sha": "12f7a9c0ca50228bc316da2cd03c8e860887a2a1", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -224,9 +224,7 @@ fn trait_item_scope_tag(item: &hir::TraitItem<'_>) -> &'static str {\n fn impl_item_scope_tag(item: &hir::ImplItem<'_>) -> &'static str {\n     match item.kind {\n         hir::ImplItemKind::Fn(..) => \"method body\",\n-        hir::ImplItemKind::Const(..)\n-        | hir::ImplItemKind::OpaqueTy(..)\n-        | hir::ImplItemKind::TyAlias(..) => \"associated item\",\n+        hir::ImplItemKind::Const(..) | hir::ImplItemKind::TyAlias(..) => \"associated item\",\n     }\n }\n "}, {"sha": "1361d5bede63bcb0b863ee9be66e56f47c7c30d1", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::MethodCall(_, call_span, exprs) = expr.kind {\n+        if let ExprKind::MethodCall(_, call_span, exprs, _) = expr.kind {\n             if call_span == self.target_span\n                 && Some(self.target)\n                     == self.infcx.in_progress_tables.and_then(|tables| {\n@@ -294,7 +294,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // 3 |     let _ = x.sum() as f64;\n             //   |               ^^^ cannot infer type for `S`\n             span\n-        } else if let Some(ExprKind::MethodCall(_, call_span, _)) =\n+        } else if let Some(ExprKind::MethodCall(_, call_span, _, _)) =\n             local_visitor.found_method_call.map(|e| &e.kind)\n         {\n             // Point at the call instead of the whole expression:\n@@ -455,7 +455,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n                     None => format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    Some(DesugaringKind::ForLoop) => {\n+                    Some(DesugaringKind::ForLoop(_)) => {\n                         \"the element type for this iterator is not specified\".to_string()\n                     }\n                     _ => format!(\"this needs {}\", suffix),\n@@ -550,7 +550,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let error_code = error_code.into();\n         let mut err = self.tcx.sess.struct_span_err_with_code(\n             local_visitor.target_span,\n-            &format!(\"type annotations needed\"),\n+            \"type annotations needed\",\n             error_code,\n         );\n "}, {"sha": "a56401ebb90f089ecaecfe29bb2d18ff5f7c8b23", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -84,7 +84,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 rustc_hir::intravisit::walk_ty(&mut v, ty);\n \n                 debug!(\"try_report_named_anon_conflict: ret ty {:?}\", ty);\n-                if sub == &ty::ReStatic && (matches!(ty.kind, TyKind::Def(_, _)) || v.0.len() == 1)\n+                if sub == &ty::ReStatic\n+                    && (matches!(ty.kind, TyKind::OpaqueDef(_, _)) || v.0.len() == 1)\n                 {\n                     debug!(\"try_report_named_anon_conflict: impl Trait + 'static\");\n                     // This is an `impl Trait` or `dyn Trait` return that evaluates de need of"}, {"sha": "45aee2b39654d197a5814be79114601d0ac76614", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -77,8 +77,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        let mut type_param_span: MultiSpan =\n-            visitor.types.iter().cloned().collect::<Vec<_>>().into();\n+        let mut type_param_span: MultiSpan = visitor.types.to_vec().into();\n         for &span in &visitor.types {\n             type_param_span.push_span_label(\n                 span,"}, {"sha": "7fa1a3eb0f591b02abcbaa53801492938ddf90c7", "filename": "src/librustc_interface/callbacks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_interface%2Fcallbacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_interface%2Fcallbacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fcallbacks.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -18,7 +18,7 @@ use std::fmt;\n fn span_debug(span: rustc_span::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n     tls::with_opt(|tcx| {\n         if let Some(tcx) = tcx {\n-            write!(f, \"{}\", tcx.sess.source_map().span_to_string(span))\n+            rustc_span::debug_with_source_map(span, f, tcx.sess.source_map())\n         } else {\n             rustc_span::default_span_debug(span, f)\n         }"}, {"sha": "1ed9bc3f1f509d0ac20144cf5cb5246a7ee282d3", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -307,16 +307,21 @@ fn configure_and_expand_inner<'a>(\n             ecx.check_unused_macros();\n         });\n \n-        let mut missing_fragment_specifiers: Vec<_> =\n-            ecx.parse_sess.missing_fragment_specifiers.borrow().iter().cloned().collect();\n-        missing_fragment_specifiers.sort();\n+        let mut missing_fragment_specifiers: Vec<_> = ecx\n+            .parse_sess\n+            .missing_fragment_specifiers\n+            .borrow()\n+            .iter()\n+            .map(|(span, node_id)| (*span, *node_id))\n+            .collect();\n+        missing_fragment_specifiers.sort_unstable_by_key(|(span, _)| *span);\n \n         let recursion_limit_hit = ecx.reduced_recursion_limit.is_some();\n \n-        for span in missing_fragment_specifiers {\n+        for (span, node_id) in missing_fragment_specifiers {\n             let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n             let msg = \"missing fragment specifier\";\n-            resolver.lint_buffer().buffer_lint(lint, ast::CRATE_NODE_ID, span, msg);\n+            resolver.lint_buffer().buffer_lint(lint, node_id, span, msg);\n         }\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n@@ -842,7 +847,11 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n \n     sess.time(\"MIR_effect_checking\", || {\n         for def_id in tcx.body_owners() {\n-            mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n+            mir::transform::check_unsafety::check_unsafety(tcx, def_id);\n+\n+            if tcx.hir().body_const_context(def_id).is_some() {\n+                tcx.ensure().mir_drops_elaborated_and_const_checked(def_id);\n+            }\n         }\n     });\n "}, {"sha": "200e7acf802353f98efdb6f4793085605bef043b", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -187,9 +187,9 @@ pub fn strip_shebang(input: &str) -> Option<usize> {\n             // Ok, this is a shebang but if the next non-whitespace token is `[` or maybe\n             // a doc comment (due to `TokenKind::(Line,Block)Comment` ambiguity at lexer level),\n             // then it may be valid Rust code, so consider it Rust code.\n-            let next_non_whitespace_token = tokenize(input_tail).map(|tok| tok.kind).filter(|tok|\n+            let next_non_whitespace_token = tokenize(input_tail).map(|tok| tok.kind).find(|tok|\n                 !matches!(tok, TokenKind::Whitespace | TokenKind::LineComment | TokenKind::BlockComment { .. })\n-            ).next();\n+            );\n             if next_non_whitespace_token != Some(TokenKind::OpenBracket) {\n                 // No other choice than to consider this a shebang.\n                 return Some(2 + first_line_tail.len());"}, {"sha": "697d25fdb585bebd78cbc6a973356bcb358b1e2b", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -335,7 +335,7 @@ where\n \n fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n-    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::ByteStr\");\n+    assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n     res as u8\n }\n "}, {"sha": "5b282c4203400bb2bec0e70a669c1c545f350845", "filename": "src/librustc_lint/array_into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -24,7 +24,7 @@ declare_lint_pass!(\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIntoIter {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n         // We only care about method call expressions.\n-        if let hir::ExprKind::MethodCall(call, span, args) = &expr.kind {\n+        if let hir::ExprKind::MethodCall(call, span, args, _) = &expr.kind {\n             if call.ident.name != sym::into_iter {\n                 return;\n             }"}, {"sha": "efe60ce1b8889d83c21d82dd0694281bbca4b9db", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1102,6 +1102,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n             hir::ItemKind::TyAlias(ref ty, ref generics) => (&*ty, generics),\n             _ => return,\n         };\n+        if let hir::TyKind::OpaqueDef(..) = ty.kind {\n+            // Bounds are respected for `type X = impl Trait`\n+            return;\n+        }\n         let mut suggested_changing_assoc_types = false;\n         // There must not be a where clause\n         if !type_alias_generics.where_clause.predicates.is_empty() {\n@@ -1899,7 +1903,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                         }\n                     }\n                 }\n-            } else if let hir::ExprKind::MethodCall(_, _, ref args) = expr.kind {\n+            } else if let hir::ExprKind::MethodCall(_, _, ref args, _) = expr.kind {\n                 // Find problematic calls to `MaybeUninit::assume_init`.\n                 let def_id = cx.tables.type_dependent_def_id(expr.hir_id)?;\n                 if cx.tcx.is_diagnostic_item(sym::assume_init, def_id) {"}, {"sha": "a8ecfdd0f3d4523a139bb4e07726d2daff04d07d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 72, "deletions": 52, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -6,7 +6,6 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::{is_range_literal, ExprKind, Node};\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{sign_extend, truncate};\n@@ -108,23 +107,23 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n // warnings are consistent between 32- and 64-bit platforms.\n fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n     match int_ty {\n-        ast::IntTy::Isize => (i64::min_value() as i128, i64::max_value() as i128),\n-        ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n-        ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n-        ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n-        ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n-        ast::IntTy::I128 => (i128::min_value() as i128, i128::max_value()),\n+        ast::IntTy::Isize => (i64::MIN as i128, i64::MAX as i128),\n+        ast::IntTy::I8 => (i8::MIN as i64 as i128, i8::MAX as i128),\n+        ast::IntTy::I16 => (i16::MIN as i64 as i128, i16::MAX as i128),\n+        ast::IntTy::I32 => (i32::MIN as i64 as i128, i32::MAX as i128),\n+        ast::IntTy::I64 => (i64::MIN as i128, i64::MAX as i128),\n+        ast::IntTy::I128 => (i128::MIN as i128, i128::MAX),\n     }\n }\n \n fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n     match uint_ty {\n-        ast::UintTy::Usize => (u64::min_value() as u128, u64::max_value() as u128),\n-        ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n-        ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n-        ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n-        ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n-        ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n+        ast::UintTy::Usize => (u64::MIN as u128, u64::MAX as u128),\n+        ast::UintTy::U8 => (u8::MIN as u128, u8::MAX as u128),\n+        ast::UintTy::U16 => (u16::MIN as u128, u16::MAX as u128),\n+        ast::UintTy::U32 => (u32::MIN as u128, u32::MAX as u128),\n+        ast::UintTy::U64 => (u64::MIN as u128, u64::MAX as u128),\n+        ast::UintTy::U128 => (u128::MIN, u128::MAX),\n     }\n }\n \n@@ -511,10 +510,6 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: &'static str, help: Option<&'static str> },\n }\n \n-fn is_zst<'tcx>(tcx: TyCtxt<'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n-    tcx.layout_of(tcx.param_env(did).and(ty)).map(|layout| layout.is_zst()).unwrap_or(false)\n-}\n-\n fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind {\n         ty::FnPtr(_) => true,\n@@ -523,7 +518,7 @@ fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n             for field in field_def.all_fields() {\n                 let field_ty =\n                     tcx.normalize_erasing_regions(ParamEnv::reveal_all(), field.ty(tcx, substs));\n-                if is_zst(tcx, field.did, field_ty) {\n+                if field_ty.is_zst(tcx, field.did) {\n                     continue;\n                 }\n \n@@ -653,32 +648,43 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             };\n                         }\n \n-                        // We can't completely trust repr(C) and repr(transparent) markings;\n-                        // make sure the fields are actually safe.\n-                        let mut all_phantom = true;\n-                        for field in &def.non_enum_variant().fields {\n-                            let field_ty = cx.normalize_erasing_regions(\n-                                ParamEnv::reveal_all(),\n-                                field.ty(cx, substs),\n-                            );\n-                            // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n-                            // PhantomData -- skip checking all ZST fields\n-                            if def.repr.transparent() && is_zst(cx, field.did, field_ty) {\n-                                continue;\n+                        if def.repr.transparent() {\n+                            // Can assume that only one field is not a ZST, so only check\n+                            // that field's type for FFI-safety.\n+                            if let Some(field) =\n+                                def.transparent_newtype_field(cx, self.cx.param_env)\n+                            {\n+                                let field_ty = cx.normalize_erasing_regions(\n+                                    self.cx.param_env,\n+                                    field.ty(cx, substs),\n+                                );\n+                                self.check_type_for_ffi(cache, field_ty)\n+                            } else {\n+                                FfiSafe\n                             }\n-                            let r = self.check_type_for_ffi(cache, field_ty);\n-                            match r {\n-                                FfiSafe => {\n-                                    all_phantom = false;\n-                                }\n-                                FfiPhantom(..) => {}\n-                                FfiUnsafe { .. } => {\n-                                    return r;\n+                        } else {\n+                            // We can't completely trust repr(C) markings; make sure the fields are\n+                            // actually safe.\n+                            let mut all_phantom = true;\n+                            for field in &def.non_enum_variant().fields {\n+                                let field_ty = cx.normalize_erasing_regions(\n+                                    self.cx.param_env,\n+                                    field.ty(cx, substs),\n+                                );\n+                                let r = self.check_type_for_ffi(cache, field_ty);\n+                                match r {\n+                                    FfiSafe => {\n+                                        all_phantom = false;\n+                                    }\n+                                    FfiPhantom(..) => {}\n+                                    FfiUnsafe { .. } => {\n+                                        return r;\n+                                    }\n                                 }\n                             }\n-                        }\n \n-                        if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n+                            if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n+                        }\n                     }\n                     AdtKind::Union => {\n                         if !def.repr.c() && !def.repr.transparent() {\n@@ -708,7 +714,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             );\n                             // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n                             // PhantomData -- skip checking all ZST fields.\n-                            if def.repr.transparent() && is_zst(cx, field.did, field_ty) {\n+                            if def.repr.transparent() && field_ty.is_zst(cx, field.did) {\n                                 continue;\n                             }\n                             let r = self.check_type_for_ffi(cache, field_ty);\n@@ -774,7 +780,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                 );\n                                 // repr(transparent) types are allowed to have arbitrary ZSTs, not\n                                 // just PhantomData -- skip checking all ZST fields.\n-                                if def.repr.transparent() && is_zst(cx, field.did, field_ty) {\n+                                if def.repr.transparent() && field_ty.is_zst(cx, field.did) {\n                                     continue;\n                                 }\n                                 let r = self.check_type_for_ffi(cache, field_ty);\n@@ -946,7 +952,13 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_type_for_ffi_and_report_errors(&mut self, sp: Span, ty: Ty<'tcx>, is_static: bool) {\n+    fn check_type_for_ffi_and_report_errors(\n+        &mut self,\n+        sp: Span,\n+        ty: Ty<'tcx>,\n+        is_static: bool,\n+        is_return_type: bool,\n+    ) {\n         // We have to check for opaque types before `normalize_erasing_regions`,\n         // which will replace opaque types with their underlying concrete type.\n         if self.check_for_opaque_ty(sp, ty) {\n@@ -957,19 +969,29 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         // it is only OK to use this function because extern fns cannot have\n         // any generic types right now:\n         let ty = self.cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-        // C doesn't really support passing arrays by value.\n-        // The only way to pass an array by value is through a struct.\n-        // So we first test that the top level isn't an array,\n-        // and then recursively check the types inside.\n+\n+        // C doesn't really support passing arrays by value - the only way to pass an array by value\n+        // is through a struct. So, first test that the top level isn't an array, and then\n+        // recursively check the types inside.\n         if !is_static && self.check_for_array_ty(sp, ty) {\n             return;\n         }\n \n+        // Don't report FFI errors for unit return types. This check exists here, and not in\n+        // `check_foreign_fn` (where it would make more sense) so that normalization has definitely\n+        // happened.\n+        if is_return_type && ty.is_unit() {\n+            return;\n+        }\n+\n         match self.check_type_for_ffi(&mut FxHashSet::default(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiPhantom(ty) => {\n                 self.emit_ffi_unsafe_type_lint(ty, sp, \"composed only of `PhantomData`\", None);\n             }\n+            // If `ty` is a `repr(transparent)` newtype, and the non-zero-sized type is a generic\n+            // argument, which after substitution, is `()`, then this branch can be hit.\n+            FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => return,\n             FfiResult::FfiUnsafe { ty, reason, help } => {\n                 self.emit_ffi_unsafe_type_lint(ty, sp, reason, help);\n             }\n@@ -982,21 +1004,19 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(decl.inputs) {\n-            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false);\n+            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false, false);\n         }\n \n         if let hir::FnRetTy::Return(ref ret_hir) = decl.output {\n             let ret_ty = sig.output();\n-            if !ret_ty.is_unit() {\n-                self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty, false);\n-            }\n+            self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty, false, true);\n         }\n     }\n \n     fn check_foreign_static(&mut self, id: hir::HirId, span: Span) {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let ty = self.cx.tcx.type_of(def_id);\n-        self.check_type_for_ffi_and_report_errors(span, ty, true);\n+        self.check_type_for_ffi_and_report_errors(span, ty, true, false);\n     }\n }\n "}, {"sha": "8196b37391b21cdb044fd25df5ef32c1c48eedc5", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -526,7 +526,7 @@ trait UnusedDelimLint {\n                 let (args_to_check, ctx) = match *call_or_other {\n                     Call(_, ref args) => (&args[..], UnusedDelimsCtx::FunctionArg),\n                     // first \"argument\" is self (which sometimes needs delims)\n-                    MethodCall(_, ref args) => (&args[1..], UnusedDelimsCtx::MethodArg),\n+                    MethodCall(_, ref args, _) => (&args[1..], UnusedDelimsCtx::MethodArg),\n                     // actual catch-all arm\n                     _ => {\n                         return;"}, {"sha": "ada48bc147e47866750a725b1c35f57e1a0b58b9", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -78,6 +78,7 @@ fn main() {\n         \"arm\",\n         \"aarch64\",\n         \"amdgpu\",\n+        \"avr\",\n         \"mips\",\n         \"powerpc\",\n         \"systemz\","}, {"sha": "79e1a6cc5dcdb7e3cb3024948bad3541bdbb6b9d", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -76,6 +76,14 @@ pub fn initialize_available_targets() {\n         LLVMInitializeAMDGPUAsmPrinter,\n         LLVMInitializeAMDGPUAsmParser\n     );\n+    init_target!(\n+        llvm_component = \"avr\",\n+        LLVMInitializeAVRTargetInfo,\n+        LLVMInitializeAVRTarget,\n+        LLVMInitializeAVRTargetMC,\n+        LLVMInitializeAVRAsmPrinter,\n+        LLVMInitializeAVRAsmParser\n+    );\n     init_target!(\n         llvm_component = \"mips\",\n         LLVMInitializeMipsTargetInfo,"}, {"sha": "c17d5311e8fe6393d23de5e463abf7fc70588d13", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -433,7 +433,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n                 try_load_from_on_disk_cache_stream.extend(quote! {\n                     ::rustc_middle::dep_graph::DepKind::#name => {\n-                        if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n+                        if <#arg as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n                             debug_assert!($tcx.dep_graph\n                                             .node_color($dep_node)\n                                             .map(|c| c.is_green())\n@@ -490,7 +490,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             // Add a match arm to force the query given the dep node\n             dep_node_force_stream.extend(quote! {\n                 ::rustc_middle::dep_graph::DepKind::#name => {\n-                    if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n+                    if <#arg as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n                         if let Some(key) = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node) {\n                             force_query::<crate::ty::query::queries::#name<'_>, _>(\n                                 $tcx,"}, {"sha": "b8ebcd6c8a8fffb138ad51c2e46dd95190f95351", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -934,7 +934,7 @@ impl<'a> CrateLoader<'a> {\n                 src: ExternCrateSource::Path,\n                 span,\n                 // to have the least priority in `update_extern_crate`\n-                path_len: usize::max_value(),\n+                path_len: usize::MAX,\n                 dependency_of: LOCAL_CRATE,\n             },\n         );"}, {"sha": "76e39a476c6d89f73507f29525a488c62a8e5e67", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -7,7 +7,7 @@\n #![feature(nll)]\n #![feature(or_patterns)]\n #![feature(proc_macro_internals)]\n-#![feature(specialization)] // FIXME: min_specialization ICEs\n+#![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "0335aa8358c3c9a6fb1adeffbbaf4e7bad7da7b2", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::mir::{self, interpret, Body, Promoted};\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util::common::record_time;\n-use rustc_serialize::{opaque, Decodable, Decoder, SpecializedDecoder};\n+use rustc_serialize::{opaque, Decodable, Decoder, SpecializedDecoder, UseSpecializedDecodable};\n use rustc_session::Session;\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -218,15 +218,15 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable> Lazy<T> {\n+impl<'a, 'tcx, T: Decodable> Lazy<T, ()> {\n     fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T], usize> {\n     fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         metadata: M,\n@@ -321,20 +321,20 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T, ()>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n         self.read_lazy_with_meta(())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T], usize>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<[T]>, Self::Error> {\n         let len = self.read_usize()?;\n         if len == 0 { Ok(Lazy::empty()) } else { self.read_lazy_with_meta(len) }\n     }\n }\n \n-impl<'a, 'tcx, I: Idx, T> SpecializedDecoder<Lazy<Table<I, T>>> for DecodeContext<'a, 'tcx>\n+impl<'a, 'tcx, I: Idx, T> SpecializedDecoder<Lazy<Table<I, T>, usize>> for DecodeContext<'a, 'tcx>\n where\n     Option<T>: FixedSizeEncoding,\n {\n@@ -515,8 +515,9 @@ impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n-    for DecodeContext<'a, 'tcx>\n+impl<'a, 'tcx, T> SpecializedDecoder<mir::ClearCrossCrate<T>> for DecodeContext<'a, 'tcx>\n+where\n+    mir::ClearCrossCrate<T>: UseSpecializedDecodable,\n {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<mir::ClearCrossCrate<T>, Self::Error> {\n@@ -579,7 +580,6 @@ impl EntryKind {\n             EntryKind::ConstParam => DefKind::ConstParam,\n             EntryKind::OpaqueTy => DefKind::OpaqueTy,\n             EntryKind::AssocType(_) => DefKind::AssocTy,\n-            EntryKind::AssocOpaqueTy(_) => DefKind::AssocOpaqueTy,\n             EntryKind::Mod(_) => DefKind::Mod,\n             EntryKind::Variant(_) => DefKind::Variant,\n             EntryKind::Trait(_) => DefKind::Trait,\n@@ -1145,7 +1145,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 (ty::AssocKind::Fn, data.container, data.has_self)\n             }\n             EntryKind::AssocType(container) => (ty::AssocKind::Type, container, false),\n-            EntryKind::AssocOpaqueTy(container) => (ty::AssocKind::OpaqueTy, container, false),\n             _ => bug!(\"cannot get associated-item of `{:?}`\", def_key),\n         };\n \n@@ -1317,13 +1316,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_fn_param_names(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Symbol] {\n+    fn get_fn_param_names(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Ident] {\n         let param_names = match self.kind(id) {\n             EntryKind::Fn(data) | EntryKind::ForeignFn(data) => data.decode(self).param_names,\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.param_names,\n             _ => Lazy::empty(),\n         };\n-        tcx.arena.alloc_from_iter(param_names.decode(self))\n+        tcx.arena.alloc_from_iter(param_names.decode((self, tcx)))\n     }\n \n     fn exported_symbols("}, {"sha": "d797e6d4a34af6d0ed57c7948997657b3bd45d1e", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -27,10 +27,10 @@ use rustc_middle::mir::{self, interpret};\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::{self as ty_codec, TyEncoder};\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n-use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n+use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder, UseSpecializedEncodable};\n use rustc_session::config::CrateType;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n use rustc_target::abi::VariantIdx;\n use std::hash::Hash;\n@@ -93,13 +93,13 @@ impl<'tcx> Encoder for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n+impl<'tcx, T> SpecializedEncoder<Lazy<T, ()>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n         self.emit_lazy_distance(*lazy)\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n+impl<'tcx, T> SpecializedEncoder<Lazy<[T], usize>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<[T]>) -> Result<(), Self::Error> {\n         self.emit_usize(lazy.meta)?;\n         if lazy.meta == 0 {\n@@ -109,7 +109,7 @@ impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, I: Idx, T> SpecializedEncoder<Lazy<Table<I, T>>> for EncodeContext<'tcx>\n+impl<'tcx, I: Idx, T> SpecializedEncoder<Lazy<Table<I, T>, usize>> for EncodeContext<'tcx>\n where\n     Option<T>: FixedSizeEncoding,\n {\n@@ -228,8 +228,13 @@ impl<'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'tcx> {\n-    fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n+impl<'a, 'b, 'tcx> SpecializedEncoder<&'a ty::TyS<'b>> for EncodeContext<'tcx>\n+where\n+    &'a ty::TyS<'b>: UseSpecializedEncodable,\n+{\n+    fn specialized_encode(&mut self, ty: &&'a ty::TyS<'b>) -> Result<(), Self::Error> {\n+        debug_assert!(self.tcx.lift(ty).is_some());\n+        let ty = unsafe { std::mem::transmute::<&&'a ty::TyS<'b>, &&'tcx ty::TyS<'tcx>>(ty) };\n         ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n     }\n }\n@@ -251,12 +256,19 @@ impl<'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx> SpecializedEncoder<&'tcx [(ty::Predicate<'tcx>, Span)]> for EncodeContext<'tcx> {\n+impl<'a, 'b, 'tcx> SpecializedEncoder<&'a [(ty::Predicate<'b>, Span)]> for EncodeContext<'tcx> {\n     fn specialized_encode(\n         &mut self,\n-        predicates: &&'tcx [(ty::Predicate<'tcx>, Span)],\n+        predicates: &&'a [(ty::Predicate<'b>, Span)],\n     ) -> Result<(), Self::Error> {\n-        ty_codec::encode_spanned_predicates(self, predicates, |ecx| &mut ecx.predicate_shorthands)\n+        debug_assert!(self.tcx.lift(*predicates).is_some());\n+        let predicates = unsafe {\n+            std::mem::transmute::<\n+                &&'a [(ty::Predicate<'b>, Span)],\n+                &&'tcx [(ty::Predicate<'tcx>, Span)],\n+            >(predicates)\n+        };\n+        ty_codec::encode_spanned_predicates(self, &predicates, |ecx| &mut ecx.predicate_shorthands)\n     }\n }\n \n@@ -266,7 +278,10 @@ impl<'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T: Encodable> SpecializedEncoder<mir::ClearCrossCrate<T>> for EncodeContext<'tcx> {\n+impl<'tcx, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for EncodeContext<'tcx>\n+where\n+    mir::ClearCrossCrate<T>: UseSpecializedEncodable,\n+{\n     fn specialized_encode(&mut self, _: &mir::ClearCrossCrate<T>) -> Result<(), Self::Error> {\n         Ok(())\n     }\n@@ -874,7 +889,6 @@ impl EncodeContext<'tcx> {\n                 }))\n             }\n             ty::AssocKind::Type => EntryKind::AssocType(container),\n-            ty::AssocKind::OpaqueTy => span_bug!(ast_item.span, \"opaque type in trait\"),\n         });\n         record!(self.tables.visibility[def_id] <- trait_item.vis);\n         record!(self.tables.span[def_id] <- ast_item.span);\n@@ -892,7 +906,6 @@ impl EncodeContext<'tcx> {\n                     self.encode_item_type(def_id);\n                 }\n             }\n-            ty::AssocKind::OpaqueTy => unreachable!(),\n         }\n         if trait_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -957,7 +970,6 @@ impl EncodeContext<'tcx> {\n                     has_self: impl_item.fn_has_self_parameter,\n                 }))\n             }\n-            ty::AssocKind::OpaqueTy => EntryKind::AssocOpaqueTy(container),\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n         });\n         record!(self.tables.visibility[def_id] <- impl_item.vis);\n@@ -989,26 +1001,20 @@ impl EncodeContext<'tcx> {\n                 let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                 needs_inline || is_const_fn || always_encode_mir\n             }\n-            hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(..) => false,\n+            hir::ImplItemKind::TyAlias(..) => false,\n         };\n         if mir {\n             self.encode_optimized_mir(def_id.expect_local());\n             self.encode_promoted_mir(def_id.expect_local());\n         }\n     }\n \n-    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId) -> Lazy<[Symbol]> {\n-        self.tcx.dep_graph.with_ignore(|| {\n-            let body = self.tcx.hir().body(body_id);\n-            self.lazy(body.params.iter().map(|arg| match arg.pat.kind {\n-                hir::PatKind::Binding(_, _, ident, _) => ident.name,\n-                _ => kw::Invalid,\n-            }))\n-        })\n+    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId) -> Lazy<[Ident]> {\n+        self.tcx.dep_graph.with_ignore(|| self.lazy(self.tcx.hir().body_param_names(body_id)))\n     }\n \n-    fn encode_fn_param_names(&mut self, param_names: &[Ident]) -> Lazy<[Symbol]> {\n-        self.lazy(param_names.iter().map(|ident| ident.name))\n+    fn encode_fn_param_names(&mut self, param_names: &[Ident]) -> Lazy<[Ident]> {\n+        self.lazy(param_names.iter())\n     }\n \n     fn encode_optimized_mir(&mut self, def_id: LocalDefId) {\n@@ -1786,7 +1792,7 @@ impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n                     self.prefetch_mir(def_id)\n                 }\n             }\n-            hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(..) => (),\n+            hir::ImplItemKind::TyAlias(..) => (),\n         }\n     }\n }"}, {"sha": "ec80a2b6171edf7f2f5e65f9355fd8887c39bde5", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -19,7 +19,7 @@ use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::CrateDisambiguator;\n use rustc_span::edition::Edition;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, Span};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n \n@@ -308,7 +308,6 @@ enum EntryKind {\n     Impl(Lazy<ImplData>),\n     AssocFn(Lazy<AssocFnData>),\n     AssocType(AssocContainer),\n-    AssocOpaqueTy(AssocContainer),\n     AssocConst(AssocContainer, mir::ConstQualifs, Lazy<RenderedConst>),\n     TraitAlias,\n }\n@@ -327,7 +326,7 @@ struct ModData {\n struct FnData {\n     asyncness: hir::IsAsync,\n     constness: hir::Constness,\n-    param_names: Lazy<[Symbol]>,\n+    param_names: Lazy<[Ident]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "f861d63aba0f3c4f77cf6927c732b0bb3624ef61", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -11,79 +11,109 @@\n macro_rules! arena_types {\n     ($macro:path, $args:tt, $tcx:lifetime) => (\n         $macro!($args, [\n-            [] layouts: rustc_target::abi::Layout,\n+            [] layouts: rustc_target::abi::Layout, rustc_target::abi::Layout;\n             // AdtDef are interned and compared by address\n-            [] adt_def: rustc_middle::ty::AdtDef,\n-            [decode] tables: rustc_middle::ty::TypeckTables<$tcx>,\n-            [] const_allocs: rustc_middle::mir::interpret::Allocation,\n+            [] adt_def: rustc_middle::ty::AdtDef, rustc_middle::ty::AdtDef;\n+            [decode] tables: rustc_middle::ty::TypeckTables<$tcx>, rustc_middle::ty::TypeckTables<'_x>;\n+            [] const_allocs: rustc_middle::mir::interpret::Allocation, rustc_middle::mir::interpret::Allocation;\n             // Required for the incremental on-disk cache\n-            [few, decode] mir_keys: rustc_hir::def_id::DefIdSet,\n-            [] region_scope_tree: rustc_middle::middle::region::ScopeTree,\n+            [few, decode] mir_keys: rustc_hir::def_id::DefIdSet, rustc_hir::def_id::DefIdSet;\n+            [] region_scope_tree: rustc_middle::middle::region::ScopeTree, rustc_middle::middle::region::ScopeTree;\n             [] dropck_outlives:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,\n                         rustc_middle::traits::query::DropckOutlivesResult<'tcx>\n                     >\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y,\n+                        rustc_middle::traits::query::DropckOutlivesResult<'_z>\n+                    >\n+                >;\n             [] normalize_projection_ty:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,\n                         rustc_middle::traits::query::NormalizationResult<'tcx>\n                     >\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y,\n+                        rustc_middle::traits::query::NormalizationResult<'_z>\n+                    >\n+                >;\n             [] implied_outlives_bounds:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,\n                         Vec<rustc_middle::traits::query::OutlivesBound<'tcx>>\n                     >\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y,\n+                        Vec<rustc_middle::traits::query::OutlivesBound<'_z>>\n+                    >\n+                >;\n             [] type_op_subtype:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, ()>\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y, ()>\n+                >;\n             [] type_op_normalize_poly_fn_sig:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::PolyFnSig<'tcx>>\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y, rustc_middle::ty::PolyFnSig<'_z>>\n+                >;\n             [] type_op_normalize_fn_sig:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::FnSig<'tcx>>\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y, rustc_middle::ty::FnSig<'_z>>\n+                >;\n             [] type_op_normalize_predicate:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Predicate<'tcx>>\n                 >,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y, rustc_middle::ty::Predicate<'_z>>\n+                >;\n             [] type_op_normalize_ty:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Ty<'tcx>>\n                 >,\n-            [few] all_traits: Vec<rustc_hir::def_id::DefId>,\n-            [few] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels,\n-            [few] foreign_module: rustc_middle::middle::cstore::ForeignModule,\n-            [few] foreign_modules: Vec<rustc_middle::middle::cstore::ForeignModule>,\n-            [] upvars_mentioned: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n-            [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation,\n-            [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<$tcx>,\n-            [] attribute: rustc_ast::ast::Attribute,\n-            [] name_set: rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>,\n-            [] hir_id_set: rustc_hir::HirIdSet,\n+                rustc_middle::infer::canonical::Canonical<'_x,\n+                    rustc_middle::infer::canonical::QueryResponse<'_y, &'_z rustc_middle::ty::TyS<'_w>>\n+                >;\n+            [few] all_traits: Vec<rustc_hir::def_id::DefId>, Vec<rustc_hir::def_id::DefId>;\n+            [few] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels, rustc_middle::middle::privacy::AccessLevels;\n+            [few] foreign_module: rustc_middle::middle::cstore::ForeignModule, rustc_middle::middle::cstore::ForeignModule;\n+            [few] foreign_modules: Vec<rustc_middle::middle::cstore::ForeignModule>, Vec<rustc_middle::middle::cstore::ForeignModule>;\n+            [] upvars_mentioned: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>, rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>;\n+            [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation, rustc_middle::traits::ObjectSafetyViolation;\n+            [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<$tcx>, rustc_middle::mir::mono::CodegenUnit<'_x>;\n+            [] attribute: rustc_ast::ast::Attribute, rustc_ast::ast::Attribute;\n+            [] name_set: rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>, rustc_data_structures::fx::FxHashSet<rustc_span::symbol::Symbol>;\n+            [] hir_id_set: rustc_hir::HirIdSet, rustc_hir::HirIdSet;\n \n             // Interned types\n-            [] tys: rustc_middle::ty::TyS<$tcx>,\n+            [] tys: rustc_middle::ty::TyS<$tcx>, rustc_middle::ty::TyS<'_x>;\n \n             // HIR query types\n-            [few] indexed_hir: rustc_middle::hir::map::IndexedHir<$tcx>,\n-            [few] hir_definitions: rustc_hir::definitions::Definitions,\n-            [] hir_owner: rustc_middle::hir::Owner<$tcx>,\n-            [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>,\n+            [few] indexed_hir: rustc_middle::hir::map::IndexedHir<$tcx>, rustc_middle::hir::map::IndexedHir<'_x>;\n+            [few] hir_definitions: rustc_hir::definitions::Definitions, rustc_hir::definitions::Definitions;\n+            [] hir_owner: rustc_middle::hir::Owner<$tcx>, rustc_middle::hir::Owner<'_x>;\n+            [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>, rustc_middle::hir::OwnerNodes<'_x>;\n \n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,\n             // since we need to allocate this type on both the `rustc_hir` arena\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n-            [decode] asm_template: rustc_ast::ast::InlineAsmTemplatePiece,\n+            [decode] asm_template: rustc_ast::ast::InlineAsmTemplatePiece, rustc_ast::ast::InlineAsmTemplatePiece;\n \n             // This is used to decode the &'tcx [Span] for InlineAsm's line_spans.\n-            [decode] span: rustc_span::Span,\n+            [decode] span: rustc_span::Span, rustc_span::Span;\n         ], $tcx);\n     )\n }"}, {"sha": "b14f17dee60603f4340116a64edd286038525ef7", "filename": "src/librustc_middle/dep_graph/dep_node.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -128,7 +128,7 @@ macro_rules! define_dep_nodes {\n                             // tuple args\n                             $({\n                                 return <$tuple_arg_ty as DepNodeParams<TyCtxt<'_>>>\n-                                    ::CAN_RECONSTRUCT_QUERY_KEY;\n+                                    ::can_reconstruct_query_key();\n                             })*\n \n                             true\n@@ -304,7 +304,10 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n ]);\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+    #[inline]\n+    fn can_reconstruct_query_key() -> bool {\n+        true\n+    }\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         tcx.def_path_hash(*self).0\n@@ -320,7 +323,10 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+    #[inline]\n+    fn can_reconstruct_query_key() -> bool {\n+        true\n+    }\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         self.to_def_id().to_fingerprint(tcx)\n@@ -336,7 +342,10 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+    #[inline]\n+    fn can_reconstruct_query_key() -> bool {\n+        true\n+    }\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n@@ -353,7 +362,10 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+    #[inline]\n+    fn can_reconstruct_query_key() -> bool {\n+        false\n+    }\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n@@ -375,7 +387,10 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n }\n \n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+    #[inline]\n+    fn can_reconstruct_query_key() -> bool {\n+        false\n+    }\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full"}, {"sha": "e3e0856ffc52ea5ac4f72ac536e43528cc0d2399", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n@@ -228,7 +228,6 @@ impl<'hir> Map<'hir> {\n                 ImplItemKind::Const(..) => DefKind::AssocConst,\n                 ImplItemKind::Fn(..) => DefKind::AssocFn,\n                 ImplItemKind::TyAlias(..) => DefKind::AssocTy,\n-                ImplItemKind::OpaqueTy(..) => DefKind::AssocOpaqueTy,\n             },\n             Node::Variant(_) => DefKind::Variant,\n             Node::Ctor(variant_data) => {\n@@ -335,6 +334,16 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    pub fn enclosing_body_owner(&self, hir_id: HirId) -> HirId {\n+        for (parent, _) in self.parent_iter(hir_id) {\n+            if let Some(body) = self.maybe_body_owned_by(parent) {\n+                return self.body_owner(body);\n+            }\n+        }\n+\n+        bug!(\"no `enclosing_body_owner` for hir_id `{}`\", hir_id);\n+    }\n+\n     /// Returns the `HirId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n@@ -365,6 +374,13 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    pub fn body_param_names(&self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n+        self.body(id).params.iter().map(|arg| match arg.pat.kind {\n+            PatKind::Binding(_, _, ident, _) => ident,\n+            _ => Ident::new(kw::Invalid, rustc_span::DUMMY_SP),\n+        })\n+    }\n+\n     /// Returns the `BodyOwnerKind` of this `LocalDefId`.\n     ///\n     /// Panics if `LocalDefId` does not have an associated body.\n@@ -537,18 +553,8 @@ impl<'hir> Map<'hir> {\n \n     /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n     /// Used exclusively for diagnostics, to avoid suggestion function calls.\n-    pub fn is_const_context(&self, hir_id: HirId) -> bool {\n-        let parent_id = self.get_parent_item(hir_id);\n-        match self.get(parent_id) {\n-            Node::Item(&Item { kind: ItemKind::Const(..) | ItemKind::Static(..), .. })\n-            | Node::TraitItem(&TraitItem { kind: TraitItemKind::Const(..), .. })\n-            | Node::ImplItem(&ImplItem { kind: ImplItemKind::Const(..), .. })\n-            | Node::AnonConst(_) => true,\n-            Node::Item(&Item { kind: ItemKind::Fn(ref sig, ..), .. }) => {\n-                sig.header.constness == Constness::Const\n-            }\n-            _ => false,\n-        }\n+    pub fn is_inside_const_context(&self, hir_id: HirId) -> bool {\n+        self.body_const_context(self.local_def_id(self.enclosing_body_owner(hir_id))).is_some()\n     }\n \n     /// Whether `hir_id` corresponds to a `mod` or a crate.\n@@ -672,6 +678,8 @@ impl<'hir> Map<'hir> {\n             if let Node::Item(Item {\n                 kind:\n                     ItemKind::Fn(..)\n+                    | ItemKind::Const(..)\n+                    | ItemKind::Static(..)\n                     | ItemKind::Mod(..)\n                     | ItemKind::Enum(..)\n                     | ItemKind::Struct(..)\n@@ -700,11 +708,7 @@ impl<'hir> Map<'hir> {\n                 return CRATE_HIR_ID;\n             }\n             match self.get(scope) {\n-                Node::Item(Item {\n-                    kind: ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }),\n-                    ..\n-                })\n-                | Node::Block(_) => {}\n+                Node::Block(_) => {}\n                 _ => break,\n             }\n         }\n@@ -1025,9 +1029,6 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n             ImplItemKind::TyAlias(_) => {\n                 format!(\"assoc type {} in {}{}\", ii.ident, path_str(), id_str)\n             }\n-            ImplItemKind::OpaqueTy(_) => {\n-                format!(\"assoc opaque type {} in {}{}\", ii.ident, path_str(), id_str)\n-            }\n         },\n         Some(Node::TraitItem(ti)) => {\n             let kind = match ti.kind {"}, {"sha": "e152d11c081a12bb430fe39ca9432bc5f7680a39", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -12,10 +12,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n-use rustc_hir::Body;\n-use rustc_hir::HirId;\n-use rustc_hir::ItemLocalId;\n-use rustc_hir::Node;\n+use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n \n pub struct Owner<'tcx> {\n@@ -79,5 +76,20 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_deref();\n+    providers.fn_arg_names = |tcx, id| {\n+        let hir = tcx.hir();\n+        let hir_id = hir.as_local_hir_id(id.expect_local());\n+        if let Some(body_id) = hir.maybe_body_owned_by(hir_id) {\n+            tcx.arena.alloc_from_iter(hir.body_param_names(body_id))\n+        } else if let Node::TraitItem(&TraitItem {\n+            kind: TraitItemKind::Fn(_, TraitFn::Required(idents)),\n+            ..\n+        }) = hir.get(hir_id)\n+        {\n+            tcx.arena.alloc_slice(idents)\n+        } else {\n+            span_bug!(hir.span(hir_id), \"fn_arg_names: unexpected item {:?}\", id);\n+        }\n+    };\n     map::provide(providers);\n }"}, {"sha": "62c92e988ba60b12c18ab26996d91dea103d58be", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -42,7 +42,7 @@\n #![feature(option_expect_none)]\n #![feature(or_patterns)]\n #![feature(range_is_empty)]\n-#![feature(specialization)] // FIXME: min_specialization does not work\n+#![feature(min_specialization)]\n #![feature(track_caller)]\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]"}, {"sha": "923119e359c4749c00556006bfcabb991969c816", "filename": "src/librustc_middle/lint.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flint.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -339,7 +339,9 @@ pub fn struct_lint_level<'s, 'd>(\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n-        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n+        ExpnKind::Root\n+        | ExpnKind::Desugaring(DesugaringKind::ForLoop(_))\n+        | ExpnKind::Desugaring(DesugaringKind::Operator) => false,\n         ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             // Dummy span for the `def_site` means it's an external macro."}, {"sha": "27848684706d6d824e34e6f8debb769d95f32769", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -76,7 +76,8 @@ pub enum MirPhase {\n     Build = 0,\n     Const = 1,\n     Validated = 2,\n-    Optimized = 3,\n+    DropElab = 3,\n+    Optimized = 4,\n }\n \n impl MirPhase {\n@@ -457,8 +458,39 @@ impl<T> ClearCrossCrate<T> {\n     }\n }\n \n-impl<T: Encodable> rustc_serialize::UseSpecializedEncodable for ClearCrossCrate<T> {}\n-impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<T> {}\n+const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n+const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n+\n+impl<T: Encodable> rustc_serialize::UseSpecializedEncodable for ClearCrossCrate<T> {\n+    #[inline]\n+    fn default_encode<E: rustc_serialize::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+        match *self {\n+            ClearCrossCrate::Clear => TAG_CLEAR_CROSS_CRATE_CLEAR.encode(e),\n+            ClearCrossCrate::Set(ref val) => {\n+                TAG_CLEAR_CROSS_CRATE_SET.encode(e)?;\n+                val.encode(e)\n+            }\n+        }\n+    }\n+}\n+impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<T> {\n+    #[inline]\n+    fn default_decode<D>(d: &mut D) -> Result<ClearCrossCrate<T>, D::Error>\n+    where\n+        D: rustc_serialize::Decoder,\n+    {\n+        let discr = u8::decode(d)?;\n+\n+        match discr {\n+            TAG_CLEAR_CROSS_CRATE_CLEAR => Ok(ClearCrossCrate::Clear),\n+            TAG_CLEAR_CROSS_CRATE_SET => {\n+                let val = T::decode(d)?;\n+                Ok(ClearCrossCrate::Set(val))\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n \n /// Grouped information about the source code origin of a MIR entity.\n /// Intended to be inspected by diagnostics and debuginfo.\n@@ -1131,6 +1163,9 @@ pub enum TerminatorKind<'tcx> {\n         /// `true` if this is from a call in HIR rather than from an overloaded\n         /// operator. True for overloaded function call.\n         from_hir_call: bool,\n+        /// This `Span` is the span of the function, without the dot and receiver\n+        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        fn_span: Span,\n     },\n \n     /// Jump to the target if the condition has the expected value,\n@@ -1240,7 +1275,7 @@ pub enum InlineAsmOperand<'tcx> {\n         value: Box<Constant<'tcx>>,\n     },\n     SymStatic {\n-        value: Box<Constant<'tcx>>,\n+        def_id: DefId,\n     },\n }\n \n@@ -1636,9 +1671,11 @@ impl<'tcx> TerminatorKind<'tcx> {\n                         InlineAsmOperand::Const { value } => {\n                             write!(fmt, \"const {:?}\", value)?;\n                         }\n-                        InlineAsmOperand::SymFn { value }\n-                        | InlineAsmOperand::SymStatic { value } => {\n-                            write!(fmt, \"sym {:?}\", value)?;\n+                        InlineAsmOperand::SymFn { value } => {\n+                            write!(fmt, \"sym_fn {:?}\", value)?;\n+                        }\n+                        InlineAsmOperand::SymStatic { def_id } => {\n+                            write!(fmt, \"sym_static {:?}\", def_id)?;\n                         }\n                     }\n                 }\n@@ -1952,8 +1989,6 @@ impl<V, T> ProjectionElem<V, T> {\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n \n-impl<'tcx> Copy for PlaceElem<'tcx> {}\n-\n // At least on 64 bit systems, `PlaceElem` should not be larger than two pointers.\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PlaceElem<'_>, 16);\n@@ -2449,7 +2484,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                                     tcx.def_path_str_with_substs(def_id.to_def_id(), substs),\n                                 )\n                             } else {\n-                                format!(\"[closure@{:?}]\", tcx.hir().span(hir_id))\n+                                let span = tcx.hir().span(hir_id);\n+                                format!(\"[closure@{}]\", tcx.sess.source_map().span_to_string(span))\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n "}, {"sha": "d82faf3e5fbaa4a89d4ece92bd233869a4faf12b", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -183,7 +183,7 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ConstraintCategory {\n-    Return,\n+    Return(ReturnConstraint),\n     Yield,\n     UseAsConst,\n     UseAsStatic,\n@@ -199,6 +199,7 @@ pub enum ConstraintCategory {\n     SizedBound,\n     Assignment,\n     OpaqueType,\n+    ClosureUpvar(hir::HirId),\n \n     /// A \"boring\" constraint (caused by the given location) is one that\n     /// the user probably doesn't want to see described in diagnostics,\n@@ -216,6 +217,13 @@ pub enum ConstraintCategory {\n     Internal,\n }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+pub enum ReturnConstraint {\n+    Normal,\n+    ClosureUpvar(hir::HirId),\n+}\n+\n /// The subject of a `ClosureOutlivesRequirement` -- that is, the thing\n /// that must outlive some region.\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]"}, {"sha": "3f5d528d9e7c4a3219b3c315970331bfc4ab9daf", "filename": "src/librustc_middle/mir/type_foldable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 resume_arg: resume_arg.fold_with(folder),\n                 drop,\n             },\n-            Call { ref func, ref args, ref destination, cleanup, from_hir_call } => {\n+            Call { ref func, ref args, ref destination, cleanup, from_hir_call, fn_span } => {\n                 let dest =\n                     destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n \n@@ -52,6 +52,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                     destination: dest,\n                     cleanup,\n                     from_hir_call,\n+                    fn_span,\n                 }\n             }\n             Assert { ref cond, expected, ref msg, target, cleanup } => {"}, {"sha": "5f9fcdca516b1ae802515bbbbc656dfb226be0be", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -492,6 +492,7 @@ macro_rules! make_mir_visitor {\n                         destination,\n                         cleanup: _,\n                         from_hir_call: _,\n+                        fn_span: _\n                     } => {\n                         self.visit_operand(func, source_location);\n                         for arg in args {\n@@ -563,10 +564,10 @@ macro_rules! make_mir_visitor {\n                                         );\n                                     }\n                                 }\n-                                InlineAsmOperand::SymFn { value }\n-                                | InlineAsmOperand::SymStatic { value } => {\n+                                InlineAsmOperand::SymFn { value } => {\n                                     self.visit_constant(value, source_location);\n                                 }\n+                                InlineAsmOperand::SymStatic { def_id: _ } => {}\n                             }\n                         }\n                     }"}, {"sha": "3b6d54a1bc1eed958e35888c4f4517e339b1e732", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -190,6 +190,12 @@ rustc_queries! {\n             no_hash\n         }\n \n+        query mir_drops_elaborated_and_const_checked(key: LocalDefId) -> Steal<mir::Body<'tcx>> {\n+            storage(ArenaCacheSelector<'tcx>)\n+            no_hash\n+            desc { |tcx| \"elaborating drops for `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        }\n+\n         query mir_validated(key: LocalDefId) ->\n             (\n                 Steal<mir::Body<'tcx>>,\n@@ -700,7 +706,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query fn_arg_names(def_id: DefId) -> &'tcx [Symbol] {\n+        query fn_arg_names(def_id: DefId) -> &'tcx [rustc_span::symbol::Ident] {\n             desc { |tcx| \"looking up function parameter names for `{}`\", tcx.def_path_str(def_id) }\n         }\n         /// Gets the rendered value of the specified constant or associated constant.\n@@ -789,6 +795,17 @@ rustc_queries! {\n             desc { \"computing whether `{}` needs drop\", env.value }\n         }\n \n+        /// Query backing `TyS::is_structural_eq_shallow`.\n+        ///\n+        /// This is only correct for ADTs. Call `is_structural_eq_shallow` to handle all types\n+        /// correctly.\n+        query has_structural_eq_impls(ty: Ty<'tcx>) -> bool {\n+            desc {\n+                \"computing whether `{:?}` implements `PartialStructuralEq` and `StructuralEq`\",\n+                ty\n+            }\n+        }\n+\n         /// A list of types where the ADT requires drop if and only if any of\n         /// those types require drop. If the ADT is known to always need drop\n         /// then `Err(AlwaysRequiresDrop)` is returned."}, {"sha": "f4961617b81c6e8365a4ee6ec6be635b19c5ba7b", "filename": "src/librustc_middle/traits/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -100,24 +100,11 @@ impl<'tcx> Node {\n         trait_item_kind: ty::AssocKind,\n         trait_def_id: DefId,\n     ) -> Option<ty::AssocItem> {\n-        use crate::ty::AssocKind::*;\n-\n         tcx.associated_items(self.def_id())\n             .filter_by_name_unhygienic(trait_item_name.name)\n             .find(move |impl_item| {\n-                match (trait_item_kind, impl_item.kind) {\n-                | (Const, Const)\n-                | (Fn, Fn)\n-                | (Type, Type)\n-                | (Type, OpaqueTy)  // assoc. types can be made opaque in impls\n-                => tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id),\n-\n-                | (Const, _)\n-                | (Fn, _)\n-                | (Type, _)\n-                | (OpaqueTy, _)\n-                => false,\n-            }\n+                trait_item_kind == impl_item.kind\n+                    && tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id)\n             })\n             .copied()\n     }"}, {"sha": "1a8e5c45dd2f7f6a16a0a946c49f236005f26414", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 85, "deletions": 57, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -97,7 +97,7 @@ where\n \n pub fn encode_spanned_predicates<'tcx, E, C>(\n     encoder: &mut E,\n-    predicates: &'tcx [(ty::Predicate<'tcx>, Span)],\n+    predicates: &[(ty::Predicate<'tcx>, Span)],\n     cache: C,\n ) -> Result<(), E::Error>\n where\n@@ -139,7 +139,7 @@ pub trait TyDecoder<'tcx>: Decoder {\n }\n \n #[inline]\n-pub fn decode_arena_allocable<D, T: ArenaAllocatable + Decodable>(\n+pub fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable>(\n     decoder: &mut D,\n ) -> Result<&'tcx T, D::Error>\n where\n@@ -149,7 +149,7 @@ where\n }\n \n #[inline]\n-pub fn decode_arena_allocable_slice<D, T: ArenaAllocatable + Decodable>(\n+pub fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable>(\n     decoder: &mut D,\n ) -> Result<&'tcx [T], D::Error>\n where\n@@ -318,18 +318,38 @@ macro_rules! __impl_decoder_methods {\n macro_rules! impl_arena_allocatable_decoder {\n     ([]$args:tt) => {};\n     ([decode $(, $attrs:ident)*]\n-     [[$DecoderName:ident [$($typaram:tt),*]], [$name:ident: $ty:ty], $tcx:lifetime]) => {\n-        impl<$($typaram),*> SpecializedDecoder<&$tcx $ty> for $DecoderName<$($typaram),*> {\n+     [[$DecoderName:ident [$($typaram:tt),*]], [$name:ident: $ty:ty, $gen_ty:ty], $tcx:lifetime]) => {\n+         // FIXME(#36588): These impls are horribly unsound as they allow\n+         // the caller to pick any lifetime for `'tcx`, including `'static`.\n+        #[allow(unused_lifetimes)]\n+        impl<'_x, '_y, '_z, '_w, '_a, $($typaram),*> SpecializedDecoder<&'_a $gen_ty>\n+        for $DecoderName<$($typaram),*>\n+        where &'_a $gen_ty: UseSpecializedDecodable\n+        {\n             #[inline]\n-            fn specialized_decode(&mut self) -> Result<&$tcx $ty, Self::Error> {\n-                decode_arena_allocable(self)\n+            fn specialized_decode(&mut self) -> Result<&'_a $gen_ty, Self::Error> {\n+                unsafe {\n+                    std::mem::transmute::<\n+                        Result<&$tcx $ty, Self::Error>,\n+                        Result<&'_a $gen_ty, Self::Error>,\n+                    >(decode_arena_allocable(self))\n+                }\n             }\n         }\n \n-        impl<$($typaram),*> SpecializedDecoder<&$tcx [$ty]> for $DecoderName<$($typaram),*> {\n+        #[allow(unused_lifetimes)]\n+        impl<'_x, '_y, '_z, '_w, '_a, $($typaram),*> SpecializedDecoder<&'_a [$gen_ty]>\n+        for $DecoderName<$($typaram),*>\n+        where &'_a [$gen_ty]: UseSpecializedDecodable\n+        {\n             #[inline]\n-            fn specialized_decode(&mut self) -> Result<&$tcx [$ty], Self::Error> {\n-                decode_arena_allocable_slice(self)\n+            fn specialized_decode(&mut self) -> Result<&'_a [$gen_ty], Self::Error> {\n+                unsafe {\n+                    std::mem::transmute::<\n+                        Result<&$tcx [$ty], Self::Error>,\n+                        Result<&'_a [$gen_ty], Self::Error>,\n+                    >(decode_arena_allocable_slice(self))\n+                }\n             }\n         }\n     };\n@@ -340,9 +360,9 @@ macro_rules! impl_arena_allocatable_decoder {\n \n #[macro_export]\n macro_rules! impl_arena_allocatable_decoders {\n-    ($args:tt, [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n+    ($args:tt, [$($a:tt $name:ident: $ty:ty, $gen_ty:ty;)*], $tcx:lifetime) => {\n         $(\n-            impl_arena_allocatable_decoder!($a [$args, [$name: $ty], $tcx]);\n+            impl_arena_allocatable_decoder!($a [$args, [$name: $ty, $gen_ty], $tcx]);\n         )*\n     }\n }\n@@ -352,14 +372,15 @@ macro_rules! implement_ty_decoder {\n     ($DecoderName:ident <$($typaram:tt),*>) => {\n         mod __ty_decoder_impl {\n             use std::borrow::Cow;\n+            use std::mem::transmute;\n \n-            use rustc_serialize::{Decoder, SpecializedDecoder};\n+            use rustc_serialize::{Decoder, SpecializedDecoder, UseSpecializedDecodable};\n \n             use $crate::infer::canonical::CanonicalVarInfos;\n             use $crate::ty;\n             use $crate::ty::codec::*;\n-            use $crate::ty::subst::SubstsRef;\n-            use rustc_hir::def_id::{CrateNum};\n+            use $crate::ty::subst::InternalSubsts;\n+            use rustc_hir::def_id::CrateNum;\n \n             use rustc_span::Span;\n \n@@ -398,8 +419,7 @@ macro_rules! implement_ty_decoder {\n             }\n \n             // FIXME(#36588): These impls are horribly unsound as they allow\n-            // the caller to pick any lifetime for `'tcx`, including `'static`,\n-            // by using the unspecialized proxies to them.\n+            // the caller to pick any lifetime for `'tcx`, including `'static`.\n \n             rustc_hir::arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);\n             arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);\n@@ -411,90 +431,98 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<ty::Ty<'tcx>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ty::Ty<'tcx>, Self::Error> {\n-                    decode_ty(self)\n+            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x ty::TyS<'_y>>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x ty::TyS<'_y>: UseSpecializedDecodable\n+            {\n+                fn specialized_decode(&mut self) -> Result<&'_x ty::TyS<'_y>, Self::Error> {\n+                    unsafe { transmute::<Result<ty::Ty<'tcx>, Self::Error>, Result<&'_x ty::TyS<'_y>, Self::Error>>(decode_ty(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx [(ty::Predicate<'tcx>, Span)]>\n-            for $DecoderName<$($typaram),*> {\n+            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x [(ty::Predicate<'_y>, Span)]>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x [(ty::Predicate<'_y>, Span)]: UseSpecializedDecodable {\n                 fn specialized_decode(&mut self)\n-                                      -> Result<&'tcx [(ty::Predicate<'tcx>, Span)], Self::Error> {\n-                    decode_spanned_predicates(self)\n+                                      -> Result<&'_x [(ty::Predicate<'_y>, Span)], Self::Error>\n+                {\n+                    unsafe { transmute(decode_spanned_predicates(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<SubstsRef<'tcx>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<SubstsRef<'tcx>, Self::Error> {\n-                    decode_substs(self)\n+            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x InternalSubsts<'_y>>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x InternalSubsts<'_y>: UseSpecializedDecodable {\n+                fn specialized_decode(&mut self) -> Result<&'_x InternalSubsts<'_y>, Self::Error> {\n+                    unsafe { transmute(decode_substs(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<$crate::mir::Place<'tcx>>\n+            impl<'_x, $($typaram),*> SpecializedDecoder<$crate::mir::Place<'_x>>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(\n                     &mut self\n-                ) -> Result<$crate::mir::Place<'tcx>, Self::Error> {\n-                    decode_place(self)\n+                ) -> Result<$crate::mir::Place<'_x>, Self::Error> {\n+                    unsafe { transmute(decode_place(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<ty::Region<'tcx>>\n+            impl<'_x, $($typaram),*> SpecializedDecoder<ty::Region<'_x>>\n             for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {\n-                    decode_region(self)\n+                fn specialized_decode(&mut self) -> Result<ty::Region<'_x>, Self::Error> {\n+                    unsafe { transmute(decode_region(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::List<ty::Ty<'tcx>>>\n-            for $DecoderName<$($typaram),*> {\n+            impl<'_x, '_y, '_z, $($typaram),*> SpecializedDecoder<&'_x ty::List<&'_y ty::TyS<'_z>>>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x ty::List<&'_y ty::TyS<'_z>>: UseSpecializedDecodable {\n                 fn specialized_decode(&mut self)\n-                                      -> Result<&'tcx ty::List<ty::Ty<'tcx>>, Self::Error> {\n-                    decode_ty_slice(self)\n+                                      -> Result<&'_x ty::List<&'_y ty::TyS<'_z>>, Self::Error> {\n+                    unsafe { transmute(decode_ty_slice(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::AdtDef>\n+            impl<'_x, $($typaram),*> SpecializedDecoder<&'_x ty::AdtDef>\n             for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n-                    decode_adt_def(self)\n+                fn specialized_decode(&mut self) -> Result<&'_x ty::AdtDef, Self::Error> {\n+                    unsafe { transmute(decode_adt_def(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>\n-                for $DecoderName<$($typaram),*> {\n+            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x ty::List<ty::ExistentialPredicate<'_y>>>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x ty::List<ty::ExistentialPredicate<'_y>>: UseSpecializedDecodable {\n                 fn specialized_decode(&mut self)\n-                    -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n-                    decode_existential_predicate_slice(self)\n+                    -> Result<&'_x ty::List<ty::ExistentialPredicate<'_y>>, Self::Error> {\n+                        unsafe { transmute(decode_existential_predicate_slice(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<CanonicalVarInfos<'tcx>>\n+            impl<'_x, $($typaram),*> SpecializedDecoder<CanonicalVarInfos<'_x>>\n                 for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self)\n-                    -> Result<CanonicalVarInfos<'tcx>, Self::Error> {\n-                    decode_canonical_var_infos(self)\n+                    -> Result<CanonicalVarInfos<'_x>, Self::Error> {\n+                        unsafe { transmute(decode_canonical_var_infos(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::ty::Const<'tcx>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-                    decode_const(self)\n+            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x $crate::ty::Const<'_y>>\n+            for $DecoderName<$($typaram),*>\n+            where &'_x $crate::ty::Const<'_y>: UseSpecializedDecodable {\n+                fn specialized_decode(&mut self) -> Result<&'_x ty::Const<'_y>, Self::Error> {\n+                    unsafe { transmute(decode_const(self)) }\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::mir::interpret::Allocation>\n+            impl<'_x, $($typaram),*> SpecializedDecoder<&'_x $crate::mir::interpret::Allocation>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(\n                     &mut self\n-                ) -> Result<&'tcx $crate::mir::interpret::Allocation, Self::Error> {\n-                    decode_allocation(self)\n+                ) -> Result<&'_x $crate::mir::interpret::Allocation, Self::Error> {\n+                    unsafe { transmute(decode_allocation(self)) }\n                 }\n             }\n         }\n-    }\n+    };\n }"}, {"sha": "be3bf748225b9885097f4c6e07379e49a9782079", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -814,7 +814,7 @@ fn foo(&self) -> Self::T { String::new() }\n                 // FIXME: account for `#![feature(specialization)]`\n                 for item in &items[..] {\n                     match item.kind {\n-                        hir::AssocItemKind::Type | hir::AssocItemKind::OpaqueTy => {\n+                        hir::AssocItemKind::Type => {\n                             // FIXME: account for returning some type in a trait fn impl that has\n                             // an assoc type as a return type (#72076).\n                             if let hir::Defaultness::Default { has_value: true } = item.defaultness\n@@ -838,7 +838,7 @@ fn foo(&self) -> Self::T { String::new() }\n             })) => {\n                 for item in &items[..] {\n                     match item.kind {\n-                        hir::AssocItemKind::Type | hir::AssocItemKind::OpaqueTy => {\n+                        hir::AssocItemKind::Type => {\n                             if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n                                 db.span_label(item.span, \"expected this associated type\");\n                                 return true;"}, {"sha": "f5bca90c2bd523d7075ff4eaeb0307b90480d1ca", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2529,6 +2529,8 @@ where\n             Msp430Interrupt => Conv::Msp430Intr,\n             X86Interrupt => Conv::X86Intr,\n             AmdGpuKernel => Conv::AmdGpuKernel,\n+            AvrInterrupt => Conv::AvrInterrupt,\n+            AvrNonBlockingInterrupt => Conv::AvrNonBlockingInterrupt,\n \n             // These API constants ought to be more specific...\n             Cdecl => Conv::C,"}, {"sha": "93ef73171993c0522fd161cda065e54c821fdf7d", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -198,14 +198,13 @@ pub struct AssocItem {\n pub enum AssocKind {\n     Const,\n     Fn,\n-    OpaqueTy,\n     Type,\n }\n \n impl AssocKind {\n     pub fn namespace(&self) -> Namespace {\n         match *self {\n-            ty::AssocKind::OpaqueTy | ty::AssocKind::Type => Namespace::TypeNS,\n+            ty::AssocKind::Type => Namespace::TypeNS,\n             ty::AssocKind::Const | ty::AssocKind::Fn => Namespace::ValueNS,\n         }\n     }\n@@ -215,22 +214,11 @@ impl AssocKind {\n             AssocKind::Const => DefKind::AssocConst,\n             AssocKind::Fn => DefKind::AssocFn,\n             AssocKind::Type => DefKind::AssocTy,\n-            AssocKind::OpaqueTy => DefKind::AssocOpaqueTy,\n         }\n     }\n }\n \n impl AssocItem {\n-    /// Tests whether the associated item admits a non-trivial implementation\n-    /// for !\n-    pub fn relevant_for_never(&self) -> bool {\n-        match self.kind {\n-            AssocKind::OpaqueTy | AssocKind::Const | AssocKind::Type => true,\n-            // FIXME(canndrew): Be more thorough here, check if any argument is uninhabited.\n-            AssocKind::Fn => !self.fn_has_self_parameter,\n-        }\n-    }\n-\n     pub fn signature(&self, tcx: TyCtxt<'_>) -> String {\n         match self.kind {\n             ty::AssocKind::Fn => {\n@@ -241,8 +229,6 @@ impl AssocItem {\n                 tcx.fn_sig(self.def_id).skip_binder().to_string()\n             }\n             ty::AssocKind::Type => format!(\"type {};\", self.ident),\n-            // FIXME(type_alias_impl_trait): we should print bounds here too.\n-            ty::AssocKind::OpaqueTy => format!(\"type {};\", self.ident),\n             ty::AssocKind::Const => {\n                 format!(\"const {}: {:?};\", self.ident, tcx.type_of(self.def_id))\n             }\n@@ -2390,6 +2376,29 @@ impl<'tcx> AdtDef {\n     pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n         tcx.adt_sized_constraint(self.did).0\n     }\n+\n+    /// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n+    /// field.\n+    pub fn transparent_newtype_field(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> Option<&FieldDef> {\n+        assert!(self.is_struct() && self.repr.transparent());\n+\n+        for field in &self.non_enum_variant().fields {\n+            let field_ty = tcx.normalize_erasing_regions(\n+                param_env,\n+                field.ty(tcx, InternalSubsts::identity_for_item(tcx, self.did)),\n+            );\n+\n+            if !field_ty.is_zst(tcx, self.did) {\n+                return Some(field);\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n impl<'tcx> FieldDef {\n@@ -2558,10 +2567,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             .filter(|item| item.kind == AssocKind::Fn && item.defaultness.has_value())\n     }\n \n-    pub fn trait_relevant_for_never(self, did: DefId) -> bool {\n-        self.associated_items(did).in_definition_order().any(|item| item.relevant_for_never())\n-    }\n-\n     pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {\n         def_id\n             .as_local()"}, {"sha": "d782dd07a65889c4dbc4548e1d99a34b0e50ef00", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -605,7 +605,8 @@ pub trait PrettyPrinter<'tcx>:\n                 // FIXME(eddyb) should use `def_span`.\n                 if let Some(did) = did.as_local() {\n                     let hir_id = self.tcx().hir().as_local_hir_id(did);\n-                    p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n+                    let span = self.tcx().hir().span(hir_id);\n+                    p!(write(\"@{}\", self.tcx().sess.source_map().span_to_string(span)));\n \n                     if substs.as_generator().is_valid() {\n                         let upvar_tys = substs.as_generator().upvar_tys();\n@@ -653,7 +654,8 @@ pub trait PrettyPrinter<'tcx>:\n                     if self.tcx().sess.opts.debugging_opts.span_free_formats {\n                         p!(write(\"@\"), print_def_path(did.to_def_id(), substs));\n                     } else {\n-                        p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n+                        let span = self.tcx().hir().span(hir_id);\n+                        p!(write(\"@{}\", self.tcx().sess.source_map().span_to_string(span)));\n                     }\n \n                     if substs.as_closure().is_valid() {\n@@ -984,7 +986,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 let ui_str = ui.name_str();\n                 if data == max {\n-                    p!(write(\"std::{}::MAX\", ui_str))\n+                    p!(write(\"{}::MAX\", ui_str))\n                 } else {\n                     if print_ty { p!(write(\"{}{}\", data, ui_str)) } else { p!(write(\"{}\", data)) }\n                 };\n@@ -997,8 +999,8 @@ pub trait PrettyPrinter<'tcx>:\n \n                 let i_str = i.name_str();\n                 match data {\n-                    d if d == min => p!(write(\"std::{}::MIN\", i_str)),\n-                    d if d == max => p!(write(\"std::{}::MAX\", i_str)),\n+                    d if d == min => p!(write(\"{}::MIN\", i_str)),\n+                    d if d == max => p!(write(\"{}::MAX\", i_str)),\n                     _ => {\n                         let data = sign_extend(data, size) as i128;\n                         if print_ty {\n@@ -1362,7 +1364,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n                 if !self.empty_path {\n                     write!(self, \"::\")?;\n                 }\n-                write!(self, \"<impl at {:?}>\", span)?;\n+                write!(self, \"<impl at {}>\", self.tcx.sess.source_map().span_to_string(span))?;\n                 self.empty_path = false;\n \n                 return Ok(self);"}, {"sha": "5374dff422425e938e066c8628616d68a59cb9f4", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 16, "deletions": 44, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,6 +1,6 @@\n use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n+use crate::mir::interpret;\n use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use crate::mir::{self, interpret};\n use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n@@ -26,9 +26,6 @@ use std::mem;\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n-const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n-const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n-\n const TAG_NO_EXPN_DATA: u8 = 0;\n const TAG_EXPN_DATA_SHORTHAND: u8 = 1;\n const TAG_EXPN_DATA_INLINE: u8 = 2;\n@@ -667,24 +664,6 @@ impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n-    for CacheDecoder<'a, 'tcx>\n-{\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<mir::ClearCrossCrate<T>, Self::Error> {\n-        let discr = u8::decode(self)?;\n-\n-        match discr {\n-            TAG_CLEAR_CROSS_CRATE_CLEAR => Ok(mir::ClearCrossCrate::Clear),\n-            TAG_CLEAR_CROSS_CRATE_SET => {\n-                let val = T::decode(self)?;\n-                Ok(mir::ClearCrossCrate::Set(val))\n-            }\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n //- ENCODING -------------------------------------------------------------------\n \n /// An encoder that can write the incr. comp. cache.\n@@ -828,26 +807,36 @@ where\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'b, 'c, 'tcx, E> SpecializedEncoder<&'b ty::TyS<'c>> for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + TyEncoder,\n+    &'b ty::TyS<'c>: UseSpecializedEncodable,\n {\n     #[inline]\n-    fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n+    fn specialized_encode(&mut self, ty: &&'b ty::TyS<'c>) -> Result<(), Self::Error> {\n+        debug_assert!(self.tcx.lift(ty).is_some());\n+        let ty = unsafe { std::mem::transmute::<&&'b ty::TyS<'c>, &&'tcx ty::TyS<'tcx>>(ty) };\n         ty_codec::encode_with_shorthand(self, ty, |encoder| &mut encoder.type_shorthands)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<&'tcx [(ty::Predicate<'tcx>, Span)]>\n+impl<'a, 'b, 'c, 'tcx, E> SpecializedEncoder<&'b [(ty::Predicate<'c>, Span)]>\n     for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(\n         &mut self,\n-        predicates: &&'tcx [(ty::Predicate<'tcx>, Span)],\n+        predicates: &&'b [(ty::Predicate<'c>, Span)],\n     ) -> Result<(), Self::Error> {\n+        debug_assert!(self.tcx.lift(*predicates).is_some());\n+        let predicates = unsafe {\n+            std::mem::transmute::<\n+                &&'b [(ty::Predicate<'c>, Span)],\n+                &&'tcx [(ty::Predicate<'tcx>, Span)],\n+            >(predicates)\n+        };\n         ty_codec::encode_spanned_predicates(self, predicates, |encoder| {\n             &mut encoder.predicate_shorthands\n         })\n@@ -890,23 +879,6 @@ impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque\n     }\n }\n \n-impl<'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-    T: Encodable,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, val: &mir::ClearCrossCrate<T>) -> Result<(), Self::Error> {\n-        match *val {\n-            mir::ClearCrossCrate::Clear => TAG_CLEAR_CROSS_CRATE_CLEAR.encode(self),\n-            mir::ClearCrossCrate::Set(ref val) => {\n-                TAG_CLEAR_CROSS_CRATE_SET.encode(self)?;\n-                val.encode(self)\n-            }\n-        }\n-    }\n-}\n-\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         #[inline]\n@@ -995,7 +967,7 @@ fn encode_query_results<'a, 'tcx, Q, E>(\n     query_result_index: &mut EncodedQueryResultIndex,\n ) -> Result<(), E::Error>\n where\n-    Q: super::QueryDescription<TyCtxt<'tcx>>,\n+    Q: super::QueryDescription<TyCtxt<'tcx>> + super::QueryAccessors<TyCtxt<'tcx>>,\n     Q::Value: Encodable,\n     E: 'a + TyEncoder,\n {"}, {"sha": "3c44662441890431f15e70a74d318aa4f4015759", "filename": "src/librustc_middle/ty/query/profiling_support.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -112,30 +112,53 @@ impl<T: Debug> IntoSelfProfilingString for T {\n     }\n }\n \n-impl IntoSelfProfilingString for DefId {\n+impl<T: SpecIntoSelfProfilingString> IntoSelfProfilingString for T {\n     fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId {\n+        self.spec_to_self_profile_string(builder)\n+    }\n+}\n+\n+#[rustc_specialization_trait]\n+pub trait SpecIntoSelfProfilingString: Debug {\n+    fn spec_to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+    ) -> StringId;\n+}\n+\n+impl SpecIntoSelfProfilingString for DefId {\n+    fn spec_to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+    ) -> StringId {\n         builder.def_id_to_string_id(*self)\n     }\n }\n \n-impl IntoSelfProfilingString for CrateNum {\n-    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId {\n+impl SpecIntoSelfProfilingString for CrateNum {\n+    fn spec_to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+    ) -> StringId {\n         builder.def_id_to_string_id(DefId { krate: *self, index: CRATE_DEF_INDEX })\n     }\n }\n \n-impl IntoSelfProfilingString for DefIndex {\n-    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId {\n+impl SpecIntoSelfProfilingString for DefIndex {\n+    fn spec_to_self_profile_string(\n+        &self,\n+        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+    ) -> StringId {\n         builder.def_id_to_string_id(DefId { krate: LOCAL_CRATE, index: *self })\n     }\n }\n \n-impl<T0, T1> IntoSelfProfilingString for (T0, T1)\n+impl<T0, T1> SpecIntoSelfProfilingString for (T0, T1)\n where\n-    T0: IntoSelfProfilingString + Debug,\n-    T1: IntoSelfProfilingString + Debug,\n+    T0: SpecIntoSelfProfilingString,\n+    T1: SpecIntoSelfProfilingString,\n {\n-    default fn to_self_profile_string(\n+    fn spec_to_self_profile_string(\n         &self,\n         builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n     ) -> StringId {"}, {"sha": "b1f76ff6a03bd2ad6a26f526e24c1e005a7fc6fd", "filename": "src/librustc_middle/ty/query/values.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,4 +1,4 @@\n-use crate::ty::{self, AdtSizedConstraint, Ty, TyCtxt};\n+use crate::ty::{self, AdtSizedConstraint, Ty, TyCtxt, TyS};\n \n use rustc_span::symbol::Symbol;\n \n@@ -13,9 +13,11 @@ impl<'tcx, T> Value<'tcx> for T {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for Ty<'tcx> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        tcx.types.err\n+impl<'tcx> Value<'tcx> for &'_ TyS<'_> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n+        // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n+        // FIXME: Represent the above fact in the trait system somehow.\n+        unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.types.err) }\n     }\n }\n \n@@ -25,8 +27,14 @@ impl<'tcx> Value<'tcx> for ty::SymbolName {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for AdtSizedConstraint<'tcx> {\n+impl<'tcx> Value<'tcx> for AdtSizedConstraint<'_> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n-        AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err]))\n+        // SAFETY: This is never called when `Self` is not `AdtSizedConstraint<'tcx>`.\n+        // FIXME: Represent the above fact in the trait system somehow.\n+        unsafe {\n+            std::mem::transmute::<AdtSizedConstraint<'tcx>, AdtSizedConstraint<'_>>(\n+                AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err])),\n+            )\n+        }\n     }\n }"}, {"sha": "cddd7081ca375fc05f020d42717cf5075dc1d063", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -250,8 +250,8 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                 &b.item_def_id,\n             )))\n         } else {\n-            let ty = relation.relate(&a.ty, &b.ty)?;\n-            let substs = relation.relate(&a.substs, &b.substs)?;\n+            let ty = relation.relate_with_variance(ty::Invariant, &a.ty, &b.ty)?;\n+            let substs = relation.relate_with_variance(ty::Invariant, &a.substs, &b.substs)?;\n             Ok(ty::ExistentialProjection { item_def_id: a.item_def_id, substs, ty })\n         }\n     }\n@@ -508,16 +508,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     debug!(\"{}.super_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n \n-    let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n-        // FIXME(eddyb) this doesn't account for lifetime inference variables\n-        // being erased by `eval`, *nor* for the polymorphic aspect of `eval`.\n-        // That is, we could always use `eval` and it will just return the\n-        // old value back if it doesn't succeed.\n-        if !x.val.needs_infer() {\n-            return x.eval(tcx, relation.param_env()).val;\n-        }\n-        x.val\n-    };\n+    let eagerly_eval = |x: &'tcx ty::Const<'tcx>| x.eval(tcx, relation.param_env()).val;\n \n     // FIXME(eddyb) doesn't look like everything below checks that `a.ty == b.ty`.\n     // We could probably always assert it early, as `const` generic parameters"}, {"sha": "fad96aa86cc0afc27eaac0dc629fe0f04ed1f0a9", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2186,6 +2186,11 @@ impl<'tcx> TyS<'tcx> {\n             }\n         }\n     }\n+\n+    /// Is this a zero-sized type?\n+    pub fn is_zst(&'tcx self, tcx: TyCtxt<'tcx>, did: DefId) -> bool {\n+        tcx.layout_of(tcx.param_env(did).and(self)).map(|layout| layout.is_zst()).unwrap_or(false)\n+    }\n }\n \n /// Typed constant value.\n@@ -2404,8 +2409,6 @@ impl<'tcx> Const<'tcx> {\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Const<'tcx> {}\n-\n /// Represents a constant in Rust.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n #[derive(HashStable)]"}, {"sha": "ff284b709c2cfeee5c3170353719f1e9962c26b5", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -705,6 +705,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n+    // FIXME: use `TyCtxtAt` instead of separate `Span`.\n     pub fn is_freeze(\n         &'tcx self,\n         tcx: TyCtxt<'tcx>,\n@@ -778,6 +779,57 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n+    /// Returns `true` if equality for this type is both reflexive and structural.\n+    ///\n+    /// Reflexive equality for a type is indicated by an `Eq` impl for that type.\n+    ///\n+    /// Primitive types (`u32`, `str`) have structural equality by definition. For composite data\n+    /// types, equality for the type as a whole is structural when it is the same as equality\n+    /// between all components (fields, array elements, etc.) of that type. For ADTs, structural\n+    /// equality is indicated by an implementation of `PartialStructuralEq` and `StructuralEq` for\n+    /// that type.\n+    ///\n+    /// This function is \"shallow\" because it may return `true` for a composite type whose fields\n+    /// are not `StructuralEq`. For example, `[T; 4]` has structural equality regardless of `T`\n+    /// because equality for arrays is determined by the equality of each array element. If you\n+    /// want to know whether a given call to `PartialEq::eq` will proceed structurally all the way\n+    /// down, you will need to use a type visitor.\n+    #[inline]\n+    pub fn is_structural_eq_shallow(&'tcx self, tcx: TyCtxt<'tcx>) -> bool {\n+        match self.kind {\n+            // Look for an impl of both `PartialStructuralEq` and `StructuralEq`.\n+            Adt(..) => tcx.has_structural_eq_impls(self),\n+\n+            // Primitive types that satisfy `Eq`.\n+            Bool | Char | Int(_) | Uint(_) | Str | Never => true,\n+\n+            // Composite types that satisfy `Eq` when all of their fields do.\n+            //\n+            // Because this function is \"shallow\", we return `true` for these composites regardless\n+            // of the type(s) contained within.\n+            Ref(..) | Array(..) | Slice(_) | Tuple(..) => true,\n+\n+            // Raw pointers use bitwise comparison.\n+            RawPtr(_) | FnPtr(_) => true,\n+\n+            // Floating point numbers are not `Eq`.\n+            Float(_) => false,\n+\n+            // Conservatively return `false` for all others...\n+\n+            // Anonymous function types\n+            FnDef(..) | Closure(..) | Dynamic(..) | Generator(..) => false,\n+\n+            // Generic or inferred types\n+            //\n+            // FIXME(ecstaticmorse): Maybe we should `bug` here? This should probably only be\n+            // called for known, fully-monomorphized types.\n+            Projection(_) | Opaque(..) | Param(_) | Bound(..) | Placeholder(_) | Infer(_) => false,\n+\n+            Foreign(_) | GeneratorWitness(..) | Error => false,\n+        }\n+    }\n+\n     pub fn same_type(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match (&a.kind, &b.kind) {\n             (&Adt(did_a, substs_a), &Adt(did_b, substs_b)) => {\n@@ -827,7 +879,15 @@ impl<'tcx> ty::TyS<'tcx> {\n                     // Find non representable fields with their spans\n                     fold_repr(def.all_fields().map(|field| {\n                         let ty = field.ty(tcx, substs);\n-                        let span = tcx.hir().span_if_local(field.did).unwrap_or(sp);\n+                        let span = match field\n+                            .did\n+                            .as_local()\n+                            .map(|id| tcx.hir().as_local_hir_id(id))\n+                            .and_then(|id| tcx.hir().find(id))\n+                        {\n+                            Some(hir::Node::Field(field)) => field.ty.span,\n+                            _ => sp,\n+                        };\n                         match is_type_structurally_recursive(\n                             tcx,\n                             span,"}, {"sha": "2e897647a3beb18a32ca9638d881142cc5c0ca80", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 68, "deletions": 10, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -24,7 +24,8 @@ use crate::borrow_check::{\n };\n \n use super::{\n-    explain_borrow::BorrowExplanation, IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n+    explain_borrow::BorrowExplanation, FnSelfUseKind, IncludingDowncast, RegionName,\n+    RegionNameSource, UseSpans,\n };\n \n #[derive(Debug)]\n@@ -150,13 +151,70 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         format!(\"value moved{} here, in previous iteration of loop\", move_msg),\n                     );\n                 } else {\n-                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n-                    move_spans.var_span_label(\n-                        &mut err,\n-                        format!(\"variable moved due to use{}\", move_spans.describe()),\n-                    );\n+                    if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } =\n+                        move_spans\n+                    {\n+                        let place_name = self\n+                            .describe_place(moved_place.as_ref())\n+                            .map(|n| format!(\"`{}`\", n))\n+                            .unwrap_or_else(|| \"value\".to_owned());\n+                        match kind {\n+                            FnSelfUseKind::FnOnceCall => {\n+                                err.span_label(\n+                                    fn_call_span,\n+                                    &format!(\"{} moved due to this call\", place_name),\n+                                );\n+                                err.span_note(\n+                                    var_span,\n+                                    \"this value implements `FnOnce`, which causes it to be moved when called\",\n+                                );\n+                            }\n+                            FnSelfUseKind::Operator { self_arg } => {\n+                                err.span_label(\n+                                    fn_call_span,\n+                                    &format!(\"{} moved due to usage in operator\", place_name),\n+                                );\n+                                if self.fn_self_span_reported.insert(fn_span) {\n+                                    err.span_note(\n+                                        self_arg.span,\n+                                        \"calling this operator moves the left-hand side\",\n+                                    );\n+                                }\n+                            }\n+                            FnSelfUseKind::Normal { self_arg, implicit_into_iter } => {\n+                                if implicit_into_iter {\n+                                    err.span_label(\n+                                        fn_call_span,\n+                                        &format!(\n+                                            \"{} moved due to this implicit call to `.into_iter()`\",\n+                                            place_name\n+                                        ),\n+                                    );\n+                                } else {\n+                                    err.span_label(\n+                                        fn_call_span,\n+                                        &format!(\"{} moved due to this method call\", place_name),\n+                                    );\n+                                }\n+                                // Avoid pointing to the same function in multiple different\n+                                // error messages\n+                                if self.fn_self_span_reported.insert(self_arg.span) {\n+                                    err.span_note(\n+                                        self_arg.span,\n+                                        &format!(\"this function consumes the receiver `self` by taking ownership of it, which moves {}\", place_name)\n+                                    );\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                        move_spans.var_span_label(\n+                            &mut err,\n+                            format!(\"variable moved due to use{}\", move_spans.describe()),\n+                        );\n+                    }\n                 }\n-                if Some(DesugaringKind::ForLoop) == move_span.desugaring_kind() {\n+                if let Some(DesugaringKind::ForLoop(_)) = move_span.desugaring_kind() {\n                     let sess = self.infcx.tcx.sess;\n                     if let Ok(snippet) = sess.source_map().span_to_snippet(move_span) {\n                         err.span_suggestion(\n@@ -766,7 +824,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     category:\n                         category\n                         @\n-                        (ConstraintCategory::Return\n+                        (ConstraintCategory::Return(_)\n                         | ConstraintCategory::CallArgument\n                         | ConstraintCategory::OpaqueType),\n                     from_closure: false,\n@@ -1089,7 +1147,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         opt_place_desc: Option<&String>,\n     ) -> Option<DiagnosticBuilder<'cx>> {\n         let return_kind = match category {\n-            ConstraintCategory::Return => \"return\",\n+            ConstraintCategory::Return(_) => \"return\",\n             ConstraintCategory::Yield => \"yield\",\n             _ => return None,\n         };\n@@ -1203,7 +1261,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let msg = match category {\n-            ConstraintCategory::Return | ConstraintCategory::OpaqueType => {\n+            ConstraintCategory::Return(_) | ConstraintCategory::OpaqueType => {\n                 format!(\"{} is returned here\", kind)\n             }\n             ConstraintCategory::CallArgument => {"}, {"sha": "d04059ff0fc7ffc405a82505b7fe26462b338102", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -509,7 +509,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // Used in a closure.\n                 (LaterUseKind::ClosureCapture, var_span)\n             }\n-            UseSpans::OtherUse(span) => {\n+            UseSpans::OtherUse(span) | UseSpans::FnSelfUse { var_span: span, .. } => {\n                 let block = &self.body.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {"}, {"sha": "04f48cd65823054613daa1804218756a462b30bc", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 130, "deletions": 20, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -11,7 +11,11 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n-use rustc_span::{symbol::sym, Span};\n+use rustc_span::{\n+    hygiene::{DesugaringKind, ForLoopLoc},\n+    symbol::sym,\n+    Span,\n+};\n use rustc_target::abi::VariantIdx;\n \n use super::borrow_set::BorrowData;\n@@ -33,6 +37,7 @@ crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionName, RegionNameSource};\n+use rustc_span::symbol::Ident;\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -529,33 +534,58 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n }\n \n-// The span(s) associated to a use of a place.\n+/// The span(s) associated to a use of a place.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub(super) enum UseSpans {\n-    // The access is caused by capturing a variable for a closure.\n+    /// The access is caused by capturing a variable for a closure.\n     ClosureUse {\n-        // This is true if the captured variable was from a generator.\n+        /// This is true if the captured variable was from a generator.\n         generator_kind: Option<GeneratorKind>,\n-        // The span of the args of the closure, including the `move` keyword if\n-        // it's present.\n+        /// The span of the args of the closure, including the `move` keyword if\n+        /// it's present.\n         args_span: Span,\n-        // The span of the first use of the captured variable inside the closure.\n+        /// The span of the first use of the captured variable inside the closure.\n+        var_span: Span,\n+    },\n+    /// The access is caused by using a variable as the receiver of a method\n+    /// that takes 'self'\n+    FnSelfUse {\n+        /// The span of the variable being moved\n         var_span: Span,\n+        /// The span of the method call on the variable\n+        fn_call_span: Span,\n+        /// The definition span of the method being called\n+        fn_span: Span,\n+        kind: FnSelfUseKind,\n     },\n     // This access has a single span associated to it: common case.\n     OtherUse(Span),\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub(super) enum FnSelfUseKind {\n+    /// A normal method call of the form `receiver.foo(a, b, c)`\n+    Normal { self_arg: Ident, implicit_into_iter: bool },\n+    /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n+    FnOnceCall,\n+    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n+    Operator { self_arg: Ident },\n+}\n+\n impl UseSpans {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n-            UseSpans::ClosureUse { args_span: span, .. } | UseSpans::OtherUse(span) => span,\n+            UseSpans::ClosureUse { args_span: span, .. }\n+            | UseSpans::FnSelfUse { var_span: span, .. }\n+            | UseSpans::OtherUse(span) => span,\n         }\n     }\n \n     pub(super) fn var_or_use(self) -> Span {\n         match self {\n-            UseSpans::ClosureUse { var_span: span, .. } | UseSpans::OtherUse(span) => span,\n+            UseSpans::ClosureUse { var_span: span, .. }\n+            | UseSpans::FnSelfUse { var_span: span, .. }\n+            | UseSpans::OtherUse(span) => span,\n         }\n     }\n \n@@ -624,6 +654,7 @@ impl UseSpans {\n     {\n         match self {\n             closure @ UseSpans::ClosureUse { .. } => closure,\n+            fn_self @ UseSpans::FnSelfUse { .. } => fn_self,\n             UseSpans::OtherUse(_) => if_other(),\n         }\n     }\n@@ -727,21 +758,100 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n         if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) = stmt.kind {\n-            let def_id = match kind {\n+            match kind {\n                 box AggregateKind::Closure(def_id, _)\n-                | box AggregateKind::Generator(def_id, _, _) => def_id,\n-                _ => return OtherUse(stmt.source_info.span),\n-            };\n-\n-            debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n-            if let Some((args_span, generator_kind, var_span)) =\n-                self.closure_span(*def_id, moved_place, places)\n-            {\n-                return ClosureUse { generator_kind, args_span, var_span };\n+                | box AggregateKind::Generator(def_id, _, _) => {\n+                    debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n+                    if let Some((args_span, generator_kind, var_span)) =\n+                        self.closure_span(*def_id, moved_place, places)\n+                    {\n+                        return ClosureUse { generator_kind, args_span, var_span };\n+                    }\n+                }\n+                _ => {}\n             }\n         }\n \n-        OtherUse(stmt.source_info.span)\n+        let normal_ret = OtherUse(stmt.source_info.span);\n+\n+        // We are trying to find MIR of the form:\n+        // ```\n+        // _temp = _moved_val;\n+        // ...\n+        // FnSelfCall(_temp, ...)\n+        // ```\n+        //\n+        // where `_moved_val` is the place we generated the move error for,\n+        // `_temp` is some other local, and `FnSelfCall` is a function\n+        // that has a `self` parameter.\n+\n+        let target_temp = match stmt.kind {\n+            StatementKind::Assign(box (temp, _)) if temp.as_local().is_some() => {\n+                temp.as_local().unwrap()\n+            }\n+            _ => return normal_ret,\n+        };\n+\n+        debug!(\"move_spans: target_temp = {:?}\", target_temp);\n+\n+        if let Some(Terminator { kind: TerminatorKind::Call { func, args, fn_span, .. }, .. }) =\n+            &self.body[location.block].terminator\n+        {\n+            let mut method_did = None;\n+            if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n+                if let ty::FnDef(def_id, _) = ty.kind {\n+                    debug!(\"move_spans: fn = {:?}\", def_id);\n+                    if let Some(ty::AssocItem { fn_has_self_parameter, .. }) =\n+                        self.infcx.tcx.opt_associated_item(def_id)\n+                    {\n+                        if *fn_has_self_parameter {\n+                            method_did = Some(def_id);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            let tcx = self.infcx.tcx;\n+            let method_did = if let Some(did) = method_did { did } else { return normal_ret };\n+\n+            if let [Operand::Move(self_place), ..] = **args {\n+                if self_place.as_local() == Some(target_temp) {\n+                    let is_fn_once = tcx.parent(method_did) == tcx.lang_items().fn_once_trait();\n+                    let fn_call_span = *fn_span;\n+\n+                    let self_arg = tcx.fn_arg_names(method_did)[0];\n+\n+                    let kind = if is_fn_once {\n+                        FnSelfUseKind::FnOnceCall\n+                    } else if fn_call_span.is_desugaring(DesugaringKind::Operator) {\n+                        FnSelfUseKind::Operator { self_arg }\n+                    } else {\n+                        debug!(\n+                            \"move_spans: method_did={:?}, fn_call_span={:?}\",\n+                            method_did, fn_call_span\n+                        );\n+                        let implicit_into_iter = matches!(\n+                            fn_call_span.desugaring_kind(),\n+                            Some(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n+                        );\n+                        FnSelfUseKind::Normal { self_arg, implicit_into_iter }\n+                    };\n+\n+                    return FnSelfUse {\n+                        var_span: stmt.source_info.span,\n+                        fn_call_span,\n+                        fn_span: self\n+                            .infcx\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .guess_head_span(self.infcx.tcx.def_span(method_did)),\n+                        kind,\n+                    };\n+                }\n+            }\n+        }\n+        return normal_ret;\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`)"}, {"sha": "4883b08e424423a71265093c884a7d3e069d3476", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     format!(\"{}.as_ref()\", snippet),\n                     Applicability::MaybeIncorrect,\n                 );\n-            } else if span.is_desugaring(DesugaringKind::ForLoop)\n+            } else if matches!(span.desugaring_kind(), Some(DesugaringKind::ForLoop(_)))\n                 && self.infcx.tcx.is_diagnostic_item(Symbol::intern(\"vec_type\"), def_id)\n             {\n                 // FIXME: suggest for anything that implements `IntoIterator`."}, {"sha": "b4bc89e827daa7010b7608ab5b68ee73abb8a98b", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     opt_assignment_rhs_span.and_then(|span| span.desugaring_kind());\n                                 match opt_desugaring_kind {\n                                     // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop) => Some((\n+                                    Some(DesugaringKind::ForLoop(_)) => Some((\n                                         false,\n                                         opt_assignment_rhs_span.unwrap(),\n                                         format!(\n@@ -495,7 +495,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let closure_id = hir.as_local_hir_id(self.mir_def_id);\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n-        let item_id = hir.get_parent_item(fn_call_id);\n+        let item_id = hir.enclosing_body_owner(fn_call_id);\n         let mut look_at_return = true;\n         // If we can detect the expression to be an `fn` call where the closure was an argument,\n         // we point at the `fn` definition argument..."}, {"sha": "f1923b9e81c66ab23f591e80d3ea07a7d402b051", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -5,9 +5,9 @@ use rustc_infer::infer::{\n     error_reporting::nice_region_error::NiceRegionError,\n     error_reporting::unexpected_hidden_region_diagnostic, NLLRegionVariableOrigin,\n };\n-use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n \n use crate::util::borrowck_errors;\n@@ -26,7 +26,7 @@ impl ConstraintDescription for ConstraintCategory {\n         // Must end with a space. Allows for empty names to be provided.\n         match self {\n             ConstraintCategory::Assignment => \"assignment \",\n-            ConstraintCategory::Return => \"returning this value \",\n+            ConstraintCategory::Return(_) => \"returning this value \",\n             ConstraintCategory::Yield => \"yielding this value \",\n             ConstraintCategory::UseAsConst => \"using this value as a constant \",\n             ConstraintCategory::UseAsStatic => \"using this value as a static \",\n@@ -37,6 +37,7 @@ impl ConstraintDescription for ConstraintCategory {\n             ConstraintCategory::SizedBound => \"proving this value is `Sized` \",\n             ConstraintCategory::CopyBound => \"copying this value \",\n             ConstraintCategory::OpaqueType => \"opaque type \",\n+            ConstraintCategory::ClosureUpvar(_) => \"closure capture \",\n             ConstraintCategory::Boring\n             | ConstraintCategory::BoringNoLocation\n             | ConstraintCategory::Internal => \"\",\n@@ -306,8 +307,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n \n         let diag = match (category, fr_is_local, outlived_fr_is_local) {\n-            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(fr) => {\n-                self.report_fnmut_error(&errci)\n+            (ConstraintCategory::Return(kind), true, false) if self.is_closure_fn_mut(fr) => {\n+                self.report_fnmut_error(&errci, kind)\n             }\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => {\n@@ -347,7 +348,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ///            executing...\n     ///    = note: ...therefore, returned references to captured variables will escape the closure\n     /// ```\n-    fn report_fnmut_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n+    fn report_fnmut_error(\n+        &self,\n+        errci: &ErrorConstraintInfo,\n+        kind: ReturnConstraint,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n         let mut diag = self\n@@ -356,19 +361,39 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             .sess\n             .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n \n-        // We should check if the return type of this closure is in fact a closure - in that\n-        // case, we can special case the error further.\n-        let return_type_is_closure =\n-            self.regioncx.universal_regions().unnormalized_output_ty.is_closure();\n-        let message = if return_type_is_closure {\n-            \"returns a closure that contains a reference to a captured variable, which then \\\n-             escapes the closure body\"\n-        } else {\n-            \"returns a reference to a captured variable which escapes the closure body\"\n+        let mut output_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n+        if let ty::Opaque(def_id, _) = output_ty.kind {\n+            output_ty = self.infcx.tcx.type_of(def_id)\n+        };\n+\n+        debug!(\"report_fnmut_error: output_ty={:?}\", output_ty);\n+\n+        let message = match output_ty.kind {\n+            ty::Closure(_, _) => {\n+                \"returns a closure that contains a reference to a captured variable, which then \\\n+                 escapes the closure body\"\n+            }\n+            ty::Adt(def, _) if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did) => {\n+                \"returns an `async` block that contains a reference to a captured variable, which then \\\n+                 escapes the closure body\"\n+            }\n+            _ => \"returns a reference to a captured variable which escapes the closure body\",\n         };\n \n         diag.span_label(*span, message);\n \n+        if let ReturnConstraint::ClosureUpvar(upvar) = kind {\n+            let def_id = match self.regioncx.universal_regions().defining_ty {\n+                DefiningTy::Closure(def_id, _) => def_id,\n+                ty @ _ => bug!(\"unexpected DefiningTy {:?}\", ty),\n+            };\n+\n+            let upvar_def_span = self.infcx.tcx.hir().span(upvar);\n+            let upvar_span = self.infcx.tcx.upvars_mentioned(def_id).unwrap()[&upvar].span;\n+            diag.span_label(upvar_def_span, \"variable defined here\");\n+            diag.span_label(upvar_span, \"variable captured here\");\n+        }\n+\n         match self.give_region_a_name(*outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n@@ -506,7 +531,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         match (category, outlived_fr_is_local, fr_is_local) {\n-            (ConstraintCategory::Return, true, _) => {\n+            (ConstraintCategory::Return(_), true, _) => {\n                 diag.span_label(\n                     *span,\n                     format!("}, {"sha": "17fa641ae6c17d1c6edd2ee56e348d677d1454ca", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -142,6 +142,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 destination,\n                 cleanup: _,\n                 from_hir_call: _,\n+                fn_span: _,\n             } => {\n                 self.consume_operand(location, func);\n                 for arg in args {\n@@ -208,7 +209,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                             }\n                         }\n                         InlineAsmOperand::SymFn { value: _ }\n-                        | InlineAsmOperand::SymStatic { value: _ } => {}\n+                        | InlineAsmOperand::SymStatic { def_id: _ } => {}\n                     }\n                 }\n             }"}, {"sha": "d099f48adc5c6312534cacd1b74001c90d9eb326", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -216,6 +216,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         &mut flow_inits,\n         &mdpe.move_data,\n         &borrow_set,\n+        &upvars,\n     );\n \n     // Dump MIR results into a file, if that is enabled. This let us\n@@ -277,6 +278,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n                 move_data: &move_data,\n                 location_table: &LocationTable::new(promoted_body),\n                 movable_generator,\n+                fn_self_span_reported: Default::default(),\n                 locals_are_invalidated_at_exit,\n                 access_place_error_reported: Default::default(),\n                 reservation_error_reported: Default::default(),\n@@ -310,6 +312,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         location_table,\n         movable_generator,\n         locals_are_invalidated_at_exit,\n+        fn_self_span_reported: Default::default(),\n         access_place_error_reported: Default::default(),\n         reservation_error_reported: Default::default(),\n         reservation_warnings: Default::default(),\n@@ -486,6 +489,10 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     // but it is currently inconvenient to track down the `BorrowIndex`\n     // at the time we detect and report a reservation error.\n     reservation_error_reported: FxHashSet<Place<'tcx>>,\n+    /// This fields keeps track of the `Span`s that we have\n+    /// used to report extra information for `FnSelfUse`, to avoid\n+    /// unnecessarily verbose errors.\n+    fn_self_span_reported: FxHashSet<Span>,\n     /// Migration warnings to be reported for #56254. We delay reporting these\n     /// so that we can suppress the warning if there's a corresponding error\n     /// for the activation of the borrow.\n@@ -699,6 +706,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 ref destination,\n                 cleanup: _,\n                 from_hir_call: _,\n+                fn_span: _,\n             } => {\n                 self.consume_operand(loc, (func, span), flow_state);\n                 for arg in args {\n@@ -759,7 +767,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                             }\n                         }\n                         InlineAsmOperand::SymFn { value: _ }\n-                        | InlineAsmOperand::SymStatic { value: _ } => {}\n+                        | InlineAsmOperand::SymStatic { def_id: _ } => {}\n                     }\n                 }\n             }\n@@ -2307,30 +2315,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// be `self` in the current MIR, because that is the only time we directly access the fields\n     /// of a closure type.\n     pub fn is_upvar_field_projection(&self, place_ref: PlaceRef<'tcx>) -> Option<Field> {\n-        let mut place_projection = place_ref.projection;\n-        let mut by_ref = false;\n-\n-        if let [proj_base @ .., ProjectionElem::Deref] = place_projection {\n-            place_projection = proj_base;\n-            by_ref = true;\n-        }\n-\n-        match place_projection {\n-            [base @ .., ProjectionElem::Field(field, _ty)] => {\n-                let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.local, base, self.body(), tcx).ty;\n-\n-                if (base_ty.is_closure() || base_ty.is_generator())\n-                    && (!by_ref || self.upvars[field.index()].by_ref)\n-                {\n-                    Some(*field)\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            _ => None,\n-        }\n+        path_utils::is_upvar_field_projection(self.infcx.tcx, &self.upvars, place_ref, self.body())\n     }\n }\n "}, {"sha": "ea68364be37a339aa4e60d8dcf4dbfa78cb97cc6", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -39,6 +39,7 @@ use crate::borrow_check::{\n     renumber,\n     type_check::{self, MirTypeckRegionConstraints, MirTypeckResults},\n     universal_regions::UniversalRegions,\n+    Upvar,\n };\n \n crate type PoloniusOutput = Output<RustcFacts>;\n@@ -166,6 +167,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     flow_inits: &mut ResultsCursor<'cx, 'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n+    upvars: &[Upvar],\n ) -> NllOutput<'tcx> {\n     let mut all_facts = AllFacts::enabled(infcx.tcx).then_some(AllFacts::default());\n \n@@ -188,6 +190,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n             flow_inits,\n             move_data,\n             elements,\n+            upvars,\n         );\n \n     if let Some(all_facts) = &mut all_facts {\n@@ -314,7 +317,7 @@ pub(super) fn dump_mir_results<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n-    regioncx: &RegionInferenceContext<'_>,\n+    regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n ) {\n     if !mir_util::dump_enabled(infcx.tcx, \"nll\", source.def_id()) {\n@@ -325,7 +328,7 @@ pub(super) fn dump_mir_results<'a, 'tcx>(\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n             PassWhere::BeforeCFG => {\n-                regioncx.dump_mir(out)?;\n+                regioncx.dump_mir(infcx.tcx, out)?;\n                 writeln!(out, \"|\")?;\n \n                 if let Some(closure_region_requirements) = closure_region_requirements {"}, {"sha": "934729553a73be6588cc0f34b4b444cfd89d157e", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,10 +1,11 @@\n use crate::borrow_check::borrow_set::{BorrowData, BorrowSet, TwoPhaseActivation};\n use crate::borrow_check::places_conflict;\n use crate::borrow_check::AccessDepth;\n+use crate::borrow_check::Upvar;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::BorrowKind;\n-use rustc_middle::mir::{BasicBlock, Body, Location, Place};\n+use rustc_middle::mir::{BasicBlock, Body, Field, Location, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::TyCtxt;\n \n /// Returns `true` if the borrow represented by `kind` is\n@@ -135,3 +136,38 @@ pub(super) fn borrow_of_local_data(place: Place<'_>) -> bool {\n     // Any errors will be caught on the initial borrow\n     !place.is_indirect()\n }\n+\n+/// If `place` is a field projection, and the field is being projected from a closure type,\n+/// then returns the index of the field being projected. Note that this closure will always\n+/// be `self` in the current MIR, because that is the only time we directly access the fields\n+/// of a closure type.\n+pub(crate) fn is_upvar_field_projection(\n+    tcx: TyCtxt<'tcx>,\n+    upvars: &[Upvar],\n+    place_ref: PlaceRef<'tcx>,\n+    body: &Body<'tcx>,\n+) -> Option<Field> {\n+    let mut place_projection = place_ref.projection;\n+    let mut by_ref = false;\n+\n+    if let [proj_base @ .., ProjectionElem::Deref] = place_projection {\n+        place_projection = proj_base;\n+        by_ref = true;\n+    }\n+\n+    match place_projection {\n+        [base @ .., ProjectionElem::Field(field, _ty)] => {\n+            let base_ty = Place::ty_from(place_ref.local, base, body, tcx).ty;\n+\n+            if (base_ty.is_closure() || base_ty.is_generator())\n+                && (!by_ref || upvars[field.index()].by_ref)\n+            {\n+                Some(*field)\n+            } else {\n+                None\n+            }\n+        }\n+\n+        _ => None,\n+    }\n+}"}, {"sha": "d6e48deb031ac317326d72f27a85d7700726905a", "filename": "src/librustc_mir/borrow_check/region_infer/dump_mir.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -4,7 +4,9 @@\n //! context internal state.\n \n use super::{OutlivesConstraint, RegionInferenceContext};\n+use crate::borrow_check::type_check::Locations;\n use rustc_infer::infer::NLLRegionVariableOrigin;\n+use rustc_middle::ty::TyCtxt;\n use std::io::{self, Write};\n \n // Room for \"'_#NNNNr\" before things get misaligned.\n@@ -14,7 +16,7 @@ const REGION_WIDTH: usize = 8;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Write out our state into the `.mir` files.\n-    pub(crate) fn dump_mir(&self, out: &mut dyn Write) -> io::Result<()> {\n+    pub(crate) fn dump_mir(&self, tcx: TyCtxt<'tcx>, out: &mut dyn Write) -> io::Result<()> {\n         writeln!(out, \"| Free Region Mapping\")?;\n \n         for region in self.regions() {\n@@ -48,7 +50,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         writeln!(out, \"|\")?;\n         writeln!(out, \"| Inference Constraints\")?;\n-        self.for_each_constraint(&mut |msg| writeln!(out, \"| {}\", msg))?;\n+        self.for_each_constraint(tcx, &mut |msg| writeln!(out, \"| {}\", msg))?;\n \n         Ok(())\n     }\n@@ -59,6 +61,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// inference resulted in the values that it did when debugging.\n     fn for_each_constraint(\n         &self,\n+        tcx: TyCtxt<'tcx>,\n         with_msg: &mut dyn FnMut(&str) -> io::Result<()>,\n     ) -> io::Result<()> {\n         for region in self.definitions.indices() {\n@@ -72,7 +75,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         constraints.sort();\n         for constraint in &constraints {\n             let OutlivesConstraint { sup, sub, locations, category } = constraint;\n-            with_msg(&format!(\"{:?}: {:?} due to {:?} at {:?}\", sup, sub, category, locations,))?;\n+            let (name, arg) = match locations {\n+                Locations::All(span) => (\"All\", tcx.sess.source_map().span_to_string(*span)),\n+                Locations::Single(loc) => (\"Single\", format!(\"{:?}\", loc)),\n+            };\n+            with_msg(&format!(\"{:?}: {:?} due to {:?} at {}({})\", sup, sub, category, name, arg))?;\n         }\n \n         Ok(())"}, {"sha": "3e459bd52f75728838147bd09a77246c67b56c7f", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound}\n use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location,\n+    ConstraintCategory, Local, Location, ReturnConstraint,\n };\n use rustc_middle::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n@@ -2017,7 +2017,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     | ConstraintCategory::BoringNoLocation\n                     | ConstraintCategory::Internal => false,\n                     ConstraintCategory::TypeAnnotation\n-                    | ConstraintCategory::Return\n+                    | ConstraintCategory::Return(_)\n                     | ConstraintCategory::Yield => true,\n                     _ => constraint_sup_scc != target_scc,\n                 }\n@@ -2042,14 +2042,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n-                if categorized_path[i].0 == ConstraintCategory::Return\n+                if matches!(categorized_path[i].0, ConstraintCategory::Return(_))\n                     && next.0 == ConstraintCategory::OpaqueType\n                 {\n                     // The return expression is being influenced by the return type being\n                     // impl Trait, point at the return type and not the return expr.\n                     return *next;\n                 }\n             }\n+\n+            if categorized_path[i].0 == ConstraintCategory::Return(ReturnConstraint::Normal) {\n+                let field = categorized_path.iter().find_map(|p| {\n+                    if let ConstraintCategory::ClosureUpvar(f) = p.0 { Some(f) } else { None }\n+                });\n+\n+                if let Some(field) = field {\n+                    categorized_path[i].0 =\n+                        ConstraintCategory::Return(ReturnConstraint::ClosureUpvar(field));\n+                }\n+            }\n+\n             return categorized_path[i];\n         }\n "}, {"sha": "5707127340d87fa92bec7359fc80fcb08cf0635b", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -259,7 +259,13 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                     .param_env\n                     .and(type_op::normalize::Normalize::new(ty))\n                     .fully_perform(self.infcx)\n-                    .unwrap_or_else(|_| bug!(\"failed to normalize {:?}\", ty));\n+                    .unwrap_or_else(|_| {\n+                        self.infcx\n+                            .tcx\n+                            .sess\n+                            .delay_span_bug(DUMMY_SP, &format!(\"failed to normalize {:?}\", ty));\n+                        (self.infcx.tcx.types.err, None)\n+                    });\n                 let constraints2 = self.add_implied_bounds(ty);\n                 normalized_inputs_and_output.push(ty);\n                 constraints1.into_iter().chain(constraints2)"}, {"sha": "168612f9beec06f76832a1da662359a4cecedef8", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -55,13 +55,15 @@ use crate::borrow_check::{\n     location::LocationTable,\n     member_constraints::MemberConstraintSet,\n     nll::ToRegionVid,\n+    path_utils,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n     },\n     region_infer::{ClosureRegionRequirementsExt, TypeTest},\n     renumber,\n     type_check::free_region_relations::{CreateResult, UniversalRegionRelations},\n     universal_regions::{DefiningTy, UniversalRegions},\n+    Upvar,\n };\n \n macro_rules! span_mirbug {\n@@ -132,6 +134,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n+    upvars: &[Upvar],\n ) -> MirTypeckResults<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n@@ -162,6 +165,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         borrow_set,\n         all_facts,\n         constraints: &mut constraints,\n+        upvars,\n     };\n \n     let opaque_type_values = type_check_internal(\n@@ -577,7 +581,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         for constraint in constraints.outlives().iter() {\n             let mut constraint = *constraint;\n             constraint.locations = locations;\n-            if let ConstraintCategory::Return\n+            if let ConstraintCategory::Return(_)\n             | ConstraintCategory::UseAsConst\n             | ConstraintCategory::UseAsStatic = constraint.category\n             {\n@@ -827,6 +831,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n     all_facts: &'a mut Option<AllFacts>,\n     borrow_set: &'a BorrowSet<'tcx>,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n+    upvars: &'a [Upvar],\n }\n \n crate struct MirTypeckResults<'tcx> {\n@@ -1420,7 +1425,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ConstraintCategory::UseAsConst\n                             }\n                         } else {\n-                            ConstraintCategory::Return\n+                            ConstraintCategory::Return(ReturnConstraint::Normal)\n                         }\n                     }\n                     Some(l) if !body.local_decls[l].is_user_variable() => {\n@@ -1703,7 +1708,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ConstraintCategory::UseAsConst\n                             }\n                         } else {\n-                            ConstraintCategory::Return\n+                            ConstraintCategory::Return(ReturnConstraint::Normal)\n                         }\n                     }\n                     Some(l) if !body.local_decls[l].is_user_variable() => {\n@@ -2489,14 +2494,26 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n \n         let mut cursor = borrowed_place.projection.as_ref();\n+        let tcx = self.infcx.tcx;\n+        let field = path_utils::is_upvar_field_projection(\n+            tcx,\n+            &self.borrowck_context.upvars,\n+            borrowed_place.as_ref(),\n+            body,\n+        );\n+        let category = if let Some(field) = field {\n+            ConstraintCategory::ClosureUpvar(self.borrowck_context.upvars[field.index()].var_hir_id)\n+        } else {\n+            ConstraintCategory::Boring\n+        };\n+\n         while let [proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n \n             debug!(\"add_reborrow_constraint - iteration {:?}\", elem);\n \n             match elem {\n                 ProjectionElem::Deref => {\n-                    let tcx = self.infcx.tcx;\n                     let base_ty = Place::ty_from(borrowed_place.local, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n@@ -2506,7 +2523,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 sup: ref_region.to_region_vid(),\n                                 sub: borrow_region.to_region_vid(),\n                                 locations: location.to_locations(),\n-                                category: ConstraintCategory::Boring,\n+                                category,\n                             });\n \n                             match mutbl {"}, {"sha": "5deae94fe0c8e785086b005f72b626051e1e9d43", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2,7 +2,7 @@ use std::error::Error;\n use std::fmt;\n \n use rustc_middle::mir::AssertKind;\n-use rustc_span::Symbol;\n+use rustc_span::{Span, Symbol};\n \n use super::InterpCx;\n use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n@@ -53,8 +53,9 @@ impl Error for ConstEvalErrKind {}\n pub fn error_to_const_error<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>(\n     ecx: &InterpCx<'mir, 'tcx, M>,\n     error: InterpErrorInfo<'tcx>,\n+    span: Option<Span>,\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n     let stacktrace = ecx.generate_stacktrace();\n-    ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n+    ConstEvalErr { error: error.kind, stacktrace, span: span.unwrap_or_else(|| ecx.cur_span()) }\n }"}, {"sha": "d62300b3f55414b198bfce5da10eede285c61366", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -27,7 +27,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     body: &'mir mir::Body<'tcx>,\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n-    let tcx = ecx.tcx.tcx;\n+    let tcx = *ecx.tcx;\n     let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n@@ -81,13 +81,14 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n pub(super) fn mk_eval_cx<'mir, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    span: Span,\n+    root_span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n     can_access_statics: bool,\n ) -> CompileTimeEvalContext<'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n     InterpCx::new(\n-        tcx.at(span),\n+        tcx,\n+        root_span,\n         param_env,\n         CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics },\n@@ -163,7 +164,7 @@ pub(super) fn op_to_const<'tcx>(\n                         0,\n                     ),\n                 };\n-                let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n+                let len = b.to_machine_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();\n                 ConstValue::Slice { data, start, end: start + len }\n@@ -212,7 +213,7 @@ fn validate_and_turn_into_const<'tcx>(\n     })();\n \n     val.map_err(|error| {\n-        let err = error_to_const_error(&ecx, error);\n+        let err = error_to_const_error(&ecx, error, None);\n         err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n             diag.note(note_on_undefined_behavior_error());\n             diag.emit();\n@@ -299,26 +300,27 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let is_static = tcx.is_static(def_id);\n \n-    let span = tcx.def_span(cid.instance.def_id());\n     let mut ecx = InterpCx::new(\n-        tcx.at(span),\n+        tcx,\n+        tcx.def_span(cid.instance.def_id()),\n         key.param_env,\n         CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics: is_static },\n     );\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body))\n-        .and_then(|place| {\n-            Ok(RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n-        })\n+        .map(|place| RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n         .map_err(|error| {\n-            let err = error_to_const_error(&ecx, error);\n+            let err = error_to_const_error(&ecx, error, None);\n             // errors in statics are always emitted as fatal errors\n             if is_static {\n                 // Ensure that if the above error was either `TooGeneric` or `Reported`\n                 // an error must be reported.\n-                let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n+                let v = err.report_as_error(\n+                    ecx.tcx.at(ecx.cur_span()),\n+                    \"could not evaluate static initializer\",\n+                );\n \n                 // If this is `Reveal:All`, then we need to make sure an error is reported but if\n                 // this is `Reveal::UserFacing`, then it's expected that we could get a\n@@ -374,13 +376,16 @@ pub fn const_eval_raw_provider<'tcx>(\n                         // anything else (array lengths, enum initializers, constant patterns) are\n                         // reported as hard errors\n                         } else {\n-                            err.report_as_error(ecx.tcx, \"evaluation of constant value failed\")\n+                            err.report_as_error(\n+                                ecx.tcx.at(ecx.cur_span()),\n+                                \"evaluation of constant value failed\",\n+                            )\n                         }\n                     }\n                 }\n             } else {\n                 // use of broken constant from other crate\n-                err.report_as_error(ecx.tcx, \"could not evaluate constant\")\n+                err.report_as_error(ecx.tcx.at(ecx.cur_span()), \"could not evaluate constant\")\n             }\n         })\n }"}, {"sha": "6c9cb529dc2f3bdc8b817d89139b0dc8d28839de", "filename": "src/librustc_mir/dataflow/framework/direction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -467,7 +467,7 @@ impl Direction for Forward {\n                 propagate(target, exit_state);\n             }\n \n-            Call { cleanup, destination, ref func, ref args, from_hir_call: _ } => {\n+            Call { cleanup, destination, ref func, ref args, from_hir_call: _, fn_span: _ } => {\n                 if let Some(unwind) = cleanup {\n                     if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n                         propagate(unwind, exit_state);"}, {"sha": "9349f5133a55db43b2e41e46e708e6d980645c2f", "filename": "src/librustc_mir/dataflow/framework/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -41,6 +41,7 @@ fn mock_body() -> mir::Body<'static> {\n             destination: Some((dummy_place.clone(), mir::START_BLOCK)),\n             cleanup: None,\n             from_hir_call: false,\n+            fn_span: DUMMY_SP,\n         },\n     );\n     block(3, mir::TerminatorKind::Return);\n@@ -53,6 +54,7 @@ fn mock_body() -> mir::Body<'static> {\n             destination: Some((dummy_place.clone(), mir::START_BLOCK)),\n             cleanup: None,\n             from_hir_call: false,\n+            fn_span: DUMMY_SP,\n         },\n     );\n "}, {"sha": "41c7bd95a96cc1e877fe7e63362e76f3bdef3e84", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -401,6 +401,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 ref destination,\n                 cleanup: _,\n                 from_hir_call: _,\n+                fn_span: _,\n             } => {\n                 self.gather_operand(func);\n                 for arg in args {\n@@ -438,7 +439,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                             }\n                         }\n                         InlineAsmOperand::SymFn { value: _ }\n-                        | InlineAsmOperand::SymStatic { value: _ } => {}\n+                        | InlineAsmOperand::SymStatic { def_id: _ } => {}\n                     }\n                 }\n             }"}, {"sha": "cfe856abe36dda2ca6c6c073417d1c864c711138", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -268,11 +268,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n                 let ptr = self.read_immediate(src)?.to_scalar()?;\n                 // u64 cast is from usize to u64, which is always good\n-                let val = Immediate::new_slice(\n-                    ptr,\n-                    length.eval_usize(self.tcx.tcx, self.param_env),\n-                    self,\n-                );\n+                let val =\n+                    Immediate::new_slice(ptr, length.eval_usize(*self.tcx, self.param_env), self);\n                 self.write_immediate(val, dest)\n             }\n             (&ty::Dynamic(..), &ty::Dynamic(..)) => {"}, {"sha": "22f4691c22b3de81226fe406c8fafd6c427c04bd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -33,6 +33,8 @@ pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n+    /// The span in this is the \"root\" of the evaluation, i.e., the const\n+    /// we are evaluating (if this is CTFE).\n     pub tcx: TyCtxtAt<'tcx>,\n \n     /// Bounds in scope for polymorphic evaluations.\n@@ -171,15 +173,8 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n \n impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     /// Return the `SourceInfo` of the current instruction.\n-    pub fn current_source_info(&self) -> Option<mir::SourceInfo> {\n-        self.loc.map(|loc| {\n-            let block = &self.body.basic_blocks()[loc.block];\n-            if loc.statement_index < block.statements.len() {\n-                block.statements[loc.statement_index].source_info\n-            } else {\n-                block.terminator().source_info\n-            }\n-        })\n+    pub fn current_source_info(&self) -> Option<&mir::SourceInfo> {\n+        self.loc.map(|loc| self.body.source_info(loc))\n     }\n }\n \n@@ -209,7 +204,7 @@ where\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = InterpResult<'tcx, TyAndLayout<'tcx>>;\n \n@@ -292,24 +287,28 @@ pub(super) fn from_known_layout<'tcx>(\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn new(\n-        tcx: TyCtxtAt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+        root_span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n         memory_extra: M::MemoryExtra,\n     ) -> Self {\n         InterpCx {\n             machine,\n-            tcx,\n+            tcx: tcx.at(root_span),\n             param_env,\n             memory: Memory::new(tcx, memory_extra),\n             vtables: FxHashMap::default(),\n         }\n     }\n \n     #[inline(always)]\n-    pub fn set_span(&mut self, span: Span) {\n-        self.tcx.span = span;\n-        self.memory.tcx.span = span;\n+    pub fn cur_span(&self) -> Span {\n+        self.stack()\n+            .last()\n+            .and_then(|f| f.current_source_info())\n+            .map(|si| si.span)\n+            .unwrap_or(self.tcx.span)\n     }\n \n     #[inline(always)]\n@@ -392,7 +391,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n+        ty.is_freeze(*self.tcx, self.param_env, self.tcx.span)\n     }\n \n     pub fn load_mir(\n@@ -561,7 +560,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let size = size.align_to(align);\n \n                 // Check if this brought us over the size limit.\n-                if size.bytes() >= self.tcx.data_layout().obj_size_bound() {\n+                if size.bytes() >= self.tcx.data_layout.obj_size_bound() {\n                     throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n                 }\n                 Ok(Some((size, align)))\n@@ -577,7 +576,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let elem = layout.field(self, 0)?;\n \n                 // Make sure the slice is not too big.\n-                let size = elem.size.checked_mul(len, &*self.tcx).ok_or_else(|| {\n+                let size = elem.size.checked_mul(len, self).ok_or_else(|| {\n                     err_ub!(InvalidMeta(\"slice is bigger than largest supported object\"))\n                 })?;\n                 Ok(Some((size, elem.align.abi)))"}, {"sha": "3c724c79b4082448860d9fc256c272537a8342e6", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -111,7 +111,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     if let InternMode::Static(mutability) = mode {\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n-        let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx.tcx, ecx.param_env, ecx.tcx.span));\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(*ecx.tcx, ecx.param_env, ecx.tcx.span));\n         // For statics, allocation mutability is the combination of the place mutability and\n         // the type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n@@ -253,8 +253,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                         // caused (by somehow getting a mutable reference in a `const`).\n                         if ref_mutability == Mutability::Mut {\n                             match referenced_ty.kind {\n-                                ty::Array(_, n)\n-                                    if n.eval_usize(tcx.tcx, self.ecx.param_env) == 0 => {}\n+                                ty::Array(_, n) if n.eval_usize(*tcx, self.ecx.param_env) == 0 => {}\n                                 ty::Slice(_)\n                                     if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n                                         == 0 => {}"}, {"sha": "47e5b8b4fcec453a7be7951569878d52c76fa863", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -347,7 +347,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let elem = args[2];\n                 let input = args[0];\n-                let (len, e_ty) = input.layout.ty.simd_size_and_type(self.tcx.tcx);\n+                let (len, e_ty) = input.layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n                     \"Index `{}` must be in bounds of vector type `{}`: `[0, {})`\",\n@@ -374,7 +374,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             sym::simd_extract => {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n-                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(self.tcx.tcx);\n+                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n                     \"index `{}` is out-of-bounds of vector type `{}` with length `{}`\","}, {"sha": "9adef8c43c7c88971f04bfbca092b43698ba08f0", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,6 +1,7 @@\n use std::convert::TryFrom;\n \n use rustc_hir::lang_items::PanicLocationLangItem;\n+use rustc_middle::mir::TerminatorKind;\n use rustc_middle::ty::subst::Subst;\n use rustc_span::{Span, Symbol};\n use rustc_target::abi::LayoutOf;\n@@ -14,19 +15,39 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n     /// frame which is not `#[track_caller]`.\n     crate fn find_closest_untracked_caller_location(&self) -> Span {\n-        self.stack()\n+        let frame = self\n+            .stack()\n             .iter()\n             .rev()\n             // Find first non-`#[track_caller]` frame.\n-            .find(|frame| !frame.instance.def.requires_caller_location(*self.tcx))\n+            .find(|frame| {\n+                debug!(\n+                    \"find_closest_untracked_caller_location: checking frame {:?}\",\n+                    frame.instance\n+                );\n+                !frame.instance.def.requires_caller_location(*self.tcx)\n+            })\n             // Assert that there is always such a frame.\n-            .unwrap()\n-            .current_source_info()\n-            // Assert that the frame we look at is actually executing code currently\n-            // (`current_source_info` is None when we are unwinding and the frame does\n-            // not require cleanup).\n-            .unwrap()\n-            .span\n+            .unwrap();\n+        // Assert that the frame we look at is actually executing code currently\n+        // (`current_source_info` is None when we are unwinding and the frame does\n+        // not require cleanup).\n+        let loc = frame.loc.unwrap();\n+        // If this is a `Call` terminator, use the `fn_span` instead.\n+        let block = &frame.body.basic_blocks()[loc.block];\n+        if loc.statement_index == block.statements.len() {\n+            debug!(\n+                \"find_closest_untracked_caller_location:: got terminator {:?} ({:?})\",\n+                block.terminator(),\n+                block.terminator().kind\n+            );\n+            if let TerminatorKind::Call { fn_span, .. } = block.terminator().kind {\n+                return fn_span;\n+            }\n+        }\n+        // This is a different terminator (such as `Drop`) or not a terminator at all\n+        // (such as `box`). Use the normal span.\n+        frame.body.source_info(loc).span\n     }\n \n     /// Allocate a `const core::panic::Location` with the provided filename and line/column numbers."}, {"sha": "8af1a8ac608ac8f2a56f4bb61d0c4d455a2a037b", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -14,7 +14,7 @@ use std::ptr;\n \n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_middle::ty::{self, query::TyCtxtAt, Instance, ParamEnv};\n+use rustc_middle::ty::{self, Instance, ParamEnv, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n@@ -115,7 +115,7 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub extra: M::MemoryExtra,\n \n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub tcx: TyCtxtAt<'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n@@ -126,7 +126,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxtAt<'tcx>, extra: M::MemoryExtra) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, extra: M::MemoryExtra) -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n             extra_fn_ptr_map: FxHashMap::default(),\n@@ -425,7 +425,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// `M::tag_allocation`.\n     fn get_global_alloc(\n         memory_extra: &M::MemoryExtra,\n-        tcx: TyCtxtAt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n@@ -455,7 +455,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     throw_unsup!(ReadForeignStatic(def_id))\n                 }\n                 trace!(\"get_global_alloc: Need to compute {:?}\", def_id);\n-                let instance = Instance::mono(tcx.tcx, def_id);\n+                let instance = Instance::mono(tcx, def_id);\n                 let gid = GlobalId { instance, promoted: None };\n                 // Use the raw query here to break validation cycles. Later uses of the static\n                 // will call the full query anyway.\n@@ -664,14 +664,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n         // Cannot be a closure because it is generic in `Tag`, `Extra`.\n         fn write_allocation_track_relocs<'tcx, Tag: Copy + fmt::Debug, Extra>(\n-            tcx: TyCtxtAt<'tcx>,\n+            tcx: TyCtxt<'tcx>,\n             allocs_to_print: &mut VecDeque<AllocId>,\n             alloc: &Allocation<Tag, Extra>,\n         ) {\n             for &(_, target_id) in alloc.relocations().values() {\n                 allocs_to_print.push_back(target_id);\n             }\n-            pretty::write_allocation(tcx.tcx, alloc, &mut std::io::stderr()).unwrap();\n+            pretty::write_allocation(tcx, alloc, &mut std::io::stderr()).unwrap();\n         }\n \n         allocs.sort();\n@@ -820,7 +820,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 return Ok(());\n             }\n         };\n-        let tcx = self.tcx.tcx;\n+        let tcx = self.tcx;\n         self.get_raw_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n     }\n \n@@ -846,7 +846,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 return Ok(());\n             }\n         };\n-        let tcx = self.tcx.tcx;\n+        let tcx = self.tcx;\n         let allocation = self.get_raw_mut(ptr.alloc_id)?;\n \n         for idx in 0..len {\n@@ -888,7 +888,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let relocations =\n             self.get_raw(src.alloc_id)?.prepare_relocation_copy(self, src, size, dest, length);\n \n-        let tcx = self.tcx.tcx;\n+        let tcx = self.tcx;\n \n         // This checks relocation edges on the src.\n         let src_bytes ="}, {"sha": "38f5988d0eb3fd82eb27768994647d9c219f1d72", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -651,12 +651,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n                 let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n-                        adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == discr_bits)\n+                        adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n                     }\n                     ty::Generator(def_id, substs, _) => {\n                         let substs = substs.as_generator();\n                         substs\n-                            .discriminants(def_id, self.tcx.tcx)\n+                            .discriminants(def_id, *self.tcx)\n                             .find(|(_, var)| var.val == discr_bits)\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),"}, {"sha": "24b191e9b535ab6c2daf9f56db6813b69186dc5b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -404,7 +404,10 @@ where\n                     // to get some code to work that probably ought to work.\n                     field_layout.align.abi\n                 }\n-                None => bug!(\"Cannot compute offset for extern type field at non-0 offset\"),\n+                None => span_bug!(\n+                    self.cur_span(),\n+                    \"cannot compute offset for extern type field at non-0 offset\"\n+                ),\n             };\n             (base.meta, offset.align_to(align))\n         } else {\n@@ -440,7 +443,11 @@ where\n                 assert!(!field_layout.is_unsized());\n                 base.offset(offset, MemPlaceMeta::None, field_layout, self)\n             }\n-            _ => bug!(\"`mplace_index` called on non-array type {:?}\", base.layout.ty),\n+            _ => span_bug!(\n+                self.cur_span(),\n+                \"`mplace_index` called on non-array type {:?}\",\n+                base.layout.ty\n+            ),\n         }\n     }\n \n@@ -454,7 +461,7 @@ where\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n             FieldsShape::Array { stride, .. } => stride,\n-            _ => bug!(\"mplace_array_fields: expected an array layout\"),\n+            _ => span_bug!(self.cur_span(), \"mplace_array_fields: expected an array layout\"),\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n@@ -484,7 +491,9 @@ where\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n             FieldsShape::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n-            _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n+            _ => {\n+                span_bug!(self.cur_span(), \"unexpected layout of index access: {:#?}\", base.layout)\n+            }\n         };\n \n         // Compute meta and new layout\n@@ -497,7 +506,9 @@ where\n                 let len = Scalar::from_machine_usize(inner_len, self);\n                 (MemPlaceMeta::Meta(len), base.layout.ty)\n             }\n-            _ => bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n+            _ => {\n+                span_bug!(self.cur_span(), \"cannot subslice non-array type: `{:?}`\", base.layout.ty)\n+            }\n         };\n         let layout = self.layout_of(ty)?;\n         base.offset(from_offset, meta, layout, self)\n@@ -768,20 +779,22 @@ where\n             None => return Ok(()), // zero-sized access\n         };\n \n-        let tcx = &*self.tcx;\n+        let tcx = *self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n         // cover all the bytes!\n         match value {\n             Immediate::Scalar(scalar) => {\n                 match dest.layout.abi {\n                     Abi::Scalar(_) => {} // fine\n-                    _ => {\n-                        bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\", dest.layout)\n-                    }\n+                    _ => span_bug!(\n+                        self.cur_span(),\n+                        \"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n+                        dest.layout\n+                    ),\n                 }\n                 self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(\n-                    tcx,\n+                    &tcx,\n                     ptr,\n                     scalar,\n                     dest.layout.size,\n@@ -793,7 +806,8 @@ where\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = match dest.layout.abi {\n                     Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\n+                    _ => span_bug!(\n+                        self.cur_span(),\n                         \"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n                         dest.layout\n                     ),\n@@ -806,8 +820,8 @@ where\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n \n-                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(tcx, ptr, a_val, a_size)?;\n-                self.memory.get_raw_mut(b_ptr.alloc_id)?.write_scalar(tcx, b_ptr, b_val, b_size)\n+                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(&tcx, ptr, a_val, a_size)?;\n+                self.memory.get_raw_mut(b_ptr.alloc_id)?.write_scalar(&tcx, b_ptr, b_val, b_size)\n             }\n         }\n     }\n@@ -841,9 +855,9 @@ where\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        if !mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n+        if !mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n             span_bug!(\n-                self.tcx.span,\n+                self.cur_span(),\n                 \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n                 src.layout.ty,\n                 dest.layout.ty,\n@@ -898,7 +912,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n+        if mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }\n@@ -910,7 +924,7 @@ where\n             // on `typeck_tables().has_errors` at all const eval entry points.\n             debug!(\"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n             self.tcx.sess.delay_span_bug(\n-                self.tcx.span,\n+                self.cur_span(),\n                 \"size-changing transmute, should have been caught by transmute checking\",\n             );\n             throw_inval!(TransmuteSizeDiff(src.layout.ty, dest.layout.ty));"}, {"sha": "16c6396799e634eedbb067b7409966875ccb2208", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -76,7 +76,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", stmt);\n-        self.set_span(stmt.source_info.span);\n \n         use rustc_middle::mir::StatementKind::*;\n \n@@ -279,7 +278,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", terminator.kind);\n-        self.set_span(terminator.source_info.span);\n \n         self.eval_terminator(terminator)?;\n         if !self.stack().is_empty() {"}, {"sha": "cd7621ea9752b4ebc51a0d40394b060bb7a74346", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -56,6 +56,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 destination,\n                 ref cleanup,\n                 from_hir_call: _from_hir_call,\n+                fn_span: _,\n             } => {\n                 let old_stack = self.frame_idx();\n                 let old_loc = self.frame().loc;"}, {"sha": "a1d124bb7602ebb1408107d5840e90e073e56fbb", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2,7 +2,7 @@ use std::convert::TryFrom;\n \n use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n-use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size};\n+use rustc_target::abi::{Align, LayoutOf, Size};\n \n use super::{FnVal, InterpCx, Machine, MemoryKind};\n \n@@ -49,8 +49,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let size = layout.size.bytes();\n         let align = layout.align.abi.bytes();\n \n+        let tcx = *self.tcx;\n         let ptr_size = self.pointer_size();\n-        let ptr_align = self.tcx.data_layout.pointer_align.abi;\n+        let ptr_align = tcx.data_layout.pointer_align.abi;\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         // If you touch this code, be sure to also make the corresponding changes to\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n@@ -60,33 +61,32 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ptr_align,\n             MemoryKind::Vtable,\n         );\n-        let tcx = &*self.tcx;\n \n-        let drop = Instance::resolve_drop_in_place(*tcx, ty);\n+        let drop = Instance::resolve_drop_in_place(tcx, ty);\n         let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n         // No need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n         // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n         let vtable_alloc = self.memory.get_raw_mut(vtable.alloc_id)?;\n-        vtable_alloc.write_ptr_sized(tcx, vtable, drop.into())?;\n+        vtable_alloc.write_ptr_sized(&tcx, vtable, drop.into())?;\n \n-        let size_ptr = vtable.offset(ptr_size, tcx)?;\n-        vtable_alloc.write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n-        let align_ptr = vtable.offset(ptr_size * 2, tcx)?;\n-        vtable_alloc.write_ptr_sized(tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n+        let size_ptr = vtable.offset(ptr_size, &tcx)?;\n+        vtable_alloc.write_ptr_sized(&tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n+        let align_ptr = vtable.offset(ptr_size * 2, &tcx)?;\n+        vtable_alloc.write_ptr_sized(&tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 // resolve for vtable: insert shims where needed\n                 let instance =\n-                    ty::Instance::resolve_for_vtable(*tcx, self.param_env, def_id, substs)\n+                    ty::Instance::resolve_for_vtable(tcx, self.param_env, def_id, substs)\n                         .ok_or_else(|| err_inval!(TooGeneric))?;\n                 let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                 // We cannot use `vtable_allic` as we are creating fn ptrs in this loop.\n-                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), tcx)?;\n+                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &tcx)?;\n                 self.memory.get_raw_mut(vtable.alloc_id)?.write_ptr_sized(\n-                    tcx,\n+                    &tcx,\n                     method_ptr,\n                     fn_ptr.into(),\n                 )?;\n@@ -171,7 +171,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.not_undef()?;\n         let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n \n-        if size >= self.tcx.data_layout().obj_size_bound() {\n+        if size >= self.tcx.data_layout.obj_size_bound() {\n             throw_ub_format!(\n                 \"invalid vtable: \\\n                 size is bigger than largest supported object\""}, {"sha": "994d1e69f2e3e709cefadfa34f4205121b151bf7", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -634,9 +634,19 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::TerminatorKind::InlineAsm { ref operands, .. } => {\n                 for op in operands {\n-                    if let mir::InlineAsmOperand::SymFn { value } = op {\n-                        let fn_ty = self.monomorphize(value.literal.ty);\n-                        visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n+                    match *op {\n+                        mir::InlineAsmOperand::SymFn { ref value } => {\n+                            let fn_ty = self.monomorphize(value.literal.ty);\n+                            visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n+                        }\n+                        mir::InlineAsmOperand::SymStatic { def_id } => {\n+                            let instance = Instance::mono(self.tcx, def_id);\n+                            if should_monomorphize_locally(self.tcx, &instance) {\n+                                trace!(\"collecting asm sym static {:?}\", def_id);\n+                                self.output.push(MonoItem::Static(def_id));\n+                            }\n+                        }\n+                        _ => {}\n                     }\n                 }\n             }"}, {"sha": "f95fd9b9e90c562f51b31024f7795957268934f9", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -460,6 +460,7 @@ impl CloneShimBuilder<'tcx> {\n                 destination: Some((dest, next)),\n                 cleanup: Some(cleanup),\n                 from_hir_call: true,\n+                fn_span: self.span,\n             },\n             false,\n         );\n@@ -788,6 +789,7 @@ fn build_call_shim<'tcx>(\n                 None\n             },\n             from_hir_call: true,\n+            fn_span: span,\n         },\n         false,\n     );"}, {"sha": "e4aa88e3c20a7d611c218c4a74e94cb05b21a891", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::ty::{self, TyCtxt};\n pub use self::qualifs::Qualif;\n \n mod ops;\n+pub mod post_drop_elaboration;\n pub mod qualifs;\n mod resolver;\n pub mod validation;"}, {"sha": "d5059c98c9511053c4c14f9eb44f19ae421a3d7d", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -10,6 +10,22 @@ use rustc_span::{Span, Symbol};\n \n use super::ConstCx;\n \n+/// Emits an error if `op` is not allowed in the given const context.\n+pub fn non_const<O: NonConstOp>(ccx: &ConstCx<'_, '_>, op: O, span: Span) {\n+    debug!(\"illegal_op: op={:?}\", op);\n+\n+    if op.is_allowed_in_item(ccx) {\n+        return;\n+    }\n+\n+    if ccx.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+        ccx.tcx.sess.miri_unleashed_feature(span, O::feature_gate());\n+        return;\n+    }\n+\n+    op.emit_error(ccx, span);\n+}\n+\n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n     /// Returns the `Symbol` corresponding to the feature gate that would enable this operation,"}, {"sha": "226e0e2049ebd62a47818d324586309529c68650", "filename": "src/librustc_mir/transform/check_consts/post_drop_elaboration.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,119 @@\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::mir::visit::Visitor;\n+use rustc_middle::mir::{self, BasicBlock, Location};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::Span;\n+\n+use super::ops;\n+use super::qualifs::{NeedsDrop, Qualif};\n+use super::validation::Qualifs;\n+use super::ConstCx;\n+\n+/// Returns `true` if we should use the more precise live drop checker that runs after drop\n+/// elaboration.\n+pub fn checking_enabled(tcx: TyCtxt<'tcx>) -> bool {\n+    tcx.features().const_precise_live_drops\n+}\n+\n+/// Look for live drops in a const context.\n+///\n+/// This is separate from the rest of the const checking logic because it must run after drop\n+/// elaboration.\n+pub fn check_live_drops(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &mir::Body<'tcx>) {\n+    let const_kind = tcx.hir().body_const_context(def_id);\n+    if const_kind.is_none() {\n+        return;\n+    }\n+\n+    if !checking_enabled(tcx) {\n+        return;\n+    }\n+\n+    let ccx = ConstCx {\n+        body,\n+        tcx,\n+        def_id: def_id.to_def_id(),\n+        const_kind,\n+        param_env: tcx.param_env(def_id),\n+    };\n+\n+    let mut visitor = CheckLiveDrops { ccx: &ccx, qualifs: Qualifs::default() };\n+\n+    visitor.visit_body(body);\n+}\n+\n+struct CheckLiveDrops<'mir, 'tcx> {\n+    ccx: &'mir ConstCx<'mir, 'tcx>,\n+    qualifs: Qualifs<'mir, 'tcx>,\n+}\n+\n+// So we can access `body` and `tcx`.\n+impl std::ops::Deref for CheckLiveDrops<'mir, 'tcx> {\n+    type Target = ConstCx<'mir, 'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.ccx\n+    }\n+}\n+\n+impl CheckLiveDrops<'mir, 'tcx> {\n+    fn check_live_drop(&self, span: Span) {\n+        ops::non_const(self.ccx, ops::LiveDrop, span);\n+    }\n+}\n+\n+impl Visitor<'tcx> for CheckLiveDrops<'mir, 'tcx> {\n+    fn visit_basic_block_data(&mut self, bb: BasicBlock, block: &mir::BasicBlockData<'tcx>) {\n+        trace!(\"visit_basic_block_data: bb={:?} is_cleanup={:?}\", bb, block.is_cleanup);\n+\n+        // Ignore drop terminators in cleanup blocks.\n+        if block.is_cleanup {\n+            return;\n+        }\n+\n+        self.super_basic_block_data(bb, block);\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n+        trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n+\n+        match &terminator.kind {\n+            mir::TerminatorKind::Drop { location: dropped_place, .. } => {\n+                let dropped_ty = dropped_place.ty(self.body, self.tcx).ty;\n+                if !NeedsDrop::in_any_value_of_ty(self.ccx, dropped_ty) {\n+                    return;\n+                }\n+\n+                if dropped_place.is_indirect() {\n+                    self.check_live_drop(terminator.source_info.span);\n+                    return;\n+                }\n+\n+                if self.qualifs.needs_drop(self.ccx, dropped_place.local, location) {\n+                    // Use the span where the dropped local was declared for the error.\n+                    let span = self.body.local_decls[dropped_place.local].source_info.span;\n+                    self.check_live_drop(span);\n+                }\n+            }\n+\n+            mir::TerminatorKind::DropAndReplace { .. } => span_bug!(\n+                terminator.source_info.span,\n+                \"`DropAndReplace` should be removed by drop elaboration\",\n+            ),\n+\n+            mir::TerminatorKind::Abort\n+            | mir::TerminatorKind::Call { .. }\n+            | mir::TerminatorKind::Assert { .. }\n+            | mir::TerminatorKind::FalseEdge { .. }\n+            | mir::TerminatorKind::FalseUnwind { .. }\n+            | mir::TerminatorKind::GeneratorDrop\n+            | mir::TerminatorKind::Goto { .. }\n+            | mir::TerminatorKind::InlineAsm { .. }\n+            | mir::TerminatorKind::Resume\n+            | mir::TerminatorKind::Return\n+            | mir::TerminatorKind::SwitchInt { .. }\n+            | mir::TerminatorKind::Unreachable\n+            | mir::TerminatorKind::Yield { .. } => {}\n+        }\n+    }\n+}"}, {"sha": "936c1a84e142eb9a595c042c016dfe695eac7303", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2,7 +2,6 @@\n //!\n //! See the `Qualif` trait for more info.\n \n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n@@ -137,10 +136,7 @@ impl Qualif for CustomEq {\n         substs: SubstsRef<'tcx>,\n     ) -> bool {\n         let ty = cx.tcx.mk_ty(ty::Adt(adt, substs));\n-        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id.as_local().unwrap());\n-        cx.tcx\n-            .infer_ctxt()\n-            .enter(|infcx| !traits::type_marked_structural(id, cx.body.span, &infcx, ty))\n+        !ty.is_structural_eq_shallow(cx.tcx)\n     }\n }\n "}, {"sha": "428a74bcdcbfba54599dbdf49723e40906ad5160", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -40,7 +40,7 @@ pub struct Qualifs<'mir, 'tcx> {\n }\n \n impl Qualifs<'mir, 'tcx> {\n-    fn indirectly_mutable(\n+    pub fn indirectly_mutable(\n         &mut self,\n         ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n@@ -68,7 +68,7 @@ impl Qualifs<'mir, 'tcx> {\n     /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary\n-    fn needs_drop(\n+    pub fn needs_drop(\n         &mut self,\n         ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n@@ -95,7 +95,7 @@ impl Qualifs<'mir, 'tcx> {\n     /// Returns `true` if `local` is `HasMutInterior` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary.\n-    fn has_mut_interior(\n+    pub fn has_mut_interior(\n         &mut self,\n         ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n@@ -232,30 +232,15 @@ impl Validator<'mir, 'tcx> {\n         self.qualifs.in_return_place(self.ccx)\n     }\n \n-    /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n-    /// context.\n-    pub fn check_op_spanned<O>(&mut self, op: O, span: Span)\n-    where\n-        O: NonConstOp,\n-    {\n-        debug!(\"check_op: op={:?}\", op);\n-\n-        if op.is_allowed_in_item(self) {\n-            return;\n-        }\n-\n-        if self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-            self.tcx.sess.miri_unleashed_feature(span, O::feature_gate());\n-            return;\n-        }\n-\n-        op.emit_error(self, span);\n-    }\n-\n     /// Emits an error if an expression cannot be evaluated in the current context.\n     pub fn check_op(&mut self, op: impl NonConstOp) {\n-        let span = self.span;\n-        self.check_op_spanned(op, span)\n+        ops::non_const(self.ccx, op, self.span);\n+    }\n+\n+    /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n+    /// context.\n+    pub fn check_op_spanned(&mut self, op: impl NonConstOp, span: Span) {\n+        ops::non_const(self.ccx, op, span);\n     }\n \n     fn check_static(&mut self, def_id: DefId, span: Span) {\n@@ -577,6 +562,12 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             // projections that cannot be `NeedsDrop`.\n             TerminatorKind::Drop { location: dropped_place, .. }\n             | TerminatorKind::DropAndReplace { location: dropped_place, .. } => {\n+                // If we are checking live drops after drop-elaboration, don't emit duplicate\n+                // errors here.\n+                if super::post_drop_elaboration::checking_enabled(self.tcx) {\n+                    return;\n+                }\n+\n                 let mut err_span = self.span;\n \n                 // Check to see if the type of this place can ever have a drop impl. If not, this"}, {"sha": "043b2d0d1703e260977a00f8627cfee836021342", "filename": "src/librustc_mir/transform/check_packed_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_packed_ref.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PackedRefChecker<'a, 'tcx> {\n                     lint_root,\n                     source_info.span,\n                     |lint| {\n-                        lint.build(&format!(\"reference to packed field is unaligned\",))\n+                        lint.build(\"reference to packed field is unaligned\")\n                             .note(\n                                 \"fields of packed structs are not properly aligned, and creating \\\n                                 a misaligned reference is undefined behavior (even if that \\"}, {"sha": "83ed2fc2d439bf8a838a57ed1c58b33f9a48f37e", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -313,7 +313,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id).with_reveal_all();\n \n         let span = tcx.def_span(def_id);\n-        let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine::new(), ());\n+        let mut ecx = InterpCx::new(tcx, span, param_env, ConstPropMachine::new(), ());\n         let can_const_prop = CanConstProp::check(body);\n \n         let ret = ecx\n@@ -404,9 +404,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         match self.ecx.eval_const_to_op(c.literal, None) {\n             Ok(op) => Some(op),\n             Err(error) => {\n-                // Make sure errors point at the constant.\n-                self.ecx.set_span(c.span);\n-                let err = error_to_const_error(&self.ecx, error);\n+                let tcx = self.ecx.tcx.at(c.span);\n+                let err = error_to_const_error(&self.ecx, error, Some(c.span));\n                 if let Some(lint_root) = self.lint_root(source_info) {\n                     let lint_only = match c.literal.val {\n                         // Promoteds must lint and not error as the user didn't ask for them\n@@ -418,17 +417,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     if lint_only {\n                         // Out of backwards compatibility we cannot report hard errors in unused\n                         // generic functions using associated constants of the generic parameters.\n-                        err.report_as_lint(\n-                            self.ecx.tcx,\n-                            \"erroneous constant used\",\n-                            lint_root,\n-                            Some(c.span),\n-                        );\n+                        err.report_as_lint(tcx, \"erroneous constant used\", lint_root, Some(c.span));\n                     } else {\n-                        err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                        err.report_as_error(tcx, \"erroneous constant used\");\n                     }\n                 } else {\n-                    err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                    err.report_as_error(tcx, \"erroneous constant used\");\n                 }\n                 None\n             }\n@@ -511,6 +505,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // This is basically `force_bits`.\n             let r_bits = r_bits.and_then(|r| r.to_bits_or_ptr(right_size, &self.tcx).ok());\n             if r_bits.map_or(false, |b| b >= left_size_bits as u128) {\n+                debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n                     source_info,\n@@ -851,7 +846,6 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n     fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n-        self.ecx.set_span(source_info.span);\n         self.source_info = Some(source_info);\n         if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n             let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n@@ -864,7 +858,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                         if let Some(value) = self.get_const(place) {\n                             if self.should_const_prop(value) {\n                                 trace!(\"replacing {:?} with {:?}\", rval, value);\n-                                self.replace_with_const(rval, value, statement.source_info);\n+                                self.replace_with_const(rval, value, source_info);\n                                 if can_const_prop == ConstPropMode::FullConstProp\n                                     || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n                                 {\n@@ -927,7 +921,6 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n \n     fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n         let source_info = terminator.source_info;\n-        self.ecx.set_span(source_info.span);\n         self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n         match &mut terminator.kind {"}, {"sha": "4240b528a6124c2be08d34ddcbb8ad0b55466b19", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -49,6 +49,7 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n         mir_const,\n         mir_const_qualif,\n         mir_validated,\n+        mir_drops_elaborated_and_const_checked,\n         optimized_mir,\n         is_mir_available,\n         promoted_mir,\n@@ -294,12 +295,31 @@ fn mir_validated(\n     (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n }\n \n-fn run_optimization_passes<'tcx>(\n+fn mir_drops_elaborated_and_const_checked<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> Steal<Body<'tcx>> {\n+    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n+    // execute before we can steal.\n+    tcx.ensure().mir_borrowck(def_id);\n+\n+    let (body, _) = tcx.mir_validated(def_id);\n+    let mut body = body.steal();\n+\n+    run_post_borrowck_cleanup_passes(tcx, &mut body, def_id, None);\n+    check_consts::post_drop_elaboration::check_live_drops(tcx, def_id, &body);\n+    tcx.alloc_steal_mir(body)\n+}\n+\n+/// After this series of passes, no lifetime analysis based on borrowing can be done.\n+fn run_post_borrowck_cleanup_passes<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     def_id: LocalDefId,\n     promoted: Option<Promoted>,\n ) {\n+    debug!(\"post_borrowck_cleanup({:?})\", def_id);\n+\n     let post_borrowck_cleanup: &[&dyn MirPass<'tcx>] = &[\n         // Remove all things only needed by analysis\n         &no_landing_pads::NoLandingPads::new(tcx),\n@@ -318,9 +338,24 @@ fn run_optimization_passes<'tcx>(\n         // but before optimizations begin.\n         &add_retag::AddRetag,\n         &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n-        // No lifetime analysis based on borrowing can be done from here on out.\n     ];\n \n+    run_passes(\n+        tcx,\n+        body,\n+        InstanceDef::Item(def_id.to_def_id()),\n+        promoted,\n+        MirPhase::DropElab,\n+        &[post_borrowck_cleanup],\n+    );\n+}\n+\n+fn run_optimization_passes<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    def_id: LocalDefId,\n+    promoted: Option<Promoted>,\n+) {\n     let optimizations: &[&dyn MirPass<'tcx>] = &[\n         &unreachable_prop::UnreachablePropagation,\n         &uninhabited_enum_branching::UninhabitedEnumBranching,\n@@ -368,14 +403,14 @@ fn run_optimization_passes<'tcx>(\n \n     let mir_opt_level = tcx.sess.opts.debugging_opts.mir_opt_level;\n \n+    #[rustfmt::skip]\n     run_passes(\n         tcx,\n         body,\n         InstanceDef::Item(def_id.to_def_id()),\n         promoted,\n         MirPhase::Optimized,\n         &[\n-            post_borrowck_cleanup,\n             if mir_opt_level > 0 { optimizations } else { no_optimizations },\n             pre_codegen_cleanup,\n         ],\n@@ -393,12 +428,7 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n \n     let def_id = def_id.expect_local();\n \n-    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n-    // execute before we can steal.\n-    tcx.ensure().mir_borrowck(def_id);\n-\n-    let (body, _) = tcx.mir_validated(def_id);\n-    let mut body = body.steal();\n+    let mut body = tcx.mir_drops_elaborated_and_const_checked(def_id).steal();\n     run_optimization_passes(tcx, &mut body, def_id, None);\n \n     debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n@@ -418,6 +448,7 @@ fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> IndexVec<Promoted, Body<'_>>\n     let mut promoted = promoted.steal();\n \n     for (p, mut body) in promoted.iter_enumerated_mut() {\n+        run_post_borrowck_cleanup_passes(tcx, &mut body, def_id, Some(p));\n         run_optimization_passes(tcx, &mut body, def_id, Some(p));\n     }\n "}, {"sha": "1f3d7bb7cc6f41c2ab16dcf425667893c323462f", "filename": "src/librustc_mir/transform/nrvo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -111,7 +111,7 @@ fn local_eligible_for_nrvo(body: &mut mir::Body<'_>) -> Option<Local> {\n         copied_to_return_place = Some(returned_local);\n     }\n \n-    return copied_to_return_place;\n+    copied_to_return_place\n }\n \n fn find_local_assigned_to_return_place(\n@@ -136,7 +136,7 @@ fn find_local_assigned_to_return_place(\n         }\n     }\n \n-    return None;\n+    None\n }\n \n // If this statement is an assignment of an unprojected local to the return place,"}, {"sha": "e1311ccd3746fbb1b346c482ed1a7e9c17b01ab7", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -909,7 +909,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             };\n \n             match terminator.kind {\n-                TerminatorKind::Call { mut func, mut args, from_hir_call, .. } => {\n+                TerminatorKind::Call { mut func, mut args, from_hir_call, fn_span, .. } => {\n                     self.visit_operand(&mut func, loc);\n                     for arg in &mut args {\n                         self.visit_operand(arg, loc);\n@@ -925,6 +925,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             cleanup: None,\n                             destination: Some((Place::from(new_temp), new_target)),\n                             from_hir_call,\n+                            fn_span,\n                         },\n                         ..terminator\n                     };"}, {"sha": "4c8fc49099b2af109b4e5b9278f2d59df278b9e7", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -368,7 +368,14 @@ fn check_terminator(\n             Err((span, \"const fn generators are unstable\".into()))\n         }\n \n-        TerminatorKind::Call { func, args, from_hir_call: _, destination: _, cleanup: _ } => {\n+        TerminatorKind::Call {\n+            func,\n+            args,\n+            from_hir_call: _,\n+            destination: _,\n+            cleanup: _,\n+            fn_span: _,\n+        } => {\n             let fn_ty = func.ty(body, tcx);\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n                 if !crate::const_eval::is_min_const_fn(tcx, def_id) {"}, {"sha": "50136ac3becca6999e2d196b97c5c459dd74b958", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -99,7 +99,7 @@ fn get_arm_identity_info<'a, 'tcx>(stmts: &'a [Statement<'tcx>]) -> Option<ArmId\n     fn try_eat<'a, 'tcx>(\n         stmt_iter: &mut StmtIter<'a, 'tcx>,\n         test: impl Fn(&'a Statement<'tcx>) -> bool,\n-        mut action: impl FnMut(usize, &'a Statement<'tcx>) -> (),\n+        mut action: impl FnMut(usize, &'a Statement<'tcx>),\n     ) {\n         while stmt_iter.peek().map(|(_, stmt)| test(stmt)).unwrap_or(false) {\n             let (idx, stmt) = stmt_iter.next().unwrap();\n@@ -271,7 +271,7 @@ fn optimization_applies<'tcx>(\n     }\n \n     // Verify the assigment chain consists of the form b = a; c = b; d = c; etc...\n-    if opt_info.field_tmp_assignments.len() == 0 {\n+    if opt_info.field_tmp_assignments.is_empty() {\n         trace!(\"NO: no assignments found\");\n     }\n     let mut last_assigned_to = opt_info.field_tmp_assignments[0].1;\n@@ -306,7 +306,11 @@ fn optimization_applies<'tcx>(\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        if tcx.sess.opts.debugging_opts.mir_opt_level < 2 {\n+            return;\n+        }\n+\n         trace!(\"running SimplifyArmIdentity on {:?}\", source);\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         for bb in basic_blocks {"}, {"sha": "a1345452ca9793e63de8a4e905f45e26de7feb04", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -644,6 +644,7 @@ where\n                     destination: Some((unit_temp, succ)),\n                     cleanup: unwind.into_option(),\n                     from_hir_call: true,\n+                    fn_span: self.source_info.span,\n                 },\n                 source_info: self.source_info,\n             }),\n@@ -988,6 +989,7 @@ where\n             destination: Some((unit_temp, target)),\n             cleanup: None,\n             from_hir_call: false,\n+            fn_span: self.source_info.span,\n         }; // FIXME(#43234)\n         let free_block = self.new_block(unwind, call);\n "}, {"sha": "02614044063fce04a66dac26add05396ba11b64c", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -135,7 +135,7 @@ fn dump_matched_mir_node<'tcx, F>(\n         }\n         writeln!(file)?;\n         extra_data(PassWhere::BeforeCFG, &mut file)?;\n-        write_user_type_annotations(body, &mut file)?;\n+        write_user_type_annotations(tcx, body, &mut file)?;\n         write_mir_fn(tcx, source, body, &mut extra_data, &mut file)?;\n         extra_data(PassWhere::AfterCFG, &mut file)?;\n     };\n@@ -351,7 +351,7 @@ fn write_extra<'tcx, F>(tcx: TyCtxt<'tcx>, write: &mut dyn Write, mut visit_op:\n where\n     F: FnMut(&mut ExtraComments<'tcx>),\n {\n-    let mut extra_comments = ExtraComments { _tcx: tcx, comments: vec![] };\n+    let mut extra_comments = ExtraComments { tcx, comments: vec![] };\n     visit_op(&mut extra_comments);\n     for comment in extra_comments.comments {\n         writeln!(write, \"{:A$} // {}\", \"\", comment, A = ALIGN)?;\n@@ -360,7 +360,7 @@ where\n }\n \n struct ExtraComments<'tcx> {\n-    _tcx: TyCtxt<'tcx>, // don't need it now, but bet we will soon\n+    tcx: TyCtxt<'tcx>,\n     comments: Vec<String>,\n }\n \n@@ -377,7 +377,7 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n         self.super_constant(constant, location);\n         let Constant { span, user_ty, literal } = constant;\n         self.push(\"mir::Constant\");\n-        self.push(&format!(\"+ span: {:?}\", span));\n+        self.push(&format!(\"+ span: {}\", self.tcx.sess.source_map().span_to_string(*span)));\n         if let Some(user_ty) = user_ty {\n             self.push(&format!(\"+ user_ty: {:?}\", user_ty));\n         }\n@@ -862,12 +862,22 @@ fn write_mir_sig(\n     Ok(())\n }\n \n-fn write_user_type_annotations(body: &Body<'_>, w: &mut dyn Write) -> io::Result<()> {\n+fn write_user_type_annotations(\n+    tcx: TyCtxt<'_>,\n+    body: &Body<'_>,\n+    w: &mut dyn Write,\n+) -> io::Result<()> {\n     if !body.user_type_annotations.is_empty() {\n         writeln!(w, \"| User Type Annotations\")?;\n     }\n     for (index, annotation) in body.user_type_annotations.iter_enumerated() {\n-        writeln!(w, \"| {:?}: {:?} at {:?}\", index.index(), annotation.user_ty, annotation.span)?;\n+        writeln!(\n+            w,\n+            \"| {:?}: {:?} at {}\",\n+            index.index(),\n+            annotation.user_ty,\n+            tcx.sess.source_map().span_to_string(annotation.span)\n+        )?;\n     }\n     if !body.user_type_annotations.is_empty() {\n         writeln!(w, \"|\")?;"}, {"sha": "0d5bd4c7e61b90a5448f5c593a25bc9930b2a827", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -162,7 +162,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 });\n                 exit_block.unit()\n             }\n-            ExprKind::Call { ty, fun, args, from_hir_call } => {\n+            ExprKind::Call { ty, fun, args, from_hir_call, fn_span } => {\n                 let intrinsic = match ty.kind {\n                     ty::FnDef(def_id, _) => {\n                         let f = ty.fn_sig(this.hir.tcx());\n@@ -206,6 +206,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     this.record_operands_moved(&args);\n \n+                    debug!(\"into_expr: fn_span={:?}\", fn_span);\n+\n                     this.cfg.terminate(\n                         block,\n                         source_info,\n@@ -222,6 +224,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 Some((destination, success))\n                             },\n                             from_hir_call,\n+                            fn_span\n                         },\n                     );\n                     success.unit()\n@@ -355,8 +358,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         hair::InlineAsmOperand::SymFn { expr } => {\n                             mir::InlineAsmOperand::SymFn { value: box this.as_constant(expr) }\n                         }\n-                        hair::InlineAsmOperand::SymStatic { expr } => {\n-                            mir::InlineAsmOperand::SymStatic { value: box this.as_constant(expr) }\n+                        hair::InlineAsmOperand::SymStatic { def_id } => {\n+                            mir::InlineAsmOperand::SymStatic { def_id }\n                         }\n                     })\n                     .collect();"}, {"sha": "19948196f256fdf6c31e118fa06b9c1f8bf2bc74", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -10,7 +10,7 @@ use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::hair::{self, *};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::{fx::{FxHashMap, FxHashSet}, stack::ensure_sufficient_stack};\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::middle::region;\n@@ -909,30 +909,32 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             split_or_candidate |= self.simplify_candidate(candidate);\n         }\n \n-        if split_or_candidate {\n-            // At least one of the candidates has been split into subcandidates.\n-            // We need to change the candidate list to include those.\n-            let mut new_candidates = Vec::new();\n+        ensure_sufficient_stack(|| {\n+            if split_or_candidate {\n+                // At least one of the candidates has been split into subcandidates.\n+                // We need to change the candidate list to include those.\n+                let mut new_candidates = Vec::new();\n \n-            for candidate in candidates {\n-                candidate.visit_leaves(|leaf_candidate| new_candidates.push(leaf_candidate));\n+                for candidate in candidates {\n+                    candidate.visit_leaves(|leaf_candidate| new_candidates.push(leaf_candidate));\n+                }\n+                self.match_simplified_candidates(\n+                    span,\n+                    start_block,\n+                    otherwise_block,\n+                    &mut *new_candidates,\n+                    fake_borrows,\n+                );\n+            } else {\n+                self.match_simplified_candidates(\n+                    span,\n+                    start_block,\n+                    otherwise_block,\n+                    candidates,\n+                    fake_borrows,\n+                );\n             }\n-            self.match_simplified_candidates(\n-                span,\n-                start_block,\n-                otherwise_block,\n-                &mut *new_candidates,\n-                fake_borrows,\n-            );\n-        } else {\n-            self.match_simplified_candidates(\n-                span,\n-                start_block,\n-                otherwise_block,\n-                candidates,\n-                fake_borrows,\n-            );\n-        };\n+        });\n     }\n \n     fn match_simplified_candidates("}, {"sha": "2917a771a2cf87d956e5ba4ccdbd118985a0c578", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -160,13 +160,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                     ty::Int(ity) => {\n                         let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n-                        let max = truncate(u128::max_value(), size);\n+                        let max = truncate(u128::MAX, size);\n                         let bias = 1u128 << (size.bits() - 1);\n                         (Some((0, max, size)), bias)\n                     }\n                     ty::Uint(uty) => {\n                         let size = Integer::from_attr(&tcx, UnsignedInt(uty)).size();\n-                        let max = truncate(u128::max_value(), size);\n+                        let max = truncate(u128::MAX, size);\n                         (Some((0, max, size)), 0)\n                     }\n                     _ => (None, 0),"}, {"sha": "3e7bfc7d59b9b58d416c1da4368430fb5b660dab", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -443,6 +443,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 destination: Some((eq_result, eq_block)),\n                 cleanup: Some(cleanup),\n                 from_hir_call: false,\n+                fn_span: source_info.span\n             },\n         );\n "}, {"sha": "703f6ef8dc41e91fcc74c4e3ff8256f477d37dc1", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -139,11 +139,11 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n     let kind = match expr.kind {\n         // Here comes the interesting stuff:\n-        hir::ExprKind::MethodCall(_, method_span, ref args) => {\n+        hir::ExprKind::MethodCall(_, method_span, ref args, fn_span) => {\n             // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n             let expr = method_callee(cx, expr, method_span, None);\n             let args = args.iter().map(|e| e.to_ref()).collect();\n-            ExprKind::Call { ty: expr.ty, fun: expr.to_ref(), args, from_hir_call: true }\n+            ExprKind::Call { ty: expr.ty, fun: expr.to_ref(), args, from_hir_call: true, fn_span }\n         }\n \n         hir::ExprKind::Call(ref fun, ref args) => {\n@@ -170,6 +170,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                     fun: method.to_ref(),\n                     args: vec![fun.to_ref(), tupled_args.to_ref()],\n                     from_hir_call: true,\n+                    fn_span: expr.span,\n                 }\n             } else {\n                 let adt_data =\n@@ -215,6 +216,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                         from_hir_call: true,\n+                        fn_span: expr.span,\n                     }\n                 }\n             }\n@@ -465,25 +467,8 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                                     }\n                                 }\n \n-                                Res::Def(DefKind::Static, id) => {\n-                                    ty = cx.tcx.static_ptr_ty(id);\n-                                    let ptr = cx.tcx.create_static_alloc(id);\n-                                    InlineAsmOperand::SymStatic {\n-                                        expr: Expr {\n-                                            ty,\n-                                            temp_lifetime,\n-                                            span: expr.span,\n-                                            kind: ExprKind::StaticRef {\n-                                                literal: ty::Const::from_scalar(\n-                                                    cx.tcx,\n-                                                    Scalar::Ptr(ptr.into()),\n-                                                    ty,\n-                                                ),\n-                                                def_id: id,\n-                                            },\n-                                        }\n-                                        .to_ref(),\n-                                    }\n+                                Res::Def(DefKind::Static, def_id) => {\n+                                    InlineAsmOperand::SymStatic { def_id }\n                                 }\n \n                                 _ => {\n@@ -1024,7 +1009,7 @@ fn overloaded_operator<'a, 'tcx>(\n     args: Vec<ExprRef<'tcx>>,\n ) -> ExprKind<'tcx> {\n     let fun = method_callee(cx, expr, expr.span, None);\n-    ExprKind::Call { ty: fun.ty, fun: fun.to_ref(), args, from_hir_call: false }\n+    ExprKind::Call { ty: fun.ty, fun: fun.to_ref(), args, from_hir_call: false, fn_span: expr.span }\n }\n \n fn overloaded_place<'a, 'tcx>(\n@@ -1060,7 +1045,13 @@ fn overloaded_place<'a, 'tcx>(\n         temp_lifetime,\n         ty: ref_ty,\n         span: expr.span,\n-        kind: ExprKind::Call { ty: fun.ty, fun: fun.to_ref(), args, from_hir_call: false },\n+        kind: ExprKind::Call {\n+            ty: fun.ty,\n+            fun: fun.to_ref(),\n+            args,\n+            from_hir_call: false,\n+            fn_span: expr.span,\n+        },\n     };\n \n     // construct and return a deref wrapper `*foo()`"}, {"sha": "ccff510f2d4e5ca7d49ca2087018394bbf93e669", "filename": "src/librustc_mir_build/hair/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -146,6 +146,9 @@ crate enum ExprKind<'tcx> {\n         // Whether this is from a call in HIR, rather than from an overloaded\n         // operator. True for overloaded function call.\n         from_hir_call: bool,\n+        /// This `Span` is the span of the function, without the dot and receiver\n+        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        fn_span: Span,\n     },\n     Deref {\n         arg: ExprRef<'tcx>,\n@@ -374,7 +377,7 @@ crate enum InlineAsmOperand<'tcx> {\n         expr: ExprRef<'tcx>,\n     },\n     SymStatic {\n-        expr: ExprRef<'tcx>,\n+        def_id: DefId,\n     },\n }\n "}, {"sha": "4a4de6c420bd80d86b472f26dcb40af7ef533e13", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 272, "deletions": 272, "changes": 544, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,274 +1,274 @@\n-/// Note: most of the tests relevant to this file can be found (at the time of writing) in\n-/// src/tests/ui/pattern/usefulness.\n-///\n-/// This file includes the logic for exhaustiveness and usefulness checking for\n-/// pattern-matching. Specifically, given a list of patterns for a type, we can\n-/// tell whether:\n-/// (a) the patterns cover every possible constructor for the type [exhaustiveness]\n-/// (b) each pattern is necessary [usefulness]\n-///\n-/// The algorithm implemented here is a modified version of the one described in:\n-/// http://moscova.inria.fr/~maranget/papers/warn/index.html\n-/// However, to save future implementors from reading the original paper, we\n-/// summarise the algorithm here to hopefully save time and be a little clearer\n-/// (without being so rigorous).\n-///\n-/// # Premise\n-///\n-/// The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n-/// are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n-/// a matrix). `U(P, p)` represents whether, given an existing list of patterns\n-/// `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n-/// uncovered values of the type).\n-///\n-/// If we have this predicate, then we can easily compute both exhaustiveness of an\n-/// entire set of patterns and the individual usefulness of each one.\n-/// (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n-/// match doesn't increase the number of values we're matching)\n-/// (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n-/// pattern to those that have come before it doesn't increase the number of values\n-/// we're matching).\n-///\n-/// # Core concept\n-///\n-/// The idea that powers everything that is done in this file is the following: a value is made\n-/// from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n-/// (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n-/// constructor for the number `2`). Fields are just a (possibly empty) list of values.\n-///\n-/// Some of the constructors listed above might feel weird: `None` and `2` don't take any\n-/// arguments. This is part of what makes constructors so general: we will consider plain values\n-/// like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n-/// constructors\"; they are the simplest case of constructors. This allows us to see any value as\n-/// made up from a tree of constructors, each having a given number of children. For example:\n-/// `(None, Ok(0))` is made from 4 different constructors.\n-///\n-/// This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n-/// describe this set using constructors. For example, `Err(_)` captures all values of the type\n-/// `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n-/// wildcard `_` captures all values of the given type starting with any of the constructors for\n-/// that type.\n-///\n-/// We use this to compute whether different patterns might capture a same value. Do the patterns\n-/// `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n-/// captures only values starting with the `Ok` constructor and the second only values starting\n-/// with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n-/// since they both capture values starting with `Some`. To be certain, we need to dig under the\n-/// `Some` constructor and continue asking the question. This is the main idea behind the\n-/// exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n-/// figure out if some new pattern might capture a value that hadn't been captured by previous\n-/// patterns.\n-///\n-/// Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n-/// Most of the complexity of this file resides in transforming between patterns and\n-/// (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n-///\n-/// Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n-/// a value of type `Rc<u64>` doesn't fit this idea very well, nor do various other things.\n-/// However, this idea covers most of the cases that are relevant to exhaustiveness checking.\n-///\n-///\n-/// # Algorithm\n-///\n-/// Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n-/// adding a new pattern `p` will cover previously-uncovered values of the type.\n-/// During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n-/// but rather partially-deconstructed patterns in the form of a list of fields. The paper\n-/// calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n-/// new pattern `p`.\n-///\n-/// For example, say we have the following:\n-/// ```\n-///     // x: (Option<bool>, Result<()>)\n-///     match x {\n-///         (Some(true), _) => {}\n-///         (None, Err(())) => {}\n-///         (None, Err(_)) => {}\n-///     }\n-/// ```\n-/// Here, the matrix `P` starts as:\n-/// [\n-///     [(Some(true), _)],\n-///     [(None, Err(()))],\n-///     [(None, Err(_))],\n-/// ]\n-/// We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n-/// `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n-/// all the values it covers are already covered by row 2.\n-///\n-/// A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n-/// the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n-/// To match the paper, the top of the stack is at the beginning / on the left.\n-///\n-/// There are two important operations on pattern-stacks necessary to understand the algorithm:\n-///     1. We can pop a given constructor off the top of a stack. This operation is called\n-///        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n-///        `None`) and `p` a pattern-stack.\n-///        If the pattern on top of the stack can cover `c`, this removes the constructor and\n-///        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n-///        Otherwise the pattern-stack is discarded.\n-///        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n-///        discards the others.\n-///\n-///        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n-///        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n-///        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n-///        nothing back.\n-///\n-///        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n-///        on top of the stack, and we have four cases:\n-///             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n-///                  push onto the stack the arguments of this constructor, and return the result:\n-///                     r_1, .., r_a, p_2, .., p_n\n-///             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n-///                  return nothing.\n-///             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n-///                  arguments (its arity), and return the resulting stack:\n-///                     _, .., _, p_2, .., p_n\n-///             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-///                  stack:\n-///                     S(c, (r_1, p_2, .., p_n))\n-///                     S(c, (r_2, p_2, .., p_n))\n-///\n-///     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n-///        a pattern-stack.\n-///        This is used when we know there are missing constructor cases, but there might be\n-///        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n-///        all its *other* components.\n-///\n-///        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n-///        and we have three cases:\n-///             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-///             1.2. `p_1 = _`. We return the rest of the stack:\n-///                     p_2, .., p_n\n-///             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-///               stack.\n-///                     D((r_1, p_2, .., p_n))\n-///                     D((r_2, p_2, .., p_n))\n-///\n-///     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n-///     exhaustive integer matching rules, so they're written here for posterity.\n-///\n-/// Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n-/// working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n-/// the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n-///\n-///\n-/// The algorithm for computing `U`\n-/// -------------------------------\n-/// The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n-/// That means we're going to check the components from left-to-right, so the algorithm\n-/// operates principally on the first component of the matrix and new pattern-stack `p`.\n-/// This algorithm is realised in the `is_useful` function.\n-///\n-/// Base case. (`n = 0`, i.e., an empty tuple pattern)\n-///     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n-///       then `U(P, p)` is false.\n-///     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n-///\n-/// Inductive step. (`n > 0`, i.e., whether there's at least one column\n-///                  [which may then be expanded into further columns later])\n-///     We're going to match on the top of the new pattern-stack, `p_1`.\n-///         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n-///           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n-///           we ignore all the patterns in the first column of `P` that involve other constructors.\n-///           This is where `S(c, P)` comes in:\n-///           `U(P, p) := U(S(c, P), S(c, p))`\n-///           This special case is handled in `is_useful_specialized`.\n-///\n-///           For example, if `P` is:\n-///           [\n-///               [Some(true), _],\n-///               [None, 0],\n-///           ]\n-///           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n-///           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n-///           arguments of `Some` to know whether some new value is covered. So we compute\n-///           `U([[true, _]], [false, 0])`.\n-///\n-///         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n-///               component of the rows of `P`:\n-///             + If there are some constructors that aren't present, then we might think that the\n-///               wildcard `_` is useful, since it covers those constructors that weren't covered\n-///               before.\n-///               That's almost correct, but only works if there were no wildcards in those first\n-///               components. So we need to check that `p` is useful with respect to the rows that\n-///               start with a wildcard, if there are any. This is where `D` comes in:\n-///               `U(P, p) := U(D(P), D(p))`\n-///\n-///               For example, if `P` is:\n-///               [\n-///                   [_, true, _],\n-///                   [None, false, 1],\n-///               ]\n-///               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n-///               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n-///               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n-///\n-///             + Otherwise, all possible constructors (for the relevant type) are present. In this\n-///               case we must check whether the wildcard pattern covers any unmatched value. For\n-///               that, we can think of the `_` pattern as a big OR-pattern that covers all\n-///               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n-///               example. The wildcard pattern is useful in this case if it is useful when\n-///               specialized to one of the possible constructors. So we compute:\n-///               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n-///\n-///               For example, if `P` is:\n-///               [\n-///                   [Some(true), _],\n-///                   [None, false],\n-///               ]\n-///               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n-///               components of `P`. We will therefore try popping both constructors in turn: we\n-///               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n-///               [false]) for the `None` constructor. The first case returns true, so we know that\n-///               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n-///               before.\n-///\n-///         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n-///           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n-///                    || U(P, (r_2, p_2, .., p_n))`\n-///\n-/// Modifications to the algorithm\n-/// ------------------------------\n-/// The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n-/// example uninhabited types and variable-length slice patterns. These are drawn attention to\n-/// throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n-/// accounted for, though.\n-///\n-/// Exhaustive integer matching\n-/// ---------------------------\n-/// An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n-/// So to support exhaustive integer matching, we can make use of the logic in the paper for\n-/// OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n-/// they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n-/// that we have a constructor *of* constructors (the integers themselves). We then need to work\n-/// through all the inductive step rules above, deriving how the ranges would be treated as\n-/// OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n-/// There are really only four special cases here:\n-/// - When we match on a constructor that's actually a range, we have to treat it as if we would\n-///   an OR-pattern.\n-///     + It turns out that we can simply extend the case for single-value patterns in\n-///      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n-///      constructor.\n-///     + When the pattern itself is a range, you just want to tell whether any of the values in\n-///       the pattern range coincide with values in the constructor range, which is precisely\n-///       intersection.\n-///   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n-///   means that whenever the constructor is a value/range and the pattern is also a value/range,\n-///   we can simply use intersection to test usefulness.\n-/// - When we're testing for usefulness of a pattern and the pattern's first component is a\n-///   wildcard.\n-///     + If all the constructors appear in the matrix, we have a slight complication. By default,\n-///       the behaviour (i.e., a disjunction over specialised matrices for each constructor) is\n-///       invalid, because we want a disjunction over every *integer* in each range, not just a\n-///       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n-///       to form equivalence classes of subranges of the constructor range for which the behaviour\n-///       of the matrix `P` and new pattern `p` are the same. This is described in more\n-///       detail in `split_grouped_constructors`.\n-///     + If some constructors are missing from the matrix, it turns out we don't need to do\n-///       anything special (because we know none of the integers are actually wildcards: i.e., we\n-///       can't span wildcards using ranges).\n+//! Note: most of the tests relevant to this file can be found (at the time of writing) in\n+//! src/tests/ui/pattern/usefulness.\n+//!\n+//! This file includes the logic for exhaustiveness and usefulness checking for\n+//! pattern-matching. Specifically, given a list of patterns for a type, we can\n+//! tell whether:\n+//! (a) the patterns cover every possible constructor for the type [exhaustiveness]\n+//! (b) each pattern is necessary [usefulness]\n+//!\n+//! The algorithm implemented here is a modified version of the one described in:\n+//! http://moscova.inria.fr/~maranget/papers/warn/index.html\n+//! However, to save future implementors from reading the original paper, we\n+//! summarise the algorithm here to hopefully save time and be a little clearer\n+//! (without being so rigorous).\n+//!\n+//! # Premise\n+//!\n+//! The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n+//! are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n+//! a matrix). `U(P, p)` represents whether, given an existing list of patterns\n+//! `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n+//! uncovered values of the type).\n+//!\n+//! If we have this predicate, then we can easily compute both exhaustiveness of an\n+//! entire set of patterns and the individual usefulness of each one.\n+//! (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n+//! match doesn't increase the number of values we're matching)\n+//! (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n+//! pattern to those that have come before it doesn't increase the number of values\n+//! we're matching).\n+//!\n+//! # Core concept\n+//!\n+//! The idea that powers everything that is done in this file is the following: a value is made\n+//! from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n+//! (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n+//! constructor for the number `2`). Fields are just a (possibly empty) list of values.\n+//!\n+//! Some of the constructors listed above might feel weird: `None` and `2` don't take any\n+//! arguments. This is part of what makes constructors so general: we will consider plain values\n+//! like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n+//! constructors\"; they are the simplest case of constructors. This allows us to see any value as\n+//! made up from a tree of constructors, each having a given number of children. For example:\n+//! `(None, Ok(0))` is made from 4 different constructors.\n+//!\n+//! This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n+//! describe this set using constructors. For example, `Err(_)` captures all values of the type\n+//! `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n+//! wildcard `_` captures all values of the given type starting with any of the constructors for\n+//! that type.\n+//!\n+//! We use this to compute whether different patterns might capture a same value. Do the patterns\n+//! `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n+//! captures only values starting with the `Ok` constructor and the second only values starting\n+//! with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n+//! since they both capture values starting with `Some`. To be certain, we need to dig under the\n+//! `Some` constructor and continue asking the question. This is the main idea behind the\n+//! exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n+//! figure out if some new pattern might capture a value that hadn't been captured by previous\n+//! patterns.\n+//!\n+//! Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n+//! Most of the complexity of this file resides in transforming between patterns and\n+//! (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n+//!\n+//! Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n+//! a value of type `Rc<u64>` doesn't fit this idea very well, nor do various other things.\n+//! However, this idea covers most of the cases that are relevant to exhaustiveness checking.\n+//!\n+//!\n+//! # Algorithm\n+//!\n+//! Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n+//! adding a new pattern `p` will cover previously-uncovered values of the type.\n+//! During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n+//! but rather partially-deconstructed patterns in the form of a list of fields. The paper\n+//! calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n+//! new pattern `p`.\n+//!\n+//! For example, say we have the following:\n+//! ```\n+//!     // x: (Option<bool>, Result<()>)\n+//!     match x {\n+//!         (Some(true), _) => {}\n+//!         (None, Err(())) => {}\n+//!         (None, Err(_)) => {}\n+//!     }\n+//! ```\n+//! Here, the matrix `P` starts as:\n+//! [\n+//!     [(Some(true), _)],\n+//!     [(None, Err(()))],\n+//!     [(None, Err(_))],\n+//! ]\n+//! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n+//! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n+//! all the values it covers are already covered by row 2.\n+//!\n+//! A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n+//! the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n+//! To match the paper, the top of the stack is at the beginning / on the left.\n+//!\n+//! There are two important operations on pattern-stacks necessary to understand the algorithm:\n+//!     1. We can pop a given constructor off the top of a stack. This operation is called\n+//!        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+//!        `None`) and `p` a pattern-stack.\n+//!        If the pattern on top of the stack can cover `c`, this removes the constructor and\n+//!        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+//!        Otherwise the pattern-stack is discarded.\n+//!        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+//!        discards the others.\n+//!\n+//!        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+//!        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+//!        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+//!        nothing back.\n+//!\n+//!        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+//!        on top of the stack, and we have four cases:\n+//!             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+//!                  push onto the stack the arguments of this constructor, and return the result:\n+//!                     r_1, .., r_a, p_2, .., p_n\n+//!             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+//!                  return nothing.\n+//!             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+//!                  arguments (its arity), and return the resulting stack:\n+//!                     _, .., _, p_2, .., p_n\n+//!             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!                  stack:\n+//!                     S(c, (r_1, p_2, .., p_n))\n+//!                     S(c, (r_2, p_2, .., p_n))\n+//!\n+//!     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n+//!        a pattern-stack.\n+//!        This is used when we know there are missing constructor cases, but there might be\n+//!        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+//!        all its *other* components.\n+//!\n+//!        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+//!        and we have three cases:\n+//!             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!             1.2. `p_1 = _`. We return the rest of the stack:\n+//!                     p_2, .., p_n\n+//!             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!               stack.\n+//!                     D((r_1, p_2, .., p_n))\n+//!                     D((r_2, p_2, .., p_n))\n+//!\n+//!     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+//!     exhaustive integer matching rules, so they're written here for posterity.\n+//!\n+//! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n+//! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n+//! the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n+//!\n+//!\n+//! The algorithm for computing `U`\n+//! -------------------------------\n+//! The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n+//! That means we're going to check the components from left-to-right, so the algorithm\n+//! operates principally on the first component of the matrix and new pattern-stack `p`.\n+//! This algorithm is realised in the `is_useful` function.\n+//!\n+//! Base case. (`n = 0`, i.e., an empty tuple pattern)\n+//!     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n+//!       then `U(P, p)` is false.\n+//!     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n+//!\n+//! Inductive step. (`n > 0`, i.e., whether there's at least one column\n+//!                  [which may then be expanded into further columns later])\n+//!     We're going to match on the top of the new pattern-stack, `p_1`.\n+//!         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+//!           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+//!           we ignore all the patterns in the first column of `P` that involve other constructors.\n+//!           This is where `S(c, P)` comes in:\n+//!           `U(P, p) := U(S(c, P), S(c, p))`\n+//!           This special case is handled in `is_useful_specialized`.\n+//!\n+//!           For example, if `P` is:\n+//!           [\n+//!               [Some(true), _],\n+//!               [None, 0],\n+//!           ]\n+//!           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+//!           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+//!           arguments of `Some` to know whether some new value is covered. So we compute\n+//!           `U([[true, _]], [false, 0])`.\n+//!\n+//!         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n+//!               component of the rows of `P`:\n+//!             + If there are some constructors that aren't present, then we might think that the\n+//!               wildcard `_` is useful, since it covers those constructors that weren't covered\n+//!               before.\n+//!               That's almost correct, but only works if there were no wildcards in those first\n+//!               components. So we need to check that `p` is useful with respect to the rows that\n+//!               start with a wildcard, if there are any. This is where `D` comes in:\n+//!               `U(P, p) := U(D(P), D(p))`\n+//!\n+//!               For example, if `P` is:\n+//!               [\n+//!                   [_, true, _],\n+//!                   [None, false, 1],\n+//!               ]\n+//!               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+//!               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+//!               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//!\n+//!             + Otherwise, all possible constructors (for the relevant type) are present. In this\n+//!               case we must check whether the wildcard pattern covers any unmatched value. For\n+//!               that, we can think of the `_` pattern as a big OR-pattern that covers all\n+//!               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+//!               example. The wildcard pattern is useful in this case if it is useful when\n+//!               specialized to one of the possible constructors. So we compute:\n+//!               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//!\n+//!               For example, if `P` is:\n+//!               [\n+//!                   [Some(true), _],\n+//!                   [None, false],\n+//!               ]\n+//!               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+//!               components of `P`. We will therefore try popping both constructors in turn: we\n+//!               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n+//!               [false]) for the `None` constructor. The first case returns true, so we know that\n+//!               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+//!               before.\n+//!\n+//!         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n+//!           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n+//!                    || U(P, (r_2, p_2, .., p_n))`\n+//!\n+//! Modifications to the algorithm\n+//! ------------------------------\n+//! The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n+//! example uninhabited types and variable-length slice patterns. These are drawn attention to\n+//! throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n+//! accounted for, though.\n+//!\n+//! Exhaustive integer matching\n+//! ---------------------------\n+//! An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n+//! So to support exhaustive integer matching, we can make use of the logic in the paper for\n+//! OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n+//! they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n+//! that we have a constructor *of* constructors (the integers themselves). We then need to work\n+//! through all the inductive step rules above, deriving how the ranges would be treated as\n+//! OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n+//! There are really only four special cases here:\n+//! - When we match on a constructor that's actually a range, we have to treat it as if we would\n+//!   an OR-pattern.\n+//!     + It turns out that we can simply extend the case for single-value patterns in\n+//!      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n+//!      constructor.\n+//!     + When the pattern itself is a range, you just want to tell whether any of the values in\n+//!       the pattern range coincide with values in the constructor range, which is precisely\n+//!       intersection.\n+//!   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n+//!   means that whenever the constructor is a value/range and the pattern is also a value/range,\n+//!   we can simply use intersection to test usefulness.\n+//! - When we're testing for usefulness of a pattern and the pattern's first component is a\n+//!   wildcard.\n+//!     + If all the constructors appear in the matrix, we have a slight complication. By default,\n+//!       the behaviour (i.e., a disjunction over specialised matrices for each constructor) is\n+//!       invalid, because we want a disjunction over every *integer* in each range, not just a\n+//!       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n+//!       to form equivalence classes of subranges of the constructor range for which the behaviour\n+//!       of the matrix `P` and new pattern `p` are the same. This is described in more\n+//!       detail in `split_grouped_constructors`.\n+//!     + If some constructors are missing from the matrix, it turns out we don't need to do\n+//!       anything special (because we know none of the integers are actually wildcards: i.e., we\n+//!       can't span wildcards using ranges).\n use self::Constructor::*;\n use self::SliceKind::*;\n use self::Usefulness::*;\n@@ -1519,7 +1519,7 @@ fn all_constructors<'a, 'tcx>(\n         }\n         ty::Uint(uty) => {\n             let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n-            let max = truncate(u128::max_value(), size);\n+            let max = truncate(u128::MAX, size);\n             vec![make_range(0, max)]\n         }\n         _ => {"}, {"sha": "087c2c064cfaf3c57f4de92a1911f85905ff2b4b", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n-        traits::type_marked_structural(self.id, self.span, &self.infcx, ty)\n+        ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n \n     fn to_pat(\n@@ -130,6 +130,9 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     traits::NonStructuralMatchTy::Generator => {\n                         \"generators cannot be used in patterns\".to_string()\n                     }\n+                    traits::NonStructuralMatchTy::Closure => {\n+                        \"closures cannot be used in patterns\".to_string()\n+                    }\n                     traits::NonStructuralMatchTy::Param => {\n                         bug!(\"use of a constant whose type is a parameter inside a pattern\")\n                     }"}, {"sha": "84b3335a0f628d7f865ed736c60de8ca06814369", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -325,7 +325,15 @@ impl<'a> StringReader<'a> {\n         let (lit_kind, mode, prefix_len, postfix_len) = match kind {\n             rustc_lexer::LiteralKind::Char { terminated } => {\n                 if !terminated {\n-                    self.fatal_span_(start, suffix_start, \"unterminated character literal\").raise()\n+                    self.sess\n+                        .span_diagnostic\n+                        .struct_span_fatal_with_code(\n+                            self.mk_sp(start, suffix_start),\n+                            \"unterminated character literal\",\n+                            error_code!(E0762),\n+                        )\n+                        .emit();\n+                    FatalError.raise();\n                 }\n                 (token::Char, Mode::Char, 1, 1) // ' '\n             }\n@@ -401,7 +409,7 @@ impl<'a> StringReader<'a> {\n         let content_end = suffix_start - BytePos(postfix_len);\n         let id = self.symbol_from_to(content_start, content_end);\n         self.validate_literal_escape(mode, content_start, content_end);\n-        return (lit_kind, id);\n+        (lit_kind, id)\n     }\n \n     pub fn pos(&self) -> BytePos {"}, {"sha": "8792605c08d38a4092f15fdffe5c258f282af0b6", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -936,7 +936,7 @@ impl<'a> Parser<'a> {\n         } else if !sm.is_multiline(self.prev_token.span.until(self.token.span)) {\n             // The current token is in the same line as the prior token, not recoverable.\n         } else if [token::Comma, token::Colon].contains(&self.token.kind)\n-            && &self.prev_token.kind == &token::CloseDelim(token::Paren)\n+            && self.prev_token.kind == token::CloseDelim(token::Paren)\n         {\n             // Likely typo: The current token is on a new line and is expected to be\n             // `.`, `;`, `?`, or an operator after a close delimiter token."}, {"sha": "49a5c8801766c5521de580d6d8d170bbd52a81a2", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -639,7 +639,7 @@ impl<'a> Parser<'a> {\n                     ExprKind::Index(_, _) => \"indexing\",\n                     ExprKind::Try(_) => \"?\",\n                     ExprKind::Field(_, _) => \"a field access\",\n-                    ExprKind::MethodCall(_, _) => \"a method call\",\n+                    ExprKind::MethodCall(_, _, _) => \"a method call\",\n                     ExprKind::Call(_, _) => \"a function call\",\n                     ExprKind::Await(_) => \"`.await`\",\n                     ExprKind::Err => return Ok(with_postfix),\n@@ -865,6 +865,7 @@ impl<'a> Parser<'a> {\n             return self.mk_await_expr(self_arg, lo);\n         }\n \n+        let fn_span_lo = self.token.span;\n         let segment = self.parse_path_segment(PathStyle::Expr)?;\n         self.check_trailing_angle_brackets(&segment, token::OpenDelim(token::Paren));\n \n@@ -873,8 +874,9 @@ impl<'a> Parser<'a> {\n             let mut args = self.parse_paren_expr_seq()?;\n             args.insert(0, self_arg);\n \n+            let fn_span = fn_span_lo.to(self.prev_token.span);\n             let span = lo.to(self.prev_token.span);\n-            Ok(self.mk_expr(span, ExprKind::MethodCall(segment, args), AttrVec::new()))\n+            Ok(self.mk_expr(span, ExprKind::MethodCall(segment, args, fn_span), AttrVec::new()))\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = segment.args {"}, {"sha": "04b64d93c70dd2b2a4ff4ff5d79d0cf5da25eeb5", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -157,6 +157,7 @@ impl<'a> Parser<'a> {\n         Ok(ast::Generics {\n             params,\n             where_clause: WhereClause {\n+                has_where_token: false,\n                 predicates: Vec::new(),\n                 span: self.prev_token.span.shrink_to_hi(),\n             },\n@@ -170,12 +171,16 @@ impl<'a> Parser<'a> {\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n     pub(super) fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n-        let mut where_clause =\n-            WhereClause { predicates: Vec::new(), span: self.prev_token.span.shrink_to_hi() };\n+        let mut where_clause = WhereClause {\n+            has_where_token: false,\n+            predicates: Vec::new(),\n+            span: self.prev_token.span.shrink_to_hi(),\n+        };\n \n         if !self.eat_keyword(kw::Where) {\n             return Ok(where_clause);\n         }\n+        where_clause.has_where_token = true;\n         let lo = self.prev_token.span;\n \n         // We are considering adding generics to the `where` keyword as an alternative higher-rank"}, {"sha": "47ae92c48bd88dce1277adb8d348326d69646aba", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -193,7 +193,7 @@ impl TokenCursor {\n                         tree,\n                         self.stack.len()\n                     );\n-                    collecting.buf.push(tree.clone().into())\n+                    collecting.buf.push(tree.clone())\n                 }\n             }\n \n@@ -675,7 +675,7 @@ impl<'a> Parser<'a> {\n                             // If this was a missing `@` in a binding pattern\n                             // bail with a suggestion\n                             // https://github.com/rust-lang/rust/issues/72373\n-                            if self.prev_token.is_ident() && &self.token.kind == &token::DotDot {\n+                            if self.prev_token.is_ident() && self.token.kind == token::DotDot {\n                                 let msg = format!(\n                                     \"if you meant to bind the contents of \\\n                                     the rest of the array pattern into `{}`, use `@`\",\n@@ -1193,7 +1193,7 @@ impl<'a> Parser<'a> {\n         let mut collected_tokens = if let Some(collecting) = self.token_cursor.collecting.take() {\n             collecting.buf\n         } else {\n-            let msg = format!(\"our vector went away?\");\n+            let msg = \"our vector went away?\";\n             debug!(\"collect_tokens: {}\", msg);\n             self.sess.span_diagnostic.delay_span_bug(self.token.span, &msg);\n             // This can happen due to a bad interaction of two unrelated recovery mechanisms"}, {"sha": "80681c143750fc7e8fe091158cfc49a891aa7c35", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -37,7 +37,7 @@ fn target_from_impl_item<'tcx>(tcx: TyCtxt<'tcx>, impl_item: &hir::ImplItem<'_>)\n                 Target::Method(MethodKind::Inherent)\n             }\n         }\n-        hir::ImplItemKind::TyAlias(..) | hir::ImplItemKind::OpaqueTy(..) => Target::AssocTy,\n+        hir::ImplItemKind::TyAlias(..) => Target::AssocTy,\n     }\n }\n "}, {"sha": "503fbb64db83dbbd6267e1e5871ef02b59dd5d3c", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -304,7 +304,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n-        if let TyKind::Def(item_id, _) = ty.kind {\n+        if let TyKind::OpaqueDef(item_id, _) = ty.kind {\n             let item = self.tcx.hir().expect_item(item_id.id);\n             intravisit::walk_item(self, item);\n         }\n@@ -668,7 +668,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 }\n                 self.visit_nested_body(body_id)\n             }\n-            hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(..) => {}\n+            hir::ImplItemKind::TyAlias(..) => {}\n         }\n     }\n "}, {"sha": "e2bfcf18edb1731fe219a58b2d22bac0f7c12f48", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -232,7 +232,7 @@ impl ExprVisitor<'tcx> {\n         // size).\n         if let Some((in_expr, Some(in_asm_ty))) = tied_input {\n             if in_asm_ty != asm_ty {\n-                let msg = &format!(\"incompatible types for asm inout argument\");\n+                let msg = \"incompatible types for asm inout argument\";\n                 let mut err = self.tcx.sess.struct_span_err(vec![in_expr.span, expr.span], msg);\n                 err.span_label(\n                     in_expr.span,"}, {"sha": "2419e6965968ed0213aa8b0de268143491acf723", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -27,8 +27,7 @@ impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n             ItemKind::TyAlias(..)\n             | ItemKind::Enum(..)\n             | ItemKind::Struct(..)\n-            | ItemKind::Union(..)\n-            | ItemKind::OpaqueTy(..) => {\n+            | ItemKind::Union(..) => {\n                 for attr in self.tcx.get_attrs(item_def_id.to_def_id()).iter() {\n                     if attr.check_name(sym::rustc_layout) {\n                         self.dump_layout_of(item_def_id, item, attr);\n@@ -83,9 +82,11 @@ impl LayoutTest<'tcx> {\n                         }\n \n                         sym::debug => {\n+                            let normalized_ty =\n+                                self.tcx.normalize_erasing_regions(param_env.with_reveal_all(), ty);\n                             self.tcx.sess.span_err(\n                                 item.span,\n-                                &format!(\"layout_of({:?}) = {:#?}\", ty, *ty_layout),\n+                                &format!(\"layout_of({:?}) = {:#?}\", normalized_ty, *ty_layout),\n                             );\n                         }\n "}, {"sha": "ff5dabd5418c9187d99bed46609d97eb8e95e983", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1198,7 +1198,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 self.propagate_through_expr(&f, succ)\n             }\n \n-            hir::ExprKind::MethodCall(.., ref args) => {\n+            hir::ExprKind::MethodCall(.., ref args, _) => {\n                 let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(\n                     m,"}, {"sha": "c9a4428c007aae7a68dd9feadad207b17938038f", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -180,7 +180,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(_) => false,\n+                    hir::ImplItemKind::TyAlias(_) => false,\n                 }\n             }\n             Some(_) => false,\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_nested_body(body)\n                     }\n                 }\n-                hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(_) => {}\n+                hir::ImplItemKind::TyAlias(_) => {}\n             },\n             Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);"}, {"sha": "3c1b56a9ef40ae4986ee48881bf89cbf2813578b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -615,7 +615,6 @@ impl EmbargoVisitor<'tcx> {\n             // public, or are not namespaced at all.\n             DefKind::AssocConst\n             | DefKind::AssocTy\n-            | DefKind::AssocOpaqueTy\n             | DefKind::ConstParam\n             | DefKind::Ctor(_, _)\n             | DefKind::Enum\n@@ -1302,7 +1301,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                     return;\n                 }\n             }\n-            hir::ExprKind::MethodCall(_, span, _) => {\n+            hir::ExprKind::MethodCall(_, span, _, _) => {\n                 // Method calls have to be checked specially.\n                 self.span = span;\n                 if let Some(def_id) = self.tables.type_dependent_def_id(expr.hir_id) {\n@@ -1333,11 +1332,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             _ => None,\n         };\n         let def = def.filter(|(kind, _)| match kind {\n-            DefKind::AssocFn\n-            | DefKind::AssocConst\n-            | DefKind::AssocTy\n-            | DefKind::AssocOpaqueTy\n-            | DefKind::Static => true,\n+            DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Static => true,\n             _ => false,\n         });\n         if let Some((kind, def_id)) = def {\n@@ -1602,9 +1597,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => {\n                                 self.access_levels.is_reachable(impl_item_ref.id.hir_id)\n                             }\n-                            hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(_) => {\n-                                false\n-                            }\n+                            hir::ImplItemKind::TyAlias(_) => false,\n                         }\n                     });\n \n@@ -1952,9 +1945,6 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         let (check_ty, is_assoc_ty) = match assoc_item_kind {\n             AssocItemKind::Const | AssocItemKind::Fn { .. } => (true, false),\n             AssocItemKind::Type => (defaultness.has_value(), true),\n-            // `ty()` for opaque types is the underlying type,\n-            // it's not a part of interface, so we skip it.\n-            AssocItemKind::OpaqueTy => (false, true),\n         };\n         check.in_assoc_ty = is_assoc_ty;\n         check.generics().predicates();"}, {"sha": "002b0f9c165dde4f3a967699dc1d72a659dc4773", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -91,7 +91,7 @@ impl<K: DepKind> fmt::Debug for DepNode<K> {\n }\n \n pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool;\n+    fn can_reconstruct_query_key() -> bool;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n     /// Fingerprint to be used in DepNode.\n@@ -108,7 +108,7 @@ pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n     /// This method tries to recover the query key from the given `DepNode`,\n     /// something which is needed when forcing `DepNode`s during red-green\n     /// evaluation. The query system will only call this method if\n-    /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n+    /// `can_reconstruct_query_key()` is `true`.\n     /// It is always valid to return `None` here, in which case incremental\n     /// compilation will treat the query as having changed instead of forcing it.\n     fn recover(tcx: Ctxt, dep_node: &DepNode<Ctxt::DepKind>) -> Option<Self>;\n@@ -118,7 +118,10 @@ impl<Ctxt: DepContext, T> DepNodeParams<Ctxt> for T\n where\n     T: HashStable<Ctxt::StableHashingContext> + fmt::Debug,\n {\n-    default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+    #[inline]\n+    default fn can_reconstruct_query_key() -> bool {\n+        false\n+    }\n \n     default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n         let mut hcx = tcx.create_stable_hashing_context();"}, {"sha": "12450a4ccd3ebc3937871f5b8cb3527644ece231", "filename": "src/librustc_query_system/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -4,7 +4,7 @@\n #![feature(const_panic)]\n #![feature(core_intrinsics)]\n #![feature(hash_raw_entry)]\n-#![feature(specialization)] // FIXME: min_specialization rejects `default const`\n+#![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n #![feature(vec_remove_item)]\n "}, {"sha": "e633bd1843e85d292411a45c65dbb0a5220d12f0", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -746,12 +746,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             // These items live in the type namespace.\n-            ItemKind::TyAlias(_, _, _, ref ty) => {\n-                let def_kind = match ty.as_deref().and_then(|ty| ty.kind.opaque_top_hack()) {\n-                    None => DefKind::TyAlias,\n-                    Some(_) => DefKind::OpaqueTy,\n-                };\n-                let res = Res::Def(def_kind, self.r.definitions.local_def_id(item.id).to_def_id());\n+            ItemKind::TyAlias(..) => {\n+                let res = Res::Def(\n+                    DefKind::TyAlias,\n+                    self.r.definitions.local_def_id(item.id).to_def_id(),\n+                );\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n@@ -917,8 +916,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 | DefKind::ForeignTy\n                 | DefKind::OpaqueTy\n                 | DefKind::TraitAlias\n-                | DefKind::AssocTy\n-                | DefKind::AssocOpaqueTy,\n+                | DefKind::AssocTy,\n                 _,\n             )\n             | Res::PrimTy(..)"}, {"sha": "bd2ce5a72e8d924e1a1d320aa2d4da5c2a5f9a41", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -629,6 +629,7 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         lookup_ident: Ident,\n         namespace: Namespace,\n+        parent_scope: &ParentScope<'a>,\n         start_module: Module<'a>,\n         crate_name: Ident,\n         filter_fn: FilterFn,\n@@ -655,7 +656,11 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 // collect results based on the filter function\n-                if ident.name == lookup_ident.name && ns == namespace {\n+                // avoid suggesting anything from the same module in which we are resolving\n+                if ident.name == lookup_ident.name\n+                    && ns == namespace\n+                    && !ptr::eq(in_module, parent_scope.module)\n+                {\n                     let res = name_binding.res();\n                     if filter_fn(res) {\n                         // create the path\n@@ -680,7 +685,9 @@ impl<'a> Resolver<'a> {\n                                 Res::Def(DefKind::Ctor(..), did) => this.parent(did),\n                                 _ => res.opt_def_id(),\n                             };\n-                            candidates.push(ImportSuggestion { did, descr: res.descr(), path });\n+                            if candidates.iter().all(|v: &ImportSuggestion| v.did != did) {\n+                                candidates.push(ImportSuggestion { did, descr: res.descr(), path });\n+                            }\n                         }\n                     }\n                 }\n@@ -722,6 +729,7 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         lookup_ident: Ident,\n         namespace: Namespace,\n+        parent_scope: &ParentScope<'a>,\n         filter_fn: FilterFn,\n     ) -> Vec<ImportSuggestion>\n     where\n@@ -730,6 +738,7 @@ impl<'a> Resolver<'a> {\n         let mut suggestions = self.lookup_import_candidates_from_module(\n             lookup_ident,\n             namespace,\n+            parent_scope,\n             self.graph_root,\n             Ident::with_dummy_span(kw::Crate),\n             &filter_fn,\n@@ -754,6 +763,7 @@ impl<'a> Resolver<'a> {\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n                         lookup_ident,\n                         namespace,\n+                        parent_scope,\n                         crate_root,\n                         ident,\n                         &filter_fn,"}, {"sha": "7166fef2d13952420262c0045bb8874730e06140", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2117,7 +2117,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ExprKind::Field(ref subexpression, _) => {\n                 self.resolve_expr(subexpression, Some(expr));\n             }\n-            ExprKind::MethodCall(ref segment, ref arguments) => {\n+            ExprKind::MethodCall(ref segment, ref arguments, _) => {\n                 let mut arguments = arguments.iter();\n                 self.resolve_expr(arguments.next().unwrap(), Some(expr));\n                 for argument in arguments {"}, {"sha": "ed7adefcb8c9e0a56985054fe9f0e92f0a44603e", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -212,7 +212,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         let ident = path.last().unwrap().ident;\n         let candidates = self\n             .r\n-            .lookup_import_candidates(ident, ns, is_expected)\n+            .lookup_import_candidates(ident, ns, &self.parent_scope, is_expected)\n             .drain(..)\n             .filter(|ImportSuggestion { did, .. }| {\n                 match (did, res.and_then(|res| res.opt_def_id())) {\n@@ -223,7 +223,8 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n             .collect::<Vec<_>>();\n         let crate_def_id = DefId::local(CRATE_DEF_INDEX);\n         if candidates.is_empty() && is_expected(Res::Def(DefKind::Enum, crate_def_id)) {\n-            let enum_candidates = self.r.lookup_import_candidates(ident, ns, is_enum_variant);\n+            let enum_candidates =\n+                self.r.lookup_import_candidates(ident, ns, &self.parent_scope, is_enum_variant);\n             let mut enum_candidates = enum_candidates\n                 .iter()\n                 .map(|suggestion| import_candidate_to_enum_paths(&suggestion))"}, {"sha": "5bbf8703f0b60d1b7ec8b6a9cc1492a0c61e7b7a", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 28, "deletions": 51, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -258,6 +258,9 @@ enum Elide {\n     Exact(Region),\n     /// Less or more than one lifetime were found, error on unspecified.\n     Error(Vec<ElisionFailureInfo>),\n+    /// Forbid lifetime elision inside of a larger scope where it would be\n+    /// permitted. For example, in let position impl trait.\n+    Forbid,\n }\n \n #[derive(Clone, Debug)]\n@@ -396,15 +399,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let scope = Scope::Elision { elide: Elide::Exact(Region::Static), s: ROOT_SCOPE };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(_), .. }) => {\n-                // Currently opaque type declarations are just generated from `impl Trait`\n-                // items. Doing anything on this node is irrelevant, as we currently don't need\n-                // it.\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n+                // Opaque types are visited when we visit the\n+                // `TyKind::OpaqueDef`, so that they have the lifetimes from\n+                // their parent opaque_ty in scope.\n             }\n             hir::ItemKind::TyAlias(_, ref generics)\n-            | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                impl_trait_fn: None, ref generics, ..\n-            })\n             | hir::ItemKind::Enum(_, ref generics)\n             | hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n@@ -557,23 +557,35 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n-            hir::TyKind::Def(item_id, lifetimes) => {\n+            hir::TyKind::OpaqueDef(item_id, lifetimes) => {\n                 // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n                 // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n                 // `type MyAnonTy<'b> = impl MyTrait<'b>;`\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n-                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).kind {\n+                let opaque_ty = self.tcx.hir().expect_item(item_id.id);\n+                let (generics, bounds) = match opaque_ty.kind {\n                     // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n                     // This arm is for `impl Trait` in the types of statics, constants and locals.\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: None, .. }) => {\n                         intravisit::walk_ty(self, ty);\n+\n+                        // Elided lifetimes are not allowed in non-return\n+                        // position impl Trait\n+                        let scope = Scope::Elision { elide: Elide::Forbid, s: self.scope };\n+                        self.with(scope, |_, this| {\n+                            intravisit::walk_item(this, opaque_ty);\n+                        });\n+\n                         return;\n                     }\n                     // RPIT (return position impl trait)\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { ref generics, bounds, .. }) => {\n-                        (generics, bounds)\n-                    }\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                        impl_trait_fn: Some(_),\n+                        ref generics,\n+                        bounds,\n+                        ..\n+                    }) => (generics, bounds),\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 };\n \n@@ -797,43 +809,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.visit_ty(ty);\n                 });\n             }\n-            OpaqueTy(bounds) => {\n-                let generics = &impl_item.generics;\n-                let mut index = self.next_early_index();\n-                let mut next_early_index = index;\n-                debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Type { .. } => {\n-                            next_early_index += 1;\n-                            None\n-                        }\n-                        GenericParamKind::Const { .. } => {\n-                            next_early_index += 1;\n-                            None\n-                        }\n-                    })\n-                    .collect();\n-\n-                let scope = Scope::Binder {\n-                    lifetimes,\n-                    next_early_index,\n-                    s: self.scope,\n-                    track_lifetime_uses: true,\n-                    opaque_type_parent: true,\n-                };\n-                self.with(scope, |_old_scope, this| {\n-                    this.visit_generics(generics);\n-                    for bound in bounds {\n-                        this.visit_param_bound(bound);\n-                    }\n-                });\n-            }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(impl_item.generics.params.is_empty());\n@@ -2367,6 +2342,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             }\n                             break Some(e);\n                         }\n+                        Elide::Forbid => break None,\n                     };\n                     for lifetime_ref in lifetime_refs {\n                         self.insert_lifetime(lifetime_ref, lifetime);\n@@ -2667,8 +2643,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 // going to make a fresh name, so we cannot\n                 // necessarily replace a single-use lifetime with\n                 // `'_`.\n-                Scope::Elision { elide: Elide::Exact(_), .. } => break false,\n-                Scope::Elision { elide: Elide::Error(_), .. } => break false,\n+                Scope::Elision {\n+                    elide: Elide::Exact(_) | Elide::Error(_) | Elide::Forbid, ..\n+                } => break false,\n \n                 Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n             }"}, {"sha": "61792e039c76ead953f6a911c7ef292b822992a3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2235,7 +2235,8 @@ impl<'a> Resolver<'a> {\n                             Res::Def(DefKind::Mod, _) => true,\n                             _ => false,\n                         };\n-                        let mut candidates = self.lookup_import_candidates(ident, TypeNS, is_mod);\n+                        let mut candidates =\n+                            self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n                         candidates.sort_by_cached_key(|c| {\n                             (c.path.segments.len(), pprust::path_to_string(&c.path))\n                         });"}, {"sha": "1b49722355e54133bf79c9a2cfc0fc732753a883", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -288,7 +288,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         // Derives are not included when `invocations` are collected, so we have to add them here.\n         let parent_scope = &ParentScope { derives, ..parent_scope };\n-        let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n+        let node_id = self.lint_node_id(eager_expansion_root);\n+        let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, node_id, force)?;\n \n         let span = invoc.span();\n         invoc_id.set_expn_data(ext.expn_data(\n@@ -338,6 +339,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n     }\n \n+    fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId {\n+        self.definitions.lint_node_id(expn_id)\n+    }\n+\n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool {\n         self.containers_deriving_copy.contains(&expn_id)\n     }\n@@ -390,6 +395,7 @@ impl<'a> Resolver<'a> {\n         path: &ast::Path,\n         kind: MacroKind,\n         parent_scope: &ParentScope<'a>,\n+        node_id: NodeId,\n         force: bool,\n     ) -> Result<(Lrc<SyntaxExtension>, Res), Indeterminate> {\n         let (ext, res) = match self.resolve_macro_path(path, Some(kind), parent_scope, true, force)\n@@ -430,7 +436,7 @@ impl<'a> Resolver<'a> {\n             _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n         };\n \n-        self.check_stability_and_deprecation(&ext, path);\n+        self.check_stability_and_deprecation(&ext, path, node_id);\n \n         Ok(if ext.macro_kind() != kind {\n             let expected = kind.descr_expected();\n@@ -984,13 +990,17 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn check_stability_and_deprecation(&mut self, ext: &SyntaxExtension, path: &ast::Path) {\n+    fn check_stability_and_deprecation(\n+        &mut self,\n+        ext: &SyntaxExtension,\n+        path: &ast::Path,\n+        node_id: NodeId,\n+    ) {\n         let span = path.span;\n         if let Some(stability) = &ext.stability {\n             if let StabilityLevel::Unstable { reason, issue, is_soft } = stability.level {\n                 let feature = stability.feature;\n                 if !self.active_features.contains(&feature) && !span.allows_unstable(feature) {\n-                    let node_id = ast::CRATE_NODE_ID;\n                     let lint_buffer = &mut self.lint_buffer;\n                     let soft_handler =\n                         |lint, span, msg: &_| lint_buffer.buffer_lint(lint, node_id, span, msg);"}, {"sha": "e63e31e03c9f021c95cf89c119349934247b4f7d", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -20,7 +20,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir_pretty::{bounds_to_string, generic_params_to_string, ty_to_string};\n+use rustc_hir_pretty::{bounds_to_string, fn_to_string, generic_params_to_string, ty_to_string};\n use rustc_middle::hir::map::Map;\n use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n@@ -199,23 +199,23 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.dumper.compilation_opts(data);\n     }\n \n-    fn write_sub_paths(&mut self, path: &'tcx hir::Path<'tcx>) {\n-        for seg in path.segments {\n+    fn write_segments(&mut self, segments: impl IntoIterator<Item = &'tcx hir::PathSegment<'tcx>>) {\n+        for seg in segments {\n             if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n                 self.dumper.dump_ref(data);\n             }\n         }\n     }\n \n+    fn write_sub_paths(&mut self, path: &'tcx hir::Path<'tcx>) {\n+        self.write_segments(path.segments)\n+    }\n+\n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere). See note on write_sub_paths about global.\n     fn write_sub_paths_truncated(&mut self, path: &'tcx hir::Path<'tcx>) {\n         if let [segments @ .., _] = path.segments {\n-            for seg in segments {\n-                if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n-                    self.dumper.dump_ref(data);\n-                }\n-            }\n+            self.write_segments(segments)\n         }\n     }\n \n@@ -276,7 +276,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 }\n                 v.process_generic_params(&generics, &method_data.qualname, hir_id);\n \n-                method_data.value = crate::make_signature(&sig.decl, &generics);\n+                method_data.value =\n+                    fn_to_string(sig.decl, sig.header, Some(ident.name), generics, vis, &[], None);\n                 method_data.sig = sig::method_signature(hir_id, ident, generics, sig, &v.save_ctxt);\n \n                 v.dumper.dump_def(&access_from_vis!(v.save_ctxt, vis, hir_id), method_data);\n@@ -643,7 +644,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.nest_tables(map.local_def_id(item.hir_id), |v| {\n             v.visit_ty(&typ);\n             if let &Some(ref trait_ref) = trait_ref {\n-                v.process_path(trait_ref.hir_ref_id, &trait_ref.path);\n+                v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n             }\n             v.process_generic_params(generics, \"\", item.hir_id);\n             for impl_item in impl_items {\n@@ -746,7 +747,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn dump_path_ref(&mut self, id: hir::HirId, path: &hir::Path<'tcx>) {\n+    fn dump_path_ref(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n         let path_data = self.save_ctxt.get_path_data(id, path);\n         if let Some(path_data) = path_data {\n             self.dumper.dump_ref(path_data);\n@@ -760,14 +761,30 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_path(&mut self, id: hir::HirId, path: &'tcx hir::Path<'tcx>) {\n-        if self.span.filter_generated(path.span) {\n+    fn process_path(&mut self, id: hir::HirId, path: &hir::QPath<'tcx>) {\n+        let span = match path {\n+            hir::QPath::Resolved(_, path) => path.span,\n+            hir::QPath::TypeRelative(_, segment) => segment.ident.span,\n+        };\n+        if self.span.filter_generated(span) {\n             return;\n         }\n         self.dump_path_ref(id, path);\n \n         // Type arguments\n-        for seg in path.segments {\n+        let segments = match path {\n+            hir::QPath::Resolved(ty, path) => {\n+                if let Some(ty) = ty {\n+                    self.visit_ty(ty);\n+                }\n+                path.segments\n+            }\n+            hir::QPath::TypeRelative(ty, segment) => {\n+                self.visit_ty(ty);\n+                std::slice::from_ref(*segment)\n+            }\n+        };\n+        for seg in segments {\n             if let Some(ref generic_args) = seg.args {\n                 for arg in generic_args.args {\n                     if let hir::GenericArg::Type(ref ty) = arg {\n@@ -777,7 +794,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             }\n         }\n \n-        self.write_sub_paths_truncated(path);\n+        if let hir::QPath::Resolved(_, path) = path {\n+            self.write_sub_paths_truncated(path);\n+        }\n     }\n \n     fn process_struct_lit(\n@@ -931,9 +950,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         for (id, ref path) in collector.collected_paths {\n-            if let hir::QPath::Resolved(_, path) = path {\n-                self.process_path(id, path);\n-            }\n+            self.process_path(id, path);\n         }\n     }\n \n@@ -1085,7 +1102,6 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     impl_item.span,\n                 );\n             }\n-            hir::ImplItemKind::OpaqueTy(..) => {}\n             hir::ImplItemKind::TyAlias(ref ty) => {\n                 // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n@@ -1135,7 +1151,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_bounds(&mut self, bounds: hir::GenericBounds<'tcx>) {\n         for bound in bounds {\n             if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n-                self.process_path(trait_ref.trait_ref.hir_ref_id, &trait_ref.trait_ref.path)\n+                self.process_path(\n+                    trait_ref.trait_ref.hir_ref_id,\n+                    &hir::QPath::Resolved(None, &trait_ref.trait_ref.path),\n+                )\n             }\n         }\n     }\n@@ -1330,13 +1349,16 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n         self.process_macro_use(t.span);\n         match t.kind {\n-            hir::TyKind::Path(hir::QPath::Resolved(_, path)) => {\n+            hir::TyKind::Path(ref path) => {\n                 if generated_code(t.span) {\n                     return;\n                 }\n \n                 if let Some(id) = self.lookup_def_id(t.hir_id) {\n-                    let sub_span = path.segments.last().unwrap().ident.span;\n+                    let sub_span = match path {\n+                        hir::QPath::Resolved(_, path) => path.segments.last().unwrap().ident.span,\n+                        hir::QPath::TypeRelative(_, segment) => segment.ident.span,\n+                    };\n                     let span = self.span_from_span(sub_span);\n                     self.dumper.dump_ref(Ref {\n                         kind: RefKind::Type,\n@@ -1345,8 +1367,10 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n                     });\n                 }\n \n-                self.write_sub_paths_truncated(path);\n-                intravisit::walk_path(self, path);\n+                if let hir::QPath::Resolved(_, path) = path {\n+                    self.write_sub_paths_truncated(path);\n+                }\n+                intravisit::walk_qpath(self, path, t.hir_id, t.span);\n             }\n             hir::TyKind::Array(ref ty, ref anon_const) => {\n                 self.visit_ty(ty);\n@@ -1355,6 +1379,10 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n                     v.visit_expr(&map.body(anon_const.body).value)\n                 });\n             }\n+            hir::TyKind::OpaqueDef(item_id, _) => {\n+                let item = self.tcx.hir().item(item_id.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(item_id.id), |v| v.visit_item(item));\n+            }\n             _ => intravisit::walk_ty(self, t),\n         }\n     }\n@@ -1375,7 +1403,9 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n                 let res = self.save_ctxt.get_path_res(hir_expr.hir_id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), *base)\n             }\n-            hir::ExprKind::MethodCall(ref seg, _, args) => self.process_method_call(ex, seg, args),\n+            hir::ExprKind::MethodCall(ref seg, _, args, _) => {\n+                self.process_method_call(ex, seg, args)\n+            }\n             hir::ExprKind::Field(ref sub_ex, _) => {\n                 self.visit_expr(&sub_ex);\n \n@@ -1432,8 +1462,8 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n         self.visit_expr(&arm.body);\n     }\n \n-    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n-        self.process_path(id, p);\n+    fn visit_qpath(&mut self, path: &'tcx hir::QPath<'tcx>, id: hir::HirId, _: Span) {\n+        self.process_path(id, path);\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {"}, {"sha": "12d2c8c7eb9a4c3be9db74681298a41b1bbab158", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -13,11 +13,11 @@ use rustc_ast::ast::{self};\n use rustc_ast::util::comments::strip_doc_comment_decoration;\n use rustc_ast_pretty::pprust::attribute_to_string;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorOf, DefKind as HirDefKind, Res};\n+use rustc_hir::def::{DefKind as HirDefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Node;\n-use rustc_hir_pretty::ty_to_string;\n+use rustc_hir_pretty::{enum_def_to_string, fn_to_string, ty_to_string};\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::cstore::ExternCrate;\n use rustc_middle::middle::privacy::AccessLevels;\n@@ -135,7 +135,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n         let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n         match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(ref decl, arg_names, ref generics) => {\n                 filter!(self.span_utils, item.ident.span);\n \n                 Some(Data::DefData(Def {\n@@ -144,7 +144,23 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    value: make_signature(decl, generics),\n+                    value: fn_to_string(\n+                        decl,\n+                        hir::FnHeader {\n+                            // functions in extern block are implicitly unsafe\n+                            unsafety: hir::Unsafety::Unsafe,\n+                            // functions in extern block cannot be const\n+                            constness: hir::Constness::NotConst,\n+                            abi: self.tcx.hir().get_foreign_abi(item.hir_id),\n+                            // functions in extern block cannot be async\n+                            asyncness: hir::IsAsync::NotAsync,\n+                        },\n+                        Some(item.ident.name),\n+                        generics,\n+                        &item.vis,\n+                        arg_names,\n+                        None,\n+                    ),\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n@@ -191,7 +207,15 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    value: make_signature(&sig.decl, generics),\n+                    value: fn_to_string(\n+                        sig.decl,\n+                        sig.header,\n+                        Some(item.ident.name),\n+                        generics,\n+                        &item.vis,\n+                        &[],\n+                        None,\n+                    ),\n                     parent: None,\n                     children: vec![],\n                     decl_id: None,\n@@ -268,13 +292,12 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.to_vec(), self),\n                 }))\n             }\n-            hir::ItemKind::Enum(ref def, _) => {\n+            hir::ItemKind::Enum(ref def, ref generics) => {\n                 let name = item.ident.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n                 filter!(self.span_utils, item.ident.span);\n-                let variants_str =\n-                    def.variants.iter().map(|v| v.ident.to_string()).collect::<Vec<_>>().join(\", \");\n-                let value = format!(\"{}::{{{}}}\", name, variants_str);\n+                let value =\n+                    enum_def_to_string(def, generics, item.ident.name, item.span, &item.vis);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Enum,\n                     id: id_from_def_id(def_id),\n@@ -579,7 +602,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     ref_id: def_id.or(decl_id).map(id_from_def_id).unwrap_or_else(null_id),\n                 }))\n             }\n-            hir::ExprKind::Path(hir::QPath::Resolved(_, path)) => {\n+            hir::ExprKind::Path(ref path) => {\n                 self.get_path_data(expr.hir_id, path).map(Data::RefData)\n             }\n             _ => {\n@@ -631,8 +654,12 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_data(&self, id: hir::HirId, path: &hir::Path<'_>) -> Option<Ref> {\n-        path.segments.last().and_then(|seg| {\n+    pub fn get_path_data(&self, id: hir::HirId, path: &hir::QPath<'_>) -> Option<Ref> {\n+        let segment = match path {\n+            hir::QPath::Resolved(_, path) => path.segments.last(),\n+            hir::QPath::TypeRelative(_, segment) => Some(*segment),\n+        };\n+        segment.and_then(|seg| {\n             self.get_path_segment_data(seg).or_else(|| self.get_path_segment_data_with_id(seg, id))\n         })\n     }\n@@ -671,7 +698,6 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 | HirDefKind::TyAlias\n                 | HirDefKind::ForeignTy\n                 | HirDefKind::TraitAlias\n-                | HirDefKind::AssocOpaqueTy\n                 | HirDefKind::AssocTy\n                 | HirDefKind::Trait\n                 | HirDefKind::OpaqueTy\n@@ -681,20 +707,16 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Res::Def(HirDefKind::ConstParam, def_id) => {\n                 Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(def_id) })\n             }\n-            Res::Def(HirDefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                // This is a reference to a tuple struct where the def_id points\n+            Res::Def(HirDefKind::Ctor(_, ..), def_id) => {\n+                // This is a reference to a tuple struct or an enum variant where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n-                // def, so adjust to point to the tuple struct itself.\n+                // def, so adjust to point to the tuple struct or enum variant itself.\n                 let parent_def_id = self.tcx.parent(def_id).unwrap();\n                 Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(parent_def_id) })\n             }\n-            Res::Def(\n-                HirDefKind::Static\n-                | HirDefKind::Const\n-                | HirDefKind::AssocConst\n-                | HirDefKind::Ctor(..),\n-                _,\n-            ) => Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(res.def_id()) }),\n+            Res::Def(HirDefKind::Static | HirDefKind::Const | HirDefKind::AssocConst, _) => {\n+                Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(res.def_id()) })\n+            }\n             Res::Def(HirDefKind::AssocFn, decl_id) => {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n@@ -844,31 +866,6 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n }\n \n-fn make_signature(decl: &hir::FnDecl<'_>, generics: &hir::Generics<'_>) -> String {\n-    let mut sig = \"fn \".to_owned();\n-    if !generics.params.is_empty() {\n-        sig.push('<');\n-        sig.push_str(\n-            &generics\n-                .params\n-                .iter()\n-                .map(|param| param.name.ident().to_string())\n-                .collect::<Vec<_>>()\n-                .join(\", \"),\n-        );\n-        sig.push_str(\"> \");\n-    }\n-    sig.push('(');\n-    sig.push_str(&decl.inputs.iter().map(ty_to_string).collect::<Vec<_>>().join(\", \"));\n-    sig.push(')');\n-    match decl.output {\n-        hir::FnRetTy::DefaultReturn(_) => sig.push_str(\" -> ()\"),\n-        hir::FnRetTy::Return(ref t) => sig.push_str(&format!(\" -> {}\", ty_to_string(t))),\n-    }\n-\n-    sig\n-}\n-\n // An AST visitor for collecting paths (e.g., the names of structs) and formal\n // variables (idents) from patterns.\n struct PathCollector<'l> {\n@@ -1088,7 +1085,7 @@ fn id_from_hir_id(id: hir::HirId, scx: &SaveContext<'_, '_>) -> rls_data::Id {\n }\n \n fn null_id() -> rls_data::Id {\n-    rls_data::Id { krate: u32::max_value(), index: u32::max_value() }\n+    rls_data::Id { krate: u32::MAX, index: u32::MAX }\n }\n \n fn lower_attributes("}, {"sha": "cd2a5deeb2d727c6448a747a0eabc4bdaeb64702", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -281,6 +281,22 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                     })\n                 }\n             }\n+            hir::TyKind::Path(hir::QPath::TypeRelative(ty, segment)) => {\n+                let nested_ty = ty.make(offset + 1, id, scx)?;\n+                let prefix = format!(\"<{}>::\", nested_ty.text,);\n+\n+                let name = path_segment_to_string(segment);\n+                let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n+                let id = id_from_def_id(res.def_id());\n+\n+                let start = offset + prefix.len();\n+                let end = start + name.len();\n+                Ok(Signature {\n+                    text: prefix + &name,\n+                    defs: vec![],\n+                    refs: vec![SigElement { id, start, end }],\n+                })\n+            }\n             hir::TyKind::TraitObject(bounds, ..) => {\n                 // FIXME recurse into bounds\n                 let bounds: Vec<hir::GenericBound<'_>> = bounds\n@@ -308,11 +324,11 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                 let text = format!(\"[{}; {}]\", nested_ty.text, expr);\n                 Ok(replace_text(nested_ty, text))\n             }\n-            hir::TyKind::Typeof(_)\n-            | hir::TyKind::Infer\n-            | hir::TyKind::Def(..)\n-            | hir::TyKind::Path(..)\n-            | hir::TyKind::Err => Err(\"Ty\"),\n+            hir::TyKind::OpaqueDef(item_id, _) => {\n+                let item = scx.tcx.hir().item(item_id.id);\n+                item.make(offset, Some(item_id.id), scx)\n+            }\n+            hir::TyKind::Typeof(_) | hir::TyKind::Infer | hir::TyKind::Err => Err(\"Ty\"),\n         }\n     }\n }"}, {"sha": "3dc3e783820963e4e0dc417c8c44380f92ab0b7a", "filename": "src/librustc_serialize/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_serialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_serialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -10,7 +10,7 @@ Core encoding and decoding interfaces.\n     test(attr(allow(unused_variables), deny(warnings)))\n )]\n #![feature(box_syntax)]\n-#![feature(specialization)] // FIXME: min_specialization does not work\n+#![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(associated_type_bounds)]"}, {"sha": "29c5737ad895abc8b834394fcb6f328ddefb1ee4", "filename": "src/librustc_serialize/serialize.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_serialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_serialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fserialize.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -635,24 +635,6 @@ impl<T> Decodable for PhantomData<T> {\n     }\n }\n \n-impl<'a, T: ?Sized + Encodable> Encodable for &'a T {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<T: ?Sized + Encodable> Encodable for Box<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<T: Decodable> Decodable for Box<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> {\n-        Ok(box Decodable::decode(d)?)\n-    }\n-}\n-\n impl<T: Decodable> Decodable for Box<[T]> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Box<[T]>, D::Error> {\n         let v: Vec<T> = Decodable::decode(d)?;\n@@ -1008,8 +990,20 @@ impl<T: UseSpecializedDecodable> Decodable for T {\n // for this exact reason.\n // May be fixable in a simpler fashion via the\n // more complex lattice model for specialization.\n-impl<'a, T: ?Sized + Encodable> UseSpecializedEncodable for &'a T {}\n-impl<T: ?Sized + Encodable> UseSpecializedEncodable for Box<T> {}\n-impl<T: Decodable> UseSpecializedDecodable for Box<T> {}\n+impl<'a, T: ?Sized + Encodable> UseSpecializedEncodable for &'a T {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+impl<T: ?Sized + Encodable> UseSpecializedEncodable for Box<T> {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+impl<T: Decodable> UseSpecializedDecodable for Box<T> {\n+    fn default_decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> {\n+        Ok(box Decodable::decode(d)?)\n+    }\n+}\n impl<'a, T: Decodable> UseSpecializedDecodable for &'a T {}\n impl<'a, T: Decodable> UseSpecializedDecodable for &'a [T] {}"}, {"sha": "411a6eecbba1584f3a49d45cbf861f694c99407b", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1031,7 +1031,7 @@ pub fn get_cmd_lint_options(\n                 // HACK: forbid is always specified last, so it can't be overridden.\n                 // FIXME: remove this once <https://github.com/rust-lang/rust/issues/70819> is\n                 // fixed and `forbid` works as expected.\n-                usize::max_value()\n+                usize::MAX\n             } else {\n                 passed_arg_pos\n             };"}, {"sha": "58388bafbeddf27bbafbc3d21e0336c00603adcd", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -606,6 +606,7 @@ declare_lint_pass! {\n         INLINE_NO_SANITIZE,\n         ASM_SUB_REGISTER,\n         UNSAFE_OP_IN_UNSAFE_FN,\n+        INCOMPLETE_INCLUDE,\n     ]\n }\n "}, {"sha": "ddbc95fb1b0b8ed61888b9b91a4829924aec1913", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -119,7 +119,7 @@ pub struct ParseSess {\n     pub unstable_features: UnstableFeatures,\n     pub config: CrateConfig,\n     pub edition: Edition,\n-    pub missing_fragment_specifiers: Lock<FxHashSet<Span>>,\n+    pub missing_fragment_specifiers: Lock<FxHashMap<Span, NodeId>>,\n     /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n     pub raw_identifier_spans: Lock<Vec<Span>>,\n     /// Used to determine and report recursive module inclusions.\n@@ -150,7 +150,7 @@ impl ParseSess {\n             unstable_features: UnstableFeatures::from_environment(),\n             config: FxHashSet::default(),\n             edition: ExpnId::root().expn_data().edition,\n-            missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n+            missing_fragment_specifiers: Default::default(),\n             raw_identifier_spans: Lock::new(Vec::new()),\n             included_mod_stack: Lock::new(vec![]),\n             source_map,"}, {"sha": "06d7d4f14d8f4407527a59f0a5a5ffd6867655e9", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -441,6 +441,9 @@ impl Session {\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n+    pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+        self.diagnostic().struct_note_without_error(msg)\n+    }\n \n     pub fn diagnostic(&self) -> &rustc_errors::Handler {\n         &self.parse_sess.span_diagnostic"}, {"sha": "0a70be1f152e9120bebb83a92f310b26e5261634", "filename": "src/librustc_span/def_id.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_span%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_span%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fdef_id.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -133,6 +133,8 @@ impl rustc_serialize::UseSpecializedDecodable for DefIndex {}\n \n /// A `DefId` identifies a particular *definition*, by combining a crate\n /// index and a def index.\n+///\n+/// You can create a `DefId` from a `LocalDefId` using `local_def_id.to_def_id()`.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,"}, {"sha": "f2c9f8055b9756d05a4435a9d61311a6ab0e3e3d", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -822,7 +822,15 @@ pub enum DesugaringKind {\n     OpaqueTy,\n     Async,\n     Await,\n-    ForLoop,\n+    ForLoop(ForLoopLoc),\n+    Operator,\n+}\n+\n+/// A location in the desugaring of a `for` loop\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+pub enum ForLoopLoc {\n+    Head,\n+    IntoIter,\n }\n \n impl DesugaringKind {\n@@ -835,7 +843,8 @@ impl DesugaringKind {\n             DesugaringKind::QuestionMark => \"operator `?`\",\n             DesugaringKind::TryBlock => \"`try` block\",\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n-            DesugaringKind::ForLoop => \"`for` loop\",\n+            DesugaringKind::ForLoop(_) => \"`for` loop\",\n+            DesugaringKind::Operator => \"operator\",\n         }\n     }\n }"}, {"sha": "af9b5a264e313d4bb689077aa285e46551901ec2", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -31,7 +31,9 @@ pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n use hygiene::Transparency;\n-pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, MacroKind, SyntaxContext};\n+pub use hygiene::{\n+    DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind, SyntaxContext,\n+};\n pub mod def_id;\n use def_id::{CrateNum, DefId, LOCAL_CRATE};\n mod span_encoding;\n@@ -726,10 +728,18 @@ pub fn with_source_map<T, F: FnOnce() -> T>(source_map: Lrc<SourceMap>, f: F) ->\n     f()\n }\n \n+pub fn debug_with_source_map(\n+    span: Span,\n+    f: &mut fmt::Formatter<'_>,\n+    source_map: &SourceMap,\n+) -> fmt::Result {\n+    write!(f, \"{} ({:?})\", source_map.span_to_string(span), span.ctxt())\n+}\n+\n pub fn default_span_debug(span: Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n     GLOBALS.with(|globals| {\n         if let Some(source_map) = &*globals.source_map.borrow() {\n-            write!(f, \"{}\", source_map.span_to_string(span))\n+            debug_with_source_map(span, f, source_map)\n         } else {\n             f.debug_struct(\"Span\")\n                 .field(\"lo\", &span.lo())\n@@ -1250,7 +1260,7 @@ impl SourceFile {\n             hasher.finish::<u128>()\n         };\n         let end_pos = start_pos.to_usize() + src.len();\n-        assert!(end_pos <= u32::max_value() as usize);\n+        assert!(end_pos <= u32::MAX as usize);\n \n         let (lines, multibyte_chars, non_narrow_chars) =\n             analyze_source_file::analyze_source_file(&src[..], start_pos);"}, {"sha": "4b5bce1db26282ab91580c7202c35e676c3fb771", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -819,9 +819,7 @@ impl SourceMap {\n \n         // Disregard indexes that are at the start or end of their spans, they can't fit bigger\n         // characters.\n-        if (!forwards && end_index == usize::min_value())\n-            || (forwards && start_index == usize::max_value())\n-        {\n+        if (!forwards && end_index == usize::MIN) || (forwards && start_index == usize::MAX) {\n             debug!(\"find_width_of_character_at_span: start or end of span, cannot be multibyte\");\n             return 1;\n         }"}, {"sha": "fdeb58b7b7a313608229ffa056b15e8caec96a81", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -120,6 +120,7 @@ symbols! {\n         abi_unadjusted,\n         abi_vectorcall,\n         abi_x86_interrupt,\n+        abi_avr_interrupt,\n         abort,\n         aborts,\n         address,\n@@ -226,6 +227,7 @@ symbols! {\n         const_loop,\n         const_mut_refs,\n         const_panic,\n+        const_precise_live_drops,\n         const_raw_ptr_deref,\n         const_raw_ptr_to_usize_cast,\n         const_transmute,"}, {"sha": "c1f7a1e3af58612af767fb4bcf15e8d685796e5f", "filename": "src/librustc_target/abi/call/avr.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fabi%2Fcall%2Favr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fabi%2Fcall%2Favr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Favr.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,59 @@\n+//! LLVM-frontend specific AVR calling convention implementation.\n+//!\n+//! # Current calling convention ABI\n+//!\n+//! Inherited from Clang's `clang::DefaultABIInfo` implementation - self described\n+//! as\n+//!\n+//! > the default implementation for ABI specific details. This implementation\n+//! > provides information which results in\n+//! > self-consistent and sensible LLVM IR generation, but does not\n+//! > conform to any particular ABI.\n+//! >\n+//! > - Doxygen Doxumentation of `clang::DefaultABIInfo`\n+//!\n+//! This calling convention may not match AVR-GCC in all cases.\n+//!\n+//! In the future, an AVR-GCC compatible argument classification ABI should be\n+//! adopted in both Rust and Clang.\n+//!\n+//! *NOTE*: Currently, this module implements the same calling convention\n+//! that clang with AVR currently does - the default, simple, unspecialized\n+//! ABI implementation available to all targets. This ABI is not\n+//! binary-compatible with AVR-GCC. Once LLVM [PR46140](https://bugs.llvm.org/show_bug.cgi?id=46140)\n+//! is completed, this module should be updated to match so that both Clang\n+//! and Rust emit code to the same AVR-GCC compatible ABI.\n+//!\n+//! In particular, both Clang and Rust may not have the same semantics\n+//! when promoting arguments to indirect references as AVR-GCC. It is important\n+//! to note that the core AVR ABI implementation within LLVM itself is ABI\n+//! compatible with AVR-GCC - Rust and AVR-GCC only differ in the small amount\n+//! of compiler frontend specific calling convention logic implemented here.\n+\n+use crate::abi::call::{ArgAbi, FnAbi};\n+\n+fn classify_ret_ty<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n+    if ret.layout.is_aggregate() {\n+        ret.make_indirect();\n+    }\n+}\n+\n+fn classify_arg_ty<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n+    if arg.layout.is_aggregate() {\n+        arg.make_indirect();\n+    }\n+}\n+\n+pub fn compute_abi_info<Ty>(fty: &mut FnAbi<'_, Ty>) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(&mut fty.ret);\n+    }\n+\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+\n+        classify_arg_ty(arg);\n+    }\n+}"}, {"sha": "8f7e2bba5aa6d785ea72f08fbd39d01ef7bfd55e", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -5,6 +5,7 @@ use crate::spec::{self, HasTargetSpec};\n mod aarch64;\n mod amdgpu;\n mod arm;\n+mod avr;\n mod hexagon;\n mod mips;\n mod mips64;\n@@ -525,6 +526,8 @@ pub enum Conv {\n     X86_64Win64,\n \n     AmdGpuKernel,\n+    AvrInterrupt,\n+    AvrNonBlockingInterrupt,\n }\n \n /// Metadata describing how the arguments to a native function\n@@ -580,6 +583,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"aarch64\" => aarch64::compute_abi_info(cx, self),\n             \"amdgpu\" => amdgpu::compute_abi_info(cx, self),\n             \"arm\" => arm::compute_abi_info(cx, self),\n+            \"avr\" => avr::compute_abi_info(self),\n             \"mips\" => mips::compute_abi_info(cx, self),\n             \"mips64\" => mips64::compute_abi_info(cx, self),\n             \"powerpc\" => powerpc::compute_abi_info(self),"}, {"sha": "1447716ca84841834fa80c41e71a6ac8af7fdd81", "filename": "src/librustc_target/spec/aarch64_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> TargetResult {\n         target_vendor: \"apple\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions {\n-            features: \"+neon,+fp-armv8,+cyclone\".to_string(),\n+            features: \"+neon,+fp-armv8,+apple-a7\".to_string(),\n             eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             abi_blacklist: super::arm_base::abi_blacklist(),"}, {"sha": "21f660ac8b8391da35d9492fcbb7206a4cb0142d", "filename": "src/librustc_target/spec/aarch64_apple_tvos.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> TargetResult {\n         target_vendor: \"apple\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions {\n-            features: \"+neon,+fp-armv8,+cyclone\".to_string(),\n+            features: \"+neon,+fp-armv8,+apple-a7\".to_string(),\n             eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             abi_blacklist: super::arm_base::abi_blacklist(),"}, {"sha": "a5c874bb4ac050a2c305b4f9b95cd3137d6a0079", "filename": "src/librustc_target/spec/abi.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fabi.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -34,6 +34,8 @@ pub enum Abi {\n     X86Interrupt,\n     AmdGpuKernel,\n     EfiApi,\n+    AvrInterrupt,\n+    AvrNonBlockingInterrupt,\n \n     // Multiplatform / generic ABIs\n     System,\n@@ -73,6 +75,12 @@ const AbiDatas: &[AbiData] = &[\n     AbiData { abi: Abi::X86Interrupt, name: \"x86-interrupt\", generic: false },\n     AbiData { abi: Abi::AmdGpuKernel, name: \"amdgpu-kernel\", generic: false },\n     AbiData { abi: Abi::EfiApi, name: \"efiapi\", generic: false },\n+    AbiData { abi: Abi::AvrInterrupt, name: \"avr-interrupt\", generic: false },\n+    AbiData {\n+        abi: Abi::AvrNonBlockingInterrupt,\n+        name: \"avr-non-blocking-interrupt\",\n+        generic: false,\n+    },\n     // Cross-platform ABIs\n     AbiData { abi: Abi::System, name: \"system\", generic: true },\n     AbiData { abi: Abi::RustIntrinsic, name: \"rust-intrinsic\", generic: true },"}, {"sha": "b07c2aef1caca004bbc07a3844652ad43157070f", "filename": "src/librustc_target/spec/apple_sdk_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -122,7 +122,7 @@ fn target_cpu(arch: Arch) -> String {\n     match arch {\n         Armv7 => \"cortex-a8\", // iOS7 is supported on iPhone 4 and higher\n         Armv7s => \"cortex-a9\",\n-        Arm64 => \"cyclone\",\n+        Arm64 => \"apple-a7\",\n         I386 => \"yonah\",\n         X86_64 => \"core2\",\n         X86_64_macabi => \"core2\","}, {"sha": "f90a8def0aa2f8699086d546426f3e3d0d697f2a", "filename": "src/librustc_target/spec/avr_unknown_unknown.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Favr_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Favr_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Favr_unknown_unknown.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,17 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"avr-unknown-unknown\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"16\".to_string(),\n+        data_layout: \"e-P1-p:16:8-i8:8-i16:8-i32:8-i64:8-f32:8-f64:8-n8-a:8\".to_string(),\n+        arch: \"avr\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        target_os: \"unknown\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        target_c_int_width: 16.to_string(),\n+        options: super::freestanding_base::opts(),\n+    })\n+}"}, {"sha": "5402ea074fae1ee891c64a17560783761408ff6e", "filename": "src/librustc_target/spec/freestanding_base.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Ffreestanding_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Ffreestanding_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Ffreestanding_base.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -0,0 +1,30 @@\n+use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut args = LinkArgs::new();\n+\n+    args.insert(\n+        LinkerFlavor::Gcc,\n+        vec![\n+            // We want to be able to strip as much executable code as possible\n+            // from the linker command line, and this flag indicates to the\n+            // linker that it can avoid linking in dynamic libraries that don't\n+            // actually satisfy any symbols up to that point (as with many other\n+            // resolutions the linker does). This option only applies to all\n+            // following libraries so we're sure to pass it as one of the first\n+            // arguments.\n+            \"-Wl,--as-needed\".to_string(),\n+        ],\n+    );\n+\n+    TargetOptions {\n+        dynamic_linking: false,\n+        executables: true,\n+        linker_is_gnu: true,\n+        has_rpath: false,\n+        pre_link_args: args,\n+        position_independent_executables: false,\n+        ..Default::default()\n+    }\n+}"}, {"sha": "29250f21383be600b306bb99957f200e87717e82", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -54,6 +54,7 @@ mod arm_base;\n mod cloudabi_base;\n mod dragonfly_base;\n mod freebsd_base;\n+mod freestanding_base;\n mod fuchsia_base;\n mod haiku_base;\n mod hermit_base;\n@@ -579,6 +580,8 @@ supported_targets! {\n     (\"aarch64-fuchsia\", aarch64_fuchsia),\n     (\"x86_64-fuchsia\", x86_64_fuchsia),\n \n+    (\"avr-unknown-unknown\", avr_unknown_unknown),\n+\n     (\"x86_64-unknown-l4re-uclibc\", x86_64_unknown_l4re_uclibc),\n \n     (\"aarch64-unknown-redox\", aarch64_unknown_redox),"}, {"sha": "680dbbad4b0a02e91f0bc76ef1570f0f82d7b156", "filename": "src/librustc_target/spec/windows_gnu_base.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -17,20 +17,21 @@ pub fn opts() -> TargetOptions {\n     let mut late_link_args = LinkArgs::new();\n     let mut late_link_args_dynamic = LinkArgs::new();\n     let mut late_link_args_static = LinkArgs::new();\n+    // Order of `late_link_args*` was found through trial and error to work with various\n+    // mingw-w64 versions (not tested on the CI). It's expected to change from time to time.\n     late_link_args.insert(\n         LinkerFlavor::Gcc,\n         vec![\n+            \"-lmsvcrt\".to_string(),\n             \"-lmingwex\".to_string(),\n             \"-lmingw32\".to_string(),\n-            \"-lmsvcrt\".to_string(),\n             // mingw's msvcrt is a weird hybrid import library and static library.\n             // And it seems that the linker fails to use import symbols from msvcrt\n             // that are required from functions in msvcrt in certain cases. For example\n             // `_fmode` that is used by an implementation of `__p__fmode` in x86_64.\n-            // Listing the library twice seems to fix that, and seems to also be done\n-            // by mingw's gcc (Though not sure if it's done on purpose, or by mistake).\n+            // The library is purposely listed twice to fix that.\n             //\n-            // See https://github.com/rust-lang/rust/pull/47483\n+            // See https://github.com/rust-lang/rust/pull/47483 for some more details.\n             \"-lmsvcrt\".to_string(),\n             \"-luser32\".to_string(),\n             \"-lkernel32\".to_string(),"}, {"sha": "f244785b49d2fdf3dd5e4050543217b5549171e5", "filename": "src/librustc_trait_selection/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Finfer.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -90,7 +90,7 @@ pub trait InferCtxtBuilderExt<'tcx> {\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + TypeFoldable<'tcx>,\n-        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable;\n+        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable<'tcx>;\n }\n \n impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n@@ -118,7 +118,7 @@ impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + TypeFoldable<'tcx>,\n-        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable,\n+        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable<'tcx>,\n     {\n         self.enter_with_canonical(\n             DUMMY_SP,"}, {"sha": "ea886cd1f9e9b38c394184ed4f0eb0bbc9279bc9", "filename": "src/librustc_trait_selection/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Flib.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -16,7 +16,6 @@\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]\n #![feature(or_patterns)]\n-#![feature(option_zip)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "d53a0ec9ef884ff336a6c2f2199795b79f3e2039", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 44, "deletions": 52, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -11,7 +11,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::config::nightly_options;\n use rustc_span::Span;\n \n@@ -133,9 +133,9 @@ pub trait InferCtxtExt<'tcx> {\n     fn generate_member_constraint(\n         &self,\n         concrete_ty: Ty<'tcx>,\n-        opaque_type_generics: &ty::Generics,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         opaque_type_def_id: DefId,\n+        first_own_region_index: usize,\n     );\n \n     /*private*/\n@@ -405,7 +405,24 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         debug!(\"constrain_opaque_type: concrete_ty={:?}\", concrete_ty);\n \n-        let opaque_type_generics = tcx.generics_of(def_id);\n+        let first_own_region = match opaque_defn.origin {\n+            hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n+                // We lower\n+                //\n+                // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+                //\n+                // into\n+                //\n+                // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+                // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+                //\n+                // For these types we onlt iterate over `'l0..lm` below.\n+                tcx.generics_of(def_id).parent_count\n+            }\n+            // These opaque type inherit all lifetime parameters from their\n+            // parent, so we have to check them all.\n+            hir::OpaqueTyOrigin::Binding | hir::OpaqueTyOrigin::Misc => 0,\n+        };\n \n         let span = tcx.def_span(def_id);\n \n@@ -427,12 +444,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 });\n             }\n             if let GenerateMemberConstraints::IfNoStaticBound = mode {\n-                self.generate_member_constraint(\n-                    concrete_ty,\n-                    opaque_type_generics,\n-                    opaque_defn,\n-                    def_id,\n-                );\n+                self.generate_member_constraint(concrete_ty, opaque_defn, def_id, first_own_region);\n             }\n             return;\n         }\n@@ -445,29 +457,27 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // `['a]` for the first impl trait and `'b` for the\n         // second.\n         let mut least_region = None;\n-        for param in &opaque_type_generics.params {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {}\n-                _ => continue,\n-            }\n \n-            // Get the value supplied for this region from the substs.\n-            let subst_arg = opaque_defn.substs.region_at(param.index as usize);\n+        for subst_arg in &opaque_defn.substs[first_own_region..] {\n+            let subst_region = match subst_arg.unpack() {\n+                GenericArgKind::Lifetime(r) => r,\n+                GenericArgKind::Type(_) | GenericArgKind::Const(_) => continue,\n+            };\n \n             // Compute the least upper bound of it with the other regions.\n             debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n-            debug!(\"constrain_opaque_types: subst_arg={:?}\", subst_arg);\n+            debug!(\"constrain_opaque_types: subst_region={:?}\", subst_region);\n             match least_region {\n-                None => least_region = Some(subst_arg),\n+                None => least_region = Some(subst_region),\n                 Some(lr) => {\n-                    if free_region_relations.sub_free_regions(self.tcx, lr, subst_arg) {\n+                    if free_region_relations.sub_free_regions(self.tcx, lr, subst_region) {\n                         // keep the current least region\n-                    } else if free_region_relations.sub_free_regions(self.tcx, subst_arg, lr) {\n-                        // switch to `subst_arg`\n-                        least_region = Some(subst_arg);\n+                    } else if free_region_relations.sub_free_regions(self.tcx, subst_region, lr) {\n+                        // switch to `subst_region`\n+                        least_region = Some(subst_region);\n                     } else {\n                         // There are two regions (`lr` and\n-                        // `subst_arg`) which are not relatable. We\n+                        // `subst_region`) which are not relatable. We\n                         // can't find a best choice. Therefore,\n                         // instead of creating a single bound like\n                         // `'r: 'a` (which is our preferred choice),\n@@ -476,13 +486,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // regions that appear in the impl trait.\n \n                         // For now, enforce a feature gate outside of async functions.\n-                        self.member_constraint_feature_gate(opaque_defn, def_id, lr, subst_arg);\n+                        self.member_constraint_feature_gate(opaque_defn, def_id, lr, subst_region);\n \n                         return self.generate_member_constraint(\n                             concrete_ty,\n-                            opaque_type_generics,\n                             opaque_defn,\n                             def_id,\n+                            first_own_region,\n                         );\n                     }\n                 }\n@@ -494,12 +504,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         if let GenerateMemberConstraints::IfNoStaticBound = mode {\n             if least_region != tcx.lifetimes.re_static {\n-                self.generate_member_constraint(\n-                    concrete_ty,\n-                    opaque_type_generics,\n-                    opaque_defn,\n-                    def_id,\n-                );\n+                self.generate_member_constraint(concrete_ty, opaque_defn, def_id, first_own_region);\n             }\n         }\n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n@@ -518,22 +523,20 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn generate_member_constraint(\n         &self,\n         concrete_ty: Ty<'tcx>,\n-        opaque_type_generics: &ty::Generics,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         opaque_type_def_id: DefId,\n+        first_own_region: usize,\n     ) {\n         // Create the set of choice regions: each region in the hidden\n         // type can be equal to any of the region parameters of the\n         // opaque type definition.\n         let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n-            opaque_type_generics\n-                .params\n+            opaque_defn.substs[first_own_region..]\n                 .iter()\n-                .filter(|param| match param.kind {\n-                    GenericParamDefKind::Lifetime => true,\n-                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => false,\n+                .filter_map(|arg| match arg.unpack() {\n+                    GenericArgKind::Lifetime(r) => Some(r),\n+                    GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n                 })\n-                .map(|param| opaque_defn.substs.region_at(param.index as usize))\n                 .chain(std::iter::once(self.tcx.lifetimes.re_static))\n                 .collect(),\n         );\n@@ -574,7 +577,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             hir::OpaqueTyOrigin::AsyncFn => return false,\n \n             // Otherwise, generate the label we'll use in the error message.\n-            hir::OpaqueTyOrigin::TypeAlias\n+            hir::OpaqueTyOrigin::Binding\n             | hir::OpaqueTyOrigin::FnReturn\n             | hir::OpaqueTyOrigin::Misc => \"impl Trait\",\n         };\n@@ -1064,21 +1067,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                     ),\n                                     origin,\n                                 ),\n-                                _ => (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias),\n-                            },\n-                            Some(Node::ImplItem(item)) => match item.kind {\n-                                hir::ImplItemKind::OpaqueTy(_) => (\n-                                    may_define_opaque_type(\n-                                        tcx,\n-                                        self.parent_def_id.expect_local(),\n-                                        opaque_hir_id,\n-                                    ),\n-                                    hir::OpaqueTyOrigin::TypeAlias,\n-                                ),\n-                                _ => (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias),\n+                                _ => (def_scope_default(), hir::OpaqueTyOrigin::Misc),\n                             },\n                             _ => bug!(\n-                                \"expected (impl) item, found {}\",\n+                                \"expected item, found {}\",\n                                 tcx.hir().node_to_string(opaque_hir_id),\n                             ),\n                         };"}, {"sha": "d31e04cffd55f57cbb03e39c75268960b50f5b95", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1747,24 +1747,41 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n pub fn recursive_type_with_infinite_size_error(\n     tcx: TyCtxt<'tcx>,\n     type_def_id: DefId,\n-) -> DiagnosticBuilder<'tcx> {\n+    spans: Vec<Span>,\n+) {\n     assert!(type_def_id.is_local());\n     let span = tcx.hir().span_if_local(type_def_id).unwrap();\n     let span = tcx.sess.source_map().guess_head_span(span);\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0072,\n-        \"recursive type `{}` has infinite size\",\n-        tcx.def_path_str(type_def_id)\n-    );\n+    let path = tcx.def_path_str(type_def_id);\n+    let mut err =\n+        struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\", path);\n     err.span_label(span, \"recursive type has infinite size\");\n-    err.help(&format!(\n-        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n-                           at some point to make `{}` representable\",\n-        tcx.def_path_str(type_def_id)\n-    ));\n-    err\n+    for &span in &spans {\n+        err.span_label(span, \"recursive without indirection\");\n+    }\n+    let msg = format!(\n+        \"insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `{}` representable\",\n+        path,\n+    );\n+    if spans.len() <= 4 {\n+        err.multipart_suggestion(\n+            &msg,\n+            spans\n+                .iter()\n+                .flat_map(|&span| {\n+                    vec![\n+                        (span.shrink_to_lo(), \"Box<\".to_string()),\n+                        (span.shrink_to_hi(), \">\".to_string()),\n+                    ]\n+                    .into_iter()\n+                })\n+                .collect(),\n+            Applicability::HasPlaceholders,\n+        );\n+    } else {\n+        err.help(&msg);\n+    }\n+    err.emit();\n }\n \n /// Summarizes information"}, {"sha": "9ab87e6b6ca01f35c7f8616aa8ba36feecaee370", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -60,7 +60,6 @@ pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n pub use self::structural_match::search_for_structural_match_violation;\n-pub use self::structural_match::type_marked_structural;\n pub use self::structural_match::NonStructuralMatchTy;\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n@@ -553,6 +552,7 @@ fn type_implements_trait<'tcx>(\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     object_safety::provide(providers);\n+    structural_match::provide(providers);\n     *providers = ty::query::Providers {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,"}, {"sha": "9492c3c340995091fb75041c1833ab4eae55d3fc", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -25,7 +25,7 @@ use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{FnOnceTraitLangItem, GeneratorTraitLangItem};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_span::symbol::{sym, Ident};\n@@ -1477,12 +1477,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n     let substs =\n         translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n-    let ty = if let ty::AssocKind::OpaqueTy = assoc_ty.item.kind {\n-        let item_substs = InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n-        tcx.mk_opaque(assoc_ty.item.def_id, item_substs)\n-    } else {\n-        tcx.type_of(assoc_ty.item.def_id)\n-    };\n+    let ty = tcx.type_of(assoc_ty.item.def_id);\n     if substs.len() != tcx.generics_of(assoc_ty.item.def_id).count() {\n         tcx.sess\n             .delay_span_bug(DUMMY_SP, \"impl item and trait item have different parameter counts\");\n@@ -1515,7 +1510,7 @@ fn assoc_ty_def(\n     // cycle error if the specialization graph is currently being built.\n     let impl_node = specialization_graph::Node::Impl(impl_def_id);\n     for item in impl_node.items(tcx) {\n-        if matches!(item.kind, ty::AssocKind::Type | ty::AssocKind::OpaqueTy)\n+        if matches!(item.kind, ty::AssocKind::Type)\n             && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n         {\n             return Ok(specialization_graph::LeafDef {"}, {"sha": "9045451056b1991d40965a24b3f7251bc48e09c3", "filename": "src/librustc_trait_selection/traits/select/candidate_assembly.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -331,6 +331,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<(), SelectionError<'tcx>> {\n         debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n \n+        // Essentially any user-written impl will match with an error type,\n+        // so creating `ImplCandidates` isn't useful. However, we might\n+        // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized)\n+        // This helps us avoid overflow: see issue #72839\n+        // Since compilation is already guaranteed to fail, this is just\n+        // to try to show the 'nicest' possible errors to the user.\n+        if obligation.references_error() {\n+            return Ok(());\n+        }\n+\n         self.tcx().for_each_relevant_impl(\n             obligation.predicate.def_id(),\n             obligation.predicate.skip_binder().trait_ref.self_ty(),"}, {"sha": "7ebf30f61c0956f0a981f4ccdadd4f21607b199e", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1104,6 +1104,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // who might care about this case, like coherence, should use\n         // that function).\n         if candidates.is_empty() {\n+            // If there's an error type, 'downgrade' our result from\n+            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n+            // emitting additional spurious errors, since we're guaranteed\n+            // to have emitted at least one.\n+            if stack.obligation.references_error() {\n+                debug!(\"no results for error type, treating as ambiguous\");\n+                return Ok(None);\n+            }\n             return Err(Unimplemented);\n         }\n "}, {"sha": "c4deb639140ca3119191d60e7376e4526f70395c", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,10 +1,11 @@\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::ObligationCause;\n-use crate::traits::{self, ConstPatternStructural, TraitEngine};\n+use crate::traits::{self, TraitEngine};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::lang_items::{StructuralPeqTraitLangItem, StructuralTeqTraitLangItem};\n+use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n \n@@ -17,6 +18,7 @@ pub enum NonStructuralMatchTy<'tcx> {\n     Opaque,\n     Generator,\n     Projection,\n+    Closure,\n }\n \n /// This method traverses the structure of `ty`, trying to find an\n@@ -45,14 +47,14 @@ pub enum NonStructuralMatchTy<'tcx> {\n /// that arose when the requirement was not enforced completely, see\n /// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n pub fn search_for_structural_match_violation<'tcx>(\n-    id: hir::HirId,\n+    _id: hir::HirId,\n     span: Span,\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<NonStructuralMatchTy<'tcx>> {\n     // FIXME: we should instead pass in an `infcx` from the outside.\n     tcx.infer_ctxt().enter(|infcx| {\n-        let mut search = Search { id, span, infcx, found: None, seen: FxHashSet::default() };\n+        let mut search = Search { infcx, span, found: None, seen: FxHashSet::default() };\n         ty.visit_with(&mut search);\n         search.found\n     })\n@@ -65,27 +67,26 @@ pub fn search_for_structural_match_violation<'tcx>(\n ///\n /// Note that this does *not* recursively check if the substructure of `adt_ty`\n /// implements the traits.\n-pub fn type_marked_structural(\n-    id: hir::HirId,\n-    span: Span,\n+fn type_marked_structural(\n     infcx: &InferCtxt<'_, 'tcx>,\n     adt_ty: Ty<'tcx>,\n+    cause: ObligationCause<'tcx>,\n ) -> bool {\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n-    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n     // require `#[derive(PartialEq)]`\n-    let structural_peq_def_id = infcx.tcx.require_lang_item(StructuralPeqTraitLangItem, Some(span));\n+    let structural_peq_def_id =\n+        infcx.tcx.require_lang_item(StructuralPeqTraitLangItem, Some(cause.span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),\n         adt_ty,\n         structural_peq_def_id,\n-        cause,\n+        cause.clone(),\n     );\n     // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n     // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n-    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n-    let structural_teq_def_id = infcx.tcx.require_lang_item(StructuralTeqTraitLangItem, Some(span));\n+    let structural_teq_def_id =\n+        infcx.tcx.require_lang_item(StructuralTeqTraitLangItem, Some(cause.span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),\n@@ -110,7 +111,6 @@ pub fn type_marked_structural(\n /// find instances of ADTs (specifically structs or enums) that do not implement\n /// the structural-match traits (`StructuralPartialEq` and `StructuralEq`).\n struct Search<'a, 'tcx> {\n-    id: hir::HirId,\n     span: Span,\n \n     infcx: InferCtxt<'a, 'tcx>,\n@@ -129,7 +129,7 @@ impl Search<'a, 'tcx> {\n     }\n \n     fn type_marked_structural(&self, adt_ty: Ty<'tcx>) -> bool {\n-        type_marked_structural(self.id, self.span, &self.infcx, adt_ty)\n+        adt_ty.is_structural_eq_shallow(self.tcx())\n     }\n }\n \n@@ -163,6 +163,10 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n                 self.found = Some(NonStructuralMatchTy::Generator);\n                 return true; // Stop visiting.\n             }\n+            ty::Closure(..) => {\n+                self.found = Some(NonStructuralMatchTy::Closure);\n+                return true; // Stop visiting.\n+            }\n             ty::RawPtr(..) => {\n                 // structural-match ignores substructure of\n                 // `*const _`/`*mut _`, so skip `super_visit_with`.\n@@ -212,7 +216,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n                 ty.super_visit_with(self);\n                 return false;\n             }\n-            ty::Closure(..) | ty::Infer(_) | ty::Placeholder(_) | ty::Bound(..) => {\n+            ty::Infer(_) | ty::Placeholder(_) | ty::Bound(..) => {\n                 bug!(\"unexpected type during structural-match checking: {:?}\", ty);\n             }\n             ty::Error => {\n@@ -251,7 +255,10 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n         // fields of ADT.\n         let tcx = self.tcx();\n         for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n-            if field_ty.visit_with(self) {\n+            let ty = self.tcx().normalize_erasing_regions(ty::ParamEnv::empty(), field_ty);\n+            debug!(\"structural-match ADT: field_ty={:?}, ty={:?}\", field_ty, ty);\n+\n+            if ty.visit_with(self) {\n                 // found an ADT without structural-match; halt visiting!\n                 assert!(self.found.is_some());\n                 return true;\n@@ -263,3 +270,12 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n         false\n     }\n }\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.has_structural_eq_impls = |tcx, ty| {\n+        tcx.infer_ctxt().enter(|infcx| {\n+            let cause = ObligationCause::dummy();\n+            type_marked_structural(&infcx, ty, cause)\n+        })\n+    };\n+}"}, {"sha": "99094246a637861154157420e102c85d54658f71", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -85,7 +85,6 @@ fn associated_item_from_trait_item_ref(\n         hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n         hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n         hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-        hir::AssocItemKind::OpaqueTy => bug!(\"only impls can have opaque types\"),\n     };\n \n     ty::AssocItem {\n@@ -110,7 +109,6 @@ fn associated_item_from_impl_item_ref(\n         hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n         hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n         hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-        hir::AssocItemKind::OpaqueTy => (ty::AssocKind::OpaqueTy, false),\n     };\n \n     ty::AssocItem {"}, {"sha": "267f3d9f3ef6e6dc02dbfe7436bc375181174a30", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2838,9 +2838,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n                 self.res_to_ty(opt_self_ty, path, false)\n             }\n-            hir::TyKind::Def(item_id, ref lifetimes) => {\n-                let did = tcx.hir().local_def_id(item_id.id);\n-                self.impl_trait_ty_to_ty(did.to_def_id(), lifetimes)\n+            hir::TyKind::OpaqueDef(item_id, ref lifetimes) => {\n+                let opaque_ty = tcx.hir().expect_item(item_id.id);\n+                let def_id = tcx.hir().local_def_id(item_id.id).to_def_id();\n+\n+                match opaque_ty.kind {\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {\n+                        self.impl_trait_ty_to_ty(def_id, lifetimes, impl_trait_fn.is_some())\n+                    }\n+                    ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n+                }\n             }\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n@@ -2893,6 +2900,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         def_id: DefId,\n         lifetimes: &[hir::GenericArg<'_>],\n+        replace_parent_lifetimes: bool,\n     ) -> Ty<'tcx> {\n         debug!(\"impl_trait_ty_to_ty(def_id={:?}, lifetimes={:?})\", def_id, lifetimes);\n         let tcx = self.tcx();\n@@ -2914,9 +2922,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     _ => bug!(),\n                 }\n             } else {\n-                // Replace all parent lifetimes with `'static`.\n                 match param.kind {\n-                    GenericParamDefKind::Lifetime => tcx.lifetimes.re_static.into(),\n+                    // For RPIT (return position impl trait), only lifetimes\n+                    // mentioned in the impl Trait predicate are captured by\n+                    // the opaque type, so the lifetime parameters from the\n+                    // parent item need to be replaced with `'static`.\n+                    //\n+                    // For `impl Trait` in the types of statics, constants,\n+                    // locals and type aliases. These capture all parent\n+                    // lifetimes, so they can use their identity subst.\n+                    GenericParamDefKind::Lifetime if replace_parent_lifetimes => {\n+                        tcx.lifetimes.re_static.into()\n+                    }\n                     _ => tcx.mk_param_from_def(param),\n                 }\n             }"}, {"sha": "15ec92568fb4d1fcaec17a639d232d9098ccd901", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1377,7 +1377,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 }\n \n                 if let Some(expr) = expression {\n-                    fcx.emit_coerce_suggestions(&mut err, expr, found, expected);\n+                    fcx.emit_coerce_suggestions(&mut err, expr, found, expected, None);\n                 }\n \n                 // Error possibly reported in `check_assign` so avoid emitting error again.\n@@ -1494,7 +1494,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let mut is_object_safe = false;\n         if let hir::FnRetTy::Return(ty) = fn_output {\n             // Get the return type.\n-            if let hir::TyKind::Def(..) = ty.kind {\n+            if let hir::TyKind::OpaqueDef(..) = ty.kind {\n                 let ty = AstConv::ast_ty_to_ty(fcx, ty);\n                 // Get the `impl Trait`'s `DefId`.\n                 if let ty::Opaque(def_id, _) = ty.kind {"}, {"sha": "5f8fcaadfdb0b2fc66081a7e26f67fa05259c6a2", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1165,6 +1165,6 @@ fn assoc_item_kind_str(impl_item: &ty::AssocItem) -> &'static str {\n     match impl_item.kind {\n         ty::AssocKind::Const => \"const\",\n         ty::AssocKind::Fn => \"method\",\n-        ty::AssocKind::Type | ty::AssocKind::OpaqueTy => \"type\",\n+        ty::AssocKind::Type => \"type\",\n     }\n }"}, {"sha": "019b4ca66060c295c6b799e4e0e79dffc7790f37", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 243, "deletions": 212, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -15,17 +15,20 @@ use rustc_span::Span;\n \n use super::method::probe;\n \n+use std::fmt;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn emit_coerce_suggestions(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         expr: &hir::Expr<'_>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         self.annotate_expected_due_to_let_ty(err, expr);\n         self.suggest_compatible_variants(err, expr, expected, expr_ty);\n-        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty);\n+        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr);\n         if self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty) {\n             return;\n         }\n@@ -100,9 +103,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> Ty<'tcx> {\n-        let (ty, err) = self.demand_coerce_diag(expr, checked_ty, expected, allow_two_phase);\n+        let (ty, err) =\n+            self.demand_coerce_diag(expr, checked_ty, expected, expected_ty_expr, allow_two_phase);\n         if let Some(mut err) = err {\n             err.emit();\n         }\n@@ -119,6 +124,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n         let expected = self.resolve_vars_with_obligations(expected);\n@@ -139,7 +145,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return (expected, None);\n         }\n \n-        self.emit_coerce_suggestions(&mut err, expr, expr_ty, expected);\n+        self.emit_coerce_suggestions(&mut err, expr, expr_ty, expected, expected_ty_expr);\n \n         (expected, Some(err))\n     }\n@@ -305,7 +311,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let (method_path, method_span, method_expr) = match (hir, closure_params_len) {\n             (\n                 Some(Node::Expr(hir::Expr {\n-                    kind: hir::ExprKind::MethodCall(path, span, expr),\n+                    kind: hir::ExprKind::MethodCall(path, span, expr, _),\n                     ..\n                 })),\n                 1,\n@@ -455,7 +461,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n                     let mut sugg_sp = sp;\n-                    if let hir::ExprKind::MethodCall(ref segment, sp, ref args) = expr.kind {\n+                    if let hir::ExprKind::MethodCall(ref segment, sp, ref args, _) = expr.kind {\n                         let clone_trait = self.tcx.require_lang_item(CloneTraitLangItem, Some(sp));\n                         if let ([arg], Some(true), sym::clone) = (\n                             &args[..],\n@@ -669,17 +675,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n-        if self.tcx.hir().is_const_context(expr.hir_id) {\n-            // Shouldn't suggest `.into()` on `const`s.\n-            // FIXME(estebank): modify once we decide to suggest `as` casts\n-            return false;\n-        }\n         if self.tcx.sess.source_map().is_imported(expr.span) {\n             // Ignore if span is from within a macro.\n             return false;\n         }\n \n+        let src = if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n+            src\n+        } else {\n+            return false;\n+        };\n+\n         // If casting this expression to a given numeric type would be appropriate in case of a type\n         // mismatch.\n         //\n@@ -708,6 +716,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             String::new()\n         };\n+\n         if let hir::ExprKind::Call(path, args) = &expr.kind {\n             if let (hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)), 1) =\n                 (&path.kind, args.len())\n@@ -743,228 +752,250 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let msg = format!(\"you can convert an `{}` to `{}`\", checked_ty, expected_ty);\n         let cast_msg = format!(\"you can cast an `{} to `{}`\", checked_ty, expected_ty);\n-        let try_msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n         let lit_msg = format!(\n             \"change the type of the numeric literal from `{}` to `{}`\",\n             checked_ty, expected_ty,\n         );\n \n-        let needs_paren = expr.precedence().order() < (PREC_POSTFIX as i8);\n-\n-        if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n-            let cast_suggestion = format!(\n-                \"{}{}{}{} as {}\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-                expected_ty,\n-            );\n-            let try_into_suggestion = format!(\n-                \"{}{}{}{}.try_into().unwrap()\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let into_suggestion = format!(\n-                \"{}{}{}{}.into()\",\n-                prefix,\n-                if needs_paren { \"(\" } else { \"\" },\n-                src,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let suffix_suggestion = format!(\n-                \"{}{}{}{}\",\n-                if needs_paren { \"(\" } else { \"\" },\n-                if let (ty::Int(_) | ty::Uint(_), ty::Float(_)) =\n-                    (&expected_ty.kind, &checked_ty.kind,)\n+        let with_opt_paren: fn(&dyn fmt::Display) -> String =\n+            if expr.precedence().order() < PREC_POSTFIX {\n+                |s| format!(\"({})\", s)\n+            } else {\n+                |s| s.to_string()\n+            };\n+\n+        let cast_suggestion = format!(\"{}{} as {}\", prefix, with_opt_paren(&src), expected_ty);\n+        let into_suggestion = format!(\"{}{}.into()\", prefix, with_opt_paren(&src));\n+        let suffix_suggestion = with_opt_paren(&format_args!(\n+            \"{}{}\",\n+            if matches!(\n+                (&expected_ty.kind, &checked_ty.kind),\n+                (ty::Int(_) | ty::Uint(_), ty::Float(_))\n+            ) {\n+                // Remove fractional part from literal, for example `42.0f32` into `42`\n+                let src = src.trim_end_matches(&checked_ty.to_string());\n+                src.split('.').next().unwrap()\n+            } else {\n+                src.trim_end_matches(&checked_ty.to_string())\n+            },\n+            expected_ty,\n+        ));\n+        let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n+            if let hir::ExprKind::Lit(lit) = &expr.kind { lit.node.is_suffixed() } else { false }\n+        };\n+\n+        let in_const_context = self.tcx.hir().is_inside_const_context(expr.hir_id);\n+\n+        let suggest_fallible_into_or_lhs_from =\n+            |err: &mut DiagnosticBuilder<'_>, exp_to_found_is_fallible: bool| {\n+                // If we know the expression the expected type is derived from, we might be able\n+                // to suggest a widening conversion rather than a narrowing one (which may\n+                // panic). For example, given x: u8 and y: u32, if we know the span of \"x\",\n+                //   x > y\n+                // can be given the suggestion \"u32::from(x) > y\" rather than\n+                // \"x > y.try_into().unwrap()\".\n+                let lhs_expr_and_src = expected_ty_expr.and_then(|expr| {\n+                    match self.tcx.sess.source_map().span_to_snippet(expr.span).ok() {\n+                        Some(src) => Some((expr, src)),\n+                        None => None,\n+                    }\n+                });\n+                let (span, msg, suggestion) = if let (Some((lhs_expr, lhs_src)), false) =\n+                    (lhs_expr_and_src, exp_to_found_is_fallible)\n                 {\n-                    // Remove fractional part from literal, for example `42.0f32` into `42`\n-                    let src = src.trim_end_matches(&checked_ty.to_string());\n-                    src.split('.').next().unwrap()\n+                    let msg = format!(\n+                        \"you can convert `{}` from `{}` to `{}`, matching the type of `{}`\",\n+                        lhs_src, expected_ty, checked_ty, src\n+                    );\n+                    let suggestion = format!(\"{}::from({})\", checked_ty, lhs_src,);\n+                    (lhs_expr.span, msg, suggestion)\n                 } else {\n-                    src.trim_end_matches(&checked_ty.to_string())\n-                },\n-                expected_ty,\n-                if needs_paren { \")\" } else { \"\" },\n-            );\n-            let literal_is_ty_suffixed = |expr: &hir::Expr<'_>| {\n-                if let hir::ExprKind::Lit(lit) = &expr.kind {\n-                    lit.node.is_suffixed()\n+                    let msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n+                    let suggestion =\n+                        format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n+                    (expr.span, msg, suggestion)\n+                };\n+                err.span_suggestion(span, &msg, suggestion, Applicability::MachineApplicable);\n+            };\n+\n+        let suggest_to_change_suffix_or_into =\n+            |err: &mut DiagnosticBuilder<'_>,\n+             found_to_exp_is_fallible: bool,\n+             exp_to_found_is_fallible: bool| {\n+                let msg = if literal_is_ty_suffixed(expr) {\n+                    &lit_msg\n+                } else if in_const_context {\n+                    // Do not recommend `into` or `try_into` in const contexts.\n+                    return;\n+                } else if found_to_exp_is_fallible {\n+                    return suggest_fallible_into_or_lhs_from(err, exp_to_found_is_fallible);\n                 } else {\n-                    false\n-                }\n+                    &msg\n+                };\n+                let suggestion = if literal_is_ty_suffixed(expr) {\n+                    suffix_suggestion.clone()\n+                } else {\n+                    into_suggestion.clone()\n+                };\n+                err.span_suggestion(expr.span, msg, suggestion, Applicability::MachineApplicable);\n             };\n \n-            let suggest_to_change_suffix_or_into =\n-                |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n+        match (&expected_ty.kind, &checked_ty.kind) {\n+            (&ty::Int(ref exp), &ty::Int(ref found)) => {\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if exp < found => (true, false),\n+                    (Some(exp), Some(found)) if exp > found => (false, true),\n+                    (None, Some(8 | 16)) => (false, true),\n+                    (Some(8 | 16), None) => (true, false),\n+                    (None, _) | (_, None) => (true, true),\n+                    _ => (false, false),\n+                };\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n+                true\n+            }\n+            (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if exp < found => (true, false),\n+                    (Some(exp), Some(found)) if exp > found => (false, true),\n+                    (None, Some(8 | 16)) => (false, true),\n+                    (Some(8 | 16), None) => (true, false),\n+                    (None, _) | (_, None) => (true, true),\n+                    _ => (false, false),\n+                };\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n+                true\n+            }\n+            (&ty::Int(exp), &ty::Uint(found)) => {\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if found < exp => (false, true),\n+                    (None, Some(8)) => (false, true),\n+                    _ => (true, true),\n+                };\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n+                true\n+            }\n+            (&ty::Uint(exp), &ty::Int(found)) => {\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if found > exp => (true, false),\n+                    (Some(8), None) => (true, false),\n+                    _ => (true, true),\n+                };\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Float(ref found)) => {\n+                if found.bit_width() < exp.bit_width() {\n+                    suggest_to_change_suffix_or_into(err, false, true);\n+                } else if literal_is_ty_suffixed(expr) {\n                     err.span_suggestion(\n                         expr.span,\n-                        if literal_is_ty_suffixed(expr) {\n-                            &lit_msg\n-                        } else if is_fallible {\n-                            &try_msg\n-                        } else {\n-                            &msg\n-                        },\n-                        if literal_is_ty_suffixed(expr) {\n-                            suffix_suggestion.clone()\n-                        } else if is_fallible {\n-                            try_into_suggestion\n-                        } else {\n-                            into_suggestion.clone()\n-                        },\n+                        &lit_msg,\n+                        suffix_suggestion,\n                         Applicability::MachineApplicable,\n                     );\n-                };\n-\n-            match (&expected_ty.kind, &checked_ty.kind) {\n-                (&ty::Int(ref exp), &ty::Int(ref found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if exp < found => true,\n-                        (None, Some(8 | 16)) => false,\n-                        (None, _) | (_, None) => true,\n-                        _ => false,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if exp < found => true,\n-                        (None, Some(8 | 16)) => false,\n-                        (None, _) | (_, None) => true,\n-                        _ => false,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Int(exp), &ty::Uint(found)) => {\n-                    let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                        (Some(exp), Some(found)) if found < exp => false,\n-                        (None, Some(8)) => false,\n-                        _ => true,\n-                    };\n-                    suggest_to_change_suffix_or_into(err, is_fallible);\n-                    true\n-                }\n-                (&ty::Uint(_), &ty::Int(_)) => {\n-                    suggest_to_change_suffix_or_into(err, true);\n-                    true\n-                }\n-                (&ty::Float(ref exp), &ty::Float(ref found)) => {\n-                    if found.bit_width() < exp.bit_width() {\n-                        suggest_to_change_suffix_or_into(err, false);\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if can_cast {\n-                        // Missing try_into implementation for `f64` to `f32`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"{}, producing the closest possible value\", cast_msg),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                } else if can_cast {\n+                    // Missing try_into implementation for `f64` to `f32`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"{}, producing the closest possible value\", cast_msg),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Uint(_) | &ty::Int(_), &ty::Float(_)) => {\n-                    if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if can_cast {\n-                        // Missing try_into implementation for `{float}` to `{integer}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"{}, rounding the float towards zero\", msg),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                true\n+            }\n+            (&ty::Uint(_) | &ty::Int(_), &ty::Float(_)) => {\n+                if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if can_cast {\n+                    // Missing try_into implementation for `{float}` to `{integer}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"{}, rounding the float towards zero\", msg),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n-                    // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n-                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer\",\n-                                msg,\n-                            ),\n-                            into_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        // Missing try_into implementation for `{integer}` to `{float}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer,\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n+                // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n+                if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer\",\n+                            msg,\n+                        ),\n+                        into_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    // Missing try_into implementation for `{integer}` to `{float}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer,\n                                  rounded if necessary\",\n-                                cast_msg,\n-                            ),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                            cast_msg,\n+                        ),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                (&ty::Float(ref exp), &ty::Int(ref found)) => {\n-                    // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n-                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer\",\n-                                &msg,\n-                            ),\n-                            into_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else if literal_is_ty_suffixed(expr) {\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &lit_msg,\n-                            suffix_suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        // Missing try_into implementation for `{integer}` to `{float}`\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\n-                                \"{}, producing the floating point representation of the integer, \\\n-                                 rounded if necessary\",\n-                                &msg,\n-                            ),\n-                            cast_suggestion,\n-                            Applicability::MaybeIncorrect, // lossy conversion\n-                        );\n-                    }\n-                    true\n+                true\n+            }\n+            (&ty::Float(ref exp), &ty::Int(ref found)) => {\n+                // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n+                if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer\",\n+                            &msg,\n+                        ),\n+                        into_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if literal_is_ty_suffixed(expr) {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &lit_msg,\n+                        suffix_suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    // Missing try_into implementation for `{integer}` to `{float}`\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}, producing the floating point representation of the integer, \\\n+                                rounded if necessary\",\n+                            &msg,\n+                        ),\n+                        cast_suggestion,\n+                        Applicability::MaybeIncorrect, // lossy conversion\n+                    );\n                 }\n-                _ => false,\n+                true\n             }\n-        } else {\n-            false\n+            _ => false,\n         }\n     }\n }"}, {"sha": "bc3ef73d851ebcdc0258c517ea26f86de9ddda98", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n             let expr = expr.peel_drop_temps();\n-            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty);\n+            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty, None);\n             extend_err(&mut err);\n             // Error possibly reported in `check_assign` so avoid emitting error again.\n             err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n@@ -98,10 +98,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {\n         let ty = self.check_expr_with_hint(expr, expected);\n         // checks don't need two phase\n-        self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n+        self.demand_coerce(expr, ty, expected, expected_ty_expr, AllowTwoPhase::No)\n     }\n \n     pub(super) fn check_expr_with_hint(\n@@ -182,7 +183,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Call(ref callee, _) => {\n                 self.warn_if_unreachable(expr.hir_id, callee.span, \"call\")\n             }\n-            ExprKind::MethodCall(_, ref span, _) => {\n+            ExprKind::MethodCall(_, ref span, _, _) => {\n                 self.warn_if_unreachable(expr.hir_id, *span, \"call\")\n             }\n             _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\"),\n@@ -262,7 +263,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ExprKind::Block(ref body, _) => self.check_block_with_expected(&body, expected),\n             ExprKind::Call(ref callee, ref args) => self.check_call(expr, &callee, args, expected),\n-            ExprKind::MethodCall(ref segment, span, ref args) => {\n+            ExprKind::MethodCall(ref segment, span, ref args, _) => {\n                 self.check_method_call(expr, segment, span, args, expected, needs)\n             }\n             ExprKind::Cast(ref e, ref t) => self.check_expr_cast(e, t, expr),\n@@ -776,7 +777,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: &Span,\n     ) -> Ty<'tcx> {\n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n-        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n+        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty, Some(lhs));\n \n         let expected_ty = expected.coercion_target_type(self, expr.span);\n         if expected_ty == self.tcx.types.bool {\n@@ -1026,7 +1027,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (element_ty, t) = match uty {\n             Some(uty) => {\n-                self.check_expr_coercable_to_type(&element, uty);\n+                self.check_expr_coercable_to_type(&element, uty, None);\n                 (uty, uty)\n             }\n             None => {\n@@ -1063,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| match flds {\n             Some(ref fs) if i < fs.len() => {\n                 let ety = fs[i].expect_ty();\n-                self.check_expr_coercable_to_type(&e, ety);\n+                self.check_expr_coercable_to_type(&e, ety, None);\n                 ety\n             }\n             _ => self.check_expr_with_expectation(&e, NoExpectation),\n@@ -1237,7 +1238,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue type-checking.\n-            self.check_expr_coercable_to_type(&field.expr, field_type);\n+            self.check_expr_coercable_to_type(&field.expr, field_type, None);\n         }\n \n         // Make sure the programmer specified correct number of fields.\n@@ -1735,7 +1736,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n-                    self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n                     element_ty\n                 }\n                 None => {\n@@ -1788,7 +1789,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         match self.resume_yield_tys {\n             Some((resume_ty, yield_ty)) => {\n-                self.check_expr_coercable_to_type(&value, yield_ty);\n+                self.check_expr_coercable_to_type(&value, yield_ty, None);\n \n                 resume_ty\n             }\n@@ -1797,7 +1798,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // information. Hence, we check the source of the yield expression here and check its\n             // value's type against `()` (this check should always hold).\n             None if src.is_await() => {\n-                self.check_expr_coercable_to_type(&value, self.tcx.mk_unit());\n+                self.check_expr_coercable_to_type(&value, self.tcx.mk_unit(), None);\n                 self.tcx.mk_unit()\n             }\n             _ => {\n@@ -1836,11 +1837,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match ty.kind {\n                 ty::FnDef(..) => {\n                     let fnptr_ty = self.tcx.mk_fn_ptr(ty.fn_sig(self.tcx));\n-                    self.demand_coerce(expr, ty, fnptr_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(expr, ty, fnptr_ty, None, AllowTwoPhase::No);\n                 }\n                 ty::Ref(_, base_ty, mutbl) => {\n                     let ptr_ty = self.tcx.mk_ptr(ty::TypeAndMut { ty: base_ty, mutbl });\n-                    self.demand_coerce(expr, ty, ptr_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(expr, ty, ptr_ty, None, AllowTwoPhase::No);\n                 }\n                 _ => {}\n             }"}, {"sha": "37652330108c9b806cfa6a8657c41be8d03b6777", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -795,6 +795,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn assemble_inherent_candidates_from_param(&mut self, param_ty: ty::ParamTy) {\n         // FIXME: do we want to commit to this behavior for param bounds?\n+        debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n \n         let bounds =\n             self.param_env.caller_bounds.iter().filter_map(|predicate| match predicate.kind() {\n@@ -952,7 +953,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         import_ids: import_ids.clone(),\n                         kind: TraitCandidate(new_trait_ref),\n                     },\n-                    true,\n+                    false,\n                 );\n             });\n         } else {\n@@ -1556,7 +1557,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         match self.mode {\n             Mode::MethodCall => item.fn_has_self_parameter,\n             Mode::Path => match item.kind {\n-                ty::AssocKind::OpaqueTy | ty::AssocKind::Type => false,\n+                ty::AssocKind::Type => false,\n                 ty::AssocKind::Fn | ty::AssocKind::Const => true,\n             },\n         }"}, {"sha": "67bdd04d3715c8fc17ae2a2c2011034f71e5058d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -158,9 +158,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let path = self.tcx.def_path_str(trait_ref.def_id);\n \n                             let ty = match item.kind {\n-                                ty::AssocKind::Const\n-                                | ty::AssocKind::Type\n-                                | ty::AssocKind::OpaqueTy => rcvr_ty,\n+                                ty::AssocKind::Const | ty::AssocKind::Type => rcvr_ty,\n                                 ty::AssocKind::Fn => self\n                                     .tcx\n                                     .fn_sig(item.def_id)"}, {"sha": "a409e20953da144c53067fdcfcf3c9631ffde9d9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1046,7 +1046,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n             // Gather locals in statics (because of block expressions).\n             GatherLocalsVisitor { fcx: &fcx, parent_id: id }.visit_body(body);\n \n-            fcx.check_expr_coercable_to_type(&body.value, revealed_ty);\n+            fcx.check_expr_coercable_to_type(&body.value, revealed_ty, None);\n \n             fcx.write_ty(id, revealed_ty);\n \n@@ -1943,7 +1943,6 @@ fn check_specialization_validity<'tcx>(\n     let kind = match impl_item.kind {\n         hir::ImplItemKind::Const(..) => ty::AssocKind::Const,\n         hir::ImplItemKind::Fn(..) => ty::AssocKind::Fn,\n-        hir::ImplItemKind::OpaqueTy(..) => ty::AssocKind::OpaqueTy,\n         hir::ImplItemKind::TyAlias(_) => ty::AssocKind::Type,\n     };\n \n@@ -2114,7 +2113,7 @@ fn check_impl_items_against_trait<'tcx>(\n                         err.emit()\n                     }\n                 }\n-                hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(_) => {\n+                hir::ImplItemKind::TyAlias(_) => {\n                     let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssocKind::Type {\n                         compare_ty_impl(\n@@ -2367,8 +2366,6 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n             )\n         }\n         ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.ident),\n-        // FIXME(type_alias_impl_trait): we should print bounds here too.\n-        ty::AssocKind::OpaqueTy => format!(\"type {} = Type;\", assoc.ident),\n         ty::AssocKind::Const => {\n             let ty = tcx.type_of(assoc.def_id);\n             let val = expr::ty_kind_suggestion(ty).unwrap_or(\"value\");\n@@ -2390,11 +2387,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalDefId) -> bo\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive(spans) => {\n-            let mut err = recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id());\n-            for span in spans {\n-                err.span_label(span, \"recursive without indirection\");\n-            }\n-            err.emit();\n+            recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id(), spans);\n             return false;\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),\n@@ -3912,7 +3905,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                  sugg_unit: bool| {\n             let (span, start_span, args) = match &expr.kind {\n                 hir::ExprKind::Call(hir::Expr { span, .. }, args) => (*span, *span, &args[..]),\n-                hir::ExprKind::MethodCall(path_segment, span, args) => (\n+                hir::ExprKind::MethodCall(path_segment, span, args, _) => (\n                     *span,\n                     // `sp` doesn't point at the whole `foo.bar()`, only at `bar`.\n                     path_segment\n@@ -4123,7 +4116,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n                 // We're processing function arguments so we definitely want to use\n                 // two-phase borrows.\n-                self.demand_coerce(&arg, checked_ty, coerce_ty, AllowTwoPhase::Yes);\n+                self.demand_coerce(&arg, checked_ty, coerce_ty, None, AllowTwoPhase::Yes);\n                 final_arg_types.push((i, checked_ty, coerce_ty));\n \n                 // 3. Relate the expected type and the formal one,\n@@ -4541,7 +4534,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.demand_eqtype(init.span, local_ty, init_ty);\n             init_ty\n         } else {\n-            self.check_expr_coercable_to_type(init, local_ty)\n+            self.check_expr_coercable_to_type(init, local_ty, None)\n         }\n     }\n \n@@ -5027,6 +5020,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         if let Some((sp, msg, suggestion, applicability)) = self.check_ref(expr, found, expected) {\n             err.span_suggestion(sp, msg, suggestion, applicability);\n@@ -5037,7 +5031,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let sp = self.sess().source_map().guess_head_span(sp);\n                 err.span_label(sp, &format!(\"{} defined here\", found));\n             }\n-        } else if !self.check_for_cast(err, expr, found, expected) {\n+        } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             let is_struct_pat_shorthand_field =\n                 self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n@@ -5091,7 +5085,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n-        if self.tcx.hir().is_const_context(expr.hir_id) {\n+        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n             // Do not suggest `Box::new` in const context.\n             return;\n         }\n@@ -5128,7 +5122,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> bool {\n         // Handle #68197.\n \n-        if self.tcx.hir().is_const_context(expr.hir_id) {\n+        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n             // Do not suggest `Box::new` in const context.\n             return false;\n         }"}, {"sha": "a3a27dc138be96f11605c2b3d898905673bc3160", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -57,9 +57,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n-                self.check_expr_coercable_to_type(lhs_expr, tcx.types.bool);\n+                self.check_expr_coercable_to_type(lhs_expr, tcx.types.bool, None);\n                 let lhs_diverges = self.diverges.get();\n-                self.check_expr_coercable_to_type(rhs_expr, tcx.types.bool);\n+                self.check_expr_coercable_to_type(rhs_expr, tcx.types.bool, None);\n \n                 // Depending on the LHS' value, the RHS can never execute.\n                 self.diverges.set(lhs_diverges);\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: lhs_expr.span,\n                 });\n-                self.demand_coerce(lhs_expr, lhs_ty, fresh_var, AllowTwoPhase::No)\n+                self.demand_coerce(lhs_expr, lhs_ty, fresh_var, Some(rhs_expr), AllowTwoPhase::No)\n             }\n             IsAssign::Yes => {\n                 // rust-lang/rust#52126: We have to use strict\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n \n         // see `NB` above\n-        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n+        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var, Some(lhs_expr));\n         let rhs_ty = self.resolve_vars_with_obligations(rhs_ty);\n \n         let return_ty = match result {"}, {"sha": "f3297ed67434758441bc026443e54aab1384d847", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 93, "deletions": 98, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -316,9 +316,6 @@ fn check_associated_item(\n                     fcx.register_wf_obligation(ty.into(), span, code.clone());\n                 }\n             }\n-            ty::AssocKind::OpaqueTy => {\n-                // Do nothing: opaque types check themselves.\n-            }\n         }\n \n         implied_bounds\n@@ -804,14 +801,14 @@ fn check_where_clauses<'tcx, 'fcx>(\n             traits::Obligation::new(cause, fcx.param_env, pred)\n         });\n \n-    let mut predicates = predicates.instantiate_identity(fcx.tcx);\n+    let predicates = predicates.instantiate_identity(fcx.tcx);\n \n-    if let Some((return_ty, span)) = return_ty {\n-        let opaque_types = check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n-        for _ in 0..opaque_types.len() {\n-            predicates.spans.push(span);\n+    if let Some((mut return_ty, span)) = return_ty {\n+        if return_ty.has_infer_types_or_consts() {\n+            fcx.select_obligations_where_possible(false, |_| {});\n+            return_ty = fcx.resolve_vars_if_possible(&return_ty);\n         }\n-        predicates.predicates.extend(opaque_types);\n+        check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n     }\n \n     let predicates = fcx.normalize_associated_types_in(span, &predicates);\n@@ -883,119 +880,117 @@ fn check_opaque_types<'fcx, 'tcx>(\n     fn_def_id: LocalDefId,\n     span: Span,\n     ty: Ty<'tcx>,\n-) -> Vec<ty::Predicate<'tcx>> {\n+) {\n     trace!(\"check_opaque_types(ty={:?})\", ty);\n-    let mut substituted_predicates = Vec::new();\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         ty_op: |ty| {\n             if let ty::Opaque(def_id, substs) = ty.kind {\n                 trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n-                // Only check named `impl Trait` types defined in this crate.\n-                // FIXME(eddyb) is  `generics.parent.is_none()` correct? It seems\n-                // potentially risky wrt associated types in `impl`s.\n-                if generics.parent.is_none() && def_id.is_local() {\n-                    let opaque_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n-                    if may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n-                        trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n-                        let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-                        for (i, arg) in substs.iter().enumerate() {\n-                            let arg_is_param = match arg.unpack() {\n-                                GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n-\n-                                GenericArgKind::Lifetime(region) => {\n-                                    if let ty::ReStatic = region {\n-                                        tcx.sess\n-                                            .struct_span_err(\n-                                                span,\n-                                                \"non-defining opaque type use in defining scope\",\n-                                            )\n-                                            .span_label(\n-                                                tcx.def_span(generics.param_at(i, tcx).def_id),\n-                                                \"cannot use static lifetime; use a bound lifetime \\\n-                                                 instead or remove the lifetime parameter from the \\\n-                                                 opaque type\",\n-                                            )\n-                                            .emit();\n-                                        continue;\n-                                    }\n-\n-                                    true\n-                                }\n-\n-                                GenericArgKind::Const(ct) => {\n-                                    matches!(ct.val, ty::ConstKind::Param(_))\n-                                }\n-                            };\n-\n-                            if arg_is_param {\n-                                seen_params.entry(arg).or_default().push(i);\n-                            } else {\n-                                // Prevent `fn foo() -> Foo<u32>` from being defining.\n-                                let opaque_param = generics.param_at(i, tcx);\n+\n+                let opaque_hir_id = if let Some(local_id) = def_id.as_local() {\n+                    tcx.hir().as_local_hir_id(local_id)\n+                } else {\n+                    // Opaque types from other crates won't have defining uses in this crate.\n+                    return ty;\n+                };\n+                if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(_), .. }) =\n+                    tcx.hir().expect_item(opaque_hir_id).kind\n+                {\n+                    // No need to check return position impl trait (RPIT)\n+                    // because for type and const parameters they are correct\n+                    // by construction: we convert\n+                    //\n+                    // fn foo<P0..Pn>() -> impl Trait\n+                    //\n+                    // into\n+                    //\n+                    // type Foo<P0...Pn>\n+                    // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n+                    //\n+                    // For lifetime parameters we convert\n+                    //\n+                    // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+                    //\n+                    // into\n+                    //\n+                    // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+                    // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+                    //\n+                    // which would error here on all of the `'static` args.\n+                    return ty;\n+                }\n+                if !may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n+                    return ty;\n+                }\n+                trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n+                let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+                for (i, arg) in substs.iter().enumerate() {\n+                    let arg_is_param = match arg.unpack() {\n+                        GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n+\n+                        GenericArgKind::Lifetime(region) => {\n+                            if let ty::ReStatic = region {\n                                 tcx.sess\n                                     .struct_span_err(\n                                         span,\n                                         \"non-defining opaque type use in defining scope\",\n                                     )\n-                                    .span_note(\n-                                        tcx.def_span(opaque_param.def_id),\n-                                        &format!(\n-                                            \"used non-generic {} `{}` for generic parameter\",\n-                                            opaque_param.kind.descr(),\n-                                            arg,\n-                                        ),\n-                                    )\n-                                    .emit();\n-                            }\n-                        } // for (arg, param)\n-\n-                        for (_, indices) in seen_params {\n-                            if indices.len() > 1 {\n-                                let descr = generics.param_at(indices[0], tcx).kind.descr();\n-                                let spans: Vec<_> = indices\n-                                    .into_iter()\n-                                    .map(|i| tcx.def_span(generics.param_at(i, tcx).def_id))\n-                                    .collect();\n-                                tcx.sess\n-                                    .struct_span_err(\n-                                        span,\n-                                        \"non-defining opaque type use in defining scope\",\n+                                    .span_label(\n+                                        tcx.def_span(generics.param_at(i, tcx).def_id),\n+                                        \"cannot use static lifetime; use a bound lifetime \\\n+                                                 instead or remove the lifetime parameter from the \\\n+                                                 opaque type\",\n                                     )\n-                                    .span_note(spans, &format!(\"{} used multiple times\", descr))\n                                     .emit();\n+                                continue;\n                             }\n-                        }\n-                    } // if may_define_opaque_type\n \n-                    // Now register the bounds on the parameters of the opaque type\n-                    // so the parameters given by the function need to fulfill them.\n-                    //\n-                    //     type Foo<T: Bar> = impl Baz + 'static;\n-                    //     fn foo<U>() -> Foo<U> { .. *}\n-                    //\n-                    // becomes\n-                    //\n-                    //     type Foo<T: Bar> = impl Baz + 'static;\n-                    //     fn foo<U: Bar>() -> Foo<U> { .. *}\n-                    let predicates = tcx.predicates_of(def_id);\n-                    trace!(\"check_opaque_types: may define, predicates={:#?}\", predicates,);\n-                    for &(pred, _) in predicates.predicates {\n-                        let substituted_pred = pred.subst(fcx.tcx, substs);\n-                        // Avoid duplication of predicates that contain no parameters, for example.\n-                        if !predicates.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n-                            substituted_predicates.push(substituted_pred);\n+                            true\n                         }\n+\n+                        GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n+                    };\n+\n+                    if arg_is_param {\n+                        seen_params.entry(arg).or_default().push(i);\n+                    } else {\n+                        // Prevent `fn foo() -> Foo<u32>` from being defining.\n+                        let opaque_param = generics.param_at(i, tcx);\n+                        tcx.sess\n+                            .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                            .span_note(\n+                                tcx.def_span(opaque_param.def_id),\n+                                &format!(\n+                                    \"used non-generic {} `{}` for generic parameter\",\n+                                    opaque_param.kind.descr(),\n+                                    arg,\n+                                ),\n+                            )\n+                            .emit();\n                     }\n-                } // if is_named_opaque_type\n+                } // for (arg, param)\n+\n+                for (_, indices) in seen_params {\n+                    if indices.len() > 1 {\n+                        let descr = generics.param_at(indices[0], tcx).kind.descr();\n+                        let spans: Vec<_> = indices\n+                            .into_iter()\n+                            .map(|i| tcx.def_span(generics.param_at(i, tcx).def_id))\n+                            .collect();\n+                        tcx.sess\n+                            .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                            .span_note(spans, &format!(\"{} used multiple times\", descr))\n+                            .emit();\n+                    }\n+                }\n             } // if let Opaque\n             ty\n         },\n         lt_op: |lt| lt,\n         ct_op: |ct| ct,\n     });\n-    substituted_predicates\n }\n \n const HELP_FOR_SELF_TYPE: &str = \"consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, \\"}, {"sha": "159d3d7a538a668e18c5b20910e3e0f06caa7c8c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -460,7 +460,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let mut skip_add = false;\n \n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.kind {\n-                if let hir::OpaqueTyOrigin::TypeAlias = opaque_defn.origin {\n+                if let hir::OpaqueTyOrigin::Misc = opaque_defn.origin {\n                     if def_id == defin_ty_def_id {\n                         debug!(\n                             \"skipping adding concrete definition for opaque type {:?} {:?}\","}, {"sha": "1d59d749634ee1cae5ac8913cf7ba5c8f6bdf596", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 43, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -742,7 +742,7 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n         hir::ImplItemKind::Fn(..) => {\n             tcx.ensure().fn_sig(def_id);\n         }\n-        hir::ImplItemKind::TyAlias(_) | hir::ImplItemKind::OpaqueTy(_) => {\n+        hir::ImplItemKind::TyAlias(_) => {\n             // Account for `type T = _;`\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_impl_item(impl_item);\n@@ -1202,22 +1202,11 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {\n                 impl_trait_fn.or_else(|| {\n                     let parent_id = tcx.hir().get_parent_item(hir_id);\n-                    if parent_id != hir_id && parent_id != CRATE_HIR_ID {\n-                        debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n-                        // If this 'impl Trait' is nested inside another 'impl Trait'\n-                        // (e.g. `impl Foo<MyType = impl Bar<A>>`), we need to use the 'parent'\n-                        // 'impl Trait' for its generic parameters, since we can reference them\n-                        // from the 'child' 'impl Trait'\n-                        if let Node::Item(hir::Item { kind: ItemKind::OpaqueTy(..), .. }) =\n-                            tcx.hir().get(parent_id)\n-                        {\n-                            Some(tcx.hir().local_def_id(parent_id).to_def_id())\n-                        } else {\n-                            None\n-                        }\n-                    } else {\n-                        None\n-                    }\n+                    assert!(parent_id != hir_id && parent_id != CRATE_HIR_ID);\n+                    debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n+                    // Opaque types are always nested within another item, and\n+                    // inherit the generics of the item.\n+                    Some(tcx.hir().local_def_id(parent_id).to_def_id())\n                 })\n             }\n             _ => None,\n@@ -1428,7 +1417,7 @@ fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n         Slice(ty) | Array(ty, _) => is_suggestable_infer_ty(ty),\n         Tup(tys) => tys.iter().any(is_suggestable_infer_ty),\n         Ptr(mut_ty) | Rptr(_, mut_ty) => is_suggestable_infer_ty(mut_ty.ty),\n-        Def(_, generic_args) => are_suggestable_generic_args(generic_args),\n+        OpaqueDef(_, generic_args) => are_suggestable_generic_args(generic_args),\n         Path(hir::QPath::TypeRelative(ty, segment)) => {\n             is_suggestable_infer_ty(ty) || are_suggestable_generic_args(segment.generic_args().args)\n         }\n@@ -1715,31 +1704,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     let ast_generics = match node {\n         Node::TraitItem(item) => &item.generics,\n \n-        Node::ImplItem(item) => match item.kind {\n-            ImplItemKind::OpaqueTy(ref bounds) => {\n-                ty::print::with_no_queries(|| {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let opaque_ty = tcx.mk_opaque(def_id, substs);\n-                    debug!(\n-                        \"explicit_predicates_of({:?}): created opaque type {:?}\",\n-                        def_id, opaque_ty\n-                    );\n-\n-                    // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                    let bounds = AstConv::compute_bounds(\n-                        &icx,\n-                        opaque_ty,\n-                        bounds,\n-                        SizedByDefault::Yes,\n-                        tcx.def_span(def_id),\n-                    );\n-\n-                    predicates.extend(bounds.predicates(tcx, opaque_ty));\n-                    &item.generics\n-                })\n-            }\n-            _ => &item.generics,\n-        },\n+        Node::ImplItem(item) => &item.generics,\n \n         Node::Item(item) => {\n             match item.kind {"}, {"sha": "549a20531e2994b5d6688ec43938d2b6ce096f4b", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -64,13 +64,6 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     icx.to_ty(ty)\n                 }\n             }\n-            ImplItemKind::OpaqueTy(_) => {\n-                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id).to_def_id()).is_none() {\n-                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n-                }\n-\n-                find_opaque_ty_constraints(tcx, def_id.expect_local())\n-            }\n             ImplItemKind::TyAlias(ref ty) => {\n                 if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id).to_def_id()).is_none() {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n@@ -107,26 +100,17 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n+                ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::Binding, .. }) => {\n+                    let_position_impl_trait_type(tcx, def_id.expect_local())\n+                }\n                 ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {\n                     find_opaque_ty_constraints(tcx, def_id.expect_local())\n                 }\n                 // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), origin, .. }) => {\n-                    let concrete_types = match origin {\n-                        OpaqueTyOrigin::FnReturn | OpaqueTyOrigin::AsyncFn => {\n-                            &tcx.mir_borrowck(owner.expect_local()).concrete_opaque_types\n-                        }\n-                        OpaqueTyOrigin::Misc => {\n-                            // We shouldn't leak borrowck results through impl trait in bindings.\n-                            // For example, we shouldn't be able to tell if `x` in\n-                            // `let x: impl Sized + 'a = &()` has type `&'static ()` or `&'a ()`.\n-                            &tcx.typeck_tables_of(owner.expect_local()).concrete_opaque_types\n-                        }\n-                        OpaqueTyOrigin::TypeAlias => {\n-                            span_bug!(item.span, \"Type alias impl trait shouldn't have an owner\")\n-                        }\n-                    };\n-                    let concrete_ty = concrete_types\n+                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), .. }) => {\n+                    let concrete_ty = tcx\n+                        .mir_borrowck(owner.expect_local())\n+                        .concrete_opaque_types\n                         .get(&def_id)\n                         .map(|opaque| opaque.concrete_type)\n                         .unwrap_or_else(|| {\n@@ -155,13 +139,6 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                             }\n                         });\n                     debug!(\"concrete_ty = {:?}\", concrete_ty);\n-                    if concrete_ty.has_erased_regions() {\n-                        // FIXME(impl_trait_in_bindings) Handle this case.\n-                        tcx.sess.span_fatal(\n-                            item.span,\n-                            \"lifetimes in impl Trait types in bindings are not currently supported\",\n-                        );\n-                    }\n                     concrete_ty\n                 }\n                 ItemKind::Trait(..)\n@@ -596,6 +573,60 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     }\n }\n \n+/// Retrieve the inferred concrete type for let position impl trait.\n+///\n+/// This is different to other kinds of impl trait because:\n+///\n+/// 1. We know which function contains the defining use (the function that\n+///    contains the let statement)\n+/// 2. We do not currently allow (free) lifetimes in the return type. `let`\n+///    statements in some statically unreachable code are removed from the MIR\n+///    by the time we borrow check, and it's not clear how we should handle\n+///    those.\n+fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty<'_> {\n+    let scope = tcx.hir().get_defining_scope(tcx.hir().as_local_hir_id(opaque_ty_id));\n+    let scope_def_id = tcx.hir().local_def_id(scope);\n+\n+    let opaque_ty_def_id = opaque_ty_id.to_def_id();\n+\n+    let owner_tables = tcx.typeck_tables_of(scope_def_id);\n+    let concrete_ty = owner_tables\n+        .concrete_opaque_types\n+        .get(&opaque_ty_def_id)\n+        .map(|opaque| opaque.concrete_type)\n+        .unwrap_or_else(|| {\n+            tcx.sess.delay_span_bug(\n+                DUMMY_SP,\n+                &format!(\n+                    \"owner {:?} has no opaque type for {:?} in its tables\",\n+                    scope_def_id, opaque_ty_id\n+                ),\n+            );\n+            if let Some(ErrorReported) = owner_tables.tainted_by_errors {\n+                // Some error in the owner fn prevented us from populating the\n+                // `concrete_opaque_types` table.\n+                tcx.types.err\n+            } else {\n+                // We failed to resolve the opaque type or it resolves to\n+                // itself. Return the non-revealed type, which should result in\n+                // E0720.\n+                tcx.mk_opaque(\n+                    opaque_ty_def_id,\n+                    InternalSubsts::identity_for_item(tcx, opaque_ty_def_id),\n+                )\n+            }\n+        });\n+    debug!(\"concrete_ty = {:?}\", concrete_ty);\n+    if concrete_ty.has_erased_regions() {\n+        // FIXME(impl_trait_in_bindings) Handle this case.\n+        tcx.sess.span_fatal(\n+            tcx.hir().span(tcx.hir().as_local_hir_id(opaque_ty_id)),\n+            \"lifetimes in impl Trait types in bindings are not currently supported\",\n+        );\n+    }\n+    concrete_ty\n+}\n+\n fn infer_placeholder_type(\n     tcx: TyCtxt<'_>,\n     def_id: LocalDefId,"}, {"sha": "6baadb8febd3689724696c7c8d5916abcb863287", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -185,7 +185,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_exprs(args);\n             }\n \n-            hir::ExprKind::MethodCall(.., ref args) => {\n+            hir::ExprKind::MethodCall(.., ref args, _) => {\n                 // callee.m(args)\n                 self.consume_exprs(args);\n             }"}, {"sha": "37d383db68ab6ae917ca7efb6d2c086031c1513b", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -140,13 +140,6 @@ fn enforce_impl_params_are_constrained(\n                         Vec::new()\n                     }\n                 }\n-                ty::AssocKind::OpaqueTy => {\n-                    // We don't know which lifetimes appear in the actual\n-                    // opaque type, so use all of the lifetimes that appear\n-                    // in the type's predicates.\n-                    let predicates = tcx.predicates_of(def_id).instantiate_identity(tcx);\n-                    cgp::parameters_for(&predicates, true)\n-                }\n                 ty::AssocKind::Fn | ty::AssocKind::Const => Vec::new(),\n             }\n         })"}, {"sha": "adb2ae9a5d660766984c58170ac41f3b73596132", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1138,10 +1138,6 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n                 TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n             }\n-            hir::ImplItemKind::OpaqueTy(ref bounds) => OpaqueTyItem(\n-                OpaqueTy { bounds: bounds.clean(cx), generics: Generics::default() },\n-                true,\n-            ),\n         };\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n         Item {\n@@ -1308,7 +1304,6 @@ impl Clean<Item> for ty::AssocItem {\n                     )\n                 }\n             }\n-            ty::AssocKind::OpaqueTy => unimplemented!(),\n         };\n \n         let visibility = match self.container {\n@@ -1356,7 +1351,7 @@ impl Clean<Type> for hir::Ty<'_> {\n                 Array(box ty.clean(cx), length)\n             }\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n-            TyKind::Def(item_id, _) => {\n+            TyKind::OpaqueDef(item_id, _) => {\n                 let item = cx.tcx.hir().expect_item(item_id.id);\n                 if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n                     ImplTrait(ty.bounds.clean(cx))"}, {"sha": "f0900c34a4ba3dbcab473d92f4a3c8e25b85e986", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -126,7 +126,7 @@ impl<'a> SourceCollector<'a> {\n             &self.scx.themes,\n         );\n         self.scx.fs.write(&cur, v.as_bytes())?;\n-        self.scx.local_sources.insert(p.clone(), href);\n+        self.scx.local_sources.insert(p, href);\n         Ok(())\n     }\n }"}, {"sha": "f5b2f1bb5b17844a6f89e1fd700b129deddd26af", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 73, "deletions": 29, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty;\n use rustc_resolve::ParentScope;\n use rustc_session::lint;\n+use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n@@ -122,6 +123,42 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }\n     }\n \n+    /// Resolves a string as a macro.\n+    fn macro_resolve(&self, path_str: &str, parent_id: Option<hir::HirId>) -> Option<Res> {\n+        let cx = self.cx;\n+        let path = ast::Path::from_ident(Ident::from_str(path_str));\n+        cx.enter_resolver(|resolver| {\n+            if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n+                &path,\n+                None,\n+                &ParentScope::module(resolver.graph_root()),\n+                false,\n+                false,\n+            ) {\n+                if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n+                    return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+                }\n+            }\n+            if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n+                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+            }\n+            if let Some(module_id) = parent_id.or(self.mod_ids.last().cloned()) {\n+                let module_id = cx.tcx.hir().local_def_id(module_id);\n+                if let Ok((_, res)) =\n+                    resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n+                {\n+                    // don't resolve builtins like `#[derive]`\n+                    if let Res::Def(..) = res {\n+                        let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                        return Some(res);\n+                    }\n+                }\n+            } else {\n+                debug!(\"attempting to resolve item without parent module: {}\", path_str);\n+            }\n+            None\n+        })\n+    }\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n     fn resolve(\n@@ -371,6 +408,22 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n }\n \n+/// Check for resolve collisions between a trait and its derive\n+///\n+/// These are common and we should just resolve to the trait in that case\n+fn is_derive_trait_collision<T>(ns: &PerNS<Option<(Res, T)>>) -> bool {\n+    if let PerNS {\n+        type_ns: Some((Res::Def(DefKind::Trait, _), _)),\n+        macro_ns: Some((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n+        ..\n+    } = *ns\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let item_hir_id = if item.is_mod() {\n@@ -451,7 +504,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             ..\n                         },\n                     ..\n-                })) => segments.first().and_then(|seg| Some(seg.ident.to_string())),\n+                })) => segments.first().map(|seg| seg.ident.to_string()),\n                 Some(hir::Node::Item(hir::Item {\n                     ident, kind: hir::ItemKind::Enum(..), ..\n                 }))\n@@ -532,6 +585,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 } else if link.starts_with(\"macro@\") {\n                     kind = Some(MacroNS);\n                     link.trim_start_matches(\"macro@\")\n+                } else if link.starts_with(\"derive@\") {\n+                    kind = Some(MacroNS);\n+                    link.trim_start_matches(\"derive@\")\n                 } else if link.ends_with('!') {\n                     kind = Some(MacroNS);\n                     link.trim_end_matches('!')\n@@ -614,8 +670,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                     None => {\n                         // Try everything!\n-                        let candidates = PerNS {\n-                            macro_ns: macro_resolve(cx, path_str)\n+                        let mut candidates = PerNS {\n+                            macro_ns: self\n+                                .macro_resolve(path_str, base_node)\n                                 .map(|res| (res, extra_fragment.clone())),\n                             type_ns: match self.resolve(\n                                 path_str,\n@@ -668,10 +725,16 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             continue;\n                         }\n \n-                        let is_unambiguous = candidates.clone().present_items().count() == 1;\n-                        if is_unambiguous {\n+                        let len = candidates.clone().present_items().count();\n+\n+                        if len == 1 {\n                             candidates.present_items().next().unwrap()\n+                        } else if len == 2 && is_derive_trait_collision(&candidates) {\n+                            candidates.type_ns.unwrap()\n                         } else {\n+                            if is_derive_trait_collision(&candidates) {\n+                                candidates.macro_ns = None;\n+                            }\n                             ambiguity_error(\n                                 cx,\n                                 &item,\n@@ -684,7 +747,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                     Some(MacroNS) => {\n-                        if let Some(res) = macro_resolve(cx, path_str) {\n+                        if let Some(res) = self.macro_resolve(path_str, base_node) {\n                             (res, extra_fragment)\n                         } else {\n                             resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -727,28 +790,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n-/// Resolves a string as a macro.\n-fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n-    let path = ast::Path::from_ident(Ident::from_str(path_str));\n-    cx.enter_resolver(|resolver| {\n-        if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path,\n-            None,\n-            &ParentScope::module(resolver.graph_root()),\n-            false,\n-            false,\n-        ) {\n-            if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n-            }\n-        }\n-        if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-            return Some(res.map_id(|_| panic!(\"unexpected id\")));\n-        }\n-        None\n-    })\n-}\n-\n fn build_diagnostic(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -916,7 +957,7 @@ fn ambiguity_error(\n                             Res::Def(DefKind::AssocFn | DefKind::Fn, _) => {\n                                 (\"add parentheses\", format!(\"{}()\", path_str))\n                             }\n-                            Res::Def(DefKind::Macro(..), _) => {\n+                            Res::Def(DefKind::Macro(MacroKind::Bang), _) => {\n                                 (\"add an exclamation mark\", format!(\"{}!\", path_str))\n                             }\n                             _ => {\n@@ -930,6 +971,9 @@ fn ambiguity_error(\n                                     (Res::Def(DefKind::Mod, _), _) => \"module\",\n                                     (_, TypeNS) => \"type\",\n                                     (_, ValueNS) => \"value\",\n+                                    (Res::Def(DefKind::Macro(MacroKind::Derive), _), MacroNS) => {\n+                                        \"derive\"\n+                                    }\n                                     (_, MacroNS) => \"macro\",\n                                 };\n "}, {"sha": "21aa0ded5a4b2c186dbd7e00215de4f93ec12d88", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -676,7 +676,11 @@ impl Collector {\n     }\n \n     fn generate_name(&self, line: usize, filename: &FileName) -> String {\n-        format!(\"{} - {} (line {})\", filename, self.names.join(\"::\"), line)\n+        let mut item_path = self.names.join(\"::\");\n+        if !item_path.is_empty() {\n+            item_path.push(' ');\n+        }\n+        format!(\"{} - {}(line {})\", filename, item_path, line)\n     }\n \n     pub fn set_position(&mut self, position: Span) {"}, {"sha": "83029a8642097e107b7223322e99ff838e9469b7", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -41,7 +41,7 @@ dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n [target.'cfg(all(any(target_arch = \"x86_64\", target_arch = \"aarch64\"), target_os = \"hermit\"))'.dependencies]\n-hermit-abi = { version = \"0.1.13\", features = ['rustc-dep-of-std'] }\n+hermit-abi = { version = \"0.1.14\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.9.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "d752ba89a276d9762263c6f4fdeccbaed45a12ee", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -916,8 +916,7 @@ impl f32 {\n \n #[cfg(test)]\n mod tests {\n-    use crate::f32;\n-    use crate::f32::*;\n+    use crate::f32::consts;\n     use crate::num::FpCategory as Fp;\n     use crate::num::*;\n \n@@ -928,14 +927,14 @@ mod tests {\n \n     #[test]\n     fn test_min_nan() {\n-        assert_eq!(NAN.min(2.0), 2.0);\n-        assert_eq!(2.0f32.min(NAN), 2.0);\n+        assert_eq!(f32::NAN.min(2.0), 2.0);\n+        assert_eq!(2.0f32.min(f32::NAN), 2.0);\n     }\n \n     #[test]\n     fn test_max_nan() {\n-        assert_eq!(NAN.max(2.0), 2.0);\n-        assert_eq!(2.0f32.max(NAN), 2.0);\n+        assert_eq!(f32::NAN.max(2.0), 2.0);\n+        assert_eq!(2.0f32.max(f32::NAN), 2.0);\n     }\n \n     #[test]\n@@ -1158,52 +1157,52 @@ mod tests {\n \n     #[test]\n     fn test_abs() {\n-        assert_eq!(INFINITY.abs(), INFINITY);\n+        assert_eq!(f32::INFINITY.abs(), f32::INFINITY);\n         assert_eq!(1f32.abs(), 1f32);\n         assert_eq!(0f32.abs(), 0f32);\n         assert_eq!((-0f32).abs(), 0f32);\n         assert_eq!((-1f32).abs(), 1f32);\n-        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f32 / NEG_INFINITY).abs(), 0f32);\n-        assert!(NAN.abs().is_nan());\n+        assert_eq!(f32::NEG_INFINITY.abs(), f32::INFINITY);\n+        assert_eq!((1f32 / f32::NEG_INFINITY).abs(), 0f32);\n+        assert!(f32::NAN.abs().is_nan());\n     }\n \n     #[test]\n     fn test_signum() {\n-        assert_eq!(INFINITY.signum(), 1f32);\n+        assert_eq!(f32::INFINITY.signum(), 1f32);\n         assert_eq!(1f32.signum(), 1f32);\n         assert_eq!(0f32.signum(), 1f32);\n         assert_eq!((-0f32).signum(), -1f32);\n         assert_eq!((-1f32).signum(), -1f32);\n-        assert_eq!(NEG_INFINITY.signum(), -1f32);\n-        assert_eq!((1f32 / NEG_INFINITY).signum(), -1f32);\n-        assert!(NAN.signum().is_nan());\n+        assert_eq!(f32::NEG_INFINITY.signum(), -1f32);\n+        assert_eq!((1f32 / f32::NEG_INFINITY).signum(), -1f32);\n+        assert!(f32::NAN.signum().is_nan());\n     }\n \n     #[test]\n     fn test_is_sign_positive() {\n-        assert!(INFINITY.is_sign_positive());\n+        assert!(f32::INFINITY.is_sign_positive());\n         assert!(1f32.is_sign_positive());\n         assert!(0f32.is_sign_positive());\n         assert!(!(-0f32).is_sign_positive());\n         assert!(!(-1f32).is_sign_positive());\n-        assert!(!NEG_INFINITY.is_sign_positive());\n-        assert!(!(1f32 / NEG_INFINITY).is_sign_positive());\n-        assert!(NAN.is_sign_positive());\n-        assert!(!(-NAN).is_sign_positive());\n+        assert!(!f32::NEG_INFINITY.is_sign_positive());\n+        assert!(!(1f32 / f32::NEG_INFINITY).is_sign_positive());\n+        assert!(f32::NAN.is_sign_positive());\n+        assert!(!(-f32::NAN).is_sign_positive());\n     }\n \n     #[test]\n     fn test_is_sign_negative() {\n-        assert!(!INFINITY.is_sign_negative());\n+        assert!(!f32::INFINITY.is_sign_negative());\n         assert!(!1f32.is_sign_negative());\n         assert!(!0f32.is_sign_negative());\n         assert!((-0f32).is_sign_negative());\n         assert!((-1f32).is_sign_negative());\n-        assert!(NEG_INFINITY.is_sign_negative());\n-        assert!((1f32 / NEG_INFINITY).is_sign_negative());\n-        assert!(!NAN.is_sign_negative());\n-        assert!((-NAN).is_sign_negative());\n+        assert!(f32::NEG_INFINITY.is_sign_negative());\n+        assert!((1f32 / f32::NEG_INFINITY).is_sign_negative());\n+        assert!(!f32::NAN.is_sign_negative());\n+        assert!((-f32::NAN).is_sign_negative());\n     }\n \n     #[test]\n@@ -1268,13 +1267,13 @@ mod tests {\n \n     #[test]\n     fn test_sqrt_domain() {\n-        assert!(NAN.sqrt().is_nan());\n-        assert!(NEG_INFINITY.sqrt().is_nan());\n+        assert!(f32::NAN.sqrt().is_nan());\n+        assert!(f32::NEG_INFINITY.sqrt().is_nan());\n         assert!((-1.0f32).sqrt().is_nan());\n         assert_eq!((-0.0f32).sqrt(), -0.0);\n         assert_eq!(0.0f32.sqrt(), 0.0);\n         assert_eq!(1.0f32.sqrt(), 1.0);\n-        assert_eq!(INFINITY.sqrt(), INFINITY);\n+        assert_eq!(f32::INFINITY.sqrt(), f32::INFINITY);\n     }\n \n     #[test]\n@@ -1523,13 +1522,13 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn test_clamp_min_is_nan() {\n-        let _ = 1.0f32.clamp(NAN, 1.0);\n+        let _ = 1.0f32.clamp(f32::NAN, 1.0);\n     }\n \n     #[test]\n     #[should_panic]\n     fn test_clamp_max_is_nan() {\n-        let _ = 1.0f32.clamp(3.0, NAN);\n+        let _ = 1.0f32.clamp(3.0, f32::NAN);\n     }\n \n     #[test]"}, {"sha": "9cd60d846a7073dd8610977c5edc9e19e2c5a717", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 91, "deletions": 92, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -943,8 +943,7 @@ impl f64 {\n \n #[cfg(test)]\n mod tests {\n-    use crate::f64;\n-    use crate::f64::*;\n+    use crate::f64::consts;\n     use crate::num::FpCategory as Fp;\n     use crate::num::*;\n \n@@ -955,19 +954,19 @@ mod tests {\n \n     #[test]\n     fn test_min_nan() {\n-        assert_eq!(NAN.min(2.0), 2.0);\n-        assert_eq!(2.0f64.min(NAN), 2.0);\n+        assert_eq!(f64::NAN.min(2.0), 2.0);\n+        assert_eq!(2.0f64.min(f64::NAN), 2.0);\n     }\n \n     #[test]\n     fn test_max_nan() {\n-        assert_eq!(NAN.max(2.0), 2.0);\n-        assert_eq!(2.0f64.max(NAN), 2.0);\n+        assert_eq!(f64::NAN.max(2.0), 2.0);\n+        assert_eq!(2.0f64.max(f64::NAN), 2.0);\n     }\n \n     #[test]\n     fn test_nan() {\n-        let nan: f64 = NAN;\n+        let nan: f64 = f64::NAN;\n         assert!(nan.is_nan());\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n@@ -979,7 +978,7 @@ mod tests {\n \n     #[test]\n     fn test_infinity() {\n-        let inf: f64 = INFINITY;\n+        let inf: f64 = f64::INFINITY;\n         assert!(inf.is_infinite());\n         assert!(!inf.is_finite());\n         assert!(inf.is_sign_positive());\n@@ -991,7 +990,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_infinity() {\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert!(neg_inf.is_infinite());\n         assert!(!neg_inf.is_finite());\n         assert!(!neg_inf.is_sign_positive());\n@@ -1043,9 +1042,9 @@ mod tests {\n \n     #[test]\n     fn test_is_nan() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert!(nan.is_nan());\n         assert!(!0.0f64.is_nan());\n         assert!(!5.3f64.is_nan());\n@@ -1056,9 +1055,9 @@ mod tests {\n \n     #[test]\n     fn test_is_infinite() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert!(!nan.is_infinite());\n         assert!(inf.is_infinite());\n         assert!(neg_inf.is_infinite());\n@@ -1069,9 +1068,9 @@ mod tests {\n \n     #[test]\n     fn test_is_finite() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert!(!nan.is_finite());\n         assert!(!inf.is_finite());\n         assert!(!neg_inf.is_finite());\n@@ -1083,9 +1082,9 @@ mod tests {\n     #[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n     #[test]\n     fn test_is_normal() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         let zero: f64 = 0.0f64;\n         let neg_zero: f64 = -0.0;\n         assert!(!nan.is_normal());\n@@ -1101,9 +1100,9 @@ mod tests {\n     #[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n     #[test]\n     fn test_classify() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         let zero: f64 = 0.0f64;\n         let neg_zero: f64 = -0.0;\n         assert_eq!(nan.classify(), Fp::Nan);\n@@ -1187,59 +1186,59 @@ mod tests {\n \n     #[test]\n     fn test_abs() {\n-        assert_eq!(INFINITY.abs(), INFINITY);\n+        assert_eq!(f64::INFINITY.abs(), f64::INFINITY);\n         assert_eq!(1f64.abs(), 1f64);\n         assert_eq!(0f64.abs(), 0f64);\n         assert_eq!((-0f64).abs(), 0f64);\n         assert_eq!((-1f64).abs(), 1f64);\n-        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f64 / NEG_INFINITY).abs(), 0f64);\n-        assert!(NAN.abs().is_nan());\n+        assert_eq!(f64::NEG_INFINITY.abs(), f64::INFINITY);\n+        assert_eq!((1f64 / f64::NEG_INFINITY).abs(), 0f64);\n+        assert!(f64::NAN.abs().is_nan());\n     }\n \n     #[test]\n     fn test_signum() {\n-        assert_eq!(INFINITY.signum(), 1f64);\n+        assert_eq!(f64::INFINITY.signum(), 1f64);\n         assert_eq!(1f64.signum(), 1f64);\n         assert_eq!(0f64.signum(), 1f64);\n         assert_eq!((-0f64).signum(), -1f64);\n         assert_eq!((-1f64).signum(), -1f64);\n-        assert_eq!(NEG_INFINITY.signum(), -1f64);\n-        assert_eq!((1f64 / NEG_INFINITY).signum(), -1f64);\n-        assert!(NAN.signum().is_nan());\n+        assert_eq!(f64::NEG_INFINITY.signum(), -1f64);\n+        assert_eq!((1f64 / f64::NEG_INFINITY).signum(), -1f64);\n+        assert!(f64::NAN.signum().is_nan());\n     }\n \n     #[test]\n     fn test_is_sign_positive() {\n-        assert!(INFINITY.is_sign_positive());\n+        assert!(f64::INFINITY.is_sign_positive());\n         assert!(1f64.is_sign_positive());\n         assert!(0f64.is_sign_positive());\n         assert!(!(-0f64).is_sign_positive());\n         assert!(!(-1f64).is_sign_positive());\n-        assert!(!NEG_INFINITY.is_sign_positive());\n-        assert!(!(1f64 / NEG_INFINITY).is_sign_positive());\n-        assert!(NAN.is_sign_positive());\n-        assert!(!(-NAN).is_sign_positive());\n+        assert!(!f64::NEG_INFINITY.is_sign_positive());\n+        assert!(!(1f64 / f64::NEG_INFINITY).is_sign_positive());\n+        assert!(f64::NAN.is_sign_positive());\n+        assert!(!(-f64::NAN).is_sign_positive());\n     }\n \n     #[test]\n     fn test_is_sign_negative() {\n-        assert!(!INFINITY.is_sign_negative());\n+        assert!(!f64::INFINITY.is_sign_negative());\n         assert!(!1f64.is_sign_negative());\n         assert!(!0f64.is_sign_negative());\n         assert!((-0f64).is_sign_negative());\n         assert!((-1f64).is_sign_negative());\n-        assert!(NEG_INFINITY.is_sign_negative());\n-        assert!((1f64 / NEG_INFINITY).is_sign_negative());\n-        assert!(!NAN.is_sign_negative());\n-        assert!((-NAN).is_sign_negative());\n+        assert!(f64::NEG_INFINITY.is_sign_negative());\n+        assert!((1f64 / f64::NEG_INFINITY).is_sign_negative());\n+        assert!(!f64::NAN.is_sign_negative());\n+        assert!((-f64::NAN).is_sign_negative());\n     }\n \n     #[test]\n     fn test_mul_add() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_approx_eq!(12.3f64.mul_add(4.5, 6.7), 62.05);\n         assert_approx_eq!((-12.3f64).mul_add(-4.5, -6.7), 48.65);\n         assert_approx_eq!(0.0f64.mul_add(8.9, 1.2), 1.2);\n@@ -1253,9 +1252,9 @@ mod tests {\n \n     #[test]\n     fn test_recip() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(1.0f64.recip(), 1.0);\n         assert_eq!(2.0f64.recip(), 0.5);\n         assert_eq!((-0.4f64).recip(), -2.5);\n@@ -1267,9 +1266,9 @@ mod tests {\n \n     #[test]\n     fn test_powi() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(1.0f64.powi(1), 1.0);\n         assert_approx_eq!((-3.1f64).powi(2), 9.61);\n         assert_approx_eq!(5.9f64.powi(-2), 0.028727);\n@@ -1281,9 +1280,9 @@ mod tests {\n \n     #[test]\n     fn test_powf() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(1.0f64.powf(1.0), 1.0);\n         assert_approx_eq!(3.4f64.powf(4.5), 246.408183);\n         assert_approx_eq!(2.7f64.powf(-3.2), 0.041652);\n@@ -1297,13 +1296,13 @@ mod tests {\n \n     #[test]\n     fn test_sqrt_domain() {\n-        assert!(NAN.sqrt().is_nan());\n-        assert!(NEG_INFINITY.sqrt().is_nan());\n+        assert!(f64::NAN.sqrt().is_nan());\n+        assert!(f64::NEG_INFINITY.sqrt().is_nan());\n         assert!((-1.0f64).sqrt().is_nan());\n         assert_eq!((-0.0f64).sqrt(), -0.0);\n         assert_eq!(0.0f64.sqrt(), 0.0);\n         assert_eq!(1.0f64.sqrt(), 1.0);\n-        assert_eq!(INFINITY.sqrt(), INFINITY);\n+        assert_eq!(f64::INFINITY.sqrt(), f64::INFINITY);\n     }\n \n     #[test]\n@@ -1312,9 +1311,9 @@ mod tests {\n         assert_approx_eq!(2.718282, 1.0f64.exp());\n         assert_approx_eq!(148.413159, 5.0f64.exp());\n \n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n         assert_eq!(inf, inf.exp());\n         assert_eq!(0.0, neg_inf.exp());\n         assert!(nan.exp().is_nan());\n@@ -1325,19 +1324,19 @@ mod tests {\n         assert_eq!(32.0, 5.0f64.exp2());\n         assert_eq!(1.0, 0.0f64.exp2());\n \n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n         assert_eq!(inf, inf.exp2());\n         assert_eq!(0.0, neg_inf.exp2());\n         assert!(nan.exp2().is_nan());\n     }\n \n     #[test]\n     fn test_ln() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_approx_eq!(1.0f64.exp().ln(), 1.0);\n         assert!(nan.ln().is_nan());\n         assert_eq!(inf.ln(), inf);\n@@ -1350,9 +1349,9 @@ mod tests {\n \n     #[test]\n     fn test_log() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(10.0f64.log(10.0), 1.0);\n         assert_approx_eq!(2.3f64.log(3.5), 0.664858);\n         assert_eq!(1.0f64.exp().log(1.0f64.exp()), 1.0);\n@@ -1368,9 +1367,9 @@ mod tests {\n \n     #[test]\n     fn test_log2() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_approx_eq!(10.0f64.log2(), 3.321928);\n         assert_approx_eq!(2.3f64.log2(), 1.201634);\n         assert_approx_eq!(1.0f64.exp().log2(), 1.442695);\n@@ -1384,9 +1383,9 @@ mod tests {\n \n     #[test]\n     fn test_log10() {\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(10.0f64.log10(), 1.0);\n         assert_approx_eq!(2.3f64.log10(), 0.361728);\n         assert_approx_eq!(1.0f64.exp().log10(), 0.434294);\n@@ -1402,9 +1401,9 @@ mod tests {\n     #[test]\n     fn test_to_degrees() {\n         let pi: f64 = consts::PI;\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(0.0f64.to_degrees(), 0.0);\n         assert_approx_eq!((-5.8f64).to_degrees(), -332.315521);\n         assert_eq!(pi.to_degrees(), 180.0);\n@@ -1416,9 +1415,9 @@ mod tests {\n     #[test]\n     fn test_to_radians() {\n         let pi: f64 = consts::PI;\n-        let nan: f64 = NAN;\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n         assert_eq!(0.0f64.to_radians(), 0.0);\n         assert_approx_eq!(154.6f64.to_radians(), 2.698279);\n         assert_approx_eq!((-332.31f64).to_radians(), -5.799903);\n@@ -1433,9 +1432,9 @@ mod tests {\n         assert_eq!(0.0f64.asinh(), 0.0f64);\n         assert_eq!((-0.0f64).asinh(), -0.0f64);\n \n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n@@ -1450,9 +1449,9 @@ mod tests {\n         assert_eq!(1.0f64.acosh(), 0.0f64);\n         assert!(0.999f64.acosh().is_nan());\n \n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n         assert_eq!(inf.acosh(), inf);\n         assert!(neg_inf.acosh().is_nan());\n         assert!(nan.acosh().is_nan());\n@@ -1465,9 +1464,9 @@ mod tests {\n         assert_eq!(0.0f64.atanh(), 0.0f64);\n         assert_eq!((-0.0f64).atanh(), -0.0f64);\n \n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n+        let inf: f64 = f64::INFINITY;\n+        let neg_inf: f64 = f64::NEG_INFINITY;\n+        let nan: f64 = f64::NAN;\n         assert_eq!(1.0f64.atanh(), inf);\n         assert_eq!((-1.0f64).atanh(), neg_inf);\n         assert!(2f64.atanh().atanh().is_nan());\n@@ -1546,13 +1545,13 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn test_clamp_min_is_nan() {\n-        let _ = 1.0f64.clamp(NAN, 1.0);\n+        let _ = 1.0f64.clamp(f64::NAN, 1.0);\n     }\n \n     #[test]\n     #[should_panic]\n     fn test_clamp_max_is_nan() {\n-        let _ = 1.0f64.clamp(3.0, NAN);\n+        let _ = 1.0f64.clamp(3.0, f64::NAN);\n     }\n \n     #[test]"}, {"sha": "dca1fdde4824295f72cd1539d5fa124ca96b3d9e", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 181, "deletions": 6, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -234,15 +234,14 @@ pub struct NulError(usize, Vec<u8>);\n \n /// An error indicating that a nul byte was not in the expected position.\n ///\n-/// The slice used to create a [`CStr`] must have one and only one nul\n-/// byte at the end of the slice.\n+/// The slice used to create a [`CStr`] must have one and only one nul byte,\n+/// positioned at the end.\n ///\n-/// This error is created by the\n-/// [`from_bytes_with_nul`][`CStr::from_bytes_with_nul`] method on\n-/// [`CStr`]. See its documentation for more.\n+/// This error is created by the [`from_bytes_with_nul`] method on [`CStr`].\n+/// See its documentation for more.\n ///\n /// [`CStr`]: struct.CStr.html\n-/// [`CStr::from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n+/// [`from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n ///\n /// # Examples\n ///\n@@ -257,6 +256,32 @@ pub struct FromBytesWithNulError {\n     kind: FromBytesWithNulErrorKind,\n }\n \n+/// An error indicating that a nul byte was not in the expected position.\n+///\n+/// The vector used to create a [`CString`] must have one and only one nul byte,\n+/// positioned at the end.\n+///\n+/// This error is created by the [`from_vec_with_nul`] method on [`CString`].\n+/// See its documentation for more.\n+///\n+/// [`CString`]: struct.CString.html\n+/// [`from_vec_with_nul`]: struct.CString.html#method.from_vec_with_nul\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(cstring_from_vec_with_nul)]\n+/// use std::ffi::{CString, FromVecWithNulError};\n+///\n+/// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"f\\0oo\".to_vec()).unwrap_err();\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+pub struct FromVecWithNulError {\n+    error_kind: FromBytesWithNulErrorKind,\n+    bytes: Vec<u8>,\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n enum FromBytesWithNulErrorKind {\n     InteriorNul(usize),\n@@ -272,6 +297,59 @@ impl FromBytesWithNulError {\n     }\n }\n \n+#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+impl FromVecWithNulError {\n+    /// Returns a slice of [`u8`]s bytes that were attempted to convert to a [`CString`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(cstring_from_vec_with_nul)]\n+    /// use std::ffi::CString;\n+    ///\n+    /// // Some invalid bytes in a vector\n+    /// let bytes = b\"f\\0oo\".to_vec();\n+    ///\n+    /// let value = CString::from_vec_with_nul(bytes.clone());\n+    ///\n+    /// assert_eq!(&bytes[..], value.unwrap_err().as_bytes());\n+    /// ```\n+    ///\n+    /// [`CString`]: struct.CString.html\n+    pub fn as_bytes(&self) -> &[u8] {\n+        &self.bytes[..]\n+    }\n+\n+    /// Returns the bytes that were attempted to convert to a [`CString`].\n+    ///\n+    /// This method is carefully constructed to avoid allocation. It will\n+    /// consume the error, moving out the bytes, so that a copy of the bytes\n+    /// does not need to be made.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(cstring_from_vec_with_nul)]\n+    /// use std::ffi::CString;\n+    ///\n+    /// // Some invalid bytes in a vector\n+    /// let bytes = b\"f\\0oo\".to_vec();\n+    ///\n+    /// let value = CString::from_vec_with_nul(bytes.clone());\n+    ///\n+    /// assert_eq!(bytes, value.unwrap_err().into_bytes());\n+    /// ```\n+    ///\n+    /// [`CString`]: struct.CString.html\n+    pub fn into_bytes(self) -> Vec<u8> {\n+        self.bytes\n+    }\n+}\n+\n /// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n ///\n /// `CString` is just a wrapper over a buffer of bytes with a nul\n@@ -643,6 +721,86 @@ impl CString {\n         let this = mem::ManuallyDrop::new(self);\n         unsafe { ptr::read(&this.inner) }\n     }\n+\n+    /// Converts a `Vec` of `u8` to a `CString` without checking the invariants\n+    /// on the given `Vec`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The given `Vec` **must** have one nul byte as its last element.\n+    /// This means it cannot be empty nor have any other nul byte anywhere else.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(cstring_from_vec_with_nul)]\n+    /// use std::ffi::CString;\n+    /// assert_eq!(\n+    ///     unsafe { CString::from_vec_with_nul_unchecked(b\"abc\\0\".to_vec()) },\n+    ///     unsafe { CString::from_vec_unchecked(b\"abc\".to_vec()) }\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+    pub unsafe fn from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {\n+        Self { inner: v.into_boxed_slice() }\n+    }\n+\n+    /// Attempts to converts a `Vec` of `u8` to a `CString`.\n+    ///\n+    /// Runtime checks are present to ensure there is only one nul byte in the\n+    /// `Vec`, its last element.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If a nul byte is present and not the last element or no nul bytes\n+    /// is present, an error will be returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A successful conversion will produce the same result as [`new`] when\n+    /// called without the ending nul byte.\n+    ///\n+    /// ```\n+    /// #![feature(cstring_from_vec_with_nul)]\n+    /// use std::ffi::CString;\n+    /// assert_eq!(\n+    ///     CString::from_vec_with_nul(b\"abc\\0\".to_vec())\n+    ///         .expect(\"CString::from_vec_with_nul failed\"),\n+    ///     CString::new(b\"abc\".to_vec()).expect(\"CString::new failed\")\n+    /// );\n+    /// ```\n+    ///\n+    /// A incorrectly formatted vector will produce an error.\n+    ///\n+    /// ```\n+    /// #![feature(cstring_from_vec_with_nul)]\n+    /// use std::ffi::{CString, FromVecWithNulError};\n+    /// // Interior nul byte\n+    /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"a\\0bc\".to_vec()).unwrap_err();\n+    /// // No nul byte\n+    /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"abc\".to_vec()).unwrap_err();\n+    /// ```\n+    ///\n+    /// [`new`]: #method.new\n+    #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+    pub fn from_vec_with_nul(v: Vec<u8>) -> Result<Self, FromVecWithNulError> {\n+        let nul_pos = memchr::memchr(0, &v);\n+        match nul_pos {\n+            Some(nul_pos) if nul_pos + 1 == v.len() => {\n+                // SAFETY: We know there is only one nul byte, at the end\n+                // of the vec.\n+                Ok(unsafe { Self::from_vec_with_nul_unchecked(v) })\n+            }\n+            Some(nul_pos) => Err(FromVecWithNulError {\n+                error_kind: FromBytesWithNulErrorKind::InteriorNul(nul_pos),\n+                bytes: v,\n+            }),\n+            None => Err(FromVecWithNulError {\n+                error_kind: FromBytesWithNulErrorKind::NotNulTerminated,\n+                bytes: v,\n+            }),\n+        }\n+    }\n }\n \n // Turns this `CString` into an empty string to prevent\n@@ -976,6 +1134,23 @@ impl fmt::Display for FromBytesWithNulError {\n     }\n }\n \n+#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+impl Error for FromVecWithNulError {}\n+\n+#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+impl fmt::Display for FromVecWithNulError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.error_kind {\n+            FromBytesWithNulErrorKind::InteriorNul(pos) => {\n+                write!(f, \"data provided contains an interior nul byte at pos {}\", pos)\n+            }\n+            FromBytesWithNulErrorKind::NotNulTerminated => {\n+                write!(f, \"data provided is not nul terminated\")\n+            }\n+        }\n+    }\n+}\n+\n impl IntoStringError {\n     /// Consumes this error, returning original [`CString`] which generated the\n     /// error."}, {"sha": "f442d7fde1a5e9464fe0e6116e2dc204930cce39", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -157,6 +157,8 @@\n \n #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n pub use self::c_str::FromBytesWithNulError;\n+#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+pub use self::c_str::FromVecWithNulError;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::c_str::{CStr, CString, IntoStringError, NulError};\n "}, {"sha": "0737008a94c9a57369f85f28433f0f0c38ab0a9c", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -366,7 +366,7 @@ impl<R: Seek> Seek for BufReader<R> {\n             // it should be safe to assume that remainder fits within an i64 as the alternative\n             // means we managed to allocate 8 exbibytes and that's absurd.\n             // But it's not out of the realm of possibility for some weird underlying reader to\n-            // support seeking by i64::min_value() so we need to handle underflow when subtracting\n+            // support seeking by i64::MIN so we need to handle underflow when subtracting\n             // remainder.\n             if let Some(offset) = n.checked_sub(remainder) {\n                 result = self.inner.seek(SeekFrom::Current(offset))?;\n@@ -1268,7 +1268,7 @@ mod tests {\n                         self.pos = self.pos.wrapping_add(n as u64);\n                     }\n                     SeekFrom::End(n) => {\n-                        self.pos = u64::max_value().wrapping_add(n as u64);\n+                        self.pos = u64::MAX.wrapping_add(n as u64);\n                     }\n                 }\n                 Ok(self.pos)\n@@ -1277,11 +1277,11 @@ mod tests {\n \n         let mut reader = BufReader::with_capacity(5, PositionReader { pos: 0 });\n         assert_eq!(reader.fill_buf().ok(), Some(&[0, 1, 2, 3, 4][..]));\n-        assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::max_value() - 5));\n+        assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::MAX - 5));\n         assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n         // the following seek will require two underlying seeks\n         let expected = 9223372036854775802;\n-        assert_eq!(reader.seek(SeekFrom::Current(i64::min_value())).ok(), Some(expected));\n+        assert_eq!(reader.seek(SeekFrom::Current(i64::MIN)).ok(), Some(expected));\n         assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n         // seeking to 0 should empty the buffer.\n         assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(expected));\n@@ -1319,7 +1319,7 @@ mod tests {\n         // The following seek will require two underlying seeks.  The first will\n         // succeed but the second will fail.  This should still invalidate the\n         // buffer.\n-        assert!(reader.seek(SeekFrom::Current(i64::min_value())).is_err());\n+        assert!(reader.seek(SeekFrom::Current(i64::MIN)).is_err());\n         assert_eq!(reader.buffer().len(), 0);\n     }\n "}, {"sha": "f4db5f8145060b42ac13594196462aa440f7a273", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -963,7 +963,7 @@ mod tests {\n     #[cfg(target_pointer_width = \"32\")]\n     fn vec_seek_and_write_past_usize_max() {\n         let mut c = Cursor::new(Vec::new());\n-        c.set_position(<usize>::max_value() as u64 + 1);\n+        c.set_position(usize::MAX as u64 + 1);\n         assert!(c.write_all(&[1, 2, 3]).is_err());\n     }\n "}, {"sha": "b8fa1a7f744d3ca432d5338cb80ad31bf77569ce", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 5, "deletions": 40, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -694,42 +694,6 @@ impl PartialEq for SocketAddrV6 {\n             && self.inner.sin6_scope_id == other.inner.sin6_scope_id\n     }\n }\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialEq<SocketAddrV4> for SocketAddr {\n-    fn eq(&self, other: &SocketAddrV4) -> bool {\n-        match self {\n-            SocketAddr::V4(v4) => v4 == other,\n-            SocketAddr::V6(_) => false,\n-        }\n-    }\n-}\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialEq<SocketAddrV6> for SocketAddr {\n-    fn eq(&self, other: &SocketAddrV6) -> bool {\n-        match self {\n-            SocketAddr::V4(_) => false,\n-            SocketAddr::V6(v6) => v6 == other,\n-        }\n-    }\n-}\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialEq<SocketAddr> for SocketAddrV4 {\n-    fn eq(&self, other: &SocketAddr) -> bool {\n-        match other {\n-            SocketAddr::V4(v4) => self == v4,\n-            SocketAddr::V6(_) => false,\n-        }\n-    }\n-}\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialEq<SocketAddr> for SocketAddrV6 {\n-    fn eq(&self, other: &SocketAddr) -> bool {\n-        match other {\n-            SocketAddr::V4(_) => false,\n-            SocketAddr::V6(v6) => self == v6,\n-        }\n-    }\n-}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Eq for SocketAddrV4 {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1242,12 +1206,8 @@ mod tests {\n         // equality\n         assert_eq!(v4_1, v4_1);\n         assert_eq!(v6_1, v6_1);\n-        assert_eq!(v4_1, SocketAddr::V4(v4_1));\n-        assert_eq!(v6_1, SocketAddr::V6(v6_1));\n         assert_eq!(SocketAddr::V4(v4_1), SocketAddr::V4(v4_1));\n         assert_eq!(SocketAddr::V6(v6_1), SocketAddr::V6(v6_1));\n-        assert!(v4_1 != SocketAddr::V6(v6_1));\n-        assert!(v6_1 != SocketAddr::V4(v4_1));\n         assert!(v4_1 != v4_2);\n         assert!(v6_1 != v6_2);\n \n@@ -1268,5 +1228,10 @@ mod tests {\n         assert!(v6_1 < v6_3);\n         assert!(v4_3 > v4_1);\n         assert!(v6_3 > v6_1);\n+\n+        // compare with an inferred right-hand side\n+        assert_eq!(v4_1, \"224.120.45.1:23456\".parse().unwrap());\n+        assert_eq!(v6_1, \"[2001:db8:f00::1002]:23456\".parse().unwrap());\n+        assert_eq!(SocketAddr::V4(v4_1), \"224.120.45.1:23456\".parse().unwrap());\n     }\n }"}, {"sha": "b496c16a749cf8b3027706bf5ffdcb672411be2e", "filename": "src/libstd/num.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -52,52 +52,43 @@ where\n #[cfg(test)]\n mod tests {\n     use crate::ops::Mul;\n-    use crate::u16;\n-    use crate::u32;\n-    use crate::u64;\n-    use crate::u8;\n-    use crate::usize;\n \n     #[test]\n     fn test_saturating_add_uint() {\n-        use crate::usize::MAX;\n         assert_eq!(3_usize.saturating_add(5_usize), 8_usize);\n-        assert_eq!(3_usize.saturating_add(MAX - 1), MAX);\n-        assert_eq!(MAX.saturating_add(MAX), MAX);\n-        assert_eq!((MAX - 2).saturating_add(1), MAX - 1);\n+        assert_eq!(3_usize.saturating_add(usize::MAX - 1), usize::MAX);\n+        assert_eq!(usize::MAX.saturating_add(usize::MAX), usize::MAX);\n+        assert_eq!((usize::MAX - 2).saturating_add(1), usize::MAX - 1);\n     }\n \n     #[test]\n     fn test_saturating_sub_uint() {\n-        use crate::usize::MAX;\n         assert_eq!(5_usize.saturating_sub(3_usize), 2_usize);\n         assert_eq!(3_usize.saturating_sub(5_usize), 0_usize);\n         assert_eq!(0_usize.saturating_sub(1_usize), 0_usize);\n-        assert_eq!((MAX - 1).saturating_sub(MAX), 0);\n+        assert_eq!((usize::MAX - 1).saturating_sub(usize::MAX), 0);\n     }\n \n     #[test]\n     fn test_saturating_add_int() {\n-        use crate::isize::{MAX, MIN};\n         assert_eq!(3i32.saturating_add(5), 8);\n-        assert_eq!(3isize.saturating_add(MAX - 1), MAX);\n-        assert_eq!(MAX.saturating_add(MAX), MAX);\n-        assert_eq!((MAX - 2).saturating_add(1), MAX - 1);\n+        assert_eq!(3isize.saturating_add(isize::MAX - 1), isize::MAX);\n+        assert_eq!(isize::MAX.saturating_add(isize::MAX), isize::MAX);\n+        assert_eq!((isize::MAX - 2).saturating_add(1), isize::MAX - 1);\n         assert_eq!(3i32.saturating_add(-5), -2);\n-        assert_eq!(MIN.saturating_add(-1), MIN);\n-        assert_eq!((-2isize).saturating_add(-MAX), MIN);\n+        assert_eq!(isize::MIN.saturating_add(-1), isize::MIN);\n+        assert_eq!((-2isize).saturating_add(-isize::MAX), isize::MIN);\n     }\n \n     #[test]\n     fn test_saturating_sub_int() {\n-        use crate::isize::{MAX, MIN};\n         assert_eq!(3i32.saturating_sub(5), -2);\n-        assert_eq!(MIN.saturating_sub(1), MIN);\n-        assert_eq!((-2isize).saturating_sub(MAX), MIN);\n+        assert_eq!(isize::MIN.saturating_sub(1), isize::MIN);\n+        assert_eq!((-2isize).saturating_sub(isize::MAX), isize::MIN);\n         assert_eq!(3i32.saturating_sub(-5), 8);\n-        assert_eq!(3isize.saturating_sub(-(MAX - 1)), MAX);\n-        assert_eq!(MAX.saturating_sub(-MAX), MAX);\n-        assert_eq!((MAX - 2).saturating_sub(-1), MAX - 1);\n+        assert_eq!(3isize.saturating_sub(-(isize::MAX - 1)), isize::MAX);\n+        assert_eq!(isize::MAX.saturating_sub(-isize::MAX), isize::MAX);\n+        assert_eq!((isize::MAX - 2).saturating_sub(-1), isize::MAX - 1);\n     }\n \n     #[test]"}, {"sha": "2250c0d4203ef26a52d4fb2b7b0c442a82a1ba1a", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -609,7 +609,6 @@ mod tests {\n     use crate::sync::{Arc, Condvar, Mutex};\n     use crate::thread;\n     use crate::time::Duration;\n-    use crate::u64;\n \n     #[test]\n     fn smoke() {"}, {"sha": "d6cc811154f11f667bd2abf47c1e1765061f517a", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -2176,8 +2176,7 @@ mod tests {\n     #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn very_long_recv_timeout_wont_panic() {\n         let (tx, rx) = channel::<()>();\n-        let join_handle =\n-            thread::spawn(move || rx.recv_timeout(Duration::from_secs(u64::max_value())));\n+        let join_handle = thread::spawn(move || rx.recv_timeout(Duration::from_secs(u64::MAX)));\n         thread::sleep(Duration::from_secs(1));\n         assert!(tx.send(()).is_ok());\n         assert_eq!(join_handle.join().unwrap(), Ok(()));"}, {"sha": "8478457eabfc2e8d0d5e68eeea7ba273e1f0f6bc", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -107,6 +107,60 @@ use crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n ///\n /// *guard += 1;\n /// ```\n+///\n+/// It is sometimes necessary to manually drop the mutex guard to unlock it\n+/// sooner than the end of the enclosing scope.\n+///\n+/// ```\n+/// use std::sync::{Arc, Mutex};\n+/// use std::thread;\n+///\n+/// const N: usize = 3;\n+///\n+/// let data_mutex = Arc::new(Mutex::new(vec![1, 2, 3, 4]));\n+/// let res_mutex = Arc::new(Mutex::new(0));\n+///\n+/// let mut threads = Vec::with_capacity(N);\n+/// (0..N).for_each(|_| {\n+///     let data_mutex_clone = Arc::clone(&data_mutex);\n+///     let res_mutex_clone = Arc::clone(&res_mutex);\n+///\n+///     threads.push(thread::spawn(move || {\n+///         let mut data = data_mutex_clone.lock().unwrap();\n+///         // This is the result of some important and long-ish work.\n+///         let result = data.iter().fold(0, |acc, x| acc + x * 2);\n+///         data.push(result);\n+///         drop(data);\n+///         *res_mutex_clone.lock().unwrap() += result;\n+///     }));\n+/// });\n+///\n+/// let mut data = data_mutex.lock().unwrap();\n+/// // This is the result of some important and long-ish work.\n+/// let result = data.iter().fold(0, |acc, x| acc + x * 2);\n+/// data.push(result);\n+/// // We drop the `data` explicitly because it's not necessary anymore and the\n+/// // thread still has work to do. This allow other threads to start working on\n+/// // the data immediately, without waiting for the rest of the unrelated work\n+/// // to be done here.\n+/// //\n+/// // It's even more important here than in the threads because we `.join` the\n+/// // threads after that. If we had not dropped the mutex guard, a thread could\n+/// // be waiting forever for it, causing a deadlock.\n+/// drop(data);\n+/// // Here the mutex guard is not assigned to a variable and so, even if the\n+/// // scope does not end after this line, the mutex is still released: there is\n+/// // no deadlock.\n+/// *res_mutex.lock().unwrap() += result;\n+///\n+/// threads.into_iter().for_each(|thread| {\n+///     thread\n+///         .join()\n+///         .expect(\"The thread creating or execution failed !\")\n+/// });\n+///\n+/// assert_eq!(*res_mutex.lock().unwrap(), 800);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"mutex_type\")]\n pub struct Mutex<T: ?Sized> {"}, {"sha": "dabdc0c9b510af2dbfda6c7b46ded950d0a4fe49", "filename": "src/libstd/sys/cloudabi/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -42,7 +42,7 @@ impl Condvar {\n             let ret = abi::condvar_signal(\n                 condvar as *mut abi::condvar,\n                 abi::scope::PRIVATE,\n-                abi::nthreads::max_value(),\n+                abi::nthreads::MAX,\n             );\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to broadcast on condition variable\");\n         }"}, {"sha": "132e579b3a5cbcd38d3e698af47bd3903359f5ac", "filename": "src/libstd/sys/hermit/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -35,7 +35,7 @@ impl Condvar {\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         let nanos = dur.as_nanos();\n-        let nanos = cmp::min(i64::max_value() as u128, nanos);\n+        let nanos = cmp::min(i64::MAX as u128, nanos);\n \n         // add current task to the wait queue\n         let _ = abi::add_queue(self.id(), nanos as i64);"}, {"sha": "9e588c4265ac2199784ba0393e8a43c850904ca0", "filename": "src/libstd/sys/hermit/net.rs", "status": "modified", "additions": 85, "deletions": 46, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1,10 +1,13 @@\n use crate::convert::TryFrom;\n use crate::fmt;\n use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n-use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n+use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::str;\n+use crate::sync::Arc;\n use crate::sys::hermit::abi;\n+use crate::sys::hermit::abi::IpAddress::{Ipv4, Ipv6};\n use crate::sys::{unsupported, Void};\n+use crate::sys_common::AsInner;\n use crate::time::Duration;\n \n /// Checks whether the HermitCore's socket interface has been started already, and\n@@ -17,14 +20,33 @@ pub fn init() -> io::Result<()> {\n     Ok(())\n }\n \n-pub struct TcpStream(abi::Handle);\n+#[derive(Debug, Clone)]\n+pub struct Socket(abi::Handle);\n+\n+impl AsInner<abi::Handle> for Socket {\n+    fn as_inner(&self) -> &abi::Handle {\n+        &self.0\n+    }\n+}\n+\n+impl Drop for Socket {\n+    fn drop(&mut self) {\n+        let _ = abi::tcpstream::close(self.0);\n+    }\n+}\n+\n+// Arc is used to count the number of used sockets.\n+// Only if all sockets are released, the drop\n+// method will close the socket.\n+#[derive(Clone)]\n+pub struct TcpStream(Arc<Socket>);\n \n impl TcpStream {\n     pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n         let addr = addr?;\n \n         match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n-            Ok(handle) => Ok(TcpStream(handle)),\n+            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n             _ => {\n                 Err(io::Error::new(ErrorKind::Other, \"Unable to initiate a connection on a socket\"))\n             }\n@@ -37,39 +59,42 @@ impl TcpStream {\n             saddr.port(),\n             Some(duration.as_millis() as u64),\n         ) {\n-            Ok(handle) => Ok(TcpStream(handle)),\n+            Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n             _ => {\n                 Err(io::Error::new(ErrorKind::Other, \"Unable to initiate a connection on a socket\"))\n             }\n         }\n     }\n \n     pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n-        abi::tcpstream::set_read_timeout(self.0, duration.map(|d| d.as_millis() as u64))\n+        abi::tcpstream::set_read_timeout(*self.0.as_inner(), duration.map(|d| d.as_millis() as u64))\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n     }\n \n     pub fn set_write_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n-        abi::tcpstream::set_write_timeout(self.0, duration.map(|d| d.as_millis() as u64))\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n+        abi::tcpstream::set_write_timeout(\n+            *self.0.as_inner(),\n+            duration.map(|d| d.as_millis() as u64),\n+        )\n+        .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        let duration = abi::tcpstream::get_read_timeout(self.0)\n+        let duration = abi::tcpstream::get_read_timeout(*self.0.as_inner())\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to determine timeout value\"))?;\n \n         Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        let duration = abi::tcpstream::get_write_timeout(self.0)\n+        let duration = abi::tcpstream::get_write_timeout(*self.0.as_inner())\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to determine timeout value\"))?;\n \n         Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        abi::tcpstream::peek(self.0, buf)\n+        abi::tcpstream::peek(*self.0.as_inner(), buf)\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"set_nodelay failed\"))\n     }\n \n@@ -81,18 +106,11 @@ impl TcpStream {\n         let mut size: usize = 0;\n \n         for i in ioslice.iter_mut() {\n-            let mut pos: usize = 0;\n-\n-            while pos < i.len() {\n-                let ret = abi::tcpstream::read(self.0, &mut i[pos..])\n-                    .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to read on socket\"))?;\n-\n-                if ret == 0 {\n-                    return Ok(size);\n-                } else {\n-                    size += ret;\n-                    pos += ret;\n-                }\n+            let ret = abi::tcpstream::read(*self.0.as_inner(), &mut i[0..])\n+                .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to read on socket\"))?;\n+\n+            if ret != 0 {\n+                size += ret;\n             }\n         }\n \n@@ -112,7 +130,7 @@ impl TcpStream {\n         let mut size: usize = 0;\n \n         for i in ioslice.iter() {\n-            size += abi::tcpstream::write(self.0, i)\n+            size += abi::tcpstream::write(*self.0.as_inner(), i)\n                 .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to write on socket\"))?;\n         }\n \n@@ -125,42 +143,53 @@ impl TcpStream {\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        Err(io::Error::new(ErrorKind::Other, \"peer_addr isn't supported\"))\n+        let (ipaddr, port) = abi::tcpstream::peer_addr(*self.0.as_inner())\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"peer_addr failed\"))?;\n+\n+        let saddr = match ipaddr {\n+            Ipv4(ref addr) => SocketAddr::new(\n+                IpAddr::V4(Ipv4Addr::new(addr.0[0], addr.0[1], addr.0[2], addr.0[3])),\n+                port,\n+            ),\n+            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n+            _ => {\n+                return Err(io::Error::new(ErrorKind::Other, \"peer_addr failed\"));\n+            }\n+        };\n+\n+        Ok(saddr)\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n         Err(io::Error::new(ErrorKind::Other, \"socket_addr isn't supported\"))\n     }\n \n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        abi::tcpstream::shutdown(self.0, how as i32)\n+        abi::tcpstream::shutdown(*self.0.as_inner(), how as i32)\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to shutdown socket\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n-        let handle = abi::tcpstream::duplicate(self.0)\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to duplicate stream\"))?;\n-\n-        Ok(TcpStream(handle))\n+        Ok(self.clone())\n     }\n \n     pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n-        abi::tcpstream::set_nodelay(self.0, mode)\n+        abi::tcpstream::set_nodelay(*self.0.as_inner(), mode)\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"set_nodelay failed\"))\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n-        abi::tcpstream::nodelay(self.0)\n+        abi::tcpstream::nodelay(*self.0.as_inner())\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"nodelay failed\"))\n     }\n \n     pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n-        abi::tcpstream::set_tll(self.0, tll)\n+        abi::tcpstream::set_tll(*self.0.as_inner(), tll)\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to set TTL\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        abi::tcpstream::get_tll(self.0)\n+        abi::tcpstream::get_tll(*self.0.as_inner())\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to get TTL\"))\n     }\n \n@@ -169,40 +198,50 @@ impl TcpStream {\n     }\n \n     pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n-        abi::tcpstream::set_nonblocking(self.0, mode)\n+        abi::tcpstream::set_nonblocking(*self.0.as_inner(), mode)\n             .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to set blocking mode\"))\n     }\n }\n \n-impl Drop for TcpStream {\n-    fn drop(&mut self) {\n-        let _ = abi::tcpstream::close(self.0);\n-    }\n-}\n-\n impl fmt::Debug for TcpStream {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         Ok(())\n     }\n }\n \n-pub struct TcpListener(abi::Handle);\n+#[derive(Clone)]\n+pub struct TcpListener(SocketAddr);\n \n impl TcpListener {\n-    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+    pub fn bind(addr: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n+        let addr = addr?;\n+\n+        Ok(TcpListener(*addr))\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Ok(self.0)\n     }\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        let (handle, ipaddr, port) = abi::tcplistener::accept(self.0.port())\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"accept failed\"))?;\n+        let saddr = match ipaddr {\n+            Ipv4(ref addr) => SocketAddr::new(\n+                IpAddr::V4(Ipv4Addr::new(addr.0[0], addr.0[1], addr.0[2], addr.0[3])),\n+                port,\n+            ),\n+            Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n+            _ => {\n+                return Err(io::Error::new(ErrorKind::Other, \"accept failed\"));\n+            }\n+        };\n+\n+        Ok((TcpStream(Arc::new(Socket(handle))), saddr))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpListener> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Ok(self.clone())\n     }\n \n     pub fn set_ttl(&self, _: u32) -> io::Result<()> {"}, {"sha": "ea05ee3d7cedf1894673e233de16d47fa0bfbfa4", "filename": "src/libstd/sys/unix/android.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -95,7 +95,7 @@ pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n         match ftruncate64.get() {\n             Some(f) => cvt_r(|| f(fd, size as i64)).map(drop),\n             None => {\n-                if size > i32::max_value() as u64 {\n+                if size > i32::MAX as u64 {\n                     Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot truncate >2GB\"))\n                 } else {\n                     cvt_r(|| ftruncate(fd, size as i32)).map(drop)"}, {"sha": "9f1847943f3262e63cfd43464e2aa91d65853920", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -10,14 +10,10 @@ unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::max_value(), tv_nsec: 1_000_000_000 - 1 };\n+    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n \n fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n-    if value > <libc::time_t>::max_value() as u64 {\n-        <libc::time_t>::max_value()\n-    } else {\n-        value as libc::time_t\n-    }\n+    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n }\n \n impl Condvar {"}, {"sha": "cd24605ec7ab724650fd971ba2ce96aec7c0085a", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1090,7 +1090,7 @@ impl<'a> Iterator for Incoming<'a> {\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::max_value(), None)\n+        (usize::MAX, None)\n     }\n }\n "}, {"sha": "c481ca8961f86192a3629e4660690bff33b141e9", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -23,11 +23,7 @@ fn max_len() -> usize {\n     // intentionally showing odd behavior by rejecting any read with a size\n     // larger than or equal to INT_MAX. To handle both of these the read\n     // size is capped on both platforms.\n-    if cfg!(target_os = \"macos\") {\n-        <c_int>::max_value() as usize - 1\n-    } else {\n-        <ssize_t>::max_value() as usize\n-    }\n+    if cfg!(target_os = \"macos\") { <c_int>::MAX as usize - 1 } else { <ssize_t>::MAX as usize }\n }\n \n impl FileDesc {\n@@ -58,7 +54,7 @@ impl FileDesc {\n             libc::readv(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n             )\n         })?;\n         Ok(ret as usize)\n@@ -115,7 +111,7 @@ impl FileDesc {\n             libc::writev(\n                 self.fd,\n                 bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::max_value() as usize) as c_int,\n+                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n             )\n         })?;\n         Ok(ret as usize)"}, {"sha": "29cdbf05354fbe353ba382332c54d8f927bb20a1", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -1196,7 +1196,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     let mut written = 0u64;\n     while written < len {\n         let copy_result = if has_copy_file_range {\n-            let bytes_to_copy = cmp::min(len - written, usize::max_value() as u64) as usize;\n+            let bytes_to_copy = cmp::min(len - written, usize::MAX as u64) as usize;\n             let copy_result = unsafe {\n                 // We actually don't have to adjust the offsets,\n                 // because copy_file_range adjusts the file offset automatically"}, {"sha": "3717c660b575d6f1c9e2d353be65fdfa6be3212f", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395256a5dd74ccef046083d6e025a6d046379040/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=395256a5dd74ccef046083d6e025a6d046379040", "patch": "@@ -148,7 +148,7 @@ impl Socket {\n                 timeout = 1;\n             }\n \n-            let timeout = cmp::min(timeout, c_int::max_value() as u64) as c_int;\n+            let timeout = cmp::min(timeout, c_int::MAX as u64) as c_int;\n \n             match unsafe { libc::poll(&mut pollfd, 1, timeout) } {\n                 -1 => {\n@@ -283,8 +283,8 @@ impl Socket {\n                     ));\n                 }\n \n-                let secs = if dur.as_secs() > libc::time_t::max_value() as u64 {\n-                    libc::time_t::max_value()\n+                let secs = if dur.as_secs() > libc::time_t::MAX as u64 {\n+                    libc::time_t::MAX\n                 } else {\n                     dur.as_secs() as libc::time_t\n                 };"}]}