{"sha": "89138a67dc2b9f7ac5363bad114984cb35033158", "node_id": "C_kwDOAAsO6NoAKDg5MTM4YTY3ZGMyYjlmN2FjNTM2M2JhZDExNDk4NGNiMzUwMzMxNTg", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-10T22:25:18Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:23Z"}, "message": "Add more top-level comments", "tree": {"sha": "c241a6158224c8d8b85ba2049a0a573e7928d2e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c241a6158224c8d8b85ba2049a0a573e7928d2e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89138a67dc2b9f7ac5363bad114984cb35033158", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRDwACgkQGBtJ+fOP\nM3RSFgv/cRNPLhyd0XlJku3pkQtZfX7PKFvLk2SMv1ZnRGBrbvTvJSPTuDcZ4Zg0\n4q+sR3LIqwN4VdAONA35VbT3feGIn8ucXUoGKbJ96ne8Nl2WAkhQxBpdN7cadjl8\nT4WmI/OcORxKA8yiT5vXiJDLkhtbnLV61Ljiik5BPqp8QjnqiHFEMNjOfxbDTYQ8\nWT3fAuI9XN15DZHAlDogEAnIX9lZ5j9HYLFpfYjZeg1aVMiQ1ZAjhiJCgu+vKRjI\npdtYOjvucIDIFNlNbgcdJoNEmmWyaD3rWPf/f94wNnqJtZeYRXNOVMzgM4dtMW4n\n4DxcAFOKZ1KKTnLvxxQSE++5SWLjnvkICpA8/gzdTZuBaRIK9gDyOFscrWseBdmy\noXdvUzW21GkAqFGg6XMRPrbJF0+BH0jAVp6KwUUun98Q90Uh3AHwGrpVos4MeZEH\nZ8nM0a5kvvX5FVJglsSG0WK0GK7pZbaU2RaC6uWd1V0Rg6oGRVZNsgcfP0SQUr0u\nxdSL6SW4\n=L0Ry\n-----END PGP SIGNATURE-----", "payload": "tree c241a6158224c8d8b85ba2049a0a573e7928d2e0\nparent f729f289255bcc8d1bfad614ac74bc51d411826a\nauthor Andy Wang <cbeuw.andy@gmail.com> 1652221518 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539323 +0100\n\nAdd more top-level comments\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89138a67dc2b9f7ac5363bad114984cb35033158", "html_url": "https://github.com/rust-lang/rust/commit/89138a67dc2b9f7ac5363bad114984cb35033158", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89138a67dc2b9f7ac5363bad114984cb35033158/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f729f289255bcc8d1bfad614ac74bc51d411826a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f729f289255bcc8d1bfad614ac74bc51d411826a", "html_url": "https://github.com/rust-lang/rust/commit/f729f289255bcc8d1bfad614ac74bc51d411826a"}], "stats": {"total": 32, "additions": 32, "deletions": 0}, "files": [{"sha": "fc2e220e5e51f1d4f521b7cdd24bf399555b5094", "filename": "src/weak_memory.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/89138a67dc2b9f7ac5363bad114984cb35033158/src%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89138a67dc2b9f7ac5363bad114984cb35033158/src%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fweak_memory.rs?ref=89138a67dc2b9f7ac5363bad114984cb35033158", "patch": "@@ -1,6 +1,34 @@\n //! Implementation of C++11-consistent weak memory emulation using store buffers\n //! based on Dynamic Race Detection for C++ (\"the paper\"):\n //! https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf\n+//! \n+//! This implementation will never generate weak memory behaviours forbidden by the C++11 model,\n+//! but it is incapable of producing all possible weak behaviours allowed by the model. There are\n+//! certain weak behaviours observable on real hardware but not while using this.\n+//! \n+//! Note that this implementation does not take into account of C++20's memory model revision to SC accesses\n+//! and fences introduced by P0668 (https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html).\n+//! This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20\n+//! disallows.\n+//! \n+//! Rust follows the full C++20 memory model (except for the Consume ordering). It is therefore\n+//! possible for this implementation to generate behaviours never observable when the same program is compiled and\n+//! run natively. Unfortunately, no literature exists at the time of writing which proposes an implementable and C++20-compatible\n+//! relaxed memory model that supports all atomic operation existing in Rust. The closest one is\n+//! A Promising Semantics for Relaxed-Memory Concurrency by Jeehoon Kang et al. (https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf)\n+//! However, this model lacks SC accesses and is therefore unusable by Miri (SC accesses are everywhere in library code).\n+//! \n+//! If you find anything that proposes a relaxed memory model that is C++20-consistent, supports all orderings Rust's atomic accesses\n+//! and fences accept, and is implementable (with operational semanitcs), please open a GitHub issue!\n+//! \n+//! One characteristic of this implementation, in contrast to some other notable operational models such as ones proposed in\n+//! Taming Release-Acquire Consistency by Ori Lahav et al. (https://plv.mpi-sws.org/sra/paper.pdf) or Promising Semantics noted above,\n+//! is that this implementation does not require each thread to hold an isolated view of the entire memory. Here, store buffers are per-location\n+//! and shared across all threads. This is more memory efficient but does require store elements (representing writes to a location) to record\n+//! information about reads, whereas in the other two models it is the other way round: reads points to the write it got its value from.\n+//! Additionally, writes in our implementation do not have globally unique timestamps attached. In the other two models this timestamp is\n+//! used to make sure a value in a thread's view is not overwritten by a write that occured earlier than the one in the existing view.\n+//! In our implementation, this is detected using read information attached to store elements, as there is no data strucutre representing reads.\n \n // Our and the author's own implementation (tsan11) of the paper have some deviations from the provided operational semantics in \u00a75.3:\n // 1. In the operational semantics, store elements keep a copy of the atomic object's vector clock (AtomicCellClocks::sync_vector in miri),\n@@ -40,6 +68,10 @@ use crate::{\n \n pub type AllocExtra = StoreBufferAlloc;\n \n+// Each store buffer must be bounded otherwise it will grow indefinitely.\n+// However, bounding the store buffer means restricting the amount of weak\n+// behaviours observable. The author picked 128 as a good tradeoff\n+// so we follow them here.\n const STORE_BUFFER_LIMIT: usize = 128;\n \n #[derive(Debug, Clone)]"}]}