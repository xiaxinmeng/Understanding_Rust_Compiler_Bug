{"sha": "9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ODRhYjlmMzk0Y2ZmNWE2YzdhOWQxZTRmMDlmMzc1YTRlMGQzODg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-26T22:13:48Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-27T08:32:00Z"}, "message": "Move html highlightig to a separate module", "tree": {"sha": "769256efcfe1f86c7c7f9b5b0520185967c20934", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/769256efcfe1f86c7c7f9b5b0520185967c20934"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388", "html_url": "https://github.com/rust-lang/rust/commit/9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "995c46024b6d3a10ee781a09ed16ef1f6de95e58", "url": "https://api.github.com/repos/rust-lang/rust/commits/995c46024b6d3a10ee781a09ed16ef1f6de95e58", "html_url": "https://github.com/rust-lang/rust/commit/995c46024b6d3a10ee781a09ed16ef1f6de95e58"}], "stats": {"total": 204, "additions": 107, "deletions": 97}, "files": [{"sha": "4e95b9ce5630d772e2595b98f4df4651dcacafad", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 3, "deletions": 97, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388", "patch": "@@ -1,9 +1,9 @@\n //! FIXME: write short doc here\n \n mod highlight;\n+mod html;\n \n use hir::{Name, Semantics};\n-use ra_db::SourceDatabase;\n use ra_ide_db::{\n     defs::{classify_name, NameDefinition},\n     RootDatabase,\n@@ -19,6 +19,8 @@ use crate::{references::classify_name_ref, FileId};\n \n pub use highlight::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n \n+pub(crate) use html::highlight_as_html;\n+\n #[derive(Debug)]\n pub struct HighlightedRange {\n     pub range: TextRange,\n@@ -257,69 +259,6 @@ fn highlight_node(\n     }\n }\n \n-pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: bool) -> String {\n-    let parse = db.parse(file_id);\n-\n-    fn rainbowify(seed: u64) -> String {\n-        use rand::prelude::*;\n-        let mut rng = SmallRng::seed_from_u64(seed);\n-        format!(\n-            \"hsl({h},{s}%,{l}%)\",\n-            h = rng.gen_range::<u16, _, _>(0, 361),\n-            s = rng.gen_range::<u16, _, _>(42, 99),\n-            l = rng.gen_range::<u16, _, _>(40, 91),\n-        )\n-    }\n-\n-    let mut ranges = highlight(db, file_id, None);\n-    ranges.sort_by_key(|it| it.range.start());\n-    // quick non-optimal heuristic to intersect token ranges and highlighted ranges\n-    let mut frontier = 0;\n-    let mut could_intersect: Vec<&HighlightedRange> = Vec::new();\n-\n-    let mut buf = String::new();\n-    buf.push_str(&STYLE);\n-    buf.push_str(\"<pre><code>\");\n-    let tokens = parse.tree().syntax().descendants_with_tokens().filter_map(|it| it.into_token());\n-    for token in tokens {\n-        could_intersect.retain(|it| token.text_range().start() <= it.range.end());\n-        while let Some(r) = ranges.get(frontier) {\n-            if r.range.start() <= token.text_range().end() {\n-                could_intersect.push(r);\n-                frontier += 1;\n-            } else {\n-                break;\n-            }\n-        }\n-        let text = html_escape(&token.text());\n-        let ranges = could_intersect\n-            .iter()\n-            .filter(|it| token.text_range().is_subrange(&it.range))\n-            .collect::<Vec<_>>();\n-        if ranges.is_empty() {\n-            buf.push_str(&text);\n-        } else {\n-            let classes = ranges\n-                .iter()\n-                .map(|it| it.highlight.to_string().replace('.', \" \"))\n-                .collect::<Vec<_>>()\n-                .join(\" \");\n-            let binding_hash = ranges.first().and_then(|x| x.binding_hash);\n-            let color = match (rainbow, binding_hash) {\n-                (true, Some(hash)) => format!(\n-                    \" data-binding-hash=\\\"{}\\\" style=\\\"color: {};\\\"\",\n-                    hash,\n-                    rainbowify(hash)\n-                ),\n-                _ => \"\".into(),\n-            };\n-            buf.push_str(&format!(\"<span class=\\\"{}\\\"{}>{}</span>\", classes, color, text));\n-        }\n-    }\n-    buf.push_str(\"</code></pre>\");\n-    buf\n-}\n-\n fn highlight_name(db: &RootDatabase, def: NameDefinition) -> Highlight {\n     match def {\n         NameDefinition::Macro(_) => HighlightTag::Macro,\n@@ -348,39 +287,6 @@ fn highlight_name(db: &RootDatabase, def: NameDefinition) -> Highlight {\n     .into()\n }\n \n-//FIXME: like, real html escaping\n-fn html_escape(text: &str) -> String {\n-    text.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n-}\n-\n-const STYLE: &str = \"\n-<style>\n-body                { margin: 0; }\n-pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n-\n-.comment            { color: #7F9F7F; }\n-.string             { color: #CC9393; }\n-.field              { color: #94BFF3; }\n-.function           { color: #93E0E3; }\n-.parameter          { color: #94BFF3; }\n-.text               { color: #DCDCCC; }\n-.type               { color: #7CB8BB; }\n-.type.builtin       { color: #8CD0D3; }\n-.type.param         { color: #20999D; }\n-.attribute          { color: #94BFF3; }\n-.literal            { color: #BFEBBF; }\n-.literal.numeric    { color: #6A8759; }\n-.macro              { color: #94BFF3; }\n-.module             { color: #AFD8AF; }\n-.variable           { color: #DCDCCC; }\n-.variable.mut       { color: #DCDCCC; text-decoration: underline; }\n-\n-.keyword            { color: #F0DFAF; }\n-.keyword.unsafe     { color: #DFAF8F; }\n-.keyword.control    { color: #F0DFAF; font-weight: bold; }\n-</style>\n-\";\n-\n #[cfg(test)]\n mod tests {\n     use std::fs;"}, {"sha": "210d9a57baea49cdf378a6d11e8685ec97d5f735", "filename": "crates/ra_ide/src/syntax_highlighting/html.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=9784ab9f394cff5a6c7a9d1e4f09f375a4e0d388", "patch": "@@ -0,0 +1,104 @@\n+//! Renders a bit of code as HTML.\n+\n+use ra_db::SourceDatabase;\n+use ra_syntax::AstNode;\n+\n+use crate::{FileId, HighlightedRange, RootDatabase};\n+\n+use super::highlight;\n+\n+pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: bool) -> String {\n+    let parse = db.parse(file_id);\n+\n+    fn rainbowify(seed: u64) -> String {\n+        use rand::prelude::*;\n+        let mut rng = SmallRng::seed_from_u64(seed);\n+        format!(\n+            \"hsl({h},{s}%,{l}%)\",\n+            h = rng.gen_range::<u16, _, _>(0, 361),\n+            s = rng.gen_range::<u16, _, _>(42, 99),\n+            l = rng.gen_range::<u16, _, _>(40, 91),\n+        )\n+    }\n+\n+    let mut ranges = highlight(db, file_id, None);\n+    ranges.sort_by_key(|it| it.range.start());\n+    // quick non-optimal heuristic to intersect token ranges and highlighted ranges\n+    let mut frontier = 0;\n+    let mut could_intersect: Vec<&HighlightedRange> = Vec::new();\n+\n+    let mut buf = String::new();\n+    buf.push_str(&STYLE);\n+    buf.push_str(\"<pre><code>\");\n+    let tokens = parse.tree().syntax().descendants_with_tokens().filter_map(|it| it.into_token());\n+    for token in tokens {\n+        could_intersect.retain(|it| token.text_range().start() <= it.range.end());\n+        while let Some(r) = ranges.get(frontier) {\n+            if r.range.start() <= token.text_range().end() {\n+                could_intersect.push(r);\n+                frontier += 1;\n+            } else {\n+                break;\n+            }\n+        }\n+        let text = html_escape(&token.text());\n+        let ranges = could_intersect\n+            .iter()\n+            .filter(|it| token.text_range().is_subrange(&it.range))\n+            .collect::<Vec<_>>();\n+        if ranges.is_empty() {\n+            buf.push_str(&text);\n+        } else {\n+            let classes = ranges\n+                .iter()\n+                .map(|it| it.highlight.to_string().replace('.', \" \"))\n+                .collect::<Vec<_>>()\n+                .join(\" \");\n+            let binding_hash = ranges.first().and_then(|x| x.binding_hash);\n+            let color = match (rainbow, binding_hash) {\n+                (true, Some(hash)) => format!(\n+                    \" data-binding-hash=\\\"{}\\\" style=\\\"color: {};\\\"\",\n+                    hash,\n+                    rainbowify(hash)\n+                ),\n+                _ => \"\".into(),\n+            };\n+            buf.push_str(&format!(\"<span class=\\\"{}\\\"{}>{}</span>\", classes, color, text));\n+        }\n+    }\n+    buf.push_str(\"</code></pre>\");\n+    buf\n+}\n+\n+//FIXME: like, real html escaping\n+fn html_escape(text: &str) -> String {\n+    text.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n+}\n+\n+const STYLE: &str = \"\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.comment            { color: #7F9F7F; }\n+.string             { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.type.builtin       { color: #8CD0D3; }\n+.type.param         { color: #20999D; }\n+.attribute          { color: #94BFF3; }\n+.literal            { color: #BFEBBF; }\n+.literal.numeric    { color: #6A8759; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.variable           { color: #DCDCCC; }\n+.variable.mut       { color: #DCDCCC; text-decoration: underline; }\n+\n+.keyword            { color: #F0DFAF; }\n+.keyword.unsafe     { color: #DFAF8F; }\n+.keyword.control    { color: #F0DFAF; font-weight: bold; }\n+</style>\n+\";"}]}