{"sha": "8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZGRhMGU3YjE2NDAwOWQ2YzAzYmIzZDRiZTYwM2ZiMzhhZDJlMmE=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-10-31T08:43:20Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-10-31T08:43:20Z"}, "message": "Merge branch 'master' into feature/themes", "tree": {"sha": "744cf81075d394e2f9c06afb07642a2601800dda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/744cf81075d394e2f9c06afb07642a2601800dda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "html_url": "https://github.com/rust-lang/rust/commit/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49562d36b97ddde34cf7585a8c2e8f232519b657", "url": "https://api.github.com/repos/rust-lang/rust/commits/49562d36b97ddde34cf7585a8c2e8f232519b657", "html_url": "https://github.com/rust-lang/rust/commit/49562d36b97ddde34cf7585a8c2e8f232519b657"}, {"sha": "d067afb064a7fa67b172abf561b7d80740cd6f18", "url": "https://api.github.com/repos/rust-lang/rust/commits/d067afb064a7fa67b172abf561b7d80740cd6f18", "html_url": "https://github.com/rust-lang/rust/commit/d067afb064a7fa67b172abf561b7d80740cd6f18"}], "stats": {"total": 7704, "additions": 4949, "deletions": 2755}, "files": [{"sha": "fdacd82a70e36ac564e7322f74198de98850dd76", "filename": "Cargo.lock", "status": "modified", "additions": 119, "deletions": 72, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -108,8 +108,8 @@ version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -123,55 +123,67 @@ name = \"cfg-if\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"chalk-derive\"\n+version = \"0.1.0\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n+dependencies = [\n+ \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"chalk-engine\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git#13303bb0067c6ed0572322080ae367ee38f9e7c9\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n dependencies = [\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git#13303bb0067c6ed0572322080ae367ee38f9e7c9\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n dependencies = [\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-macros\"\n version = \"0.1.1\"\n-source = \"git+https://github.com/rust-lang/chalk.git#13303bb0067c6ed0572322080ae367ee38f9e7c9\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git#13303bb0067c6ed0572322080ae367ee38f9e7c9\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n dependencies = [\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git#13303bb0067c6ed0572322080ae367ee38f9e7c9\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809#8314f2fcec8582a58c24b638f1a259d4145a0809\"\n dependencies = [\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -288,7 +300,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -413,7 +425,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.1.12\"\n+version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -443,7 +455,7 @@ name = \"heck\"\n version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"unicode-segmentation 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-segmentation 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -501,7 +513,7 @@ dependencies = [\n  \"console 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_yaml 0.8.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"uuid 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -517,7 +529,7 @@ dependencies = [\n \n [[package]]\n name = \"itertools\"\n-version = \"0.8.0\"\n+version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"either 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -624,7 +636,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-channel 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -634,7 +646,7 @@ version = \"0.61.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_repr 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -790,7 +802,7 @@ dependencies = [\n  \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"redox_syscall 0.1.56 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -811,7 +823,7 @@ dependencies = [\n  \"proc-macro-hack 0.5.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -845,7 +857,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -903,7 +915,7 @@ name = \"ra_assists\"\n version = \"0.1.0\"\n dependencies = [\n  \"format-buf 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n  \"ra_fmt 0.1.0\",\n@@ -970,7 +982,7 @@ dependencies = [\n name = \"ra_fmt\"\n version = \"0.1.0\"\n dependencies = [\n- \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_syntax 0.1.0\",\n ]\n \n@@ -979,9 +991,9 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n- \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -991,6 +1003,27 @@ dependencies = [\n  \"ra_arena 0.1.0\",\n  \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n+ \"ra_hir_def 0.1.0\",\n+ \"ra_hir_expand 0.1.0\",\n+ \"ra_mbe 0.1.0\",\n+ \"ra_prof 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"ra_tt 0.1.0\",\n+ \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n+]\n+\n+[[package]]\n+name = \"ra_hir_def\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_arena 0.1.0\",\n+ \"ra_cfg 0.1.0\",\n+ \"ra_db 0.1.0\",\n+ \"ra_hir_expand 0.1.0\",\n  \"ra_mbe 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n@@ -1000,14 +1033,27 @@ dependencies = [\n  \"test_utils 0.1.0\",\n ]\n \n+[[package]]\n+name = \"ra_hir_expand\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_arena 0.1.0\",\n+ \"ra_db 0.1.0\",\n+ \"ra_mbe 0.1.0\",\n+ \"ra_prof 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"ra_tt 0.1.0\",\n+]\n+\n [[package]]\n name = \"ra_ide_api\"\n version = \"0.1.0\"\n dependencies = [\n  \"format-buf 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fst 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1049,7 +1095,7 @@ dependencies = [\n  \"ra_vfs_glob 0.1.0\",\n  \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n@@ -1065,7 +1111,7 @@ dependencies = [\n  \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n \n@@ -1081,7 +1127,7 @@ name = \"ra_prof\"\n version = \"0.1.0\"\n dependencies = [\n  \"backtrace 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jemalloc-ctl 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jemallocator 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1097,7 +1143,7 @@ dependencies = [\n  \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1106,7 +1152,7 @@ name = \"ra_syntax\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n@@ -1180,7 +1226,7 @@ name = \"rand\"\n version = \"0.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"getrandom 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getrandom 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.65 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_chacha 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_core 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1224,7 +1270,7 @@ name = \"rand_core\"\n version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"getrandom 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getrandom 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1370,7 +1416,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1430,7 +1476,7 @@ dependencies = [\n  \"rand 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"salsa-macros 0.13.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1441,7 +1487,7 @@ dependencies = [\n  \"heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1463,7 +1509,7 @@ version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1473,20 +1519,20 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.101\"\n+version = \"1.0.102\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde_derive 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.101\"\n+version = \"1.0.102\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1496,7 +1542,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ryu 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1506,7 +1552,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1516,7 +1562,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"linked-hash-map 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"yaml-rust 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1527,15 +1573,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"0.6.10\"\n+version = \"0.6.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"smol_str\"\n version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1557,7 +1603,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.5\"\n+version = \"1.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1647,12 +1693,12 @@ name = \"unicode-normalization\"\n version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"unicode-segmentation\"\n-version = \"1.3.0\"\n+version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1673,7 +1719,7 @@ dependencies = [\n  \"idna 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"percent-encoding 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1682,7 +1728,7 @@ version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rand 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1759,7 +1805,7 @@ dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ron 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1794,11 +1840,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cargo_metadata 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d2d1617e838936c0d2323a65cc151e03ae19a7678dd24f72bccf27119b90a5d\"\n \"checksum cc 1.0.46 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0213d356d3c4ea2c18c40b037c3be23cd639825c18f25ee670ac7813beeef99c\"\n \"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git)\" = \"<none>\"\n-\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\" = \"<none>\"\n-\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git)\" = \"<none>\"\n-\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git)\" = \"<none>\"\n-\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git)\" = \"<none>\"\n+\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n+\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n+\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n+\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n+\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n+\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=8314f2fcec8582a58c24b638f1a259d4145a0809)\" = \"<none>\"\n \"checksum chrono 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8493056968583b0193c1bb04d6f7684586f3726992d6c573261941a895dbd68\"\n \"checksum clicolors-control 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90082ee5dcdd64dc4e9e0d37fbf3ee325419e39c0092191e0393df65518f741e\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n@@ -1828,7 +1875,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba\"\n \"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82\"\n \"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7\"\n-\"checksum getrandom 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"473a1265acc8ff1e808cd0a1af8cee3c2ee5200916058a2ca113c29f2d903571\"\n+\"checksum getrandom 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e7db7ca94ed4cd01190ceee0d8a8052f08a247aa1b469a7f68c6a3b71afcf407\"\n \"checksum glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574\"\n \"checksum globset 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"925aa2cac82d8834e2b2a4415b6f6879757fb5c0928fc445ae76461a12eed8f2\"\n \"checksum heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n@@ -1839,7 +1886,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum inotify-sys 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e74a1aa87c59aeff6ef2cc2fa62d41bc43f54952f55652656b18a02fd5e356c0\"\n \"checksum insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d499dc062e841590a67230d853bce62d0abeb91304927871670b7c55c461349\"\n \"checksum iovec 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b2b3ea6ff95e175473f8ffe6a7eb7c00d054240321b84c57051175fe3c1e075e\"\n-\"checksum itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5b8467d9c1cebe26feb08c640139247fac215782d35371ade9a2136ed6085358\"\n+\"checksum itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"87fa75c9dea7b07be3138c49abbb83fd4bea199b5cdc76f9804458edc5da0d6e\"\n \"checksum itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"501266b7edd0174f8530248f87f99c88fbe60ca4ef3dd486835b8d8d53136f7f\"\n \"checksum jemalloc-ctl 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c502a5ff9dd2924f1ed32ba96e3b65735d837b4bfd978d3161b1702e66aca4b7\"\n \"checksum jemalloc-sys 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d3b9f3f5c9b31aa0f5ed3260385ac205db665baa41d49bb8338008ae94ede45\"\n@@ -1922,17 +1969,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum scopeguard 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b42e15e59b18a828bbf5c58ea01debb36b9b096346de35d941dcb89009f24a0d\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\"checksum serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9796c9b7ba2ffe7a9ce53c2287dfc48080f4b2b362fcc245a259b3a7201119dd\"\n-\"checksum serde_derive 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4b133a43a1ecd55d4086bd5b4dc6c1751c68b1bfbeba7a5040442022c7e7c02e\"\n+\"checksum serde 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c4b39bd9b0b087684013a792c59e3e07a46a01d2322518d8a1104641a0b1be0\"\n+\"checksum serde_derive 1.0.102 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca13fc1a832f793322228923fbb3aba9f3f44444898f835d31ad1b74fa0a2bf8\"\n \"checksum serde_json 1.0.41 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f72eb2a68a7dc3f9a691bfda9305a1c017a6215e5a4545c258500d2099a37c2\"\n \"checksum serde_repr 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cd02c7587ec314570041b2754829f84d873ced14a96d1fd1823531e11db40573\"\n \"checksum serde_yaml 0.8.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"691b17f19fc1ec9d94ec0b5864859290dff279dbd7b03f017afda54eb36c3c35\"\n \"checksum slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n-\"checksum smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab606a9c5e214920bb66c458cd7be8ef094f813f20fe77a54cc7dbfff220d4b7\"\n+\"checksum smallvec 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cefaa50e76a6f10b86f36e640eb1739eafbd4084865067778463913e43a77ff3\"\n \"checksum smol_str 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"34836c9a295c62c2ce3514471117c5cb269891e8421b2aafdd910050576c4d8b\"\n \"checksum stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d96fc4f13a0ac088e9a3cd9af1cc8c5cc1ab5deb2145cef661267dfc9c542f8a\"\n \"checksum superslice 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n-\"checksum syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf\"\n+\"checksum syn 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e7bedb3320d0f3035594b0b723c8a28d7d336a3eda3881db79e61d676fb644c\"\n \"checksum tempfile 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n \"checksum termios 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72b620c5ea021d75a735c943269bb07d30c9b77d6ac6b236bc8b5c496ef05625\"\n \"checksum text_unit 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e08bbcb7a3adbda0eb23431206b653bdad3d8dea311e72d36bf2215e27a42579\"\n@@ -1942,7 +1989,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum unicase 2.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e2e6bd1e59e56598518beb94fd6db628ded570326f0a98c679a304bd9f00150\"\n \"checksum unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49f2bd0c6468a8230e1db229cff8029217cf623c767ea5d60bfbd42729ea54d5\"\n \"checksum unicode-normalization 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"141339a08b982d942be2ca06ff8b076563cbe223d1befd5450716790d44e2426\"\n-\"checksum unicode-segmentation 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1967f4cdfc355b37fd76d2a954fb2ed3871034eb4f26d60537d88795cfc332a9\"\n+\"checksum unicode-segmentation 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dc5415c074426c7c65db13bd647c23d78c0fb2e10dca0b8fb0f40058a59bccdf\"\n \"checksum unicode-width 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7007dbd421b92cc6e28410fe7362e2e0a2503394908f417b68ec8d1c364c4e20\"\n \"checksum unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\"\n \"checksum url 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"75b414f6c464c879d7f9babf951f23bc3743fb7313c081b2e6ca719067ea9d61\""}, {"sha": "1908bdec90df5216177666f658ecdd2b58b8be96", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,11 +1,11 @@\n-//! FIXME: write short doc here\n+//! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n \n use hir::db::HirDatabase;\n use ra_db::FileRange;\n use ra_fmt::{leading_indent, reindent};\n use ra_syntax::{\n     algo::{self, find_covering_element, find_node_at_offset},\n-    AstNode, SourceFile, SyntaxElement, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n+    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n     TokenAtOffset,\n };\n use ra_text_edit::TextEditBuilder;\n@@ -14,8 +14,8 @@ use crate::{AssistAction, AssistId, AssistLabel};\n \n #[derive(Clone, Debug)]\n pub(crate) enum Assist {\n-    Unresolved(Vec<AssistLabel>),\n-    Resolved(Vec<(AssistLabel, AssistAction)>),\n+    Unresolved { label: AssistLabel },\n+    Resolved { label: AssistLabel, action: AssistAction },\n }\n \n /// `AssistCtx` allows to apply an assist or check if it could be applied.\n@@ -54,7 +54,6 @@ pub(crate) struct AssistCtx<'a, DB> {\n     pub(crate) frange: FileRange,\n     source_file: SourceFile,\n     should_compute_edit: bool,\n-    assist: Assist,\n }\n \n impl<'a, DB> Clone for AssistCtx<'a, DB> {\n@@ -64,7 +63,6 @@ impl<'a, DB> Clone for AssistCtx<'a, DB> {\n             frange: self.frange,\n             source_file: self.source_file.clone(),\n             should_compute_edit: self.should_compute_edit,\n-            assist: self.assist.clone(),\n         }\n     }\n }\n@@ -75,43 +73,41 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n         F: FnOnce(AssistCtx<DB>) -> T,\n     {\n         let parse = db.parse(frange.file_id);\n-        let assist =\n-            if should_compute_edit { Assist::Resolved(vec![]) } else { Assist::Unresolved(vec![]) };\n \n-        let ctx = AssistCtx { db, frange, source_file: parse.tree(), should_compute_edit, assist };\n+        let ctx = AssistCtx { db, frange, source_file: parse.tree(), should_compute_edit };\n         f(ctx)\n     }\n \n-    pub(crate) fn add_action(\n-        &mut self,\n+    pub(crate) fn add_assist(\n+        self,\n         id: AssistId,\n         label: impl Into<String>,\n         f: impl FnOnce(&mut AssistBuilder),\n-    ) -> &mut Self {\n+    ) -> Option<Assist> {\n         let label = AssistLabel { label: label.into(), id };\n-        match &mut self.assist {\n-            Assist::Unresolved(labels) => labels.push(label),\n-            Assist::Resolved(labels_actions) => {\n-                let action = {\n-                    let mut edit = AssistBuilder::default();\n-                    f(&mut edit);\n-                    edit.build()\n-                };\n-                labels_actions.push((label, action));\n-            }\n-        }\n-        self\n-    }\n+        let assist = if self.should_compute_edit {\n+            let action = {\n+                let mut edit = AssistBuilder::default();\n+                f(&mut edit);\n+                edit.build()\n+            };\n+            Assist::Resolved { label, action }\n+        } else {\n+            Assist::Unresolved { label }\n+        };\n \n-    pub(crate) fn build(self) -> Option<Assist> {\n-        Some(self.assist)\n+        Some(assist)\n     }\n \n     pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n         self.source_file.syntax().token_at_offset(self.frange.range.start())\n     }\n \n-    pub(crate) fn node_at_offset<N: AstNode>(&self) -> Option<N> {\n+    pub(crate) fn find_token_at_offset(&self, kind: SyntaxKind) -> Option<SyntaxToken> {\n+        self.token_at_offset().find(|it| it.kind() == kind)\n+    }\n+\n+    pub(crate) fn find_node_at_offset<N: AstNode>(&self) -> Option<N> {\n         find_node_at_offset(self.source_file.syntax(), self.frange.range.start())\n     }\n     pub(crate) fn covering_element(&self) -> SyntaxElement {"}, {"sha": "764b17bd8dc48c886c5a7161df9f250678806db1", "filename": "crates/ra_assists/src/assists/add_derive.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_derive.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n@@ -9,10 +7,28 @@ use ra_syntax::{\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn add_derive(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let nominal = ctx.node_at_offset::<ast::NominalDef>()?;\n+// Assist: add_derive\n+//\n+// Adds a new `#[derive()]` clause to a struct or enum.\n+//\n+// ```\n+// struct Point {\n+//     x: u32,\n+//     y: u32,<|>\n+// }\n+// ```\n+// ->\n+// ```\n+// #[derive()]\n+// struct Point {\n+//     x: u32,\n+//     y: u32,\n+// }\n+// ```\n+pub(crate) fn add_derive(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let node_start = derive_insertion_offset(&nominal)?;\n-    ctx.add_action(AssistId(\"add_derive\"), \"add `#[derive]`\", |edit| {\n+    ctx.add_assist(AssistId(\"add_derive\"), \"add `#[derive]`\", |edit| {\n         let derive_attr = nominal\n             .attrs()\n             .filter_map(|x| x.as_simple_call())\n@@ -28,9 +44,7 @@ pub(crate) fn add_derive(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist>\n         };\n         edit.target(nominal.syntax().text_range());\n         edit.set_cursor(offset)\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n // Insert `derive` after doc comments."}, {"sha": "ddda1a0f2c665a29f847525ada5a1b14dc2cf69a", "filename": "crates/ra_assists/src/assists/add_explicit_type.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::{db::HirDatabase, HirDisplay, Ty};\n use ra_syntax::{\n     ast::{self, AstNode, LetStmt, NameOwner},\n@@ -8,9 +6,23 @@ use ra_syntax::{\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-/// Add explicit type assist.\n-pub(crate) fn add_explicit_type(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let stmt = ctx.node_at_offset::<LetStmt>()?;\n+// Assist: add_explicit_type\n+//\n+// Specify type for a let binding.\n+//\n+// ```\n+// fn main() {\n+//     let x<|> = 92;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let x: i32 = 92;\n+// }\n+// ```\n+pub(crate) fn add_explicit_type(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let stmt = ctx.find_node_at_offset::<LetStmt>()?;\n     let expr = stmt.initializer()?;\n     let pat = stmt.pat()?;\n     // Must be a binding\n@@ -35,11 +47,10 @@ pub(crate) fn add_explicit_type(mut ctx: AssistCtx<impl HirDatabase>) -> Option<\n         return None;\n     }\n \n-    ctx.add_action(AssistId(\"add_explicit_type\"), \"add explicit type\", |edit| {\n+    ctx.add_assist(AssistId(\"add_explicit_type\"), \"add explicit type\", |edit| {\n         edit.target(pat_range);\n         edit.insert(name_range.end(), format!(\": {}\", ty.display(db)));\n-    });\n-    ctx.build()\n+    })\n }\n \n /// Returns true if any type parameter is unknown"}, {"sha": "7da0cfd0d3261d9f8400801557af19d454d11961", "filename": "crates/ra_assists/src/assists/add_impl.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_impl.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use format_buf::format;\n use hir::db::HirDatabase;\n use join_to_string::join;\n@@ -10,10 +8,29 @@ use ra_syntax::{\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn add_impl(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let nominal = ctx.node_at_offset::<ast::NominalDef>()?;\n+// Assist: add_impl\n+//\n+// Adds a new inherent impl for a type.\n+//\n+// ```\n+// struct Ctx<T: Clone> {\n+//      data: T,<|>\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Ctx<T: Clone> {\n+//      data: T,\n+// }\n+//\n+// impl<T: Clone> Ctx<T> {\n+//\n+// }\n+// ```\n+pub(crate) fn add_impl(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let name = nominal.name()?;\n-    ctx.add_action(AssistId(\"add_impl\"), \"add impl\", |edit| {\n+    ctx.add_assist(AssistId(\"add_impl\"), \"add impl\", |edit| {\n         edit.target(nominal.syntax().text_range());\n         let type_params = nominal.type_param_list();\n         let start_offset = nominal.syntax().text_range().end();\n@@ -37,9 +54,7 @@ pub(crate) fn add_impl(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         edit.set_cursor(start_offset + TextUnit::of_str(&buf));\n         buf.push_str(\"\\n}\");\n         edit.insert(start_offset, buf);\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "363ade016b041e8fba8fc32b8a4a1039f16aea7f", "filename": "crates/ra_assists/src/assists/add_import.rs", "status": "renamed", "additions": 136, "deletions": 113, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,18 +1,81 @@\n-//! FIXME: write short doc here\n-\n use hir::{self, db::HirDatabase};\n-use ra_text_edit::TextEditBuilder;\n-\n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    AssistId,\n-};\n use ra_syntax::{\n     ast::{self, NameOwner},\n     AstNode, Direction, SmolStr,\n     SyntaxKind::{PATH, PATH_SEGMENT},\n     SyntaxNode, TextRange, T,\n };\n+use ra_text_edit::TextEditBuilder;\n+\n+use crate::{\n+    assist_ctx::{Assist, AssistCtx},\n+    AssistId,\n+};\n+\n+/// This function produces sequence of text edits into edit\n+/// to import the target path in the most appropriate scope given\n+/// the cursor position\n+pub fn auto_import_text_edit(\n+    // Ideally the position of the cursor, used to\n+    position: &SyntaxNode,\n+    // The statement to use as anchor (last resort)\n+    anchor: &SyntaxNode,\n+    // The path to import as a sequence of strings\n+    target: &[SmolStr],\n+    edit: &mut TextEditBuilder,\n+) {\n+    let container = position.ancestors().find_map(|n| {\n+        if let Some(module) = ast::Module::cast(n.clone()) {\n+            return module.item_list().map(|it| it.syntax().clone());\n+        }\n+        ast::SourceFile::cast(n).map(|it| it.syntax().clone())\n+    });\n+\n+    if let Some(container) = container {\n+        let action = best_action_for_target(container, anchor.clone(), target);\n+        make_assist(&action, target, edit);\n+    }\n+}\n+\n+// Assist: add_import\n+//\n+// Adds a use statement for a given fully-qualified path.\n+//\n+// ```\n+// fn process(map: std::collections::<|>HashMap<String, String>) {}\n+// ```\n+// ->\n+// ```\n+// use std::collections::HashMap;\n+//\n+// fn process(map: HashMap<String, String>) {}\n+// ```\n+pub(crate) fn add_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n+    // We don't want to mess with use statements\n+    if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n+        return None;\n+    }\n+\n+    let hir_path = hir::Path::from_ast(path.clone())?;\n+    let segments = collect_hir_path_segments(&hir_path)?;\n+    if segments.len() < 2 {\n+        return None;\n+    }\n+\n+    let module = path.syntax().ancestors().find_map(ast::Module::cast);\n+    let position = match module.and_then(|it| it.item_list()) {\n+        Some(item_list) => item_list.syntax().clone(),\n+        None => {\n+            let current_file = path.syntax().ancestors().find_map(ast::SourceFile::cast)?;\n+            current_file.syntax().clone()\n+        }\n+    };\n+\n+    ctx.add_assist(AssistId(\"add_import\"), format!(\"import {}\", fmt_segments(&segments)), |edit| {\n+        apply_auto_import(&position, &path, &segments, edit.text_edit_builder());\n+    })\n+}\n \n fn collect_path_segments_raw(\n     segments: &mut Vec<ast::PathSegment>,\n@@ -61,9 +124,9 @@ fn fmt_segments_raw(segments: &[SmolStr], buf: &mut String) {\n     }\n }\n \n-// Returns the numeber of common segments.\n+/// Returns the number of common segments.\n fn compare_path_segments(left: &[SmolStr], right: &[ast::PathSegment]) -> usize {\n-    left.iter().zip(right).filter(|(l, r)| compare_path_segment(l, r)).count()\n+    left.iter().zip(right).take_while(|(l, r)| compare_path_segment(l, r)).count()\n }\n \n fn compare_path_segment(a: &SmolStr, b: &ast::PathSegment) -> bool {\n@@ -84,7 +147,7 @@ fn compare_path_segment_with_name(a: &SmolStr, b: &ast::Name) -> bool {\n     a == b.text()\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n enum ImportAction {\n     Nothing,\n     // Add a brand new use statement.\n@@ -154,9 +217,17 @@ impl ImportAction {\n             (\n                 ImportAction::AddNestedImport { common_segments: n, .. },\n                 ImportAction::AddInTreeList { common_segments: m, .. },\n-            ) => n > m,\n-            (\n+            )\n+            | (\n+                ImportAction::AddInTreeList { common_segments: n, .. },\n+                ImportAction::AddNestedImport { common_segments: m, .. },\n+            )\n+            | (\n                 ImportAction::AddInTreeList { common_segments: n, .. },\n+                ImportAction::AddInTreeList { common_segments: m, .. },\n+            )\n+            | (\n+                ImportAction::AddNestedImport { common_segments: n, .. },\n                 ImportAction::AddNestedImport { common_segments: m, .. },\n             ) => n > m,\n             (ImportAction::AddInTreeList { .. }, _) => true,\n@@ -226,7 +297,7 @@ fn walk_use_tree_for_best_action(\n         common if common == left.len() && left.len() == right.len() => {\n             // e.g: target is std::fmt and we can have\n             // 1- use std::fmt;\n-            // 2- use std::fmt:{ ... }\n+            // 2- use std::fmt::{ ... }\n             if let Some(list) = tree_list {\n                 // In case 2 we need to add self to the nested list\n                 // unless it's already there\n@@ -474,7 +545,7 @@ fn make_assist_add_nested_import(\n         if add_colon_colon {\n             buf.push_str(\"::\");\n         }\n-        buf.push_str(\"{ \");\n+        buf.push_str(\"{\");\n         if add_self {\n             buf.push_str(\"self, \");\n         }\n@@ -505,7 +576,7 @@ fn apply_auto_import(\n     }\n }\n \n-pub fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n+fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n     let mut ps = Vec::<SmolStr>::with_capacity(10);\n     match path.kind {\n         hir::PathKind::Abs => ps.push(\"\".into()),\n@@ -521,87 +592,16 @@ pub fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n     Some(ps)\n }\n \n-// This function produces sequence of text edits into edit\n-// to import the target path in the most appropriate scope given\n-// the cursor position\n-pub fn auto_import_text_edit(\n-    // Ideally the position of the cursor, used to\n-    position: &SyntaxNode,\n-    // The statement to use as anchor (last resort)\n-    anchor: &SyntaxNode,\n-    // The path to import as a sequence of strings\n-    target: &[SmolStr],\n-    edit: &mut TextEditBuilder,\n-) {\n-    let container = position.ancestors().find_map(|n| {\n-        if let Some(module) = ast::Module::cast(n.clone()) {\n-            return module.item_list().map(|it| it.syntax().clone());\n-        }\n-        ast::SourceFile::cast(n).map(|it| it.syntax().clone())\n-    });\n-\n-    if let Some(container) = container {\n-        let action = best_action_for_target(container, anchor.clone(), target);\n-        make_assist(&action, target, edit);\n-    }\n-}\n-\n-pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let path: ast::Path = ctx.node_at_offset()?;\n-    // We don't want to mess with use statements\n-    if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n-        return None;\n-    }\n-\n-    let hir_path = hir::Path::from_ast(path.clone())?;\n-    let segments = collect_hir_path_segments(&hir_path)?;\n-    if segments.len() < 2 {\n-        return None;\n-    }\n-\n-    if let Some(module) = path.syntax().ancestors().find_map(ast::Module::cast) {\n-        if let (Some(item_list), Some(name)) = (module.item_list(), module.name()) {\n-            ctx.add_action(\n-                AssistId(\"auto_import\"),\n-                format!(\"import {} in mod {}\", fmt_segments(&segments), name.text()),\n-                |edit| {\n-                    apply_auto_import(\n-                        item_list.syntax(),\n-                        &path,\n-                        &segments,\n-                        edit.text_edit_builder(),\n-                    );\n-                },\n-            );\n-        }\n-    } else {\n-        let current_file = path.syntax().ancestors().find_map(ast::SourceFile::cast)?;\n-        ctx.add_action(\n-            AssistId(\"auto_import\"),\n-            format!(\"import {} in the current file\", fmt_segments(&segments)),\n-            |edit| {\n-                apply_auto_import(\n-                    current_file.syntax(),\n-                    &path,\n-                    &segments,\n-                    edit.text_edit_builder(),\n-                );\n-            },\n-        );\n-    }\n-\n-    ctx.build()\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::helpers::{check_assist, check_assist_not_applicable};\n \n+    use super::*;\n+\n     #[test]\n     fn test_auto_import_add_use_no_anchor() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n std::fmt::Debug<|>\n     \",\n@@ -615,7 +615,7 @@ Debug<|>\n     #[test]\n     fn test_auto_import_add_use_no_anchor_with_item_below() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n std::fmt::Debug<|>\n \n@@ -636,7 +636,7 @@ fn main() {\n     #[test]\n     fn test_auto_import_add_use_no_anchor_with_item_above() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n fn main() {\n }\n@@ -657,7 +657,7 @@ Debug<|>\n     #[test]\n     fn test_auto_import_add_use_no_anchor_2seg() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n std::fmt<|>::Debug\n     \",\n@@ -672,7 +672,7 @@ fmt<|>::Debug\n     #[test]\n     fn test_auto_import_add_use() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n use stdx;\n \n@@ -692,7 +692,7 @@ impl Debug<|> for Foo {\n     #[test]\n     fn test_auto_import_file_use_other_anchor() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n impl std::fmt::Debug<|> for Foo {\n }\n@@ -709,7 +709,7 @@ impl Debug<|> for Foo {\n     #[test]\n     fn test_auto_import_add_use_other_anchor_indent() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n     impl std::fmt::Debug<|> for Foo {\n     }\n@@ -726,15 +726,15 @@ impl Debug<|> for Foo {\n     #[test]\n     fn test_auto_import_split_different() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n use std::fmt;\n \n impl std::io<|> for Foo {\n }\n     \",\n             \"\n-use std::{ io, fmt};\n+use std::{io, fmt};\n \n impl io<|> for Foo {\n }\n@@ -745,15 +745,15 @@ impl io<|> for Foo {\n     #[test]\n     fn test_auto_import_split_self_for_use() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n use std::fmt;\n \n impl std::fmt::Debug<|> for Foo {\n }\n     \",\n             \"\n-use std::fmt::{ self, Debug, };\n+use std::fmt::{self, Debug, };\n \n impl Debug<|> for Foo {\n }\n@@ -764,15 +764,15 @@ impl Debug<|> for Foo {\n     #[test]\n     fn test_auto_import_split_self_for_target() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n use std::fmt::Debug;\n \n impl std::fmt<|> for Foo {\n }\n     \",\n             \"\n-use std::fmt::{ self, Debug};\n+use std::fmt::{self, Debug};\n \n impl fmt<|> for Foo {\n }\n@@ -783,7 +783,7 @@ impl fmt<|> for Foo {\n     #[test]\n     fn test_auto_import_add_to_nested_self_nested() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n use std::fmt::{Debug, nested::{Display}};\n \n@@ -802,7 +802,7 @@ impl nested<|> for Foo {\n     #[test]\n     fn test_auto_import_add_to_nested_self_already_included() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n use std::fmt::{Debug, nested::{self, Display}};\n \n@@ -821,7 +821,7 @@ impl nested<|> for Foo {\n     #[test]\n     fn test_auto_import_add_to_nested_nested() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n use std::fmt::{Debug, nested::{Display}};\n \n@@ -840,15 +840,15 @@ impl Debug<|> for Foo {\n     #[test]\n     fn test_auto_import_split_common_target_longer() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n use std::fmt::Debug;\n \n impl std::fmt::nested::Display<|> for Foo {\n }\n \",\n             \"\n-use std::fmt::{ nested::Display, Debug};\n+use std::fmt::{nested::Display, Debug};\n \n impl Display<|> for Foo {\n }\n@@ -859,26 +859,49 @@ impl Display<|> for Foo {\n     #[test]\n     fn test_auto_import_split_common_use_longer() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n use std::fmt::nested::Debug;\n \n impl std::fmt::Display<|> for Foo {\n }\n \",\n             \"\n-use std::fmt::{ Display, nested::Debug};\n+use std::fmt::{Display, nested::Debug};\n \n impl Display<|> for Foo {\n }\n \",\n         );\n     }\n \n+    #[test]\n+    fn test_auto_import_use_nested_import() {\n+        check_assist(\n+            add_import,\n+            \"\n+use crate::{\n+    ty::{Substs, Ty},\n+    AssocItem,\n+};\n+\n+fn foo() { crate::ty::lower<|>::trait_env() }\n+\",\n+            \"\n+use crate::{\n+    ty::{Substs, Ty, lower},\n+    AssocItem,\n+};\n+\n+fn foo() { lower<|>::trait_env() }\n+\",\n+        );\n+    }\n+\n     #[test]\n     fn test_auto_import_alias() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n use std::fmt as foo;\n \n@@ -897,7 +920,7 @@ impl Debug<|> for Foo {\n     #[test]\n     fn test_auto_import_not_applicable_one_segment() {\n         check_assist_not_applicable(\n-            auto_import,\n+            add_import,\n             \"\n impl foo<|> for Foo {\n }\n@@ -908,7 +931,7 @@ impl foo<|> for Foo {\n     #[test]\n     fn test_auto_import_not_applicable_in_use() {\n         check_assist_not_applicable(\n-            auto_import,\n+            add_import,\n             \"\n use std::fmt<|>;\n \",\n@@ -918,7 +941,7 @@ use std::fmt<|>;\n     #[test]\n     fn test_auto_import_add_use_no_anchor_in_mod_mod() {\n         check_assist(\n-            auto_import,\n+            add_import,\n             \"\n mod foo {\n     mod bar {", "previous_filename": "crates/ra_assists/src/assists/auto_import.rs"}, {"sha": "41de239219fbdf19badebc5217c14f2f9af09ac3", "filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::{db::HirDatabase, HasSource};\n use ra_syntax::{\n     ast::{self, edit, make, AstNode, NameOwner},\n@@ -14,6 +12,34 @@ enum AddMissingImplMembersMode {\n     NoDefaultMethods,\n }\n \n+// Assist: add_impl_missing_members\n+//\n+// Adds scaffold for required impl members.\n+//\n+// ```\n+// trait T {\n+//     Type X;\n+//     fn foo(&self);\n+//     fn bar(&self) {}\n+// }\n+//\n+// impl T for () {<|>\n+//\n+// }\n+// ```\n+// ->\n+// ```\n+// trait T {\n+//     Type X;\n+//     fn foo(&self);\n+//     fn bar(&self) {}\n+// }\n+//\n+// impl T for () {\n+//     fn foo(&self) { unimplemented!() }\n+//\n+// }\n+// ```\n pub(crate) fn add_missing_impl_members(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     add_missing_impl_members_inner(\n         ctx,\n@@ -23,6 +49,38 @@ pub(crate) fn add_missing_impl_members(ctx: AssistCtx<impl HirDatabase>) -> Opti\n     )\n }\n \n+// Assist: add_impl_default_members\n+//\n+// Adds scaffold for overriding default impl members.\n+//\n+// ```\n+// trait T {\n+//     Type X;\n+//     fn foo(&self);\n+//     fn bar(&self) {}\n+// }\n+//\n+// impl T for () {\n+//     Type X = ();\n+//     fn foo(&self) {}<|>\n+//\n+// }\n+// ```\n+// ->\n+// ```\n+// trait T {\n+//     Type X;\n+//     fn foo(&self);\n+//     fn bar(&self) {}\n+// }\n+//\n+// impl T for () {\n+//     Type X = ();\n+//     fn foo(&self) {}\n+//     fn bar(&self) {}\n+//\n+// }\n+// ```\n pub(crate) fn add_missing_default_members(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     add_missing_impl_members_inner(\n         ctx,\n@@ -33,12 +91,12 @@ pub(crate) fn add_missing_default_members(ctx: AssistCtx<impl HirDatabase>) -> O\n }\n \n fn add_missing_impl_members_inner(\n-    mut ctx: AssistCtx<impl HirDatabase>,\n+    ctx: AssistCtx<impl HirDatabase>,\n     mode: AddMissingImplMembersMode,\n     assist_id: &'static str,\n     label: &'static str,\n ) -> Option<Assist> {\n-    let impl_node = ctx.node_at_offset::<ast::ImplBlock>()?;\n+    let impl_node = ctx.find_node_at_offset::<ast::ImplBlock>()?;\n     let impl_item_list = impl_node.item_list()?;\n \n     let trait_def = {\n@@ -75,7 +133,7 @@ fn add_missing_impl_members_inner(\n         return None;\n     }\n \n-    ctx.add_action(AssistId(assist_id), label, |edit| {\n+    ctx.add_assist(AssistId(assist_id), label, |edit| {\n         let n_existing_items = impl_item_list.impl_items().count();\n         let items = missing_items\n             .into_iter()\n@@ -92,9 +150,7 @@ fn add_missing_impl_members_inner(\n \n         edit.replace_ast(impl_item_list, new_impl_item_list);\n         edit.set_cursor(cursor_position);\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n fn add_body(fn_def: ast::FnDef) -> ast::FnDef {"}, {"sha": "068da1774d98e544ce2aee16b029d680b4f1c002", "filename": "crates/ra_assists/src/assists/apply_demorgan.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fapply_demorgan.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,20 +1,30 @@\n-//! This contains the functions associated with the demorgan assist.\n-//! This assist transforms boolean expressions of the form `!a || !b` into\n-//! `!(a && b)`.\n use hir::db::HirDatabase;\n use ra_syntax::ast::{self, AstNode};\n use ra_syntax::SyntaxNode;\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-/// Assist for applying demorgan's law\n-///\n-/// This transforms expressions of the form `!l || !r` into `!(l && r)`.\n-/// This also works with `&&`. This assist can only be applied with the cursor\n-/// on either `||` or `&&`, with both operands being a negation of some kind.\n-/// This means something of the form `!x` or `x != y`.\n-pub(crate) fn apply_demorgan(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let expr = ctx.node_at_offset::<ast::BinExpr>()?;\n+// Assist: apply_demorgan\n+//\n+// Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).\n+// This transforms expressions of the form `!l || !r` into `!(l && r)`.\n+// This also works with `&&`. This assist can only be applied with the cursor\n+// on either `||` or `&&`, with both operands being a negation of some kind.\n+// This means something of the form `!x` or `x != y`.\n+//\n+// ```\n+// fn main() {\n+//     if x != 4 ||<|> !y {}\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     if !(x == 4 && y) {}\n+// }\n+// ```\n+pub(crate) fn apply_demorgan(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();\n     let opposite_op = opposite_logic_op(op)?;\n@@ -29,13 +39,12 @@ pub(crate) fn apply_demorgan(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Ass\n     let not_lhs = undo_negation(lhs)?;\n     let not_rhs = undo_negation(rhs)?;\n \n-    ctx.add_action(AssistId(\"apply_demorgan\"), \"apply demorgan's law\", |edit| {\n+    ctx.add_assist(AssistId(\"apply_demorgan\"), \"apply demorgan's law\", |edit| {\n         edit.target(op_range);\n         edit.replace(op_range, opposite_op);\n         edit.replace(lhs_range, format!(\"!({}\", not_lhs));\n         edit.replace(rhs_range, format!(\"{})\", not_rhs));\n-    });\n-    ctx.build()\n+    })\n }\n \n // Return the opposite text for a given logical operator, if it makes sense"}, {"sha": "132c9dc1d750e243c560003baff8a81ce6e3e9aa", "filename": "crates/ra_assists/src/assists/change_visibility.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fchange_visibility.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, NameOwner, VisibilityOwner},\n@@ -13,14 +11,25 @@ use ra_syntax::{\n \n use crate::{Assist, AssistCtx, AssistId};\n \n+// Assist: change_visibility\n+//\n+// Adds or changes existing visibility specifier.\n+//\n+// ```\n+// <|>fn frobnicate() {}\n+// ```\n+// ->\n+// ```\n+// pub(crate) fn frobnicate() {}\n+// ```\n pub(crate) fn change_visibility(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    if let Some(vis) = ctx.node_at_offset::<ast::Visibility>() {\n+    if let Some(vis) = ctx.find_node_at_offset::<ast::Visibility>() {\n         return change_vis(ctx, vis);\n     }\n     add_vis(ctx)\n }\n \n-fn add_vis(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+fn add_vis(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let item_keyword = ctx.token_at_offset().find(|leaf| match leaf.kind() {\n         T![fn] | T![mod] | T![struct] | T![enum] | T![trait] => true,\n         _ => false,\n@@ -48,13 +57,11 @@ fn add_vis(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         (vis_offset(field.syntax()), ident.text_range())\n     };\n \n-    ctx.add_action(AssistId(\"change_visibility\"), \"make pub(crate)\", |edit| {\n+    ctx.add_assist(AssistId(\"change_visibility\"), \"make pub(crate)\", |edit| {\n         edit.target(target);\n         edit.insert(offset, \"pub(crate) \");\n         edit.set_cursor(offset);\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n fn vis_offset(node: &SyntaxNode) -> TextUnit {\n@@ -68,24 +75,20 @@ fn vis_offset(node: &SyntaxNode) -> TextUnit {\n         .unwrap_or_else(|| node.text_range().start())\n }\n \n-fn change_vis(mut ctx: AssistCtx<impl HirDatabase>, vis: ast::Visibility) -> Option<Assist> {\n+fn change_vis(ctx: AssistCtx<impl HirDatabase>, vis: ast::Visibility) -> Option<Assist> {\n     if vis.syntax().text() == \"pub\" {\n-        ctx.add_action(AssistId(\"change_visibility\"), \"change to pub(crate)\", |edit| {\n+        return ctx.add_assist(AssistId(\"change_visibility\"), \"change to pub(crate)\", |edit| {\n             edit.target(vis.syntax().text_range());\n             edit.replace(vis.syntax().text_range(), \"pub(crate)\");\n             edit.set_cursor(vis.syntax().text_range().start())\n         });\n-\n-        return ctx.build();\n     }\n     if vis.syntax().text() == \"pub(crate)\" {\n-        ctx.add_action(AssistId(\"change_visibility\"), \"change to pub\", |edit| {\n+        return ctx.add_assist(AssistId(\"change_visibility\"), \"change to pub\", |edit| {\n             edit.target(vis.syntax().text_range());\n             edit.replace(vis.syntax().text_range(), \"pub\");\n             edit.set_cursor(vis.syntax().text_range().start());\n         });\n-\n-        return ctx.build();\n     }\n     None\n }"}, {"sha": "ad6c5695a3a4fc7905e2261c08bd39989707ca73", "filename": "crates/ra_assists/src/assists/early_return.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,26 +1,3 @@\n-//! Assist: `convert_to_guarded_return`\n-//!\n-//! Replace a large conditional with a guarded return.\n-//!\n-//! ```text\n-//! fn <|>main() {\n-//!     if cond {\n-//!         foo();\n-//!         bar();\n-//!     }\n-//! }\n-//! ```\n-//! ->\n-//! ```text\n-//! fn main() {\n-//!     if !cond {\n-//!         return;\n-//!     }\n-//!     foo();\n-//!     bar();\n-//! }\n-//! ```\n-\n use std::ops::RangeInclusive;\n \n use hir::db::HirDatabase;\n@@ -36,8 +13,30 @@ use crate::{\n     AssistId,\n };\n \n-pub(crate) fn convert_to_guarded_return(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let if_expr: ast::IfExpr = ctx.node_at_offset()?;\n+// Assist: convert_to_guarded_return\n+//\n+// Replace a large conditional with a guarded return.\n+//\n+// ```\n+// fn main() {\n+//     <|>if cond {\n+//         foo();\n+//         bar();\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     if !cond {\n+//         return;\n+//     }\n+//     foo();\n+//     bar();\n+// }\n+// ```\n+pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     let expr = if_expr.condition()?.expr()?;\n     let then_block = if_expr.then_branch()?.block()?;\n     if if_expr.else_branch().is_some() {\n@@ -51,7 +50,7 @@ pub(crate) fn convert_to_guarded_return(mut ctx: AssistCtx<impl HirDatabase>) ->\n     }\n \n     // check for early return and continue\n-    let first_in_then_block = then_block.syntax().first_child()?.clone();\n+    let first_in_then_block = then_block.syntax().first_child()?;\n     if ast::ReturnExpr::can_cast(first_in_then_block.kind())\n         || ast::ContinueExpr::can_cast(first_in_then_block.kind())\n         || first_in_then_block\n@@ -76,7 +75,7 @@ pub(crate) fn convert_to_guarded_return(mut ctx: AssistCtx<impl HirDatabase>) ->\n     then_block.syntax().last_child_or_token().filter(|t| t.kind() == R_CURLY)?;\n     let cursor_position = ctx.frange.range.start();\n \n-    ctx.add_action(AssistId(\"convert_to_guarded_return\"), \"convert to guarded return\", |edit| {\n+    ctx.add_assist(AssistId(\"convert_to_guarded_return\"), \"convert to guarded return\", |edit| {\n         let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n         let new_if_expr =\n             if_indent_level.increase_indent(make::if_expression(&expr, early_expression));\n@@ -106,8 +105,7 @@ pub(crate) fn convert_to_guarded_return(mut ctx: AssistCtx<impl HirDatabase>) ->\n         edit.target(if_expr.syntax().text_range());\n         edit.replace_ast(parent_block, ast::Block::cast(new_block).unwrap());\n         edit.set_cursor(cursor_position);\n-    });\n-    ctx.build()\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "2b74f355c6ab5ada8d9fd6767ed15d4b27d47045", "filename": "crates/ra_assists/src/assists/fill_match_arms.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -7,8 +7,32 @@ use ra_syntax::ast::{self, edit::IndentLevel, make, AstNode, NameOwner};\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let match_expr = ctx.node_at_offset::<ast::MatchExpr>()?;\n+// Assist: fill_match_arms\n+//\n+// Adds missing clauses to a `match` expression.\n+//\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         <|>\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move { distance } => (),\n+//         Action::Stop => (),\n+//     }\n+// }\n+// ```\n+pub(crate) fn fill_match_arms(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let match_expr = ctx.find_node_at_offset::<ast::MatchExpr>()?;\n     let match_arm_list = match_expr.match_arm_list()?;\n \n     // We already have some match arms, so we don't provide any assists.\n@@ -29,7 +53,7 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n     };\n     let variant_list = enum_def.variant_list()?;\n \n-    ctx.add_action(AssistId(\"fill_match_arms\"), \"fill match arms\", |edit| {\n+    ctx.add_assist(AssistId(\"fill_match_arms\"), \"fill match arms\", |edit| {\n         let indent_level = IndentLevel::from_node(match_arm_list.syntax());\n \n         let new_arm_list = {\n@@ -43,9 +67,7 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n         edit.target(match_expr.syntax().text_range());\n         edit.set_cursor(expr.syntax().text_range().start());\n         edit.replace_ast(match_arm_list, new_arm_list);\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n fn is_trivial(arm: &ast::MatchArm) -> bool {\n@@ -130,7 +152,7 @@ mod tests {\n                     A::Bs => (),\n                     A::Cs(_) => (),\n                     A::Ds(_, _) => (),\n-                    A::Es{ x, y } => (),\n+                    A::Es { x, y } => (),\n                 }\n             }\n             \"#,\n@@ -183,7 +205,7 @@ mod tests {\n \n             fn foo(a: &mut A) {\n                 match <|>a {\n-                    A::Es{ x, y } => (),\n+                    A::Es { x, y } => (),\n                 }\n             }\n             \"#,"}, {"sha": "386045eb0a05f3699819dd76167626c248d65183", "filename": "crates/ra_assists/src/assists/flip_binexpr.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fflip_binexpr.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,13 +1,25 @@\n-//! FIXME: write short doc here\n-\n use hir::db::HirDatabase;\n use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-/// Flip binary expression assist.\n-pub(crate) fn flip_binexpr(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let expr = ctx.node_at_offset::<BinExpr>()?;\n+// Assist: flip_binexpr\n+//\n+// Flips operands of a binary expression.\n+//\n+// ```\n+// fn main() {\n+//     let _ = 90 +<|> 2;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let _ = 2 + 90;\n+// }\n+// ```\n+pub(crate) fn flip_binexpr(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let expr = ctx.find_node_at_offset::<BinExpr>()?;\n     let lhs = expr.lhs()?.syntax().clone();\n     let rhs = expr.rhs()?.syntax().clone();\n     let op_range = expr.op_token()?.text_range();\n@@ -22,16 +34,14 @@ pub(crate) fn flip_binexpr(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assis\n         return None;\n     }\n \n-    ctx.add_action(AssistId(\"flip_binexpr\"), \"flip binary expression\", |edit| {\n+    ctx.add_assist(AssistId(\"flip_binexpr\"), \"flip binary expression\", |edit| {\n         edit.target(op_range);\n         if let FlipAction::FlipAndReplaceOp(new_op) = action {\n             edit.replace(op_range, new_op);\n         }\n         edit.replace(lhs.text_range(), rhs.text());\n         edit.replace(rhs.text_range(), lhs.text());\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n enum FlipAction {"}, {"sha": "9be1c1dc6997b0f769c8e2e7cb3978d96d5882c5", "filename": "crates/ra_assists/src/assists/flip_comma.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fflip_comma.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,12 +1,25 @@\n-//! FIXME: write short doc here\n-\n use hir::db::HirDatabase;\n use ra_syntax::{algo::non_trivia_sibling, Direction, T};\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn flip_comma(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let comma = ctx.token_at_offset().find(|leaf| leaf.kind() == T![,])?;\n+// Assist: flip_comma\n+//\n+// Flips two comma-separated items.\n+//\n+// ```\n+// fn main() {\n+//     ((1, 2),<|> (3, 4));\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     ((3, 4), (1, 2));\n+// }\n+// ```\n+pub(crate) fn flip_comma(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let comma = ctx.find_token_at_offset(T![,])?;\n     let prev = non_trivia_sibling(comma.clone().into(), Direction::Prev)?;\n     let next = non_trivia_sibling(comma.clone().into(), Direction::Next)?;\n \n@@ -16,13 +29,11 @@ pub(crate) fn flip_comma(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist>\n         return None;\n     }\n \n-    ctx.add_action(AssistId(\"flip_comma\"), \"flip comma\", |edit| {\n+    ctx.add_assist(AssistId(\"flip_comma\"), \"flip comma\", |edit| {\n         edit.target(comma.text_range());\n         edit.replace(prev.text_range(), next.to_string());\n         edit.replace(next.text_range(), prev.to_string());\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "6017b39dd84b3678f7ddf656fcbb5f23b769613b", "filename": "crates/ra_assists/src/assists/flip_trait_bound.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fflip_trait_bound.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,117 @@\n+use hir::db::HirDatabase;\n+use ra_syntax::{\n+    algo::non_trivia_sibling,\n+    ast::{self, AstNode},\n+    Direction, T,\n+};\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+\n+// Assist: flip_trait_bound\n+//\n+// Flips two trait bounds.\n+//\n+// ```\n+// fn foo<T: Clone +<|> Copy>() { }\n+// ```\n+// ->\n+// ```\n+// fn foo<T: Copy + Clone>() { }\n+// ```\n+pub(crate) fn flip_trait_bound(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    // We want to replicate the behavior of `flip_binexpr` by only suggesting\n+    // the assist when the cursor is on a `+`\n+    let plus = ctx.find_token_at_offset(T![+])?;\n+\n+    // Make sure we're in a `TypeBoundList`\n+    if ast::TypeBoundList::cast(plus.parent()).is_none() {\n+        return None;\n+    }\n+\n+    let (before, after) = (\n+        non_trivia_sibling(plus.clone().into(), Direction::Prev)?,\n+        non_trivia_sibling(plus.clone().into(), Direction::Next)?,\n+    );\n+\n+    ctx.add_assist(AssistId(\"flip_trait_bound\"), \"flip trait bound\", |edit| {\n+        edit.target(plus.text_range());\n+        edit.replace(before.text_range(), after.to_string());\n+        edit.replace(after.text_range(), before.to_string());\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+\n+    #[test]\n+    fn flip_trait_bound_assist_available() {\n+        check_assist_target(flip_trait_bound, \"struct S<T> where T: A <|>+ B + C { }\", \"+\")\n+    }\n+\n+    #[test]\n+    fn flip_trait_bound_not_applicable_for_single_trait_bound() {\n+        check_assist_not_applicable(flip_trait_bound, \"struct S<T> where T: <|>A { }\")\n+    }\n+\n+    #[test]\n+    fn flip_trait_bound_works_for_struct() {\n+        check_assist(\n+            flip_trait_bound,\n+            \"struct S<T> where T: A <|>+ B { }\",\n+            \"struct S<T> where T: B <|>+ A { }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_trait_bound_works_for_trait_impl() {\n+        check_assist(\n+            flip_trait_bound,\n+            \"impl X for S<T> where T: A +<|> B { }\",\n+            \"impl X for S<T> where T: B +<|> A { }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_trait_bound_works_for_fn() {\n+        check_assist(flip_trait_bound, \"fn f<T: A <|>+ B>(t: T) { }\", \"fn f<T: B <|>+ A>(t: T) { }\")\n+    }\n+\n+    #[test]\n+    fn flip_trait_bound_works_for_fn_where_clause() {\n+        check_assist(\n+            flip_trait_bound,\n+            \"fn f<T>(t: T) where T: A +<|> B { }\",\n+            \"fn f<T>(t: T) where T: B +<|> A { }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_trait_bound_works_for_lifetime() {\n+        check_assist(\n+            flip_trait_bound,\n+            \"fn f<T>(t: T) where T: A <|>+ 'static { }\",\n+            \"fn f<T>(t: T) where T: 'static <|>+ A { }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_trait_bound_works_for_complex_bounds() {\n+        check_assist(\n+            flip_trait_bound,\n+            \"struct S<T> where T: A<T> <|>+ b_mod::B<T> + C<T> { }\",\n+            \"struct S<T> where T: b_mod::B<T> <|>+ A<T> + C<T> { }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_trait_bound_works_for_long_bounds() {\n+        check_assist(\n+            flip_trait_bound,\n+            \"struct S<T> where T: A + B + C + D + E + F +<|> G + H + I + J { }\",\n+            \"struct S<T> where T: A + B + C + D + E + G +<|> F + H + I + J { }\",\n+        )\n+    }\n+}"}, {"sha": "a7fd9b6d2d6ef065c5854d68ecc37cf8b4c8fbb4", "filename": "crates/ra_assists/src/assists/inline_local_variable.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Finline_local_variable.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, AstToken},\n@@ -9,8 +7,24 @@ use ra_syntax::{\n use crate::assist_ctx::AssistBuilder;\n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let let_stmt = ctx.node_at_offset::<ast::LetStmt>()?;\n+// Assist: inline_local_variable\n+//\n+// Inlines local variable.\n+//\n+// ```\n+// fn main() {\n+//     let x<|> = 1 + 2;\n+//     x * 4;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     (1 + 2) * 4;\n+// }\n+// ```\n+pub(crate) fn inline_local_varialbe(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n     let bind_pat = match let_stmt.pat()? {\n         ast::Pat::BindPat(pat) => pat,\n         _ => return None,\n@@ -37,10 +51,8 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n     let mut wrap_in_parens = vec![true; refs.len()];\n \n     for (i, desc) in refs.iter().enumerate() {\n-        let usage_node = ctx\n-            .covering_node_for_range(desc.range)\n-            .ancestors()\n-            .find_map(|node| ast::PathExpr::cast(node))?;\n+        let usage_node =\n+            ctx.covering_node_for_range(desc.range).ancestors().find_map(ast::PathExpr::cast)?;\n         let usage_parent_option = usage_node.syntax().parent().and_then(ast::Expr::cast);\n         let usage_parent = match usage_parent_option {\n             Some(u) => u,\n@@ -79,7 +91,7 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n     let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);\n \n-    ctx.add_action(\n+    ctx.add_assist(\n         AssistId(\"inline_local_variable\"),\n         \"inline local variable\",\n         move |edit: &mut AssistBuilder| {\n@@ -93,9 +105,7 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n             }\n             edit.set_cursor(delete_range.start())\n         },\n-    );\n-\n-    ctx.build()\n+    )\n }\n \n #[cfg(test)]"}, {"sha": "0623d44759e5dd3d11d0fb3d04176ed93d036067", "filename": "crates/ra_assists/src/assists/introduce_variable.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fintroduce_variable.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use format_buf::format;\n use hir::db::HirDatabase;\n use ra_syntax::{\n@@ -14,7 +12,23 @@ use test_utils::tested_by;\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn introduce_variable(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+// Assist: introduce_variable\n+//\n+// Extracts subexpression into a variable.\n+//\n+// ```\n+// fn main() {\n+//     <|>(1 + 2)<|> * 4;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let var_name = (1 + 2);\n+//     var_name * 4;\n+// }\n+// ```\n+pub(crate) fn introduce_variable(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     if ctx.frange.range.is_empty() {\n         return None;\n     }\n@@ -29,7 +43,7 @@ pub(crate) fn introduce_variable(mut ctx: AssistCtx<impl HirDatabase>) -> Option\n     if indent.kind() != WHITESPACE {\n         return None;\n     }\n-    ctx.add_action(AssistId(\"introduce_variable\"), \"introduce variable\", move |edit| {\n+    ctx.add_assist(AssistId(\"introduce_variable\"), \"introduce variable\", move |edit| {\n         let mut buf = String::new();\n \n         let cursor_offset = if wrap_in_block {\n@@ -74,9 +88,7 @@ pub(crate) fn introduce_variable(mut ctx: AssistCtx<impl HirDatabase>) -> Option\n             }\n         }\n         edit.set_cursor(anchor_stmt.text_range().start() + cursor_offset);\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n /// Check whether the node is a valid expression which can be extracted to a variable."}, {"sha": "e9f2cae91d3514fbc3de646a5f5ff9779e98c085", "filename": "crates/ra_assists/src/assists/merge_match_arms.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fmerge_match_arms.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,11 +1,33 @@\n-//! FIXME: write short doc here\n-\n use crate::{Assist, AssistCtx, AssistId, TextRange, TextUnit};\n use hir::db::HirDatabase;\n use ra_syntax::ast::{AstNode, MatchArm};\n \n-pub(crate) fn merge_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let current_arm = ctx.node_at_offset::<MatchArm>()?;\n+// Assist: merge_match_arms\n+//\n+// Merges identical match arms.\n+//\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         <|>Action::Move(..) => foo(),\n+//         Action::Stop => foo(),\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move(..) | Action::Stop => foo(),\n+//     }\n+// }\n+// ```\n+pub(crate) fn merge_match_arms(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let current_arm = ctx.find_node_at_offset::<MatchArm>()?;\n \n     // We check if the following match arm matches this one. We could, but don't,\n     // compare to the previous match arm as well.\n@@ -30,7 +52,7 @@ pub(crate) fn merge_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<A\n \n     let cursor_to_end = current_arm.syntax().text_range().end() - ctx.frange.range.start();\n \n-    ctx.add_action(AssistId(\"merge_match_arms\"), \"merge match arms\", |edit| {\n+    ctx.add_assist(AssistId(\"merge_match_arms\"), \"merge match arms\", |edit| {\n         fn contains_placeholder(a: &MatchArm) -> bool {\n             a.pats().any(|x| match x {\n                 ra_syntax::ast::Pat::PlaceholderPat(..) => true,\n@@ -58,9 +80,7 @@ pub(crate) fn merge_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<A\n         edit.target(current_arm.syntax().text_range());\n         edit.replace(TextRange::from_to(start, end), arm);\n         edit.set_cursor(start + offset);\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "3145d7625de6095a0533cf92984ccbd86122bc8e", "filename": "crates/ra_assists/src/assists/move_bounds.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, edit, make, AstNode, NameOwner, TypeBoundsOwner},\n@@ -9,8 +7,23 @@ use ra_syntax::{\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let type_param_list = ctx.node_at_offset::<ast::TypeParamList>()?;\n+// Assist: move_bounds_to_where_clause\n+//\n+// Moves inline type bounds to a where clause.\n+//\n+// ```\n+// fn apply<T, U, <|>F: FnOnce(T) -> U>(f: F, x: T) -> U {\n+//     f(x)\n+// }\n+// ```\n+// ->\n+// ```\n+// fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n+//     f(x)\n+// }\n+// ```\n+pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let type_param_list = ctx.find_node_at_offset::<ast::TypeParamList>()?;\n \n     let mut type_params = type_param_list.type_params();\n     if type_params.all(|p| p.type_bound_list().is_none()) {\n@@ -33,38 +46,30 @@ pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>)\n         _ => return None,\n     };\n \n-    ctx.add_action(\n-        AssistId(\"move_bounds_to_where_clause\"),\n-        \"move_bounds_to_where_clause\",\n-        |edit| {\n-            let new_params = type_param_list\n-                .type_params()\n-                .filter(|it| it.type_bound_list().is_some())\n-                .map(|type_param| {\n-                    let without_bounds = type_param.remove_bounds();\n-                    (type_param, without_bounds)\n-                });\n-\n-            let new_type_param_list = edit::replace_descendants(&type_param_list, new_params);\n-            edit.replace_ast(type_param_list.clone(), new_type_param_list);\n-\n-            let where_clause = {\n-                let predicates = type_param_list.type_params().filter_map(build_predicate);\n-                make::where_clause(predicates)\n-            };\n-\n-            let to_insert = match anchor.prev_sibling_or_token() {\n-                Some(ref elem) if elem.kind() == WHITESPACE => {\n-                    format!(\"{} \", where_clause.syntax())\n-                }\n-                _ => format!(\" {}\", where_clause.syntax()),\n-            };\n-            edit.insert(anchor.text_range().start(), to_insert);\n-            edit.target(type_param_list.syntax().text_range());\n-        },\n-    );\n-\n-    ctx.build()\n+    ctx.add_assist(AssistId(\"move_bounds_to_where_clause\"), \"move_bounds_to_where_clause\", |edit| {\n+        let new_params = type_param_list\n+            .type_params()\n+            .filter(|it| it.type_bound_list().is_some())\n+            .map(|type_param| {\n+                let without_bounds = type_param.remove_bounds();\n+                (type_param, without_bounds)\n+            });\n+\n+        let new_type_param_list = edit::replace_descendants(&type_param_list, new_params);\n+        edit.replace_ast(type_param_list.clone(), new_type_param_list);\n+\n+        let where_clause = {\n+            let predicates = type_param_list.type_params().filter_map(build_predicate);\n+            make::where_clause(predicates)\n+        };\n+\n+        let to_insert = match anchor.prev_sibling_or_token() {\n+            Some(ref elem) if elem.kind() == WHITESPACE => format!(\"{} \", where_clause.syntax()),\n+            _ => format!(\" {}\", where_clause.syntax()),\n+        };\n+        edit.insert(anchor.text_range().start(), to_insert);\n+        edit.target(type_param_list.syntax().text_range());\n+    })\n }\n \n fn build_predicate(param: ast::TypeParam) -> Option<ast::WherePred> {"}, {"sha": "b49ec6172ac35dd6d536c29f2db2dc9abf513ba8", "filename": "crates/ra_assists/src/assists/move_guard.rs", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_guard.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::db::HirDatabase;\n use ra_syntax::{\n     ast,\n@@ -9,16 +7,41 @@ use ra_syntax::{\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn move_guard_to_arm_body(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let match_arm = ctx.node_at_offset::<MatchArm>()?;\n+// Assist: move_guard_to_arm_body\n+//\n+// Moves match guard into match arm body.\n+//\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move { distance } <|>if distance > 10 => foo(),\n+//         _ => (),\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move { distance } => if distance > 10 { foo() },\n+//         _ => (),\n+//     }\n+// }\n+// ```\n+pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let match_arm = ctx.find_node_at_offset::<MatchArm>()?;\n     let guard = match_arm.guard()?;\n     let space_before_guard = guard.syntax().prev_sibling_or_token();\n \n     let guard_conditions = guard.expr()?;\n     let arm_expr = match_arm.expr()?;\n     let buf = format!(\"if {} {{ {} }}\", guard_conditions.syntax().text(), arm_expr.syntax().text());\n \n-    ctx.add_action(AssistId(\"move_guard_to_arm_body\"), \"move guard to arm body\", |edit| {\n+    ctx.add_assist(AssistId(\"move_guard_to_arm_body\"), \"move guard to arm body\", |edit| {\n         edit.target(guard.syntax().text_range());\n         let offseting_amount = match space_before_guard.and_then(|it| it.into_token()) {\n             Some(tok) => {\n@@ -38,12 +61,36 @@ pub(crate) fn move_guard_to_arm_body(mut ctx: AssistCtx<impl HirDatabase>) -> Op\n         edit.set_cursor(\n             arm_expr.syntax().text_range().start() + TextUnit::from(3) - offseting_amount,\n         );\n-    });\n-    ctx.build()\n+    })\n }\n \n-pub(crate) fn move_arm_cond_to_match_guard(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let match_arm: MatchArm = ctx.node_at_offset::<MatchArm>()?;\n+// Assist: move_arm_cond_to_match_guard\n+//\n+// Moves if expression from match arm body into a guard.\n+//\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move { distance } => <|>if distance > 10 { foo() },\n+//         _ => (),\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move { distance } if distance > 10 => foo(),\n+//         _ => (),\n+//     }\n+// }\n+// ```\n+pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let match_arm: MatchArm = ctx.find_node_at_offset::<MatchArm>()?;\n     let last_match_pat = match_arm.pats().last()?;\n \n     let arm_body = match_arm.expr()?;\n@@ -62,7 +109,7 @@ pub(crate) fn move_arm_cond_to_match_guard(mut ctx: AssistCtx<impl HirDatabase>)\n \n     let buf = format!(\" if {}\", cond.syntax().text());\n \n-    ctx.add_action(\n+    ctx.add_assist(\n         AssistId(\"move_arm_cond_to_match_guard\"),\n         \"move condition to match guard\",\n         |edit| {\n@@ -79,8 +126,7 @@ pub(crate) fn move_arm_cond_to_match_guard(mut ctx: AssistCtx<impl HirDatabase>)\n             edit.insert(last_match_pat.syntax().text_range().end(), buf);\n             edit.set_cursor(last_match_pat.syntax().text_range().end() + TextUnit::from(1));\n         },\n-    );\n-    ctx.build()\n+    )\n }\n \n #[cfg(test)]"}, {"sha": "58f7157ae21c9f72527784fa48d6adbfda122614", "filename": "crates/ra_assists/src/assists/raw_string.rs", "status": "modified", "additions": 157, "deletions": 70, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,17 +1,29 @@\n-//! FIXME: write short doc here\n-\n use hir::db::HirDatabase;\n-use ra_syntax::{ast::AstNode, ast::Literal, TextRange, TextUnit};\n+use ra_syntax::{\n+    SyntaxKind::{RAW_STRING, STRING},\n+    TextRange, TextUnit,\n+};\n use rustc_lexer;\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn make_raw_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let literal = ctx.node_at_offset::<Literal>()?;\n-    if literal.token().kind() != ra_syntax::SyntaxKind::STRING {\n-        return None;\n-    }\n-    let token = literal.token();\n+// Assist: make_raw_string\n+//\n+// Adds `r#` to a plain string literal.\n+//\n+// ```\n+// fn main() {\n+//     \"Hello,<|> World!\";\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     r#\"Hello, World!\"#;\n+// }\n+// ```\n+pub(crate) fn make_raw_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let token = ctx.find_token_at_offset(STRING)?;\n     let text = token.text().as_str();\n     let usual_string_range = find_usual_string_range(text)?;\n     let start_of_inside = usual_string_range.start().to_usize() + 1;\n@@ -29,97 +41,131 @@ pub(crate) fn make_raw_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n     if error.is_err() {\n         return None;\n     }\n-    ctx.add_action(AssistId(\"make_raw_string\"), \"make raw string\", |edit| {\n-        edit.target(literal.syntax().text_range());\n+    ctx.add_assist(AssistId(\"make_raw_string\"), \"make raw string\", |edit| {\n+        edit.target(token.text_range());\n         let max_hash_streak = count_hashes(&unescaped);\n         let mut hashes = String::with_capacity(max_hash_streak + 1);\n         for _ in 0..hashes.capacity() {\n             hashes.push('#');\n         }\n-        edit.replace(\n-            literal.syntax().text_range(),\n-            format!(\"r{}\\\"{}\\\"{}\", hashes, unescaped, hashes),\n-        );\n-    });\n-    ctx.build()\n-}\n-\n-fn count_hashes(s: &str) -> usize {\n-    let mut max_hash_streak = 0usize;\n-    for idx in s.match_indices(\"\\\"#\").map(|(i, _)| i) {\n-        let (_, sub) = s.split_at(idx + 1);\n-        let nb_hash = sub.chars().take_while(|c| *c == '#').count();\n-        if nb_hash > max_hash_streak {\n-            max_hash_streak = nb_hash;\n-        }\n-    }\n-    max_hash_streak\n-}\n-\n-fn find_usual_string_range(s: &str) -> Option<TextRange> {\n-    Some(TextRange::from_to(\n-        TextUnit::from(s.find('\"')? as u32),\n-        TextUnit::from(s.rfind('\"')? as u32),\n-    ))\n+        edit.replace(token.text_range(), format!(\"r{}\\\"{}\\\"{}\", hashes, unescaped, hashes));\n+    })\n }\n \n-pub(crate) fn make_usual_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let literal = ctx.node_at_offset::<Literal>()?;\n-    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\n-        return None;\n-    }\n-    let token = literal.token();\n+// Assist: make_usual_string\n+//\n+// Turns a raw string into a plain string.\n+//\n+// ```\n+// fn main() {\n+//     r#\"Hello,<|> \"World!\"\"#;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     \"Hello, \\\"World!\\\"\";\n+// }\n+// ```\n+pub(crate) fn make_usual_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let text = token.text().as_str();\n     let usual_string_range = find_usual_string_range(text)?;\n-    ctx.add_action(AssistId(\"make_usual_string\"), \"make usual string\", |edit| {\n-        edit.target(literal.syntax().text_range());\n+    ctx.add_assist(AssistId(\"make_usual_string\"), \"make usual string\", |edit| {\n+        edit.target(token.text_range());\n         // parse inside string to escape `\"`\n         let start_of_inside = usual_string_range.start().to_usize() + 1;\n         let end_of_inside = usual_string_range.end().to_usize();\n         let inside_str = &text[start_of_inside..end_of_inside];\n         let escaped = inside_str.escape_default().to_string();\n-        edit.replace(literal.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n-    });\n-    ctx.build()\n+        edit.replace(token.text_range(), format!(\"\\\"{}\\\"\", escaped));\n+    })\n }\n \n-pub(crate) fn add_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let literal = ctx.node_at_offset::<Literal>()?;\n-    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\n-        return None;\n-    }\n-    ctx.add_action(AssistId(\"add_hash\"), \"add hash to raw string\", |edit| {\n-        edit.target(literal.syntax().text_range());\n-        edit.insert(literal.syntax().text_range().start() + TextUnit::of_char('r'), \"#\");\n-        edit.insert(literal.syntax().text_range().end(), \"#\");\n-    });\n-    ctx.build()\n+// Assist: add_hash\n+//\n+// Adds a hash to a raw string literal.\n+//\n+// ```\n+// fn main() {\n+//     r#\"Hello,<|> World!\"#;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     r##\"Hello, World!\"##;\n+// }\n+// ```\n+pub(crate) fn add_hash(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let token = ctx.find_token_at_offset(RAW_STRING)?;\n+    ctx.add_assist(AssistId(\"add_hash\"), \"add hash to raw string\", |edit| {\n+        edit.target(token.text_range());\n+        edit.insert(token.text_range().start() + TextUnit::of_char('r'), \"#\");\n+        edit.insert(token.text_range().end(), \"#\");\n+    })\n }\n \n-pub(crate) fn remove_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let literal = ctx.node_at_offset::<Literal>()?;\n-    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\n-        return None;\n-    }\n-    let token = literal.token();\n+// Assist: remove_hash\n+//\n+// Removes a hash from a raw string literal.\n+//\n+// ```\n+// fn main() {\n+//     r#\"Hello,<|> World!\"#;\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     r\"Hello, World!\";\n+// }\n+// ```\n+pub(crate) fn remove_hash(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let text = token.text().as_str();\n     if text.starts_with(\"r\\\"\") {\n         // no hash to remove\n         return None;\n     }\n-    ctx.add_action(AssistId(\"remove_hash\"), \"remove hash from raw string\", |edit| {\n-        edit.target(literal.syntax().text_range());\n+    ctx.add_assist(AssistId(\"remove_hash\"), \"remove hash from raw string\", |edit| {\n+        edit.target(token.text_range());\n         let result = &text[2..text.len() - 1];\n-        let result = if result.starts_with(\"\\\"\") {\n+        let result = if result.starts_with('\\\"') {\n             // no more hash, escape\n             let internal_str = &result[1..result.len() - 1];\n             format!(\"\\\"{}\\\"\", internal_str.escape_default().to_string())\n         } else {\n             result.to_owned()\n         };\n-        edit.replace(literal.syntax().text_range(), format!(\"r{}\", result));\n-    });\n-    ctx.build()\n+        edit.replace(token.text_range(), format!(\"r{}\", result));\n+    })\n+}\n+\n+fn count_hashes(s: &str) -> usize {\n+    let mut max_hash_streak = 0usize;\n+    for idx in s.match_indices(\"\\\"#\").map(|(i, _)| i) {\n+        let (_, sub) = s.split_at(idx + 1);\n+        let nb_hash = sub.chars().take_while(|c| *c == '#').count();\n+        if nb_hash > max_hash_streak {\n+            max_hash_streak = nb_hash;\n+        }\n+    }\n+    max_hash_streak\n+}\n+\n+fn find_usual_string_range(s: &str) -> Option<TextRange> {\n+    let left_quote = s.find('\"')?;\n+    let right_quote = s.rfind('\"')?;\n+    if left_quote == right_quote {\n+        // `s` only contains one quote\n+        None\n+    } else {\n+        Some(TextRange::from_to(\n+            TextUnit::from(left_quote as u32),\n+            TextUnit::from(right_quote as u32),\n+        ))\n+    }\n }\n \n #[cfg(test)]\n@@ -158,6 +204,23 @@ string\"#;\n         )\n     }\n \n+    #[test]\n+    fn make_raw_string_works_inside_macros() {\n+        check_assist(\n+            make_raw_string,\n+            r#\"\n+            fn f() {\n+                format!(<|>\"x = {}\", 92)\n+            }\n+            \"#,\n+            r##\"\n+            fn f() {\n+                format!(<|>r#\"x = {}\"#, 92)\n+            }\n+            \"##,\n+        )\n+    }\n+\n     #[test]\n     fn make_raw_string_hashes_inside_works() {\n         check_assist(\n@@ -211,6 +274,30 @@ string\"###;\n         )\n     }\n \n+    #[test]\n+    fn make_raw_string_not_works_on_partial_string() {\n+        check_assist_not_applicable(\n+            make_raw_string,\n+            r#\"\n+            fn f() {\n+                let s = \"foo<|>\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn make_usual_string_not_works_on_partial_string() {\n+        check_assist_not_applicable(\n+            make_usual_string,\n+            r#\"\n+            fn main() {\n+                let s = r#\"bar<|>\n+            }\n+            \"#,\n+        )\n+    }\n+\n     #[test]\n     fn add_hash_target() {\n         check_assist_target("}, {"sha": "aedf8747f22a79dc2d87ee2cab1f782b626c202d", "filename": "crates/ra_assists/src/assists/remove_dbg.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fremove_dbg.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,14 +1,28 @@\n-//! FIXME: write short doc here\n-\n-use crate::{Assist, AssistCtx, AssistId};\n use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode},\n     TextUnit, T,\n };\n \n-pub(crate) fn remove_dbg(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let macro_call = ctx.node_at_offset::<ast::MacroCall>()?;\n+use crate::{Assist, AssistCtx, AssistId};\n+\n+// Assist: remove_dbg\n+//\n+// Removes `dbg!()` macro call.\n+//\n+// ```\n+// fn main() {\n+//     <|>dbg!(92);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     92;\n+// }\n+// ```\n+pub(crate) fn remove_dbg(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let macro_call = ctx.find_node_at_offset::<ast::MacroCall>()?;\n \n     if !is_valid_macrocall(&macro_call, \"dbg\")? {\n         return None;\n@@ -44,13 +58,11 @@ pub(crate) fn remove_dbg(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist>\n         text.slice(without_parens).to_string()\n     };\n \n-    ctx.add_action(AssistId(\"remove_dbg\"), \"remove dbg!()\", |edit| {\n+    ctx.add_assist(AssistId(\"remove_dbg\"), \"remove dbg!()\", |edit| {\n         edit.target(macro_call.syntax().text_range());\n         edit.replace(macro_range, macro_content);\n         edit.set_cursor(cursor_pos);\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n /// Verifies that the given macro_call actually matches the given name"}, {"sha": "dff84d86516cba7aaaa26c8ccc399bf3190c7a5a", "filename": "crates/ra_assists/src/assists/replace_if_let_with_match.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Freplace_if_let_with_match.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,14 +1,38 @@\n-//! FIXME: write short doc here\n-\n use format_buf::format;\n use hir::db::HirDatabase;\n use ra_fmt::extract_trivial_expression;\n use ra_syntax::{ast, AstNode};\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn replace_if_let_with_match(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let if_expr: ast::IfExpr = ctx.node_at_offset()?;\n+// Assist: replace_if_let_with_match\n+//\n+// Replaces `if let` with an else branch with a `match` expression.\n+//\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     <|>if let Action::Move { distance } = action {\n+//         foo(distance)\n+//     } else {\n+//         bar()\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move { distance } => foo(distance),\n+//         _ => bar(),\n+//     }\n+// }\n+// ```\n+pub(crate) fn replace_if_let_with_match(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     let cond = if_expr.condition()?;\n     let pat = cond.pat()?;\n     let expr = cond.expr()?;\n@@ -18,14 +42,12 @@ pub(crate) fn replace_if_let_with_match(mut ctx: AssistCtx<impl HirDatabase>) ->\n         ast::ElseBranch::IfExpr(_) => return None,\n     };\n \n-    ctx.add_action(AssistId(\"replace_if_let_with_match\"), \"replace with match\", |edit| {\n+    ctx.add_assist(AssistId(\"replace_if_let_with_match\"), \"replace with match\", |edit| {\n         let match_expr = build_match_expr(expr, pat, then_block, else_block);\n         edit.target(if_expr.syntax().text_range());\n         edit.replace_node_and_indent(if_expr.syntax(), match_expr);\n         edit.set_cursor(if_expr.syntax().text_range().start())\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n fn build_match_expr("}, {"sha": "5f8d6b0be1ff11b9a3d7359de8af24c8fcd51377", "filename": "crates/ra_assists/src/assists/split_import.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fassists%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fsplit_import.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,14 +1,23 @@\n-//! FIXME: write short doc here\n-\n use std::iter::successors;\n \n use hir::db::HirDatabase;\n use ra_syntax::{ast, AstNode, TextUnit, T};\n \n use crate::{Assist, AssistCtx, AssistId};\n \n-pub(crate) fn split_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let colon_colon = ctx.token_at_offset().find(|leaf| leaf.kind() == T![::])?;\n+// Assist: split_import\n+//\n+// Wraps the tail of import into braces.\n+//\n+// ```\n+// use std::<|>collections::HashMap;\n+// ```\n+// ->\n+// ```\n+// use std::{collections::HashMap};\n+// ```\n+pub(crate) fn split_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let colon_colon = ctx.find_token_at_offset(T![::])?;\n     let path = ast::Path::cast(colon_colon.parent())?;\n     let top_path = successors(Some(path), |it| it.parent_path()).last()?;\n \n@@ -23,14 +32,12 @@ pub(crate) fn split_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assis\n         None => top_path.syntax().text_range().end(),\n     };\n \n-    ctx.add_action(AssistId(\"split_import\"), \"split import\", |edit| {\n+    ctx.add_assist(AssistId(\"split_import\"), \"split import\", |edit| {\n         edit.target(colon_colon.text_range());\n         edit.insert(l_curly, \"{\");\n         edit.insert(r_curly, \"}\");\n         edit.set_cursor(l_curly + TextUnit::of_str(\"{\"));\n-    });\n-\n-    ctx.build()\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "6e1e3de843e60167ed45256c854f910e5112da3c", "filename": "crates/ra_assists/src/doc_tests.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,34 @@\n+//! Each assist definition has a special comment, which specifies docs and\n+//! example.\n+//!\n+//! We collect all the example and write the as tests in this module.\n+\n+mod generated;\n+\n+use hir::mock::MockDatabase;\n+use ra_db::FileRange;\n+use test_utils::{assert_eq_text, extract_range_or_offset};\n+\n+fn check(assist_id: &str, before: &str, after: &str) {\n+    let (selection, before) = extract_range_or_offset(before);\n+    let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+    let frange = FileRange { file_id, range: selection.into() };\n+\n+    let (_assist_id, action) = crate::assists(&db, frange)\n+        .into_iter()\n+        .find(|(id, _)| id.id.0 == assist_id)\n+        .unwrap_or_else(|| {\n+            panic!(\n+                \"\\n\\nAssist is not applicable: {}\\nAvailable assists: {}\",\n+                assist_id,\n+                crate::assists(&db, frange)\n+                    .into_iter()\n+                    .map(|(id, _)| id.id.0)\n+                    .collect::<Vec<_>>()\n+                    .join(\", \")\n+            )\n+        });\n+\n+    let actual = action.edit.apply(&before);\n+    assert_eq_text!(after, &actual);\n+}"}, {"sha": "1bee76f59a33674daa8d060e1a3e9860cc71f5f2", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,526 @@\n+//! Generated file, do not edit by hand, see `crate/ra_tools/src/codegen`\n+\n+use super::check;\n+\n+#[test]\n+fn doctest_add_derive() {\n+    check(\n+        \"add_derive\",\n+        r#####\"\n+struct Point {\n+    x: u32,\n+    y: u32,<|>\n+}\n+\"#####,\n+        r#####\"\n+#[derive()]\n+struct Point {\n+    x: u32,\n+    y: u32,\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_add_explicit_type() {\n+    check(\n+        \"add_explicit_type\",\n+        r#####\"\n+fn main() {\n+    let x<|> = 92;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let x: i32 = 92;\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_add_hash() {\n+    check(\n+        \"add_hash\",\n+        r#####\"\n+fn main() {\n+    r#\"Hello,<|> World!\"#;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    r##\"Hello, World!\"##;\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_add_impl() {\n+    check(\n+        \"add_impl\",\n+        r#####\"\n+struct Ctx<T: Clone> {\n+     data: T,<|>\n+}\n+\"#####,\n+        r#####\"\n+struct Ctx<T: Clone> {\n+     data: T,\n+}\n+\n+impl<T: Clone> Ctx<T> {\n+\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_add_impl_default_members() {\n+    check(\n+        \"add_impl_default_members\",\n+        r#####\"\n+trait T {\n+    Type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl T for () {\n+    Type X = ();\n+    fn foo(&self) {}<|>\n+\n+}\n+\"#####,\n+        r#####\"\n+trait T {\n+    Type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl T for () {\n+    Type X = ();\n+    fn foo(&self) {}\n+    fn bar(&self) {}\n+\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_add_impl_missing_members() {\n+    check(\n+        \"add_impl_missing_members\",\n+        r#####\"\n+trait T {\n+    Type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl T for () {<|>\n+\n+}\n+\"#####,\n+        r#####\"\n+trait T {\n+    Type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl T for () {\n+    fn foo(&self) { unimplemented!() }\n+\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_add_import() {\n+    check(\n+        \"add_import\",\n+        r#####\"\n+fn process(map: std::collections::<|>HashMap<String, String>) {}\n+\"#####,\n+        r#####\"\n+use std::collections::HashMap;\n+\n+fn process(map: HashMap<String, String>) {}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_apply_demorgan() {\n+    check(\n+        \"apply_demorgan\",\n+        r#####\"\n+fn main() {\n+    if x != 4 ||<|> !y {}\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    if !(x == 4 && y) {}\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_change_visibility() {\n+    check(\n+        \"change_visibility\",\n+        r#####\"\n+<|>fn frobnicate() {}\n+\"#####,\n+        r#####\"\n+pub(crate) fn frobnicate() {}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_convert_to_guarded_return() {\n+    check(\n+        \"convert_to_guarded_return\",\n+        r#####\"\n+fn main() {\n+    <|>if cond {\n+        foo();\n+        bar();\n+    }\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    if !cond {\n+        return;\n+    }\n+    foo();\n+    bar();\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_fill_match_arms() {\n+    check(\n+        \"fill_match_arms\",\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        <|>\n+    }\n+}\n+\"#####,\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } => (),\n+        Action::Stop => (),\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_flip_binexpr() {\n+    check(\n+        \"flip_binexpr\",\n+        r#####\"\n+fn main() {\n+    let _ = 90 +<|> 2;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let _ = 2 + 90;\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_flip_comma() {\n+    check(\n+        \"flip_comma\",\n+        r#####\"\n+fn main() {\n+    ((1, 2),<|> (3, 4));\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    ((3, 4), (1, 2));\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_flip_trait_bound() {\n+    check(\n+        \"flip_trait_bound\",\n+        r#####\"\n+fn foo<T: Clone +<|> Copy>() { }\n+\"#####,\n+        r#####\"\n+fn foo<T: Copy + Clone>() { }\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_inline_local_variable() {\n+    check(\n+        \"inline_local_variable\",\n+        r#####\"\n+fn main() {\n+    let x<|> = 1 + 2;\n+    x * 4;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    (1 + 2) * 4;\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_introduce_variable() {\n+    check(\n+        \"introduce_variable\",\n+        r#####\"\n+fn main() {\n+    <|>(1 + 2)<|> * 4;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let var_name = (1 + 2);\n+    var_name * 4;\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_make_raw_string() {\n+    check(\n+        \"make_raw_string\",\n+        r#####\"\n+fn main() {\n+    \"Hello,<|> World!\";\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    r#\"Hello, World!\"#;\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_make_usual_string() {\n+    check(\n+        \"make_usual_string\",\n+        r#####\"\n+fn main() {\n+    r#\"Hello,<|> \"World!\"\"#;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    \"Hello, \\\"World!\\\"\";\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_merge_match_arms() {\n+    check(\n+        \"merge_match_arms\",\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        <|>Action::Move(..) => foo(),\n+        Action::Stop => foo(),\n+    }\n+}\n+\"#####,\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move(..) | Action::Stop => foo(),\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_move_arm_cond_to_match_guard() {\n+    check(\n+        \"move_arm_cond_to_match_guard\",\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } => <|>if distance > 10 { foo() },\n+        _ => (),\n+    }\n+}\n+\"#####,\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } if distance > 10 => foo(),\n+        _ => (),\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_move_bounds_to_where_clause() {\n+    check(\n+        \"move_bounds_to_where_clause\",\n+        r#####\"\n+fn apply<T, U, <|>F: FnOnce(T) -> U>(f: F, x: T) -> U {\n+    f(x)\n+}\n+\"#####,\n+        r#####\"\n+fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n+    f(x)\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_move_guard_to_arm_body() {\n+    check(\n+        \"move_guard_to_arm_body\",\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } <|>if distance > 10 => foo(),\n+        _ => (),\n+    }\n+}\n+\"#####,\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } => if distance > 10 { foo() },\n+        _ => (),\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_remove_dbg() {\n+    check(\n+        \"remove_dbg\",\n+        r#####\"\n+fn main() {\n+    <|>dbg!(92);\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    92;\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_remove_hash() {\n+    check(\n+        \"remove_hash\",\n+        r#####\"\n+fn main() {\n+    r#\"Hello,<|> World!\"#;\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    r\"Hello, World!\";\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_replace_if_let_with_match() {\n+    check(\n+        \"replace_if_let_with_match\",\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    <|>if let Action::Move { distance } = action {\n+        foo(distance)\n+    } else {\n+        bar()\n+    }\n+}\n+\"#####,\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } => foo(distance),\n+        _ => bar(),\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_split_import() {\n+    check(\n+        \"split_import\",\n+        r#####\"\n+use std::<|>collections::HashMap;\n+\"#####,\n+        r#####\"\n+use std::{collections::HashMap};\n+\"#####,\n+    )\n+}"}, {"sha": "38599d4f173c6769ae4d40542ff39cd0e7f98936", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 29, "deletions": 66, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -7,15 +7,16 @@\n \n mod assist_ctx;\n mod marks;\n+#[cfg(test)]\n+mod doc_tests;\n \n use hir::db::HirDatabase;\n-use itertools::Itertools;\n use ra_db::FileRange;\n use ra_syntax::{TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n \n pub(crate) use crate::assist_ctx::{Assist, AssistCtx};\n-pub use crate::assists::auto_import::auto_import_text_edit;\n+pub use crate::assists::add_import::auto_import_text_edit;\n \n /// Unique identifier of the assist, should not be shown to the user\n /// directly.\n@@ -36,7 +37,7 @@ pub struct AssistAction {\n     pub target: Option<TextRange>,\n }\n \n-/// Return all the assists eapplicable at the given position.\n+/// Return all the assists applicable at the given position.\n ///\n /// Assists are returned in the \"unresolved\" state, that is only labels are\n /// returned, without actual edits.\n@@ -49,10 +50,10 @@ where\n             .iter()\n             .filter_map(|f| f(ctx.clone()))\n             .map(|a| match a {\n-                Assist::Unresolved(labels) => labels,\n-                Assist::Resolved(..) => unreachable!(),\n+                Assist::Unresolved { label } => label,\n+                Assist::Resolved { .. } => unreachable!(),\n             })\n-            .concat()\n+            .collect()\n     })\n }\n \n@@ -71,10 +72,10 @@ where\n             .iter()\n             .filter_map(|f| f(ctx.clone()))\n             .map(|a| match a {\n-                Assist::Resolved(labels_actions) => labels_actions,\n-                Assist::Unresolved(..) => unreachable!(),\n+                Assist::Resolved { label, action } => (label, action),\n+                Assist::Unresolved { .. } => unreachable!(),\n             })\n-            .concat();\n+            .collect::<Vec<_>>();\n         a.sort_by(|a, b| match (a.1.target, b.1.target) {\n             (Some(a), Some(b)) => a.len().cmp(&b.len()),\n             (Some(_), None) => Ordering::Less,\n@@ -95,6 +96,7 @@ mod assists {\n     mod apply_demorgan;\n     mod flip_comma;\n     mod flip_binexpr;\n+    mod flip_trait_bound;\n     mod change_visibility;\n     mod fill_match_arms;\n     mod merge_match_arms;\n@@ -104,7 +106,7 @@ mod assists {\n     mod replace_if_let_with_match;\n     mod split_import;\n     mod remove_dbg;\n-    pub(crate) mod auto_import;\n+    pub(crate) mod add_import;\n     mod add_missing_impl_members;\n     mod move_guard;\n     mod move_bounds;\n@@ -121,11 +123,12 @@ mod assists {\n             merge_match_arms::merge_match_arms,\n             flip_comma::flip_comma,\n             flip_binexpr::flip_binexpr,\n+            flip_trait_bound::flip_trait_bound,\n             introduce_variable::introduce_variable,\n             replace_if_let_with_match::replace_if_let_with_match,\n             split_import::split_import,\n             remove_dbg::remove_dbg,\n-            auto_import::auto_import,\n+            add_import::add_import,\n             add_missing_impl_members::add_missing_impl_members,\n             add_missing_impl_members::add_missing_default_members,\n             inline_local_variable::inline_local_varialbe,\n@@ -154,52 +157,18 @@ mod helpers {\n         assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n         before: &str,\n         after: &str,\n-    ) {\n-        check_assist_nth_action(assist, before, after, 0)\n-    }\n-\n-    pub(crate) fn check_assist_range(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n-        before: &str,\n-        after: &str,\n-    ) {\n-        check_assist_range_nth_action(assist, before, after, 0)\n-    }\n-\n-    pub(crate) fn check_assist_target(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n-        before: &str,\n-        target: &str,\n-    ) {\n-        check_assist_target_nth_action(assist, before, target, 0)\n-    }\n-\n-    pub(crate) fn check_assist_range_target(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n-        before: &str,\n-        target: &str,\n-    ) {\n-        check_assist_range_target_nth_action(assist, before, target, 0)\n-    }\n-\n-    pub(crate) fn check_assist_nth_action(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n-        before: &str,\n-        after: &str,\n-        index: usize,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let labels_actions = match assist {\n-            Assist::Unresolved(_) => unreachable!(),\n-            Assist::Resolved(labels_actions) => labels_actions,\n+        let action = match assist {\n+            Assist::Unresolved { .. } => unreachable!(),\n+            Assist::Resolved { action, .. } => action,\n         };\n \n-        let (_, action) = labels_actions.get(index).expect(\"expect assist action at index\");\n         let actual = action.edit.apply(&before);\n         let actual_cursor_pos = match action.cursor_position {\n             None => action\n@@ -212,69 +181,63 @@ mod helpers {\n         assert_eq_text!(after, &actual);\n     }\n \n-    pub(crate) fn check_assist_range_nth_action(\n+    pub(crate) fn check_assist_range(\n         assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n         before: &str,\n         after: &str,\n-        index: usize,\n     ) {\n         let (range, before) = extract_range(before);\n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let labels_actions = match assist {\n-            Assist::Unresolved(_) => unreachable!(),\n-            Assist::Resolved(labels_actions) => labels_actions,\n+        let action = match assist {\n+            Assist::Unresolved { .. } => unreachable!(),\n+            Assist::Resolved { action, .. } => action,\n         };\n \n-        let (_, action) = labels_actions.get(index).expect(\"expect assist action at index\");\n         let mut actual = action.edit.apply(&before);\n         if let Some(pos) = action.cursor_position {\n             actual = add_cursor(&actual, pos);\n         }\n         assert_eq_text!(after, &actual);\n     }\n \n-    pub(crate) fn check_assist_target_nth_action(\n+    pub(crate) fn check_assist_target(\n         assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n         before: &str,\n         target: &str,\n-        index: usize,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let labels_actions = match assist {\n-            Assist::Unresolved(_) => unreachable!(),\n-            Assist::Resolved(labels_actions) => labels_actions,\n+        let action = match assist {\n+            Assist::Unresolved { .. } => unreachable!(),\n+            Assist::Resolved { action, .. } => action,\n         };\n \n-        let (_, action) = labels_actions.get(index).expect(\"expect assist action at index\");\n         let range = action.target.expect(\"expected target on action\");\n         assert_eq_text!(&before[range.start().to_usize()..range.end().to_usize()], target);\n     }\n \n-    pub(crate) fn check_assist_range_target_nth_action(\n+    pub(crate) fn check_assist_range_target(\n         assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n         before: &str,\n         target: &str,\n-        index: usize,\n     ) {\n         let (range, before) = extract_range(before);\n         let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let labels_actions = match assist {\n-            Assist::Unresolved(_) => unreachable!(),\n-            Assist::Resolved(labels_actions) => labels_actions,\n+        let action = match assist {\n+            Assist::Unresolved { .. } => unreachable!(),\n+            Assist::Resolved { action, .. } => action,\n         };\n \n-        let (_, action) = labels_actions.get(index).expect(\"expect assist action at index\");\n         let range = action.target.expect(\"expected target on action\");\n         assert_eq_text!(&before[range.start().to_usize()..range.end().to_usize()], target);\n     }"}, {"sha": "0d1ab48438d02d717eef8fe36988d2d52c9e6d50", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -134,10 +134,7 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n     ) -> Option<FileId> {\n         let path = {\n             let mut path = self.0.file_relative_path(anchor);\n-            // Workaround for relative path API: turn `lib.rs` into ``.\n-            if !path.pop() {\n-                path = RelativePathBuf::default();\n-            }\n+            assert!(path.pop());\n             path.push(relative_path);\n             path.normalize()\n         };"}, {"sha": "5df371bc0f97ee682ae5cb050d438b178ec185b2", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -19,12 +19,14 @@ ra_cfg = { path = \"../ra_cfg\" }\n ra_db = { path = \"../ra_db\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n+hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n+hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n test_utils = { path = \"../test_utils\" }\n ra_prof = { path = \"../ra_prof\" }\n \n-chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\" }\n-chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\" }\n+chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"8314f2fcec8582a58c24b638f1a259d4145a0809\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"8314f2fcec8582a58c24b638f1a259d4145a0809\" }\n+chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"8314f2fcec8582a58c24b638f1a259d4145a0809\" }\n lalrpop-intern = \"0.15.1\"\n \n [dev-dependencies]"}, {"sha": "4fa2062bdba16ab5e627ccc0c68e8c1ec7ce65c7", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -3,13 +3,14 @@\n \n use std::sync::Arc;\n \n+use hir_def::{type_ref::TypeRef, LocalEnumVariantId};\n+use hir_expand::name::AsName;\n use ra_arena::{impl_arena_id, Arena, RawId};\n use ra_syntax::ast::{self, NameOwner, StructKind, TypeAscriptionOwner};\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    type_ref::TypeRef,\n-    AsName, Enum, EnumVariant, FieldSource, HasSource, Module, Name, Source, Struct, StructField,\n+    Enum, EnumVariant, FieldSource, HasSource, Module, Name, Source, Struct, StructField,\n };\n \n impl Struct {\n@@ -67,7 +68,7 @@ impl EnumVariant {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n     pub(crate) name: Option<Name>,\n-    pub(crate) variants: Arena<EnumVariantId, EnumVariantData>,\n+    pub(crate) variants: Arena<LocalEnumVariantId, EnumVariantData>,\n }\n \n impl EnumData {\n@@ -84,10 +85,6 @@ impl EnumData {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct EnumVariantId(RawId);\n-impl_arena_id!(EnumVariantId);\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub(crate) struct EnumVariantData {\n     pub(crate) name: Option<Name>,"}, {"sha": "b32aa145ea8b867884993e59947cd7c0d8820c8c", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 61, "deletions": 121, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -5,11 +5,17 @@ pub(crate) mod docs;\n \n use std::sync::Arc;\n \n-use ra_db::{CrateId, Edition, FileId};\n+use hir_def::{\n+    builtin_type::BuiltinType,\n+    type_ref::{Mutability, TypeRef},\n+    CrateModuleId, LocalEnumVariantId, ModuleId,\n+};\n+use hir_expand::name::{self, AsName};\n+use ra_db::{CrateId, Edition};\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n-    adt::{EnumVariantId, StructFieldId, VariantDef},\n+    adt::{StructFieldId, VariantDef},\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     diagnostics::DiagnosticSink,\n     expr::{validation::ExprValidator, Body, BodySourceMap},\n@@ -19,20 +25,11 @@ use crate::{\n         TypeAliasId,\n     },\n     impl_block::ImplBlock,\n-    name::{\n-        BOOL, CHAR, F32, F64, I128, I16, I32, I64, I8, ISIZE, SELF_TYPE, STR, U128, U16, U32, U64,\n-        U8, USIZE,\n-    },\n-    nameres::{CrateModuleId, ImportId, ModuleScope, Namespace},\n+    nameres::{ImportId, ModuleScope, Namespace},\n     resolve::{Resolver, Scope, TypeNs},\n     traits::TraitData,\n-    ty::{\n-        primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness},\n-        InferenceResult, TraitRef,\n-    },\n-    type_ref::Mutability,\n-    type_ref::TypeRef,\n-    AsName, AstId, Either, HasSource, Name, Ty,\n+    ty::{InferenceResult, TraitRef},\n+    Either, HasSource, Name, Ty,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -67,8 +64,7 @@ impl Crate {\n \n     pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n         let module_id = db.crate_def_map(self).root();\n-        let module = Module { krate: self, module_id };\n-        Some(module)\n+        Some(Module::new(self, module_id))\n     }\n \n     pub fn edition(self, db: &impl DefDatabase) -> Edition {\n@@ -83,43 +79,7 @@ impl Crate {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Module {\n-    pub(crate) krate: Crate,\n-    pub(crate) module_id: CrateModuleId,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum BuiltinType {\n-    Char,\n-    Bool,\n-    Str,\n-    Int(IntTy),\n-    Float(FloatTy),\n-}\n-\n-impl BuiltinType {\n-    #[rustfmt::skip]\n-    pub(crate) const ALL: &'static [(Name, BuiltinType)] = &[\n-        (CHAR, BuiltinType::Char),\n-        (BOOL, BuiltinType::Bool),\n-        (STR, BuiltinType::Str),\n-\n-        (ISIZE, BuiltinType::Int(IntTy { signedness: Signedness::Signed, bitness: IntBitness::Xsize })),\n-        (I8,    BuiltinType::Int(IntTy { signedness: Signedness::Signed, bitness: IntBitness::X8 })),\n-        (I16,   BuiltinType::Int(IntTy { signedness: Signedness::Signed, bitness: IntBitness::X16 })),\n-        (I32,   BuiltinType::Int(IntTy { signedness: Signedness::Signed, bitness: IntBitness::X32 })),\n-        (I64,   BuiltinType::Int(IntTy { signedness: Signedness::Signed, bitness: IntBitness::X64 })),\n-        (I128,  BuiltinType::Int(IntTy { signedness: Signedness::Signed, bitness: IntBitness::X128 })),\n-\n-        (USIZE, BuiltinType::Int(IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize })),\n-        (U8,    BuiltinType::Int(IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X8 })),\n-        (U16,   BuiltinType::Int(IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X16 })),\n-        (U32,   BuiltinType::Int(IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X32 })),\n-        (U64,   BuiltinType::Int(IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X64 })),\n-        (U128,  BuiltinType::Int(IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X128 })),\n-\n-        (F32, BuiltinType::Float(FloatTy { bitness: FloatBitness::X32 })),\n-        (F64, BuiltinType::Float(FloatTy { bitness: FloatBitness::X64 })),\n-    ];\n+    pub(crate) id: ModuleId,\n }\n \n /// The defs which can be visible in the module.\n@@ -148,39 +108,19 @@ impl_froms!(\n     BuiltinType\n );\n \n-pub enum ModuleSource {\n-    SourceFile(ast::SourceFile),\n-    Module(ast::Module),\n-}\n+pub use hir_def::ModuleSource;\n \n-impl ModuleSource {\n-    pub(crate) fn new(\n-        db: &(impl DefDatabase + AstDatabase),\n-        file_id: Option<FileId>,\n-        decl_id: Option<AstId<ast::Module>>,\n-    ) -> ModuleSource {\n-        match (file_id, decl_id) {\n-            (Some(file_id), _) => {\n-                let source_file = db.parse(file_id).tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-            (None, Some(item_id)) => {\n-                let module = item_id.to_node(db);\n-                assert!(module.item_list().is_some(), \"expected inline module\");\n-                ModuleSource::Module(module)\n-            }\n-            (None, None) => panic!(),\n-        }\n+impl Module {\n+    pub(crate) fn new(krate: Crate, crate_module_id: CrateModuleId) -> Module {\n+        Module { id: ModuleId { krate: krate.crate_id, module_id: crate_module_id } }\n     }\n-}\n \n-impl Module {\n     /// Name of this module.\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let parent = def_map[self.module_id].parent?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let parent = def_map[self.id.module_id].parent?;\n         def_map[parent].children.iter().find_map(|(name, module_id)| {\n-            if *module_id == self.module_id {\n+            if *module_id == self.id.module_id {\n                 Some(name.clone())\n             } else {\n                 None\n@@ -200,29 +140,29 @@ impl Module {\n     }\n \n     /// Returns the crate this module is part of.\n-    pub fn krate(self, _db: &impl DefDatabase) -> Option<Crate> {\n-        Some(self.krate)\n+    pub fn krate(self) -> Crate {\n+        Crate { crate_id: self.id.krate }\n     }\n \n     /// Topmost parent of this module. Every module has a `crate_root`, but some\n     /// might be missing `krate`. This can happen if a module's file is not included\n     /// in the module tree of any target in `Cargo.toml`.\n     pub fn crate_root(self, db: &impl DefDatabase) -> Module {\n-        let def_map = db.crate_def_map(self.krate);\n+        let def_map = db.crate_def_map(self.krate());\n         self.with_module_id(def_map.root())\n     }\n \n     /// Finds a child module with the specified name.\n     pub fn child(self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let child_id = def_map[self.module_id].children.get(name)?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let child_id = def_map[self.id.module_id].children.get(name)?;\n         Some(self.with_module_id(*child_id))\n     }\n \n     /// Iterates over all child modules.\n     pub fn children(self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let children = def_map[self.module_id]\n+        let def_map = db.crate_def_map(self.krate());\n+        let children = def_map[self.id.module_id]\n             .children\n             .iter()\n             .map(|(_, module_id)| self.with_module_id(*module_id))\n@@ -232,8 +172,8 @@ impl Module {\n \n     /// Finds a parent module.\n     pub fn parent(self, db: &impl DefDatabase) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let parent_id = def_map[self.module_id].parent?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let parent_id = def_map[self.id.module_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n \n@@ -249,11 +189,11 @@ impl Module {\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub fn scope(self, db: &impl HirDatabase) -> ModuleScope {\n-        db.crate_def_map(self.krate)[self.module_id].scope.clone()\n+        db.crate_def_map(self.krate())[self.id.module_id].scope.clone()\n     }\n \n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n-        db.crate_def_map(self.krate).add_diagnostics(db, self.module_id, sink);\n+        db.crate_def_map(self.krate()).add_diagnostics(db, self.id.module_id, sink);\n         for decl in self.declarations(db) {\n             match decl {\n                 crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n@@ -277,13 +217,13 @@ impl Module {\n     }\n \n     pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        let def_map = db.crate_def_map(self.krate);\n-        Resolver::default().push_module_scope(def_map, self.module_id)\n+        let def_map = db.crate_def_map(self.krate());\n+        Resolver::default().push_module_scope(def_map, self.id.module_id)\n     }\n \n     pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n-        let def_map = db.crate_def_map(self.krate);\n-        def_map[self.module_id]\n+        let def_map = db.crate_def_map(self.krate());\n+        def_map[self.id.module_id]\n             .scope\n             .entries()\n             .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n@@ -303,7 +243,7 @@ impl Module {\n     }\n \n     fn with_module_id(self, module_id: CrateModuleId) -> Module {\n-        Module { module_id, krate: self.krate }\n+        Module::new(self.krate(), module_id)\n     }\n }\n \n@@ -340,11 +280,11 @@ pub struct Struct {\n \n impl Struct {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n@@ -402,7 +342,7 @@ impl Union {\n     }\n \n     pub fn module(self, db: &impl HirDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n@@ -428,11 +368,11 @@ pub struct Enum {\n \n impl Enum {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n@@ -470,7 +410,7 @@ impl Enum {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct EnumVariant {\n     pub(crate) parent: Enum,\n-    pub(crate) id: EnumVariantId,\n+    pub(crate) id: LocalEnumVariantId,\n }\n \n impl EnumVariant {\n@@ -523,12 +463,14 @@ impl Adt {\n     }\n \n     pub fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n-        match self {\n-            Adt::Struct(s) => s.module(db),\n-            Adt::Union(s) => s.module(db),\n-            Adt::Enum(e) => e.module(db),\n-        }\n-        .krate(db)\n+        Some(\n+            match self {\n+                Adt::Struct(s) => s.module(db),\n+                Adt::Union(s) => s.module(db),\n+                Adt::Enum(e) => e.module(db),\n+            }\n+            .krate(),\n+        )\n     }\n \n     pub(crate) fn resolver(self, db: &impl HirDatabase) -> Resolver {\n@@ -643,7 +585,7 @@ impl FnData {\n                 let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n                     TypeRef::from_ast(type_ref)\n                 } else {\n-                    let self_type = TypeRef::Path(SELF_TYPE.into());\n+                    let self_type = TypeRef::Path(name::SELF_TYPE.into());\n                     match self_param.kind() {\n                         ast::SelfParamKind::Owned => self_type,\n                         ast::SelfParamKind::Ref => {\n@@ -692,11 +634,11 @@ impl FnData {\n \n impl Function {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn name(self, db: &impl HirDatabase) -> Name {\n@@ -770,11 +712,11 @@ pub struct Const {\n \n impl Const {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn data(self, db: &impl HirDatabase) -> Arc<ConstData> {\n@@ -867,11 +809,11 @@ pub struct Static {\n \n impl Static {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     pub fn data(self, db: &impl HirDatabase) -> Arc<ConstData> {\n@@ -896,7 +838,7 @@ pub struct Trait {\n \n impl Trait {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n@@ -917,9 +859,7 @@ impl Trait {\n             .where_predicates\n             .iter()\n             .filter_map(|pred| match &pred.type_ref {\n-                TypeRef::Path(p) if p.as_ident() == Some(&crate::name::SELF_TYPE) => {\n-                    pred.bound.as_path()\n-                }\n+                TypeRef::Path(p) if p.as_ident() == Some(&name::SELF_TYPE) => pred.bound.as_path(),\n                 _ => None,\n             })\n             .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n@@ -998,11 +938,11 @@ pub struct TypeAlias {\n \n impl TypeAlias {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        self.id.module(db)\n+        Module { id: self.id.module(db) }\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n-        self.module(db).krate(db)\n+        Some(self.module(db).krate())\n     }\n \n     /// The containing impl block, if this is a method."}, {"sha": "5c7f61eefb46162b9c973d61fbd28d4ff2b55cfd", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,9 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::{\n-    ast::{self, AstNode},\n-    SyntaxNode,\n-};\n+use ra_syntax::ast::{self, AstNode};\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n@@ -12,34 +9,21 @@ use crate::{\n     ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n };\n \n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub struct Source<T> {\n-    pub file_id: HirFileId,\n-    pub ast: T,\n-}\n+pub use hir_def::Source;\n \n pub trait HasSource {\n     type Ast;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<Self::Ast>;\n }\n \n-impl<T> Source<T> {\n-    pub(crate) fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n-        Source { file_id: self.file_id, ast: f(self.ast) }\n-    }\n-    pub(crate) fn file_syntax(&self, db: &impl AstDatabase) -> SyntaxNode {\n-        db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n-    }\n-}\n-\n /// NB: Module is !HasSource, because it has two source nodes at the same time:\n /// definition and declaration.\n impl Module {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n     pub fn definition_source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ModuleSource> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl_id = def_map[self.module_id].declaration;\n-        let file_id = def_map[self.module_id].definition;\n+        let def_map = db.crate_def_map(self.krate());\n+        let decl_id = def_map[self.id.module_id].declaration;\n+        let file_id = def_map[self.id.module_id].definition;\n         let ast = ModuleSource::new(db, file_id, decl_id);\n         let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n         Source { file_id, ast }\n@@ -51,8 +35,8 @@ impl Module {\n         self,\n         db: &(impl DefDatabase + AstDatabase),\n     ) -> Option<Source<ast::Module>> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let decl = def_map[self.module_id].declaration?;\n+        let def_map = db.crate_def_map(self.krate());\n+        let decl = def_map[self.id.module_id].declaration?;\n         let ast = decl.to_node(db);\n         Some(Source { file_id: decl.file_id(), ast })\n     }"}, {"sha": "ebfd970ebc44787ae290b08ac7e860c97891655b", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 20, "deletions": 74, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,8 +2,8 @@\n \n use std::sync::Arc;\n \n-use ra_db::{salsa, SourceDatabase};\n-use ra_syntax::{ast, Parse, SmolStr, SyntaxNode};\n+use ra_db::salsa;\n+use ra_syntax::SmolStr;\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -12,81 +12,30 @@ use crate::{\n     ids,\n     impl_block::{ImplBlock, ImplSourceMap, ModuleImplBlocks},\n     lang_item::{LangItemTarget, LangItems},\n-    nameres::{CrateDefMap, ImportSourceMap, Namespace, RawItems},\n+    nameres::{CrateDefMap, Namespace},\n     traits::TraitData,\n     ty::{\n         method_resolution::CrateImplBlocks, traits::Impl, CallableDef, FnSig, GenericPredicate,\n         InferenceResult, Substs, Ty, TypableDef, TypeCtor,\n     },\n     type_alias::TypeAliasData,\n-    AstIdMap, Const, ConstData, Crate, DefWithBody, Enum, ErasedFileAstId, ExprScopes, FnData,\n-    Function, HirFileId, MacroCallLoc, MacroDefId, Module, Static, Struct, StructField, Trait,\n-    TypeAlias,\n+    Const, ConstData, Crate, DefWithBody, Enum, ExprScopes, FnData, Function, Module, Static,\n+    Struct, StructField, Trait, TypeAlias,\n };\n \n-/// We store all interned things in the single QueryGroup.\n-///\n-/// This is done mainly to allow both \"volatile\" `AstDatabase` and \"stable\"\n-/// `DefDatabase` to access macros, without adding hard dependencies between the\n-/// two.\n-#[salsa::query_group(InternDatabaseStorage)]\n-pub trait InternDatabase: SourceDatabase {\n-    #[salsa::interned]\n-    fn intern_macro(&self, macro_call: MacroCallLoc) -> ids::MacroCallId;\n-    #[salsa::interned]\n-    fn intern_function(&self, loc: ids::ItemLoc<ast::FnDef>) -> ids::FunctionId;\n-    #[salsa::interned]\n-    fn intern_struct(&self, loc: ids::ItemLoc<ast::StructDef>) -> ids::StructId;\n-    #[salsa::interned]\n-    fn intern_enum(&self, loc: ids::ItemLoc<ast::EnumDef>) -> ids::EnumId;\n-    #[salsa::interned]\n-    fn intern_const(&self, loc: ids::ItemLoc<ast::ConstDef>) -> ids::ConstId;\n-    #[salsa::interned]\n-    fn intern_static(&self, loc: ids::ItemLoc<ast::StaticDef>) -> ids::StaticId;\n-    #[salsa::interned]\n-    fn intern_trait(&self, loc: ids::ItemLoc<ast::TraitDef>) -> ids::TraitId;\n-    #[salsa::interned]\n-    fn intern_type_alias(&self, loc: ids::ItemLoc<ast::TypeAliasDef>) -> ids::TypeAliasId;\n-\n-    // Interned IDs for Chalk integration\n-    #[salsa::interned]\n-    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n-    #[salsa::interned]\n-    fn intern_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n-}\n-\n-/// This database has access to source code, so queries here are not really\n-/// incremental.\n-#[salsa::query_group(AstDatabaseStorage)]\n-pub trait AstDatabase: InternDatabase {\n-    #[salsa::invoke(crate::source_id::AstIdMap::ast_id_map_query)]\n-    fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n-\n-    #[salsa::transparent]\n-    #[salsa::invoke(crate::source_id::AstIdMap::file_item_query)]\n-    fn ast_id_to_node(&self, file_id: HirFileId, ast_id: ErasedFileAstId) -> SyntaxNode;\n-\n-    #[salsa::transparent]\n-    #[salsa::invoke(crate::ids::HirFileId::parse_or_expand_query)]\n-    fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode>;\n-\n-    #[salsa::invoke(crate::ids::HirFileId::parse_macro_query)]\n-    fn parse_macro(&self, macro_file: ids::MacroFile) -> Option<Parse<SyntaxNode>>;\n-\n-    #[salsa::invoke(crate::ids::macro_def_query)]\n-    fn macro_def(&self, macro_id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n-\n-    #[salsa::invoke(crate::ids::macro_arg_query)]\n-    fn macro_arg(&self, macro_call: ids::MacroCallId) -> Option<Arc<tt::Subtree>>;\n-\n-    #[salsa::invoke(crate::ids::macro_expand_query)]\n-    fn macro_expand(&self, macro_call: ids::MacroCallId) -> Result<Arc<tt::Subtree>, String>;\n-}\n+pub use hir_def::db::{\n+    DefDatabase2, DefDatabase2Storage, InternDatabase, InternDatabaseStorage, RawItemsQuery,\n+    RawItemsWithSourceMapQuery,\n+};\n+pub use hir_expand::db::{\n+    AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n+    ParseMacroQuery,\n+};\n \n // This database uses `AstDatabase` internally,\n #[salsa::query_group(DefDatabaseStorage)]\n #[salsa::requires(AstDatabase)]\n-pub trait DefDatabase: InternDatabase + HirDebugDatabase {\n+pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n     fn struct_data(&self, s: Struct) -> Arc<StructData>;\n \n@@ -99,15 +48,6 @@ pub trait DefDatabase: InternDatabase + HirDebugDatabase {\n     #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n     fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n \n-    #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n-    fn raw_items_with_source_map(\n-        &self,\n-        file_id: HirFileId,\n-    ) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n-\n-    #[salsa::invoke(RawItems::raw_items_query)]\n-    fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n-\n     #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n     fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;\n \n@@ -202,6 +142,12 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(crate::ty::traits::trait_solver_query)]\n     fn trait_solver(&self, krate: Crate) -> crate::ty::traits::TraitSolver;\n \n+    // Interned IDs for Chalk integration\n+    #[salsa::interned]\n+    fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n+    #[salsa::interned]\n+    fn intern_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n+\n     #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk_ir::TypeId) -> Arc<chalk_rust_ir::AssociatedTyDatum>;\n "}, {"sha": "4f3e922c3c5c35057e62d9773dbd6ef59cafb259", "filename": "crates/ra_hir/src/debug.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdebug.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -36,12 +36,6 @@ impl Module {\n     }\n }\n \n-impl HirFileId {\n-    pub fn debug(self, db: &impl HirDebugDatabase) -> impl fmt::Debug + '_ {\n-        debug_fn(move |fmt| db.debug_hir_file_id(self, fmt))\n-    }\n-}\n-\n pub trait HirDebugHelper: HirDatabase {\n     fn crate_name(&self, _krate: CrateId) -> Option<String> {\n         None"}, {"sha": "6e23197a4d1c6d99f4a9da92058f236b9fb08c15", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -6,15 +6,17 @@ pub(crate) mod validation;\n \n use std::{ops::Index, sync::Arc};\n \n+use hir_def::{\n+    path::GenericArgs,\n+    type_ref::{Mutability, TypeRef},\n+};\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{ast, AstPtr};\n use rustc_hash::FxHashMap;\n \n use crate::{\n     db::HirDatabase,\n-    path::GenericArgs,\n     ty::primitive::{UncertainFloatTy, UncertainIntTy},\n-    type_ref::{Mutability, TypeRef},\n     DefWithBody, Either, HasSource, Name, Path, Resolver, Source,\n };\n "}, {"sha": "6463dd65e1ed17b89330a9dc0c70e82263ae4068", "filename": "crates/ra_hir/src/expr/lower.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,10 @@\n //! FIXME: write short doc here\n \n+use hir_def::{path::GenericArgs, type_ref::TypeRef};\n+use hir_expand::{\n+    hygiene::Hygiene,\n+    name::{self, AsName, Name},\n+};\n use ra_arena::Arena;\n use ra_syntax::{\n     ast::{\n@@ -12,11 +17,8 @@ use test_utils::tested_by;\n \n use crate::{\n     db::HirDatabase,\n-    name::{AsName, Name, SELF_PARAM},\n-    path::GenericArgs,\n     ty::primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n-    type_ref::TypeRef,\n-    DefWithBody, Either, HirFileId, MacroCallLoc, MacroFileKind, Mutability, Path, Resolver,\n+    AstId, DefWithBody, Either, HirFileId, MacroCallLoc, MacroFileKind, Mutability, Path, Resolver,\n     Source,\n };\n \n@@ -78,7 +80,7 @@ where\n                 let ptr = AstPtr::new(&self_param);\n                 let param_pat = self.alloc_pat(\n                     Pat::Bind {\n-                        name: SELF_PARAM,\n+                        name: name::SELF_PARAM,\n                         mode: BindingAnnotation::Unannotated,\n                         subpat: None,\n                     },\n@@ -458,15 +460,14 @@ where\n             ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::MacroCall(e) => {\n-                let ast_id = self\n-                    .db\n-                    .ast_id_map(self.current_file_id)\n-                    .ast_id(&e)\n-                    .with_file_id(self.current_file_id);\n+                let ast_id = AstId::new(\n+                    self.current_file_id,\n+                    self.db.ast_id_map(self.current_file_id).ast_id(&e),\n+                );\n \n                 if let Some(path) = e.path().and_then(|path| self.parse_path(path)) {\n                     if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n-                        let call_id = MacroCallLoc { def: def.id, ast_id }.id(self.db);\n+                        let call_id = self.db.intern_macro(MacroCallLoc { def: def.id, ast_id });\n                         let file_id = call_id.as_file(MacroFileKind::Expr);\n                         if let Some(node) = self.db.parse_or_expand(file_id) {\n                             if let Some(expr) = ast::Expr::cast(node) {\n@@ -596,7 +597,8 @@ where\n     }\n \n     fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n-        Path::from_src(Source { ast: path, file_id: self.current_file_id }, self.db)\n+        let hygiene = Hygiene::new(self.db, self.current_file_id);\n+        Path::from_src(path, &hygiene)\n     }\n }\n "}, {"sha": "c685edda193f45c915b919ddc56e8d187c17c0f3", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,14 +2,14 @@\n \n use std::sync::Arc;\n \n+use hir_def::path::known;\n use ra_syntax::ast;\n use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n     diagnostics::{DiagnosticSink, MissingFields, MissingOkInTailExpr},\n     expr::AstPtr,\n-    path::known,\n     ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n     Adt, Function, Name, Path,\n };"}, {"sha": "a9de0145538b630aa3dc93fdc7345fb8b19e0089", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 6, "deletions": 46, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,17 +1,12 @@\n //! FIXME: write short doc here\n \n-use ra_db::{FileId, FilePosition};\n-use ra_syntax::{\n-    algo::find_node_at_offset,\n-    ast::{self, AstNode, NameOwner},\n-    SyntaxNode,\n-};\n+use hir_expand::name::AsName;\n+use ra_syntax::ast::{self, AstNode, NameOwner};\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::{AstItemDef, LocationCtx},\n-    name::AsName,\n-    Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock, Module,\n+    AstId, Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock, Module,\n     ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n };\n \n@@ -129,41 +124,6 @@ impl FromSource for StructField {\n     }\n }\n \n-// FIXME: simplify it\n-impl ModuleSource {\n-    pub fn from_position(\n-        db: &(impl DefDatabase + AstDatabase),\n-        position: FilePosition,\n-    ) -> ModuleSource {\n-        let parse = db.parse(position.file_id);\n-        match &find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n-            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n-            _ => {\n-                let source_file = parse.tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-        }\n-    }\n-\n-    pub fn from_child_node(\n-        db: &(impl DefDatabase + AstDatabase),\n-        file_id: FileId,\n-        child: &SyntaxNode,\n-    ) -> ModuleSource {\n-        if let Some(m) = child.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi()) {\n-            ModuleSource::Module(m)\n-        } else {\n-            let source_file = db.parse(file_id).tree();\n-            ModuleSource::SourceFile(source_file)\n-        }\n-    }\n-\n-    pub fn from_file_id(db: &(impl DefDatabase + AstDatabase), file_id: FileId) -> ModuleSource {\n-        let source_file = db.parse(file_id).tree();\n-        ModuleSource::SourceFile(source_file)\n-    }\n-}\n-\n impl Module {\n     pub fn from_declaration(db: &impl HirDatabase, src: Source<ast::Module>) -> Option<Self> {\n         let src_parent = Source {\n@@ -183,7 +143,7 @@ impl Module {\n             ModuleSource::Module(ref module) => {\n                 assert!(!module.has_semi());\n                 let ast_id_map = db.ast_id_map(src.file_id);\n-                let item_id = ast_id_map.ast_id(module).with_file_id(src.file_id);\n+                let item_id = AstId::new(src.file_id, ast_id_map.ast_id(module));\n                 Some(item_id)\n             }\n             ModuleSource::SourceFile(_) => None,\n@@ -195,7 +155,7 @@ impl Module {\n             .find_map(|krate| {\n                 let def_map = db.crate_def_map(krate);\n                 let module_id = def_map.find_module_by_source(src.file_id, decl_id)?;\n-                Some(Module { krate, module_id })\n+                Some(Module::new(krate, module_id))\n             })\n     }\n }\n@@ -208,6 +168,6 @@ where\n     let module_src =\n         crate::ModuleSource::from_child_node(db, src.file_id.original_file(db), &src.ast.syntax());\n     let module = Module::from_definition(db, Source { file_id: src.file_id, ast: module_src })?;\n-    let ctx = LocationCtx::new(db, module, src.file_id);\n+    let ctx = LocationCtx::new(db, module.id, src.file_id);\n     Some(DEF::from_ast(ctx, &src.ast))\n }"}, {"sha": "52e1fbf2946b121047a93e50230dfb9a11a86583", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -5,15 +5,17 @@\n \n use std::sync::Arc;\n \n+use hir_def::{\n+    path::Path,\n+    type_ref::{TypeBound, TypeRef},\n+};\n+use hir_expand::name::{self, AsName};\n use ra_syntax::ast::{self, DefaultTypeParamOwner, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    name::SELF_TYPE,\n-    path::Path,\n-    type_ref::{TypeBound, TypeRef},\n-    Adt, AsName, Const, Container, Enum, EnumVariant, Function, HasSource, ImplBlock, Name, Struct,\n-    Trait, TypeAlias, Union,\n+    Adt, Const, Container, Enum, EnumVariant, Function, HasSource, ImplBlock, Name, Struct, Trait,\n+    TypeAlias, Union,\n };\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n@@ -94,11 +96,15 @@ impl GenericParams {\n             GenericDef::Adt(Adt::Enum(it)) => generics.fill(&it.source(db).ast, start),\n             GenericDef::Trait(it) => {\n                 // traits get the Self type as an implicit first type parameter\n-                generics.params.push(GenericParam { idx: start, name: SELF_TYPE, default: None });\n+                generics.params.push(GenericParam {\n+                    idx: start,\n+                    name: name::SELF_TYPE,\n+                    default: None,\n+                });\n                 generics.fill(&it.source(db).ast, start + 1);\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n-                let self_param = TypeRef::Path(SELF_TYPE.into());\n+                let self_param = TypeRef::Path(name::SELF_TYPE.into());\n                 generics.fill_bounds(&it.source(db).ast, self_param);\n             }\n             GenericDef::TypeAlias(it) => generics.fill(&it.source(db).ast, start),"}, {"sha": "fe083c0c65f68841224ab71a673f370e250819fa", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 13, "deletions": 350, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,168 +1,17 @@\n-//! FIXME: write short doc here\n-\n-use std::{\n-    hash::{Hash, Hasher},\n-    sync::Arc,\n-};\n-\n-use mbe::MacroRules;\n-use ra_db::{salsa, FileId};\n-use ra_prof::profile;\n-use ra_syntax::{ast, AstNode, Parse, SyntaxNode};\n-\n-use crate::{\n-    db::{AstDatabase, DefDatabase, InternDatabase},\n-    AstId, Crate, FileAstId, Module, Source,\n+//! hir makes heavy use of ids: integer (u32) handlers to various things. You\n+//! can think of id as a pointer (but without a lifetime) or a file descriptor\n+//! (but for hir objects).\n+//!\n+//! This module defines a bunch of ids we are using. The most important ones are\n+//! probably `HirFileId` and `DefId`.\n+\n+use ra_db::salsa;\n+\n+pub use hir_def::{\n+    AstItemDef, ConstId, EnumId, FunctionId, ItemLoc, LocationCtx, StaticId, StructId, TraitId,\n+    TypeAliasId,\n };\n-\n-/// hir makes heavy use of ids: integer (u32) handlers to various things. You\n-/// can think of id as a pointer (but without a lifetime) or a file descriptor\n-/// (but for hir objects).\n-///\n-/// This module defines a bunch of ids we are using. The most important ones are\n-/// probably `HirFileId` and `DefId`.\n-\n-/// Input to the analyzer is a set of files, where each file is identified by\n-/// `FileId` and contains source code. However, another source of source code in\n-/// Rust are macros: each macro can be thought of as producing a \"temporary\n-/// file\". To assign an id to such a file, we use the id of the macro call that\n-/// produced the file. So, a `HirFileId` is either a `FileId` (source code\n-/// written by user), or a `MacroCallId` (source code produced by macro).\n-///\n-/// What is a `MacroCallId`? Simplifying, it's a `HirFileId` of a file\n-/// containing the call plus the offset of the macro call in the file. Note that\n-/// this is a recursive definition! However, the size_of of `HirFileId` is\n-/// finite (because everything bottoms out at the real `FileId`) and small\n-/// (`MacroCallId` uses the location interner).\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct HirFileId(HirFileIdRepr);\n-\n-impl HirFileId {\n-    /// For macro-expansion files, returns the file original source file the\n-    /// expansion originated from.\n-    pub fn original_file(self, db: &impl InternDatabase) -> FileId {\n-        match self.0 {\n-            HirFileIdRepr::File(file_id) => file_id,\n-            HirFileIdRepr::Macro(macro_file) => {\n-                let loc = macro_file.macro_call_id.loc(db);\n-                loc.ast_id.file_id().original_file(db)\n-            }\n-        }\n-    }\n-\n-    /// Get the crate which the macro lives in, if it is a macro file.\n-    pub(crate) fn macro_crate(self, db: &impl AstDatabase) -> Option<Crate> {\n-        match self.0 {\n-            HirFileIdRepr::File(_) => None,\n-            HirFileIdRepr::Macro(macro_file) => {\n-                let loc = macro_file.macro_call_id.loc(db);\n-                Some(loc.def.krate)\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn parse_or_expand_query(\n-        db: &impl AstDatabase,\n-        file_id: HirFileId,\n-    ) -> Option<SyntaxNode> {\n-        match file_id.0 {\n-            HirFileIdRepr::File(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n-            HirFileIdRepr::Macro(macro_file) => {\n-                db.parse_macro(macro_file).map(|it| it.syntax_node())\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn parse_macro_query(\n-        db: &impl AstDatabase,\n-        macro_file: MacroFile,\n-    ) -> Option<Parse<SyntaxNode>> {\n-        let _p = profile(\"parse_macro_query\");\n-        let macro_call_id = macro_file.macro_call_id;\n-        let tt = db\n-            .macro_expand(macro_call_id)\n-            .map_err(|err| {\n-                // Note:\n-                // The final goal we would like to make all parse_macro success,\n-                // such that the following log will not call anyway.\n-                log::warn!(\"fail on macro_parse: (reason: {})\", err,);\n-            })\n-            .ok()?;\n-        match macro_file.macro_file_kind {\n-            MacroFileKind::Items => mbe::token_tree_to_items(&tt).ok().map(Parse::to_syntax),\n-            MacroFileKind::Expr => mbe::token_tree_to_expr(&tt).ok().map(Parse::to_syntax),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-enum HirFileIdRepr {\n-    File(FileId),\n-    Macro(MacroFile),\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroFile {\n-    macro_call_id: MacroCallId,\n-    macro_file_kind: MacroFileKind,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) enum MacroFileKind {\n-    Items,\n-    Expr,\n-}\n-\n-impl From<FileId> for HirFileId {\n-    fn from(file_id: FileId) -> HirFileId {\n-        HirFileId(HirFileIdRepr::File(file_id))\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroDefId {\n-    pub(crate) ast_id: AstId<ast::MacroCall>,\n-    pub(crate) krate: Crate,\n-}\n-\n-pub(crate) fn macro_def_query(db: &impl AstDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n-    let macro_call = id.ast_id.to_node(db);\n-    let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(&arg).or_else(|| {\n-        log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n-        None\n-    })?;\n-    let rules = MacroRules::parse(&tt).ok().or_else(|| {\n-        log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n-        None\n-    })?;\n-    Some(Arc::new(rules))\n-}\n-\n-pub(crate) fn macro_arg_query(db: &impl AstDatabase, id: MacroCallId) -> Option<Arc<tt::Subtree>> {\n-    let loc = id.loc(db);\n-    let macro_call = loc.ast_id.to_node(db);\n-    let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(&arg)?;\n-    Some(Arc::new(tt))\n-}\n-\n-pub(crate) fn macro_expand_query(\n-    db: &impl AstDatabase,\n-    id: MacroCallId,\n-) -> Result<Arc<tt::Subtree>, String> {\n-    let loc = id.loc(db);\n-    let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n-\n-    let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n-    let tt = macro_rules.expand(&macro_arg).map_err(|err| format!(\"{:?}\", err))?;\n-    // Set a hard limit for the expanded tt\n-    let count = tt.count();\n-    if count > 65536 {\n-        return Err(format!(\"Total tokens count exceed limit : count = {}\", count));\n-    }\n-    Ok(Arc::new(tt))\n-}\n+pub use hir_expand::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, MacroFileKind};\n \n macro_rules! impl_intern_key {\n     ($name:ident) => {\n@@ -177,192 +26,6 @@ macro_rules! impl_intern_key {\n     };\n }\n \n-/// `MacroCallId` identifies a particular macro invocation, like\n-/// `println!(\"Hello, {}\", world)`.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroCallId(salsa::InternId);\n-impl_intern_key!(MacroCallId);\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MacroCallLoc {\n-    pub(crate) def: MacroDefId,\n-    pub(crate) ast_id: AstId<ast::MacroCall>,\n-}\n-\n-impl MacroCallId {\n-    pub(crate) fn loc(self, db: &impl InternDatabase) -> MacroCallLoc {\n-        db.lookup_intern_macro(self)\n-    }\n-\n-    pub(crate) fn as_file(self, kind: MacroFileKind) -> HirFileId {\n-        let macro_file = MacroFile { macro_call_id: self, macro_file_kind: kind };\n-        HirFileId(HirFileIdRepr::Macro(macro_file))\n-    }\n-}\n-\n-impl MacroCallLoc {\n-    pub(crate) fn id(self, db: &impl InternDatabase) -> MacroCallId {\n-        db.intern_macro(self)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct ItemLoc<N: AstNode> {\n-    pub(crate) module: Module,\n-    ast_id: AstId<N>,\n-}\n-\n-impl<N: AstNode> PartialEq for ItemLoc<N> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.module == other.module && self.ast_id == other.ast_id\n-    }\n-}\n-impl<N: AstNode> Eq for ItemLoc<N> {}\n-impl<N: AstNode> Hash for ItemLoc<N> {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        self.module.hash(hasher);\n-        self.ast_id.hash(hasher);\n-    }\n-}\n-\n-impl<N: AstNode> Clone for ItemLoc<N> {\n-    fn clone(&self) -> ItemLoc<N> {\n-        ItemLoc { module: self.module, ast_id: self.ast_id }\n-    }\n-}\n-\n-#[derive(Clone, Copy)]\n-pub(crate) struct LocationCtx<DB> {\n-    db: DB,\n-    module: Module,\n-    file_id: HirFileId,\n-}\n-\n-impl<'a, DB: DefDatabase> LocationCtx<&'a DB> {\n-    pub(crate) fn new(db: &'a DB, module: Module, file_id: HirFileId) -> LocationCtx<&'a DB> {\n-        LocationCtx { db, module, file_id }\n-    }\n-}\n-\n-impl<'a, DB: DefDatabase + AstDatabase> LocationCtx<&'a DB> {\n-    pub(crate) fn to_def<N, DEF>(self, ast: &N) -> DEF\n-    where\n-        N: AstNode,\n-        DEF: AstItemDef<N>,\n-    {\n-        DEF::from_ast(self, ast)\n-    }\n-}\n-\n-pub(crate) trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n-    fn intern(db: &impl DefDatabase, loc: ItemLoc<N>) -> Self;\n-    fn lookup_intern(self, db: &impl DefDatabase) -> ItemLoc<N>;\n-\n-    fn from_ast(ctx: LocationCtx<&(impl AstDatabase + DefDatabase)>, ast: &N) -> Self {\n-        let items = ctx.db.ast_id_map(ctx.file_id);\n-        let item_id = items.ast_id(ast);\n-        Self::from_ast_id(ctx, item_id)\n-    }\n-    fn from_ast_id(ctx: LocationCtx<&impl DefDatabase>, ast_id: FileAstId<N>) -> Self {\n-        let loc = ItemLoc { module: ctx.module, ast_id: ast_id.with_file_id(ctx.file_id) };\n-        Self::intern(ctx.db, loc)\n-    }\n-    fn source(self, db: &(impl AstDatabase + DefDatabase)) -> Source<N> {\n-        let loc = self.lookup_intern(db);\n-        let ast = loc.ast_id.to_node(db);\n-        Source { file_id: loc.ast_id.file_id(), ast }\n-    }\n-    fn module(self, db: &impl DefDatabase) -> Module {\n-        let loc = self.lookup_intern(db);\n-        loc.module\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct FunctionId(salsa::InternId);\n-impl_intern_key!(FunctionId);\n-\n-impl AstItemDef<ast::FnDef> for FunctionId {\n-    fn intern(db: &impl DefDatabase, loc: ItemLoc<ast::FnDef>) -> Self {\n-        db.intern_function(loc)\n-    }\n-    fn lookup_intern(self, db: &impl DefDatabase) -> ItemLoc<ast::FnDef> {\n-        db.lookup_intern_function(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StructId(salsa::InternId);\n-impl_intern_key!(StructId);\n-impl AstItemDef<ast::StructDef> for StructId {\n-    fn intern(db: &impl DefDatabase, loc: ItemLoc<ast::StructDef>) -> Self {\n-        db.intern_struct(loc)\n-    }\n-    fn lookup_intern(self, db: &impl DefDatabase) -> ItemLoc<ast::StructDef> {\n-        db.lookup_intern_struct(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct EnumId(salsa::InternId);\n-impl_intern_key!(EnumId);\n-impl AstItemDef<ast::EnumDef> for EnumId {\n-    fn intern(db: &impl DefDatabase, loc: ItemLoc<ast::EnumDef>) -> Self {\n-        db.intern_enum(loc)\n-    }\n-    fn lookup_intern(self, db: &impl DefDatabase) -> ItemLoc<ast::EnumDef> {\n-        db.lookup_intern_enum(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ConstId(salsa::InternId);\n-impl_intern_key!(ConstId);\n-impl AstItemDef<ast::ConstDef> for ConstId {\n-    fn intern(db: &impl DefDatabase, loc: ItemLoc<ast::ConstDef>) -> Self {\n-        db.intern_const(loc)\n-    }\n-    fn lookup_intern(self, db: &impl DefDatabase) -> ItemLoc<ast::ConstDef> {\n-        db.lookup_intern_const(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StaticId(salsa::InternId);\n-impl_intern_key!(StaticId);\n-impl AstItemDef<ast::StaticDef> for StaticId {\n-    fn intern(db: &impl DefDatabase, loc: ItemLoc<ast::StaticDef>) -> Self {\n-        db.intern_static(loc)\n-    }\n-    fn lookup_intern(self, db: &impl DefDatabase) -> ItemLoc<ast::StaticDef> {\n-        db.lookup_intern_static(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TraitId(salsa::InternId);\n-impl_intern_key!(TraitId);\n-impl AstItemDef<ast::TraitDef> for TraitId {\n-    fn intern(db: &impl DefDatabase, loc: ItemLoc<ast::TraitDef>) -> Self {\n-        db.intern_trait(loc)\n-    }\n-    fn lookup_intern(self, db: &impl DefDatabase) -> ItemLoc<ast::TraitDef> {\n-        db.lookup_intern_trait(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TypeAliasId(salsa::InternId);\n-impl_intern_key!(TypeAliasId);\n-impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n-    fn intern(db: &impl DefDatabase, loc: ItemLoc<ast::TypeAliasDef>) -> Self {\n-        db.intern_type_alias(loc)\n-    }\n-    fn lookup_intern(self, db: &impl DefDatabase) -> ItemLoc<ast::TypeAliasDef> {\n-        db.lookup_intern_type_alias(self)\n-    }\n-}\n-\n /// This exists just for Chalk, because Chalk just has a single `StructId` where\n /// we have different kinds of ADTs, primitive types and special type\n /// constructors like tuples and function pointers."}, {"sha": "b1a0140745c4e55c3c8fe26915e0601244e07d18", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -3,6 +3,8 @@\n use rustc_hash::FxHashMap;\n use std::sync::Arc;\n \n+use hir_def::{attr::Attr, type_ref::TypeRef};\n+use hir_expand::hygiene::Hygiene;\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_cfg::CfgOptions;\n use ra_syntax::{\n@@ -11,16 +13,14 @@ use ra_syntax::{\n };\n \n use crate::{\n-    attr::Attr,\n     code_model::{Module, ModuleSource},\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     generics::HasGenericParams,\n     ids::LocationCtx,\n     ids::MacroCallLoc,\n     resolve::Resolver,\n     ty::Ty,\n-    type_ref::TypeRef,\n-    AssocItem, Const, Function, HasSource, HirFileId, MacroFileKind, Path, Source, TraitRef,\n+    AssocItem, AstId, Const, Function, HasSource, HirFileId, MacroFileKind, Path, Source, TraitRef,\n     TypeAlias,\n };\n \n@@ -129,7 +129,7 @@ impl ImplData {\n     ) -> Self {\n         let target_trait = node.target_trait().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n-        let ctx = LocationCtx::new(db, module, file_id);\n+        let ctx = LocationCtx::new(db, module.id, file_id);\n         let negative = node.is_negative();\n         let items = if let Some(item_list) = node.item_list() {\n             item_list\n@@ -182,7 +182,7 @@ impl ModuleImplBlocks {\n     ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>) {\n         let mut source_map = ImplSourceMap::default();\n         let crate_graph = db.crate_graph();\n-        let cfg_options = crate_graph.cfg_options(module.krate.crate_id());\n+        let cfg_options = crate_graph.cfg_options(module.id.krate);\n \n         let result = ModuleImplBlocks::collect(db, cfg_options, module, &mut source_map);\n         (Arc::new(result), Arc::new(source_map))\n@@ -228,10 +228,11 @@ impl ModuleImplBlocks {\n         owner: &dyn ast::ModuleItemOwner,\n         file_id: HirFileId,\n     ) {\n+        let hygiene = Hygiene::new(db, file_id);\n         for item in owner.items_with_macros() {\n             match item {\n                 ast::ItemOrMacro::Item(ast::ModuleItem::ImplBlock(impl_block_ast)) => {\n-                    let attrs = Attr::from_attrs_owner(file_id, &impl_block_ast, db);\n+                    let attrs = Attr::from_attrs_owner(&impl_block_ast, &hygiene);\n                     if attrs.map_or(false, |attrs| {\n                         attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false))\n                     }) {\n@@ -248,22 +249,21 @@ impl ModuleImplBlocks {\n                 }\n                 ast::ItemOrMacro::Item(_) => (),\n                 ast::ItemOrMacro::Macro(macro_call) => {\n-                    let attrs = Attr::from_attrs_owner(file_id, &macro_call, db);\n+                    let attrs = Attr::from_attrs_owner(&macro_call, &hygiene);\n                     if attrs.map_or(false, |attrs| {\n                         attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false))\n                     }) {\n                         continue;\n                     }\n \n                     //FIXME: we should really cut down on the boilerplate required to process a macro\n-                    let ast_id = db.ast_id_map(file_id).ast_id(&macro_call).with_file_id(file_id);\n-                    if let Some(path) = macro_call\n-                        .path()\n-                        .and_then(|path| Path::from_src(Source { ast: path, file_id }, db))\n+                    let ast_id = AstId::new(file_id, db.ast_id_map(file_id).ast_id(&macro_call));\n+                    if let Some(path) =\n+                        macro_call.path().and_then(|path| Path::from_src(path, &hygiene))\n                     {\n                         if let Some(def) = self.module.resolver(db).resolve_path_as_macro(db, &path)\n                         {\n-                            let call_id = MacroCallLoc { def: def.id, ast_id }.id(db);\n+                            let call_id = db.intern_macro(MacroCallLoc { def: def.id, ast_id });\n                             let file_id = call_id.as_file(MacroFileKind::Items);\n                             if let Some(item_list) =\n                                 db.parse_or_expand(file_id).and_then(ast::MacroItems::cast)"}, {"sha": "e1780ed388f0b7f5a1739995055ac533924b1dca", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -22,14 +22,14 @@ pub enum LangItemTarget {\n \n impl LangItemTarget {\n     pub(crate) fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n-        match self {\n-            LangItemTarget::Enum(e) => e.module(db).krate(db),\n-            LangItemTarget::Function(f) => f.module(db).krate(db),\n-            LangItemTarget::ImplBlock(i) => i.module().krate(db),\n-            LangItemTarget::Static(s) => s.module(db).krate(db),\n-            LangItemTarget::Struct(s) => s.module(db).krate(db),\n-            LangItemTarget::Trait(t) => t.module(db).krate(db),\n-        }\n+        Some(match self {\n+            LangItemTarget::Enum(e) => e.module(db).krate(),\n+            LangItemTarget::Function(f) => f.module(db).krate(),\n+            LangItemTarget::ImplBlock(i) => i.module().krate(),\n+            LangItemTarget::Static(s) => s.module(db).krate(),\n+            LangItemTarget::Struct(s) => s.module(db).krate(),\n+            LangItemTarget::Trait(t) => t.module(db).krate(),\n+        })\n     }\n }\n "}, {"sha": "40f5562b406a82dd111dbd0790519d71bb9bb4f2", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -26,25 +26,19 @@ macro_rules! impl_froms {\n     }\n }\n \n-mod either;\n pub mod debug;\n \n pub mod db;\n #[macro_use]\n pub mod mock;\n-mod path;\n pub mod source_binder;\n \n-mod source_id;\n mod ids;\n-mod name;\n mod nameres;\n mod adt;\n mod traits;\n mod type_alias;\n-mod type_ref;\n mod ty;\n-mod attr;\n mod impl_block;\n mod expr;\n mod lang_item;\n@@ -60,37 +54,35 @@ pub mod from_source;\n #[cfg(test)]\n mod marks;\n \n-use crate::{\n-    ids::MacroFileKind,\n-    name::AsName,\n-    resolve::Resolver,\n-    source_id::{AstId, FileAstId},\n-};\n+use hir_expand::AstId;\n+\n+use crate::{ids::MacroFileKind, resolve::Resolver};\n \n-pub use self::{\n+pub use crate::{\n     adt::VariantDef,\n-    either::Either,\n+    code_model::{\n+        docs::{DocDef, Docs, Documentation},\n+        src::{HasBodySource, HasSource, Source},\n+        Adt, AssocItem, Const, ConstData, Container, Crate, CrateDependency, DefWithBody, Enum,\n+        EnumVariant, FieldSource, FnData, Function, HasBody, MacroDef, Module, ModuleDef,\n+        ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n+    },\n     expr::ExprScopes,\n     from_source::FromSource,\n     generics::{GenericDef, GenericParam, GenericParams, HasGenericParams},\n     ids::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile},\n     impl_block::ImplBlock,\n-    name::Name,\n     nameres::{ImportId, Namespace, PerNs},\n-    path::{Path, PathKind},\n     resolve::ScopeDef,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n-    source_id::{AstIdMap, ErasedFileAstId},\n     ty::{\n         display::HirDisplay, ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n     },\n-    type_ref::Mutability,\n };\n \n-pub use self::code_model::{\n-    docs::{DocDef, Docs, Documentation},\n-    src::{HasBodySource, HasSource, Source},\n-    Adt, AssocItem, BuiltinType, Const, ConstData, Container, Crate, CrateDependency, DefWithBody,\n-    Enum, EnumVariant, FieldSource, FnData, Function, HasBody, MacroDef, Module, ModuleDef,\n-    ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n+pub use hir_def::{\n+    builtin_type::BuiltinType,\n+    path::{Path, PathKind},\n+    type_ref::Mutability,\n };\n+pub use hir_expand::{either::Either, name::Name};"}, {"sha": "b423489a11178a533f6cd2b3425de9037f0fc17f", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,6 +2,7 @@\n \n test_utils::marks!(\n     bogus_paths\n+    // FIXME: restore this mark once hir is split\n     name_res_works_for_broken_modules\n     can_import_enum_variant\n     type_var_cycles_resolve_completely"}, {"sha": "35dfaf3bad0e78ce234a407173fd50d6582671c5", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -22,6 +22,7 @@ pub const WORKSPACE: SourceRootId = SourceRootId(0);\n     db::InternDatabaseStorage,\n     db::AstDatabaseStorage,\n     db::DefDatabaseStorage,\n+    db::DefDatabase2Storage,\n     db::HirDatabaseStorage\n )]\n #[derive(Debug)]"}, {"sha": "7ba03182718cee0d579c3aa75844e330514c9215", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -48,16 +48,15 @@\n //! on the result\n \n mod per_ns;\n-mod raw;\n mod collector;\n-mod mod_resolution;\n #[cfg(test)]\n mod tests;\n \n use std::sync::Arc;\n \n+use hir_def::{builtin_type::BuiltinType, CrateModuleId};\n use once_cell::sync::Lazy;\n-use ra_arena::{impl_arena_id, Arena, RawId};\n+use ra_arena::Arena;\n use ra_db::{Edition, FileId};\n use ra_prof::profile;\n use ra_syntax::ast;\n@@ -69,16 +68,12 @@ use crate::{\n     diagnostics::DiagnosticSink,\n     ids::MacroDefId,\n     nameres::diagnostics::DefDiagnostic,\n-    Adt, AstId, BuiltinType, Crate, HirFileId, MacroDef, Module, ModuleDef, Name, Path, PathKind,\n-    Trait,\n+    Adt, AstId, Crate, HirFileId, MacroDef, Module, ModuleDef, Name, Path, PathKind, Trait,\n };\n \n-pub(crate) use self::raw::{ImportSourceMap, RawItems};\n+pub use self::per_ns::{Namespace, PerNs};\n \n-pub use self::{\n-    per_ns::{Namespace, PerNs},\n-    raw::ImportId,\n-};\n+pub use hir_def::nameres::raw::ImportId;\n \n /// Contains all top-level defs from a macro-expanded crate\n #[derive(Debug, PartialEq, Eq)]\n@@ -115,13 +110,8 @@ impl std::ops::Index<CrateModuleId> for CrateDefMap {\n     }\n }\n \n-/// An ID of a module, **local** to a specific crate\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub(crate) struct CrateModuleId(RawId);\n-impl_arena_id!(CrateModuleId);\n-\n #[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct ModuleData {\n+pub struct ModuleData {\n     pub(crate) parent: Option<CrateModuleId>,\n     pub(crate) children: FxHashMap<Name, CrateModuleId>,\n     pub(crate) scope: ModuleScope,\n@@ -332,10 +322,11 @@ impl CrateDefMap {\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs = match path.kind {\n-            PathKind::DollarCrate(krate) => {\n+            PathKind::DollarCrate(crate_id) => {\n+                let krate = Crate { crate_id };\n                 if krate == self.krate {\n                     tested_by!(macro_dollar_crate_self);\n-                    PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n+                    PerNs::types(Module::new(self.krate, self.root).into())\n                 } else {\n                     match krate.root_module(db) {\n                         Some(module) => {\n@@ -346,12 +337,8 @@ impl CrateDefMap {\n                     }\n                 }\n             }\n-            PathKind::Crate => {\n-                PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n-            }\n-            PathKind::Self_ => {\n-                PerNs::types(Module { krate: self.krate, module_id: original_module }.into())\n-            }\n+            PathKind::Crate => PerNs::types(Module::new(self.krate, self.root).into()),\n+            PathKind::Self_ => PerNs::types(Module::new(self.krate, original_module).into()),\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n@@ -377,7 +364,7 @@ impl CrateDefMap {\n             }\n             PathKind::Super => {\n                 if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(Module { krate: self.krate, module_id: p }.into())\n+                    PerNs::types(Module::new(self.krate, p).into())\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -419,12 +406,12 @@ impl CrateDefMap {\n \n             curr_per_ns = match curr {\n                 ModuleDef::Module(module) => {\n-                    if module.krate != self.krate {\n+                    if module.krate() != self.krate {\n                         let path =\n                             Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n-                        let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n+                        let defp_map = db.crate_def_map(module.krate());\n+                        let (def, s) = defp_map.resolve_path(db, module.id.module_id, &path);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n@@ -433,7 +420,7 @@ impl CrateDefMap {\n                     }\n \n                     // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.module_id].scope.get(&segment.name) {\n+                    match self[module.id.module_id].scope.get(&segment.name) {\n                         Some(res) => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n@@ -511,14 +498,14 @@ impl CrateDefMap {\n     fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs {\n         if let Some(prelude) = self.prelude {\n             let keep;\n-            let def_map = if prelude.krate == self.krate {\n+            let def_map = if prelude.krate() == self.krate {\n                 self\n             } else {\n                 // Extend lifetime\n-                keep = db.crate_def_map(prelude.krate);\n+                keep = db.crate_def_map(prelude.krate());\n                 &keep\n             };\n-            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n+            def_map[prelude.id.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n         } else {\n             PerNs::none()\n         }"}, {"sha": "ee0a4c99fe00295a392110c4bfbbe5cdc3657a57", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,19 +1,22 @@\n //! FIXME: write short doc here\n \n+use hir_def::{\n+    attr::Attr,\n+    nameres::{mod_resolution::ModDir, raw},\n+};\n+use hir_expand::name;\n use ra_cfg::CfgOptions;\n use ra_db::FileId;\n use ra_syntax::{ast, SmolStr};\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n-    attr::Attr,\n     db::DefDatabase,\n     ids::{AstItemDef, LocationCtx, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind},\n-    name::MACRO_RULES,\n     nameres::{\n-        diagnostics::DefDiagnostic, mod_resolution::ModDir, raw, Crate, CrateDefMap, CrateModuleId,\n-        ModuleData, ModuleDef, PerNs, ReachedFixedPoint, Resolution, ResolveMode,\n+        diagnostics::DefDiagnostic, Crate, CrateDefMap, CrateModuleId, ModuleData, ModuleDef,\n+        PerNs, ReachedFixedPoint, Resolution, ResolveMode,\n     },\n     Adt, AstId, Const, Enum, Function, HirFileId, MacroDef, Module, Name, Path, PathKind, Static,\n     Struct, Trait, TypeAlias, Union,\n@@ -212,7 +215,7 @@ where\n \n         if let Some(ModuleDef::Module(m)) = res.take_types() {\n             tested_by!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(current_module_id, m.krate);\n+            self.import_all_macros_exported(current_module_id, m.krate());\n         }\n     }\n \n@@ -289,11 +292,11 @@ where\n                     if import.is_prelude {\n                         tested_by!(std_prelude);\n                         self.def_map.prelude = Some(m);\n-                    } else if m.krate != self.def_map.krate {\n+                    } else if m.krate() != self.def_map.krate {\n                         tested_by!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n-                        let item_map = self.db.crate_def_map(m.krate);\n-                        let scope = &item_map[m.module_id].scope;\n+                        let item_map = self.db.crate_def_map(m.krate());\n+                        let scope = &item_map[m.id.module_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -307,7 +310,7 @@ where\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n-                        let scope = &self.def_map[m.module_id].scope;\n+                        let scope = &self.def_map[m.id.module_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -319,7 +322,7 @@ where\n                         self.update(module_id, Some(import_id), &items);\n                         // record the glob import in case we add further items\n                         self.glob_imports\n-                            .entry(m.module_id)\n+                            .entry(m.id.module_id)\n                             .or_default()\n                             .push((module_id, import_id));\n                     }\n@@ -448,7 +451,7 @@ where\n             );\n \n             if let Some(def) = resolved_res.resolved_def.get_macros() {\n-                let call_id = MacroCallLoc { def: def.id, ast_id: *ast_id }.id(self.db);\n+                let call_id = self.db.intern_macro(MacroCallLoc { def: def.id, ast_id: *ast_id });\n                 resolved.push((*module_id, call_id, def.id));\n                 res = ReachedFixedPoint::No;\n                 return false;\n@@ -523,9 +526,10 @@ where\n \n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n-            if prelude_module.krate != self.def_collector.def_map.krate {\n+            if prelude_module.krate() != self.def_collector.def_map.krate {\n                 tested_by!(prelude_is_macro_use);\n-                self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n+                self.def_collector\n+                    .import_all_macros_exported(self.module_id, prelude_module.krate());\n             }\n         }\n \n@@ -567,7 +571,7 @@ where\n             // inline module, just recurse\n             raw::ModuleData::Definition { name, items, ast_id } => {\n                 let module_id =\n-                    self.push_child_module(name.clone(), ast_id.with_file_id(self.file_id), None);\n+                    self.push_child_module(name.clone(), AstId::new(self.file_id, *ast_id), None);\n \n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n@@ -583,7 +587,7 @@ where\n             }\n             // out of line module, resolve, parse and recurse\n             raw::ModuleData::Declaration { name, ast_id } => {\n-                let ast_id = ast_id.with_file_id(self.file_id);\n+                let ast_id = AstId::new(self.file_id, *ast_id);\n                 match self.mod_dir.resolve_declaration(\n                     self.def_collector.db,\n                     self.file_id,\n@@ -631,18 +635,16 @@ where\n         modules[res].scope.legacy_macros = modules[self.module_id].scope.legacy_macros.clone();\n         modules[self.module_id].children.insert(name.clone(), res);\n         let resolution = Resolution {\n-            def: PerNs::types(\n-                Module { krate: self.def_collector.def_map.krate, module_id: res }.into(),\n-            ),\n+            def: PerNs::types(Module::new(self.def_collector.def_map.krate, res).into()),\n             import: None,\n         };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n         res\n     }\n \n     fn define_def(&mut self, def: &raw::DefData) {\n-        let module = Module { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n-        let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n+        let module = Module::new(self.def_collector.def_map.krate, self.module_id);\n+        let ctx = LocationCtx::new(self.def_collector.db, module.id, self.file_id);\n \n         macro_rules! def {\n             ($kind:ident, $ast_id:ident) => {\n@@ -671,28 +673,26 @@ where\n     }\n \n     fn collect_macro(&mut self, mac: &raw::MacroData) {\n+        let ast_id = AstId::new(self.file_id, mac.ast_id);\n+\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                let macro_id = MacroDefId {\n-                    ast_id: mac.ast_id.with_file_id(self.file_id),\n-                    krate: self.def_collector.def_map.krate,\n-                };\n+                let macro_id =\n+                    MacroDefId { ast_id, krate: self.def_collector.def_map.krate.crate_id };\n                 let macro_ = MacroDef { id: macro_id };\n                 self.def_collector.define_macro(self.module_id, name.clone(), macro_, mac.export);\n             }\n             return;\n         }\n \n-        let ast_id = mac.ast_id.with_file_id(self.file_id);\n-\n         // Case 2: try to resolve in legacy scope and expand macro_rules, triggering\n         // recursive item collection.\n         if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n             self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n         }) {\n             let def = macro_def.id;\n-            let macro_call_id = MacroCallLoc { def, ast_id }.id(self.def_collector.db);\n+            let macro_call_id = self.def_collector.db.intern_macro(MacroCallLoc { def, ast_id });\n \n             self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, def);\n             return;\n@@ -728,7 +728,7 @@ where\n }\n \n fn is_macro_rules(path: &Path) -> bool {\n-    path.as_ident() == Some(&MACRO_RULES)\n+    path.as_ident() == Some(&name::MACRO_RULES)\n }\n \n #[cfg(test)]"}, {"sha": "abfe8b1c346e28ee6387b4a2fde473a1bcde939f", "filename": "crates/ra_hir/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n #[test]\n fn name_res_works_for_broken_modules() {\n-    covers!(name_res_works_for_broken_modules);\n+    // covers!(name_res_works_for_broken_modules);\n     let map = def_map(\n         \"\n         //- /lib.rs"}, {"sha": "75b24d386f16af06f04b4e3b899b25a2c9b5f808", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,6 +1,12 @@\n //! Name resolution.\n use std::sync::Arc;\n \n+use hir_def::{\n+    builtin_type::BuiltinType,\n+    path::{Path, PathKind},\n+    CrateModuleId,\n+};\n+use hir_expand::name::{self, Name};\n use rustc_hash::FxHashSet;\n \n use crate::{\n@@ -12,11 +18,8 @@ use crate::{\n     },\n     generics::GenericParams,\n     impl_block::ImplBlock,\n-    name::{Name, SELF_PARAM, SELF_TYPE},\n-    nameres::{CrateDefMap, CrateModuleId, PerNs},\n-    path::{Path, PathKind},\n-    Adt, BuiltinType, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct,\n-    Trait, TypeAlias,\n+    nameres::{CrateDefMap, PerNs},\n+    Adt, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct, Trait, TypeAlias,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -149,13 +152,13 @@ impl Resolver {\n                     }\n                 }\n                 Scope::ImplBlockScope(impl_) => {\n-                    if first_name == &SELF_TYPE {\n+                    if first_name == &name::SELF_TYPE {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::SelfType(*impl_), idx));\n                     }\n                 }\n                 Scope::AdtScope(adt) => {\n-                    if first_name == &SELF_TYPE {\n+                    if first_name == &name::SELF_TYPE {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::AdtSelfType(*adt), idx));\n                     }\n@@ -204,7 +207,7 @@ impl Resolver {\n             return None;\n         }\n         let n_segments = path.segments.len();\n-        let tmp = SELF_PARAM;\n+        let tmp = name::SELF_PARAM;\n         let first_name = if path.is_self() { &tmp } else { &path.segments.first()?.name };\n         let skip_to_mod = path.kind != PathKind::Plain && !path.is_self();\n         for scope in self.scopes.iter().rev() {\n@@ -240,13 +243,13 @@ impl Resolver {\n                 Scope::GenericParams(_) => continue,\n \n                 Scope::ImplBlockScope(impl_) if n_segments > 1 => {\n-                    if first_name == &SELF_TYPE {\n+                    if first_name == &name::SELF_TYPE {\n                         let ty = TypeNs::SelfType(*impl_);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::AdtScope(adt) if n_segments > 1 => {\n-                    if first_name == &SELF_TYPE {\n+                    if first_name == &name::SELF_TYPE {\n                         let ty = TypeNs::AdtSelfType(*adt);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n@@ -330,8 +333,8 @@ impl Resolver {\n         for scope in &self.scopes {\n             if let Scope::ModuleScope(m) = scope {\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    traits.extend(prelude_def_map[prelude.module_id].scope.traits());\n+                    let prelude_def_map = db.crate_def_map(prelude.krate());\n+                    traits.extend(prelude_def_map[prelude.id.module_id].scope.traits());\n                 }\n                 traits.extend(m.crate_def_map[m.module_id].scope.traits());\n             }\n@@ -444,10 +447,12 @@ impl Scope {\n                     f(name.clone(), ScopeDef::ModuleDef(*def));\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n-                        f(name.clone(), res.def.into());\n-                    });\n+                    let prelude_def_map = db.crate_def_map(prelude.krate());\n+                    prelude_def_map[prelude.id.module_id].scope.entries().for_each(\n+                        |(name, res)| {\n+                            f(name.clone(), res.def.into());\n+                        },\n+                    );\n                 }\n             }\n             Scope::GenericParams(gp) => {\n@@ -456,10 +461,10 @@ impl Scope {\n                 }\n             }\n             Scope::ImplBlockScope(i) => {\n-                f(SELF_TYPE, ScopeDef::ImplSelfType(*i));\n+                f(name::SELF_TYPE, ScopeDef::ImplSelfType(*i));\n             }\n             Scope::AdtScope(i) => {\n-                f(SELF_TYPE, ScopeDef::AdtSelfType(*i));\n+                f(name::SELF_TYPE, ScopeDef::AdtSelfType(*i));\n             }\n             Scope::ExprScope(e) => {\n                 e.expr_scopes.entries(e.scope_id).iter().for_each(|e| {"}, {"sha": "152bc71bd28772fb135d53dfc7e64f48d025809e", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -7,10 +7,12 @@\n //! purely for \"IDE needs\".\n use std::sync::Arc;\n \n+use hir_def::path::known;\n+use hir_expand::name::AsName;\n use ra_db::FileId;\n use ra_syntax::{\n     ast::{self, AstNode},\n-    AstPtr,\n+    match_ast, AstPtr,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxNodePtr, TextRange, TextUnit,\n };\n@@ -24,36 +26,45 @@ use crate::{\n         BodySourceMap,\n     },\n     ids::LocationCtx,\n-    path::known,\n     resolve::{ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::implements_trait,\n-    AsName, Const, DefWithBody, Either, Enum, FromSource, Function, HasBody, HirFileId, MacroDef,\n-    Module, Name, Path, Resolver, Static, Struct, Ty,\n+    Const, DefWithBody, Either, Enum, FromSource, Function, HasBody, HirFileId, MacroDef, Module,\n+    Name, Path, Resolver, Static, Struct, Ty,\n };\n \n fn try_get_resolver_for_node(\n     db: &impl HirDatabase,\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<Resolver> {\n-    if let Some(module) = ast::Module::cast(node.clone()) {\n-        let src = crate::Source { file_id: file_id.into(), ast: module };\n-        Some(crate::Module::from_declaration(db, src)?.resolver(db))\n-    } else if let Some(file) = ast::SourceFile::cast(node.clone()) {\n-        let src =\n-            crate::Source { file_id: file_id.into(), ast: crate::ModuleSource::SourceFile(file) };\n-        Some(crate::Module::from_definition(db, src)?.resolver(db))\n-    } else if let Some(s) = ast::StructDef::cast(node.clone()) {\n-        let src = crate::Source { file_id: file_id.into(), ast: s };\n-        Some(Struct::from_source(db, src)?.resolver(db))\n-    } else if let Some(e) = ast::EnumDef::cast(node.clone()) {\n-        let src = crate::Source { file_id: file_id.into(), ast: e };\n-        Some(Enum::from_source(db, src)?.resolver(db))\n-    } else if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n-        Some(def_with_body_from_child_node(db, file_id, node)?.resolver(db))\n-    } else {\n-        // FIXME add missing cases\n-        None\n+    match_ast! {\n+        match node {\n+            ast::Module(it) => {\n+                let src = crate::Source { file_id: file_id.into(), ast: it };\n+                Some(crate::Module::from_declaration(db, src)?.resolver(db))\n+            },\n+             ast::SourceFile(it) => {\n+                let src =\n+                    crate::Source { file_id: file_id.into(), ast: crate::ModuleSource::SourceFile(it) };\n+                Some(crate::Module::from_definition(db, src)?.resolver(db))\n+            },\n+            ast::StructDef(it) => {\n+                let src = crate::Source { file_id: file_id.into(), ast: it };\n+                Some(Struct::from_source(db, src)?.resolver(db))\n+            },\n+            ast::EnumDef(it) => {\n+                let src = crate::Source { file_id: file_id.into(), ast: it };\n+                Some(Enum::from_source(db, src)?.resolver(db))\n+            },\n+            _ => {\n+                if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n+                    Some(def_with_body_from_child_node(db, file_id, node)?.resolver(db))\n+                } else {\n+                    // FIXME add missing cases\n+                    None\n+                }\n+            },\n+        }\n     }\n }\n \n@@ -64,19 +75,17 @@ fn def_with_body_from_child_node(\n ) -> Option<DefWithBody> {\n     let src = crate::ModuleSource::from_child_node(db, file_id, node);\n     let module = Module::from_definition(db, crate::Source { file_id: file_id.into(), ast: src })?;\n-    let ctx = LocationCtx::new(db, module, file_id.into());\n+    let ctx = LocationCtx::new(db, module.id, file_id.into());\n \n     node.ancestors().find_map(|node| {\n-        if let Some(def) = ast::FnDef::cast(node.clone()) {\n-            return Some(Function { id: ctx.to_def(&def) }.into());\n-        }\n-        if let Some(def) = ast::ConstDef::cast(node.clone()) {\n-            return Some(Const { id: ctx.to_def(&def) }.into());\n-        }\n-        if let Some(def) = ast::StaticDef::cast(node) {\n-            return Some(Static { id: ctx.to_def(&def) }.into());\n+        match_ast! {\n+            match node {\n+                ast::FnDef(def)  => { Some(Function {id: ctx.to_def(&def) }.into()) },\n+                ast::ConstDef(def) => { Some(Const { id: ctx.to_def(&def) }.into()) },\n+                ast::StaticDef(def) => { Some(Static { id: ctx.to_def(&def) }.into()) },\n+                _ => { None },\n+            }\n         }\n-        None\n     })\n }\n "}, {"sha": "1a45dacba92d837acd0232bab31f263d0005f79d", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,14 +1,15 @@\n //! HIR for trait definitions.\n \n-use rustc_hash::FxHashMap;\n use std::sync::Arc;\n \n+use hir_expand::name::AsName;\n+\n use ra_syntax::ast::{self, NameOwner};\n+use rustc_hash::FxHashMap;\n \n use crate::{\n     db::{AstDatabase, DefDatabase},\n     ids::LocationCtx,\n-    name::AsName,\n     AssocItem, Const, Function, HasSource, Module, Name, Trait, TypeAlias,\n };\n \n@@ -27,7 +28,7 @@ impl TraitData {\n         let src = tr.source(db);\n         let name = src.ast.name().map(|n| n.as_name());\n         let module = tr.module(db);\n-        let ctx = LocationCtx::new(db, module, src.file_id);\n+        let ctx = LocationCtx::new(db, module.id, src.file_id);\n         let auto = src.ast.is_auto();\n         let items = if let Some(item_list) = src.ast.item_list() {\n             item_list"}, {"sha": "d2bfcdc7dbcb981e5c271ef2947df54f673d488e", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -17,8 +17,8 @@ use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n use crate::{\n-    db::HirDatabase, expr::ExprId, type_ref::Mutability, util::make_mut_slice, Adt, Crate,\n-    DefWithBody, GenericParams, HasGenericParams, Name, Trait, TypeAlias,\n+    db::HirDatabase, expr::ExprId, util::make_mut_slice, Adt, Crate, DefWithBody, GenericParams,\n+    HasGenericParams, Mutability, Name, Trait, TypeAlias,\n };\n use display::{HirDisplay, HirFormatter};\n "}, {"sha": "3645ee831c91113985ea8df816dca03d80af7935", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -5,10 +5,11 @@\n \n use std::iter::successors;\n \n+use hir_expand::name;\n use log::{info, warn};\n \n use super::{traits::Solution, Canonical, Substs, Ty, TypeWalk};\n-use crate::{db::HirDatabase, name, HasGenericParams, Resolver};\n+use crate::{db::HirDatabase, HasGenericParams, Resolver};\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n "}, {"sha": "6694467a36cbb6df712fd63e22c4d944120358c4", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -21,6 +21,11 @@ use std::sync::Arc;\n use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use rustc_hash::FxHashMap;\n \n+use hir_def::{\n+    path::known,\n+    type_ref::{Mutability, TypeRef},\n+};\n+use hir_expand::name;\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n use test_utils::tested_by;\n@@ -37,11 +42,8 @@ use crate::{\n     db::HirDatabase,\n     diagnostics::DiagnosticSink,\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n-    name,\n-    path::known,\n     resolve::{Resolver, TypeNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n-    type_ref::{Mutability, TypeRef},\n     Adt, AssocItem, ConstData, DefWithBody, FnData, Function, HasBody, Path, StructField,\n };\n "}, {"sha": "6ea135126a5cf207807cdb5959df8212b2b69b04", "filename": "crates/ra_hir/src/ty/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -14,8 +14,7 @@ use crate::{\n     lang_item::LangItemTarget,\n     resolve::Resolver,\n     ty::{autoderef, Substs, Ty, TypeCtor, TypeWalk},\n-    type_ref::Mutability,\n-    Adt,\n+    Adt, Mutability,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {"}, {"sha": "fed52df39cef186978fb4edc18786e8620f150e0", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -3,14 +3,15 @@\n use std::iter::{repeat, repeat_with};\n use std::sync::Arc;\n \n+use hir_def::path::{GenericArg, GenericArgs};\n+use hir_expand::name;\n+\n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n use crate::{\n     db::HirDatabase,\n     expr::{self, Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     generics::{GenericParams, HasGenericParams},\n-    name,\n     nameres::Namespace,\n-    path::{GenericArg, GenericArgs},\n     ty::{\n         autoderef, method_resolution, op, primitive, CallableDef, InferTy, Mutability, Obligation,\n         ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,"}, {"sha": "77aa35ce13308b22b53700b766fbc25011cffcaf", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,7 @@\n //! Path expression resolution.\n \n+use hir_def::path::PathSegment;\n+\n use super::{ExprOrPatId, InferenceContext, TraitRef};\n use crate::{\n     db::HirDatabase,\n@@ -131,7 +133,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_trait_assoc_item(\n         &mut self,\n         trait_ref: TraitRef,\n-        segment: &crate::path::PathSegment,\n+        segment: &PathSegment,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         let trait_ = trait_ref.trait_;\n@@ -170,7 +172,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_ty_assoc_item(\n         &mut self,\n         ty: Ty,\n-        segment: &crate::path::PathSegment,\n+        segment: &PathSegment,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         if let Ty::Unknown = ty {"}, {"sha": "dd7cd979ff47873106283614f49115e70c7b5dd9", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -8,6 +8,12 @@\n use std::iter;\n use std::sync::Arc;\n \n+use hir_def::{\n+    builtin_type::BuiltinType,\n+    path::{GenericArg, PathSegment},\n+    type_ref::{TypeBound, TypeRef},\n+};\n+\n use super::{\n     FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n     TypeWalk,\n@@ -18,13 +24,14 @@ use crate::{\n     generics::HasGenericParams,\n     generics::{GenericDef, WherePredicate},\n     nameres::Namespace,\n-    path::{GenericArg, PathSegment},\n     resolve::{Resolver, TypeNs},\n-    ty::Adt,\n-    type_ref::{TypeBound, TypeRef},\n+    ty::{\n+        primitive::{FloatTy, IntTy},\n+        Adt,\n+    },\n     util::make_mut_slice,\n-    BuiltinType, Const, Enum, EnumVariant, Function, ModuleDef, Path, Static, Struct, StructField,\n-    Trait, TypeAlias, Union,\n+    Const, Enum, EnumVariant, Function, ModuleDef, Path, Static, Struct, StructField, Trait,\n+    TypeAlias, Union,\n };\n \n impl Ty {\n@@ -640,8 +647,10 @@ fn type_for_builtin(def: BuiltinType) -> Ty {\n         BuiltinType::Char => TypeCtor::Char,\n         BuiltinType::Bool => TypeCtor::Bool,\n         BuiltinType::Str => TypeCtor::Str,\n-        BuiltinType::Int(ty) => TypeCtor::Int(ty.into()),\n-        BuiltinType::Float(ty) => TypeCtor::Float(ty.into()),\n+        BuiltinType::Int { signedness, bitness } => {\n+            TypeCtor::Int(IntTy { signedness, bitness }.into())\n+        }\n+        BuiltinType::Float { bitness } => TypeCtor::Float(FloatTy { bitness }.into()),\n     })\n }\n "}, {"sha": "eb69344f6a7425ae9f765cbddbe3ba28e1fe8bfb", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -5,18 +5,17 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n+use hir_def::CrateModuleId;\n use rustc_hash::FxHashMap;\n \n use super::{autoderef, lower, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n use crate::{\n     db::HirDatabase,\n     impl_block::{ImplBlock, ImplId},\n-    nameres::CrateModuleId,\n     resolve::Resolver,\n     ty::primitive::{FloatBitness, UncertainFloatTy, UncertainIntTy},\n     ty::{Ty, TypeCtor},\n-    type_ref::Mutability,\n-    AssocItem, Crate, Function, Module, Name, Trait,\n+    AssocItem, Crate, Function, Module, Mutability, Name, Trait,\n };\n \n /// This is used as a key for indexing impls.\n@@ -50,7 +49,7 @@ impl CrateImplBlocks {\n         let fingerprint = TyFingerprint::for_impl(ty);\n         fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n-                let module = Module { krate: self.krate, module_id: *module_id };\n+                let module = Module::new(self.krate, *module_id);\n                 ImplBlock::from_id(module, *impl_id)\n             },\n         )\n@@ -62,7 +61,7 @@ impl CrateImplBlocks {\n     ) -> impl Iterator<Item = ImplBlock> + 'a {\n         self.impls_by_trait.get(&tr).into_iter().flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n-                let module = Module { krate: self.krate, module_id: *module_id };\n+                let module = Module::new(self.krate, *module_id);\n                 ImplBlock::from_id(module, *impl_id)\n             },\n         )\n@@ -71,7 +70,7 @@ impl CrateImplBlocks {\n     pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplBlock> + 'a {\n         self.impls.values().chain(self.impls_by_trait.values()).flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n-                let module = Module { krate: self.krate, module_id: *module_id };\n+                let module = Module::new(self.krate, *module_id);\n                 ImplBlock::from_id(module, *impl_id)\n             },\n         )\n@@ -90,14 +89,14 @@ impl CrateImplBlocks {\n                     self.impls_by_trait\n                         .entry(tr.trait_)\n                         .or_insert_with(Vec::new)\n-                        .push((module.module_id, impl_id));\n+                        .push((module.id.module_id, impl_id));\n                 }\n             } else {\n                 if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n                     self.impls\n                         .entry(target_ty_fp)\n                         .or_insert_with(Vec::new)\n-                        .push((module.module_id, impl_id));\n+                        .push((module.id.module_id, impl_id));\n                 }\n             }\n         }"}, {"sha": "1749752f10e91442ef43a377acfae2a9fd72ff5f", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,27 +2,7 @@\n \n use std::fmt;\n \n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum Signedness {\n-    Signed,\n-    Unsigned,\n-}\n-\n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum IntBitness {\n-    Xsize,\n-    X8,\n-    X16,\n-    X32,\n-    X64,\n-    X128,\n-}\n-\n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum FloatBitness {\n-    X32,\n-    X64,\n-}\n+pub use hir_def::builtin_type::{FloatBitness, IntBitness, Signedness};\n \n #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n pub enum UncertainIntTy {"}, {"sha": "4f1eab1508afdca01768224369b680290c7868c2", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,7 +1,7 @@\n //! Trait solving using Chalk.\n use std::sync::{Arc, Mutex};\n \n-use chalk_ir::cast::Cast;\n+use chalk_ir::{cast::Cast, family::ChalkIr};\n use log::debug;\n use ra_db::salsa;\n use ra_prof::profile;\n@@ -33,7 +33,7 @@ impl TraitSolver {\n     fn solve(\n         &self,\n         db: &impl HirDatabase,\n-        goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal>>,\n+        goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<ChalkIr>>>,\n     ) -> Option<chalk_solve::Solution> {\n         let context = ChalkContext { db, krate: self.krate };\n         debug!(\"solve goal: {:?}\", goal);\n@@ -196,7 +196,7 @@ pub(crate) fn trait_solve_query(\n }\n \n fn solution_from_chalk(db: &impl HirDatabase, solution: chalk_solve::Solution) -> Solution {\n-    let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution>| {\n+    let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<ChalkIr>>| {\n         let value = subst\n             .value\n             .parameters"}, {"sha": "39ef9218279e6d7013f499ac38a51c83110754ed", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 82, "deletions": 75, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -4,11 +4,13 @@ use std::sync::Arc;\n use log::debug;\n \n use chalk_ir::{\n-    cast::Cast, Identifier, ImplId, Parameter, PlaceholderIndex, TypeId, TypeKindId, TypeName,\n-    UniverseIndex,\n+    cast::Cast, family::ChalkIr, Identifier, ImplId, Parameter, PlaceholderIndex, TypeId,\n+    TypeKindId, TypeName, UniverseIndex,\n };\n use chalk_rust_ir::{AssociatedTyDatum, ImplDatum, StructDatum, TraitDatum};\n \n+use hir_expand::name;\n+\n use ra_db::salsa::{InternId, InternKey};\n \n use super::{Canonical, ChalkContext, Impl, Obligation};\n@@ -38,8 +40,8 @@ where\n }\n \n impl ToChalk for Ty {\n-    type Chalk = chalk_ir::Ty;\n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty {\n+    type Chalk = chalk_ir::Ty<ChalkIr>;\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty<ChalkIr> {\n         match self {\n             Ty::Apply(apply_ty) => {\n                 let name = match apply_ty.ctor {\n@@ -62,21 +64,19 @@ impl ToChalk for Ty {\n                 chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast()\n             }\n             Ty::Param { idx, .. } => {\n-                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty()\n+                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty::<ChalkIr>()\n             }\n             Ty::Bound(idx) => chalk_ir::Ty::BoundVar(idx as usize),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n-            // FIXME this is clearly incorrect, but probably not too incorrect\n-            // and I'm not sure what to actually do with Ty::Unknown\n-            // maybe an alternative would be `for<T> T`? (meaningless in rust, but expressible in chalk's Ty)\n-            //\n-            // FIXME also dyn and impl Trait are currently handled like Unknown because Chalk doesn't have them yet\n+            // FIXME use Chalk's Dyn/Opaque once the bugs with that are fixed\n             Ty::Unknown | Ty::Dyn(_) | Ty::Opaque(_) => {\n-                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: usize::max_value() }.to_ty()\n+                let parameters = Vec::new();\n+                let name = TypeName::Error;\n+                chalk_ir::ApplicationTy { name, parameters }.cast()\n             }\n         }\n     }\n-    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty) -> Self {\n+    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty<ChalkIr>) -> Self {\n         match chalk {\n             chalk_ir::Ty::Apply(apply_ty) => {\n                 // FIXME this is kind of hacky due to the fact that\n@@ -92,6 +92,7 @@ impl ToChalk for Ty {\n                         let parameters = from_chalk(db, apply_ty.parameters);\n                         Ty::Apply(ApplicationTy { ctor, parameters })\n                     }\n+                    TypeName::Error => Ty::Unknown,\n                     // FIXME handle TypeKindId::Trait/Type here\n                     TypeName::TypeKindId(_) => unimplemented!(),\n                     TypeName::Placeholder(idx) => {\n@@ -108,18 +109,30 @@ impl ToChalk for Ty {\n             chalk_ir::Ty::ForAll(_) => unimplemented!(),\n             chalk_ir::Ty::BoundVar(idx) => Ty::Bound(idx as u32),\n             chalk_ir::Ty::InferenceVar(_iv) => Ty::Unknown,\n+            chalk_ir::Ty::Dyn(where_clauses) => {\n+                assert_eq!(where_clauses.binders.len(), 1);\n+                let predicates =\n+                    where_clauses.value.into_iter().map(|c| from_chalk(db, c)).collect();\n+                Ty::Dyn(predicates)\n+            }\n+            chalk_ir::Ty::Opaque(where_clauses) => {\n+                assert_eq!(where_clauses.binders.len(), 1);\n+                let predicates =\n+                    where_clauses.value.into_iter().map(|c| from_chalk(db, c)).collect();\n+                Ty::Opaque(predicates)\n+            }\n         }\n     }\n }\n \n impl ToChalk for Substs {\n-    type Chalk = Vec<chalk_ir::Parameter>;\n+    type Chalk = Vec<chalk_ir::Parameter<ChalkIr>>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> Vec<Parameter> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> Vec<Parameter<ChalkIr>> {\n         self.iter().map(|ty| ty.clone().to_chalk(db).cast()).collect()\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, parameters: Vec<chalk_ir::Parameter>) -> Substs {\n+    fn from_chalk(db: &impl HirDatabase, parameters: Vec<chalk_ir::Parameter<ChalkIr>>) -> Substs {\n         let tys = parameters\n             .into_iter()\n             .map(|p| match p {\n@@ -132,15 +145,15 @@ impl ToChalk for Substs {\n }\n \n impl ToChalk for TraitRef {\n-    type Chalk = chalk_ir::TraitRef;\n+    type Chalk = chalk_ir::TraitRef<ChalkIr>;\n \n-    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef {\n+    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef<ChalkIr> {\n         let trait_id = self.trait_.to_chalk(db);\n         let parameters = self.substs.to_chalk(db);\n         chalk_ir::TraitRef { trait_id, parameters }\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef) -> Self {\n+    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef<ChalkIr>) -> Self {\n         let trait_ = from_chalk(db, trait_ref.trait_id);\n         let substs = from_chalk(db, trait_ref.parameters);\n         TraitRef { trait_, substs }\n@@ -151,11 +164,11 @@ impl ToChalk for Trait {\n     type Chalk = chalk_ir::TraitId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TraitId {\n-        self.id.into()\n+        chalk_ir::TraitId(id_to_chalk(self.id))\n     }\n \n     fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> Trait {\n-        Trait { id: trait_id.into() }\n+        Trait { id: id_from_chalk(trait_id.0) }\n     }\n }\n \n@@ -187,18 +200,18 @@ impl ToChalk for TypeAlias {\n     type Chalk = chalk_ir::TypeId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TypeId {\n-        self.id.into()\n+        chalk_ir::TypeId(id_to_chalk(self.id))\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, impl_id: chalk_ir::TypeId) -> TypeAlias {\n-        TypeAlias { id: impl_id.into() }\n+    fn from_chalk(_db: &impl HirDatabase, type_alias_id: chalk_ir::TypeId) -> TypeAlias {\n+        TypeAlias { id: id_from_chalk(type_alias_id.0) }\n     }\n }\n \n impl ToChalk for GenericPredicate {\n-    type Chalk = chalk_ir::QuantifiedWhereClause;\n+    type Chalk = chalk_ir::QuantifiedWhereClause<ChalkIr>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::QuantifiedWhereClause {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::QuantifiedWhereClause<ChalkIr> {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => {\n                 make_binders(chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db)), 0)\n@@ -221,25 +234,40 @@ impl ToChalk for GenericPredicate {\n     }\n \n     fn from_chalk(\n-        _db: &impl HirDatabase,\n-        _where_clause: chalk_ir::QuantifiedWhereClause,\n+        db: &impl HirDatabase,\n+        where_clause: chalk_ir::QuantifiedWhereClause<ChalkIr>,\n     ) -> GenericPredicate {\n-        // This should never need to be called\n-        unimplemented!()\n+        match where_clause.value {\n+            chalk_ir::WhereClause::Implemented(tr) => {\n+                if tr.trait_id == UNKNOWN_TRAIT {\n+                    // FIXME we need an Error enum on the Chalk side to avoid this\n+                    return GenericPredicate::Error;\n+                }\n+                GenericPredicate::Implemented(from_chalk(db, tr))\n+            }\n+            chalk_ir::WhereClause::ProjectionEq(projection_eq) => {\n+                let projection_ty = from_chalk(db, projection_eq.projection);\n+                let ty = from_chalk(db, projection_eq.ty);\n+                GenericPredicate::Projection(super::ProjectionPredicate { projection_ty, ty })\n+            }\n+        }\n     }\n }\n \n impl ToChalk for ProjectionTy {\n-    type Chalk = chalk_ir::ProjectionTy;\n+    type Chalk = chalk_ir::ProjectionTy<ChalkIr>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ProjectionTy {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ProjectionTy<ChalkIr> {\n         chalk_ir::ProjectionTy {\n             associated_ty_id: self.associated_ty.to_chalk(db),\n             parameters: self.parameters.to_chalk(db),\n         }\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, projection_ty: chalk_ir::ProjectionTy) -> ProjectionTy {\n+    fn from_chalk(\n+        db: &impl HirDatabase,\n+        projection_ty: chalk_ir::ProjectionTy<ChalkIr>,\n+    ) -> ProjectionTy {\n         ProjectionTy {\n             associated_ty: from_chalk(db, projection_ty.associated_ty_id),\n             parameters: from_chalk(db, projection_ty.parameters),\n@@ -248,31 +276,31 @@ impl ToChalk for ProjectionTy {\n }\n \n impl ToChalk for super::ProjectionPredicate {\n-    type Chalk = chalk_ir::Normalize;\n+    type Chalk = chalk_ir::Normalize<ChalkIr>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Normalize {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Normalize<ChalkIr> {\n         chalk_ir::Normalize {\n             projection: self.projection_ty.to_chalk(db),\n             ty: self.ty.to_chalk(db),\n         }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _normalize: chalk_ir::Normalize) -> Self {\n+    fn from_chalk(_db: &impl HirDatabase, _normalize: chalk_ir::Normalize<ChalkIr>) -> Self {\n         unimplemented!()\n     }\n }\n \n impl ToChalk for Obligation {\n-    type Chalk = chalk_ir::DomainGoal;\n+    type Chalk = chalk_ir::DomainGoal<ChalkIr>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::DomainGoal {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::DomainGoal<ChalkIr> {\n         match self {\n             Obligation::Trait(tr) => tr.to_chalk(db).cast(),\n             Obligation::Projection(pr) => pr.to_chalk(db).cast(),\n         }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _goal: chalk_ir::DomainGoal) -> Self {\n+    fn from_chalk(_db: &impl HirDatabase, _goal: chalk_ir::DomainGoal<ChalkIr>) -> Self {\n         unimplemented!()\n     }\n }\n@@ -296,30 +324,33 @@ where\n }\n \n impl ToChalk for Arc<super::TraitEnvironment> {\n-    type Chalk = Arc<chalk_ir::Environment>;\n+    type Chalk = chalk_ir::Environment<ChalkIr>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> Arc<chalk_ir::Environment> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Environment<ChalkIr> {\n         let mut clauses = Vec::new();\n         for pred in &self.predicates {\n             if pred.is_error() {\n                 // for env, we just ignore errors\n                 continue;\n             }\n-            let program_clause: chalk_ir::ProgramClause = pred.clone().to_chalk(db).cast();\n+            let program_clause: chalk_ir::ProgramClause<ChalkIr> = pred.clone().to_chalk(db).cast();\n             clauses.push(program_clause.into_from_env_clause());\n         }\n         chalk_ir::Environment::new().add_clauses(clauses)\n     }\n \n     fn from_chalk(\n         _db: &impl HirDatabase,\n-        _env: Arc<chalk_ir::Environment>,\n+        _env: chalk_ir::Environment<ChalkIr>,\n     ) -> Arc<super::TraitEnvironment> {\n         unimplemented!()\n     }\n }\n \n-impl<T: ToChalk> ToChalk for super::InEnvironment<T> {\n+impl<T: ToChalk> ToChalk for super::InEnvironment<T>\n+where\n+    T::Chalk: chalk_ir::family::HasTypeFamily<TypeFamily = ChalkIr>,\n+{\n     type Chalk = chalk_ir::InEnvironment<T::Chalk>;\n \n     fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::InEnvironment<T::Chalk> {\n@@ -351,7 +382,7 @@ fn convert_where_clauses(\n     db: &impl HirDatabase,\n     def: GenericDef,\n     substs: &Substs,\n-) -> Vec<chalk_ir::QuantifiedWhereClause> {\n+) -> Vec<chalk_ir::QuantifiedWhereClause<ChalkIr>> {\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n@@ -384,7 +415,7 @@ where\n     fn impls_for_trait(\n         &self,\n         trait_id: chalk_ir::TraitId,\n-        parameters: &[Parameter],\n+        parameters: &[Parameter<ChalkIr>],\n     ) -> Vec<ImplId> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n         if trait_id == UNKNOWN_TRAIT {\n@@ -430,13 +461,13 @@ where\n     }\n     fn split_projection<'p>(\n         &self,\n-        projection: &'p chalk_ir::ProjectionTy,\n-    ) -> (Arc<AssociatedTyDatum>, &'p [Parameter], &'p [Parameter]) {\n+        projection: &'p chalk_ir::ProjectionTy<ChalkIr>,\n+    ) -> (Arc<AssociatedTyDatum>, &'p [Parameter<ChalkIr>], &'p [Parameter<ChalkIr>]) {\n         debug!(\"split_projection {:?}\", projection);\n         // we don't support GATs, so I think this should always be correct currently\n         (self.db.associated_ty_data(projection.associated_ty_id), &projection.parameters, &[])\n     }\n-    fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause> {\n+    fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<ChalkIr>> {\n         vec![]\n     }\n     fn local_impls_to_coherence_check(\n@@ -508,7 +539,7 @@ pub(crate) fn trait_datum_query(\n     let trait_ref = trait_.trait_ref(db).subst(&bound_vars).to_chalk(db);\n     let flags = chalk_rust_ir::TraitFlags {\n         auto: trait_.is_auto(db),\n-        upstream: trait_.module(db).krate(db) != Some(krate),\n+        upstream: trait_.module(db).krate() != krate,\n         non_enumerable: true,\n         // FIXME set these flags correctly\n         marker: false,\n@@ -596,7 +627,7 @@ fn impl_block_datum(\n         .target_trait_ref(db)\n         .expect(\"FIXME handle unresolved impl block trait ref\")\n         .subst(&bound_vars);\n-    let impl_type = if impl_block.module().krate(db) == Some(krate) {\n+    let impl_type = if impl_block.module().krate() == krate {\n         chalk_rust_ir::ImplType::Local\n     } else {\n         chalk_rust_ir::ImplType::External\n@@ -705,7 +736,7 @@ fn closure_fn_trait_impl_datum(\n         substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n     };\n \n-    let output_ty_id = fn_once_trait.associated_type_by_name(db, &crate::name::OUTPUT_TYPE)?;\n+    let output_ty_id = fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n \n     let output_ty_value = chalk_rust_ir::AssociatedTyValue {\n         associated_ty_id: output_ty_id.to_chalk(db),\n@@ -746,30 +777,6 @@ fn id_to_chalk<T: InternKey>(salsa_id: T) -> chalk_ir::RawId {\n     chalk_ir::RawId { index: salsa_id.as_intern_id().as_u32() }\n }\n \n-impl From<chalk_ir::TraitId> for crate::ids::TraitId {\n-    fn from(trait_id: chalk_ir::TraitId) -> Self {\n-        id_from_chalk(trait_id.0)\n-    }\n-}\n-\n-impl From<crate::ids::TraitId> for chalk_ir::TraitId {\n-    fn from(trait_id: crate::ids::TraitId) -> Self {\n-        chalk_ir::TraitId(id_to_chalk(trait_id))\n-    }\n-}\n-\n-impl From<chalk_ir::TypeId> for crate::ids::TypeAliasId {\n-    fn from(type_id: chalk_ir::TypeId) -> Self {\n-        id_from_chalk(type_id.0)\n-    }\n-}\n-\n-impl From<crate::ids::TypeAliasId> for chalk_ir::TypeId {\n-    fn from(type_id: crate::ids::TypeAliasId) -> Self {\n-        chalk_ir::TypeId(id_to_chalk(type_id))\n-    }\n-}\n-\n impl From<chalk_ir::StructId> for crate::ids::TypeCtorId {\n     fn from(struct_id: chalk_ir::StructId) -> Self {\n         id_from_chalk(struct_id.0)"}, {"sha": "078e6295eaa3f826612957b1f164e63ef2e13034", "filename": "crates/ra_hir/src/type_alias.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,12 +2,13 @@\n \n use std::sync::Arc;\n \n+use hir_def::type_ref::TypeRef;\n+use hir_expand::name::{AsName, Name};\n+\n use ra_syntax::ast::NameOwner;\n \n use crate::{\n     db::{AstDatabase, DefDatabase},\n-    name::{AsName, Name},\n-    type_ref::TypeRef,\n     HasSource, TypeAlias,\n };\n "}, {"sha": "746c907e80dabe4b23c10aa4f1bad2d768557330", "filename": "crates/ra_hir_def/Cargo.toml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,21 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_hir_def\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+log = \"0.4.5\"\n+once_cell = \"1.0.1\"\n+relative-path = \"1.0.0\"\n+rustc-hash = \"1.0\"\n+\n+ra_arena = { path = \"../ra_arena\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_prof = { path = \"../ra_prof\" }\n+hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n+test_utils = { path = \"../test_utils\" }\n+mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n+ra_cfg = { path = \"../ra_cfg\" }\n+tt = { path = \"../ra_tt\", package = \"ra_tt\" }"}, {"sha": "0e961ca12aff63a679b5a52dc317baff3d8d24e6", "filename": "crates/ra_hir_def/src/attr.rs", "status": "renamed", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,6 +2,7 @@\n \n use std::sync::Arc;\n \n+use hir_expand::hygiene::Hygiene;\n use mbe::ast_to_token_tree;\n use ra_cfg::CfgOptions;\n use ra_syntax::{\n@@ -10,10 +11,10 @@ use ra_syntax::{\n };\n use tt::Subtree;\n \n-use crate::{db::AstDatabase, path::Path, HirFileId, Source};\n+use crate::path::Path;\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub(crate) struct Attr {\n+pub struct Attr {\n     pub(crate) path: Path,\n     pub(crate) input: Option<AttrInput>,\n }\n@@ -25,11 +26,8 @@ pub enum AttrInput {\n }\n \n impl Attr {\n-    pub(crate) fn from_src(\n-        Source { file_id, ast }: Source<ast::Attr>,\n-        db: &impl AstDatabase,\n-    ) -> Option<Attr> {\n-        let path = Path::from_src(Source { file_id, ast: ast.path()? }, db)?;\n+    pub(crate) fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n+        let path = Path::from_src(ast.path()?, hygiene)?;\n         let input = match ast.input() {\n             None => None,\n             Some(ast::AttrInput::Literal(lit)) => {\n@@ -45,26 +43,22 @@ impl Attr {\n         Some(Attr { path, input })\n     }\n \n-    pub(crate) fn from_attrs_owner(\n-        file_id: HirFileId,\n-        owner: &dyn AttrsOwner,\n-        db: &impl AstDatabase,\n-    ) -> Option<Arc<[Attr]>> {\n+    pub fn from_attrs_owner(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Option<Arc<[Attr]>> {\n         let mut attrs = owner.attrs().peekable();\n         if attrs.peek().is_none() {\n             // Avoid heap allocation\n             return None;\n         }\n-        Some(attrs.flat_map(|ast| Attr::from_src(Source { file_id, ast }, db)).collect())\n+        Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).collect())\n     }\n \n-    pub(crate) fn is_simple_atom(&self, name: &str) -> bool {\n+    pub fn is_simple_atom(&self, name: &str) -> bool {\n         // FIXME: Avoid cloning\n         self.path.as_ident().map_or(false, |s| s.to_string() == name)\n     }\n \n     // FIXME: handle cfg_attr :-)\n-    pub(crate) fn as_cfg(&self) -> Option<&Subtree> {\n+    pub fn as_cfg(&self) -> Option<&Subtree> {\n         if !self.is_simple_atom(\"cfg\") {\n             return None;\n         }\n@@ -74,7 +68,7 @@ impl Attr {\n         }\n     }\n \n-    pub(crate) fn as_path(&self) -> Option<&SmolStr> {\n+    pub fn as_path(&self) -> Option<&SmolStr> {\n         if !self.is_simple_atom(\"path\") {\n             return None;\n         }\n@@ -84,7 +78,7 @@ impl Attr {\n         }\n     }\n \n-    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> Option<bool> {\n+    pub fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> Option<bool> {\n         cfg_options.is_cfg_enabled(self.as_cfg()?)\n     }\n }", "previous_filename": "crates/ra_hir/src/attr.rs"}, {"sha": "12929caa9003e027dbeb8b36664805315f549884", "filename": "crates/ra_hir_def/src/builtin_type.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,63 @@\n+//! This module defines built-in types.\n+//!\n+//! A peculiarity of built-in types is that they are always available and are\n+//! not associated with any particular crate.\n+\n+use hir_expand::name::{self, Name};\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n+pub enum Signedness {\n+    Signed,\n+    Unsigned,\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n+pub enum IntBitness {\n+    Xsize,\n+    X8,\n+    X16,\n+    X32,\n+    X64,\n+    X128,\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n+pub enum FloatBitness {\n+    X32,\n+    X64,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum BuiltinType {\n+    Char,\n+    Bool,\n+    Str,\n+    Int { signedness: Signedness, bitness: IntBitness },\n+    Float { bitness: FloatBitness },\n+}\n+\n+impl BuiltinType {\n+    #[rustfmt::skip]\n+    pub const ALL: &'static [(Name, BuiltinType)] = &[\n+        (name::CHAR, BuiltinType::Char),\n+        (name::BOOL, BuiltinType::Bool),\n+        (name::STR,  BuiltinType::Str ),\n+\n+        (name::ISIZE, BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::Xsize }),\n+        (name::I8,    BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::X8    }),\n+        (name::I16,   BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::X16   }),\n+        (name::I32,   BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::X32   }),\n+        (name::I64,   BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::X64   }),\n+        (name::I128,  BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::X128  }),\n+\n+        (name::USIZE, BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize }),\n+        (name::U8,    BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::X8    }),\n+        (name::U16,   BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::X16   }),\n+        (name::U32,   BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::X32   }),\n+        (name::U64,   BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::X64   }),\n+        (name::U128,  BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::X128  }),\n+\n+        (name::F32, BuiltinType::Float { bitness: FloatBitness::X32 }),\n+        (name::F64, BuiltinType::Float { bitness: FloatBitness::X64 }),\n+    ];\n+}"}, {"sha": "b271636b07e7b003f87c104d5a753a75de59d477", "filename": "crates/ra_hir_def/src/db.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,40 @@\n+//! Defines database & queries for name resolution.\n+use std::sync::Arc;\n+\n+use hir_expand::{db::AstDatabase, HirFileId};\n+use ra_db::{salsa, SourceDatabase};\n+use ra_syntax::ast;\n+\n+use crate::nameres::raw::{ImportSourceMap, RawItems};\n+\n+#[salsa::query_group(InternDatabaseStorage)]\n+pub trait InternDatabase: SourceDatabase {\n+    #[salsa::interned]\n+    fn intern_function(&self, loc: crate::ItemLoc<ast::FnDef>) -> crate::FunctionId;\n+    #[salsa::interned]\n+    fn intern_struct(&self, loc: crate::ItemLoc<ast::StructDef>) -> crate::StructId;\n+    #[salsa::interned]\n+    fn intern_union(&self, loc: crate::ItemLoc<ast::StructDef>) -> crate::UnionId;\n+    #[salsa::interned]\n+    fn intern_enum(&self, loc: crate::ItemLoc<ast::EnumDef>) -> crate::EnumId;\n+    #[salsa::interned]\n+    fn intern_const(&self, loc: crate::ItemLoc<ast::ConstDef>) -> crate::ConstId;\n+    #[salsa::interned]\n+    fn intern_static(&self, loc: crate::ItemLoc<ast::StaticDef>) -> crate::StaticId;\n+    #[salsa::interned]\n+    fn intern_trait(&self, loc: crate::ItemLoc<ast::TraitDef>) -> crate::TraitId;\n+    #[salsa::interned]\n+    fn intern_type_alias(&self, loc: crate::ItemLoc<ast::TypeAliasDef>) -> crate::TypeAliasId;\n+}\n+\n+#[salsa::query_group(DefDatabase2Storage)]\n+pub trait DefDatabase2: InternDatabase + AstDatabase {\n+    #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n+    fn raw_items_with_source_map(\n+        &self,\n+        file_id: HirFileId,\n+    ) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n+\n+    #[salsa::invoke(RawItems::raw_items_query)]\n+    fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n+}"}, {"sha": "93ad40005c7f1df25f198bd84ab0dd5a5e8f8356", "filename": "crates/ra_hir_def/src/lib.rs", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,362 @@\n+//! `hir_def` crate contains everything between macro expansion and type\n+//! inference.\n+//!\n+//! It defines various items (structs, enums, traits) which comprises Rust code,\n+//! as well as an algorithm for resolving paths to such entities.\n+//!\n+//! Note that `hir_def` is a work in progress, so not all of the above is\n+//! actually true.\n+\n+pub mod db;\n+pub mod attr;\n+pub mod path;\n+pub mod type_ref;\n+pub mod builtin_type;\n+\n+// FIXME: this should be private\n+pub mod nameres;\n+\n+use std::hash::{Hash, Hasher};\n+\n+use hir_expand::{ast_id_map::FileAstId, db::AstDatabase, AstId, HirFileId};\n+use ra_arena::{impl_arena_id, RawId};\n+use ra_db::{salsa, CrateId, FileId};\n+use ra_syntax::{ast, AstNode, SyntaxNode};\n+\n+use crate::{builtin_type::BuiltinType, db::InternDatabase};\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub struct Source<T> {\n+    pub file_id: HirFileId,\n+    pub ast: T,\n+}\n+\n+pub enum ModuleSource {\n+    SourceFile(ast::SourceFile),\n+    Module(ast::Module),\n+}\n+\n+impl ModuleSource {\n+    pub fn new(\n+        db: &impl db::DefDatabase2,\n+        file_id: Option<FileId>,\n+        decl_id: Option<AstId<ast::Module>>,\n+    ) -> ModuleSource {\n+        match (file_id, decl_id) {\n+            (Some(file_id), _) => {\n+                let source_file = db.parse(file_id).tree();\n+                ModuleSource::SourceFile(source_file)\n+            }\n+            (None, Some(item_id)) => {\n+                let module = item_id.to_node(db);\n+                assert!(module.item_list().is_some(), \"expected inline module\");\n+                ModuleSource::Module(module)\n+            }\n+            (None, None) => panic!(),\n+        }\n+    }\n+\n+    // FIXME: this methods do not belong here\n+    pub fn from_position(\n+        db: &impl db::DefDatabase2,\n+        position: ra_db::FilePosition,\n+    ) -> ModuleSource {\n+        let parse = db.parse(position.file_id);\n+        match &ra_syntax::algo::find_node_at_offset::<ast::Module>(\n+            parse.tree().syntax(),\n+            position.offset,\n+        ) {\n+            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n+            _ => {\n+                let source_file = parse.tree();\n+                ModuleSource::SourceFile(source_file)\n+            }\n+        }\n+    }\n+\n+    pub fn from_child_node(\n+        db: &impl db::DefDatabase2,\n+        file_id: FileId,\n+        child: &SyntaxNode,\n+    ) -> ModuleSource {\n+        if let Some(m) = child.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi()) {\n+            ModuleSource::Module(m)\n+        } else {\n+            let source_file = db.parse(file_id).tree();\n+            ModuleSource::SourceFile(source_file)\n+        }\n+    }\n+\n+    pub fn from_file_id(db: &impl db::DefDatabase2, file_id: FileId) -> ModuleSource {\n+        let source_file = db.parse(file_id).tree();\n+        ModuleSource::SourceFile(source_file)\n+    }\n+}\n+\n+impl<T> Source<T> {\n+    pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n+        Source { file_id: self.file_id, ast: f(self.ast) }\n+    }\n+    pub fn file_syntax(&self, db: &impl AstDatabase) -> SyntaxNode {\n+        db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ModuleId {\n+    pub krate: CrateId,\n+    pub module_id: CrateModuleId,\n+}\n+\n+/// An ID of a module, **local** to a specific crate\n+// FIXME: rename to `LocalModuleId`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct CrateModuleId(RawId);\n+impl_arena_id!(CrateModuleId);\n+\n+macro_rules! impl_intern_key {\n+    ($name:ident) => {\n+        impl salsa::InternKey for $name {\n+            fn from_intern_id(v: salsa::InternId) -> Self {\n+                $name(v)\n+            }\n+            fn as_intern_id(&self) -> salsa::InternId {\n+                self.0\n+            }\n+        }\n+    };\n+}\n+\n+#[derive(Debug)]\n+pub struct ItemLoc<N: AstNode> {\n+    pub(crate) module: ModuleId,\n+    ast_id: AstId<N>,\n+}\n+\n+impl<N: AstNode> PartialEq for ItemLoc<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.module == other.module && self.ast_id == other.ast_id\n+    }\n+}\n+impl<N: AstNode> Eq for ItemLoc<N> {}\n+impl<N: AstNode> Hash for ItemLoc<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.module.hash(hasher);\n+        self.ast_id.hash(hasher);\n+    }\n+}\n+\n+impl<N: AstNode> Clone for ItemLoc<N> {\n+    fn clone(&self) -> ItemLoc<N> {\n+        ItemLoc { module: self.module, ast_id: self.ast_id }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct LocationCtx<DB> {\n+    db: DB,\n+    module: ModuleId,\n+    file_id: HirFileId,\n+}\n+\n+impl<'a, DB> LocationCtx<&'a DB> {\n+    pub fn new(db: &'a DB, module: ModuleId, file_id: HirFileId) -> LocationCtx<&'a DB> {\n+        LocationCtx { db, module, file_id }\n+    }\n+}\n+\n+impl<'a, DB: AstDatabase + InternDatabase> LocationCtx<&'a DB> {\n+    pub fn to_def<N, DEF>(self, ast: &N) -> DEF\n+    where\n+        N: AstNode,\n+        DEF: AstItemDef<N>,\n+    {\n+        DEF::from_ast(self, ast)\n+    }\n+}\n+\n+pub trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<N>) -> Self;\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<N>;\n+\n+    fn from_ast(ctx: LocationCtx<&(impl AstDatabase + InternDatabase)>, ast: &N) -> Self {\n+        let items = ctx.db.ast_id_map(ctx.file_id);\n+        let item_id = items.ast_id(ast);\n+        Self::from_ast_id(ctx, item_id)\n+    }\n+    fn from_ast_id(ctx: LocationCtx<&impl InternDatabase>, ast_id: FileAstId<N>) -> Self {\n+        let loc = ItemLoc { module: ctx.module, ast_id: AstId::new(ctx.file_id, ast_id) };\n+        Self::intern(ctx.db, loc)\n+    }\n+    fn source(self, db: &(impl AstDatabase + InternDatabase)) -> Source<N> {\n+        let loc = self.lookup_intern(db);\n+        let ast = loc.ast_id.to_node(db);\n+        Source { file_id: loc.ast_id.file_id(), ast }\n+    }\n+    fn module(self, db: &impl InternDatabase) -> ModuleId {\n+        let loc = self.lookup_intern(db);\n+        loc.module\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct FunctionId(salsa::InternId);\n+impl_intern_key!(FunctionId);\n+\n+impl AstItemDef<ast::FnDef> for FunctionId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::FnDef>) -> Self {\n+        db.intern_function(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::FnDef> {\n+        db.lookup_intern_function(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct StructId(salsa::InternId);\n+impl_intern_key!(StructId);\n+impl AstItemDef<ast::StructDef> for StructId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StructDef>) -> Self {\n+        db.intern_struct(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StructDef> {\n+        db.lookup_intern_struct(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct UnionId(salsa::InternId);\n+impl_intern_key!(UnionId);\n+impl AstItemDef<ast::StructDef> for UnionId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StructDef>) -> Self {\n+        db.intern_union(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StructDef> {\n+        db.lookup_intern_union(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct EnumId(salsa::InternId);\n+impl_intern_key!(EnumId);\n+impl AstItemDef<ast::EnumDef> for EnumId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::EnumDef>) -> Self {\n+        db.intern_enum(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::EnumDef> {\n+        db.lookup_intern_enum(self)\n+    }\n+}\n+\n+// FIXME: rename to `VariantId`, only enums can ave variants\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct EnumVariantId {\n+    parent: EnumId,\n+    local_id: LocalEnumVariantId,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct LocalEnumVariantId(RawId);\n+impl_arena_id!(LocalEnumVariantId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ConstId(salsa::InternId);\n+impl_intern_key!(ConstId);\n+impl AstItemDef<ast::ConstDef> for ConstId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::ConstDef>) -> Self {\n+        db.intern_const(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::ConstDef> {\n+        db.lookup_intern_const(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct StaticId(salsa::InternId);\n+impl_intern_key!(StaticId);\n+impl AstItemDef<ast::StaticDef> for StaticId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::StaticDef>) -> Self {\n+        db.intern_static(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::StaticDef> {\n+        db.lookup_intern_static(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TraitId(salsa::InternId);\n+impl_intern_key!(TraitId);\n+impl AstItemDef<ast::TraitDef> for TraitId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::TraitDef>) -> Self {\n+        db.intern_trait(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::TraitDef> {\n+        db.lookup_intern_trait(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TypeAliasId(salsa::InternId);\n+impl_intern_key!(TypeAliasId);\n+impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::TypeAliasDef>) -> Self {\n+        db.intern_type_alias(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::TypeAliasDef> {\n+        db.lookup_intern_type_alias(self)\n+    }\n+}\n+\n+macro_rules! impl_froms {\n+    ($e:ident: $($v:ident $(($($sv:ident),*))?),*) => {\n+        $(\n+            impl From<$v> for $e {\n+                fn from(it: $v) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+            $($(\n+                impl From<$sv> for $e {\n+                    fn from(it: $sv) -> $e {\n+                        $e::$v($v::$sv(it))\n+                    }\n+                }\n+            )*)?\n+        )*\n+    }\n+}\n+\n+/// A Data Type\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum AdtId {\n+    StructId(StructId),\n+    UnionId(UnionId),\n+    EnumId(EnumId),\n+}\n+impl_froms!(AdtId: StructId, UnionId, EnumId);\n+\n+/// The defs which can be visible in the module.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum ModuleDefId {\n+    ModuleId(ModuleId),\n+    FunctionId(FunctionId),\n+    AdtId(AdtId),\n+    // Can't be directly declared, but can be imported.\n+    EnumVariantId(EnumVariantId),\n+    ConstId(ConstId),\n+    StaticId(StaticId),\n+    TraitId(TraitId),\n+    TypeAliasId(TypeAliasId),\n+    BuiltinType(BuiltinType),\n+}\n+impl_froms!(\n+    ModuleDefId: ModuleId,\n+    FunctionId,\n+    AdtId(StructId, EnumId, UnionId),\n+    EnumVariantId,\n+    ConstId,\n+    StaticId,\n+    TraitId,\n+    TypeAliasId,\n+    BuiltinType\n+);"}, {"sha": "11ba8a7770d9f2af71ab311a9747fc5ee52494b7", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,5 @@\n+//! FIXME: write short doc here\n+\n+// FIXME: review privacy of submodules\n+pub mod raw;\n+pub mod mod_resolution;"}, {"sha": "7d7e2779aa2045ee039c0eb78193cf7619ba6fc3", "filename": "crates/ra_hir_def/src/nameres/mod_resolution.rs", "status": "renamed", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,12 +1,13 @@\n //! This module resolves `mod foo;` declaration to file.\n+use hir_expand::name::Name;\n use ra_db::FileId;\n use ra_syntax::SmolStr;\n use relative_path::RelativePathBuf;\n \n-use crate::{db::DefDatabase, HirFileId, Name};\n+use crate::{db::DefDatabase2, HirFileId};\n \n #[derive(Clone, Debug)]\n-pub(super) struct ModDir {\n+pub struct ModDir {\n     /// `.` for `mod.rs`, `lib.rs`\n     /// `./foo` for `foo.rs`\n     /// `./foo/bar` for `mod bar { mod x; }` nested in `foo.rs`\n@@ -16,49 +17,38 @@ pub(super) struct ModDir {\n }\n \n impl ModDir {\n-    pub(super) fn root() -> ModDir {\n+    pub fn root() -> ModDir {\n         ModDir { path: RelativePathBuf::default(), root_non_dir_owner: false }\n     }\n \n-    pub(super) fn descend_into_definition(\n-        &self,\n-        name: &Name,\n-        attr_path: Option<&SmolStr>,\n-    ) -> ModDir {\n+    pub fn descend_into_definition(&self, name: &Name, attr_path: Option<&SmolStr>) -> ModDir {\n         let mut path = self.path.clone();\n         match attr_to_path(attr_path) {\n             None => path.push(&name.to_string()),\n             Some(attr_path) => {\n                 if self.root_non_dir_owner {\n-                    // Workaround for relative path API: turn `lib.rs` into ``.\n-                    if !path.pop() {\n-                        path = RelativePathBuf::default();\n-                    }\n+                    assert!(path.pop());\n                 }\n                 path.push(attr_path);\n             }\n         }\n         ModDir { path, root_non_dir_owner: false }\n     }\n \n-    pub(super) fn resolve_declaration(\n+    pub fn resolve_declaration(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &impl DefDatabase2,\n         file_id: HirFileId,\n         name: &Name,\n         attr_path: Option<&SmolStr>,\n     ) -> Result<(FileId, ModDir), RelativePathBuf> {\n-        let empty_path = RelativePathBuf::default();\n         let file_id = file_id.original_file(db);\n \n         let mut candidate_files = Vec::new();\n         match attr_to_path(attr_path) {\n             Some(attr_path) => {\n-                let base = if self.root_non_dir_owner {\n-                    self.path.parent().unwrap_or(&empty_path)\n-                } else {\n-                    &self.path\n-                };\n+                let base =\n+                    if self.root_non_dir_owner { self.path.parent().unwrap() } else { &self.path };\n                 candidate_files.push(base.join(attr_path))\n             }\n             None => {", "previous_filename": "crates/ra_hir/src/nameres/mod_resolution.rs"}, {"sha": "86c05d6028e72c9171ea11d44e93ef7150699a7f", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "renamed", "additions": 53, "deletions": 56, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,18 +2,20 @@\n \n use std::{ops::Index, sync::Arc};\n \n+use hir_expand::{\n+    ast_id_map::AstIdMap,\n+    db::AstDatabase,\n+    either::Either,\n+    hygiene::Hygiene,\n+    name::{AsName, Name},\n+};\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n     AstNode, AstPtr, SourceFile,\n };\n-use test_utils::tested_by;\n \n-use crate::{\n-    attr::Attr,\n-    db::{AstDatabase, DefDatabase},\n-    AsName, AstIdMap, Either, FileAstId, HirFileId, ModuleSource, Name, Path, Source,\n-};\n+use crate::{attr::Attr, db::DefDatabase2, path::Path, FileAstId, HirFileId, ModuleSource, Source};\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n ///\n@@ -37,45 +39,43 @@ pub struct ImportSourceMap {\n type ImportSourcePtr = Either<AstPtr<ast::UseTree>, AstPtr<ast::ExternCrateItem>>;\n type ImportSource = Either<ast::UseTree, ast::ExternCrateItem>;\n \n-impl ImportSourcePtr {\n-    fn to_node(self, file: &SourceFile) -> ImportSource {\n-        self.map(|ptr| ptr.to_node(file.syntax()), |ptr| ptr.to_node(file.syntax()))\n-    }\n+fn to_node(ptr: ImportSourcePtr, file: &SourceFile) -> ImportSource {\n+    ptr.map(|ptr| ptr.to_node(file.syntax()), |ptr| ptr.to_node(file.syntax()))\n }\n \n impl ImportSourceMap {\n     fn insert(&mut self, import: ImportId, ptr: ImportSourcePtr) {\n         self.map.insert(import, ptr)\n     }\n \n-    pub(crate) fn get(&self, source: &ModuleSource, import: ImportId) -> ImportSource {\n+    pub fn get(&self, source: &ModuleSource, import: ImportId) -> ImportSource {\n         let file = match source {\n             ModuleSource::SourceFile(file) => file.clone(),\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n         };\n \n-        self.map[import].to_node(&file)\n+        to_node(self.map[import], &file)\n     }\n }\n \n impl RawItems {\n     pub(crate) fn raw_items_query(\n-        db: &(impl DefDatabase + AstDatabase),\n+        db: &(impl DefDatabase2 + AstDatabase),\n         file_id: HirFileId,\n     ) -> Arc<RawItems> {\n         db.raw_items_with_source_map(file_id).0\n     }\n \n     pub(crate) fn raw_items_with_source_map_query(\n-        db: &(impl DefDatabase + AstDatabase),\n+        db: &(impl DefDatabase2 + AstDatabase),\n         file_id: HirFileId,\n     ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n             source_ast_id_map: db.ast_id_map(file_id),\n             source_map: ImportSourceMap::default(),\n             file_id,\n-            db,\n+            hygiene: Hygiene::new(db, file_id),\n         };\n         if let Some(node) = db.parse_or_expand(file_id) {\n             if let Some(source_file) = ast::SourceFile::cast(node.clone()) {\n@@ -87,7 +87,7 @@ impl RawItems {\n         (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n     }\n \n-    pub(super) fn items(&self) -> &[RawItem] {\n+    pub fn items(&self) -> &[RawItem] {\n         &self.items\n     }\n }\n@@ -124,31 +124,31 @@ impl Index<Macro> for RawItems {\n type Attrs = Option<Arc<[Attr]>>;\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n-pub(super) struct RawItem {\n+pub struct RawItem {\n     attrs: Attrs,\n-    pub(super) kind: RawItemKind,\n+    pub kind: RawItemKind,\n }\n \n impl RawItem {\n-    pub(super) fn attrs(&self) -> &[Attr] {\n+    pub fn attrs(&self) -> &[Attr] {\n         self.attrs.as_ref().map_or(&[], |it| &*it)\n     }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum RawItemKind {\n+pub enum RawItemKind {\n     Module(Module),\n     Import(ImportId),\n     Def(Def),\n     Macro(Macro),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(super) struct Module(RawId);\n+pub struct Module(RawId);\n impl_arena_id!(Module);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(super) enum ModuleData {\n+pub enum ModuleData {\n     Declaration { name: Name, ast_id: FileAstId<ast::Module> },\n     Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n }\n@@ -159,26 +159,26 @@ impl_arena_id!(ImportId);\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n-    pub(super) path: Path,\n-    pub(super) alias: Option<Name>,\n-    pub(super) is_glob: bool,\n-    pub(super) is_prelude: bool,\n-    pub(super) is_extern_crate: bool,\n-    pub(super) is_macro_use: bool,\n+    pub path: Path,\n+    pub alias: Option<Name>,\n+    pub is_glob: bool,\n+    pub is_prelude: bool,\n+    pub is_extern_crate: bool,\n+    pub is_macro_use: bool,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(super) struct Def(RawId);\n+pub struct Def(RawId);\n impl_arena_id!(Def);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(super) struct DefData {\n-    pub(super) name: Name,\n-    pub(super) kind: DefKind,\n+pub struct DefData {\n+    pub name: Name,\n+    pub kind: DefKind,\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum DefKind {\n+pub enum DefKind {\n     Function(FileAstId<ast::FnDef>),\n     Struct(FileAstId<ast::StructDef>),\n     Union(FileAstId<ast::StructDef>),\n@@ -190,26 +190,26 @@ pub(super) enum DefKind {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(super) struct Macro(RawId);\n+pub struct Macro(RawId);\n impl_arena_id!(Macro);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(super) struct MacroData {\n-    pub(super) ast_id: FileAstId<ast::MacroCall>,\n-    pub(super) path: Path,\n-    pub(super) name: Option<Name>,\n-    pub(super) export: bool,\n+pub struct MacroData {\n+    pub ast_id: FileAstId<ast::MacroCall>,\n+    pub path: Path,\n+    pub name: Option<Name>,\n+    pub export: bool,\n }\n \n-struct RawItemsCollector<DB> {\n+struct RawItemsCollector {\n     raw_items: RawItems,\n     source_ast_id_map: Arc<AstIdMap>,\n     source_map: ImportSourceMap,\n     file_id: HirFileId,\n-    db: DB,\n+    hygiene: Hygiene,\n }\n \n-impl<DB: AstDatabase> RawItemsCollector<&DB> {\n+impl RawItemsCollector {\n     fn process_module(&mut self, current_module: Option<Module>, body: impl ast::ModuleItemOwner) {\n         for item_or_macro in body.items_with_macros() {\n             match item_or_macro {\n@@ -297,17 +297,19 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n             self.push_item(current_module, attrs, RawItemKind::Module(item));\n             return;\n         }\n-        tested_by!(name_res_works_for_broken_modules);\n+        // FIXME: restore this mark once we complete hir splitting\n+        // tested_by!(name_res_works_for_broken_modules);\n     }\n \n     fn add_use_item(&mut self, current_module: Option<Module>, use_item: ast::UseItem) {\n         // FIXME: cfg_attr\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n         let attrs = self.parse_attrs(&use_item);\n \n+        let mut buf = Vec::new();\n         Path::expand_use_item(\n             Source { ast: use_item, file_id: self.file_id },\n-            self.db,\n+            &self.hygiene,\n             |path, use_tree, is_glob, alias| {\n                 let import_data = ImportData {\n                     path,\n@@ -317,14 +319,12 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n                     is_extern_crate: false,\n                     is_macro_use: false,\n                 };\n-                self.push_import(\n-                    current_module,\n-                    attrs.clone(),\n-                    import_data,\n-                    Either::A(AstPtr::new(use_tree)),\n-                );\n+                buf.push((import_data, Either::A(AstPtr::new(use_tree))));\n             },\n-        )\n+        );\n+        for (import_data, ptr) in buf {\n+            self.push_import(current_module, attrs.clone(), import_data, ptr);\n+        }\n     }\n \n     fn add_extern_crate_item(\n@@ -357,10 +357,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: ast::MacroCall) {\n         let attrs = self.parse_attrs(&m);\n-        let path = match m\n-            .path()\n-            .and_then(|path| Path::from_src(Source { ast: path, file_id: self.file_id }, self.db))\n-        {\n+        let path = match m.path().and_then(|path| Path::from_src(path, &self.hygiene)) {\n             Some(it) => it,\n             _ => return,\n         };\n@@ -398,6 +395,6 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n     }\n \n     fn parse_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n-        Attr::from_attrs_owner(self.file_id, item, self.db)\n+        Attr::from_attrs_owner(item, &self.hygiene)\n     }\n }", "previous_filename": "crates/ra_hir/src/nameres/raw.rs"}, {"sha": "04039376f3942449b83437beac1a280bef8c74b6", "filename": "crates/ra_hir_def/src/path.rs", "status": "renamed", "additions": 59, "deletions": 56, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,12 +2,18 @@\n \n use std::{iter, sync::Arc};\n \n+use hir_expand::{\n+    either::Either,\n+    hygiene::Hygiene,\n+    name::{self, AsName, Name},\n+};\n+use ra_db::CrateId;\n use ra_syntax::{\n     ast::{self, NameOwner, TypeAscriptionOwner},\n     AstNode,\n };\n \n-use crate::{db::AstDatabase, name, type_ref::TypeRef, AsName, Crate, Name, Source};\n+use crate::{type_ref::TypeRef, Source};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n@@ -55,18 +61,18 @@ pub enum PathKind {\n     // Type based path like `<T>::foo`\n     Type(Box<TypeRef>),\n     // `$crate` from macro expansion\n-    DollarCrate(Crate),\n+    DollarCrate(CrateId),\n }\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n     pub fn expand_use_item(\n         item_src: Source<ast::UseItem>,\n-        db: &impl AstDatabase,\n+        hygiene: &Hygiene,\n         mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n     ) {\n         if let Some(tree) = item_src.ast.use_tree() {\n-            expand_use_tree(None, tree, &|| item_src.file_id.macro_crate(db), &mut cb);\n+            expand_use_tree(None, tree, hygiene, &mut cb);\n         }\n     }\n \n@@ -83,17 +89,12 @@ impl Path {\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// DEPRECATED: It does not handle `$crate` from macro call.\n     pub fn from_ast(path: ast::Path) -> Option<Path> {\n-        Path::parse(path, &|| None)\n+        Path::from_src(path, &Hygiene::new_unhygienic())\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n-    pub fn from_src(source: Source<ast::Path>, db: &impl AstDatabase) -> Option<Path> {\n-        let file_id = source.file_id;\n-        Path::parse(source.ast, &|| file_id.macro_crate(db))\n-    }\n-\n-    fn parse(mut path: ast::Path, macro_crate: &impl Fn() -> Option<Crate>) -> Option<Path> {\n+    pub fn from_src(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -104,26 +105,28 @@ impl Path {\n             }\n \n             match segment.kind()? {\n-                ast::PathSegmentKind::Name(name) => {\n-                    if name.text() == \"$crate\" {\n-                        if let Some(macro_crate) = macro_crate() {\n-                            kind = PathKind::DollarCrate(macro_crate);\n+                ast::PathSegmentKind::Name(name_ref) => {\n+                    // FIXME: this should just return name\n+                    match hygiene.name_ref_to_name(name_ref) {\n+                        Either::A(name) => {\n+                            let args = segment\n+                                .type_arg_list()\n+                                .and_then(GenericArgs::from_ast)\n+                                .or_else(|| {\n+                                    GenericArgs::from_fn_like_path_ast(\n+                                        segment.param_list(),\n+                                        segment.ret_type(),\n+                                    )\n+                                })\n+                                .map(Arc::new);\n+                            let segment = PathSegment { name, args_and_bindings: args };\n+                            segments.push(segment);\n+                        }\n+                        Either::B(crate_id) => {\n+                            kind = PathKind::DollarCrate(crate_id);\n                             break;\n                         }\n                     }\n-\n-                    let args = segment\n-                        .type_arg_list()\n-                        .and_then(GenericArgs::from_ast)\n-                        .or_else(|| {\n-                            GenericArgs::from_fn_like_path_ast(\n-                                segment.param_list(),\n-                                segment.ret_type(),\n-                            )\n-                        })\n-                        .map(Arc::new);\n-                    let segment = PathSegment { name: name.as_name(), args_and_bindings: args };\n-                    segments.push(segment);\n                 }\n                 ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                     assert!(path.qualifier().is_none()); // this can only occur at the first segment\n@@ -137,7 +140,7 @@ impl Path {\n                         }\n                         // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                         Some(trait_ref) => {\n-                            let path = Path::parse(trait_ref.path()?, macro_crate)?;\n+                            let path = Path::from_src(trait_ref.path()?, hygiene)?;\n                             kind = path.kind;\n                             let mut prefix_segments = path.segments;\n                             prefix_segments.reverse();\n@@ -224,7 +227,7 @@ impl Path {\n }\n \n impl GenericArgs {\n-    pub(crate) fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n+    pub fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n         let mut args = Vec::new();\n         for type_arg in node.type_args() {\n             let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n@@ -288,22 +291,22 @@ impl From<Name> for Path {\n fn expand_use_tree(\n     prefix: Option<Path>,\n     tree: ast::UseTree,\n-    macro_crate: &impl Fn() -> Option<Crate>,\n-    cb: &mut impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n+    hygiene: &Hygiene,\n+    cb: &mut dyn FnMut(Path, &ast::UseTree, bool, Option<Name>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n         let prefix = match tree.path() {\n             // E.g. use something::{{{inner}}};\n             None => prefix,\n             // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n             // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n-            Some(path) => match convert_path(prefix, path, macro_crate) {\n+            Some(path) => match convert_path(prefix, path, hygiene) {\n                 Some(it) => Some(it),\n                 None => return, // FIXME: report errors somewhere\n             },\n         };\n         for child_tree in use_tree_list.use_trees() {\n-            expand_use_tree(prefix.clone(), child_tree, macro_crate, cb);\n+            expand_use_tree(prefix.clone(), child_tree, hygiene, cb);\n         }\n     } else {\n         let alias = tree.alias().and_then(|a| a.name()).map(|a| a.as_name());\n@@ -320,7 +323,7 @@ fn expand_use_tree(\n                     }\n                 }\n             }\n-            if let Some(path) = convert_path(prefix, ast_path, macro_crate) {\n+            if let Some(path) = convert_path(prefix, ast_path, hygiene) {\n                 let is_glob = tree.has_star();\n                 cb(path, &tree, is_glob, alias)\n             }\n@@ -330,37 +333,36 @@ fn expand_use_tree(\n     }\n }\n \n-fn convert_path(\n-    prefix: Option<Path>,\n-    path: ast::Path,\n-    macro_crate: &impl Fn() -> Option<Crate>,\n-) -> Option<Path> {\n+fn convert_path(prefix: Option<Path>, path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n     let prefix = if let Some(qual) = path.qualifier() {\n-        Some(convert_path(prefix, qual, macro_crate)?)\n+        Some(convert_path(prefix, qual, hygiene)?)\n     } else {\n         prefix\n     };\n \n     let segment = path.segment()?;\n     let res = match segment.kind()? {\n-        ast::PathSegmentKind::Name(name) => {\n-            if name.text() == \"$crate\" {\n-                if let Some(krate) = macro_crate() {\n+        ast::PathSegmentKind::Name(name_ref) => {\n+            match hygiene.name_ref_to_name(name_ref) {\n+                Either::A(name) => {\n+                    // no type args in use\n+                    let mut res = prefix.unwrap_or_else(|| Path {\n+                        kind: PathKind::Plain,\n+                        segments: Vec::with_capacity(1),\n+                    });\n+                    res.segments.push(PathSegment {\n+                        name,\n+                        args_and_bindings: None, // no type args in use\n+                    });\n+                    res\n+                }\n+                Either::B(crate_id) => {\n                     return Some(Path::from_simple_segments(\n-                        PathKind::DollarCrate(krate),\n+                        PathKind::DollarCrate(crate_id),\n                         iter::empty(),\n-                    ));\n+                    ))\n                 }\n             }\n-\n-            // no type args in use\n-            let mut res = prefix\n-                .unwrap_or_else(|| Path { kind: PathKind::Plain, segments: Vec::with_capacity(1) });\n-            res.segments.push(PathSegment {\n-                name: name.as_name(),\n-                args_and_bindings: None, // no type args in use\n-            });\n-            res\n         }\n         ast::PathSegmentKind::CrateKw => {\n             if prefix.is_some() {\n@@ -389,8 +391,9 @@ fn convert_path(\n }\n \n pub mod known {\n+    use hir_expand::name;\n+\n     use super::{Path, PathKind};\n-    use crate::name;\n \n     pub fn std_iter_into_iterator() -> Path {\n         Path::from_simple_segments(", "previous_filename": "crates/ra_hir/src/path.rs"}, {"sha": "8af061116de8719c7b68397e64d0a27a9acc302d", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -3,7 +3,7 @@\n \n use ra_syntax::ast::{self, TypeAscriptionOwner, TypeBoundsOwner};\n \n-use crate::Path;\n+use crate::path::Path;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Mutability {\n@@ -64,7 +64,7 @@ pub enum TypeBound {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n+    pub fn from_ast(node: ast::TypeRef) -> Self {\n         match node {\n             ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n             ast::TypeRef::TupleType(inner) => {\n@@ -113,7 +113,7 @@ impl TypeRef {\n         }\n     }\n \n-    pub(crate) fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n+    pub fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n         if let Some(node) = node {\n             TypeRef::from_ast(node)\n         } else {\n@@ -135,7 +135,7 @@ pub(crate) fn type_bounds_from_ast(type_bounds_opt: Option<ast::TypeBoundList>)\n }\n \n impl TypeBound {\n-    pub(crate) fn from_ast(node: ast::TypeBound) -> Self {\n+    pub fn from_ast(node: ast::TypeBound) -> Self {\n         match node.kind() {\n             ast::TypeBoundKind::PathType(path_type) => {\n                 let path = match path_type.path() {", "previous_filename": "crates/ra_hir/src/type_ref.rs"}, {"sha": "9bf5b79187512ecf9782c13c2f3ea5a00880168e", "filename": "crates/ra_hir_expand/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2FCargo.toml?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_hir_expand\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+log = \"0.4.5\"\n+\n+ra_arena = { path = \"../ra_arena\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_prof = { path = \"../ra_prof\" }\n+tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n+mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }"}, {"sha": "cb464c3ff17d294cbe07add19f587a82e480ac31", "filename": "crates/ra_hir_expand/src/ast_id_map.rs", "status": "renamed", "additions": 30, "deletions": 85, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,58 +1,21 @@\n-//! FIXME: write short doc here\n+//! `AstIdMap` allows to create stable IDs for \"large\" syntax nodes like items\n+//! and macro calls.\n+//!\n+//! Specifically, it enumerates all items in a file and uses position of a an\n+//! item as an ID. That way, id's don't change unless the set of items itself\n+//! changes.\n \n use std::{\n     hash::{Hash, Hasher},\n     marker::PhantomData,\n-    sync::Arc,\n };\n \n use ra_arena::{impl_arena_id, Arena, RawId};\n-use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxNodePtr};\n-\n-use crate::{db::AstDatabase, HirFileId};\n-\n-/// `AstId` points to an AST node in any file.\n-///\n-/// It is stable across reparses, and can be used as salsa key/value.\n-#[derive(Debug)]\n-pub(crate) struct AstId<N: AstNode> {\n-    file_id: HirFileId,\n-    file_ast_id: FileAstId<N>,\n-}\n-\n-impl<N: AstNode> Clone for AstId<N> {\n-    fn clone(&self) -> AstId<N> {\n-        *self\n-    }\n-}\n-impl<N: AstNode> Copy for AstId<N> {}\n-\n-impl<N: AstNode> PartialEq for AstId<N> {\n-    fn eq(&self, other: &Self) -> bool {\n-        (self.file_id, self.file_ast_id) == (other.file_id, other.file_ast_id)\n-    }\n-}\n-impl<N: AstNode> Eq for AstId<N> {}\n-impl<N: AstNode> Hash for AstId<N> {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        (self.file_id, self.file_ast_id).hash(hasher);\n-    }\n-}\n-\n-impl<N: AstNode> AstId<N> {\n-    pub(crate) fn file_id(&self) -> HirFileId {\n-        self.file_id\n-    }\n-\n-    pub(crate) fn to_node(&self, db: &impl AstDatabase) -> N {\n-        let syntax_node = db.ast_id_to_node(self.file_id, self.file_ast_id.raw);\n-        N::cast(syntax_node).unwrap()\n-    }\n-}\n+use ra_syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr};\n \n /// `AstId` points to an AST node in a specific file.\n #[derive(Debug)]\n-pub(crate) struct FileAstId<N: AstNode> {\n+pub struct FileAstId<N: AstNode> {\n     raw: ErasedFileAstId,\n     _ty: PhantomData<fn() -> N>,\n }\n@@ -76,14 +39,8 @@ impl<N: AstNode> Hash for FileAstId<N> {\n     }\n }\n \n-impl<N: AstNode> FileAstId<N> {\n-    pub(crate) fn with_file_id(self, file_id: HirFileId) -> AstId<N> {\n-        AstId { file_id, file_ast_id: self }\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ErasedFileAstId(RawId);\n+struct ErasedFileAstId(RawId);\n impl_arena_id!(ErasedFileAstId);\n \n /// Maps items' `SyntaxNode`s to `ErasedFileAstId`s and back.\n@@ -93,39 +50,7 @@ pub struct AstIdMap {\n }\n \n impl AstIdMap {\n-    pub(crate) fn ast_id_map_query(db: &impl AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n-        let map = if let Some(node) = db.parse_or_expand(file_id) {\n-            AstIdMap::from_source(&node)\n-        } else {\n-            AstIdMap::default()\n-        };\n-        Arc::new(map)\n-    }\n-\n-    pub(crate) fn file_item_query(\n-        db: &impl AstDatabase,\n-        file_id: HirFileId,\n-        ast_id: ErasedFileAstId,\n-    ) -> SyntaxNode {\n-        let node = db.parse_or_expand(file_id).unwrap();\n-        db.ast_id_map(file_id).arena[ast_id].to_node(&node)\n-    }\n-\n-    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n-        let ptr = SyntaxNodePtr::new(item.syntax());\n-        let raw = match self.arena.iter().find(|(_id, i)| **i == ptr) {\n-            Some((it, _)) => it,\n-            None => panic!(\n-                \"Can't find {:?} in AstIdMap:\\n{:?}\",\n-                item.syntax(),\n-                self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n-            ),\n-        };\n-\n-        FileAstId { raw, _ty: PhantomData }\n-    }\n-\n-    fn from_source(node: &SyntaxNode) -> AstIdMap {\n+    pub(crate) fn from_source(node: &SyntaxNode) -> AstIdMap {\n         assert!(node.parent().is_none());\n         let mut res = AstIdMap { arena: Arena::default() };\n         // By walking the tree in bread-first order we make sure that parents\n@@ -142,6 +67,26 @@ impl AstIdMap {\n         res\n     }\n \n+    pub fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n+        let raw = self.erased_ast_id(item.syntax());\n+        FileAstId { raw, _ty: PhantomData }\n+    }\n+    fn erased_ast_id(&self, item: &SyntaxNode) -> ErasedFileAstId {\n+        let ptr = SyntaxNodePtr::new(item);\n+        match self.arena.iter().find(|(_id, i)| **i == ptr) {\n+            Some((it, _)) => it,\n+            None => panic!(\n+                \"Can't find {:?} in AstIdMap:\\n{:?}\",\n+                item,\n+                self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n+            ),\n+        }\n+    }\n+\n+    pub(crate) fn get<N: AstNode>(&self, id: FileAstId<N>) -> AstPtr<N> {\n+        self.arena[id.raw].cast::<N>().unwrap()\n+    }\n+\n     fn alloc(&mut self, item: &SyntaxNode) -> ErasedFileAstId {\n         self.arena.alloc(SyntaxNodePtr::new(item))\n     }", "previous_filename": "crates/ra_hir/src/source_id.rs"}, {"sha": "a4ee9a529a1c4b26f7cd1bf0351d170d308f1922", "filename": "crates/ra_hir_expand/src/db.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,104 @@\n+//! Defines database & queries for macro expansion.\n+\n+use std::sync::Arc;\n+\n+use mbe::MacroRules;\n+use ra_db::{salsa, SourceDatabase};\n+use ra_prof::profile;\n+use ra_syntax::{AstNode, Parse, SyntaxNode};\n+\n+use crate::{\n+    ast_id_map::AstIdMap, HirFileId, HirFileIdRepr, MacroCallId, MacroCallLoc, MacroDefId,\n+    MacroFile, MacroFileKind,\n+};\n+\n+// FIXME: rename to ExpandDatabase\n+#[salsa::query_group(AstDatabaseStorage)]\n+pub trait AstDatabase: SourceDatabase {\n+    fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n+\n+    #[salsa::transparent]\n+    fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode>;\n+\n+    #[salsa::interned]\n+    fn intern_macro(&self, macro_call: MacroCallLoc) -> MacroCallId;\n+    fn macro_arg(&self, id: MacroCallId) -> Option<Arc<tt::Subtree>>;\n+    fn macro_def(&self, id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n+    fn parse_macro(&self, macro_file: MacroFile) -> Option<Parse<SyntaxNode>>;\n+    fn macro_expand(&self, macro_call: MacroCallId) -> Result<Arc<tt::Subtree>, String>;\n+}\n+\n+pub(crate) fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n+    let map =\n+        db.parse_or_expand(file_id).map_or_else(AstIdMap::default, |it| AstIdMap::from_source(&it));\n+    Arc::new(map)\n+}\n+\n+pub(crate) fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n+    let macro_call = id.ast_id.to_node(db);\n+    let arg = macro_call.token_tree()?;\n+    let (tt, _) = mbe::ast_to_token_tree(&arg).or_else(|| {\n+        log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n+        None\n+    })?;\n+    let rules = MacroRules::parse(&tt).ok().or_else(|| {\n+        log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n+        None\n+    })?;\n+    Some(Arc::new(rules))\n+}\n+\n+pub(crate) fn macro_arg(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<tt::Subtree>> {\n+    let loc = db.lookup_intern_macro(id);\n+    let macro_call = loc.ast_id.to_node(db);\n+    let arg = macro_call.token_tree()?;\n+    let (tt, _) = mbe::ast_to_token_tree(&arg)?;\n+    Some(Arc::new(tt))\n+}\n+\n+pub(crate) fn macro_expand(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+) -> Result<Arc<tt::Subtree>, String> {\n+    let loc = db.lookup_intern_macro(id);\n+    let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n+\n+    let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n+    let tt = macro_rules.expand(&macro_arg).map_err(|err| format!(\"{:?}\", err))?;\n+    // Set a hard limit for the expanded tt\n+    let count = tt.count();\n+    if count > 65536 {\n+        return Err(format!(\"Total tokens count exceed limit : count = {}\", count));\n+    }\n+    Ok(Arc::new(tt))\n+}\n+\n+pub(crate) fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n+    match file_id.0 {\n+        HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n+        HirFileIdRepr::MacroFile(macro_file) => {\n+            db.parse_macro(macro_file).map(|it| it.syntax_node())\n+        }\n+    }\n+}\n+\n+pub(crate) fn parse_macro(\n+    db: &dyn AstDatabase,\n+    macro_file: MacroFile,\n+) -> Option<Parse<SyntaxNode>> {\n+    let _p = profile(\"parse_macro_query\");\n+    let macro_call_id = macro_file.macro_call_id;\n+    let tt = db\n+        .macro_expand(macro_call_id)\n+        .map_err(|err| {\n+            // Note:\n+            // The final goal we would like to make all parse_macro success,\n+            // such that the following log will not call anyway.\n+            log::warn!(\"fail on macro_parse: (reason: {})\", err,);\n+        })\n+        .ok()?;\n+    match macro_file.macro_file_kind {\n+        MacroFileKind::Items => mbe::token_tree_to_items(&tt).ok().map(Parse::to_syntax),\n+        MacroFileKind::Expr => mbe::token_tree_to_expr(&tt).ok().map(Parse::to_syntax),\n+    }\n+}"}, {"sha": "83583ef8bd3ca81e587a106e6bb60053f1deb3e9", "filename": "crates/ra_hir_expand/src/either.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Feither.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "previous_filename": "crates/ra_hir/src/either.rs"}, {"sha": "77428ec99049c221df4fec8661d96551ff9ca31c", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,46 @@\n+//! This modules handles hygiene information.\n+//!\n+//! Specifically, `ast` + `Hygiene` allows you to create a `Name`. Note that, at\n+//! this moment, this is horribly incomplete and handles only `$crate`.\n+use ra_db::CrateId;\n+use ra_syntax::ast;\n+\n+use crate::{\n+    db::AstDatabase,\n+    either::Either,\n+    name::{AsName, Name},\n+    HirFileId, HirFileIdRepr,\n+};\n+\n+#[derive(Debug)]\n+pub struct Hygiene {\n+    // This is what `$crate` expands to\n+    def_crate: Option<CrateId>,\n+}\n+\n+impl Hygiene {\n+    pub fn new(db: &impl AstDatabase, file_id: HirFileId) -> Hygiene {\n+        let def_crate = match file_id.0 {\n+            HirFileIdRepr::FileId(_) => None,\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                Some(loc.def.krate)\n+            }\n+        };\n+        Hygiene { def_crate }\n+    }\n+\n+    pub fn new_unhygienic() -> Hygiene {\n+        Hygiene { def_crate: None }\n+    }\n+\n+    // FIXME: this should just return name\n+    pub fn name_ref_to_name(&self, name_ref: ast::NameRef) -> Either<Name, CrateId> {\n+        if let Some(def_crate) = self.def_crate {\n+            if name_ref.text() == \"$crate\" {\n+                return Either::B(def_crate);\n+            }\n+        }\n+        Either::A(name_ref.as_name())\n+    }\n+}"}, {"sha": "5a0e5a19c5335c31f990bcd4bd882dc59a39af00", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,153 @@\n+//! `ra_hir_expand` deals with macro expansion.\n+//!\n+//! Specifically, it implements a concept of `MacroFile` -- a file whose syntax\n+//! tree originates not from the text of some `FileId`, but from some macro\n+//! expansion.\n+\n+pub mod db;\n+pub mod ast_id_map;\n+pub mod either;\n+pub mod name;\n+pub mod hygiene;\n+\n+use std::hash::{Hash, Hasher};\n+\n+use ra_db::{salsa, CrateId, FileId};\n+use ra_syntax::ast::{self, AstNode};\n+\n+use crate::ast_id_map::FileAstId;\n+\n+/// Input to the analyzer is a set of files, where each file is identified by\n+/// `FileId` and contains source code. However, another source of source code in\n+/// Rust are macros: each macro can be thought of as producing a \"temporary\n+/// file\". To assign an id to such a file, we use the id of the macro call that\n+/// produced the file. So, a `HirFileId` is either a `FileId` (source code\n+/// written by user), or a `MacroCallId` (source code produced by macro).\n+///\n+/// What is a `MacroCallId`? Simplifying, it's a `HirFileId` of a file\n+/// containing the call plus the offset of the macro call in the file. Note that\n+/// this is a recursive definition! However, the size_of of `HirFileId` is\n+/// finite (because everything bottoms out at the real `FileId`) and small\n+/// (`MacroCallId` uses the location interner).\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct HirFileId(HirFileIdRepr);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+enum HirFileIdRepr {\n+    FileId(FileId),\n+    MacroFile(MacroFile),\n+}\n+\n+impl From<FileId> for HirFileId {\n+    fn from(id: FileId) -> Self {\n+        HirFileId(HirFileIdRepr::FileId(id))\n+    }\n+}\n+\n+impl From<MacroFile> for HirFileId {\n+    fn from(id: MacroFile) -> Self {\n+        HirFileId(HirFileIdRepr::MacroFile(id))\n+    }\n+}\n+\n+impl HirFileId {\n+    /// For macro-expansion files, returns the file original source file the\n+    /// expansion originated from.\n+    pub fn original_file(self, db: &dyn db::AstDatabase) -> FileId {\n+        match self.0 {\n+            HirFileIdRepr::FileId(file_id) => file_id,\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                loc.ast_id.file_id().original_file(db)\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroFile {\n+    macro_call_id: MacroCallId,\n+    macro_file_kind: MacroFileKind,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum MacroFileKind {\n+    Items,\n+    Expr,\n+}\n+\n+/// `MacroCallId` identifies a particular macro invocation, like\n+/// `println!(\"Hello, {}\", world)`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroCallId(salsa::InternId);\n+impl salsa::InternKey for MacroCallId {\n+    fn from_intern_id(v: salsa::InternId) -> Self {\n+        MacroCallId(v)\n+    }\n+    fn as_intern_id(&self) -> salsa::InternId {\n+        self.0\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroDefId {\n+    pub krate: CrateId,\n+    pub ast_id: AstId<ast::MacroCall>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MacroCallLoc {\n+    pub def: MacroDefId,\n+    pub ast_id: AstId<ast::MacroCall>,\n+}\n+\n+impl MacroCallId {\n+    pub fn as_file(self, kind: MacroFileKind) -> HirFileId {\n+        let macro_file = MacroFile { macro_call_id: self, macro_file_kind: kind };\n+        macro_file.into()\n+    }\n+}\n+\n+/// `AstId` points to an AST node in any file.\n+///\n+/// It is stable across reparses, and can be used as salsa key/value.\n+// FIXME: isn't this just a `Source<FileAstId<N>>` ?\n+#[derive(Debug)]\n+pub struct AstId<N: AstNode> {\n+    file_id: HirFileId,\n+    file_ast_id: FileAstId<N>,\n+}\n+\n+impl<N: AstNode> Clone for AstId<N> {\n+    fn clone(&self) -> AstId<N> {\n+        *self\n+    }\n+}\n+impl<N: AstNode> Copy for AstId<N> {}\n+\n+impl<N: AstNode> PartialEq for AstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.file_id, self.file_ast_id) == (other.file_id, other.file_ast_id)\n+    }\n+}\n+impl<N: AstNode> Eq for AstId<N> {}\n+impl<N: AstNode> Hash for AstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        (self.file_id, self.file_ast_id).hash(hasher);\n+    }\n+}\n+\n+impl<N: AstNode> AstId<N> {\n+    pub fn new(file_id: HirFileId, file_ast_id: FileAstId<N>) -> AstId<N> {\n+        AstId { file_id, file_ast_id }\n+    }\n+\n+    pub fn file_id(&self) -> HirFileId {\n+        self.file_id\n+    }\n+\n+    pub fn to_node(&self, db: &dyn db::AstDatabase) -> N {\n+        let root = db.parse_or_expand(self.file_id).unwrap();\n+        db.ast_id_map(self.file_id).get(self.file_ast_id).to_node(&root)\n+    }\n+}"}, {"sha": "720896ee8ebfa7f948fc0a1566c1c37b6a37bbcc", "filename": "crates/ra_hir_expand/src/name.rs", "status": "renamed", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -33,7 +33,7 @@ impl Name {\n         Name(Repr::Text(text))\n     }\n \n-    pub(crate) fn new_tuple_field(idx: usize) -> Name {\n+    pub fn new_tuple_field(idx: usize) -> Name {\n         Name(Repr::TupleField(idx))\n     }\n \n@@ -52,19 +52,19 @@ impl Name {\n         }\n     }\n \n-    pub(crate) fn missing() -> Name {\n+    pub fn missing() -> Name {\n         Name::new_text(\"[missing name]\".into())\n     }\n \n-    pub(crate) fn as_tuple_index(&self) -> Option<usize> {\n+    pub fn as_tuple_index(&self) -> Option<usize> {\n         match self.0 {\n             Repr::TupleField(idx) => Some(idx),\n             _ => None,\n         }\n     }\n }\n \n-pub(crate) trait AsName {\n+pub trait AsName {\n     fn as_name(&self) -> Name;\n }\n \n@@ -99,44 +99,44 @@ impl AsName for ra_db::Dependency {\n }\n \n // Primitives\n-pub(crate) const ISIZE: Name = Name::new_inline_ascii(5, b\"isize\");\n-pub(crate) const I8: Name = Name::new_inline_ascii(2, b\"i8\");\n-pub(crate) const I16: Name = Name::new_inline_ascii(3, b\"i16\");\n-pub(crate) const I32: Name = Name::new_inline_ascii(3, b\"i32\");\n-pub(crate) const I64: Name = Name::new_inline_ascii(3, b\"i64\");\n-pub(crate) const I128: Name = Name::new_inline_ascii(4, b\"i128\");\n-pub(crate) const USIZE: Name = Name::new_inline_ascii(5, b\"usize\");\n-pub(crate) const U8: Name = Name::new_inline_ascii(2, b\"u8\");\n-pub(crate) const U16: Name = Name::new_inline_ascii(3, b\"u16\");\n-pub(crate) const U32: Name = Name::new_inline_ascii(3, b\"u32\");\n-pub(crate) const U64: Name = Name::new_inline_ascii(3, b\"u64\");\n-pub(crate) const U128: Name = Name::new_inline_ascii(4, b\"u128\");\n-pub(crate) const F32: Name = Name::new_inline_ascii(3, b\"f32\");\n-pub(crate) const F64: Name = Name::new_inline_ascii(3, b\"f64\");\n-pub(crate) const BOOL: Name = Name::new_inline_ascii(4, b\"bool\");\n-pub(crate) const CHAR: Name = Name::new_inline_ascii(4, b\"char\");\n-pub(crate) const STR: Name = Name::new_inline_ascii(3, b\"str\");\n+pub const ISIZE: Name = Name::new_inline_ascii(5, b\"isize\");\n+pub const I8: Name = Name::new_inline_ascii(2, b\"i8\");\n+pub const I16: Name = Name::new_inline_ascii(3, b\"i16\");\n+pub const I32: Name = Name::new_inline_ascii(3, b\"i32\");\n+pub const I64: Name = Name::new_inline_ascii(3, b\"i64\");\n+pub const I128: Name = Name::new_inline_ascii(4, b\"i128\");\n+pub const USIZE: Name = Name::new_inline_ascii(5, b\"usize\");\n+pub const U8: Name = Name::new_inline_ascii(2, b\"u8\");\n+pub const U16: Name = Name::new_inline_ascii(3, b\"u16\");\n+pub const U32: Name = Name::new_inline_ascii(3, b\"u32\");\n+pub const U64: Name = Name::new_inline_ascii(3, b\"u64\");\n+pub const U128: Name = Name::new_inline_ascii(4, b\"u128\");\n+pub const F32: Name = Name::new_inline_ascii(3, b\"f32\");\n+pub const F64: Name = Name::new_inline_ascii(3, b\"f64\");\n+pub const BOOL: Name = Name::new_inline_ascii(4, b\"bool\");\n+pub const CHAR: Name = Name::new_inline_ascii(4, b\"char\");\n+pub const STR: Name = Name::new_inline_ascii(3, b\"str\");\n \n // Special names\n-pub(crate) const SELF_PARAM: Name = Name::new_inline_ascii(4, b\"self\");\n-pub(crate) const SELF_TYPE: Name = Name::new_inline_ascii(4, b\"Self\");\n-pub(crate) const MACRO_RULES: Name = Name::new_inline_ascii(11, b\"macro_rules\");\n+pub const SELF_PARAM: Name = Name::new_inline_ascii(4, b\"self\");\n+pub const SELF_TYPE: Name = Name::new_inline_ascii(4, b\"Self\");\n+pub const MACRO_RULES: Name = Name::new_inline_ascii(11, b\"macro_rules\");\n \n // Components of known path (value or mod name)\n-pub(crate) const STD: Name = Name::new_inline_ascii(3, b\"std\");\n-pub(crate) const ITER: Name = Name::new_inline_ascii(4, b\"iter\");\n-pub(crate) const OPS: Name = Name::new_inline_ascii(3, b\"ops\");\n-pub(crate) const FUTURE: Name = Name::new_inline_ascii(6, b\"future\");\n-pub(crate) const RESULT: Name = Name::new_inline_ascii(6, b\"result\");\n-pub(crate) const BOXED: Name = Name::new_inline_ascii(5, b\"boxed\");\n+pub const STD: Name = Name::new_inline_ascii(3, b\"std\");\n+pub const ITER: Name = Name::new_inline_ascii(4, b\"iter\");\n+pub const OPS: Name = Name::new_inline_ascii(3, b\"ops\");\n+pub const FUTURE: Name = Name::new_inline_ascii(6, b\"future\");\n+pub const RESULT: Name = Name::new_inline_ascii(6, b\"result\");\n+pub const BOXED: Name = Name::new_inline_ascii(5, b\"boxed\");\n \n // Components of known path (type name)\n-pub(crate) const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(12, b\"IntoIterator\");\n-pub(crate) const ITEM_TYPE: Name = Name::new_inline_ascii(4, b\"Item\");\n-pub(crate) const TRY_TYPE: Name = Name::new_inline_ascii(3, b\"Try\");\n-pub(crate) const OK_TYPE: Name = Name::new_inline_ascii(2, b\"Ok\");\n-pub(crate) const FUTURE_TYPE: Name = Name::new_inline_ascii(6, b\"Future\");\n-pub(crate) const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n-pub(crate) const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n-pub(crate) const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n-pub(crate) const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");\n+pub const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(12, b\"IntoIterator\");\n+pub const ITEM_TYPE: Name = Name::new_inline_ascii(4, b\"Item\");\n+pub const TRY_TYPE: Name = Name::new_inline_ascii(3, b\"Try\");\n+pub const OK_TYPE: Name = Name::new_inline_ascii(2, b\"Ok\");\n+pub const FUTURE_TYPE: Name = Name::new_inline_ascii(6, b\"Future\");\n+pub const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n+pub const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n+pub const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n+pub const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");", "previous_filename": "crates/ra_hir/src/name.rs"}, {"sha": "bf6ef12f3ffb2be621af8f9d9244002e755067ff", "filename": "crates/ra_ide_api/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2FCargo.toml?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -27,10 +27,13 @@ ra_db = { path = \"../ra_db\" }\n ra_cfg = { path = \"../ra_cfg\" }\n ra_fmt = { path = \"../ra_fmt\" }\n ra_prof = { path = \"../ra_prof\" }\n-hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n test_utils = { path = \"../test_utils\" }\n ra_assists = { path = \"../ra_assists\" }\n \n+# ra_ide_api should depend only on the top-level `hir` package. if you need\n+# something from some `hir_xxx` subpackage, reexport the API via `hir`.\n+hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n+\n [dev-dependencies]\n insta = \"0.12.0\"\n "}, {"sha": "3572825b57a6890522f7f333f5afe9098b257a52", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 165, "deletions": 18, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,9 +2,9 @@\n \n use ra_db::SourceDatabase;\n use ra_syntax::{\n-    algo::find_node_at_offset,\n+    algo::ancestors_at_offset,\n     ast::{self, ArgListOwner},\n-    AstNode, SyntaxNode, TextUnit,\n+    match_ast, AstNode, SyntaxNode, TextUnit,\n };\n use test_utils::tested_by;\n \n@@ -20,24 +20,30 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     let name_ref = calling_node.name_ref()?;\n \n     let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-    let function = match &calling_node {\n+    let (mut call_info, has_self) = match &calling_node {\n         FnCallNode::CallExpr(expr) => {\n             //FIXME: apply subst\n             let (callable_def, _subst) = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n-                hir::CallableDef::Function(it) => it,\n-                //FIXME: handle other callables\n-                _ => return None,\n+                hir::CallableDef::Function(it) => {\n+                    (CallInfo::with_fn(db, it), it.data(db).has_self_param())\n+                }\n+                hir::CallableDef::Struct(it) => (CallInfo::with_struct(db, it)?, false),\n+                hir::CallableDef::EnumVariant(it) => (CallInfo::with_enum_variant(db, it)?, false),\n             }\n         }\n-        FnCallNode::MethodCallExpr(expr) => analyzer.resolve_method_call(&expr)?,\n+        FnCallNode::MethodCallExpr(expr) => {\n+            let function = analyzer.resolve_method_call(&expr)?;\n+            (CallInfo::with_fn(db, function), function.data(db).has_self_param())\n+        }\n+        FnCallNode::MacroCallExpr(expr) => {\n+            let macro_def = analyzer.resolve_macro_call(db, &expr)?;\n+            (CallInfo::with_macro(db, macro_def)?, false)\n+        }\n     };\n \n-    let mut call_info = CallInfo::new(db, function);\n-\n     // If we have a calling expression let's find which argument we are on\n     let num_params = call_info.parameters().len();\n-    let has_self = function.data(db).has_self_param();\n \n     if num_params == 1 {\n         if !has_self {\n@@ -75,20 +81,25 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     Some(call_info)\n }\n \n+#[derive(Debug)]\n enum FnCallNode {\n     CallExpr(ast::CallExpr),\n     MethodCallExpr(ast::MethodCallExpr),\n+    MacroCallExpr(ast::MacroCall),\n }\n \n impl FnCallNode {\n     fn with_node(syntax: &SyntaxNode, offset: TextUnit) -> Option<FnCallNode> {\n-        if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n-            return Some(FnCallNode::CallExpr(expr));\n-        }\n-        if let Some(expr) = find_node_at_offset::<ast::MethodCallExpr>(syntax, offset) {\n-            return Some(FnCallNode::MethodCallExpr(expr));\n-        }\n-        None\n+        ancestors_at_offset(syntax, offset).find_map(|node| {\n+            match_ast! {\n+                match node {\n+                    ast::CallExpr(it) => { Some(FnCallNode::CallExpr(it)) },\n+                    ast::MethodCallExpr(it) => { Some(FnCallNode::MethodCallExpr(it)) },\n+                    ast::MacroCall(it) => { Some(FnCallNode::MacroCallExpr(it)) },\n+                    _ => { None },\n+                }\n+            }\n+        })\n     }\n \n     fn name_ref(&self) -> Option<ast::NameRef> {\n@@ -101,24 +112,45 @@ impl FnCallNode {\n             FnCallNode::MethodCallExpr(call_expr) => {\n                 call_expr.syntax().children().filter_map(ast::NameRef::cast).nth(0)\n             }\n+\n+            FnCallNode::MacroCallExpr(call_expr) => call_expr.path()?.segment()?.name_ref(),\n         }\n     }\n \n     fn arg_list(&self) -> Option<ast::ArgList> {\n         match self {\n             FnCallNode::CallExpr(expr) => expr.arg_list(),\n             FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n+            FnCallNode::MacroCallExpr(_) => None,\n         }\n     }\n }\n \n impl CallInfo {\n-    fn new(db: &RootDatabase, function: hir::Function) -> Self {\n+    fn with_fn(db: &RootDatabase, function: hir::Function) -> Self {\n         let signature = FunctionSignature::from_hir(db, function);\n \n         CallInfo { signature, active_parameter: None }\n     }\n \n+    fn with_struct(db: &RootDatabase, st: hir::Struct) -> Option<Self> {\n+        let signature = FunctionSignature::from_struct(db, st)?;\n+\n+        Some(CallInfo { signature, active_parameter: None })\n+    }\n+\n+    fn with_enum_variant(db: &RootDatabase, variant: hir::EnumVariant) -> Option<Self> {\n+        let signature = FunctionSignature::from_enum_variant(db, variant)?;\n+\n+        Some(CallInfo { signature, active_parameter: None })\n+    }\n+\n+    fn with_macro(db: &RootDatabase, macro_def: hir::MacroDef) -> Option<Self> {\n+        let signature = FunctionSignature::from_macro(db, macro_def)?;\n+\n+        Some(CallInfo { signature, active_parameter: None })\n+    }\n+\n     fn parameters(&self) -> &[String] {\n         &self.signature.parameters\n     }\n@@ -415,6 +447,7 @@ pub fn foo(mut r: WriteHandler<()>) {\n \"#,\n         );\n \n+        assert_eq!(info.label(), \"fn finished(&mut self, ctx: &mut Self::Context)\".to_string());\n         assert_eq!(info.parameters(), [\"&mut self\", \"ctx: &mut Self::Context\"]);\n         assert_eq!(info.active_parameter, Some(1));\n         assert_eq!(\n@@ -438,4 +471,118 @@ By default this method stops actor's `Context`.\"#\n         let call_info = analysis.call_info(position).unwrap();\n         assert!(call_info.is_none());\n     }\n+\n+    #[test]\n+    fn test_nested_method_in_lamba() {\n+        let info = call_info(\n+            r#\"struct Foo;\n+\n+impl Foo {\n+    fn bar(&self, _: u32) { }\n+}\n+\n+fn bar(_: u32) { }\n+\n+fn main() {\n+    let foo = Foo;\n+    std::thread::spawn(move || foo.bar(<|>));\n+}\"#,\n+        );\n+\n+        assert_eq!(info.parameters(), [\"&self\", \"_: u32\"]);\n+        assert_eq!(info.active_parameter, Some(1));\n+        assert_eq!(info.label(), \"fn bar(&self, _: u32)\");\n+    }\n+\n+    #[test]\n+    fn works_for_tuple_structs() {\n+        let info = call_info(\n+            r#\"\n+/// A cool tuple struct\n+struct TS(u32, i32);\n+fn main() {\n+    let s = TS(0, <|>);\n+}\"#,\n+        );\n+\n+        assert_eq!(info.label(), \"struct TS(u32, i32) -> TS\");\n+        assert_eq!(info.doc().map(|it| it.into()), Some(\"A cool tuple struct\".to_string()));\n+        assert_eq!(info.active_parameter, Some(1));\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn cant_call_named_structs() {\n+        let _ = call_info(\n+            r#\"\n+struct TS { x: u32, y: i32 }\n+fn main() {\n+    let s = TS(<|>);\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn works_for_enum_variants() {\n+        let info = call_info(\n+            r#\"\n+enum E {\n+    /// A Variant\n+    A(i32),\n+    /// Another\n+    B,\n+    /// And C\n+    C { a: i32, b: i32 }\n+}\n+\n+fn main() {\n+    let a = E::A(<|>);\n+}\n+            \"#,\n+        );\n+\n+        assert_eq!(info.label(), \"E::A(0: i32)\");\n+        assert_eq!(info.doc().map(|it| it.into()), Some(\"A Variant\".to_string()));\n+        assert_eq!(info.active_parameter, Some(0));\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn cant_call_enum_records() {\n+        let _ = call_info(\n+            r#\"\n+enum E {\n+    /// A Variant\n+    A(i32),\n+    /// Another\n+    B,\n+    /// And C\n+    C { a: i32, b: i32 }\n+}\n+\n+fn main() {\n+    let a = E::C(<|>);\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fn_signature_for_macro() {\n+        let info = call_info(\n+            r#\"\n+/// empty macro\n+macro_rules! foo {\n+    () => {}\n+}\n+\n+fn f() {\n+    foo!(<|>);\n+}\n+        \"#,\n+        );\n+\n+        assert_eq!(info.label(), \"foo!()\");\n+        assert_eq!(info.doc().map(|it| it.into()), Some(\"empty macro\".to_string()));\n+    }\n }"}, {"sha": "39c5946c7f1874ad68df343840f4248119c688fd", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -43,7 +43,7 @@ impl fmt::Debug for AnalysisChange {\n         if !self.libraries_added.is_empty() {\n             d.field(\"libraries_added\", &self.libraries_added.len());\n         }\n-        if !self.crate_graph.is_some() {\n+        if !self.crate_graph.is_none() {\n             d.field(\"crate_graph\", &self.crate_graph);\n         }\n         d.finish()"}, {"sha": "a58fdc036fef2be742dadcc25bc0295a1b9975a1", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -50,7 +50,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 hir::ModuleDef::TypeAlias(a) => a.ty(ctx.db),\n                 _ => unreachable!(),\n             };\n-            let krate = ctx.module.and_then(|m| m.krate(ctx.db));\n+            let krate = ctx.module.map(|m| m.krate());\n             if let Some(krate) = krate {\n                 ty.iterate_impl_items(ctx.db, krate, |item| {\n                     match item {\n@@ -67,7 +67,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 });\n             }\n         }\n-        _ => return,\n+        _ => {}\n     };\n }\n "}, {"sha": "60ed3518b89a92994243fe8dc4b9b249c8904dd6", "filename": "crates/ra_ide_api/src/completion/complete_postfix.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -9,16 +9,14 @@ use crate::{\n };\n use hir::{Ty, TypeCtor};\n use ra_syntax::{ast::AstNode, TextRange, TextUnit};\n-use ra_text_edit::TextEditBuilder;\n+use ra_text_edit::TextEdit;\n \n fn postfix_snippet(ctx: &CompletionContext, label: &str, detail: &str, snippet: &str) -> Builder {\n     let edit = {\n         let receiver_range =\n             ctx.dot_receiver.as_ref().expect(\"no receiver available\").syntax().text_range();\n         let delete_range = TextRange::from_to(receiver_range.start(), ctx.source_range().end());\n-        let mut builder = TextEditBuilder::default();\n-        builder.replace(delete_range, snippet.to_string());\n-        builder.finish()\n+        TextEdit::replace(delete_range, snippet.to_string())\n     };\n     CompletionItem::new(CompletionKind::Postfix, ctx.source_range(), label)\n         .detail(detail)"}, {"sha": "5c9c44704b3bb9daeb105833c7d4271d0049a2fc", "filename": "crates/ra_ide_api/src/completion/completion_item.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -4,7 +4,7 @@ use std::fmt;\n \n use hir::Documentation;\n use ra_syntax::TextRange;\n-use ra_text_edit::{TextEdit, TextEditBuilder};\n+use ra_text_edit::TextEdit;\n \n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n /// It is basically a POD with various properties. To construct a\n@@ -192,12 +192,10 @@ impl Builder {\n         let label = self.label;\n         let text_edit = match self.text_edit {\n             Some(it) => it,\n-            None => {\n-                let mut builder = TextEditBuilder::default();\n-                builder\n-                    .replace(self.source_range, self.insert_text.unwrap_or_else(|| label.clone()));\n-                builder.finish()\n-            }\n+            None => TextEdit::replace(\n+                self.source_range,\n+                self.insert_text.unwrap_or_else(|| label.clone()),\n+            ),\n         };\n \n         CompletionItem {"}, {"sha": "65bb639ed508d18bb9666b3bd30b267eab80a9d9", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 55, "deletions": 19, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -136,7 +136,7 @@ impl Completions {\n         for (idx, s) in docs.match_indices(&macro_name) {\n             let (before, after) = (&docs[..idx], &docs[idx + s.len()..]);\n             // Ensure to match the full word\n-            if after.starts_with(\"!\")\n+            if after.starts_with('!')\n                 && before\n                     .chars()\n                     .rev()\n@@ -164,27 +164,32 @@ impl Completions {\n         name: Option<String>,\n         macro_: hir::MacroDef,\n     ) {\n+        let name = match name {\n+            Some(it) => it,\n+            None => return,\n+        };\n+\n         let ast_node = macro_.source(ctx.db).ast;\n-        if let Some(name) = name {\n-            let detail = macro_label(&ast_node);\n+        let detail = macro_label(&ast_node);\n+\n+        let docs = macro_.docs(ctx.db);\n+        let macro_declaration = format!(\"{}!\", name);\n+\n+        let mut builder =\n+            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), &macro_declaration)\n+                .kind(CompletionItemKind::Macro)\n+                .set_documentation(docs.clone())\n+                .detail(detail);\n \n-            let docs = macro_.docs(ctx.db);\n+        builder = if ctx.use_item_syntax.is_some() {\n+            builder.insert_text(name)\n+        } else {\n             let macro_braces_to_insert =\n                 self.guess_macro_braces(&name, docs.as_ref().map_or(\"\", |s| s.as_str()));\n-            let macro_declaration = name + \"!\";\n-\n-            let builder = CompletionItem::new(\n-                CompletionKind::Reference,\n-                ctx.source_range(),\n-                &macro_declaration,\n-            )\n-            .kind(CompletionItemKind::Macro)\n-            .set_documentation(docs)\n-            .detail(detail)\n-            .insert_snippet(macro_declaration + macro_braces_to_insert);\n+            builder.insert_snippet(macro_declaration + macro_braces_to_insert)\n+        };\n \n-            self.add(builder);\n-        }\n+        self.add(builder);\n     }\n \n     fn add_function_with_name(\n@@ -220,7 +225,7 @@ impl Completions {\n                 } else {\n                     (format!(\"{}($0)\", data.name()), format!(\"{}(\u2026)\", name))\n                 };\n-            builder = builder.lookup_by(name.clone()).label(label).insert_snippet(snippet);\n+            builder = builder.lookup_by(name).label(label).insert_snippet(snippet);\n         }\n \n         self.add(builder)\n@@ -281,10 +286,11 @@ fn has_non_default_type_params(def: hir::GenericDef, db: &db::RootDatabase) -> b\n \n #[cfg(test)]\n mod tests {\n-    use crate::completion::{do_completion, CompletionItem, CompletionKind};\n     use insta::assert_debug_snapshot;\n     use test_utils::covers;\n \n+    use crate::completion::{do_completion, CompletionItem, CompletionKind};\n+\n     fn do_reference_completion(code: &str) -> Vec<CompletionItem> {\n         do_completion(code, CompletionKind::Reference)\n     }\n@@ -576,4 +582,34 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn dont_insert_macro_call_braces_in_use() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                //- /main.rs\n+                use foo::<|>;\n+\n+                //- /foo/lib.rs\n+                #[macro_export]\n+                macro_rules frobnicate {\n+                    () => ()\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"frobnicate!\",\n+                source_range: [9; 9),\n+                delete: [9; 9),\n+                insert: \"frobnicate\",\n+                kind: Macro,\n+                detail: \"#[macro_export]\\nmacro_rules! frobnicate\",\n+            },\n+        ]\n+        \"###\n+        )\n+    }\n }"}, {"sha": "785e71808b7c400d9d6fd9bfa1b6061aed4b0aec", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -23,6 +23,7 @@ use crate::{\n     hir::db::InternDatabaseStorage,\n     hir::db::AstDatabaseStorage,\n     hir::db::DefDatabaseStorage,\n+    hir::db::DefDatabase2Storage,\n     hir::db::HirDatabaseStorage\n )]\n #[derive(Debug)]"}, {"sha": "1f1f5cd742c98e30f8fd277cdb43eb363ceb97e4", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -85,10 +85,9 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n     })\n     .on::<hir::diagnostics::MissingOkInTailExpr, _>(|d| {\n         let node = d.ast(db);\n-        let mut builder = TextEditBuilder::default();\n         let replacement = format!(\"Ok({})\", node.syntax());\n-        builder.replace(node.syntax().text_range(), replacement);\n-        let fix = SourceChange::source_file_edit_from(\"wrap with ok\", file_id, builder.finish());\n+        let edit = TextEdit::replace(node.syntax().text_range(), replacement);\n+        let fix = SourceChange::source_file_edit_from(\"wrap with ok\", file_id, edit);\n         res.borrow_mut().push(Diagnostic {\n             range: d.highlight_range(),\n             message: d.message(),\n@@ -152,9 +151,7 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n         let start = use_tree_list_node.prev_sibling_or_token()?.text_range().start();\n         let end = use_tree_list_node.text_range().end();\n         let range = TextRange::from_to(start, end);\n-        let mut edit_builder = TextEditBuilder::default();\n-        edit_builder.delete(range);\n-        return Some(edit_builder.finish());\n+        return Some(TextEdit::delete(range));\n     }\n     None\n }"}, {"sha": "9075ca443c3fe75f48ca7ba5d2ff2fc562ed6b40", "filename": "crates/ra_ide_api/src/display/function_signature.rs", "status": "modified", "additions": 110, "deletions": 2, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt::{self, Display};\n \n-use hir::{Docs, Documentation, HasSource};\n+use hir::{Docs, Documentation, HasSource, HirDisplay};\n use join_to_string::join;\n use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n use std::convert::From;\n@@ -12,9 +12,18 @@ use crate::{\n     display::{generic_parameters, where_predicates},\n };\n \n+#[derive(Debug)]\n+pub enum CallableKind {\n+    Function,\n+    StructConstructor,\n+    VariantConstructor,\n+    Macro,\n+}\n+\n /// Contains information about a function signature\n #[derive(Debug)]\n pub struct FunctionSignature {\n+    pub kind: CallableKind,\n     /// Optional visibility\n     pub visibility: Option<String>,\n     /// Name of the function\n@@ -42,6 +51,99 @@ impl FunctionSignature {\n         let ast_node = function.source(db).ast;\n         FunctionSignature::from(&ast_node).with_doc_opt(doc)\n     }\n+\n+    pub(crate) fn from_struct(db: &db::RootDatabase, st: hir::Struct) -> Option<Self> {\n+        let node: ast::StructDef = st.source(db).ast;\n+        match node.kind() {\n+            ast::StructKind::Named(_) => return None,\n+            _ => (),\n+        };\n+\n+        let params = st\n+            .fields(db)\n+            .into_iter()\n+            .map(|field: hir::StructField| {\n+                let ty = field.ty(db);\n+                format!(\"{}\", ty.display(db))\n+            })\n+            .collect();\n+\n+        Some(\n+            FunctionSignature {\n+                kind: CallableKind::StructConstructor,\n+                visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n+                name: node.name().map(|n| n.text().to_string()),\n+                ret_type: node.name().map(|n| n.text().to_string()),\n+                parameters: params,\n+                generic_parameters: generic_parameters(&node),\n+                where_predicates: where_predicates(&node),\n+                doc: None,\n+            }\n+            .with_doc_opt(st.docs(db)),\n+        )\n+    }\n+\n+    pub(crate) fn from_enum_variant(\n+        db: &db::RootDatabase,\n+        variant: hir::EnumVariant,\n+    ) -> Option<Self> {\n+        let node: ast::EnumVariant = variant.source(db).ast;\n+        match node.kind() {\n+            ast::StructKind::Named(_) | ast::StructKind::Unit => return None,\n+            _ => (),\n+        };\n+\n+        let parent_name = match variant.parent_enum(db).name(db) {\n+            Some(name) => name.to_string(),\n+            None => \"missing\".into(),\n+        };\n+\n+        let name = format!(\"{}::{}\", parent_name, variant.name(db).unwrap());\n+\n+        let params = variant\n+            .fields(db)\n+            .into_iter()\n+            .map(|field: hir::StructField| {\n+                let name = field.name(db);\n+                let ty = field.ty(db);\n+                format!(\"{}: {}\", name, ty.display(db))\n+            })\n+            .collect();\n+\n+        Some(\n+            FunctionSignature {\n+                kind: CallableKind::VariantConstructor,\n+                visibility: None,\n+                name: Some(name),\n+                ret_type: None,\n+                parameters: params,\n+                generic_parameters: vec![],\n+                where_predicates: vec![],\n+                doc: None,\n+            }\n+            .with_doc_opt(variant.docs(db)),\n+        )\n+    }\n+\n+    pub(crate) fn from_macro(db: &db::RootDatabase, macro_def: hir::MacroDef) -> Option<Self> {\n+        let node: ast::MacroCall = macro_def.source(db).ast;\n+\n+        let params = vec![];\n+\n+        Some(\n+            FunctionSignature {\n+                kind: CallableKind::Macro,\n+                visibility: None,\n+                name: node.name().map(|n| n.text().to_string()),\n+                ret_type: None,\n+                parameters: params,\n+                generic_parameters: vec![],\n+                where_predicates: vec![],\n+                doc: None,\n+            }\n+            .with_doc_opt(macro_def.docs(db)),\n+        )\n+    }\n }\n \n impl From<&'_ ast::FnDef> for FunctionSignature {\n@@ -59,6 +161,7 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n         }\n \n         FunctionSignature {\n+            kind: CallableKind::Function,\n             visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n             name: node.name().map(|n| n.text().to_string()),\n             ret_type: node\n@@ -81,7 +184,12 @@ impl Display for FunctionSignature {\n         }\n \n         if let Some(name) = &self.name {\n-            write!(f, \"fn {}\", name)?;\n+            match self.kind {\n+                CallableKind::Function => write!(f, \"fn {}\", name)?,\n+                CallableKind::StructConstructor => write!(f, \"struct {}\", name)?,\n+                CallableKind::VariantConstructor => write!(f, \"{}\", name)?,\n+                CallableKind::Macro => write!(f, \"{}!\", name)?,\n+            }\n         }\n \n         if !self.generic_parameters.is_empty() {"}, {"sha": "4b7bfc0b11e8a3b8838547a4f159f7cc9c9145a4", "filename": "crates/ra_ide_api/src/extend_selection.rs", "status": "modified", "additions": 72, "deletions": 10, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     algo::find_covering_element,\n     ast::{self, AstNode, AstToken},\n     Direction, NodeOrToken,\n-    SyntaxKind::*,\n+    SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, TextRange, TextUnit, TokenAtOffset, T,\n };\n \n@@ -29,10 +29,12 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n         USE_TREE_LIST,\n         TYPE_PARAM_LIST,\n         TYPE_ARG_LIST,\n+        TYPE_BOUND_LIST,\n         PARAM_LIST,\n         ARG_LIST,\n         ARRAY_EXPR,\n         TUPLE_EXPR,\n+        WHERE_CLAUSE,\n     ];\n \n     if range.is_empty() {\n@@ -146,13 +148,17 @@ fn pick_best<'a>(l: SyntaxToken, r: SyntaxToken) -> SyntaxToken {\n     }\n }\n \n-/// Extend list item selection to include nearby comma and whitespace.\n+/// Extend list item selection to include nearby delimiter and whitespace.\n fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n     fn is_single_line_ws(node: &SyntaxToken) -> bool {\n         node.kind() == WHITESPACE && !node.text().contains('\\n')\n     }\n \n-    fn nearby_comma(node: &SyntaxNode, dir: Direction) -> Option<SyntaxToken> {\n+    fn nearby_delimiter(\n+        delimiter_kind: SyntaxKind,\n+        node: &SyntaxNode,\n+        dir: Direction,\n+    ) -> Option<SyntaxToken> {\n         node.siblings_with_tokens(dir)\n             .skip(1)\n             .skip_while(|node| match node {\n@@ -161,19 +167,26 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n             })\n             .next()\n             .and_then(|it| it.into_token())\n-            .filter(|node| node.kind() == T![,])\n+            .filter(|node| node.kind() == delimiter_kind)\n     }\n \n-    if let Some(comma_node) = nearby_comma(node, Direction::Prev) {\n-        return Some(TextRange::from_to(comma_node.text_range().start(), node.text_range().end()));\n+    let delimiter = match node.kind() {\n+        TYPE_BOUND => T![+],\n+        _ => T![,],\n+    };\n+    if let Some(delimiter_node) = nearby_delimiter(delimiter, node, Direction::Prev) {\n+        return Some(TextRange::from_to(\n+            delimiter_node.text_range().start(),\n+            node.text_range().end(),\n+        ));\n     }\n-    if let Some(comma_node) = nearby_comma(node, Direction::Next) {\n-        // Include any following whitespace when comma if after list item.\n-        let final_node = comma_node\n+    if let Some(delimiter_node) = nearby_delimiter(delimiter, node, Direction::Next) {\n+        // Include any following whitespace when delimiter is after list item.\n+        let final_node = delimiter_node\n             .next_sibling_or_token()\n             .and_then(|it| it.into_token())\n             .filter(|node| is_single_line_ws(node))\n-            .unwrap_or(comma_node);\n+            .unwrap_or(delimiter_node);\n \n         return Some(TextRange::from_to(node.text_range().start(), final_node.text_range().end()));\n     }\n@@ -387,4 +400,53 @@ fn bar(){}\n             &[\"foo\", \"\\\" fn foo() {\\\"\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_extend_trait_bounds_list_in_where_clause() {\n+        do_check(\n+            r#\"\n+fn foo<R>() \n+    where \n+        R: req::Request + 'static,\n+        R::Params: DeserializeOwned<|> + panic::UnwindSafe + 'static,\n+        R::Result: Serialize + 'static,\n+\"#,\n+            &[\n+                \"DeserializeOwned\",\n+                \"DeserializeOwned + \",\n+                \"DeserializeOwned + panic::UnwindSafe + 'static\",\n+                \"R::Params: DeserializeOwned + panic::UnwindSafe + 'static\",\n+                \"R::Params: DeserializeOwned + panic::UnwindSafe + 'static,\",\n+            ],\n+        );\n+        do_check(r#\"fn foo<T>() where T: <|>Copy\"#, &[\"Copy\"]);\n+        do_check(r#\"fn foo<T>() where T: <|>Copy + Display\"#, &[\"Copy\", \"Copy + \"]);\n+        do_check(r#\"fn foo<T>() where T: <|>Copy +Display\"#, &[\"Copy\", \"Copy +\"]);\n+        do_check(r#\"fn foo<T>() where T: <|>Copy+Display\"#, &[\"Copy\", \"Copy+\"]);\n+        do_check(r#\"fn foo<T>() where T: Copy + <|>Display\"#, &[\"Display\", \"+ Display\"]);\n+        do_check(r#\"fn foo<T>() where T: Copy + <|>Display + Sync\"#, &[\"Display\", \"+ Display\"]);\n+        do_check(r#\"fn foo<T>() where T: Copy +<|>Display\"#, &[\"Display\", \"+Display\"]);\n+    }\n+\n+    #[test]\n+    fn test_extend_trait_bounds_list_inline() {\n+        do_check(r#\"fn foo<T: <|>Copy>() {}\"#, &[\"Copy\"]);\n+        do_check(r#\"fn foo<T: <|>Copy + Display>() {}\"#, &[\"Copy\", \"Copy + \"]);\n+        do_check(r#\"fn foo<T: <|>Copy +Display>() {}\"#, &[\"Copy\", \"Copy +\"]);\n+        do_check(r#\"fn foo<T: <|>Copy+Display>() {}\"#, &[\"Copy\", \"Copy+\"]);\n+        do_check(r#\"fn foo<T: Copy + <|>Display>() {}\"#, &[\"Display\", \"+ Display\"]);\n+        do_check(r#\"fn foo<T: Copy + <|>Display + Sync>() {}\"#, &[\"Display\", \"+ Display\"]);\n+        do_check(r#\"fn foo<T: Copy +<|>Display>() {}\"#, &[\"Display\", \"+Display\"]);\n+        do_check(\n+            r#\"fn foo<T: Copy<|> + Display, U: Copy>() {}\"#,\n+            &[\n+                \"Copy\",\n+                \"Copy + \",\n+                \"Copy + Display\",\n+                \"T: Copy + Display\",\n+                \"T: Copy + Display, \",\n+                \"<T: Copy + Display, U: Copy>\",\n+            ],\n+        );\n+    }\n }"}, {"sha": "b899ed3a5f78f49b4224061f3fdbbfdbb8a232dc", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -51,7 +51,7 @@ fn impls_for_def(\n         }\n     };\n \n-    let krate = module.krate(db)?;\n+    let krate = module.krate();\n     let impls = db.impls_in_crate(krate);\n \n     Some(\n@@ -72,7 +72,7 @@ fn impls_for_trait(\n     let src = hir::Source { file_id: position.file_id.into(), ast: node.clone() };\n     let tr = hir::Trait::from_source(db, src)?;\n \n-    let krate = module.krate(db)?;\n+    let krate = module.krate();\n     let impls = db.impls_in_crate(krate);\n \n     Some("}, {"sha": "d0188da4493e6f19550dd141babbfc572a9b8462", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 16, "deletions": 113, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -14,6 +14,7 @@ mod db;\n pub mod mock_analysis;\n mod symbol_index;\n mod change;\n+mod source_change;\n mod feature_flags;\n \n mod status;\n@@ -54,8 +55,6 @@ use ra_db::{\n     CheckCanceled, FileLoader, SourceDatabase,\n };\n use ra_syntax::{SourceFile, TextRange, TextUnit};\n-use ra_text_edit::TextEdit;\n-use relative_path::RelativePathBuf;\n \n use crate::{db::LineIndexDatabase, symbol_index::FileSymbol};\n \n@@ -73,6 +72,7 @@ pub use crate::{\n     line_index_utils::translate_offset_with_edit,\n     references::{ReferenceSearchResult, SearchScope},\n     runnables::{Runnable, RunnableKind},\n+    source_change::{FileSystemEdit, SourceChange, SourceFileEdit},\n     syntax_highlighting::HighlightedRange,\n };\n \n@@ -83,99 +83,6 @@ pub use ra_db::{\n \n pub type Cancelable<T> = Result<T, Canceled>;\n \n-#[derive(Debug)]\n-pub struct SourceChange {\n-    pub label: String,\n-    pub source_file_edits: Vec<SourceFileEdit>,\n-    pub file_system_edits: Vec<FileSystemEdit>,\n-    pub cursor_position: Option<FilePosition>,\n-}\n-\n-impl SourceChange {\n-    /// Creates a new SourceChange with the given label\n-    /// from the edits.\n-    pub(crate) fn from_edits<L: Into<String>>(\n-        label: L,\n-        source_file_edits: Vec<SourceFileEdit>,\n-        file_system_edits: Vec<FileSystemEdit>,\n-    ) -> Self {\n-        SourceChange {\n-            label: label.into(),\n-            source_file_edits,\n-            file_system_edits,\n-            cursor_position: None,\n-        }\n-    }\n-\n-    /// Creates a new SourceChange with the given label,\n-    /// containing only the given `SourceFileEdits`.\n-    pub(crate) fn source_file_edits<L: Into<String>>(label: L, edits: Vec<SourceFileEdit>) -> Self {\n-        SourceChange {\n-            label: label.into(),\n-            source_file_edits: edits,\n-            file_system_edits: vec![],\n-            cursor_position: None,\n-        }\n-    }\n-\n-    /// Creates a new SourceChange with the given label,\n-    /// containing only the given `FileSystemEdits`.\n-    pub(crate) fn file_system_edits<L: Into<String>>(label: L, edits: Vec<FileSystemEdit>) -> Self {\n-        SourceChange {\n-            label: label.into(),\n-            source_file_edits: vec![],\n-            file_system_edits: edits,\n-            cursor_position: None,\n-        }\n-    }\n-\n-    /// Creates a new SourceChange with the given label,\n-    /// containing only a single `SourceFileEdit`.\n-    pub(crate) fn source_file_edit<L: Into<String>>(label: L, edit: SourceFileEdit) -> Self {\n-        SourceChange::source_file_edits(label, vec![edit])\n-    }\n-\n-    /// Creates a new SourceChange with the given label\n-    /// from the given `FileId` and `TextEdit`\n-    pub(crate) fn source_file_edit_from<L: Into<String>>(\n-        label: L,\n-        file_id: FileId,\n-        edit: TextEdit,\n-    ) -> Self {\n-        SourceChange::source_file_edit(label, SourceFileEdit { file_id, edit })\n-    }\n-\n-    /// Creates a new SourceChange with the given label\n-    /// from the given `FileId` and `TextEdit`\n-    pub(crate) fn file_system_edit<L: Into<String>>(label: L, edit: FileSystemEdit) -> Self {\n-        SourceChange::file_system_edits(label, vec![edit])\n-    }\n-\n-    /// Sets the cursor position to the given `FilePosition`\n-    pub(crate) fn with_cursor(mut self, cursor_position: FilePosition) -> Self {\n-        self.cursor_position = Some(cursor_position);\n-        self\n-    }\n-\n-    /// Sets the cursor position to the given `FilePosition`\n-    pub(crate) fn with_cursor_opt(mut self, cursor_position: Option<FilePosition>) -> Self {\n-        self.cursor_position = cursor_position;\n-        self\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct SourceFileEdit {\n-    pub file_id: FileId,\n-    pub edit: TextEdit,\n-}\n-\n-#[derive(Debug)]\n-pub enum FileSystemEdit {\n-    CreateFile { source_root: SourceRootId, path: RelativePathBuf },\n-    MoveFile { src: FileId, dst_source_root: SourceRootId, dst_path: RelativePathBuf },\n-}\n-\n #[derive(Debug)]\n pub struct Diagnostic {\n     pub message: String,\n@@ -407,24 +314,20 @@ impl Analysis {\n         self.with_db(|db| typing::on_enter(&db, position))\n     }\n \n-    /// Returns an edit which should be applied after `=` was typed. Primarily,\n-    /// this works when adding `let =`.\n-    // FIXME: use a snippet completion instead of this hack here.\n-    pub fn on_eq_typed(&self, position: FilePosition) -> Cancelable<Option<SourceChange>> {\n-        self.with_db(|db| {\n-            let parse = db.parse(position.file_id);\n-            let file = parse.tree();\n-            let edit = typing::on_eq_typed(&file, position.offset)?;\n-            Some(SourceChange::source_file_edit(\n-                \"add semicolon\",\n-                SourceFileEdit { edit, file_id: position.file_id },\n-            ))\n-        })\n-    }\n-\n-    /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n-    pub fn on_dot_typed(&self, position: FilePosition) -> Cancelable<Option<SourceChange>> {\n-        self.with_db(|db| typing::on_dot_typed(&db, position))\n+    /// Returns an edit which should be applied after a character was typed.\n+    ///\n+    /// This is useful for some on-the-fly fixups, like adding `;` to `let =`\n+    /// automatically.\n+    pub fn on_char_typed(\n+        &self,\n+        position: FilePosition,\n+        char_typed: char,\n+    ) -> Cancelable<Option<SourceChange>> {\n+        // Fast path to not even parse the file.\n+        if !typing::TRIGGER_CHARS.contains(char_typed) {\n+            return Ok(None);\n+        }\n+        self.with_db(|db| typing::on_char_typed(&db, position, char_typed))\n     }\n \n     /// Returns a tree representation of symbols in the file. Useful to draw a"}, {"sha": "4c57566e2af930b469224082681caab424c2d7b9", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -27,10 +27,7 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n             Some(it) => it,\n             None => return Vec::new(),\n         };\n-    let krate = match module.krate(db) {\n-        Some(it) => it,\n-        None => return Vec::new(),\n-    };\n+    let krate = module.krate();\n     vec![krate.crate_id()]\n }\n "}, {"sha": "a8783d7a0dc4463e5fbbe40e216e4470b30a03ae", "filename": "crates/ra_ide_api/src/references/rename.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Frename.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -3,6 +3,7 @@\n use hir::ModuleSource;\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SyntaxNode};\n+use ra_text_edit::TextEdit;\n use relative_path::{RelativePath, RelativePathBuf};\n \n use crate::{\n@@ -43,14 +44,7 @@ fn source_edit_from_file_id_range(\n     range: TextRange,\n     new_name: &str,\n ) -> SourceFileEdit {\n-    SourceFileEdit {\n-        file_id,\n-        edit: {\n-            let mut builder = ra_text_edit::TextEditBuilder::default();\n-            builder.replace(range, new_name.into());\n-            builder.finish()\n-        },\n-    }\n+    SourceFileEdit { file_id, edit: TextEdit::replace(range, new_name.into()) }\n }\n \n fn rename_mod(\n@@ -94,11 +88,7 @@ fn rename_mod(\n \n     let edit = SourceFileEdit {\n         file_id: position.file_id,\n-        edit: {\n-            let mut builder = ra_text_edit::TextEditBuilder::default();\n-            builder.replace(ast_name.syntax().text_range(), new_name.into());\n-            builder.finish()\n-        },\n+        edit: TextEdit::replace(ast_name.syntax().text_range(), new_name.into()),\n     };\n     source_file_edits.push(edit);\n \n@@ -126,12 +116,14 @@ fn rename_reference(\n \n #[cfg(test)]\n mod tests {\n+    use insta::assert_debug_snapshot;\n+    use ra_text_edit::TextEditBuilder;\n+    use test_utils::assert_eq_text;\n+\n     use crate::{\n         mock_analysis::analysis_and_position, mock_analysis::single_file_with_position, FileId,\n         ReferenceSearchResult,\n     };\n-    use insta::assert_debug_snapshot;\n-    use test_utils::assert_eq_text;\n \n     #[test]\n     fn test_find_all_refs_for_local() {\n@@ -452,7 +444,7 @@ mod tests {\n     fn test_rename(text: &str, new_name: &str, expected: &str) {\n         let (analysis, position) = single_file_with_position(text);\n         let source_change = analysis.rename(position, new_name).unwrap();\n-        let mut text_edit_builder = ra_text_edit::TextEditBuilder::default();\n+        let mut text_edit_builder = TextEditBuilder::default();\n         let mut file_id: Option<FileId> = None;\n         if let Some(change) = source_change {\n             for edit in change.info.source_file_edits {"}, {"sha": "f2789e0b2a4369b1cc66d1ab0372035fc3d0ee72", "filename": "crates/ra_ide_api/src/references/search_scope.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -111,24 +111,23 @@ impl NameDefinition {\n         if vis.as_str() != \"\" {\n             let source_root_id = db.file_source_root(file_id);\n             let source_root = db.source_root(source_root_id);\n-            let mut res =\n-                source_root.walk().map(|id| (id.into(), None)).collect::<FxHashMap<_, _>>();\n+            let mut res = source_root.walk().map(|id| (id, None)).collect::<FxHashMap<_, _>>();\n \n             // FIXME: add \"pub(in path)\"\n \n             if vis.as_str() == \"pub(crate)\" {\n                 return SearchScope::new(res);\n             }\n             if vis.as_str() == \"pub\" {\n-                let krate = self.container.krate(db).unwrap();\n+                let krate = self.container.krate();\n                 let crate_graph = db.crate_graph();\n                 for crate_id in crate_graph.iter() {\n                     let mut crate_deps = crate_graph.dependencies(crate_id);\n                     if crate_deps.any(|dep| dep.crate_id() == krate.crate_id()) {\n                         let root_file = crate_graph.crate_root(crate_id);\n                         let source_root_id = db.file_source_root(root_file);\n                         let source_root = db.source_root(source_root_id);\n-                        res.extend(source_root.walk().map(|id| (id.into(), None)));\n+                        res.extend(source_root.walk().map(|id| (id, None)));\n                     }\n                 }\n                 return SearchScope::new(res);"}, {"sha": "1b5c8deea0f88a2b5a771ad5d6c859efb6c6aba0", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -4,7 +4,7 @@ use itertools::Itertools;\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner, ModuleItemOwner, NameOwner},\n-    SyntaxNode, TextRange,\n+    match_ast, SyntaxNode, TextRange,\n };\n \n use crate::{db::RootDatabase, FileId};\n@@ -29,12 +29,12 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n }\n \n fn runnable(db: &RootDatabase, file_id: FileId, item: SyntaxNode) -> Option<Runnable> {\n-    if let Some(fn_def) = ast::FnDef::cast(item.clone()) {\n-        runnable_fn(fn_def)\n-    } else if let Some(m) = ast::Module::cast(item) {\n-        runnable_mod(db, file_id, m)\n-    } else {\n-        None\n+    match_ast! {\n+        match item {\n+            ast::FnDef(it) => { runnable_fn(it) },\n+            ast::Module(it) => { runnable_mod(db, file_id, it) },\n+            _ => { None },\n+        }\n     }\n }\n "}, {"sha": "4e63bbf6f0c891c7e259cb61d3e11c83867fa8da", "filename": "crates/ra_ide_api/src/source_change.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,119 @@\n+//! This modules defines type to represent changes to the source code, that flow\n+//! from the server to the client.\n+//!\n+//! It can be viewed as a dual for `AnalysisChange`.\n+\n+use ra_text_edit::TextEdit;\n+use relative_path::RelativePathBuf;\n+\n+use crate::{FileId, FilePosition, SourceRootId, TextUnit};\n+\n+#[derive(Debug)]\n+pub struct SourceChange {\n+    pub label: String,\n+    pub source_file_edits: Vec<SourceFileEdit>,\n+    pub file_system_edits: Vec<FileSystemEdit>,\n+    pub cursor_position: Option<FilePosition>,\n+}\n+\n+impl SourceChange {\n+    /// Creates a new SourceChange with the given label\n+    /// from the edits.\n+    pub(crate) fn from_edits<L: Into<String>>(\n+        label: L,\n+        source_file_edits: Vec<SourceFileEdit>,\n+        file_system_edits: Vec<FileSystemEdit>,\n+    ) -> Self {\n+        SourceChange {\n+            label: label.into(),\n+            source_file_edits,\n+            file_system_edits,\n+            cursor_position: None,\n+        }\n+    }\n+\n+    /// Creates a new SourceChange with the given label,\n+    /// containing only the given `SourceFileEdits`.\n+    pub(crate) fn source_file_edits<L: Into<String>>(label: L, edits: Vec<SourceFileEdit>) -> Self {\n+        SourceChange {\n+            label: label.into(),\n+            source_file_edits: edits,\n+            file_system_edits: vec![],\n+            cursor_position: None,\n+        }\n+    }\n+\n+    /// Creates a new SourceChange with the given label,\n+    /// containing only the given `FileSystemEdits`.\n+    pub(crate) fn file_system_edits<L: Into<String>>(label: L, edits: Vec<FileSystemEdit>) -> Self {\n+        SourceChange {\n+            label: label.into(),\n+            source_file_edits: vec![],\n+            file_system_edits: edits,\n+            cursor_position: None,\n+        }\n+    }\n+\n+    /// Creates a new SourceChange with the given label,\n+    /// containing only a single `SourceFileEdit`.\n+    pub(crate) fn source_file_edit<L: Into<String>>(label: L, edit: SourceFileEdit) -> Self {\n+        SourceChange::source_file_edits(label, vec![edit])\n+    }\n+\n+    /// Creates a new SourceChange with the given label\n+    /// from the given `FileId` and `TextEdit`\n+    pub(crate) fn source_file_edit_from<L: Into<String>>(\n+        label: L,\n+        file_id: FileId,\n+        edit: TextEdit,\n+    ) -> Self {\n+        SourceChange::source_file_edit(label, SourceFileEdit { file_id, edit })\n+    }\n+\n+    /// Creates a new SourceChange with the given label\n+    /// from the given `FileId` and `TextEdit`\n+    pub(crate) fn file_system_edit<L: Into<String>>(label: L, edit: FileSystemEdit) -> Self {\n+        SourceChange::file_system_edits(label, vec![edit])\n+    }\n+\n+    /// Sets the cursor position to the given `FilePosition`\n+    pub(crate) fn with_cursor(mut self, cursor_position: FilePosition) -> Self {\n+        self.cursor_position = Some(cursor_position);\n+        self\n+    }\n+\n+    /// Sets the cursor position to the given `FilePosition`\n+    pub(crate) fn with_cursor_opt(mut self, cursor_position: Option<FilePosition>) -> Self {\n+        self.cursor_position = cursor_position;\n+        self\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SourceFileEdit {\n+    pub file_id: FileId,\n+    pub edit: TextEdit,\n+}\n+\n+#[derive(Debug)]\n+pub enum FileSystemEdit {\n+    CreateFile { source_root: SourceRootId, path: RelativePathBuf },\n+    MoveFile { src: FileId, dst_source_root: SourceRootId, dst_path: RelativePathBuf },\n+}\n+\n+pub(crate) struct SingleFileChange {\n+    pub label: String,\n+    pub edit: TextEdit,\n+    pub cursor_position: Option<TextUnit>,\n+}\n+\n+impl SingleFileChange {\n+    pub(crate) fn into_source_change(self, file_id: FileId) -> SourceChange {\n+        SourceChange {\n+            label: self.label,\n+            source_file_edits: vec![SourceFileEdit { file_id, edit: self.edit }],\n+            file_system_edits: Vec::new(),\n+            cursor_position: self.cursor_position.map(|offset| FilePosition { file_id, offset }),\n+        }\n+    }\n+}"}, {"sha": "d51132f736052675944a793dd01a77c0dbcbfac6", "filename": "crates/ra_ide_api/src/typing.rs", "status": "modified", "additions": 196, "deletions": 163, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,4 +1,17 @@\n-//! FIXME: write short doc here\n+//! This module handles auto-magic editing actions applied together with users\n+//! edits. For example, if the user typed\n+//!\n+//! ```text\n+//!     foo\n+//!         .bar()\n+//!         .baz()\n+//!     |   // <- cursor is here\n+//! ```\n+//!\n+//! and types `.` next, we want to indent the dot.\n+//!\n+//! Language server executes such typing assists synchronously. That is, they\n+//! block user's typing and should be pretty fast for this reason!\n \n use ra_db::{FilePosition, SourceDatabase};\n use ra_fmt::leading_indent;\n@@ -9,9 +22,9 @@ use ra_syntax::{\n     SyntaxKind::*,\n     SyntaxToken, TextRange, TextUnit, TokenAtOffset,\n };\n-use ra_text_edit::{TextEdit, TextEditBuilder};\n+use ra_text_edit::TextEdit;\n \n-use crate::{db::RootDatabase, SourceChange, SourceFileEdit};\n+use crate::{db::RootDatabase, source_change::SingleFileChange, SourceChange, SourceFileEdit};\n \n pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n     let parse = db.parse(position.file_id);\n@@ -36,13 +49,12 @@ pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<Sour\n     let indent = node_indent(&file, comment.syntax())?;\n     let inserted = format!(\"\\n{}{} \", indent, prefix);\n     let cursor_position = position.offset + TextUnit::of_str(&inserted);\n-    let mut edit = TextEditBuilder::default();\n-    edit.insert(position.offset, inserted);\n+    let edit = TextEdit::insert(position.offset, inserted);\n \n     Some(\n         SourceChange::source_file_edit(\n             \"on enter\",\n-            SourceFileEdit { edit: edit.finish(), file_id: position.file_id },\n+            SourceFileEdit { edit, file_id: position.file_id },\n         )\n         .with_cursor(FilePosition { offset: cursor_position, file_id: position.file_id }),\n     )\n@@ -68,39 +80,67 @@ fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {\n     Some(text[pos..].into())\n }\n \n-pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<TextEdit> {\n-    assert_eq!(file.syntax().text().char_at(eq_offset), Some('='));\n-    let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), eq_offset)?;\n+pub(crate) const TRIGGER_CHARS: &str = \".=>\";\n+\n+pub(crate) fn on_char_typed(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+    char_typed: char,\n+) -> Option<SourceChange> {\n+    assert!(TRIGGER_CHARS.contains(char_typed));\n+    let file = &db.parse(position.file_id).tree();\n+    assert_eq!(file.syntax().text().char_at(position.offset), Some(char_typed));\n+    let single_file_change = on_char_typed_inner(file, position.offset, char_typed)?;\n+    Some(single_file_change.into_source_change(position.file_id))\n+}\n+\n+fn on_char_typed_inner(\n+    file: &SourceFile,\n+    offset: TextUnit,\n+    char_typed: char,\n+) -> Option<SingleFileChange> {\n+    assert!(TRIGGER_CHARS.contains(char_typed));\n+    match char_typed {\n+        '.' => on_dot_typed(file, offset),\n+        '=' => on_eq_typed(file, offset),\n+        '>' => on_arrow_typed(file, offset),\n+        _ => unreachable!(),\n+    }\n+}\n+\n+/// Returns an edit which should be applied after `=` was typed. Primarily,\n+/// this works when adding `let =`.\n+// FIXME: use a snippet completion instead of this hack here.\n+fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n+    assert_eq!(file.syntax().text().char_at(offset), Some('='));\n+    let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n     if let_stmt.has_semi() {\n         return None;\n     }\n     if let Some(expr) = let_stmt.initializer() {\n         let expr_range = expr.syntax().text_range();\n-        if expr_range.contains(eq_offset) && eq_offset != expr_range.start() {\n+        if expr_range.contains(offset) && offset != expr_range.start() {\n             return None;\n         }\n-        if file.syntax().text().slice(eq_offset..expr_range.start()).contains_char('\\n') {\n+        if file.syntax().text().slice(offset..expr_range.start()).contains_char('\\n') {\n             return None;\n         }\n     } else {\n         return None;\n     }\n     let offset = let_stmt.syntax().text_range().end();\n-    let mut edit = TextEditBuilder::default();\n-    edit.insert(offset, \";\".to_string());\n-    Some(edit.finish())\n+    Some(SingleFileChange {\n+        label: \"add semicolon\".to_string(),\n+        edit: TextEdit::insert(offset, \";\".to_string()),\n+        cursor_position: None,\n+    })\n }\n \n-pub(crate) fn on_dot_typed(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n-    let parse = db.parse(position.file_id);\n-    assert_eq!(parse.tree().syntax().text().char_at(position.offset), Some('.'));\n-\n-    let whitespace = parse\n-        .tree()\n-        .syntax()\n-        .token_at_offset(position.offset)\n-        .left_biased()\n-        .and_then(ast::Whitespace::cast)?;\n+/// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n+fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n+    assert_eq!(file.syntax().text().char_at(offset), Some('.'));\n+    let whitespace =\n+        file.syntax().token_at_offset(offset).left_biased().and_then(ast::Whitespace::cast)?;\n \n     let current_indent = {\n         let text = whitespace.text();\n@@ -117,20 +157,36 @@ pub(crate) fn on_dot_typed(db: &RootDatabase, position: FilePosition) -> Option<\n     if current_indent_len == target_indent_len {\n         return None;\n     }\n-    let mut edit = TextEditBuilder::default();\n-    edit.replace(\n-        TextRange::from_to(position.offset - current_indent_len, position.offset),\n-        target_indent,\n-    );\n-\n-    let res = SourceChange::source_file_edit_from(\"reindent dot\", position.file_id, edit.finish())\n-        .with_cursor(FilePosition {\n-            offset: position.offset + target_indent_len - current_indent_len\n-                + TextUnit::of_char('.'),\n-            file_id: position.file_id,\n-        });\n-\n-    Some(res)\n+\n+    Some(SingleFileChange {\n+        label: \"reindent dot\".to_string(),\n+        edit: TextEdit::replace(\n+            TextRange::from_to(offset - current_indent_len, offset),\n+            target_indent,\n+        ),\n+        cursor_position: Some(\n+            offset + target_indent_len - current_indent_len + TextUnit::of_char('.'),\n+        ),\n+    })\n+}\n+\n+/// Adds a space after an arrow when `fn foo() { ... }` is turned into `fn foo() -> { ... }`\n+fn on_arrow_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n+    let file_text = file.syntax().text();\n+    assert_eq!(file_text.char_at(offset), Some('>'));\n+    let after_arrow = offset + TextUnit::of_char('>');\n+    if file_text.char_at(after_arrow) != Some('{') {\n+        return None;\n+    }\n+    if find_node_at_offset::<ast::RetType>(file.syntax(), offset).is_none() {\n+        return None;\n+    }\n+\n+    Some(SingleFileChange {\n+        label: \"add space after return type\".to_string(),\n+        edit: TextEdit::insert(after_arrow, \" \".to_string()),\n+        cursor_position: Some(after_arrow),\n+    })\n }\n \n #[cfg(test)]\n@@ -142,21 +198,87 @@ mod tests {\n     use super::*;\n \n     #[test]\n-    fn test_on_eq_typed() {\n-        fn type_eq(before: &str, after: &str) {\n+    fn test_on_enter() {\n+        fn apply_on_enter(before: &str) -> Option<String> {\n             let (offset, before) = extract_offset(before);\n-            let mut edit = TextEditBuilder::default();\n-            edit.insert(offset, \"=\".to_string());\n-            let before = edit.finish().apply(&before);\n-            let parse = SourceFile::parse(&before);\n-            if let Some(result) = on_eq_typed(&parse.tree(), offset) {\n-                let actual = result.apply(&before);\n-                assert_eq_text!(after, &actual);\n-            } else {\n-                assert_eq_text!(&before, after)\n-            };\n+            let (analysis, file_id) = single_file(&before);\n+            let result = analysis.on_enter(FilePosition { offset, file_id }).unwrap()?;\n+\n+            assert_eq!(result.source_file_edits.len(), 1);\n+            let actual = result.source_file_edits[0].edit.apply(&before);\n+            let actual = add_cursor(&actual, result.cursor_position.unwrap().offset);\n+            Some(actual)\n+        }\n+\n+        fn do_check(before: &str, after: &str) {\n+            let actual = apply_on_enter(before).unwrap();\n+            assert_eq_text!(after, &actual);\n+        }\n+\n+        fn do_check_noop(text: &str) {\n+            assert!(apply_on_enter(text).is_none())\n         }\n \n+        do_check(\n+            r\"\n+/// Some docs<|>\n+fn foo() {\n+}\n+\",\n+            r\"\n+/// Some docs\n+/// <|>\n+fn foo() {\n+}\n+\",\n+        );\n+        do_check(\n+            r\"\n+impl S {\n+    /// Some<|> docs.\n+    fn foo() {}\n+}\n+\",\n+            r\"\n+impl S {\n+    /// Some\n+    /// <|> docs.\n+    fn foo() {}\n+}\n+\",\n+        );\n+        do_check_noop(r\"<|>//! docz\");\n+    }\n+\n+    fn do_type_char(char_typed: char, before: &str) -> Option<(String, SingleFileChange)> {\n+        let (offset, before) = extract_offset(before);\n+        let edit = TextEdit::insert(offset, char_typed.to_string());\n+        let before = edit.apply(&before);\n+        let parse = SourceFile::parse(&before);\n+        on_char_typed_inner(&parse.tree(), offset, char_typed)\n+            .map(|it| (it.edit.apply(&before), it))\n+    }\n+\n+    fn type_char(char_typed: char, before: &str, after: &str) {\n+        let (actual, file_change) = do_type_char(char_typed, before)\n+            .unwrap_or_else(|| panic!(\"typing `{}` did nothing\", char_typed));\n+\n+        if after.contains(\"<|>\") {\n+            let (offset, after) = extract_offset(after);\n+            assert_eq_text!(&after, &actual);\n+            assert_eq!(file_change.cursor_position, Some(offset))\n+        } else {\n+            assert_eq_text!(after, &actual);\n+        }\n+    }\n+\n+    fn type_char_noop(char_typed: char, before: &str) {\n+        let file_change = do_type_char(char_typed, before);\n+        assert!(file_change.is_none())\n+    }\n+\n+    #[test]\n+    fn test_on_eq_typed() {\n         //     do_check(r\"\n         // fn foo() {\n         //     let foo =<|>\n@@ -166,7 +288,8 @@ mod tests {\n         //     let foo =;\n         // }\n         // \");\n-        type_eq(\n+        type_char(\n+            '=',\n             r\"\n fn foo() {\n     let foo <|> 1 + 1\n@@ -191,24 +314,10 @@ fn foo() {\n         // \");\n     }\n \n-    fn type_dot(before: &str, after: &str) {\n-        let (offset, before) = extract_offset(before);\n-        let mut edit = TextEditBuilder::default();\n-        edit.insert(offset, \".\".to_string());\n-        let before = edit.finish().apply(&before);\n-        let (analysis, file_id) = single_file(&before);\n-        if let Some(result) = analysis.on_dot_typed(FilePosition { offset, file_id }).unwrap() {\n-            assert_eq!(result.source_file_edits.len(), 1);\n-            let actual = result.source_file_edits[0].edit.apply(&before);\n-            assert_eq_text!(after, &actual);\n-        } else {\n-            assert_eq_text!(&before, after)\n-        };\n-    }\n-\n     #[test]\n     fn indents_new_chain_call() {\n-        type_dot(\n+        type_char(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n@@ -222,25 +331,21 @@ fn foo() {\n             }\n             \",\n         );\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n                     <|>\n             }\n             \",\n-            r\"\n-            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-                self.child_impl(db, name)\n-                    .\n-            }\n-            \",\n         )\n     }\n \n     #[test]\n     fn indents_new_chain_call_with_semi() {\n-        type_dot(\n+        type_char(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n@@ -254,25 +359,21 @@ fn foo() {\n             }\n             \",\n         );\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n                     <|>;\n             }\n             \",\n-            r\"\n-            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-                self.child_impl(db, name)\n-                    .;\n-            }\n-            \",\n         )\n     }\n \n     #[test]\n     fn indents_continued_chain_call() {\n-        type_dot(\n+        type_char(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n@@ -288,27 +389,22 @@ fn foo() {\n             }\n             \",\n         );\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n                     .first()\n                     <|>\n             }\n             \",\n-            r\"\n-            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-                self.child_impl(db, name)\n-                    .first()\n-                    .\n-            }\n-            \",\n         );\n     }\n \n     #[test]\n     fn indents_middle_of_chain_call() {\n-        type_dot(\n+        type_char(\n+            '.',\n             r\"\n             fn source_impl() {\n                 let var = enum_defvariant_list().unwrap()\n@@ -326,7 +422,8 @@ fn foo() {\n             }\n             \",\n         );\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             fn source_impl() {\n                 let var = enum_defvariant_list().unwrap()\n@@ -335,95 +432,31 @@ fn foo() {\n                     .unwrap();\n             }\n             \",\n-            r\"\n-            fn source_impl() {\n-                let var = enum_defvariant_list().unwrap()\n-                    .\n-                    .nth(92)\n-                    .unwrap();\n-            }\n-            \",\n         );\n     }\n \n     #[test]\n     fn dont_indent_freestanding_dot() {\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 <|>\n             }\n             \",\n-            r\"\n-            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-                .\n-            }\n-            \",\n         );\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n             <|>\n             }\n             \",\n-            r\"\n-            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-            .\n-            }\n-            \",\n         );\n     }\n \n     #[test]\n-    fn test_on_enter() {\n-        fn apply_on_enter(before: &str) -> Option<String> {\n-            let (offset, before) = extract_offset(before);\n-            let (analysis, file_id) = single_file(&before);\n-            let result = analysis.on_enter(FilePosition { offset, file_id }).unwrap()?;\n-\n-            assert_eq!(result.source_file_edits.len(), 1);\n-            let actual = result.source_file_edits[0].edit.apply(&before);\n-            let actual = add_cursor(&actual, result.cursor_position.unwrap().offset);\n-            Some(actual)\n-        }\n-\n-        fn do_check(before: &str, after: &str) {\n-            let actual = apply_on_enter(before).unwrap();\n-            assert_eq_text!(after, &actual);\n-        }\n-\n-        fn do_check_noop(text: &str) {\n-            assert!(apply_on_enter(text).is_none())\n-        }\n-\n-        do_check(\n-            r\"\n-/// Some docs<|>\n-fn foo() {\n-}\n-\",\n-            r\"\n-/// Some docs\n-/// <|>\n-fn foo() {\n-}\n-\",\n-        );\n-        do_check(\n-            r\"\n-impl S {\n-    /// Some<|> docs.\n-    fn foo() {}\n-}\n-\",\n-            r\"\n-impl S {\n-    /// Some\n-    /// <|> docs.\n-    fn foo() {}\n-}\n-\",\n-        );\n-        do_check_noop(r\"<|>//! docz\");\n+    fn adds_space_after_return_type() {\n+        type_char('>', \"fn foo() -<|>{ 92 }\", \"fn foo() -><|> { 92 }\")\n     }\n }"}, {"sha": "eea0965edbea6d77ea1eaf4828e685b490c2a6d2", "filename": "crates/ra_lsp_server/src/caps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -38,7 +38,7 @@ pub fn server_capabilities() -> ServerCapabilities {\n         document_range_formatting_provider: None,\n         document_on_type_formatting_provider: Some(DocumentOnTypeFormattingOptions {\n             first_trigger_character: \"=\".to_string(),\n-            more_trigger_character: Some(vec![\".\".to_string()]),\n+            more_trigger_character: Some(vec![\".\".to_string(), \">\".to_string()]),\n         }),\n         selection_range_provider: Some(GenericCapability::default()),\n         folding_range_provider: Some(FoldingRangeProviderCapability::Simple(true)),"}, {"sha": "9871a3b37f3958ece204a6b07248c13041e81e8c", "filename": "crates/ra_lsp_server/src/config.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,4 +1,11 @@\n-//! FIXME: write short doc here\n+//! Config used by the language server.\n+//!\n+//! We currently get this config from `initialize` LSP request, which is not the\n+//! best way to do it, but was the simplest thing we could implement.\n+//!\n+//! Of particular interest is the `feature_flags` hash map: while other fields\n+//! configure the server itself, feature flags are passed into analysis, and\n+//! tweak things like automatic insertion of `()` in completions.\n \n use rustc_hash::FxHashMap;\n \n@@ -72,10 +79,7 @@ mod test {\n         assert_eq!(default, serde_json::from_str(r#\"{}\"#).unwrap());\n         assert_eq!(\n             default,\n-            serde_json::from_str(\n-                r#\"{\"publishDecorations\":null, \"showWorkspaceLoaded\":null, \"lruCapacity\":null}\"#\n-            )\n-            .unwrap()\n+            serde_json::from_str(r#\"{\"publishDecorations\":null, \"lruCapacity\":null}\"#).unwrap()\n         );\n     }\n }"}, {"sha": "379dab4384f10eaec459cdcbc51ce5504b16f5ab", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -196,7 +196,7 @@ pub fn main_loop(\n     task_receiver.into_iter().for_each(|task| {\n         on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut world_state)\n     });\n-    libdata_receiver.into_iter().for_each(|lib| drop(lib));\n+    libdata_receiver.into_iter().for_each(drop);\n     log::info!(\"...tasks have finished\");\n     log::info!(\"joining threadpool...\");\n     drop(pool);"}, {"sha": "20f9aee138fb540691b83f8bb09f80dfcedcc378", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -27,6 +27,7 @@ use crate::{\n };\n \n pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n+    let _p = profile(\"handle_analyzer_status\");\n     let mut buf = world.status();\n     writeln!(buf, \"\\n\\nrequests:\").unwrap();\n     let requests = world.latest_requests.read();\n@@ -38,6 +39,7 @@ pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n }\n \n pub fn handle_syntax_tree(world: WorldSnapshot, params: req::SyntaxTreeParams) -> Result<String> {\n+    let _p = profile(\"handle_syntax_tree\");\n     let id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(id)?;\n     let text_range = params.range.map(|p| p.conv_with(&line_index));\n@@ -132,6 +134,7 @@ pub fn handle_on_enter(\n     }\n }\n \n+// Don't forget to add new trigger characters to `ServerCapabilities` in `caps.rs`.\n pub fn handle_on_type_formatting(\n     world: WorldSnapshot,\n     params: req::DocumentOnTypeFormattingParams,\n@@ -144,12 +147,17 @@ pub fn handle_on_type_formatting(\n     // in `ra_ide_api`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n     position.offset = position.offset - TextUnit::of_char('.');\n+    let char_typed = params.ch.chars().next().unwrap_or('\\0');\n \n-    let edit = match params.ch.as_str() {\n-        \"=\" => world.analysis().on_eq_typed(position),\n-        \".\" => world.analysis().on_dot_typed(position),\n-        _ => return Ok(None),\n-    }?;\n+    // We have an assist that inserts ` ` after typing `->` in `fn foo() ->{`,\n+    // but it requires precise cursor positioning to work, and one can't\n+    // position the cursor with on_type formatting. So, let's just toggle this\n+    // feature off here, hoping that we'll enable it one day, \ud83d\ude3f.\n+    if char_typed == '>' {\n+        return Ok(None);\n+    }\n+\n+    let edit = world.analysis().on_char_typed(position, char_typed)?;\n     let mut edit = match edit {\n         Some(it) => it,\n         None => return Ok(None),\n@@ -166,6 +174,7 @@ pub fn handle_document_symbol(\n     world: WorldSnapshot,\n     params: req::DocumentSymbolParams,\n ) -> Result<Option<req::DocumentSymbolResponse>> {\n+    let _p = profile(\"handle_document_symbol\");\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n \n@@ -204,6 +213,7 @@ pub fn handle_workspace_symbol(\n     world: WorldSnapshot,\n     params: req::WorkspaceSymbolParams,\n ) -> Result<Option<Vec<SymbolInformation>>> {\n+    let _p = profile(\"handle_workspace_symbol\");\n     let all_symbols = params.query.contains('#');\n     let libs = params.query.contains('*');\n     let query = {\n@@ -247,6 +257,7 @@ pub fn handle_goto_definition(\n     world: WorldSnapshot,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::GotoDefinitionResponse>> {\n+    let _p = profile(\"handle_goto_definition\");\n     let position = params.try_conv_with(&world)?;\n     let nav_info = match world.analysis().goto_definition(position)? {\n         None => return Ok(None),\n@@ -260,6 +271,7 @@ pub fn handle_goto_implementation(\n     world: WorldSnapshot,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::GotoImplementationResponse>> {\n+    let _p = profile(\"handle_goto_implementation\");\n     let position = params.try_conv_with(&world)?;\n     let nav_info = match world.analysis().goto_implementation(position)? {\n         None => return Ok(None),\n@@ -273,6 +285,7 @@ pub fn handle_goto_type_definition(\n     world: WorldSnapshot,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::GotoTypeDefinitionResponse>> {\n+    let _p = profile(\"handle_goto_type_definition\");\n     let position = params.try_conv_with(&world)?;\n     let nav_info = match world.analysis().goto_type_definition(position)? {\n         None => return Ok(None),\n@@ -286,6 +299,7 @@ pub fn handle_parent_module(\n     world: WorldSnapshot,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Vec<Location>> {\n+    let _p = profile(\"handle_parent_module\");\n     let position = params.try_conv_with(&world)?;\n     world.analysis().parent_module(position)?.iter().try_conv_with_to_vec(&world)\n }\n@@ -294,6 +308,7 @@ pub fn handle_runnables(\n     world: WorldSnapshot,\n     params: req::RunnablesParams,\n ) -> Result<Vec<req::Runnable>> {\n+    let _p = profile(\"handle_runnables\");\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n     let offset = params.position.map(|it| it.conv_with(&line_index));\n@@ -335,6 +350,7 @@ pub fn handle_decorations(\n     world: WorldSnapshot,\n     params: TextDocumentIdentifier,\n ) -> Result<Vec<Decoration>> {\n+    let _p = profile(\"handle_decorations\");\n     let file_id = params.try_conv_with(&world)?;\n     highlight(&world, file_id)\n }\n@@ -383,6 +399,7 @@ pub fn handle_folding_range(\n     world: WorldSnapshot,\n     params: FoldingRangeParams,\n ) -> Result<Option<Vec<FoldingRange>>> {\n+    let _p = profile(\"handle_folding_range\");\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let folds = world.analysis().folding_ranges(file_id)?;\n     let text = world.analysis().file_text(file_id)?;\n@@ -400,6 +417,7 @@ pub fn handle_signature_help(\n     world: WorldSnapshot,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::SignatureHelp>> {\n+    let _p = profile(\"handle_signature_help\");\n     let position = params.try_conv_with(&world)?;\n     if let Some(call_info) = world.analysis().call_info(position)? {\n         let active_parameter = call_info.active_parameter.map(|it| it as i64);\n@@ -419,6 +437,7 @@ pub fn handle_hover(\n     world: WorldSnapshot,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<Hover>> {\n+    let _p = profile(\"handle_hover\");\n     let position = params.try_conv_with(&world)?;\n     let info = match world.analysis().hover(position)? {\n         None => return Ok(None),\n@@ -517,6 +536,7 @@ pub fn handle_formatting(\n     world: WorldSnapshot,\n     params: DocumentFormattingParams,\n ) -> Result<Option<Vec<TextEdit>>> {\n+    let _p = profile(\"handle_formatting\");\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let file = world.analysis().file_text(file_id)?;\n \n@@ -639,6 +659,7 @@ pub fn handle_code_lens(\n     world: WorldSnapshot,\n     params: req::CodeLensParams,\n ) -> Result<Option<Vec<CodeLens>>> {\n+    let _p = profile(\"handle_code_lens\");\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n \n@@ -699,6 +720,7 @@ enum CodeLensResolveData {\n }\n \n pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Result<CodeLens> {\n+    let _p = profile(\"handle_code_lens_resolve\");\n     let data = code_lens.data.unwrap();\n     let resolve = serde_json::from_value(data)?;\n     match resolve {\n@@ -770,6 +792,7 @@ pub fn publish_diagnostics(\n     world: &WorldSnapshot,\n     file_id: FileId,\n ) -> Result<req::PublishDiagnosticsParams> {\n+    let _p = profile(\"publish_diagnostics\");\n     let uri = world.file_id_to_uri(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n     let diagnostics = world\n@@ -792,6 +815,7 @@ pub fn publish_decorations(\n     world: &WorldSnapshot,\n     file_id: FileId,\n ) -> Result<req::PublishDecorationsParams> {\n+    let _p = profile(\"publish_decorations\");\n     let uri = world.file_id_to_uri(file_id)?;\n     Ok(req::PublishDecorationsParams { uri, decorations: highlight(&world, file_id)? })\n }\n@@ -841,6 +865,7 @@ pub fn handle_inlay_hints(\n     world: WorldSnapshot,\n     params: InlayHintsParams,\n ) -> Result<Vec<InlayHint>> {\n+    let _p = profile(\"handle_inlay_hints\");\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let analysis = world.analysis();\n     let line_index = analysis.file_line_index(file_id)?;"}, {"sha": "33b9d483d2e1fea8bdf0855e69b8eefce0bafb5d", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -123,7 +123,6 @@ fn match_subtree(\n                     }\n                     None => bindings.push_optional(name),\n                 }\n-                ()\n             }\n             Op::Repeat { subtree, kind, separator } => {\n                 match_repeat(bindings, subtree, kind, separator, src)?\n@@ -159,7 +158,7 @@ impl<'a> TtIter<'a> {\n     pub(crate) fn expect_lifetime(&mut self) -> Result<&tt::Ident, ()> {\n         let ident = self.expect_ident()?;\n         // check if it start from \"`\"\n-        if ident.text.chars().next() != Some('\\'') {\n+        if !ident.text.starts_with('\\'') {\n             return Err(());\n         }\n         Ok(ident)"}, {"sha": "592fcf527bb311501bb136057690791c93b67bd3", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -383,7 +383,7 @@ mod tests {\n             \"#,\n         );\n         let expansion = expand(&rules, \"literals!(foo);\");\n-        let tts = &[expansion.clone().into()];\n+        let tts = &[expansion.into()];\n         let buffer = tt::buffer::TokenBuffer::new(tts);\n         let mut tt_src = SubtreeTokenSource::new(&buffer);\n         let mut tokens = vec![];"}, {"sha": "4952bd1891b5f85aaaaef642049afa427fad3a27", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -56,7 +56,8 @@ pub(super) const ATOM_EXPR_FIRST: TokenSet =\n         LIFETIME,\n         ASYNC_KW,\n         TRY_KW,\n-        LOOP_KW\n+        LOOP_KW,\n+        FOR_KW,\n     ]);\n \n const EXPR_RECOVERY_SET: TokenSet = token_set![LET_KW];"}, {"sha": "a12da5be2ab4d1923c6288ee7b9a38be8a7ecff5", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -173,7 +173,7 @@ fn test_doc_comment_single_line_block_strips_suffix_whitespace() {\n     .ok()\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert_eq!(\"this is mod foo\", module.doc_comment_text().unwrap());\n+    assert_eq!(\"this is mod foo \", module.doc_comment_text().unwrap());\n }\n \n #[test]\n@@ -191,7 +191,27 @@ fn test_doc_comment_multi_line_block_strips_suffix() {\n     .ok()\n     .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n-    assert_eq!(\"        this\\n        is\\n        mod foo\", module.doc_comment_text().unwrap());\n+    assert_eq!(\n+        \"        this\\n        is\\n        mod foo\\n        \",\n+        module.doc_comment_text().unwrap()\n+    );\n+}\n+\n+#[test]\n+fn test_comments_preserve_trailing_whitespace() {\n+    let file = SourceFile::parse(\n+        r#\"\n+/// Representation of a Realm.   \n+/// In the specification these are called Realm Records.\n+struct Realm {}\"#,\n+    )\n+    .ok()\n+    .unwrap();\n+    let def = file.syntax().descendants().find_map(StructDef::cast).unwrap();\n+    assert_eq!(\n+        \"Representation of a Realm.   \\nIn the specification these are called Realm Records.\",\n+        def.doc_comment_text().unwrap()\n+    );\n }\n \n #[test]"}, {"sha": "3d5f18bfae689e7c47d1e04f9d504e40907b3df5", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -77,7 +77,7 @@ pub fn tuple_struct_pat(\n \n pub fn record_pat(path: ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::RecordPat {\n     let pats_str = pats.map(|p| p.syntax().to_string()).join(\", \");\n-    return from_text(&format!(\"{}{{ {} }}\", path.syntax(), pats_str));\n+    return from_text(&format!(\"{} {{ {} }}\", path.syntax(), pats_str));\n \n     fn from_text(text: &str) -> ast::RecordPat {\n         ast_from_text(&format!(\"fn f({}: ())\", text))\n@@ -129,11 +129,11 @@ pub fn where_clause(preds: impl Iterator<Item = ast::WherePred>) -> ast::WhereCl\n }\n \n pub fn if_expression(condition: &ast::Expr, statement: &str) -> ast::IfExpr {\n-    return ast_from_text(&format!(\n+    ast_from_text(&format!(\n         \"fn f() {{ if !{} {{\\n    {}\\n}}\\n}}\",\n         condition.syntax().text(),\n         statement\n-    ));\n+    ))\n }\n \n fn ast_from_text<N: AstNode>(text: &str) -> N {"}, {"sha": "c2b005886a97f58b5beea1b46eb43dbf7db7ebf3", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -6,6 +6,7 @@ use itertools::Itertools;\n \n use crate::{\n     ast::{self, child_opt, children, AstChildren, AstNode, AstToken},\n+    match_ast,\n     syntax_node::{SyntaxElementChildren, SyntaxNodeChildren},\n };\n \n@@ -68,11 +69,12 @@ impl Iterator for ItemOrMacroIter {\n     fn next(&mut self) -> Option<ItemOrMacro> {\n         loop {\n             let n = self.0.next()?;\n-            if let Some(item) = ast::ModuleItem::cast(n.clone()) {\n-                return Some(ItemOrMacro::Item(item));\n-            }\n-            if let Some(call) = ast::MacroCall::cast(n) {\n-                return Some(ItemOrMacro::Macro(call));\n+            match_ast! {\n+                match n {\n+                    ast::ModuleItem(it) => { return Some(ItemOrMacro::Item(it)) },\n+                    ast::MacroCall(it) => { return Some(ItemOrMacro::Macro(it)) },\n+                    _ => {},\n+                }\n             }\n         }\n     }\n@@ -120,7 +122,7 @@ pub trait DocCommentsOwner: AstNode {\n                 has_comments = true;\n                 let prefix_len = comment.prefix().len();\n \n-                let line = comment.text().as_str();\n+                let line: &str = comment.text().as_str();\n \n                 // Determine if the prefix or prefix + 1 char is stripped\n                 let pos =\n@@ -136,7 +138,10 @@ pub trait DocCommentsOwner: AstNode {\n                     line.len()\n                 };\n \n-                line[pos..end].trim_end().to_owned()\n+                // Note that we do not trim the end of the line here\n+                // since whitespace can have special meaning at the end\n+                // of a line in markdown.\n+                line[pos..end].to_owned()\n             })\n             .join(\"\\n\");\n "}, {"sha": "5dcb6a95a6637d378ef7afaee6365263acb8efd5", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -160,6 +160,20 @@ impl SourceFile {\n     }\n }\n \n+/// Matches a `SyntaxNode` against an `ast` type.\n+///\n+/// # Example:\n+///\n+/// ```ignore\n+/// match_ast! {\n+///     match node {\n+///         ast::CallExpr(it) => { ... },\n+///         ast::MethodCallExpr(it) => { ... },\n+///         ast::MacroCall(it) => { ... },\n+///         _ => None,\n+///     }\n+/// }\n+/// ```\n #[macro_export]\n macro_rules! match_ast {\n     (match $node:ident {"}, {"sha": "0a93e11a53217f4d5a14fc4bbb4bd6fb59ca6cb7", "filename": "crates/ra_syntax/test_data/parser/err/0024_many_type_parens.txt", "status": "modified", "additions": 43, "deletions": 48, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.txt?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -179,50 +179,47 @@ SOURCE_FILE@[0; 240)\n           ERROR@[148; 149)\n             PLUS@[148; 149) \"+\"\n         WHITESPACE@[149; 150) \" \"\n-        EXPR_STMT@[150; 151)\n-          PAREN_EXPR@[150; 151)\n+        EXPR_STMT@[150; 180)\n+          TUPLE_EXPR@[150; 180)\n             L_PAREN@[150; 151) \"(\"\n-        EXPR_STMT@[151; 157)\n-          FOR_EXPR@[151; 157)\n-            FOR_KW@[151; 154) \"for\"\n-            ERROR@[154; 155)\n-              L_ANGLE@[154; 155) \"<\"\n-            ERROR@[155; 157)\n-              LIFETIME@[155; 157) \"\\'a\"\n-        EXPR_STMT@[157; 158)\n-          ERROR@[157; 158)\n-            R_ANGLE@[157; 158) \">\"\n-        WHITESPACE@[158; 159) \" \"\n-        EXPR_STMT@[159; 180)\n-          BIN_EXPR@[159; 180)\n-            BIN_EXPR@[159; 178)\n-              BIN_EXPR@[159; 169)\n-                BIN_EXPR@[159; 167)\n-                  PATH_EXPR@[159; 164)\n-                    PATH@[159; 164)\n-                      PATH_SEGMENT@[159; 164)\n-                        NAME_REF@[159; 164)\n-                          IDENT@[159; 164) \"Trait\"\n-                  L_ANGLE@[164; 165) \"<\"\n-                  ERROR@[165; 167)\n-                    LIFETIME@[165; 167) \"\\'a\"\n-                R_ANGLE@[167; 168) \">\"\n-                ERROR@[168; 169)\n-                  R_PAREN@[168; 169) \")\"\n-              WHITESPACE@[169; 170) \" \"\n-              PLUS@[170; 171) \"+\"\n-              WHITESPACE@[171; 172) \" \"\n-              PAREN_EXPR@[172; 178)\n-                L_PAREN@[172; 173) \"(\"\n-                PATH_EXPR@[173; 177)\n-                  PATH@[173; 177)\n-                    PATH_SEGMENT@[173; 177)\n-                      NAME_REF@[173; 177)\n-                        IDENT@[173; 177) \"Copy\"\n-                R_PAREN@[177; 178) \")\"\n-            R_ANGLE@[178; 179) \">\"\n-            ERROR@[179; 180)\n-              SEMI@[179; 180) \";\"\n+            BIN_EXPR@[151; 180)\n+              BIN_EXPR@[151; 178)\n+                BIN_EXPR@[151; 169)\n+                  BIN_EXPR@[151; 167)\n+                    BIN_EXPR@[151; 164)\n+                      FOR_EXPR@[151; 157)\n+                        FOR_KW@[151; 154) \"for\"\n+                        ERROR@[154; 155)\n+                          L_ANGLE@[154; 155) \"<\"\n+                        ERROR@[155; 157)\n+                          LIFETIME@[155; 157) \"\\'a\"\n+                      R_ANGLE@[157; 158) \">\"\n+                      WHITESPACE@[158; 159) \" \"\n+                      PATH_EXPR@[159; 164)\n+                        PATH@[159; 164)\n+                          PATH_SEGMENT@[159; 164)\n+                            NAME_REF@[159; 164)\n+                              IDENT@[159; 164) \"Trait\"\n+                    L_ANGLE@[164; 165) \"<\"\n+                    ERROR@[165; 167)\n+                      LIFETIME@[165; 167) \"\\'a\"\n+                  R_ANGLE@[167; 168) \">\"\n+                  ERROR@[168; 169)\n+                    R_PAREN@[168; 169) \")\"\n+                WHITESPACE@[169; 170) \" \"\n+                PLUS@[170; 171) \"+\"\n+                WHITESPACE@[171; 172) \" \"\n+                PAREN_EXPR@[172; 178)\n+                  L_PAREN@[172; 173) \"(\"\n+                  PATH_EXPR@[173; 177)\n+                    PATH@[173; 177)\n+                      PATH_SEGMENT@[173; 177)\n+                        NAME_REF@[173; 177)\n+                          IDENT@[173; 177) \"Copy\"\n+                  R_PAREN@[177; 178) \")\"\n+              R_ANGLE@[178; 179) \">\"\n+              ERROR@[179; 180)\n+                SEMI@[179; 180) \";\"\n         WHITESPACE@[180; 185) \"\\n    \"\n         LET_STMT@[185; 235)\n           LET_KW@[185; 188) \"let\"\n@@ -307,18 +304,16 @@ error 146: expected expression\n error 147: expected SEMI\n error 148: expected expression\n error 149: expected SEMI\n-error 151: expected expression\n-error 151: expected R_PAREN\n-error 151: expected SEMI\n error 154: expected pattern\n error 155: expected IN_KW\n error 155: expected expression\n error 157: expected a block\n-error 157: expected expression\n-error 158: expected SEMI\n error 165: expected expression\n error 168: expected expression\n error 179: expected expression\n+error 180: expected COMMA\n+error 180: expected expression\n+error 180: expected R_PAREN\n error 180: expected SEMI\n error 215: expected COMMA\n error 215: expected R_ANGLE"}, {"sha": "6e8b718aaf9a09dd576886be6ac035234dce2095", "filename": "crates/ra_syntax/test_data/parser/ok/0059_loops_in_parens.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0059_loops_in_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0059_loops_in_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0059_loops_in_parens.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    Some(for _ in [1].into_iter() {});\n+    Some(loop { break; });\n+    Some(while true {});\n+}"}, {"sha": "c011187ead5e76630d0663df2da536d701cb2611", "filename": "crates/ra_syntax/test_data/parser/ok/0059_loops_in_parens.txt", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0059_loops_in_parens.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0059_loops_in_parens.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0059_loops_in_parens.txt?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,101 @@\n+SOURCE_FILE@[0; 105)\n+  FN_DEF@[0; 104)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 7)\n+      IDENT@[3; 7) \"main\"\n+    PARAM_LIST@[7; 9)\n+      L_PAREN@[7; 8) \"(\"\n+      R_PAREN@[8; 9) \")\"\n+    WHITESPACE@[9; 10) \" \"\n+    BLOCK_EXPR@[10; 104)\n+      BLOCK@[10; 104)\n+        L_CURLY@[10; 11) \"{\"\n+        WHITESPACE@[11; 16) \"\\n    \"\n+        EXPR_STMT@[16; 50)\n+          CALL_EXPR@[16; 49)\n+            PATH_EXPR@[16; 20)\n+              PATH@[16; 20)\n+                PATH_SEGMENT@[16; 20)\n+                  NAME_REF@[16; 20)\n+                    IDENT@[16; 20) \"Some\"\n+            ARG_LIST@[20; 49)\n+              L_PAREN@[20; 21) \"(\"\n+              FOR_EXPR@[21; 48)\n+                FOR_KW@[21; 24) \"for\"\n+                WHITESPACE@[24; 25) \" \"\n+                PLACEHOLDER_PAT@[25; 26)\n+                  UNDERSCORE@[25; 26) \"_\"\n+                WHITESPACE@[26; 27) \" \"\n+                IN_KW@[27; 29) \"in\"\n+                WHITESPACE@[29; 30) \" \"\n+                METHOD_CALL_EXPR@[30; 45)\n+                  ARRAY_EXPR@[30; 33)\n+                    L_BRACK@[30; 31) \"[\"\n+                    LITERAL@[31; 32)\n+                      INT_NUMBER@[31; 32) \"1\"\n+                    R_BRACK@[32; 33) \"]\"\n+                  DOT@[33; 34) \".\"\n+                  NAME_REF@[34; 43)\n+                    IDENT@[34; 43) \"into_iter\"\n+                  ARG_LIST@[43; 45)\n+                    L_PAREN@[43; 44) \"(\"\n+                    R_PAREN@[44; 45) \")\"\n+                WHITESPACE@[45; 46) \" \"\n+                BLOCK_EXPR@[46; 48)\n+                  BLOCK@[46; 48)\n+                    L_CURLY@[46; 47) \"{\"\n+                    R_CURLY@[47; 48) \"}\"\n+              R_PAREN@[48; 49) \")\"\n+          SEMI@[49; 50) \";\"\n+        WHITESPACE@[50; 55) \"\\n    \"\n+        EXPR_STMT@[55; 77)\n+          CALL_EXPR@[55; 76)\n+            PATH_EXPR@[55; 59)\n+              PATH@[55; 59)\n+                PATH_SEGMENT@[55; 59)\n+                  NAME_REF@[55; 59)\n+                    IDENT@[55; 59) \"Some\"\n+            ARG_LIST@[59; 76)\n+              L_PAREN@[59; 60) \"(\"\n+              LOOP_EXPR@[60; 75)\n+                LOOP_KW@[60; 64) \"loop\"\n+                WHITESPACE@[64; 65) \" \"\n+                BLOCK_EXPR@[65; 75)\n+                  BLOCK@[65; 75)\n+                    L_CURLY@[65; 66) \"{\"\n+                    WHITESPACE@[66; 67) \" \"\n+                    EXPR_STMT@[67; 73)\n+                      BREAK_EXPR@[67; 72)\n+                        BREAK_KW@[67; 72) \"break\"\n+                      SEMI@[72; 73) \";\"\n+                    WHITESPACE@[73; 74) \" \"\n+                    R_CURLY@[74; 75) \"}\"\n+              R_PAREN@[75; 76) \")\"\n+          SEMI@[76; 77) \";\"\n+        WHITESPACE@[77; 82) \"\\n    \"\n+        EXPR_STMT@[82; 102)\n+          CALL_EXPR@[82; 101)\n+            PATH_EXPR@[82; 86)\n+              PATH@[82; 86)\n+                PATH_SEGMENT@[82; 86)\n+                  NAME_REF@[82; 86)\n+                    IDENT@[82; 86) \"Some\"\n+            ARG_LIST@[86; 101)\n+              L_PAREN@[86; 87) \"(\"\n+              WHILE_EXPR@[87; 100)\n+                WHILE_KW@[87; 92) \"while\"\n+                WHITESPACE@[92; 93) \" \"\n+                CONDITION@[93; 97)\n+                  LITERAL@[93; 97)\n+                    TRUE_KW@[93; 97) \"true\"\n+                WHITESPACE@[97; 98) \" \"\n+                BLOCK_EXPR@[98; 100)\n+                  BLOCK@[98; 100)\n+                    L_CURLY@[98; 99) \"{\"\n+                    R_CURLY@[99; 100) \"}\"\n+              R_PAREN@[100; 101) \")\"\n+          SEMI@[101; 102) \";\"\n+        WHITESPACE@[102; 103) \"\\n\"\n+        R_CURLY@[103; 104) \"}\"\n+  WHITESPACE@[104; 105) \"\\n\""}, {"sha": "413c7d782eb588464a778ce177346fae87f12fc1", "filename": "crates/ra_text_edit/src/text_edit.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -32,6 +32,24 @@ impl TextEditBuilder {\n }\n \n impl TextEdit {\n+    pub fn insert(offset: TextUnit, text: String) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.insert(offset, text);\n+        builder.finish()\n+    }\n+\n+    pub fn delete(range: TextRange) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.delete(range);\n+        builder.finish()\n+    }\n+\n+    pub fn replace(range: TextRange, replace_with: String) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.replace(range, replace_with);\n+        builder.finish()\n+    }\n+\n     pub(crate) fn from_atoms(mut atoms: Vec<AtomTextEdit>) -> TextEdit {\n         atoms.sort_by_key(|a| (a.delete.start(), a.delete.end()));\n         for (a1, a2) in atoms.iter().zip(atoms.iter().skip(1)) {"}, {"sha": "1244ea8cf189bbf4fa87a6124d53660148ef2145", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,4 +1,10 @@\n-//! FIXME: write short doc here\n+//! Assorted testing utilities.\n+//!\n+//! Most notable things are:\n+//!\n+//! * Rich text comparison, which outputs a diff.\n+//! * Extracting markup (mainly, `<|>` markers) out of fixture strings.\n+//! * marks (see the eponymous module).\n \n #[macro_use]\n pub mod marks;\n@@ -43,7 +49,7 @@ pub fn extract_offset(text: &str) -> (TextUnit, String) {\n     }\n }\n \n-pub fn try_extract_offset(text: &str) -> Option<(TextUnit, String)> {\n+fn try_extract_offset(text: &str) -> Option<(TextUnit, String)> {\n     let cursor_pos = text.find(CURSOR_MARKER)?;\n     let mut new_text = String::with_capacity(text.len() - CURSOR_MARKER.len());\n     new_text.push_str(&text[..cursor_pos]);\n@@ -59,12 +65,34 @@ pub fn extract_range(text: &str) -> (TextRange, String) {\n     }\n }\n \n-pub fn try_extract_range(text: &str) -> Option<(TextRange, String)> {\n+fn try_extract_range(text: &str) -> Option<(TextRange, String)> {\n     let (start, text) = try_extract_offset(text)?;\n     let (end, text) = try_extract_offset(&text)?;\n     Some((TextRange::from_to(start, end), text))\n }\n \n+pub enum RangeOrOffset {\n+    Range(TextRange),\n+    Offset(TextUnit),\n+}\n+\n+impl From<RangeOrOffset> for TextRange {\n+    fn from(selection: RangeOrOffset) -> Self {\n+        match selection {\n+            RangeOrOffset::Range(it) => it,\n+            RangeOrOffset::Offset(it) => TextRange::from_to(it, it),\n+        }\n+    }\n+}\n+\n+pub fn extract_range_or_offset(text: &str) -> (RangeOrOffset, String) {\n+    if let Some((range, text)) = try_extract_range(text) {\n+        return (RangeOrOffset::Range(range), text);\n+    }\n+    let (offset, text) = extract_offset(text);\n+    (RangeOrOffset::Offset(offset), text)\n+}\n+\n /// Extracts ranges, marked with `<tag> </tag>` paris from the `text`\n pub fn extract_ranges(mut text: &str, tag: &str) -> (Vec<TextRange>, String) {\n     let open = format!(\"<{}>\", tag);"}, {"sha": "006518afc0ffea98e29c0a75d80069ab3a5ee85f", "filename": "docs/dev/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -14,7 +14,7 @@ To learn more about how rust-analyzer works, see\n \n We also publish rustdoc docs to pages:\n \n-https://rust-analyzer.github.io/rust-analyzer/api-docs/ra_ide_api/\n+https://rust-analyzer.github.io/rust-analyzer/ra_ide_api/\n \n Various organizational and process issues are discussed in this document.\n "}, {"sha": "eb1d5ed141ecc9ef5900ab934c84ac834c00fe8a", "filename": "docs/user/README.md", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/docs%2Fuser%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/docs%2Fuser%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2FREADME.md?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -83,8 +83,6 @@ host.\n ### Settings\n \n * `rust-analyzer.highlightingOn`: enables experimental syntax highlighting\n-* `rust-analyzer.showWorkspaceLoadedNotification`: to ease troubleshooting, a\n-  notification is shown by default when a workspace is loaded\n * `rust-analyzer.enableEnhancedTyping`: by default, rust-analyzer intercepts\n   `Enter` key to make it easier to continue comments. Note that it may conflict with VIM emulation plugin.\n * `rust-analyzer.raLspServerPath`: path to `ra_lsp_server` executable\n@@ -102,6 +100,17 @@ host.\n * `rust-analyzer.trace.server`: enables internal logging\n * `rust-analyzer.trace.cargo-watch`: enables cargo-watch logging\n * `RUST_SRC_PATH`: environment variable that overwrites the sysroot\n+* `rust-analyzer.featureFlags` -- a JSON object to tweak fine-grained behavior:\n+   ```js\n+   {\n+       // Show diagnostics produced by rust-analyzer itself.\n+       \"lsp.diagnostics\": true,\n+       // Automatically insert `()` and `<>` when completing functions and types.\n+       \"completion.insertion.add-call-parenthesis\": true,\n+       // Show notification when workspace is fully loaded\n+       \"notifications.workspace-loaded\": true,\n+   }\n+   ```\n \n \n ## Emacs\n@@ -173,7 +182,11 @@ Installation:\n     \"syntaxes\": [\n         \"Packages/Rust/Rust.sublime-syntax\",\n         \"Packages/Rust Enhanced/RustEnhanced.sublime-syntax\"\n-    ]\n+    ],\n+    \"initializationOptions\": {\n+      \"featureFlags\": {\n+      }\n+    },\n }\n ```\n "}, {"sha": "303353e742940bf542ad54cb0554d1c3527c4abe", "filename": "docs/user/assists.md", "status": "added", "additions": 505, "deletions": 0, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,505 @@\n+# Assists\n+\n+Cursor position or selection is signified by `\u2503` character.\n+\n+\n+## `add_derive`\n+\n+Adds a new `#[derive()]` clause to a struct or enum.\n+\n+```rust\n+// BEFORE\n+struct Point {\n+    x: u32,\n+    y: u32,\u2503\n+}\n+\n+// AFTER\n+#[derive()]\n+struct Point {\n+    x: u32,\n+    y: u32,\n+}\n+```\n+\n+## `add_explicit_type`\n+\n+Specify type for a let binding.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    let x\u2503 = 92;\n+}\n+\n+// AFTER\n+fn main() {\n+    let x: i32 = 92;\n+}\n+```\n+\n+## `add_hash`\n+\n+Adds a hash to a raw string literal.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    r#\"Hello,\u2503 World!\"#;\n+}\n+\n+// AFTER\n+fn main() {\n+    r##\"Hello, World!\"##;\n+}\n+```\n+\n+## `add_impl`\n+\n+Adds a new inherent impl for a type.\n+\n+```rust\n+// BEFORE\n+struct Ctx<T: Clone> {\n+     data: T,\u2503\n+}\n+\n+// AFTER\n+struct Ctx<T: Clone> {\n+     data: T,\n+}\n+\n+impl<T: Clone> Ctx<T> {\n+\n+}\n+```\n+\n+## `add_impl_default_members`\n+\n+Adds scaffold for overriding default impl members.\n+\n+```rust\n+// BEFORE\n+trait T {\n+    Type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl T for () {\n+    Type X = ();\n+    fn foo(&self) {}\u2503\n+\n+}\n+\n+// AFTER\n+trait T {\n+    Type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl T for () {\n+    Type X = ();\n+    fn foo(&self) {}\n+    fn bar(&self) {}\n+\n+}\n+```\n+\n+## `add_impl_missing_members`\n+\n+Adds scaffold for required impl members.\n+\n+```rust\n+// BEFORE\n+trait T {\n+    Type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl T for () {\u2503\n+\n+}\n+\n+// AFTER\n+trait T {\n+    Type X;\n+    fn foo(&self);\n+    fn bar(&self) {}\n+}\n+\n+impl T for () {\n+    fn foo(&self) { unimplemented!() }\n+\n+}\n+```\n+\n+## `add_import`\n+\n+Adds a use statement for a given fully-qualified path.\n+\n+```rust\n+// BEFORE\n+fn process(map: std::collections::\u2503HashMap<String, String>) {}\n+\n+// AFTER\n+use std::collections::HashMap;\n+\n+fn process(map: HashMap<String, String>) {}\n+```\n+\n+## `apply_demorgan`\n+\n+Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).\n+This transforms expressions of the form `!l || !r` into `!(l && r)`.\n+This also works with `&&`. This assist can only be applied with the cursor\n+on either `||` or `&&`, with both operands being a negation of some kind.\n+This means something of the form `!x` or `x != y`.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    if x != 4 ||\u2503 !y {}\n+}\n+\n+// AFTER\n+fn main() {\n+    if !(x == 4 && y) {}\n+}\n+```\n+\n+## `change_visibility`\n+\n+Adds or changes existing visibility specifier.\n+\n+```rust\n+// BEFORE\n+\u2503fn frobnicate() {}\n+\n+// AFTER\n+pub(crate) fn frobnicate() {}\n+```\n+\n+## `convert_to_guarded_return`\n+\n+Replace a large conditional with a guarded return.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    \u2503if cond {\n+        foo();\n+        bar();\n+    }\n+}\n+\n+// AFTER\n+fn main() {\n+    if !cond {\n+        return;\n+    }\n+    foo();\n+    bar();\n+}\n+```\n+\n+## `fill_match_arms`\n+\n+Adds missing clauses to a `match` expression.\n+\n+```rust\n+// BEFORE\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        \u2503\n+    }\n+}\n+\n+// AFTER\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } => (),\n+        Action::Stop => (),\n+    }\n+}\n+```\n+\n+## `flip_binexpr`\n+\n+Flips operands of a binary expression.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    let _ = 90 +\u2503 2;\n+}\n+\n+// AFTER\n+fn main() {\n+    let _ = 2 + 90;\n+}\n+```\n+\n+## `flip_comma`\n+\n+Flips two comma-separated items.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    ((1, 2),\u2503 (3, 4));\n+}\n+\n+// AFTER\n+fn main() {\n+    ((3, 4), (1, 2));\n+}\n+```\n+\n+## `flip_trait_bound`\n+\n+Flips two trait bounds.\n+\n+```rust\n+// BEFORE\n+fn foo<T: Clone +\u2503 Copy>() { }\n+\n+// AFTER\n+fn foo<T: Copy + Clone>() { }\n+```\n+\n+## `inline_local_variable`\n+\n+Inlines local variable.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    let x\u2503 = 1 + 2;\n+    x * 4;\n+}\n+\n+// AFTER\n+fn main() {\n+    (1 + 2) * 4;\n+}\n+```\n+\n+## `introduce_variable`\n+\n+Extracts subexpression into a variable.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    \u2503(1 + 2)\u2503 * 4;\n+}\n+\n+// AFTER\n+fn main() {\n+    let var_name = (1 + 2);\n+    var_name * 4;\n+}\n+```\n+\n+## `make_raw_string`\n+\n+Adds `r#` to a plain string literal.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    \"Hello,\u2503 World!\";\n+}\n+\n+// AFTER\n+fn main() {\n+    r#\"Hello, World!\"#;\n+}\n+```\n+\n+## `make_usual_string`\n+\n+Turns a raw string into a plain string.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    r#\"Hello,\u2503 \"World!\"\"#;\n+}\n+\n+// AFTER\n+fn main() {\n+    \"Hello, \\\"World!\\\"\";\n+}\n+```\n+\n+## `merge_match_arms`\n+\n+Merges identical match arms.\n+\n+```rust\n+// BEFORE\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        \u2503Action::Move(..) => foo(),\n+        Action::Stop => foo(),\n+    }\n+}\n+\n+// AFTER\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move(..) | Action::Stop => foo(),\n+    }\n+}\n+```\n+\n+## `move_arm_cond_to_match_guard`\n+\n+Moves if expression from match arm body into a guard.\n+\n+```rust\n+// BEFORE\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } => \u2503if distance > 10 { foo() },\n+        _ => (),\n+    }\n+}\n+\n+// AFTER\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } if distance > 10 => foo(),\n+        _ => (),\n+    }\n+}\n+```\n+\n+## `move_bounds_to_where_clause`\n+\n+Moves inline type bounds to a where clause.\n+\n+```rust\n+// BEFORE\n+fn apply<T, U, \u2503F: FnOnce(T) -> U>(f: F, x: T) -> U {\n+    f(x)\n+}\n+\n+// AFTER\n+fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n+    f(x)\n+}\n+```\n+\n+## `move_guard_to_arm_body`\n+\n+Moves match guard into match arm body.\n+\n+```rust\n+// BEFORE\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } \u2503if distance > 10 => foo(),\n+        _ => (),\n+    }\n+}\n+\n+// AFTER\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } => if distance > 10 { foo() },\n+        _ => (),\n+    }\n+}\n+```\n+\n+## `remove_dbg`\n+\n+Removes `dbg!()` macro call.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    \u2503dbg!(92);\n+}\n+\n+// AFTER\n+fn main() {\n+    92;\n+}\n+```\n+\n+## `remove_hash`\n+\n+Removes a hash from a raw string literal.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    r#\"Hello,\u2503 World!\"#;\n+}\n+\n+// AFTER\n+fn main() {\n+    r\"Hello, World!\";\n+}\n+```\n+\n+## `replace_if_let_with_match`\n+\n+Replaces `if let` with an else branch with a `match` expression.\n+\n+```rust\n+// BEFORE\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    \u2503if let Action::Move { distance } = action {\n+        foo(distance)\n+    } else {\n+        bar()\n+    }\n+}\n+\n+// AFTER\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move { distance } => foo(distance),\n+        _ => bar(),\n+    }\n+}\n+```\n+\n+## `split_import`\n+\n+Wraps the tail of import into braces.\n+\n+```rust\n+// BEFORE\n+use std::\u2503collections::HashMap;\n+\n+// AFTER\n+use std::{collections::HashMap};\n+```"}, {"sha": "c160dd70bd95c5b378421ace92825cc344d0e009", "filename": "docs/user/features.md", "status": "modified", "additions": 6, "deletions": 418, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/docs%2Fuser%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/docs%2Fuser%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Ffeatures.md?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -97,424 +97,12 @@ Start `cargo watch` for live error highlighting. Will prompt to install if it's\n \n Stop `cargo watch`\n \n-### Code Actions (Assists)\n-\n-These are triggered in a particular context via light bulb. We use custom code on\n-the VS Code side to be able to position cursor. `<|>` signifies cursor\n-\n-- Add `#[derive]`\n-\n-```rust\n-// before:\n-struct Foo {\n-    <|>x: i32\n-}\n-// after:\n-#[derive(<|>)]\n-struct Foo {\n-    x: i32\n-}\n-```\n-\n-- Add `impl`\n-\n-```rust\n-// before:\n-struct Foo<'a, T: Debug> {\n-    <|>t: T\n-}\n-// after:\n-struct Foo<'a, T: Debug> {\n-    t: T\n-}\n-\n-impl<'a, T: Debug> Foo<'a, T> {\n-    <|>\n-}\n-```\n-\n-- Add missing `impl` members\n-\n-```rust\n-// before:\n-trait Foo {\n-    fn foo(&self);\n-    fn bar(&self);\n-    fn baz(&self);\n-}\n-\n-struct S;\n-\n-impl Foo for S {\n-    fn bar(&self) {}\n-    <|>\n-}\n-\n-// after:\n-trait Foo {\n-    fn foo(&self);\n-    fn bar(&self);\n-    fn baz(&self);\n-}\n-\n-struct S;\n-\n-impl Foo for S {\n-    fn bar(&self) {}\n-    fn foo(&self) { unimplemented!() }\n-    fn baz(&self) { unimplemented!() }<|>\n-}\n-```\n-\n-- Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)\n-\n-```rust\n-// before:\n-fn example(x: bool) -> bool {\n-    !x || !x\n-}\n-\n-// after:\n-fn example(x: bool) -> bool {\n-    !(x && x)\n-}\n-```\n-\n-- Import path\n-\n-```rust\n-// before:\n-impl std::fmt::Debug<|> for Foo {\n-}\n-\n-// after:\n-use std::fmt::Debug;\n-\n-impl Debug<|> for Foo {\n-}\n-```\n-\n-- Change Visibility\n-\n-```rust\n-// before:\n-<|>fn foo() {}\n-\n-// after:\n-<|>pub(crate) fn foo() {}\n-\n-// after:\n-<|>pub fn foo() {}\n-```\n-\n-- Fill match arms\n-\n-```rust\n-// before:\n-enum A {\n-    As,\n-    Bs,\n-    Cs(String),\n-    Ds(String, String),\n-    Es{x: usize, y: usize}\n-}\n-\n-fn main() {\n-    let a = A::As;\n-    match a<|> {}\n-}\n-\n-// after:\n-enum A {\n-    As,\n-    Bs,\n-    Cs(String),\n-    Ds(String, String),\n-    Es{x: usize, y: usize}\n-}\n-\n-fn main() {\n-    let a = A::As;\n-    match <|>a {\n-        A::As => (),\n-        A::Bs => (),\n-        A::Cs(_) => (),\n-        A::Ds(_, _) => (),\n-        A::Es{x, y} => (),\n-    }\n-}\n-```\n-\n-- Fill struct fields\n-\n-```rust\n-// before:\n-struct S<'a, D> {\n-    a: u32,\n-    b: String,\n-    c: (i32, i32),\n-    d: D,\n-    r: &'a str,\n-}\n-\n-fn main() {\n-    let s = S<|> {}\n-}\n-\n-// after:\n-struct S<'a, D> {\n-    a: u32,\n-    b: String,\n-    c: (i32, i32),\n-    d: D,\n-    r: &'a str,\n-}\n-\n-fn main() {\n-    let s = <|>S {\n-        a: (),\n-        b: (),\n-        c: (),\n-        d: (),\n-        r: (),\n-    }\n-}\n-```\n-\n-- Flip `,`\n-\n-```rust\n-// before:\n-fn foo(x: usize,<|> dim: (usize, usize)) {}\n-// after:\n-fn foo(dim: (usize, usize), x: usize) {}\n-```\n-\n-- Introduce variable:\n-\n-```rust\n-// before:\n-fn foo() {\n-    foo(<|>1 + 1<|>);\n-}\n-\n-// after:\n-fn foo() {\n-    let var_name = 1 + 1;\n-    foo(var_name);\n-}\n-```\n-\n-- Inline local variable:\n-\n-```rust\n-// before:\n-fn foo() {\n-    let a<|> = 1 + 1;\n-    let b = a * 10;\n-}\n-\n-// after:\n-fn foo() {\n-    let b = (1 + 1) * 10;\n-}\n-```\n-\n-- Remove `dbg!`\n-\n-```rust\n-// before:\n-fn foo(n: usize) {\n-    if let Some(_) = dbg!(n.<|>checked_sub(4)) {\n-        // ...\n-    }\n-}\n-\n-// after:\n-fn foo(n: usize) {\n-    if let Some(_) = n.<|>checked_sub(4) {\n-        // ...\n-    }\n-}\n-```\n-\n-- Replace if-let with match:\n-\n-```rust\n-// before:\n-impl VariantData {\n-    pub fn is_struct(&self) -> bool {\n-        if <|>let VariantData::Struct(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-// after:\n-impl VariantData {\n-    pub fn is_struct(&self) -> bool {\n-        <|>match *self {\n-            VariantData::Struct(..) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-```\n-\n-- Split import\n-\n-```rust\n-// before:\n-use crate:<|>:db::{RootDatabase, FileSymbol};\n-// after:\n-use crate::{<|>db::{RootDatabase, FileSymbol}};\n-```\n-\n-- Flip binary expression\n-\n-```rust\n-// before:\n-fn foo() {\n-    if 1 <<|> 2 {\n-        println!(\"Who would have thought?\");\n-    }\n-}\n-// after:\n-fn foo() {\n-    if 2 ><|> 1 {\n-        println!(\"Who would have thought?\");\n-    }\n-}\n-```\n-\n-- Add explicit type\n-\n-```rust\n-// before:\n-fn foo() {\n-    let t<|> = (&2, Some(1));\n-}\n-// after:\n-fn foo() {\n-    let t<|>: (&i32, Option<i32>) = (&2, Some(1));\n-}\n-```\n-\n-- Move guard expression to match arm body\n-```rust\n-// before:\n-fn f() {\n-    match x {\n-        <|>y @ 4 | y @ 5    if y > 5 => true,\n-        _ => false\n-    }\n-}\n-// after:\n-fn f() {\n-    match x {\n-        y @ 4 | y @ 5 => if y > 5 { <|>true },\n-        _ => false\n-    }\n-}\n-```\n-\n-- Move if condition to match arm guard\n-```rust\n-// before:\n-fn f() {\n-    let mut t = 'a';\n-    let chars = \"abcd\";\n-    match t {\n-        '\\r' => if chars.clone().next().is_some() {\n-            t = 'e';<|>\n-            false\n-        },\n-        _ => true\n-    }\n-}\n-\n-// after:\n-fn f() {\n-    let mut t = 'a';\n-    let chars = \"abcd\";\n-    match t {\n-        '\\r' <|>if chars.clone().next().is_some() => {\n-            t = 'e';\n-            false\n-        },\n-        _ => true\n-    }\n-}\n-```\n-\n-- Move type bounds to where clause\n-\n-```rust\n-// before:\n-fn foo<T: u32, F: FnOnce(T) -> T>() {}\n-\n-// after:\n-fn foo<T, F>() where T: u32, F: FnOnce(T) -> T {}\n-```\n-\n-- Make raw string unescaped\n-\n-```rust\n-// before:\n-fn f() {\n-    let s = <|>\"ab\\ncd\";\n-}\n-\n-// after:\n-fn f() {\n-    let s = <|>r#\"ab\n-cd\"#;\n-}\n-```\n-\n-- Make usual string\n-\n-```rust\n-// before:\n-fn f() {\n-    let s = <|>r#\"abcd\"#;\n-}\n-\n-// after:\n-fn f() {\n-    let s = <|>\"abcd\";\n-}\n-```\n-\n-- Add hash\n-\n-```rust\n-// before:\n-fn f() {\n-    let s = <|>r\"abcd\";\n-}\n-\n-// after:\n-fn f() {\n-    let s = <|>r#\"abcd\"#;\n-}\n-```\n-\n-- Remove hash\n-\n-```rust\n-// before:\n-fn f() {\n-    let s = <|>r#\"abcd\"#;\n-}\n-\n-// after:\n-fn f() {\n-    let s = <|>r\"abcd\";\n-}\n-```\n+### Assists (Code Actions)\n+\n+Assists, or code actions, are small local refactorings, available in a particular context.\n+They are usually triggered by a shortcut or by clicking a light bulb icon in the editor.\n+\n+See [assists.md](./assists.md) for the list of available assists.\n \n ### Magic Completions\n "}, {"sha": "ee997e58f5d09c099f63210215e65efd1419c345", "filename": "editors/code/package.json", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -229,11 +229,6 @@\n                     \"description\": \"A list of patterns for cargo-watch to ignore (will be passed as `--ignore`)\",\n                     \"default\": []\n                 },\n-                \"rust-analyzer.showWorkspaceLoadedNotification\": {\n-                    \"type\": \"boolean\",\n-                    \"description\": \"Controls whether rust-analyzer displays a notification when a project is loaded.\",\n-                    \"default\": false\n-                },\n                 \"rust-analyzer.trace.server\": {\n                     \"type\": \"string\",\n                     \"scope\": \"window\","}, {"sha": "12823f31985b12d837504fae27e40a7db5fa265f", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -21,7 +21,6 @@ export class Config {\n     public rainbowHighlightingOn = false;\n     public enableEnhancedTyping = true;\n     public raLspServerPath = RA_LSP_DEBUG || 'ra_lsp_server';\n-    public showWorkspaceLoadedNotification = true;\n     public lruCapacity: null | number = null;\n     public displayInlayHints = true;\n     public maxInlayHintLength: null | number = null;\n@@ -62,12 +61,6 @@ export class Config {\n             ) as boolean;\n         }\n \n-        if (config.has('showWorkspaceLoadedNotification')) {\n-            this.showWorkspaceLoadedNotification = config.get(\n-                'showWorkspaceLoadedNotification'\n-            ) as boolean;\n-        }\n-\n         if (!this.highlightingOn && Server) {\n             Server.highlighter.removeHighlights();\n         }"}, {"sha": "07a5c59e81e468bba72af86968ea17d3da8eefd3", "filename": "editors/code/src/extension.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/editors%2Fcode%2Fsrc%2Fextension.ts", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/editors%2Fcode%2Fsrc%2Fextension.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fextension.ts?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -45,7 +45,7 @@ export function activate(context: vscode.ExtensionContext) {\n             });\n         } catch (_) {\n             vscode.window.showWarningMessage(\n-                'Enhanced typing feature is disabled because of incompatibility with VIM extension'\n+                'Enhanced typing feature is disabled because of incompatibility with VIM extension, consider turning off rust-analyzer.enableEnhancedTyping: https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/README.md#settings'\n             );\n         }\n     }"}, {"sha": "a3ef21a1671949dec48dfe8ff7c409be8a34c1e6", "filename": "editors/code/src/server.ts", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/editors%2Fcode%2Fsrc%2Fserver.ts", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/editors%2Fcode%2Fsrc%2Fserver.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fserver.ts?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -42,8 +42,6 @@ export class Server {\n             documentSelector: [{ scheme: 'file', language: 'rust' }],\n             initializationOptions: {\n                 publishDecorations: true,\n-                showWorkspaceLoaded:\n-                    Server.config.showWorkspaceLoadedNotification,\n                 lruCapacity: Server.config.lruCapacity,\n                 excludeGlobs: Server.config.excludeGlobs,\n                 useClientWatching: Server.config.useClientWatching,"}, {"sha": "4ec8ab75af5c371951e7f8b489bad971f935a410", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 68, "deletions": 4, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -7,12 +7,22 @@\n \n mod gen_syntax;\n mod gen_parser_tests;\n+mod gen_assists_docs;\n \n-use std::{fs, path::Path};\n+use std::{\n+    fs,\n+    io::Write,\n+    mem,\n+    path::Path,\n+    process::{Command, Stdio},\n+};\n \n-use crate::Result;\n+use crate::{project_root, Result};\n \n-pub use self::{gen_parser_tests::generate_parser_tests, gen_syntax::generate_syntax};\n+pub use self::{\n+    gen_assists_docs::generate_assists_docs, gen_parser_tests::generate_parser_tests,\n+    gen_syntax::generate_syntax,\n+};\n \n pub const GRAMMAR: &str = \"crates/ra_syntax/src/grammar.ron\";\n const GRAMMAR_DIR: &str = \"crates/ra_parser/src/grammar\";\n@@ -22,6 +32,10 @@ const ERR_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/test_data/parser/inline/err\n pub const SYNTAX_KINDS: &str = \"crates/ra_parser/src/syntax_kind/generated.rs\";\n pub const AST: &str = \"crates/ra_syntax/src/ast/generated.rs\";\n \n+const ASSISTS_DIR: &str = \"crates/ra_assists/src/assists\";\n+const ASSISTS_TESTS: &str = \"crates/ra_assists/src/doc_tests/generated.rs\";\n+const ASSISTS_DOCS: &str = \"docs/user/assists.md\";\n+\n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub enum Mode {\n     Overwrite,\n@@ -30,7 +44,7 @@ pub enum Mode {\n \n /// A helper to update file on disk if it has changed.\n /// With verify = false,\n-pub fn update(path: &Path, contents: &str, mode: Mode) -> Result<()> {\n+fn update(path: &Path, contents: &str, mode: Mode) -> Result<()> {\n     match fs::read_to_string(path) {\n         Ok(ref old_contents) if old_contents == contents => {\n             return Ok(());\n@@ -44,3 +58,53 @@ pub fn update(path: &Path, contents: &str, mode: Mode) -> Result<()> {\n     fs::write(path, contents)?;\n     Ok(())\n }\n+\n+fn reformat(text: impl std::fmt::Display) -> Result<String> {\n+    let mut rustfmt = Command::new(\"rustfmt\")\n+        .arg(\"--config-path\")\n+        .arg(project_root().join(\"rustfmt.toml\"))\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .spawn()?;\n+    write!(rustfmt.stdin.take().unwrap(), \"{}\", text)?;\n+    let output = rustfmt.wait_with_output()?;\n+    let stdout = String::from_utf8(output.stdout)?;\n+    let preamble = \"Generated file, do not edit by hand, see `crate/ra_tools/src/codegen`\";\n+    Ok(format!(\"//! {}\\n\\n{}\", preamble, stdout))\n+}\n+\n+fn extract_comment_blocks(text: &str) -> Vec<Vec<String>> {\n+    do_extract_comment_blocks(text, false)\n+}\n+\n+fn extract_comment_blocks_with_empty_lines(text: &str) -> Vec<Vec<String>> {\n+    do_extract_comment_blocks(text, true)\n+}\n+\n+fn do_extract_comment_blocks(text: &str, allow_blocks_with_empty_lins: bool) -> Vec<Vec<String>> {\n+    let mut res = Vec::new();\n+\n+    let prefix = \"// \";\n+    let lines = text.lines().map(str::trim_start);\n+\n+    let mut block = vec![];\n+    for line in lines {\n+        if line == \"//\" && allow_blocks_with_empty_lins {\n+            block.push(String::new());\n+            continue;\n+        }\n+\n+        let is_comment = line.starts_with(prefix);\n+        if is_comment {\n+            block.push(line[prefix.len()..].to_string());\n+        } else {\n+            if !block.is_empty() {\n+                res.push(mem::replace(&mut block, Vec::new()))\n+            }\n+        }\n+    }\n+    if !block.is_empty() {\n+        res.push(mem::replace(&mut block, Vec::new()))\n+    }\n+    res\n+}"}, {"sha": "05afda8f11183d8f472a0affdaa38d76f21a77c8", "filename": "xtask/src/codegen/gen_assists_docs.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -0,0 +1,137 @@\n+use std::{fs, path::Path};\n+\n+use crate::{\n+    codegen::{self, extract_comment_blocks_with_empty_lines, Mode},\n+    project_root, Result,\n+};\n+\n+pub fn generate_assists_docs(mode: Mode) -> Result<()> {\n+    let assists = collect_assists()?;\n+    generate_tests(&assists, mode)?;\n+    generate_docs(&assists, mode)?;\n+    Ok(())\n+}\n+\n+#[derive(Debug)]\n+struct Assist {\n+    id: String,\n+    doc: String,\n+    before: String,\n+    after: String,\n+}\n+\n+fn collect_assists() -> Result<Vec<Assist>> {\n+    let mut res = Vec::new();\n+    for entry in fs::read_dir(project_root().join(codegen::ASSISTS_DIR))? {\n+        let entry = entry?;\n+        let path = entry.path();\n+        if path.is_file() {\n+            collect_file(&mut res, path.as_path())?;\n+        }\n+    }\n+    res.sort_by(|lhs, rhs| lhs.id.cmp(&rhs.id));\n+    return Ok(res);\n+\n+    fn collect_file(acc: &mut Vec<Assist>, path: &Path) -> Result<()> {\n+        let text = fs::read_to_string(path)?;\n+        let comment_blocks = extract_comment_blocks_with_empty_lines(&text);\n+\n+        for block in comment_blocks {\n+            // FIXME: doesn't support blank lines yet, need to tweak\n+            // `extract_comment_blocks` for that.\n+            let mut lines = block.iter();\n+            let first_line = lines.next().unwrap();\n+            if !first_line.starts_with(\"Assist: \") {\n+                continue;\n+            }\n+            let id = first_line[\"Assist: \".len()..].to_string();\n+            assert!(\n+                id.chars().all(|it| it.is_ascii_lowercase() || it == '_'),\n+                \"invalid assist id: {:?}\",\n+                id\n+            );\n+\n+            let doc = take_until(lines.by_ref(), \"```\").trim().to_string();\n+            assert!(\n+                doc.chars().next().unwrap().is_ascii_uppercase() && doc.ends_with('.'),\n+                \"\\n\\n{}: assist docs should be proper sentences, with capitalization and a full stop at the end.\\n\\n{}\\n\\n\",\n+                id, doc,\n+            );\n+\n+            let before = take_until(lines.by_ref(), \"```\");\n+\n+            assert_eq!(lines.next().unwrap().as_str(), \"->\");\n+            assert_eq!(lines.next().unwrap().as_str(), \"```\");\n+            let after = take_until(lines.by_ref(), \"```\");\n+            acc.push(Assist { id, doc, before, after })\n+        }\n+\n+        fn take_until<'a>(lines: impl Iterator<Item = &'a String>, marker: &str) -> String {\n+            let mut buf = Vec::new();\n+            for line in lines {\n+                if line == marker {\n+                    break;\n+                }\n+                buf.push(line.clone());\n+            }\n+            buf.join(\"\\n\")\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn generate_tests(assists: &[Assist], mode: Mode) -> Result<()> {\n+    let mut buf = String::from(\"use super::check;\\n\");\n+\n+    for assist in assists.iter() {\n+        let test = format!(\n+            r######\"\n+#[test]\n+fn doctest_{}() {{\n+    check(\n+        \"{}\",\n+r#####\"\n+{}\n+\"#####, r#####\"\n+{}\n+\"#####)\n+}}\n+\"######,\n+            assist.id, assist.id, assist.before, assist.after\n+        );\n+\n+        buf.push_str(&test)\n+    }\n+    let buf = codegen::reformat(buf)?;\n+    codegen::update(&project_root().join(codegen::ASSISTS_TESTS), &buf, mode)\n+}\n+\n+fn generate_docs(assists: &[Assist], mode: Mode) -> Result<()> {\n+    let mut buf = String::from(\n+        \"# Assists\\n\\nCursor position or selection is signified by `\u2503` character.\\n\\n\",\n+    );\n+\n+    for assist in assists {\n+        let before = assist.before.replace(\"<|>\", \"\u2503\"); // Unicode pseudo-graphics bar\n+        let after = assist.after.replace(\"<|>\", \"\u2503\");\n+        let docs = format!(\n+            \"\n+## `{}`\n+\n+{}\n+\n+```rust\n+// BEFORE\n+{}\n+\n+// AFTER\n+{}\n+```\n+\",\n+            assist.id, assist.doc, before, after\n+        );\n+        buf.push_str(&docs);\n+    }\n+\n+    codegen::update(&project_root().join(codegen::ASSISTS_DOCS), &buf, mode)\n+}"}, {"sha": "d0f0f683b817ea12c6a4fb88f4ffd45b214f650b", "filename": "xtask/src/codegen/gen_parser_tests.rs", "status": "modified", "additions": 25, "deletions": 46, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Fsrc%2Fcodegen%2Fgen_parser_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Fsrc%2Fcodegen%2Fgen_parser_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_parser_tests.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -3,12 +3,12 @@\n \n use std::{\n     collections::HashMap,\n-    fs,\n+    fs, iter,\n     path::{Path, PathBuf},\n };\n \n use crate::{\n-    codegen::{self, update, Mode},\n+    codegen::{self, extract_comment_blocks, update, Mode},\n     project_root, Result,\n };\n \n@@ -56,48 +56,29 @@ struct Tests {\n     pub err: HashMap<String, Test>,\n }\n \n-fn collect_tests(s: &str) -> Vec<(usize, Test)> {\n-    let mut res = vec![];\n-    let prefix = \"// \";\n-    let lines = s.lines().map(str::trim_start).enumerate();\n-\n-    let mut block = vec![];\n-    for (line_idx, line) in lines {\n-        let is_comment = line.starts_with(prefix);\n-        if is_comment {\n-            block.push((line_idx, &line[prefix.len()..]));\n+fn collect_tests(s: &str) -> Vec<Test> {\n+    let mut res = Vec::new();\n+    for comment_block in extract_comment_blocks(s) {\n+        let first_line = &comment_block[0];\n+        let (name, ok) = if first_line.starts_with(\"test \") {\n+            let name = first_line[\"test \".len()..].to_string();\n+            (name, true)\n+        } else if first_line.starts_with(\"test_err \") {\n+            let name = first_line[\"test_err \".len()..].to_string();\n+            (name, false)\n         } else {\n-            process_block(&mut res, &block);\n-            block.clear();\n-        }\n-    }\n-    process_block(&mut res, &block);\n-    return res;\n-\n-    fn process_block(acc: &mut Vec<(usize, Test)>, block: &[(usize, &str)]) {\n-        if block.is_empty() {\n-            return;\n-        }\n-        let mut ok = true;\n-        let mut block = block.iter();\n-        let (start_line, name) = loop {\n-            match block.next() {\n-                Some(&(idx, line)) if line.starts_with(\"test \") => {\n-                    break (idx, line[\"test \".len()..].to_string());\n-                }\n-                Some(&(idx, line)) if line.starts_with(\"test_err \") => {\n-                    ok = false;\n-                    break (idx, line[\"test_err \".len()..].to_string());\n-                }\n-                Some(_) => (),\n-                None => return,\n-            }\n+            continue;\n         };\n-        let text: String =\n-            block.map(|(_, line)| *line).chain(std::iter::once(\"\")).collect::<Vec<_>>().join(\"\\n\");\n+        let text: String = comment_block[1..]\n+            .iter()\n+            .cloned()\n+            .chain(iter::once(String::new()))\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n         assert!(!text.trim().is_empty() && text.ends_with('\\n'));\n-        acc.push((start_line, Test { name, text, ok }))\n+        res.push(Test { name, text, ok })\n     }\n+    res\n }\n \n fn tests_from_dir(dir: &Path) -> Result<Tests> {\n@@ -118,15 +99,13 @@ fn tests_from_dir(dir: &Path) -> Result<Tests> {\n     fn process_file(res: &mut Tests, path: &Path) -> Result<()> {\n         let text = fs::read_to_string(path)?;\n \n-        for (_, test) in collect_tests(&text) {\n+        for test in collect_tests(&text) {\n             if test.ok {\n                 if let Some(old_test) = res.ok.insert(test.name.clone(), test) {\n-                    Err(format!(\"Duplicate test: {}\", old_test.name))?\n-                }\n-            } else {\n-                if let Some(old_test) = res.err.insert(test.name.clone(), test) {\n-                    Err(format!(\"Duplicate test: {}\", old_test.name))?\n+                    return Err(format!(\"Duplicate test: {}\", old_test.name).into());\n                 }\n+            } else if let Some(old_test) = res.err.insert(test.name.clone(), test) {\n+                return Err(format!(\"Duplicate test: {}\", old_test.name).into());\n             }\n         }\n         Ok(())"}, {"sha": "88f2ac0e35e2652ad27744256c0f8a4efe7b2d9e", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -3,12 +3,7 @@\n //! Specifically, it generates the `SyntaxKind` enum and a number of newtype\n //! wrappers around `SyntaxNode` which implement `ra_syntax::AstNode`.\n \n-use std::{\n-    collections::BTreeMap,\n-    fs,\n-    io::Write,\n-    process::{Command, Stdio},\n-};\n+use std::{collections::BTreeMap, fs};\n \n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n@@ -163,7 +158,7 @@ fn generate_ast(grammar: &Grammar) -> Result<String> {\n         #(#nodes)*\n     };\n \n-    let pretty = reformat(ast)?;\n+    let pretty = codegen::reformat(ast)?;\n     Ok(pretty)\n }\n \n@@ -276,21 +271,7 @@ fn generate_syntax_kinds(grammar: &Grammar) -> Result<String> {\n         }\n     };\n \n-    reformat(ast)\n-}\n-\n-fn reformat(text: impl std::fmt::Display) -> Result<String> {\n-    let mut rustfmt = Command::new(\"rustfmt\")\n-        .arg(\"--config-path\")\n-        .arg(project_root().join(\"rustfmt.toml\"))\n-        .stdin(Stdio::piped())\n-        .stdout(Stdio::piped())\n-        .spawn()?;\n-    write!(rustfmt.stdin.take().unwrap(), \"{}\", text)?;\n-    let output = rustfmt.wait_with_output()?;\n-    let stdout = String::from_utf8(output.stdout)?;\n-    let preamble = \"Generated file, do not edit by hand, see `crate/ra_tools/src/codegen`\";\n-    Ok(format!(\"//! {}\\n\\n{}\", preamble, stdout))\n+    codegen::reformat(ast)\n }\n \n #[derive(Deserialize, Debug)]"}, {"sha": "e04e45f157529c5f14d2639345467597b7d9bc2b", "filename": "xtask/src/main.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -1,5 +1,12 @@\n-//! FIXME: write short doc here\n-\n+//! See https://github.com/matklad/cargo-xtask/.\n+//!\n+//! This binary defines various auxiliary build commands, which are not\n+//! expressible with just `cargo`. Notably, it provides `cargo xtask codegen`\n+//! for code generation and `cargo xtask install` for installation of\n+//! rust-analyzer server and client.\n+//!\n+//! This binary is integrated into the `cargo` command line by using an alias in\n+//! `.cargo/config`.\n mod help;\n \n use core::fmt::Write;\n@@ -53,7 +60,7 @@ fn main() -> Result<()> {\n             matches.finish().or_else(handle_extra_flags)?;\n             let opts = InstallOpt {\n                 client: if server { None } else { Some(ClientOpt::VsCode) },\n-                server: if client_code { None } else { Some(ServerOpt { jemalloc: jemalloc }) },\n+                server: if client_code { None } else { Some(ServerOpt { jemalloc }) },\n             };\n             install(opts)?\n         }\n@@ -64,6 +71,7 @@ fn main() -> Result<()> {\n             }\n             codegen::generate_syntax(Mode::Overwrite)?;\n             codegen::generate_parser_tests(Mode::Overwrite)?;\n+            codegen::generate_assists_docs(Mode::Overwrite)?;\n         }\n         \"format\" => {\n             if matches.contains([\"-h\", \"--help\"]) {\n@@ -158,6 +166,17 @@ fn fix_path_for_mac() -> Result<()> {\n }\n \n fn install_client(ClientOpt::VsCode: ClientOpt) -> Result<()> {\n+    let npm_version = Cmd {\n+        unix: r\"npm --version\",\n+        windows: r\"cmd.exe /c npm.cmd --version\",\n+        work_dir: \"./editors/code\",\n+    }\n+    .run();\n+\n+    if npm_version.is_err() {\n+        eprintln!(\"\\nERROR: `npm --version` failed, `npm` is required to build the VS Code plugin\")\n+    }\n+\n     Cmd { unix: r\"npm ci\", windows: r\"cmd.exe /c npm.cmd ci\", work_dir: \"./editors/code\" }.run()?;\n     Cmd {\n         unix: r\"npm run package\",\n@@ -210,6 +229,7 @@ fn install_server(opts: ServerOpt) -> Result<()> {\n     let mut old_rust = false;\n     if let Ok(output) = run_with_output(\"cargo --version\", \".\") {\n         if let Ok(stdout) = String::from_utf8(output.stdout) {\n+            println!(\"{}\", stdout);\n             if !check_version(&stdout, REQUIRED_RUST_VERSION) {\n                 old_rust = true;\n             }"}, {"sha": "573ffadbf8eec9e68da691d6bea7e76bb6105eac", "filename": "xtask/tests/tidy-tests/cli.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Ftests%2Ftidy-tests%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Ftests%2Ftidy-tests%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fcli.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -18,6 +18,13 @@ fn generated_tests_are_fresh() {\n     }\n }\n \n+#[test]\n+fn generated_assists_are_fresh() {\n+    if let Err(error) = codegen::generate_assists_docs(Mode::Verify) {\n+        panic!(\"{}. Please update assists by running `cargo xtask codegen`\", error);\n+    }\n+}\n+\n #[test]\n fn check_code_formatting() {\n     if let Err(error) = run_rustfmt(Mode::Verify) {"}, {"sha": "6a629ce63e8fc6cec66ee3d7d9408f3d9607d0eb", "filename": "xtask/tests/tidy-tests/docs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8edda0e7b164009d6c03bb3d4be603fb38ad2e2a/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs?ref=8edda0e7b164009d6c03bb3d4be603fb38ad2e2a", "patch": "@@ -8,7 +8,9 @@ use walkdir::{DirEntry, WalkDir};\n use xtask::project_root;\n \n fn is_exclude_dir(p: &Path) -> bool {\n-    let exclude_dirs = [\"tests\", \"test_data\"];\n+    // Test hopefully don't really need comments, and for assists we already\n+    // have special comments which are source of doc tests and user docs.\n+    let exclude_dirs = [\"tests\", \"test_data\", \"assists\"];\n     let mut cur_path = p;\n     while let Some(path) = cur_path.parent() {\n         if exclude_dirs.iter().any(|dir| path.ends_with(dir)) {\n@@ -27,7 +29,7 @@ fn is_exclude_file(d: &DirEntry) -> bool {\n }\n \n fn is_hidden(entry: &DirEntry) -> bool {\n-    entry.file_name().to_str().map(|s| s.starts_with(\".\")).unwrap_or(false)\n+    entry.file_name().to_str().map(|s| s.starts_with('.')).unwrap_or(false)\n }\n \n #[test]"}]}