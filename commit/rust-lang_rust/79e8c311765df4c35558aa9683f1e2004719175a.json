{"sha": "79e8c311765df4c35558aa9683f1e2004719175a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZThjMzExNzY1ZGY0YzM1NTU4YWE5NjgzZjFlMjAwNDcxOTE3NWE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-06T13:13:01Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-13T19:41:31Z"}, "message": "Propagate region constraints more precisely from closures", "tree": {"sha": "6485a8eaa4965a47e2e135193043dfac70f5a8c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6485a8eaa4965a47e2e135193043dfac70f5a8c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79e8c311765df4c35558aa9683f1e2004719175a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79e8c311765df4c35558aa9683f1e2004719175a", "html_url": "https://github.com/rust-lang/rust/commit/79e8c311765df4c35558aa9683f1e2004719175a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79e8c311765df4c35558aa9683f1e2004719175a/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea613f30d9728e9bc283ec213225ea8bdaa18f7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea613f30d9728e9bc283ec213225ea8bdaa18f7c", "html_url": "https://github.com/rust-lang/rust/commit/ea613f30d9728e9bc283ec213225ea8bdaa18f7c"}], "stats": {"total": 208, "additions": 142, "deletions": 66}, "files": [{"sha": "cbeb5dc206ee68d5754cbbe1f96e62c4f9f85fe9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/79e8c311765df4c35558aa9683f1e2004719175a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79e8c311765df4c35558aa9683f1e2004719175a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=79e8c311765df4c35558aa9683f1e2004719175a", "patch": "@@ -763,20 +763,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             debug!(\"try_promote_type_test: ur={:?}\", ur);\n \n-            let non_local_ub = self.universal_region_relations.non_local_upper_bound(ur);\n+            let non_local_ub = self.universal_region_relations.non_local_upper_bounds(&ur);\n             debug!(\"try_promote_type_test: non_local_ub={:?}\", non_local_ub);\n \n-            assert!(self.universal_regions.is_universal_region(non_local_ub));\n-            assert!(!self.universal_regions.is_local_free_region(non_local_ub));\n-\n-            let requirement = ClosureOutlivesRequirement {\n-                subject,\n-                outlived_free_region: non_local_ub,\n-                blame_span: locations.span(mir),\n-                category: ConstraintCategory::Boring,\n-            };\n-            debug!(\"try_promote_type_test: pushing {:#?}\", requirement);\n-            propagated_outlives_requirements.push(requirement);\n+            // This is slightly too conservative. To show T: '1, given `'2: '1`\n+            // and `'3: '1` we only need to prove that T: '2 *or* T: '3, but to\n+            // avoid potential non-determinism we approximate this by requiring\n+            // T: '1 and T: '2.\n+            for &upper_bound in non_local_ub {\n+                debug_assert!(self.universal_regions.is_universal_region(upper_bound));\n+                debug_assert!(!self.universal_regions.is_local_free_region(upper_bound));\n+\n+                let requirement = ClosureOutlivesRequirement {\n+                    subject,\n+                    outlived_free_region: upper_bound,\n+                    blame_span: locations.span(mir),\n+                    category: ConstraintCategory::Boring,\n+                };\n+                debug!(\"try_promote_type_test: pushing {:#?}\", requirement);\n+                propagated_outlives_requirements.push(requirement);\n+            }\n         }\n         true\n     }\n@@ -1217,35 +1223,37 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             longer_fr, shorter_fr,\n         );\n \n-\n         if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n-            // Shrink `fr` until we find a non-local region (if we do).\n-            // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n-            if let Some(fr_minus) = self.universal_region_relations\n+            // Shrink `longer_fr` until we find a non-local region (if we do).\n+            // We'll call it `fr-` -- it's ever so slightly smaller than\n+            // `longer_fr`.\n+\n+            if let Some(fr_minus) = self\n+                .universal_region_relations\n                 .non_local_lower_bound(longer_fr)\n             {\n                 debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n \n                 let blame_span_category = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n \n-                // Grow `shorter_fr` until we find a non-local\n-                // region. (We always will.)  We'll call that\n-                // `shorter_fr+` -- it's ever so slightly larger than\n-                // `fr`.\n+                // Grow `shorter_fr` until we find some non-local regions. (We\n+                // always will.)  We'll call them `shorter_fr+` -- they're ever\n+                // so slightly larger than `shorter_fr`.\n                 let shorter_fr_plus = self.universal_region_relations\n-                    .non_local_upper_bound(shorter_fr);\n+                    .non_local_upper_bounds(&shorter_fr);\n                 debug!(\n                     \"check_universal_region: shorter_fr_plus={:?}\",\n                     shorter_fr_plus\n                 );\n-\n-                // Push the constraint `fr-: shorter_fr+`\n-                propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n-                    subject: ClosureOutlivesSubject::Region(fr_minus),\n-                    outlived_free_region: shorter_fr_plus,\n-                    blame_span: blame_span_category.1,\n-                    category: blame_span_category.0,\n-                });\n+                for &&fr in &shorter_fr_plus {\n+                    // Push the constraint `fr-: shorter_fr+`\n+                    propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n+                        subject: ClosureOutlivesSubject::Region(fr_minus),\n+                        outlived_free_region: fr,\n+                        blame_span: blame_span_category.1,\n+                        category: blame_span_category.0,\n+                    });\n+                }\n                 return None;\n             }\n         }"}, {"sha": "3b663ef6dad61f44477edd99774b77e53bd99cce", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 65, "deletions": 37, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/79e8c311765df4c35558aa9683f1e2004719175a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79e8c311765df4c35558aa9683f1e2004719175a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=79e8c311765df4c35558aa9683f1e2004719175a", "patch": "@@ -105,44 +105,89 @@ impl UniversalRegionRelations<'tcx> {\n \n     /// Finds an \"upper bound\" for `fr` that is not local. In other\n     /// words, returns the smallest (*) known region `fr1` that (a)\n-    /// outlives `fr` and (b) is not local. This cannot fail, because\n-    /// we will always find `'static` at worst.\n+    /// outlives `fr` and (b) is not local.\n     ///\n-    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n-    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n-    crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+    /// (*) If there are multiple competing choices, we return all of them.\n+    crate fn non_local_upper_bounds(&'a self, fr: &'a RegionVid) -> Vec<&'a RegionVid> {\n         debug!(\"non_local_upper_bound(fr={:?})\", fr);\n-        self.non_local_bound(&self.inverse_outlives, fr)\n+        let res = self.non_local_bounds(&self.inverse_outlives, fr);\n+        assert!(!res.is_empty(), \"can't find an upper bound!?\");\n+        res\n+    }\n+\n+    /// Returns the \"postdominating\" bound of the set of\n+    /// `non_local_upper_bounds` for the given region.\n+    crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+        let upper_bounds = self.non_local_upper_bounds(&fr);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = self\n+            .inverse_outlives\n+            .mutual_immediate_postdominator(upper_bounds);\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom\n+            .and_then(|&post_dom| {\n+                // If the mutual immediate postdom is not local, then\n+                // there is no non-local result we can return.\n+                if !self.universal_regions.is_local_free_region(post_dom) {\n+                    Some(post_dom)\n+                } else {\n+                    None\n+                }\n+            })\n             .unwrap_or(self.universal_regions.fr_static)\n     }\n \n+\n     /// Finds a \"lower bound\" for `fr` that is not local. In other\n     /// words, returns the largest (*) known region `fr1` that (a) is\n-    /// outlived by `fr` and (b) is not local. This cannot fail,\n-    /// because we will always find `'static` at worst.\n+    /// outlived by `fr` and (b) is not local.\n     ///\n     /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n     /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n     crate fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n         debug!(\"non_local_lower_bound(fr={:?})\", fr);\n-        self.non_local_bound(&self.outlives, fr)\n+        let lower_bounds = self.non_local_bounds(&self.outlives, &fr);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = self\n+            .outlives\n+            .mutual_immediate_postdominator(lower_bounds);\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom\n+            .and_then(|&post_dom| {\n+                // If the mutual immediate postdom is not local, then\n+                // there is no non-local result we can return.\n+                if !self.universal_regions.is_local_free_region(post_dom) {\n+                    Some(post_dom)\n+                } else {\n+                    None\n+                }\n+            })\n     }\n \n-    /// Helper for `non_local_upper_bound` and\n-    /// `non_local_lower_bound`. Repeatedly invokes `postdom_parent`\n-    /// until we find something that is not local. Returns `None` if we\n-    /// never do so.\n-    fn non_local_bound(\n+    /// Helper for `non_local_upper_bounds` and `non_local_lower_bounds`.\n+    /// Repeatedly invokes `postdom_parent` until we find something that is not\n+    /// local. Returns `None` if we never do so.\n+    fn non_local_bounds<'a>(\n         &self,\n-        relation: &TransitiveRelation<RegionVid>,\n-        fr0: RegionVid,\n-    ) -> Option<RegionVid> {\n+        relation: &'a TransitiveRelation<RegionVid>,\n+        fr0: &'a RegionVid,\n+    ) -> Vec<&'a RegionVid> {\n         // This method assumes that `fr0` is one of the universally\n         // quantified region variables.\n-        assert!(self.universal_regions.is_universal_region(fr0));\n+        assert!(self.universal_regions.is_universal_region(*fr0));\n \n         let mut external_parents = vec![];\n-        let mut queue = vec![&fr0];\n+        let mut queue = vec![fr0];\n \n         // Keep expanding `fr` into its parents until we reach\n         // non-local regions.\n@@ -157,24 +202,7 @@ impl UniversalRegionRelations<'tcx> {\n \n         debug!(\"non_local_bound: external_parents={:?}\", external_parents);\n \n-        // In case we find more than one, reduce to one for\n-        // convenience.  This is to prevent us from generating more\n-        // complex constraints, but it will cause spurious errors.\n-        let post_dom = relation\n-            .mutual_immediate_postdominator(external_parents)\n-            .cloned();\n-\n-        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n-\n-        post_dom.and_then(|post_dom| {\n-            // If the mutual immediate postdom is not local, then\n-            // there is no non-local result we can return.\n-            if !self.universal_regions.is_local_free_region(post_dom) {\n-                Some(post_dom)\n-            } else {\n-                None\n-            }\n-        })\n+        external_parents\n     }\n \n     /// Returns `true` if fr1 is known to outlive fr2."}, {"sha": "71d5d4053ee252cbb89de224860fef2a146cdfc6", "filename": "src/test/ui/nll/closure-requirements/issue-58127-mutliple-requirements.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/79e8c311765df4c35558aa9683f1e2004719175a/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fissue-58127-mutliple-requirements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79e8c311765df4c35558aa9683f1e2004719175a/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fissue-58127-mutliple-requirements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fissue-58127-mutliple-requirements.rs?ref=79e8c311765df4c35558aa9683f1e2004719175a", "patch": "@@ -0,0 +1,40 @@\n+// revisions: migrate nll\n+//[migrate]compile-flags: -Z borrowck=migrate\n+#![cfg_attr(nll, feature(nll))]\n+\n+// compile-pass\n+\n+// Test that we propagate region relations from closures precisely when there is\n+// more than one non-local lower bound.\n+\n+// In this case the closure has signature\n+// |x: &'4 mut (&'5 (&'1 str, &'2 str), &'3 str)| -> ..\n+// We end up with a `'3: '5` constraint that we can propagate as\n+// `'3: '1`, `'3: '2`, but previously we approximated it as `'3: 'static`.\n+\n+// As an optimization, we primarily propagate bounds for the \"representative\"\n+// of each SCC. As such we have these two similar cases where hopefully one\n+// of them will test the case we want (case2, when this test was added).\n+mod case1 {\n+    fn f(s: &str) {\n+        g(s, |x| h(x));\n+    }\n+\n+    fn g<T, F>(_: T, _: F)\n+    where F: Fn(&mut (&(T, T), T)) {}\n+\n+    fn h<T>(_: &mut (&(T, T), T)) {}\n+}\n+\n+mod case2 {\n+    fn f(s: &str) {\n+        g(s, |x| h(x));\n+    }\n+\n+    fn g<T, F>(_: T, _: F)\n+    where F: Fn(&mut (T, &(T, T))) {}\n+\n+    fn h<T>(_: &mut (T, &(T, T))) {}\n+}\n+\n+fn main() {}"}]}