{"sha": "cb08cb8aefa38d082b3f30629e15ff2eb4e61aec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMDhjYjhhZWZhMzhkMDgyYjNmMzA2MjllMTVmZjJlYjRlNjFhZWM=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-04-22T11:20:08Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-05-02T21:46:26Z"}, "message": "Provide a note if method lookup fails and there are static definitions with the same name.", "tree": {"sha": "918dde117532dd51b84f4d62fc10dcbca2e14823", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/918dde117532dd51b84f4d62fc10dcbca2e14823"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec", "html_url": "https://github.com/rust-lang/rust/commit/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5d6b07370b665df6b54fa20e971e61041a233b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5d6b07370b665df6b54fa20e971e61041a233b0", "html_url": "https://github.com/rust-lang/rust/commit/b5d6b07370b665df6b54fa20e971e61041a233b0"}], "stats": {"total": 235, "additions": 200, "deletions": 35}, "files": [{"sha": "8df94ea14286575e045b39a44809ab4398ca6e02", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=cb08cb8aefa38d082b3f30629e15ff2eb4e61aec", "patch": "@@ -16,7 +16,7 @@ use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use middle::lang_items::LanguageItems;\n use middle::lint::{UnnecessaryQualification, UnusedImports};\n use middle::pat_util::pat_bindings;\n-use util::nodemap::{NodeMap, DefIdSet, FnvHashSet};\n+use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n use syntax::ast::*;\n use syntax::ast;\n@@ -821,7 +821,7 @@ fn Resolver<'a>(session: &'a Session,\n \n         graph_root: graph_root,\n \n-        method_set: RefCell::new(FnvHashSet::new()),\n+        method_map: RefCell::new(FnvHashMap::new()),\n         structs: HashSet::new(),\n \n         unresolved_imports: 0,\n@@ -860,7 +860,7 @@ struct Resolver<'a> {\n \n     graph_root: NameBindings,\n \n-    method_set: RefCell<FnvHashSet<(Name, DefId)>>,\n+    method_map: RefCell<FnvHashMap<(Name, DefId), ast::ExplicitSelf_>>,\n     structs: HashSet<DefId>,\n \n     // The number of imports that are currently unresolved.\n@@ -1371,10 +1371,8 @@ impl<'a> Resolver<'a> {\n                                        ty_m.span);\n                     method_name_bindings.define_value(def, ty_m.span, true);\n \n-                    // Add it to the trait info if not static.\n-                    if ty_m.explicit_self.node != SelfStatic {\n-                        self.method_set.borrow_mut().insert((ident.name, def_id));\n-                    }\n+                    self.method_map.borrow_mut().insert((ident.name, def_id),\n+                                                        ty_m.explicit_self.node);\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, is_public);\n@@ -1660,10 +1658,8 @@ impl<'a> Resolver<'a> {\n                           trait method '{}'\",\n                          token::get_ident(method_name));\n \n-                  // Add it to the trait info if not static.\n-                  if explicit_self != SelfStatic {\n-                      self.method_set.borrow_mut().insert((method_name.name, def_id));\n-                  }\n+                  self.method_map.borrow_mut().insert((method_name.name, def_id), explicit_self);\n+\n                   if is_exported {\n                       self.external_exports.insert(method_def_id);\n                   }\n@@ -4718,10 +4714,16 @@ impl<'a> Resolver<'a> {\n         match containing_module.kind.get() {\n             TraitModuleKind | ImplModuleKind => {\n                 match containing_module.def_id.get() {\n-                    Some(def_id) if self.method_set.borrow().contains(&(ident.name, def_id)) => {\n-                        debug!(\"containing module was a trait or impl \\\n+                    Some(def_id) => {\n+                        match self.method_map.borrow().find(&(ident.name, def_id)) {\n+                            Some(x) if *x == SelfStatic => (),\n+                            None => (),\n+                            _ => {\n+                                debug!(\"containing module was a trait or impl \\\n                                 and name was a method -> not resolved\");\n-                        return None;\n+                                return None;\n+                            }\n+                        }\n                     },\n                     _ => (),\n                 }\n@@ -5110,9 +5112,9 @@ impl<'a> Resolver<'a> {\n             // Look for the current trait.\n             match self.current_trait_refs {\n                 Some(ref trait_def_ids) => {\n-                    let method_set = self.method_set.borrow();\n+                    let method_map = self.method_map.borrow();\n                     for &trait_def_id in trait_def_ids.iter() {\n-                        if method_set.contains(&(name, trait_def_id)) {\n+                        if method_map.contains_key(&(name, trait_def_id)) {\n                             add_trait_info(&mut found_traits, trait_def_id, name);\n                         }\n                     }\n@@ -5126,7 +5128,7 @@ impl<'a> Resolver<'a> {\n             self.populate_module_if_necessary(&search_module);\n \n             {\n-                let method_set = self.method_set.borrow();\n+                let method_map = self.method_map.borrow();\n                 for (_, child_names) in search_module.children.borrow().iter() {\n                     let def = match child_names.def_for_namespace(TypeNS) {\n                         Some(def) => def,\n@@ -5136,7 +5138,7 @@ impl<'a> Resolver<'a> {\n                         DefTrait(trait_def_id) => trait_def_id,\n                         _ => continue,\n                     };\n-                    if method_set.contains(&(name, trait_def_id)) {\n+                    if method_map.contains_key(&(name, trait_def_id)) {\n                         add_trait_info(&mut found_traits, trait_def_id, name);\n                     }\n                 }\n@@ -5152,7 +5154,7 @@ impl<'a> Resolver<'a> {\n                     Some(DefTrait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };\n-                if self.method_set.borrow().contains(&(name, did)) {\n+                if self.method_map.borrow().contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n                     self.used_imports.insert((import.type_id, TypeNS));\n                 }"}, {"sha": "9234270cf7ebc4d2f4e2e9b3ffddfaa925381cd0", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 58, "deletions": 11, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=cb08cb8aefa38d082b3f30629e15ff2eb4e61aec", "patch": "@@ -118,6 +118,12 @@ pub enum AutoderefReceiverFlag {\n     DontAutoderefReceiver,\n }\n \n+#[deriving(Eq)]\n+pub enum StaticMethodsFlag {\n+    ReportStaticMethods,\n+    IgnoreStaticMethods,\n+}\n+\n pub fn lookup<'a>(\n         fcx: &'a FnCtxt<'a>,\n \n@@ -129,7 +135,8 @@ pub fn lookup<'a>(\n         supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n         deref_args: check::DerefArgs,       // Whether we autopointer first.\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n-        autoderef_receiver: AutoderefReceiverFlag)\n+        autoderef_receiver: AutoderefReceiverFlag,\n+        report_statics: StaticMethodsFlag)\n      -> Option<MethodCallee> {\n     let mut lcx = LookupContext {\n         fcx: fcx,\n@@ -143,6 +150,7 @@ pub fn lookup<'a>(\n         deref_args: deref_args,\n         check_traits: check_traits,\n         autoderef_receiver: autoderef_receiver,\n+        report_statics: report_statics,\n     };\n \n     debug!(\"method lookup(self_ty={}, expr={}, self_expr={})\",\n@@ -173,7 +181,8 @@ pub fn lookup_in_trait<'a>(\n         trait_did: DefId,                   // The trait to limit the lookup to.\n         self_ty: ty::t,                     // The type of `a`.\n         supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n-        autoderef_receiver: AutoderefReceiverFlag)\n+        autoderef_receiver: AutoderefReceiverFlag,\n+        report_statics: StaticMethodsFlag)\n      -> Option<MethodCallee> {\n     let mut lcx = LookupContext {\n         fcx: fcx,\n@@ -187,6 +196,7 @@ pub fn lookup_in_trait<'a>(\n         deref_args: check::DoDerefArgs,\n         check_traits: CheckTraitsOnly,\n         autoderef_receiver: autoderef_receiver,\n+        report_statics: report_statics,\n     };\n \n     debug!(\"method lookup_in_trait(self_ty={}, self_expr={})\",\n@@ -197,8 +207,6 @@ pub fn lookup_in_trait<'a>(\n     lcx.search(self_ty)\n }\n \n-\n-\n // Determine the index of a method in the list of all methods belonging\n // to a trait and its supertraits.\n fn get_method_index(tcx: &ty::ctxt,\n@@ -301,6 +309,7 @@ struct LookupContext<'a> {\n     deref_args: check::DerefArgs,\n     check_traits: CheckTraitsFlag,\n     autoderef_receiver: AutoderefReceiverFlag,\n+    report_statics: StaticMethodsFlag,\n }\n \n /**\n@@ -661,7 +670,17 @@ impl<'a> LookupContext<'a> {\n                                  impl_did: DefId,\n                                  impl_methods: &[DefId],\n                                  is_extension: bool) {\n-        if !self.impl_dups.insert(impl_did) {\n+        let did = if self.report_statics == ReportStaticMethods {\n+            // we only want to report each base trait once\n+            match ty::impl_trait_ref(self.tcx(), impl_did) {\n+                Some(trait_ref) => trait_ref.def_id,\n+                None => impl_did\n+            }\n+        } else {\n+            impl_did\n+        };\n+\n+        if !self.impl_dups.insert(did) {\n             return; // already visited\n         }\n \n@@ -1018,6 +1037,25 @@ impl<'a> LookupContext<'a> {\n             return None;\n         }\n \n+        if self.report_statics == ReportStaticMethods {\n+            // lookup should only be called with ReportStaticMethods if a regular lookup failed\n+            assert!(relevant_candidates.iter().all(|c| c.method_ty.explicit_self == SelfStatic));\n+\n+            self.tcx().sess.fileline_note(self.span,\n+                                \"found defined static methods, maybe a `self` is missing?\");\n+\n+            for (idx, candidate) in relevant_candidates.iter().enumerate() {\n+                self.report_candidate(idx, &candidate.origin);\n+            }\n+\n+            // return something so we don't get errors for every mutability\n+            return Some(MethodCallee {\n+                origin: relevant_candidates.get(0).origin,\n+                ty: ty::mk_err(),\n+                substs: substs::empty()\n+            });\n+        }\n+\n         if relevant_candidates.len() > 1 {\n             self.tcx().sess.span_err(\n                 self.span,\n@@ -1305,7 +1343,7 @@ impl<'a> LookupContext<'a> {\n         return match candidate.method_ty.explicit_self {\n             SelfStatic => {\n                 debug!(\"(is relevant?) explicit self is static\");\n-                false\n+                self.report_statics == ReportStaticMethods\n             }\n \n             SelfValue => {\n@@ -1391,11 +1429,20 @@ impl<'a> LookupContext<'a> {\n     fn report_candidate(&self, idx: uint, origin: &MethodOrigin) {\n         match *origin {\n             MethodStatic(impl_did) => {\n-                // If it is an instantiated default method, use the original\n-                // default method for error reporting.\n-                let did = match provided_source(self.tcx(), impl_did) {\n-                    None => impl_did,\n-                    Some(did) => did\n+                let did = if self.report_statics == ReportStaticMethods {\n+                    // If we're reporting statics, we want to report the trait\n+                    // definition if possible, rather than an impl\n+                    match ty::trait_method_of_method(self.tcx(), impl_did) {\n+                        None => {debug!(\"(report candidate) No trait method found\"); impl_did},\n+                        Some(trait_did) => {debug!(\"(report candidate) Found trait ref\"); trait_did}\n+                    }\n+                } else {\n+                    // If it is an instantiated default method, use the original\n+                    // default method for error reporting.\n+                    match provided_source(self.tcx(), impl_did) {\n+                        None => impl_did,\n+                        Some(did) => did\n+                    }\n                 };\n                 self.report_static_candidate(idx, did)\n             }"}, {"sha": "d18e50291fb287027f2d46d375037e4adfc7488f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=cb08cb8aefa38d082b3f30629e15ff2eb4e61aec", "patch": "@@ -97,6 +97,7 @@ use middle::typeck::check::method::{AutoderefReceiver};\n use middle::typeck::check::method::{AutoderefReceiverFlag};\n use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{DontAutoderefReceiver};\n+use middle::typeck::check::method::{IgnoreStaticMethods, ReportStaticMethods};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::check::regionmanip::relate_free_regions;\n use middle::typeck::check::vtable::VtableContext;\n@@ -1360,7 +1361,7 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n         (PreferMutLvalue, Some(trait_did)) => {\n             method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n                                     token::intern(\"deref_mut\"), trait_did,\n-                                    base_ty, [], DontAutoderefReceiver)\n+                                    base_ty, [], DontAutoderefReceiver, IgnoreStaticMethods)\n         }\n         _ => None\n     };\n@@ -1370,7 +1371,7 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n         (None, Some(trait_did)) => {\n             method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n                                     token::intern(\"deref\"), trait_did,\n-                                    base_ty, [], DontAutoderefReceiver)\n+                                    base_ty, [], DontAutoderefReceiver, IgnoreStaticMethods)\n         }\n         (method, _) => method\n     };\n@@ -1956,7 +1957,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                          expr_t, tps.as_slice(),\n                                          DontDerefArgs,\n                                          CheckTraitsAndInherentMethods,\n-                                         AutoderefReceiver) {\n+                                         AutoderefReceiver, IgnoreStaticMethods) {\n             Some(method) => {\n                 let method_ty = method.ty;\n                 let method_call = MethodCall::expr(expr.id);\n@@ -1976,6 +1977,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n                 // Add error type for the result\n                 fcx.write_error(expr.id);\n+\n+                // Check for potential static matches (missing self parameters)\n+                method::lookup(fcx, expr, rcvr,\n+                                    method_name.node.name,\n+                                    expr_t, tps.as_slice(),\n+                                    DontDerefArgs,\n+                                    CheckTraitsAndInherentMethods,\n+                                    DontAutoderefReceiver, ReportStaticMethods);\n+\n                 ty::mk_err()\n             }\n         };\n@@ -2040,7 +2050,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let method = match trait_did {\n             Some(trait_did) => {\n                 method::lookup_in_trait(fcx, op_ex.span, Some(&*args[0]), opname,\n-                                        trait_did, self_t, [], autoderef_receiver)\n+                                        trait_did, self_t, [], autoderef_receiver,\n+                                        IgnoreStaticMethods)\n             }\n             None => None\n         };\n@@ -2348,7 +2359,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                              tps.as_slice(),\n                              DontDerefArgs,\n                              CheckTraitsAndInherentMethods,\n-                             AutoderefReceiver) {\n+                             AutoderefReceiver,\n+                             IgnoreStaticMethods) {\n             Some(_) => {\n                 fcx.type_error_message(\n                     expr.span,"}, {"sha": "5b03e6fc2265dc4b51bc558d20b85b70cfb9ac61", "filename": "src/test/compile-fail/issue-7575.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs?ref=cb08cb8aefa38d082b3f30629e15ff2eb4e61aec", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait CtxtFn {\n+    fn f8(self, uint) -> uint;\n+    fn f9(uint) -> uint; //~ NOTE candidate #\n+}\n+\n+trait OtherTrait {\n+    fn f9(uint) -> uint; //~ NOTE candidate #\n+}\n+\n+trait UnusedTrait { // This should never show up as a candidate\n+    fn f9(uint) -> uint;\n+}\n+\n+impl CtxtFn for uint {\n+    fn f8(self, i: uint) -> uint {\n+        i * 4u\n+    }\n+\n+    fn f9(i: uint) -> uint {\n+        i * 4u\n+    }\n+}\n+\n+impl OtherTrait for uint {\n+    fn f9(i: uint) -> uint {\n+        i * 8u\n+    }\n+}\n+\n+struct MyInt(int);\n+\n+impl MyInt {\n+    fn fff(i: int) -> int { //~ NOTE candidate #1 is `MyInt::fff`\n+        i\n+    }\n+}\n+\n+trait ManyImplTrait {\n+    fn is_str() -> bool { //~ NOTE candidate #1 is\n+        false\n+    }\n+}\n+\n+impl ManyImplTrait for ~str {\n+    fn is_str() -> bool {\n+        true\n+    }\n+}\n+\n+impl ManyImplTrait for uint {}\n+impl ManyImplTrait for int {}\n+impl ManyImplTrait for char {}\n+impl ManyImplTrait for MyInt {}\n+\n+fn no_param_bound(u: uint, m: MyInt) -> uint {\n+    u.f8(42) + u.f9(342) + m.fff(42)\n+            //~^ ERROR type `uint` does not implement any method in scope named `f9`\n+            //~^^ NOTE found defined static methods, maybe a `self` is missing?\n+                        //~^^^ ERROR type `MyInt` does not implement any method in scope named `fff`\n+                        //~^^^^ NOTE found defined static methods, maybe a `self` is missing?\n+}\n+\n+fn param_bound<T: ManyImplTrait>(t: T) -> bool {\n+    t.is_str()\n+    //~^ ERROR type `T` does not implement any method in scope named `is_str`\n+    //~^^ NOTE found defined static methods, maybe a `self` is missing?\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "f31fbc0a12ebb697196c0716925aff18b474c449", "filename": "src/test/run-pass/issue-7575.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/src%2Ftest%2Frun-pass%2Fissue-7575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb08cb8aefa38d082b3f30629e15ff2eb4e61aec/src%2Ftest%2Frun-pass%2Fissue-7575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7575.rs?ref=cb08cb8aefa38d082b3f30629e15ff2eb4e61aec", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    fn new() -> bool { false }\n+}\n+\n+trait Bar {\n+    fn new(&self) -> bool { true }\n+}\n+\n+impl Bar for int {}\n+impl Foo for int {}\n+\n+fn main() {\n+    assert!(1i.new());\n+}\n\\ No newline at end of file"}]}