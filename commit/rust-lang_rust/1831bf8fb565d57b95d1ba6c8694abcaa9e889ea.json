{"sha": "1831bf8fb565d57b95d1ba6c8694abcaa9e889ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MzFiZjhmYjU2NWQ1N2I5NWQxYmE2Yzg2OTRhYmNhYTllODg5ZWE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-05T03:44:26Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-11T08:41:08Z"}, "message": "rustfmt libgraphviz", "tree": {"sha": "d96bdfd656361ae266e8e54e46ef34e2c8201f8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d96bdfd656361ae266e8e54e46ef34e2c8201f8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1831bf8fb565d57b95d1ba6c8694abcaa9e889ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1831bf8fb565d57b95d1ba6c8694abcaa9e889ea", "html_url": "https://github.com/rust-lang/rust/commit/1831bf8fb565d57b95d1ba6c8694abcaa9e889ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1831bf8fb565d57b95d1ba6c8694abcaa9e889ea/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01024c9f61e7e3cea6f898e781eb76556b379516", "url": "https://api.github.com/repos/rust-lang/rust/commits/01024c9f61e7e3cea6f898e781eb76556b379516", "html_url": "https://github.com/rust-lang/rust/commit/01024c9f61e7e3cea6f898e781eb76556b379516"}], "stats": {"total": 174, "additions": 100, "deletions": 74}, "files": [{"sha": "76c79c1a1b0adda26f1022f5b72b5a2301d23e47", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 100, "deletions": 74, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/1831bf8fb565d57b95d1ba6c8694abcaa9e889ea/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1831bf8fb565d57b95d1ba6c8694abcaa9e889ea/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=1831bf8fb565d57b95d1ba6c8694abcaa9e889ea", "patch": "@@ -413,8 +413,9 @@ impl<'a> Id<'a> {\n         {\n             let mut chars = name.chars();\n             match chars.next() {\n-                Some(c) if is_letter_or_underscore(c) => { ; },\n-                _ => return Err(())\n+                Some(c) if is_letter_or_underscore(c) => { ;\n+                }\n+                _ => return Err(()),\n             }\n             if !chars.all(is_constituent) {\n                 return Err(())\n@@ -505,24 +506,28 @@ pub fn escape_html(s: &str) -> String {\n }\n \n impl<'a> LabelText<'a> {\n-    pub fn label<S:IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n+    pub fn label<S: IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n         LabelStr(s.into_cow())\n     }\n \n-    pub fn escaped<S:IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n+    pub fn escaped<S: IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n         EscStr(s.into_cow())\n     }\n \n-    pub fn html<S:IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n+    pub fn html<S: IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n         HtmlStr(s.into_cow())\n     }\n \n-    fn escape_char<F>(c: char, mut f: F) where F: FnMut(char) {\n+    fn escape_char<F>(c: char, mut f: F)\n+        where F: FnMut(char)\n+    {\n         match c {\n             // not escaping \\\\, since Graphviz escString needs to\n             // interpret backslashes; see EscStr above.\n             '\\\\' => f(c),\n-            _ => for c in c.escape_default() { f(c) }\n+            _ => for c in c.escape_default() {\n+                f(c)\n+            },\n         }\n     }\n     fn escape_str(s: &str) -> String {\n@@ -613,29 +618,42 @@ pub enum RenderOption {\n }\n \n /// Returns vec holding all the default render options.\n-pub fn default_options() -> Vec<RenderOption> { vec![] }\n+pub fn default_options() -> Vec<RenderOption> {\n+    vec![]\n+}\n \n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n /// (Simple wrapper around `render_opts` that passes a default set of options.)\n-pub fn render<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Write>(\n-              g: &'a G,\n-              w: &mut W) -> io::Result<()> {\n+pub fn render<'a,\n+              N: Clone + 'a,\n+              E: Clone + 'a,\n+              G: Labeller<'a, N, E> + GraphWalk<'a, N, E>,\n+              W: Write>\n+    (g: &'a G,\n+     w: &mut W)\n+     -> io::Result<()> {\n     render_opts(g, w, &[])\n }\n \n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n /// (Main entry point for the library.)\n-pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Write>(\n-              g: &'a G,\n-              w: &mut W,\n-              options: &[RenderOption]) -> io::Result<()>\n-{\n-    fn writeln<W:Write>(w: &mut W, arg: &[&str]) -> io::Result<()> {\n-        for &s in arg { try!(w.write_all(s.as_bytes())); }\n+pub fn render_opts<'a,\n+                   N: Clone + 'a,\n+                   E: Clone + 'a,\n+                   G: Labeller<'a, N, E> + GraphWalk<'a, N, E>,\n+                   W: Write>\n+    (g: &'a G,\n+     w: &mut W,\n+     options: &[RenderOption])\n+     -> io::Result<()> {\n+    fn writeln<W: Write>(w: &mut W, arg: &[&str]) -> io::Result<()> {\n+        for &s in arg {\n+            try!(w.write_all(s.as_bytes()));\n+        }\n         write!(w, \"\\n\")\n     }\n \n-    fn indent<W:Write>(w: &mut W) -> io::Result<()> {\n+    fn indent<W: Write>(w: &mut W) -> io::Result<()> {\n         w.write_all(b\"    \")\n     }\n \n@@ -748,7 +766,7 @@ mod tests {\n     // A simple wrapper around LabelledGraph that forces the labels to\n     // be emitted as EscStr.\n     struct LabelledGraphWithEscStrs {\n-        graph: LabelledGraph\n+        graph: LabelledGraph,\n     }\n \n     enum NodeLabels<L> {\n@@ -762,13 +780,10 @@ mod tests {\n     impl NodeLabels<&'static str> {\n         fn to_opt_strs(self) -> Vec<Option<&'static str>> {\n             match self {\n-                UnlabelledNodes(len)\n-                    => vec![None; len],\n-                AllNodesLabelled(lbls)\n-                    => lbls.into_iter().map(\n+                UnlabelledNodes(len) => vec![None; len],\n+                AllNodesLabelled(lbls) => lbls.into_iter().map(\n                         |l|Some(l)).collect(),\n-                SomeNodesLabelled(lbls)\n-                    => lbls.into_iter().collect(),\n+                SomeNodesLabelled(lbls) => lbls.into_iter().collect(),\n             }\n         }\n \n@@ -785,7 +800,8 @@ mod tests {\n         fn new(name: &'static str,\n                node_labels: Trivial,\n                edges: Vec<Edge>,\n-               node_styles: Option<Vec<Style>>) -> LabelledGraph {\n+               node_styles: Option<Vec<Style>>)\n+               -> LabelledGraph {\n             let count = node_labels.len();\n             LabelledGraph {\n                 name: name,\n@@ -794,21 +810,17 @@ mod tests {\n                 node_styles: match node_styles {\n                     Some(nodes) => nodes,\n                     None => vec![Style::None; count],\n-                }\n+                },\n             }\n         }\n     }\n \n     impl LabelledGraphWithEscStrs {\n         fn new(name: &'static str,\n                node_labels: Trivial,\n-               edges: Vec<Edge>) -> LabelledGraphWithEscStrs {\n-            LabelledGraphWithEscStrs {\n-                graph: LabelledGraph::new(name,\n-                                          node_labels,\n-                                          edges,\n-                                          None)\n-            }\n+               edges: Vec<Edge>)\n+               -> LabelledGraphWithEscStrs {\n+            LabelledGraphWithEscStrs { graph: LabelledGraph::new(name, node_labels, edges, None) }\n         }\n     }\n \n@@ -826,61 +838,65 @@ mod tests {\n         fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n             match self.node_labels[*n] {\n                 Some(ref l) => LabelStr(l.into_cow()),\n-                None        => LabelStr(id_name(n).name()),\n+                None => LabelStr(id_name(n).name()),\n             }\n         }\n-        fn edge_label(&'a self, e: & &'a Edge) -> LabelText<'a> {\n+        fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {\n             LabelStr(e.label.into_cow())\n         }\n         fn node_style(&'a self, n: &Node) -> Style {\n             self.node_styles[*n]\n         }\n-        fn edge_style(&'a self, e: & &'a Edge) -> Style {\n+        fn edge_style(&'a self, e: &&'a Edge) -> Style {\n             e.style\n         }\n     }\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraphWithEscStrs {\n-        fn graph_id(&'a self) -> Id<'a> { self.graph.graph_id() }\n-        fn node_id(&'a self, n: &Node) -> Id<'a> { self.graph.node_id(n) }\n+        fn graph_id(&'a self) -> Id<'a> {\n+            self.graph.graph_id()\n+        }\n+        fn node_id(&'a self, n: &Node) -> Id<'a> {\n+            self.graph.node_id(n)\n+        }\n         fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n             match self.graph.node_label(n) {\n                 LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n             }\n         }\n-        fn edge_label(&'a self, e: & &'a Edge) -> LabelText<'a> {\n+        fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {\n             match self.graph.edge_label(e) {\n                 LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n             }\n         }\n     }\n \n     impl<'a> GraphWalk<'a, Node, &'a Edge> for LabelledGraph {\n-        fn nodes(&'a self) -> Nodes<'a,Node> {\n+        fn nodes(&'a self) -> Nodes<'a, Node> {\n             (0..self.node_labels.len()).collect()\n         }\n-        fn edges(&'a self) -> Edges<'a,&'a Edge> {\n+        fn edges(&'a self) -> Edges<'a, &'a Edge> {\n             self.edges.iter().collect()\n         }\n-        fn source(&'a self, edge: & &'a Edge) -> Node {\n+        fn source(&'a self, edge: &&'a Edge) -> Node {\n             edge.from\n         }\n-        fn target(&'a self, edge: & &'a Edge) -> Node {\n+        fn target(&'a self, edge: &&'a Edge) -> Node {\n             edge.to\n         }\n     }\n \n     impl<'a> GraphWalk<'a, Node, &'a Edge> for LabelledGraphWithEscStrs {\n-        fn nodes(&'a self) -> Nodes<'a,Node> {\n+        fn nodes(&'a self) -> Nodes<'a, Node> {\n             self.graph.nodes()\n         }\n-        fn edges(&'a self) -> Edges<'a,&'a Edge> {\n+        fn edges(&'a self) -> Edges<'a, &'a Edge> {\n             self.graph.edges()\n         }\n-        fn source(&'a self, edge: & &'a Edge) -> Node {\n+        fn source(&'a self, edge: &&'a Edge) -> Node {\n             edge.from\n         }\n-        fn target(&'a self, edge: & &'a Edge) -> Node {\n+        fn target(&'a self, edge: &&'a Edge) -> Node {\n             edge.to\n         }\n     }\n@@ -899,7 +915,7 @@ mod tests {\n \n     #[test]\n     fn empty_graph() {\n-        let labels : Trivial = UnlabelledNodes(0);\n+        let labels: Trivial = UnlabelledNodes(0);\n         let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec![], None));\n         assert_eq!(r.unwrap(),\n r#\"digraph empty_graph {\n@@ -909,7 +925,7 @@ r#\"digraph empty_graph {\n \n     #[test]\n     fn single_node() {\n-        let labels : Trivial = UnlabelledNodes(1);\n+        let labels: Trivial = UnlabelledNodes(1);\n         let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], None));\n         assert_eq!(r.unwrap(),\n r#\"digraph single_node {\n@@ -920,7 +936,7 @@ r#\"digraph single_node {\n \n     #[test]\n     fn single_node_with_style() {\n-        let labels : Trivial = UnlabelledNodes(1);\n+        let labels: Trivial = UnlabelledNodes(1);\n         let styles = Some(vec![Style::Dashed]);\n         let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], styles));\n         assert_eq!(r.unwrap(),\n@@ -932,9 +948,11 @@ r#\"digraph single_node {\n \n     #[test]\n     fn single_edge() {\n-        let labels : Trivial = UnlabelledNodes(2);\n-        let result = test_input(LabelledGraph::new(\"single_edge\", labels,\n-                                                   vec![edge(0, 1, \"E\", Style::None)], None));\n+        let labels: Trivial = UnlabelledNodes(2);\n+        let result = test_input(LabelledGraph::new(\"single_edge\",\n+                                                   labels,\n+                                                   vec![edge(0, 1, \"E\", Style::None)],\n+                                                   None));\n         assert_eq!(result.unwrap(),\n r#\"digraph single_edge {\n     N0[label=\"N0\"];\n@@ -946,9 +964,11 @@ r#\"digraph single_edge {\n \n     #[test]\n     fn single_edge_with_style() {\n-        let labels : Trivial = UnlabelledNodes(2);\n-        let result = test_input(LabelledGraph::new(\"single_edge\", labels,\n-                                                   vec![edge(0, 1, \"E\", Style::Bold)], None));\n+        let labels: Trivial = UnlabelledNodes(2);\n+        let result = test_input(LabelledGraph::new(\"single_edge\",\n+                                                   labels,\n+                                                   vec![edge(0, 1, \"E\", Style::Bold)],\n+                                                   None));\n         assert_eq!(result.unwrap(),\n r#\"digraph single_edge {\n     N0[label=\"N0\"];\n@@ -960,10 +980,12 @@ r#\"digraph single_edge {\n \n     #[test]\n     fn test_some_labelled() {\n-        let labels : Trivial = SomeNodesLabelled(vec![Some(\"A\"), None]);\n+        let labels: Trivial = SomeNodesLabelled(vec![Some(\"A\"), None]);\n         let styles = Some(vec![Style::None, Style::Dotted]);\n-        let result = test_input(LabelledGraph::new(\"test_some_labelled\", labels,\n-                                                   vec![edge(0, 1, \"A-1\", Style::None)], styles));\n+        let result = test_input(LabelledGraph::new(\"test_some_labelled\",\n+                                                   labels,\n+                                                   vec![edge(0, 1, \"A-1\", Style::None)],\n+                                                   styles));\n         assert_eq!(result.unwrap(),\n r#\"digraph test_some_labelled {\n     N0[label=\"A\"];\n@@ -975,9 +997,11 @@ r#\"digraph test_some_labelled {\n \n     #[test]\n     fn single_cyclic_node() {\n-        let labels : Trivial = UnlabelledNodes(1);\n-        let r = test_input(LabelledGraph::new(\"single_cyclic_node\", labels,\n-                                              vec![edge(0, 0, \"E\", Style::None)], None));\n+        let labels: Trivial = UnlabelledNodes(1);\n+        let r = test_input(LabelledGraph::new(\"single_cyclic_node\",\n+                                              labels,\n+                                              vec![edge(0, 0, \"E\", Style::None)],\n+                                              None));\n         assert_eq!(r.unwrap(),\n r#\"digraph single_cyclic_node {\n     N0[label=\"N0\"];\n@@ -989,11 +1013,11 @@ r#\"digraph single_cyclic_node {\n     #[test]\n     fn hasse_diagram() {\n         let labels = AllNodesLabelled(vec!(\"{x,y}\", \"{x}\", \"{y}\", \"{}\"));\n-        let r = test_input(LabelledGraph::new(\n-            \"hasse_diagram\", labels,\n-            vec![edge(0, 1, \"\", Style::None), edge(0, 2, \"\", Style::None),\n+        let r = test_input(LabelledGraph::new(\"hasse_diagram\",\n+                                              labels,\n+                                              vec![edge(0, 1, \"\", Style::None), edge(0, 2, \"\", Style::None),\n                  edge(1, 3, \"\", Style::None), edge(2, 3, \"\", Style::None)],\n-            None));\n+                                              None));\n         assert_eq!(r.unwrap(),\n r#\"digraph hasse_diagram {\n     N0[label=\"{x,y}\"];\n@@ -1024,9 +1048,9 @@ r#\"digraph hasse_diagram {\n \n         let mut writer = Vec::new();\n \n-        let g = LabelledGraphWithEscStrs::new(\n-            \"syntax_tree\", labels,\n-            vec![edge(0, 1, \"then\", Style::None), edge(0, 2, \"else\", Style::None),\n+        let g = LabelledGraphWithEscStrs::new(\"syntax_tree\",\n+                                              labels,\n+                                              vec![edge(0, 1, \"then\", Style::None), edge(0, 2, \"else\", Style::None),\n                  edge(1, 3, \";\", Style::None),    edge(2, 3, \";\", Style::None)]);\n \n         render(&g, &mut writer).unwrap();\n@@ -1051,8 +1075,9 @@ r#\"digraph syntax_tree {\n     fn simple_id_construction() {\n         let id1 = Id::new(\"hello\");\n         match id1 {\n-            Ok(_) => {;},\n-            Err(..) => panic!(\"'hello' is not a valid value for id anymore\")\n+            Ok(_) => {;\n+            }\n+            Err(..) => panic!(\"'hello' is not a valid value for id anymore\"),\n         }\n     }\n \n@@ -1061,7 +1086,8 @@ r#\"digraph syntax_tree {\n         let id2 = Id::new(\"Weird { struct : ure } !!!\");\n         match id2 {\n             Ok(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n-            Err(..) => {;}\n+            Err(..) => {;\n+            }\n         }\n     }\n }"}]}