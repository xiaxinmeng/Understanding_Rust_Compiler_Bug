{"sha": "0e6455e2b8ee707c0683c67ba224b7682aff4e85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNjQ1NWUyYjhlZTcwN2MwNjgzYzY3YmEyMjRiNzY4MmFmZjRlODU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-20T02:21:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-20T02:21:39Z"}, "message": "auto merge of #10801 : musitdev/rust/jsondoc2, r=cmr\n\nI update the example of json use to the last update of the json.rs code. I delete the old branch.\r\nFrom my last request, I remove the example3 because it doesn't compile. I don't understand why and I don't have the time now to investigate.", "tree": {"sha": "82107346401eaed22f634facd27ac1d34b82273d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82107346401eaed22f634facd27ac1d34b82273d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e6455e2b8ee707c0683c67ba224b7682aff4e85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e6455e2b8ee707c0683c67ba224b7682aff4e85", "html_url": "https://github.com/rust-lang/rust/commit/0e6455e2b8ee707c0683c67ba224b7682aff4e85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e6455e2b8ee707c0683c67ba224b7682aff4e85/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c33df0dbb22ce528e62b8b118880a189307963a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c33df0dbb22ce528e62b8b118880a189307963a", "html_url": "https://github.com/rust-lang/rust/commit/7c33df0dbb22ce528e62b8b118880a189307963a"}, {"sha": "aeb541674cb97fdd68eacfda7309a06b39db7a83", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb541674cb97fdd68eacfda7309a06b39db7a83", "html_url": "https://github.com/rust-lang/rust/commit/aeb541674cb97fdd68eacfda7309a06b39db7a83"}], "stats": {"total": 223, "additions": 222, "deletions": 1}, "files": [{"sha": "76dc1d31c49b8153461f9c646b96c70301dde488", "filename": "src/libextra/json.rs", "status": "modified", "additions": 222, "deletions": 1, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/0e6455e2b8ee707c0683c67ba224b7682aff4e85/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6455e2b8ee707c0683c67ba224b7682aff4e85/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=0e6455e2b8ee707c0683c67ba224b7682aff4e85", "patch": "@@ -14,7 +14,211 @@\n #[forbid(non_camel_case_types)];\n #[allow(missing_doc)];\n \n-//! json parsing and serialization\n+/*!\n+JSON parsing and serialization\n+\n+# What is JSON?\n+\n+JSON (JavaScript Object Notation) is a way to write data in Javascript.\n+Like XML it allows one to encode structured data in a text format that can be read by humans easily.\n+Its native compatibility with JavaScript and its simple syntax make it used widely.\n+\n+Json data are encoded in a form of \"key\":\"value\".\n+Data types that can be encoded are JavaScript types :\n+boolean (`true` or `false`), number (`f64`), string, array, object, null.\n+An object is a series of string keys mapping to values, in `\"key\": value` format.\n+Arrays are enclosed in square brackets ([ ... ]) and objects in curly brackets ({ ... }).\n+A simple JSON document encoding a person, his/her age, address and phone numbers could look like:\n+\n+```\n+{\n+    \"FirstName\": \"John\",\n+    \"LastName\": \"Doe\",\n+    \"Age\": 43,\n+    \"Address\": {\n+        \"Street\": \"Downing Street 10\",\n+        \"City\": \"London\",\n+        \"Country\": \"Great Britain\"\n+    },\n+    \"PhoneNumbers\": [\n+        \"+44 1234567\",\n+        \"+44 2345678\"\n+    ]\n+}\n+```\n+\n+# Rust Type-based Encoding and Decoding\n+\n+Rust provides a mechanism for low boilerplate encoding & decoding\n+of values to and from JSON via the serialization API.\n+To be able to encode a piece of data, it must implement the `extra::serialize::Encodable` trait.\n+To be able to decode a piece of data, it must implement the `extra::serialize::Decodable` trait.\n+The Rust compiler provides an annotation to automatically generate\n+the code for these traits: `#[deriving(Decodable, Encodable)]`\n+\n+To encode using Encodable :\n+\n+```rust\n+use extra::json;\n+use std::io;\n+use extra::serialize::Encodable;\n+\n+ #[deriving(Encodable)]\n+ pub struct TestStruct   {\n+    data_str: ~str,\n+ }\n+\n+fn main() {\n+    let to_encode_object = TestStruct{data_str:~\"example of string to encode\"};\n+    let mut m = io::MemWriter::new();\n+    {\n+        let mut encoder = json::Encoder::new(&mut m as &mut std::io::Writer);\n+        to_encode_object.encode(&mut encoder);\n+    }\n+}\n+```\n+\n+Two wrapper functions are provided to encode a Encodable object\n+into a string (~str) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n+\n+```rust\n+use extra::json;\n+let to_encode_object = ~\"example of string to encode\";\n+let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n+```\n+\n+JSON API provide an enum `json::Json` and a trait `ToJson` to encode object.\n+The trait `ToJson` encode object into a container `json::Json` and the API provide writer\n+to encode them into a stream or a string ...\n+\n+When using `ToJson` the `Encodable` trait implementation is not mandatory.\n+\n+A basic `ToJson` example using a TreeMap of attribute name / attribute value:\n+\n+\n+```rust\n+use extra::json;\n+use extra::json::ToJson;\n+use extra::treemap::TreeMap;\n+\n+pub struct MyStruct  {\n+    attr1: u8,\n+    attr2: ~str,\n+}\n+\n+impl ToJson for MyStruct {\n+    fn to_json( &self ) -> json::Json {\n+        let mut d = ~TreeMap::new();\n+        d.insert(~\"attr1\", self.attr1.to_json());\n+        d.insert(~\"attr2\", self.attr2.to_json());\n+        json::Object(d)\n+    }\n+}\n+\n+fn main() {\n+    let test2: MyStruct = MyStruct {attr1: 1, attr2:~\"test\"};\n+    let tjson: json::Json = test2.to_json();\n+    let json_str: ~str = tjson.to_str();\n+}\n+```\n+\n+To decode a json string using `Decodable` trait :\n+\n+```rust\n+use extra::serialize::Decodable;\n+\n+#[deriving(Decodable)]\n+pub struct MyStruct  {\n+     attr1: u8,\n+     attr2: ~str,\n+}\n+\n+fn main() {\n+    let json_str_to_decode: ~str =\n+            ~\"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\";\n+    let json_object = extra::json::from_str(json_str_to_decode);\n+    let mut decoder = extra::json::Decoder::new(json_object.unwrap());\n+    let decoded_object: MyStruct = Decodable::decode(&mut decoder); // create the final object\n+}\n+```\n+\n+# Examples of use\n+\n+## Using Autoserialization\n+\n+Create a struct called TestStruct1 and serialize and deserialize it to and from JSON\n+using the serialization API, using the derived serialization code.\n+\n+```rust\n+use extra::json;\n+use extra::serialize::{Encodable, Decodable};\n+\n+ #[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n+ pub struct TestStruct1  {\n+    data_int: u8,\n+    data_str: ~str,\n+    data_vector: ~[u8],\n+ }\n+\n+// To serialize use the `json::str_encode` to encode an object in a string.\n+// It calls the generated `Encodable` impl.\n+fn main() {\n+    let to_encode_object = TestStruct1\n+         {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n+    let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n+\n+    // To unserialize use the `extra::json::from_str` and `extra::json::Decoder`\n+\n+    let json_object = extra::json::from_str(encoded_str);\n+    let mut decoder = json::Decoder::new(json_object.unwrap());\n+    let decoded1: TestStruct1 = Decodable::decode(&mut decoder); // create the final object\n+}\n+```\n+\n+## Using `ToJson`\n+\n+This example use the ToJson impl to unserialize the json string.\n+Example of `ToJson` trait implementation for TestStruct1.\n+\n+```rust\n+use extra::json;\n+use extra::json::ToJson;\n+use extra::serialize::{Encodable, Decodable};\n+use extra::treemap::TreeMap;\n+\n+#[deriving(Decodable, Encodable)] // generate Decodable, Encodable impl.\n+pub struct TestStruct1  {\n+    data_int: u8,\n+    data_str: ~str,\n+    data_vector: ~[u8],\n+}\n+\n+impl ToJson for TestStruct1 {\n+    fn to_json( &self ) -> json::Json {\n+        let mut d = ~TreeMap::new();\n+        d.insert(~\"data_int\", self.data_int.to_json());\n+        d.insert(~\"data_str\", self.data_str.to_json());\n+        d.insert(~\"data_vector\", self.data_vector.to_json());\n+        json::Object(d)\n+    }\n+}\n+\n+fn main() {\n+    // Seralization using our impl of to_json\n+\n+    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n+    let tjson: json::Json = test2.to_json();\n+    let json_str: ~str = tjson.to_str();\n+\n+    // Unserialize like before.\n+\n+    let mut decoder = json::Decoder::new(json::from_str(json_str).unwrap());\n+    // create the final object\n+    let decoded2: TestStruct1 = Decodable::decode(&mut decoder);\n+}\n+```\n+\n+*/\n \n use std::char;\n use std::cast::transmute;\n@@ -93,6 +297,23 @@ impl<'a> Encoder<'a> {\n     pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n         Encoder { wr: wr }\n     }\n+\n+    /// Encode the specified struct into a json [u8]\n+    pub fn buffer_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~[u8]  {\n+       //Serialize the object in a string using a writer\n+        let mut m = MemWriter::new();\n+        {\n+            let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n+            to_encode_object.encode(&mut encoder);\n+        }\n+        m.unwrap()\n+    }\n+\n+    /// Encode the specified struct into a json str\n+    pub fn str_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~str  {\n+        let buff:~[u8] = Encoder::buffer_encode(to_encode_object);\n+        str::from_utf8_owned(buff)\n+    }\n }\n \n impl<'a> serialize::Encoder for Encoder<'a> {"}]}