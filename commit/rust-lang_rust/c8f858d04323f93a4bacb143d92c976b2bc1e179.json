{"sha": "c8f858d04323f93a4bacb143d92c976b2bc1e179", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4Zjg1OGQwNDMyM2Y5M2E0YmFjYjE0M2Q5MmM5NzZiMmJjMWUxNzk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-17T16:11:43Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-17T16:11:43Z"}, "message": "Make shift an implementation detail of mbe", "tree": {"sha": "ebef32480be69fe1fad58678f8ad9ac97669453a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebef32480be69fe1fad58678f8ad9ac97669453a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8f858d04323f93a4bacb143d92c976b2bc1e179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8f858d04323f93a4bacb143d92c976b2bc1e179", "html_url": "https://github.com/rust-lang/rust/commit/c8f858d04323f93a4bacb143d92c976b2bc1e179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8f858d04323f93a4bacb143d92c976b2bc1e179/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64dac40a8665c851e48c50e6f778a51aeac2838e", "url": "https://api.github.com/repos/rust-lang/rust/commits/64dac40a8665c851e48c50e6f778a51aeac2838e", "html_url": "https://github.com/rust-lang/rust/commit/64dac40a8665c851e48c50e6f778a51aeac2838e"}], "stats": {"total": 131, "additions": 84, "deletions": 47}, "files": [{"sha": "9de7c1ea83751d6df26695dd1e863dc6da26ec5c", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8f858d04323f93a4bacb143d92c976b2bc1e179/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f858d04323f93a4bacb143d92c976b2bc1e179/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=c8f858d04323f93a4bacb143d92c976b2bc1e179", "patch": "@@ -32,10 +32,17 @@ impl TokenExpander {\n         }\n     }\n \n-    pub fn shift(&self) -> u32 {\n+    pub fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n         match self {\n-            TokenExpander::MacroRules(it) => it.shift(),\n-            TokenExpander::Builtin(_) => 0,\n+            TokenExpander::MacroRules(it) => it.map_id_down(id),\n+            TokenExpander::Builtin(..) => id,\n+        }\n+    }\n+\n+    pub fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, mbe::Origin) {\n+        match self {\n+            TokenExpander::MacroRules(it) => it.map_id_up(id),\n+            TokenExpander::Builtin(..) => (id, mbe::Origin::Def),\n         }\n     }\n }"}, {"sha": "5927a03ba3247b28161ac7017b458b1606348286", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8f858d04323f93a4bacb143d92c976b2bc1e179/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f858d04323f93a4bacb143d92c976b2bc1e179/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=c8f858d04323f93a4bacb143d92c976b2bc1e179", "patch": "@@ -161,7 +161,7 @@ impl ExpansionInfo {\n     pub fn translate_offset(&self, offset: TextUnit) -> Option<TextUnit> {\n         let offset = offset.checked_sub(self.arg_start.1)?;\n         let token_id = self.macro_arg.1.token_by_offset(offset)?;\n-        let token_id = tt::TokenId(token_id.0 + self.macro_def.0.shift());\n+        let token_id = self.macro_def.0.map_id_down(token_id);\n \n         let (r, _) = self.exp_map.ranges.iter().find(|(_, tid)| *tid == token_id)?;\n         Some(r.start())\n@@ -170,11 +170,11 @@ impl ExpansionInfo {\n     pub fn find_range(&self, from: TextRange) -> Option<(HirFileId, TextRange)> {\n         let token_id = look_in_rev_map(&self.exp_map, from)?;\n \n-        let shift = self.macro_def.0.shift();\n-        let (token_map, (file_id, start_offset), token_id) = if token_id.0 >= shift {\n-            (&self.macro_arg.1, self.arg_start, tt::TokenId(token_id.0 - shift).into())\n-        } else {\n-            (&self.macro_def.1, self.def_start, token_id)\n+        let (token_id, origin) = self.macro_def.0.map_id_up(token_id);\n+\n+        let (token_map, (file_id, start_offset)) = match origin {\n+            mbe::Origin::Call => (&self.macro_arg.1, self.arg_start),\n+            mbe::Origin::Def => (&self.macro_def.1, self.def_start),\n         };\n \n         let range = token_map.relative_range_of(token_id)?;"}, {"sha": "58ca95368d9957a12c10792867efcec8afa8f656", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 68, "deletions": 38, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/c8f858d04323f93a4bacb143d92c976b2bc1e179/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8f858d04323f93a4bacb143d92c976b2bc1e179/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=c8f858d04323f93a4bacb143d92c976b2bc1e179", "patch": "@@ -40,49 +40,75 @@ pub use crate::syntax_bridge::{\n /// and `$()*` have special meaning (see `Var` and `Repeat` data structures)\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct MacroRules {\n-    pub(crate) rules: Vec<Rule>,\n+    rules: Vec<Rule>,\n     /// Highest id of the token we have in TokenMap\n-    pub(crate) shift: u32,\n+    shift: Shift,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) struct Rule {\n-    pub(crate) lhs: tt::Subtree,\n-    pub(crate) rhs: tt::Subtree,\n+struct Rule {\n+    lhs: tt::Subtree,\n+    rhs: tt::Subtree,\n }\n \n-// Find the max token id inside a subtree\n-fn max_id(subtree: &tt::Subtree) -> Option<u32> {\n-    subtree\n-        .token_trees\n-        .iter()\n-        .filter_map(|tt| match tt {\n-            tt::TokenTree::Subtree(subtree) => max_id(subtree),\n-            tt::TokenTree::Leaf(tt::Leaf::Ident(ident))\n-                if ident.id != tt::TokenId::unspecified() =>\n-            {\n-                Some(ident.id.0)\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+struct Shift(u32);\n+\n+impl Shift {\n+    fn new(tt: &tt::Subtree) -> Shift {\n+        // Note that TokenId is started from zero,\n+        // We have to add 1 to prevent duplication.\n+        let value = max_id(tt).map_or(0, |it| it + 1);\n+        return Shift(value);\n+\n+        // Find the max token id inside a subtree\n+        fn max_id(subtree: &tt::Subtree) -> Option<u32> {\n+            subtree\n+                .token_trees\n+                .iter()\n+                .filter_map(|tt| match tt {\n+                    tt::TokenTree::Subtree(subtree) => max_id(subtree),\n+                    tt::TokenTree::Leaf(tt::Leaf::Ident(ident))\n+                        if ident.id != tt::TokenId::unspecified() =>\n+                    {\n+                        Some(ident.id.0)\n+                    }\n+                    _ => None,\n+                })\n+                .max()\n+        }\n+    }\n+\n+    /// Shift given TokenTree token id\n+    fn shift_all(self, tt: &mut tt::Subtree) {\n+        for t in tt.token_trees.iter_mut() {\n+            match t {\n+                tt::TokenTree::Leaf(leaf) => match leaf {\n+                    tt::Leaf::Ident(ident) => ident.id = self.shift(ident.id),\n+                    _ => (),\n+                },\n+                tt::TokenTree::Subtree(tt) => self.shift_all(tt),\n             }\n-            _ => None,\n-        })\n-        .max()\n-}\n+        }\n+    }\n \n-/// Shift given TokenTree token id\n-fn shift_subtree(tt: &mut tt::Subtree, shift: u32) {\n-    for t in tt.token_trees.iter_mut() {\n-        match t {\n-            tt::TokenTree::Leaf(leaf) => match leaf {\n-                tt::Leaf::Ident(ident) if ident.id != tt::TokenId::unspecified() => {\n-                    ident.id.0 += shift;\n-                }\n-                _ => (),\n-            },\n-            tt::TokenTree::Subtree(tt) => shift_subtree(tt, shift),\n+    fn shift(self, id: tt::TokenId) -> tt::TokenId {\n+        if id == tt::TokenId::unspecified() {\n+            return id;\n         }\n+        tt::TokenId(id.0 + self.0)\n+    }\n+\n+    fn unshift(self, id: tt::TokenId) -> Option<tt::TokenId> {\n+        id.0.checked_sub(self.0).map(tt::TokenId)\n     }\n }\n \n+pub enum Origin {\n+    Def,\n+    Call,\n+}\n+\n impl MacroRules {\n     pub fn parse(tt: &tt::Subtree) -> Result<MacroRules, ParseError> {\n         // Note: this parsing can be implemented using mbe machinery itself, by\n@@ -105,21 +131,25 @@ impl MacroRules {\n             validate(&rule.lhs)?;\n         }\n \n-        // Note that TokenId is started from zero,\n-        // We have to add 1 to prevent duplication.\n-        let shift = max_id(tt).map_or(0, |it| it + 1);\n-        Ok(MacroRules { rules, shift })\n+        Ok(MacroRules { rules, shift: Shift::new(tt) })\n     }\n \n     pub fn expand(&self, tt: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n         // apply shift\n         let mut tt = tt.clone();\n-        shift_subtree(&mut tt, self.shift);\n+        self.shift.shift_all(&mut tt);\n         mbe_expander::expand(self, &tt)\n     }\n \n-    pub fn shift(&self) -> u32 {\n-        self.shift\n+    pub fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n+        self.shift.shift(id)\n+    }\n+\n+    pub fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, Origin) {\n+        match self.shift.unshift(id) {\n+            Some(id) => (id, Origin::Call),\n+            None => (id, Origin::Def),\n+        }\n     }\n }\n "}]}