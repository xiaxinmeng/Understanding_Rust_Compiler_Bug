{"sha": "0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmOGEyOTY0NzVkOGJjMjdkZmE0OGVjMTA1M2NlYzhmYTJmNzM2NzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-28T02:50:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-28T02:50:51Z"}, "message": "Auto merge of #39353 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 21 pull requests\n\n- Successful merges: #38617, #39284, #39285, #39290, #39302, #39305, #39306, #39307, #39311, #39313, #39314, #39321, #39325, #39332, #39335, #39344, #39345, #39346, #39348, #39350, #39351\n- Failed merges:", "tree": {"sha": "ddda8dff0a83c98eb56a0152b4c758d95efb32bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddda8dff0a83c98eb56a0152b4c758d95efb32bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "html_url": "https://github.com/rust-lang/rust/commit/0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "154c202afb256c379b7d454ec0244da69eaa2ced", "url": "https://api.github.com/repos/rust-lang/rust/commits/154c202afb256c379b7d454ec0244da69eaa2ced", "html_url": "https://github.com/rust-lang/rust/commit/154c202afb256c379b7d454ec0244da69eaa2ced"}, {"sha": "1767d9715c7e90ef9add83d866066a69b2103806", "url": "https://api.github.com/repos/rust-lang/rust/commits/1767d9715c7e90ef9add83d866066a69b2103806", "html_url": "https://github.com/rust-lang/rust/commit/1767d9715c7e90ef9add83d866066a69b2103806"}], "stats": {"total": 1229, "additions": 782, "deletions": 447}, "files": [{"sha": "c44c486831accadcc6f1facdadbcffd5f2b38001", "filename": ".mailmap", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -43,8 +43,8 @@ Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n-Carol (Nichols || Goulding) <carol.nichols@gmail.com> Carol Nichols <carol.nichols@gmail.com>\n-Carol (Nichols || Goulding) <carol.nichols@gmail.com> Carol Nichols <cnichols@thinkthroughmath.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com>\n+Carol (Nichols || Goulding) <cnichols@thinkthroughmath.com>\n Carol Willing <carolcode@willingconsulting.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n@@ -53,6 +53,7 @@ Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n Clinton Ryan <clint.ryan3@gmail.com>\n Corey Farwell <coreyf+rust@rwell.org> Corey Farwell <coreyf@rwell.org>\n Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>\n+Cyryl P\u0142otnicki <cyplo@cyplo.net>\n Damien Schoof <damien.schoof@gmail.com>\n Daniel Ramos <dan@daramos.com>\n David Klein <david.klein@baesystemsdetica.com>\n@@ -102,6 +103,7 @@ Jason Toffaletti <toffaletti@gmail.com> Jason Toffaletti <jason@topsy.com>\n Jauhien Piatlicki <jauhien@gentoo.org> Jauhien Piatlicki <jpiatlicki@zertisa.com>\n Jay True <glacjay@gmail.com>\n Jeremy Letang <letang.jeremy@gmail.com>\n+Jethro Beekman <github@jbeekman.nl>\n Jihyun Yu <j.yu@navercorp.com> <yjh0502@gmail.com>\n Jihyun Yu <j.yu@navercorp.com> jihyun <jihyun@nablecomm.com>\n Jihyun Yu <j.yu@navercorp.com> Jihyun Yu <jihyun@nclab.kaist.ac.kr>"}, {"sha": "8a7dc96b34b2541b81c45d0edf4b7a8655878113", "filename": ".travis.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -110,9 +110,9 @@ before_deploy:\n   - mkdir -p deploy/$TRAVIS_COMMIT\n   - >\n       if [ \"$TRAVIS_OS_NAME\" == \"osx\" ]; then\n-          cp build/dist/*.tar.gz deploy/$TRAVIS_COMMIT;\n+          cp -r build/dist deploy/$TRAVIS_COMMIT;\n       else\n-          cp obj/build/dist/*.tar.gz deploy/$TRAVIS_COMMIT;\n+          cp -r obj/build/dist deploy/$TRAVIS_COMMIT;\n       fi\n \n deploy:"}, {"sha": "418cdcb07af4e507166f651236f05472ff954e95", "filename": "appveyor.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -137,7 +137,7 @@ branches:\n before_deploy:\n   - ps: |\n         New-Item -Path deploy -ItemType directory\n-        Get-ChildItem -Path build\\dist -Filter '*.tar.gz' | Move-Item -Destination deploy\n+        Get-ChildItem -Path build\\dist | Move-Item -Destination deploy\n         Get-ChildItem -Path deploy | Foreach-Object {\n           Push-AppveyorArtifact $_.FullName -FileName ${env:APPVEYOR_REPO_COMMIT}/$_\n         }\n@@ -151,7 +151,7 @@ deploy:\n     bucket: rust-lang-ci\n     set_public: true\n     region: us-east-1\n-    artifact: /.*\\.tar.gz/\n+    artifact: /.*/\n     folder: rustc-builds\n     on:\n       branch: auto"}, {"sha": "93bbf0f227b1ba691d6500180fbdaa8e72151315", "filename": "src/Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -50,6 +50,14 @@ dependencies = [\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"build-manifest\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"build_helper\"\n version = \"0.1.0\""}, {"sha": "0db26ea5ae021ae7219884994b9dbc0a025c8853", "filename": "src/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -10,6 +10,7 @@ members = [\n   \"tools/linkchecker\",\n   \"tools/rustbook\",\n   \"tools/tidy\",\n+  \"tools/build-manifest\",\n ]\n \n # Curiously, compiletest will segfault if compiled with opt-level=3 on 64-bit"}, {"sha": "e035f8157ffde9a6d6ecb22415fd97dbe8d139f5", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -78,6 +78,11 @@ pub struct Config {\n     pub cargo: Option<PathBuf>,\n     pub local_rebuild: bool,\n \n+    // dist misc\n+    pub dist_sign_folder: Option<PathBuf>,\n+    pub dist_upload_addr: Option<String>,\n+    pub dist_gpg_password_file: Option<PathBuf>,\n+\n     // libstd features\n     pub debug_jemalloc: bool,\n     pub use_jemalloc: bool,\n@@ -123,6 +128,7 @@ struct TomlConfig {\n     llvm: Option<Llvm>,\n     rust: Option<Rust>,\n     target: Option<HashMap<String, TomlTarget>>,\n+    dist: Option<Dist>,\n }\n \n /// TOML representation of various global build decisions.\n@@ -166,6 +172,13 @@ struct Llvm {\n     targets: Option<String>,\n }\n \n+#[derive(RustcDecodable, Default, Clone)]\n+struct Dist {\n+    sign_folder: Option<String>,\n+    gpg_password_file: Option<String>,\n+    upload_addr: Option<String>,\n+}\n+\n #[derive(RustcDecodable)]\n enum StringOrBool {\n     String(String),\n@@ -352,6 +365,12 @@ impl Config {\n             }\n         }\n \n+        if let Some(ref t) = toml.dist {\n+            config.dist_sign_folder = t.sign_folder.clone().map(PathBuf::from);\n+            config.dist_gpg_password_file = t.gpg_password_file.clone().map(PathBuf::from);\n+            config.dist_upload_addr = t.upload_addr.clone();\n+        }\n+\n         return config\n     }\n "}, {"sha": "a53419ad7fd780a28b41fcf6433a5081510187bc", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -242,3 +242,33 @@\n # that this option only makes sense for MUSL targets that produce statically\n # linked binaries\n #musl-root = \"...\"\n+\n+# =============================================================================\n+# Distribution options\n+#\n+# These options are related to distribution, mostly for the Rust project itself.\n+# You probably won't need to concern yourself with any of these options\n+# =============================================================================\n+[dist]\n+\n+# This is the folder of artifacts that the build system will sign. All files in\n+# this directory will be signed with the default gpg key using the system `gpg`\n+# binary. The `asc` and `sha256` files will all be output into the standard dist\n+# output folder (currently `build/dist`)\n+#\n+# This folder should be populated ahead of time before the build system is\n+# invoked.\n+#sign-folder = \"path/to/folder/to/sign\"\n+\n+# This is a file which contains the password of the default gpg key. This will\n+# be passed to `gpg` down the road when signing all files in `sign-folder`\n+# above. This should be stored in plaintext.\n+#gpg-password-file = \"path/to/gpg/password\"\n+\n+# The remote address that all artifacts will eventually be uploaded to. The\n+# build system generates manifests which will point to these urls, and for the\n+# manifests to be correct they'll have to have the right URLs encoded.\n+#\n+# Note that this address should not contain a trailing slash as file names will\n+# be appended to it.\n+#upload-addr = \"https://example.com/folder\""}, {"sha": "71a5f313bbd26257d5b6f384dd60ca298399c222", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -22,7 +22,7 @@ use std::env;\n use std::fs::{self, File};\n use std::io::{Read, Write};\n use std::path::{PathBuf, Path};\n-use std::process::Command;\n+use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n@@ -876,3 +876,34 @@ fn add_env(build: &Build, cmd: &mut Command, target: &str) {\n        cmd.env(\"CFG_PLATFORM\", \"x86\");\n     }\n }\n+\n+pub fn hash_and_sign(build: &Build) {\n+    let compiler = Compiler::new(0, &build.config.build);\n+    let mut cmd = build.tool_cmd(&compiler, \"build-manifest\");\n+    let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n+        panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n+    });\n+    let addr = build.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n+        panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n+    });\n+    let file = build.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n+        panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n+    });\n+    let mut pass = String::new();\n+    t!(t!(File::open(&file)).read_to_string(&mut pass));\n+\n+    let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n+\n+    cmd.arg(sign);\n+    cmd.arg(distdir(build));\n+    cmd.arg(today.trim());\n+    cmd.arg(package_vers(build));\n+    cmd.arg(addr);\n+\n+    t!(fs::create_dir_all(distdir(build)));\n+\n+    let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n+    t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));\n+    let status = t!(child.wait());\n+    assert!(status.success());\n+}"}, {"sha": "3932a7cf8c56376c32af9a2a6938abcf9a31cc75", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -513,6 +513,9 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n          .dep(|s| s.name(\"libtest\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n+    rules.build(\"tool-build-manifest\", \"src/tools/build-manifest\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n \n     // ========================================================================\n     // Documentation targets\n@@ -633,6 +636,13 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(|d| d.name(\"dist-cargo\"))\n          .run(move |s| dist::extended(build, s.stage, s.target));\n \n+    rules.dist(\"dist-sign\", \"hash-and-sign\")\n+         .host(true)\n+         .only_build(true)\n+         .only_host_build(true)\n+         .dep(move |s| s.name(\"tool-build-manifest\").target(&build.config.build).stage(0))\n+         .run(move |_| dist::hash_and_sign(build));\n+\n     rules.verify();\n     return rules;\n }"}, {"sha": "8ab580e6aa9fd7a5a4850142eee35ab596292bc0", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -710,7 +710,7 @@ Please note that [`catch_unwind()`] will only catch unwinding panics, not\n those who abort the process. See the documentation of [`catch_unwind()`]\n for more information.\n \n-[`catch_unwind()`]: https://doc.rust-lang.org/std/panic/fn.catch_unwind.html\n+[`catch_unwind()`]: ../std/panic/fn.catch_unwind.html\n \n # Representing opaque structs\n "}, {"sha": "be4730cf8bce627fdb6e81c9993dd26dc05da3bf", "filename": "src/doc/nomicon/destructors.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fdoc%2Fnomicon%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fdoc%2Fnomicon%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdestructors.md?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -26,7 +26,7 @@ this is totally fine.\n For instance, a custom implementation of `Box` might write `Drop` like this:\n \n ```rust\n-#![feature(alloc, heap_api, drop_in_place, unique)]\n+#![feature(alloc, heap_api, unique)]\n \n extern crate alloc;\n \n@@ -57,7 +57,7 @@ use-after-free the `ptr` because when drop exits, it becomes inaccessible.\n However this wouldn't work:\n \n ```rust\n-#![feature(alloc, heap_api, drop_in_place, unique)]\n+#![feature(alloc, heap_api, unique)]\n \n extern crate alloc;\n \n@@ -135,7 +135,7 @@ The classic safe solution to overriding recursive drop and allowing moving out\n of Self during `drop` is to use an Option:\n \n ```rust\n-#![feature(alloc, heap_api, drop_in_place, unique)]\n+#![feature(alloc, heap_api, unique)]\n \n extern crate alloc;\n "}, {"sha": "38d843263ffda09c7c1609e684a42da31a9763df", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -59,7 +59,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// as long as `T` implements [`Send`] and [`Sync`][sync]. The disadvantage is\n /// that atomic operations are more expensive than ordinary memory accesses.\n /// If you are not sharing reference-counted values between threads, consider\n-/// using [`rc::Rc`] for lower overhead. [`Rc`] is a safe default, because\n+/// using [`rc::Rc`][`Rc`] for lower overhead. [`Rc`] is a safe default, because\n /// the compiler will catch any attempt to send an [`Rc`] between threads.\n /// However, a library might choose `Arc` in order to give library consumers\n /// more flexibility."}, {"sha": "78b610797778190f398d75eafbadcb0f4b4a25a5", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -17,6 +17,8 @@\n             reason = \"matches collection reform specification, \\\n                       waiting for dust to settle\",\n             issue = \"37966\")]\n+#![rustc_deprecated(since = \"1.16.0\", reason = \"long since replaced\")]\n+#![allow(deprecated)]\n \n use core::marker;\n use core::fmt;"}, {"sha": "39de87c08407f5bcea0f9050c2557758e403e28d", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -79,6 +79,7 @@ pub use btree_set::BTreeSet;\n #[doc(no_inline)]\n pub use linked_list::LinkedList;\n #[doc(no_inline)]\n+#[allow(deprecated)]\n pub use enum_set::EnumSet;\n #[doc(no_inline)]\n pub use vec_deque::VecDeque;"}, {"sha": "11f513ed798e07edbb7509eddf14f96cab145d6d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -509,7 +509,7 @@ impl<T> [T] {\n         core_slice::SliceExt::swap(self, a, b)\n     }\n \n-    /// Reverse the order of elements in a slice, in place.\n+    /// Reverses the order of elements in a slice, in place.\n     ///\n     /// # Example\n     ///\n@@ -1062,7 +1062,7 @@ impl<T> [T] {\n         core_slice::SliceExt::binary_search_by_key(self, b, f)\n     }\n \n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n+    /// Sorts the slice.\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///"}, {"sha": "458d5114829f459b404ddcb8e34debd5b553fd5b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -1607,7 +1607,6 @@ impl str {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// # #![feature(str_replacen)]\n     /// let s = \"foo foo 123 foo\";\n     /// assert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\n     /// assert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\n@@ -1617,13 +1616,10 @@ impl str {\n     /// When the pattern doesn't match:\n     ///\n     /// ```\n-    /// # #![feature(str_replacen)]\n     /// let s = \"this is old\";\n     /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n     /// ```\n-    #[unstable(feature = \"str_replacen\",\n-               issue = \"36436\",\n-               reason = \"only need to replace first N matches\")]\n+    #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n     pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String {\n         // Hope to reduce the times of re-allocation\n         let mut result = String::with_capacity(32);\n@@ -1795,11 +1791,9 @@ impl str {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(repeat_str)]\n-    ///\n     /// assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n     /// ```\n-    #[unstable(feature = \"repeat_str\", issue = \"37079\")]\n+    #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {\n         let mut s = String::with_capacity(self.len() * n);\n         s.extend((0..n).map(|_| self));"}, {"sha": "b184a8603e6bd1be5fa4568e3a68ab46174d9e64", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -1166,18 +1166,14 @@ impl String {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(insert_str)]\n-    ///\n     /// let mut s = String::from(\"bar\");\n     ///\n     /// s.insert_str(0, \"foo\");\n     ///\n     /// assert_eq!(\"foobar\", s);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"insert_str\",\n-               reason = \"recent addition\",\n-               issue = \"35553\")]\n+    #[stable(feature = \"insert_str\", since = \"1.16.0\")]\n     pub fn insert_str(&mut self, idx: usize, string: &str) {\n         assert!(self.is_char_boundary(idx));\n \n@@ -1270,7 +1266,6 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(string_split_off)]\n     /// # fn main() {\n     /// let mut hello = String::from(\"Hello, World!\");\n     /// let world = hello.split_off(7);\n@@ -1279,7 +1274,7 @@ impl String {\n     /// # }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"string_split_off\", issue = \"38080\")]\n+    #[stable(feature = \"string_split_off\", since = \"1.16.0\")]\n     pub fn split_off(&mut self, mid: usize) -> String {\n         assert!(self.is_char_boundary(mid));\n         let other = self.vec.split_off(mid);"}, {"sha": "1f8fd32da9ab8829bbd5a1b2308ad07ce35c86ea", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -820,15 +820,13 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(dedup_by)]\n-    ///\n     /// let mut vec = vec![10, 20, 21, 30, 20];\n     ///\n     /// vec.dedup_by_key(|i| *i / 10);\n     ///\n     /// assert_eq!(vec, [10, 20, 30, 20]);\n     /// ```\n-    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n+    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n     #[inline]\n     pub fn dedup_by_key<F, K>(&mut self, mut key: F) where F: FnMut(&mut T) -> K, K: PartialEq {\n         self.dedup_by(|a, b| key(a) == key(b))\n@@ -841,7 +839,6 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(dedup_by)]\n     /// use std::ascii::AsciiExt;\n     ///\n     /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n@@ -850,7 +847,7 @@ impl<T> Vec<T> {\n     ///\n     /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n     /// ```\n-    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n+    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n     pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make"}, {"sha": "5b1bc3a3ae4f14897d934c8c0f7d787903f405cc", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -643,8 +643,6 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(deque_extras)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -655,9 +653,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf.len(), 1);\n     /// assert_eq!(Some(&5), buf.get(0));\n     /// ```\n-    #[unstable(feature = \"deque_extras\",\n-               reason = \"matches collection reform specification; waiting on panic semantics\",\n-               issue = \"27788\")]\n+    #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn truncate(&mut self, len: usize) {\n         for _ in len..self.len() {\n             self.pop_back();\n@@ -1779,8 +1775,6 @@ impl<T: Clone> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(deque_extras)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -1793,9 +1787,7 @@ impl<T: Clone> VecDeque<T> {\n     ///     assert_eq!(a, b);\n     /// }\n     /// ```\n-    #[unstable(feature = \"deque_extras\",\n-               reason = \"matches collection reform specification; waiting on panic semantics\",\n-               issue = \"27788\")]\n+    #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n "}, {"sha": "972361326d7bb33af99e99d0a34b49ff8a4ccc70", "filename": "src/libcollectionstest/enum_set.rs", "status": "removed", "additions": 0, "deletions": 268, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/154c202afb256c379b7d454ec0244da69eaa2ced/src%2Flibcollectionstest%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c202afb256c379b7d454ec0244da69eaa2ced/src%2Flibcollectionstest%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fenum_set.rs?ref=154c202afb256c379b7d454ec0244da69eaa2ced", "patch": "@@ -1,268 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::mem;\n-\n-use collections::enum_set::{CLike, EnumSet};\n-\n-use self::Foo::*;\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(usize)]\n-enum Foo {\n-    A,\n-    B,\n-    C,\n-}\n-\n-impl CLike for Foo {\n-    fn to_usize(&self) -> usize {\n-        *self as usize\n-    }\n-\n-    fn from_usize(v: usize) -> Foo {\n-        unsafe { mem::transmute(v) }\n-    }\n-}\n-\n-#[test]\n-fn test_new() {\n-    let e: EnumSet<Foo> = EnumSet::new();\n-    assert!(e.is_empty());\n-}\n-\n-#[test]\n-fn test_show() {\n-    let mut e = EnumSet::new();\n-    assert!(format!(\"{:?}\", e) == \"{}\");\n-    e.insert(A);\n-    assert!(format!(\"{:?}\", e) == \"{A}\");\n-    e.insert(C);\n-    assert!(format!(\"{:?}\", e) == \"{A, C}\");\n-}\n-\n-#[test]\n-fn test_len() {\n-    let mut e = EnumSet::new();\n-    assert_eq!(e.len(), 0);\n-    e.insert(A);\n-    e.insert(B);\n-    e.insert(C);\n-    assert_eq!(e.len(), 3);\n-    e.remove(&A);\n-    assert_eq!(e.len(), 2);\n-    e.clear();\n-    assert_eq!(e.len(), 0);\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// intersect\n-\n-#[test]\n-fn test_two_empties_do_not_intersect() {\n-    let e1: EnumSet<Foo> = EnumSet::new();\n-    let e2: EnumSet<Foo> = EnumSet::new();\n-    assert!(e1.is_disjoint(&e2));\n-}\n-\n-#[test]\n-fn test_empty_does_not_intersect_with_full() {\n-    let e1: EnumSet<Foo> = EnumSet::new();\n-\n-    let mut e2: EnumSet<Foo> = EnumSet::new();\n-    e2.insert(A);\n-    e2.insert(B);\n-    e2.insert(C);\n-\n-    assert!(e1.is_disjoint(&e2));\n-}\n-\n-#[test]\n-fn test_disjoint_intersects() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-    e1.insert(A);\n-\n-    let mut e2: EnumSet<Foo> = EnumSet::new();\n-    e2.insert(B);\n-\n-    assert!(e1.is_disjoint(&e2));\n-}\n-\n-#[test]\n-fn test_overlapping_intersects() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-    e1.insert(A);\n-\n-    let mut e2: EnumSet<Foo> = EnumSet::new();\n-    e2.insert(A);\n-    e2.insert(B);\n-\n-    assert!(!e1.is_disjoint(&e2));\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// contains and contains_elem\n-\n-#[test]\n-fn test_superset() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-    e1.insert(A);\n-\n-    let mut e2: EnumSet<Foo> = EnumSet::new();\n-    e2.insert(A);\n-    e2.insert(B);\n-\n-    let mut e3: EnumSet<Foo> = EnumSet::new();\n-    e3.insert(C);\n-\n-    assert!(e1.is_subset(&e2));\n-    assert!(e2.is_superset(&e1));\n-    assert!(!e3.is_superset(&e2));\n-    assert!(!e2.is_superset(&e3))\n-}\n-\n-#[test]\n-fn test_contains() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-    e1.insert(A);\n-    assert!(e1.contains(&A));\n-    assert!(!e1.contains(&B));\n-    assert!(!e1.contains(&C));\n-\n-    e1.insert(A);\n-    e1.insert(B);\n-    assert!(e1.contains(&A));\n-    assert!(e1.contains(&B));\n-    assert!(!e1.contains(&C));\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// iter\n-\n-#[test]\n-fn test_iterator() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-\n-    let elems: Vec<Foo> = e1.iter().collect();\n-    assert!(elems.is_empty());\n-\n-    e1.insert(A);\n-    let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A]);\n-\n-    e1.insert(C);\n-    let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A, C]);\n-\n-    e1.insert(C);\n-    let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A, C]);\n-\n-    e1.insert(B);\n-    let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A, B, C]);\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// operators\n-\n-#[test]\n-fn test_operators() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-    e1.insert(A);\n-    e1.insert(C);\n-\n-    let mut e2: EnumSet<Foo> = EnumSet::new();\n-    e2.insert(B);\n-    e2.insert(C);\n-\n-    let e_union = e1 | e2;\n-    let elems: Vec<_> = e_union.iter().collect();\n-    assert_eq!(elems, [A, B, C]);\n-\n-    let e_intersection = e1 & e2;\n-    let elems: Vec<_> = e_intersection.iter().collect();\n-    assert_eq!(elems, [C]);\n-\n-    // Another way to express intersection\n-    let e_intersection = e1 - (e1 - e2);\n-    let elems: Vec<_> = e_intersection.iter().collect();\n-    assert_eq!(elems, [C]);\n-\n-    let e_subtract = e1 - e2;\n-    let elems: Vec<_> = e_subtract.iter().collect();\n-    assert_eq!(elems, [A]);\n-\n-    // Bitwise XOR of two sets, aka symmetric difference\n-    let e_symmetric_diff = e1 ^ e2;\n-    let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!(elems, [A, B]);\n-\n-    // Another way to express symmetric difference\n-    let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n-    let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!(elems, [A, B]);\n-\n-    // Yet another way to express symmetric difference\n-    let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n-    let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!(elems, [A, B]);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_overflow() {\n-    #[allow(dead_code)]\n-    #[derive(Copy, Clone)]\n-    #[repr(usize)]\n-    enum Bar {\n-        V00, V01, V02, V03, V04, V05, V06, V07, V08, V09,\n-        V10, V11, V12, V13, V14, V15, V16, V17, V18, V19,\n-        V20, V21, V22, V23, V24, V25, V26, V27, V28, V29,\n-        V30, V31, V32, V33, V34, V35, V36, V37, V38, V39,\n-        V40, V41, V42, V43, V44, V45, V46, V47, V48, V49,\n-        V50, V51, V52, V53, V54, V55, V56, V57, V58, V59,\n-        V60, V61, V62, V63, V64, V65, V66, V67, V68, V69,\n-    }\n-\n-    impl CLike for Bar {\n-        fn to_usize(&self) -> usize {\n-            *self as usize\n-        }\n-\n-        fn from_usize(v: usize) -> Bar {\n-            unsafe { mem::transmute(v) }\n-        }\n-    }\n-    let mut set = EnumSet::new();\n-    set.insert(Bar::V64);\n-}\n-\n-#[test]\n-fn test_extend_ref() {\n-    let mut a = EnumSet::new();\n-    a.insert(A);\n-\n-    a.extend(&[A, C]);\n-\n-    assert_eq!(a.len(), 2);\n-    assert!(a.contains(&A));\n-    assert!(a.contains(&C));\n-\n-    let mut b = EnumSet::new();\n-    b.insert(B);\n-\n-    a.extend(&b);\n-\n-    assert_eq!(a.len(), 3);\n-    assert!(a.contains(&A));\n-    assert!(a.contains(&B));\n-    assert!(a.contains(&C));\n-}"}, {"sha": "b146672893f8dcf60ce09202a95581696ff34e8f", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -18,17 +18,12 @@\n #![feature(collections)]\n #![feature(collections_bound)]\n #![feature(const_fn)]\n-#![feature(dedup_by)]\n-#![feature(enumset)]\n #![feature(exact_size_is_empty)]\n #![feature(pattern)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n-#![feature(repeat_str)]\n #![feature(step_by)]\n #![feature(str_escape)]\n-#![feature(str_replacen)]\n-#![feature(string_split_off)]\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n@@ -47,7 +42,6 @@ mod bench;\n mod binary_heap;\n mod btree;\n mod cow_str;\n-mod enum_set;\n mod fmt;\n mod linked_list;\n mod slice;"}, {"sha": "dd6edc7d39af0ca0afca1f2be4418cd9430099df", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -307,6 +307,7 @@ pub trait BuildHasher {\n /// [`BuildHasher`]: trait.BuildHasher.html\n /// [`Default`]: ../default/trait.Default.html\n /// [`Hasher`]: trait.Hasher.html\n+/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n pub struct BuildHasherDefault<H>(marker::PhantomData<H>);\n "}, {"sha": "3b406873d4b191b63fc2d5a71cc416fd884d4606", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -1108,9 +1108,9 @@ pub trait Iterator {\n     ///\n     /// One of the keys to `collect()`'s power is that many things you might\n     /// not think of as 'collections' actually are. For example, a [`String`]\n-    /// is a collection of [`char`]s. And a collection of [`Result<T, E>`] can\n-    /// be thought of as single [`Result`]`<Collection<T>, E>`. See the examples\n-    /// below for more.\n+    /// is a collection of [`char`]s. And a collection of\n+    /// [`Result<T, E>`][`Result`] can be thought of as single\n+    /// [`Result`]`<Collection<T>, E>`. See the examples below for more.\n     ///\n     /// Because `collect()` is so general, it can cause problems with type\n     /// inference. As such, `collect()` is one of the few times you'll see"}, {"sha": "02851c224e2e35b019c8cd6a0a06446156916716", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -448,7 +448,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(ptr_wrapping_offset)]\n     /// // Iterate using a raw pointer in increments of two elements\n     /// let data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *const u8 = data.as_ptr();\n@@ -463,7 +462,7 @@ impl<T: ?Sized> *const T {\n     ///     ptr = ptr.wrapping_offset(step);\n     /// }\n     /// ```\n-    #[unstable(feature = \"ptr_wrapping_offset\", issue = \"37570\")]\n+    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[inline]\n     pub fn wrapping_offset(self, count: isize) -> *const T where T: Sized {\n         unsafe {\n@@ -572,7 +571,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(ptr_wrapping_offset)]\n     /// // Iterate using a raw pointer in increments of two elements\n     /// let mut data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *mut u8 = data.as_mut_ptr();\n@@ -587,7 +585,7 @@ impl<T: ?Sized> *mut T {\n     /// }\n     /// assert_eq!(&data, &[0, 2, 0, 4, 0]);\n     /// ```\n-    #[unstable(feature = \"ptr_wrapping_offset\", issue = \"37570\")]\n+    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[inline]\n     pub fn wrapping_offset(self, count: isize) -> *mut T where T: Sized {\n         unsafe {"}, {"sha": "0a2e363965347830468dd2283c34e967e7a68df6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -840,8 +840,6 @@ impl<T: Default, E> Result<T, E> {\n     /// `Err` on error.\n     ///\n     /// ```\n-    /// #![feature(result_unwrap_or_default)]\n-    ///\n     /// let good_year_from_input = \"1909\";\n     /// let bad_year_from_input = \"190blarg\";\n     /// let good_year = good_year_from_input.parse().unwrap_or_default();\n@@ -854,7 +852,7 @@ impl<T: Default, E> Result<T, E> {\n     /// [`FromStr`]: ../../std/str/trait.FromStr.html\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"result_unwrap_or_default\", issue = \"37516\")]\n+    #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Ok(x) => x,"}, {"sha": "743e3c41170a34d0c99ef3575cd234811eb3deb2", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -24,7 +24,7 @@\n //! same as [LLVM atomic orderings][1]. For more information see the [nomicon][2].\n //!\n //! [1]: http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n-//! [2]: https://doc.rust-lang.org/nomicon/atomics.html\n+//! [2]: ../../../nomicon/atomics.html\n //!\n //! Atomic variables are safe to share between threads (they implement `Sync`)\n //! but they do not themselves provide the mechanism for sharing and follow the\n@@ -144,7 +144,7 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// LLVM's](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n ///\n /// For more information see the [nomicon][1].\n-/// [1]: https://doc.rust-lang.org/nomicon/atomics.html\n+/// [1]: ../../../nomicon/atomics.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Debug)]\n pub enum Ordering {"}, {"sha": "8e5893b5ecbed8de5b000b7b9333ae71be31b36c", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -32,7 +32,6 @@\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(ordering_chaining)]\n-#![feature(result_unwrap_or_default)]\n #![feature(ptr_unaligned)]\n \n extern crate core;"}, {"sha": "931d83f5e188a3f0a022ea600cb0d8211afcc29f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -231,7 +231,11 @@ pub struct TypeckTables<'tcx> {\n     /// of the struct - this is needed because it is non-trivial to\n     /// normalize while preserving regions. This table is used only in\n     /// MIR construction and hence is not serialized to metadata.\n-    pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>\n+    pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>,\n+\n+    /// Maps a cast expression to its kind. This is keyed on the\n+    /// *from* expression of the cast, not the cast itself.\n+    pub cast_kinds: NodeMap<ty::cast::CastKind>,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -246,7 +250,8 @@ impl<'tcx> TypeckTables<'tcx> {\n             closure_tys: NodeMap(),\n             closure_kinds: NodeMap(),\n             liberated_fn_sigs: NodeMap(),\n-            fru_field_types: NodeMap()\n+            fru_field_types: NodeMap(),\n+            cast_kinds: NodeMap(),\n         }\n     }\n \n@@ -533,10 +538,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// expression defining the closure.\n     pub closure_kinds: RefCell<DepTrackingMap<maps::ClosureKinds<'tcx>>>,\n \n-    /// Maps a cast expression to its kind. This is keyed on the\n-    /// *from* expression of the cast, not the cast itself.\n-    pub cast_kinds: RefCell<NodeMap<ty::cast::CastKind>>,\n-\n     /// Maps Fn items to a collection of fragment infos.\n     ///\n     /// The main goal is to identify data (each of which may be moved\n@@ -792,7 +793,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             closure_tys: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             closure_kinds: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,"}, {"sha": "6c49493a655597abb1b95ec23aeba408ea0bcffa", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -191,11 +191,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }\n             }\n             TyRef(_, ref tm) => {\n-                if tcx.sess.features.borrow().never_type {\n-                    tm.ty.uninhabited_from(visited, tcx)\n-                } else {\n-                    DefIdForest::empty()\n-                }\n+                tm.ty.uninhabited_from(visited, tcx)\n             }\n \n             _ => DefIdForest::empty(),"}, {"sha": "f97039b6a9210a216063b88682bb144d17f11eef", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -514,7 +514,7 @@ pub enum BorrowKind {\n \n     /// Data must be immutable but not aliasable.  This kind of borrow\n     /// cannot currently be expressed by the user and is used only in\n-    /// implicit closure bindings. It is needed when you the closure\n+    /// implicit closure bindings. It is needed when the closure\n     /// is borrowing or mutating a mutable referent, e.g.:\n     ///\n     ///    let x: &mut isize = ...;"}, {"sha": "1770a112cdf231ab159d3782581f7902f50f55dc", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -379,19 +379,24 @@ impl<'tcx> Witness<'tcx> {\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   pcx: PatternContext<'tcx>) -> Vec<Constructor>\n {\n+    let check_inhabited = cx.tcx.sess.features.borrow().never_type;\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(ref sub_ty) => {\n-            if sub_ty.is_uninhabited_from(cx.module, cx.tcx) {\n+            if sub_ty.is_uninhabited_from(cx.module, cx.tcx)\n+                && check_inhabited\n+            {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n         ty::TyArray(ref sub_ty, length) => {\n-            if length == 0 || !sub_ty.is_uninhabited_from(cx.module, cx.tcx) {\n+            if length == 0 || !(sub_ty.is_uninhabited_from(cx.module, cx.tcx)\n+                                && check_inhabited)\n+            {\n                 vec![Slice(length)]\n             } else {\n                 vec![]\n@@ -403,15 +408,19 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 let forest = v.uninhabited_from(&mut visited,\n                                                 cx.tcx, substs,\n                                                 AdtKind::Enum);\n-                if forest.contains(cx.tcx, cx.module) {\n+                if forest.contains(cx.tcx, cx.module)\n+                    && check_inhabited\n+                {\n                     None\n                 } else {\n                     Some(Variant(v.did))\n                 }\n             }).collect()\n         }\n         _ => {\n-            if pcx.ty.is_uninhabited_from(cx.module, cx.tcx) {\n+            if pcx.ty.is_uninhabited_from(cx.module, cx.tcx)\n+                    && check_inhabited\n+            {\n                 vec![]\n             } else {\n                 vec![Single]"}, {"sha": "e94d35195c21336cc162a8f777ca2e7a303eecb5", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -99,20 +99,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n-                let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n-                    i == variant_index || {\n-                        let mut visited = FxHashSet::default();\n-                        let node_set = v.uninhabited_from(&mut visited,\n-                                                          self.hir.tcx(),\n-                                                          substs,\n-                                                          adt_def.adt_kind());\n-                        !node_set.is_empty()\n+                if self.hir.tcx().sess.features.borrow().never_type {\n+                    let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n+                        i == variant_index || {\n+                            let mut visited = FxHashSet::default();\n+                            let node_set = v.uninhabited_from(&mut visited,\n+                                                              self.hir.tcx(),\n+                                                              substs,\n+                                                              adt_def.adt_kind());\n+                            !node_set.is_empty()\n+                        }\n+                    });\n+                    if irrefutable {\n+                        let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);\n+                        candidate.match_pairs.extend(self.field_match_pairs(lvalue, subpatterns));\n+                        Ok(())\n+                    } else {\n+                        Err(match_pair)\n                     }\n-                });\n-                if irrefutable {\n-                    let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);\n-                    candidate.match_pairs.extend(self.field_match_pairs(lvalue, subpatterns));\n-                    Ok(())\n                 } else {\n                     Err(match_pair)\n                 }"}, {"sha": "7eaf1fe13986518e85fd8ccd4c44759cb6b6bd7a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -663,7 +663,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprCast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n-            if let Some(&TyCastKind::CoercionCast) = cx.tcx.cast_kinds.borrow().get(&source.id) {\n+            if let Some(&TyCastKind::CoercionCast) = cx.tables().cast_kinds.get(&source.id) {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n             } else {"}, {"sha": "35734dcce2beb631c2dd58cc319dffd7c7a7a816", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -92,7 +92,7 @@ pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     where I: Iterator<Item=DefId>, 'tcx: 'a\n {\n     let mut first = true;\n-    for def_id in iter {\n+    for def_id in iter.filter(DefId::is_local) {\n         let mir = &tcx.item_mir(def_id);\n \n         if first {"}, {"sha": "0b55513f8318c3c45cd8228fb8f3823a0f15db35", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -314,7 +314,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         }\n         hir::ExprCast(ref from, _) => {\n             debug!(\"Checking const cast(id={})\", from.id);\n-            match v.tcx.cast_kinds.borrow().get(&from.id) {\n+            match v.tables.cast_kinds.get(&from.id) {\n                 None => span_bug!(e.span, \"no kind for cast\"),\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n                     v.promotable = false;"}, {"sha": "f128167bbf621b50e074a27a3d34bd2227ddaf70", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -111,11 +111,16 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     fn nest_tables<F>(&mut self, item_id: NodeId, f: F)\n         where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n-        let old_tables = self.save_ctxt.tables;\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n-        self.save_ctxt.tables = self.tcx.item_tables(item_def_id);\n-        f(self);\n-        self.save_ctxt.tables = old_tables;\n+        match self.tcx.tables.borrow().get(&item_def_id) {\n+            Some(tables) => {\n+                let old_tables = self.save_ctxt.tables;\n+                self.save_ctxt.tables = tables;\n+                f(self);\n+                self.save_ctxt.tables = old_tables;\n+            }\n+            None => f(self),\n+        }\n     }\n \n     pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {"}, {"sha": "0ba94fdfe635cf5aca3968f15e836fa18597e319", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -234,7 +234,8 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n pub fn C_big_integral(t: Type, u: u128, sign_extend: bool) -> ValueRef {\n     if ::std::mem::size_of::<u128>() == 16 {\n         unsafe {\n-            llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, &u as *const u128 as *const u64)\n+            let words = [u as u64, u.wrapping_shr(64) as u64];\n+            llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, words.as_ptr())\n         }\n     } else {\n         // SNAP: remove after snapshot"}, {"sha": "0218f1c70ba8e151666f3fad6066306492f62ecf", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -348,12 +348,12 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);\n             debug!(\" -> CoercionCast\");\n-            fcx.tcx.cast_kinds.borrow_mut().insert(self.expr.id, CastKind::CoercionCast);\n+            fcx.tables.borrow_mut().cast_kinds.insert(self.expr.id, CastKind::CoercionCast);\n         } else {\n             match self.do_check(fcx) {\n                 Ok(k) => {\n                     debug!(\" -> {:?}\", k);\n-                    fcx.tcx.cast_kinds.borrow_mut().insert(self.expr.id, k);\n+                    fcx.tables.borrow_mut().cast_kinds.insert(self.expr.id, k);\n                 }\n                 Err(e) => self.report_cast_error(fcx, e),\n             };"}, {"sha": "925d28247b610cc1268ff5a83623f975801d885a", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -12,7 +12,7 @@\n \n use super::FnCtxt;\n use hir::def_id::DefId;\n-use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue};\n+use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue, TypeVariants};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -204,6 +204,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             \"binary operation `{}` cannot be applied to type `{}`\",\n                             op.node.as_str(),\n                             lhs_ty);\n+\n+                        if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n+                            if !self.infcx.type_moves_by_default(ty_mut.ty, lhs_expr.span) &&\n+                                self.lookup_op_method(expr, ty_mut.ty, vec![rhs_ty_var],\n+                                    Symbol::intern(name), trait_def_id,\n+                                    lhs_expr).is_ok() {\n+                                err.span_note(\n+                                    lhs_expr.span,\n+                                    &format!(\n+                                        \"this is a reference of type that `{}` can be applied to, \\\n+                                        you need to dereference this variable once for this \\\n+                                        operation to work\",\n+                                    op.node.as_str()));\n+                            }\n+                        }\n+\n                         let missing_trait = match op.node {\n                             hir::BiAdd    => Some(\"std::ops::Add\"),\n                             hir::BiSub    => Some(\"std::ops::Sub\"),"}, {"sha": "7f82d7829ce52d7e700ff06bce99f8552f6bb2c2", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -51,6 +51,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_anon_types();\n         wbcx.visit_deferred_obligations(item_id);\n         wbcx.visit_type_nodes();\n+        wbcx.visit_cast_types();\n \n         let tables = self.tcx.alloc_tables(wbcx.tables);\n         self.tcx.tables.borrow_mut().insert(item_def_id, tables);\n@@ -291,6 +292,15 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_cast_types(&mut self) {\n+        if self.fcx.writeback_errors.get() {\n+            return\n+        }\n+\n+        self.tables.cast_kinds.extend(\n+            self.fcx.tables.borrow().cast_kinds.iter().map(|(&key, &value)| (key, value)));\n+    }\n+\n     fn visit_anon_types(&self) {\n         if self.fcx.writeback_errors.get() {\n             return"}, {"sha": "a0d25abd14ce61eb963709c8f97479fd3799d167", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -263,6 +263,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                             .span_label(item.span, &format!(\"impl doesn't use types inside crate\"))\n                             .note(&format!(\"the impl does not reference any types defined in \\\n                                             this crate\"))\n+                            .note(\"define and implement a trait or new type instead\")\n                             .emit();\n                         return;\n                     }"}, {"sha": "05cfb6352fbb800e49a8b8210ff7d3814963b709", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -11,11 +11,9 @@\n //! Implementations of serialization for structures found in libcollections\n \n use std::hash::{Hash, BuildHasher};\n-use std::mem;\n \n use {Decodable, Encodable, Decoder, Encoder};\n use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet};\n-use collections::enum_set::{EnumSet, CLike};\n \n impl<\n     T: Encodable\n@@ -128,33 +126,6 @@ impl<\n     }\n }\n \n-impl<\n-    T: Encodable + CLike\n-> Encodable for EnumSet<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        let mut bits = 0;\n-        for item in self {\n-            bits |= 1 << item.to_usize();\n-        }\n-        s.emit_usize(bits)\n-    }\n-}\n-\n-impl<\n-    T: Decodable + CLike\n-> Decodable for EnumSet<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<EnumSet<T>, D::Error> {\n-        let bits = d.read_usize()?;\n-        let mut set = EnumSet::new();\n-        for bit in 0..(mem::size_of::<usize>()*8) {\n-            if bits & (1 << bit) != 0 {\n-                set.insert(CLike::from_usize(bit));\n-            }\n-        }\n-        Ok(set)\n-    }\n-}\n-\n impl<K, V, S> Encodable for HashMap<K, V, S>\n     where K: Encodable + Hash + Eq,\n           V: Encodable,"}, {"sha": "1cb83fa33da068ecca77c6aaedc1111d8f0c55fe", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -30,7 +30,6 @@ Core encoding and decoding interfaces.\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core_intrinsics)]\n-#![feature(enumset)]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![cfg_attr(test, feature(test))]"}, {"sha": "c3a6b2433ed8815acb1460ba3800a2a13857738b", "filename": "src/libstd/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -222,7 +222,7 @@ fn _var_os(key: &OsStr) -> Option<OsString> {\n \n /// Possible errors from the [`env::var`] function.\n ///\n-/// [env::var]: fn.var.html\n+/// [`env::var`]: fn.var.html\n #[derive(Debug, PartialEq, Eq, Clone)]\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub enum VarError {"}, {"sha": "249627c430cb7d49299b5cda6a3c4b1d9da91384", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -404,7 +404,6 @@ impl File {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(set_permissions_atomic)]\n     /// # fn foo() -> std::io::Result<()> {\n     /// use std::fs::File;\n     ///\n@@ -415,7 +414,7 @@ impl File {\n     /// # Ok(())\n     /// # }\n     /// ```\n-    #[unstable(feature = \"set_permissions_atomic\", issue=\"37916\")]\n+    #[stable(feature = \"set_permissions_atomic\", since = \"1.16.0\")]\n     pub fn set_permissions(&self, perm: Permissions) -> io::Result<()> {\n         self.inner.set_permissions(perm.0)\n     }"}, {"sha": "751878c687c0150c21d53932b03d39e96c8250df", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -148,8 +148,6 @@ impl SocketAddr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(sockaddr_checker)]\n-    ///\n     /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n     ///\n     /// fn main() {\n@@ -158,7 +156,7 @@ impl SocketAddr {\n     ///     assert_eq!(socket.is_ipv6(), false);\n     /// }\n     /// ```\n-    #[unstable(feature = \"sockaddr_checker\", issue = \"36949\")]\n+    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv4(&self) -> bool {\n         match *self {\n             SocketAddr::V4(_) => true,\n@@ -172,8 +170,6 @@ impl SocketAddr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(sockaddr_checker)]\n-    ///\n     /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n     ///\n     /// fn main() {\n@@ -183,7 +179,7 @@ impl SocketAddr {\n     ///     assert_eq!(socket.is_ipv6(), true);\n     /// }\n     /// ```\n-    #[unstable(feature = \"sockaddr_checker\", issue = \"36949\")]\n+    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv6(&self) -> bool {\n         match *self {\n             SocketAddr::V4(_) => false,"}, {"sha": "7803cf728f2e98777855e0fa32e7f09e4985769b", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -196,8 +196,6 @@ impl IpAddr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(ipaddr_checker)]\n-    ///\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n     /// fn main() {\n@@ -206,7 +204,7 @@ impl IpAddr {\n     ///                false);\n     /// }\n     /// ```\n-    #[unstable(feature = \"ipaddr_checker\", issue = \"36949\")]\n+    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv4(&self) -> bool {\n         match *self {\n             IpAddr::V4(_) => true,\n@@ -219,8 +217,6 @@ impl IpAddr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(ipaddr_checker)]\n-    ///\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n     /// fn main() {\n@@ -229,7 +225,7 @@ impl IpAddr {\n     ///                true);\n     /// }\n     /// ```\n-    #[unstable(feature = \"ipaddr_checker\", issue = \"36949\")]\n+    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv6(&self) -> bool {\n         match *self {\n             IpAddr::V4(_) => false,"}, {"sha": "1419a4af4273831d81dc3017db2cfbde008e1b82", "filename": "src/libstd/sys/windows/ext/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -99,17 +99,17 @@ impl ExitStatusExt for process::ExitStatus {\n }\n \n /// Windows-specific extensions to the `std::process::Command` builder\n-#[unstable(feature = \"windows_process_extensions\", issue = \"37827\")]\n+#[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n pub trait CommandExt {\n     /// Sets the [process creation flags][1] to be passed to `CreateProcess`.\n     ///\n     /// These will always be ORed with `CREATE_UNICODE_ENVIRONMENT`.\n     /// [1]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx\n-    #[unstable(feature = \"windows_process_extensions\", issue = \"37827\")]\n+    #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n     fn creation_flags(&mut self, flags: u32) -> &mut process::Command;\n }\n \n-#[unstable(feature = \"windows_process_extensions\", issue = \"37827\")]\n+#[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n impl CommandExt for process::Command {\n     fn creation_flags(&mut self, flags: u32) -> &mut process::Command {\n         self.as_inner_mut().creation_flags(flags);"}, {"sha": "8789006436c0c7baa2cfe93a0960b3ea1b4faa57", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -391,7 +391,7 @@ impl Builder {\n /// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n /// [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-/// [`panic!`]: ../../std/macro.panic.html\n+/// [`panic`]: ../../std/macro.panic.html\n /// [`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n ///\n /// # Examples\n@@ -974,7 +974,7 @@ impl<T> JoinHandle<T> {\n     /// to [`panic`].\n     ///\n     /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`panic!`]: ../../std/macro.panic.html\n+    /// [`panic`]: ../../std/macro.panic.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "af7eaeb3106b2e73151cbd08a108fd44f3e5b8a7", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -154,14 +154,12 @@ impl Duration {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(duration_checked_ops)]\n-    ///\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)), Some(Duration::new(0, 1)));\n     /// assert_eq!(Duration::new(1, 0).checked_add(Duration::new(std::u64::MAX, 0)), None);\n     /// ```\n-    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]\n     pub fn checked_add(self, rhs: Duration) -> Option<Duration> {\n         if let Some(mut secs) = self.secs.checked_add(rhs.secs) {\n@@ -194,14 +192,12 @@ impl Duration {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(duration_checked_ops)]\n-    ///\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 1).checked_sub(Duration::new(0, 0)), Some(Duration::new(0, 1)));\n     /// assert_eq!(Duration::new(0, 0).checked_sub(Duration::new(0, 1)), None);\n     /// ```\n-    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]\n     pub fn checked_sub(self, rhs: Duration) -> Option<Duration> {\n         if let Some(mut secs) = self.secs.checked_sub(rhs.secs) {\n@@ -232,14 +228,12 @@ impl Duration {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(duration_checked_ops)]\n-    ///\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 500_000_001).checked_mul(2), Some(Duration::new(1, 2)));\n     /// assert_eq!(Duration::new(std::u64::MAX - 1, 0).checked_mul(2), None);\n     /// ```\n-    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]\n     pub fn checked_mul(self, rhs: u32) -> Option<Duration> {\n         // Multiply nanoseconds as u64, because it cannot overflow that way.\n@@ -269,15 +263,13 @@ impl Duration {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(duration_checked_ops)]\n-    ///\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(2, 0).checked_div(2), Some(Duration::new(1, 0)));\n     /// assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n     /// assert_eq!(Duration::new(2, 0).checked_div(0), None);\n     /// ```\n-    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]\n     pub fn checked_div(self, rhs: u32) -> Option<Duration> {\n         if rhs != 0 {"}, {"sha": "0f0c6d0ca83f5f01a333de4f542a9755f7966786", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -80,6 +80,28 @@ impl Lit {\n     }\n }\n \n+fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n+    let ident_token: Token = Ident(ident);\n+\n+    !ident_token.is_any_keyword() ||\n+    ident_token.is_path_segment_keyword() ||\n+    [\n+        keywords::Box.name(),\n+        keywords::Break.name(),\n+        keywords::Continue.name(),\n+        keywords::False.name(),\n+        keywords::For.name(),\n+        keywords::If.name(),\n+        keywords::Loop.name(),\n+        keywords::Match.name(),\n+        keywords::Move.name(),\n+        keywords::Return.name(),\n+        keywords::True.name(),\n+        keywords::Unsafe.name(),\n+        keywords::While.name(),\n+    ].contains(&ident.name)\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug)]\n pub enum Token {\n     /* Expression-operator symbols. */\n@@ -163,7 +185,7 @@ impl Token {\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {\n             OpenDelim(..)               => true,\n-            Ident(..)                   => true,\n+            Ident(ident)                => ident_can_begin_expr(ident),\n             Literal(..)                 => true,\n             Not                         => true,\n             BinOp(Minus)                => true,"}, {"sha": "2a14b3da7b7d01ecc43cb056f5bbca9fc7fe9ecf", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -269,7 +269,7 @@ LARGE_INTEGER increment_all_parts(LARGE_INTEGER li) {\n     return li;\n }\n \n-#if !(defined(WIN32) || defined(_WIN32) || defined(__WIN32)) && defined(__amd64__)\n+#if __SIZEOF_INT128__ == 16\n \n unsigned __int128 identity(unsigned __int128 a) {\n     return a;"}, {"sha": "4ba9c3382f35d4792219ac0f5b54f559eefcaf6d", "filename": "src/test/compile-fail/E0117.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2FE0117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2FE0117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0117.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -11,6 +11,7 @@\n impl Drop for u32 {} //~ ERROR E0117\n //~^ NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n+//~| NOTE define and implement a trait or new type instead\n \n fn main() {\n }"}, {"sha": "1131e8e1b01cae69a1c19043442f149ce935e3c7", "filename": "src/test/compile-fail/E0206.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2FE0206.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2FE0206.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0206.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -16,6 +16,7 @@ impl Copy for Foo { }\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n //~| NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n+//~| NOTE define and implement a trait or new type instead\n \n #[derive(Copy, Clone)]\n struct Bar;"}, {"sha": "a49cfaa17606dfcad53844dd0f3351440a9dd77f", "filename": "src/test/compile-fail/binary-op-on-double-ref.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2Fbinary-op-on-double-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2Fbinary-op-on-double-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinary-op-on-double-ref.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let vr = v.iter().filter(|x| {\n+        x % 2 == 0\n+        //~^ ERROR binary operation `%` cannot be applied to type `&&{integer}`\n+        //~| NOTE this is a reference of type that `%` can be applied to\n+        //~| NOTE an implementation of `std::ops::Rem` might be missing for `&&{integer}`\n+    });\n+    println!(\"{:?}\", vr);\n+}"}, {"sha": "68f219c6ed9935830b40f714c3a1a4be42dcc544", "filename": "src/test/compile-fail/can-begin-expr-check.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2Fcan-begin-expr-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2Fcan-begin-expr-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcan-begin-expr-check.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+\n+    return;\n+    return ();\n+    return as ();\n+    return return as ();\n+    return return return;\n+\n+    return if true {\n+        ()\n+    } else {\n+        ()\n+    };\n+\n+    loop {\n+        return break as ();\n+    }\n+\n+    return enum; //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `enum`\n+}"}, {"sha": "fe121a3bc48ffbaac5a6f07e5b7eedbed60f4bb3", "filename": "src/test/compile-fail/coherence-impls-copy.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -37,6 +37,7 @@ impl Copy for (MyType, MyType) {}\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n //~| NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n+//~| NOTE define and implement a trait or new type instead\n \n impl Copy for &'static NotSync {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n@@ -46,15 +47,17 @@ impl Copy for [MyType] {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n //~| NOTE type is not a structure or enumeration\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n-//~| NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n+//~| NOTE define and implement a trait or new type instead\n+//~| NOTE impl doesn't use types inside crate\n \n impl Copy for &'static [NotSync] {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n //~| NOTE type is not a structure or enumeration\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n //~| NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n+//~| NOTE define and implement a trait or new type instead\n \n fn main() {\n }"}, {"sha": "f85422f76d40ee0d492fe6f219b2e62d9c7ed848", "filename": "src/test/compile-fail/str-concat-on-double-ref.rs", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2Fstr-concat-on-double-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2Fstr-concat-on-double-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstr-concat-on-double-ref.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Void {}\n-\n fn main() {\n-    let x: Result<u32, &'static Void> = Ok(23);\n-    let _ = match x {   //~ ERROR non-exhaustive\n-        Ok(n) => n,\n-    };\n+    let a: &String = &\"1\".to_owned();\n+    let b: &str = &\"2\";\n+    let c = a + b;\n+    //~^ ERROR binary operation `+` cannot be applied to type `&std::string::String`\n+    //~| NOTE an implementation of `std::ops::Add` might be missing for `&std::string::String`\n+    println!(\"{:?}\", c);\n }\n-", "previous_filename": "src/test/compile-fail/uninhabited-reference-type-feature-gated.rs"}, {"sha": "0f8b0a6c238d08f03c4d2ae88554f4c3775313e5", "filename": "src/test/compile-fail/uninhabited-matches-feature-gated.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(slice_patterns)]\n+\n+enum Void {}\n+\n+fn main() {\n+    let x: Result<u32, &'static Void> = Ok(23);\n+    let _ = match x {   //~ ERROR non-exhaustive\n+        Ok(n) => n,\n+    };\n+\n+    let x: &Void = unsafe { std::mem::uninitialized() };\n+    let _ = match x {};\n+    //~^ ERROR non-exhaustive\n+\n+    let x: (Void,) = unsafe { std::mem::uninitialized() };\n+    let _ = match x {};\n+    //~^ ERROR non-exhaustive\n+\n+    let x: [Void; 1] = unsafe { std::mem::uninitialized() };\n+    let _ = match x {};\n+    //~^ ERROR non-exhaustive\n+\n+    let x: &[Void] = unsafe { std::mem::uninitialized() };\n+    let _ = match x {   //~ ERROR non-exhaustive\n+        &[] => (),\n+    };\n+\n+    let x: Void = unsafe { std::mem::uninitialized() };\n+    let _ = match x {}; // okay\n+\n+    let x: Result<u32, Void> = Ok(23);\n+    let _ = match x {   //~ ERROR non-exhaustive\n+        Ok(x) => x,\n+    };\n+\n+    let x: Result<u32, Void> = Ok(23);\n+    let Ok(x) = x;\n+    //~^ ERROR refutable\n+}\n+"}, {"sha": "8ce1f744dee17c73829987eee2be79679aafa8dc", "filename": "src/test/run-pass/extern_fat_drop.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Frun-pass%2Fextern_fat_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftest%2Frun-pass%2Fextern_fat_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern_fat_drop.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -10,8 +10,6 @@\n \n // aux-build:fat_drop.rs\n \n-#![feature(drop_in_place)]\n-\n extern crate fat_drop;\n \n fn main() {"}, {"sha": "4b876753b1fea48e92a80fe5a59a4eda790a407b", "filename": "src/tools/build-manifest/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FCargo.toml?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"build-manifest\"\n+version = \"0.1.0\"\n+authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+\n+[dependencies]\n+toml = \"0.1\"\n+rustc-serialize = \"0.3\""}, {"sha": "8c15a6630a33c9139787177ed56a99b74cbc6449", "filename": "src/tools/build-manifest/src/main.rs", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f8a296475d8bc27dfa48ec1053cec8fa2f73673/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=0f8a296475d8bc27dfa48ec1053cec8fa2f73673", "patch": "@@ -0,0 +1,404 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate toml;\n+extern crate rustc_serialize;\n+\n+use std::collections::HashMap;\n+use std::env;\n+use std::fs::File;\n+use std::io::{self, Read, Write};\n+use std::path::{PathBuf, Path};\n+use std::process::{Command, Stdio};\n+\n+static HOSTS: &'static [&'static str] = &[\n+    \"aarch64-unknown-linux-gnu\",\n+    \"arm-unknown-linux-gnueabi\",\n+    \"arm-unknown-linux-gnueabihf\",\n+    \"armv7-unknown-linux-gnueabihf\",\n+    \"i686-apple-darwin\",\n+    \"i686-pc-windows-gnu\",\n+    \"i686-pc-windows-msvc\",\n+    \"i686-unknown-linux-gnu\",\n+    \"mips-unknown-linux-gnu\",\n+    \"mips64-unknown-linux-gnuabi64\",\n+    \"mips64el-unknown-linux-gnuabi64\",\n+    \"mipsel-unknown-linux-gnu\",\n+    \"powerpc-unknown-linux-gnu\",\n+    \"powerpc64-unknown-linux-gnu\",\n+    \"powerpc64le-unknown-linux-gnu\",\n+    \"s390x-unknown-linux-gnu\",\n+    \"x86_64-apple-darwin\",\n+    \"x86_64-pc-windows-gnu\",\n+    \"x86_64-pc-windows-msvc\",\n+    \"x86_64-unknown-freebsd\",\n+    \"x86_64-unknown-linux-gnu\",\n+    \"x86_64-unknown-netbsd\",\n+];\n+\n+static TARGETS: &'static [&'static str] = &[\n+    \"aarch64-apple-ios\",\n+    \"aarch64-linux-android\",\n+    \"aarch64-unknown-linux-gnu\",\n+    \"arm-linux-androideabi\",\n+    \"arm-unknown-linux-gnueabi\",\n+    \"arm-unknown-linux-gnueabihf\",\n+    \"arm-unknown-linux-musleabi\",\n+    \"arm-unknown-linux-musleabihf\",\n+    \"armv7-apple-ios\",\n+    \"armv7-linux-androideabi\",\n+    \"armv7-unknown-linux-gnueabihf\",\n+    \"armv7-unknown-linux-musleabihf\",\n+    \"armv7s-apple-ios\",\n+    \"asmjs-unknown-emscripten\",\n+    \"i386-apple-ios\",\n+    \"i586-pc-windows-msvc\",\n+    \"i586-unknown-linux-gnu\",\n+    \"i686-apple-darwin\",\n+    \"i686-linux-android\",\n+    \"i686-pc-windows-gnu\",\n+    \"i686-pc-windows-msvc\",\n+    \"i686-unknown-freebsd\",\n+    \"i686-unknown-linux-gnu\",\n+    \"i686-unknown-linux-musl\",\n+    \"mips-unknown-linux-gnu\",\n+    \"mips-unknown-linux-musl\",\n+    \"mips64-unknown-linux-gnuabi64\",\n+    \"mips64el-unknown-linux-gnuabi64\",\n+    \"mipsel-unknown-linux-gnu\",\n+    \"mipsel-unknown-linux-musl\",\n+    \"powerpc-unknown-linux-gnu\",\n+    \"powerpc64-unknown-linux-gnu\",\n+    \"powerpc64le-unknown-linux-gnu\",\n+    \"s390x-unknown-linux-gnu\",\n+    \"wasm32-unknown-emscripten\",\n+    \"x86_64-apple-darwin\",\n+    \"x86_64-apple-ios\",\n+    \"x86_64-pc-windows-gnu\",\n+    \"x86_64-pc-windows-msvc\",\n+    \"x86_64-rumprun-netbsd\",\n+    \"x86_64-unknown-freebsd\",\n+    \"x86_64-unknown-linux-gnu\",\n+    \"x86_64-unknown-linux-musl\",\n+    \"x86_64-unknown-netbsd\",\n+];\n+\n+static MINGW: &'static [&'static str] = &[\n+    \"i686-pc-windows-gnu\",\n+    \"x86_64-pc-windows-gnu\",\n+];\n+\n+#[derive(RustcEncodable)]\n+struct Manifest {\n+    manifest_version: String,\n+    date: String,\n+    pkg: HashMap<String, Package>,\n+}\n+\n+#[derive(RustcEncodable)]\n+struct Package {\n+    version: String,\n+    target: HashMap<String, Target>,\n+}\n+\n+#[derive(RustcEncodable)]\n+struct Target {\n+    available: bool,\n+    url: Option<String>,\n+    hash: Option<String>,\n+    components: Option<Vec<Component>>,\n+    extensions: Option<Vec<Component>>,\n+}\n+\n+#[derive(RustcEncodable)]\n+struct Component {\n+    pkg: String,\n+    target: String,\n+}\n+\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+    })\n+}\n+\n+struct Builder {\n+    channel: String,\n+    input: PathBuf,\n+    output: PathBuf,\n+    gpg_passphrase: String,\n+    digests: HashMap<String, String>,\n+    s3_address: String,\n+    date: String,\n+    rust_version: String,\n+    cargo_version: String,\n+}\n+\n+fn main() {\n+    let mut args = env::args().skip(1);\n+    let input = PathBuf::from(args.next().unwrap());\n+    let output = PathBuf::from(args.next().unwrap());\n+    let date = args.next().unwrap();\n+    let channel = args.next().unwrap();\n+    let s3_address = args.next().unwrap();\n+    let mut passphrase = String::new();\n+    t!(io::stdin().read_to_string(&mut passphrase));\n+\n+    Builder {\n+        channel: channel,\n+        input: input,\n+        output: output,\n+        gpg_passphrase: passphrase,\n+        digests: HashMap::new(),\n+        s3_address: s3_address,\n+        date: date,\n+        rust_version: String::new(),\n+        cargo_version: String::new(),\n+    }.build();\n+}\n+\n+impl Builder {\n+    fn build(&mut self) {\n+        self.rust_version = self.version(\"rust\", \"x86_64-unknown-linux-gnu\");\n+        self.cargo_version = self.version(\"cargo\", \"x86_64-unknown-linux-gnu\");\n+\n+        self.digest_and_sign();\n+        let manifest = self.build_manifest();\n+        let manifest = toml::encode(&manifest).to_string();\n+\n+        let filename = format!(\"channel-rust-{}.toml\", self.channel);\n+        self.write_manifest(&manifest, &filename);\n+\n+        if self.channel != \"beta\" && self.channel != \"nightly\" {\n+            self.write_manifest(&manifest, \"channel-rust-stable.toml\");\n+        }\n+    }\n+\n+    fn digest_and_sign(&mut self) {\n+        for file in t!(self.input.read_dir()).map(|e| t!(e).path()) {\n+            let filename = file.file_name().unwrap().to_str().unwrap();\n+            let digest = self.hash(&file);\n+            self.sign(&file);\n+            assert!(self.digests.insert(filename.to_string(), digest).is_none());\n+        }\n+    }\n+\n+    fn build_manifest(&mut self) -> Manifest {\n+        let mut manifest = Manifest {\n+            manifest_version: \"2\".to_string(),\n+            date: self.date.to_string(),\n+            pkg: HashMap::new(),\n+        };\n+\n+        self.package(\"rustc\", &mut manifest.pkg, HOSTS);\n+        self.package(\"cargo\", &mut manifest.pkg, HOSTS);\n+        self.package(\"rust-mingw\", &mut manifest.pkg, MINGW);\n+        self.package(\"rust-std\", &mut manifest.pkg, TARGETS);\n+        self.package(\"rust-docs\", &mut manifest.pkg, TARGETS);\n+        self.package(\"rust-src\", &mut manifest.pkg, &[\"*\"]);\n+\n+        let mut pkg = Package {\n+            version: self.cached_version(\"rust\").to_string(),\n+            target: HashMap::new(),\n+        };\n+        for host in HOSTS {\n+            let filename = self.filename(\"rust\", host);\n+            let digest = match self.digests.remove(&filename) {\n+                Some(digest) => digest,\n+                None => {\n+                    pkg.target.insert(host.to_string(), Target {\n+                        available: false,\n+                        url: None,\n+                        hash: None,\n+                        components: None,\n+                        extensions: None,\n+                    });\n+                    continue\n+                }\n+            };\n+            let mut components = Vec::new();\n+            let mut extensions = Vec::new();\n+\n+            // rustc/rust-std/cargo are all required, and so is rust-mingw if it's\n+            // available for the target.\n+            components.extend(vec![\n+                Component { pkg: \"rustc\".to_string(), target: host.to_string() },\n+                Component { pkg: \"rust-std\".to_string(), target: host.to_string() },\n+                Component { pkg: \"cargo\".to_string(), target: host.to_string() },\n+            ]);\n+            if host.contains(\"pc-windows-gnu\") {\n+                components.push(Component {\n+                    pkg: \"rust-mingw\".to_string(),\n+                    target: host.to_string(),\n+                });\n+            }\n+\n+            // Docs, other standard libraries, and the source package are all\n+            // optional.\n+            extensions.push(Component {\n+                pkg: \"rust-docs\".to_string(),\n+                target: host.to_string(),\n+            });\n+            for target in TARGETS {\n+                if target != host {\n+                    extensions.push(Component {\n+                        pkg: \"rust-std\".to_string(),\n+                        target: target.to_string(),\n+                    });\n+                }\n+            }\n+            extensions.push(Component {\n+                pkg: \"rust-src\".to_string(),\n+                target: \"*\".to_string(),\n+            });\n+\n+            pkg.target.insert(host.to_string(), Target {\n+                available: true,\n+                url: Some(self.url(\"rust\", host)),\n+                hash: Some(to_hex(digest.as_ref())),\n+                components: Some(components),\n+                extensions: Some(extensions),\n+            });\n+        }\n+        manifest.pkg.insert(\"rust\".to_string(), pkg);\n+\n+        return manifest\n+    }\n+\n+    fn package(&mut self,\n+               pkgname: &str,\n+               dst: &mut HashMap<String, Package>,\n+               targets: &[&str]) {\n+        let targets = targets.iter().map(|name| {\n+            let filename = self.filename(pkgname, name);\n+            let digest = match self.digests.remove(&filename) {\n+                Some(digest) => digest,\n+                None => {\n+                    return (name.to_string(), Target {\n+                        available: false,\n+                        url: None,\n+                        hash: None,\n+                        components: None,\n+                        extensions: None,\n+                    })\n+                }\n+            };\n+\n+            (name.to_string(), Target {\n+                available: true,\n+                url: Some(self.url(pkgname, name)),\n+                hash: Some(digest),\n+                components: None,\n+                extensions: None,\n+            })\n+        }).collect();\n+\n+        dst.insert(pkgname.to_string(), Package {\n+            version: self.cached_version(pkgname).to_string(),\n+            target: targets,\n+        });\n+    }\n+\n+    fn url(&self, component: &str, target: &str) -> String {\n+        format!(\"{}/{}/{}\",\n+                self.s3_address,\n+                self.date,\n+                self.filename(component, target))\n+    }\n+\n+    fn filename(&self, component: &str, target: &str) -> String {\n+        if component == \"rust-src\" {\n+            format!(\"rust-src-{}.tar.gz\", self.channel)\n+        } else {\n+            format!(\"{}-{}-{}.tar.gz\", component, self.channel, target)\n+        }\n+    }\n+\n+    fn cached_version(&self, component: &str) -> &str {\n+        if component == \"cargo\" {\n+            &self.cargo_version\n+        } else {\n+            &self.rust_version\n+        }\n+    }\n+\n+    fn version(&self, component: &str, target: &str) -> String {\n+        let mut cmd = Command::new(\"tar\");\n+        let filename = self.filename(component, target);\n+        cmd.arg(\"xf\")\n+           .arg(self.input.join(&filename))\n+           .arg(format!(\"{}/version\", filename.replace(\".tar.gz\", \"\")))\n+           .arg(\"-O\");\n+        let version = t!(cmd.output());\n+        if !version.status.success() {\n+            panic!(\"failed to learn version:\\n\\n{:?}\\n\\n{}\\n\\n{}\",\n+                   cmd,\n+                   String::from_utf8_lossy(&version.stdout),\n+                   String::from_utf8_lossy(&version.stderr));\n+        }\n+        String::from_utf8_lossy(&version.stdout).trim().to_string()\n+    }\n+\n+    fn hash(&self, path: &Path) -> String {\n+        let sha = t!(Command::new(\"shasum\")\n+                        .arg(\"-a\").arg(\"256\")\n+                        .arg(path)\n+                        .output());\n+        assert!(sha.status.success());\n+\n+        let filename = path.file_name().unwrap().to_str().unwrap();\n+        let sha256 = self.output.join(format!(\"{}.sha256\", filename));\n+        t!(t!(File::create(&sha256)).write_all(&sha.stdout));\n+\n+        let stdout = String::from_utf8_lossy(&sha.stdout);\n+        stdout.split_whitespace().next().unwrap().to_string()\n+    }\n+\n+    fn sign(&self, path: &Path) {\n+        let filename = path.file_name().unwrap().to_str().unwrap();\n+        let asc = self.output.join(format!(\"{}.asc\", filename));\n+        println!(\"signing: {:?}\", path);\n+        let mut cmd = Command::new(\"gpg\");\n+        cmd.arg(\"--no-tty\")\n+            .arg(\"--yes\")\n+            .arg(\"--passphrase-fd\").arg(\"0\")\n+            .arg(\"--armor\")\n+            .arg(\"--output\").arg(&asc)\n+            .arg(\"--detach-sign\").arg(path)\n+            .stdin(Stdio::piped());\n+        let mut child = t!(cmd.spawn());\n+        t!(child.stdin.take().unwrap().write_all(self.gpg_passphrase.as_bytes()));\n+        assert!(t!(child.wait()).success());\n+    }\n+\n+    fn write_manifest(&self, manifest: &str, name: &str) {\n+        let dst = self.output.join(name);\n+        t!(t!(File::create(&dst)).write_all(manifest.as_bytes()));\n+        self.hash(&dst);\n+        self.sign(&dst);\n+    }\n+}\n+\n+fn to_hex(digest: &[u8]) -> String {\n+    let mut ret = String::new();\n+    for byte in digest {\n+        ret.push(hex((byte & 0xf0) >> 4));\n+        ret.push(hex(byte & 0xf));\n+    }\n+    return ret;\n+\n+    fn hex(b: u8) -> char {\n+        match b {\n+            0...9 => (b'0' + b) as char,\n+            _ => (b'a' + b - 10) as char,\n+        }\n+    }\n+}"}]}