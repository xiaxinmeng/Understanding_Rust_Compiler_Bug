{"sha": "933def408c48e9b20c478cf4cad9ae2d20b3c5df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzM2RlZjQwOGM0OGU5YjIwYzQ3OGNmNGNhZDlhZTJkMjBiM2M1ZGY=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-12-28T00:43:01Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-12-29T04:16:03Z"}, "message": "Stop passing duplicate parameters in expand", "tree": {"sha": "55cf1e0e6e70d1d92dad6e2350f7fd05a8753d5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55cf1e0e6e70d1d92dad6e2350f7fd05a8753d5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/933def408c48e9b20c478cf4cad9ae2d20b3c5df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/933def408c48e9b20c478cf4cad9ae2d20b3c5df", "html_url": "https://github.com/rust-lang/rust/commit/933def408c48e9b20c478cf4cad9ae2d20b3c5df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/933def408c48e9b20c478cf4cad9ae2d20b3c5df/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "711d5106bcd5e2b42d59b12f646f406c572def20", "url": "https://api.github.com/repos/rust-lang/rust/commits/711d5106bcd5e2b42d59b12f646f406c572def20", "html_url": "https://github.com/rust-lang/rust/commit/711d5106bcd5e2b42d59b12f646f406c572def20"}], "stats": {"total": 220, "additions": 92, "deletions": 128}, "files": [{"sha": "37a1ae6884dda6008fa37173e9a157c484c37956", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/933def408c48e9b20c478cf4cad9ae2d20b3c5df/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933def408c48e9b20c478cf4cad9ae2d20b3c5df/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=933def408c48e9b20c478cf4cad9ae2d20b3c5df", "patch": "@@ -324,12 +324,11 @@ impl ExtCtxt {\n         loop {\n             match e.node {\n                 ast::ExprMac(..) => {\n-                    let extsbox = @mut syntax_expander_table();\n                     let expander = expand::MacroExpander {\n-                        extsbox: extsbox,\n+                        extsbox: @mut syntax_expander_table(),\n                         cx: self,\n                     };\n-                    e = expand::expand_expr(extsbox, self, e, &expander);\n+                    e = expand::expand_expr(e, &expander);\n                 }\n                 _ => return e\n             }"}, {"sha": "31c44b7e5744b71927085d7a2f14a4ee8a060191", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 90, "deletions": 125, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/933def408c48e9b20c478cf4cad9ae2d20b3c5df/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933def408c48e9b20c478cf4cad9ae2d20b3c5df/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=933def408c48e9b20c478cf4cad9ae2d20b3c5df", "patch": "@@ -31,11 +31,7 @@ use util::small_vector::SmallVector;\n \n use std::vec;\n \n-pub fn expand_expr(extsbox: @mut SyntaxEnv,\n-                   cx: &ExtCtxt,\n-                   e: @ast::Expr,\n-                   fld: &MacroExpander)\n-                   -> @ast::Expr {\n+pub fn expand_expr(e: @ast::Expr, fld: &MacroExpander) -> @ast::Expr {\n     match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n@@ -49,22 +45,22 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                 // Token-tree macros:\n                 mac_invoc_tt(ref pth, ref tts, ctxt) => {\n                     if (pth.segments.len() > 1u) {\n-                        cx.span_fatal(\n+                        fld.cx.span_fatal(\n                             pth.span,\n                             format!(\"expected macro name without module \\\n                                   separators\"));\n                     }\n                     let extname = &pth.segments[0].identifier;\n                     let extnamestr = ident_to_str(extname);\n                     // leaving explicit deref here to highlight unbox op:\n-                    match (*extsbox).find(&extname.name) {\n+                    match (*fld.extsbox).find(&extname.name) {\n                         None => {\n-                            cx.span_fatal(\n+                            fld.cx.span_fatal(\n                                 pth.span,\n                                 format!(\"macro undefined: '{}'\", extnamestr))\n                         }\n                         Some(@SE(NormalTT(expandfun, exp_span))) => {\n-                            cx.bt_push(ExpnInfo {\n+                            fld.cx.bt_push(ExpnInfo {\n                                 call_site: e.span,\n                                 callee: NameAndSpan {\n                                     name: extnamestr,\n@@ -81,17 +77,17 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             // be the root of the call stack. That's the most\n                             // relevant span and it's the actual invocation of\n                             // the macro.\n-                            let mac_span = original_span(cx);\n+                            let mac_span = original_span(fld.cx);\n \n                             let expanded =\n-                                match expandfun.expand(cx,\n+                                match expandfun.expand(fld.cx,\n                                                        mac_span.call_site,\n                                                        marked_before,\n                                                        marked_ctxt) {\n                                     MRExpr(e) => e,\n                                     MRAny(any_macro) => any_macro.make_expr(),\n                                     _ => {\n-                                        cx.span_fatal(\n+                                        fld.cx.span_fatal(\n                                             pth.span,\n                                             format!(\n                                                 \"non-expr macro in expr pos: {}\",\n@@ -109,7 +105,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             // node here?\n                             let fully_expanded =\n                                 fld.fold_expr(marked_after).node.clone();\n-                            cx.bt_pop();\n+                            fld.cx.bt_pop();\n \n                             @ast::Expr {\n                                 id: ast::DUMMY_NODE_ID,\n@@ -118,7 +114,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             }\n                         }\n                         _ => {\n-                            cx.span_fatal(\n+                            fld.cx.span_fatal(\n                                 pth.span,\n                                 format!(\"'{}' is not a tt-style macro\", extnamestr)\n                             )\n@@ -152,46 +148,47 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n             // }\n \n             let local_ident = token::gensym_ident(\"i\");\n-            let next_ident = cx.ident_of(\"next\");\n-            let none_ident = cx.ident_of(\"None\");\n+            let next_ident = fld.cx.ident_of(\"next\");\n+            let none_ident = fld.cx.ident_of(\"None\");\n \n-            let local_path = cx.path_ident(span, local_ident);\n-            let some_path = cx.path_ident(span, cx.ident_of(\"Some\"));\n+            let local_path = fld.cx.path_ident(span, local_ident);\n+            let some_path = fld.cx.path_ident(span, fld.cx.ident_of(\"Some\"));\n \n             // `let i = &mut <src_expr>`\n-            let iter_decl_stmt = cx.stmt_let(span, false, local_ident,\n-                                             cx.expr_mut_addr_of(span, src_expr));\n+            let iter_decl_stmt = fld.cx.stmt_let(span, false, local_ident,\n+                                                 fld.cx.expr_mut_addr_of(span, src_expr));\n \n             // `None => break ['<ident>];`\n             let none_arm = {\n                 // FIXME #6993: this map goes away:\n-                let break_expr = cx.expr(span, ast::ExprBreak(opt_ident.map(|x| x.name)));\n-                let none_pat = cx.pat_ident(span, none_ident);\n-                cx.arm(span, ~[none_pat], break_expr)\n+                let break_expr = fld.cx.expr(span, ast::ExprBreak(opt_ident.map(|x| x.name)));\n+                let none_pat = fld.cx.pat_ident(span, none_ident);\n+                fld.cx.arm(span, ~[none_pat], break_expr)\n             };\n \n             // `Some(<src_pat>) => <src_loop_block>`\n             let some_arm =\n-                cx.arm(span,\n-                       ~[cx.pat_enum(span, some_path, ~[src_pat])],\n-                       cx.expr_block(src_loop_block));\n+                fld.cx.arm(span,\n+                           ~[fld.cx.pat_enum(span, some_path, ~[src_pat])],\n+                           fld.cx.expr_block(src_loop_block));\n \n             // `match i.next() { ... }`\n             let match_expr = {\n                 let next_call_expr =\n-                    cx.expr_method_call(span, cx.expr_path(local_path), next_ident, ~[]);\n+                    fld.cx.expr_method_call(span, fld.cx.expr_path(local_path), next_ident, ~[]);\n \n-                cx.expr_match(span, next_call_expr, ~[none_arm, some_arm])\n+                fld.cx.expr_match(span, next_call_expr, ~[none_arm, some_arm])\n             };\n \n             // ['ident:] loop { ... }\n-            let loop_expr = cx.expr(span,\n-                                    ast::ExprLoop(cx.block_expr(match_expr), opt_ident));\n+            let loop_expr = fld.cx.expr(span,\n+                                        ast::ExprLoop(fld.cx.block_expr(match_expr),\n+                                                      opt_ident));\n \n             // `{ let ... ;  loop { ... } }`\n-            let block = cx.block(span,\n-                                 ~[iter_decl_stmt],\n-                                 Some(loop_expr));\n+            let block = fld.cx.block(span,\n+                                     ~[iter_decl_stmt],\n+                                     Some(loop_expr));\n \n             @ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n@@ -213,11 +210,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n //\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n-pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n-                        cx: &ExtCtxt,\n-                        module_: &ast::_mod,\n-                        fld: &MacroExpander)\n-                        -> ast::_mod {\n+pub fn expand_mod_items(module_: &ast::_mod, fld: &MacroExpander) -> ast::_mod {\n     // Fold the contents first:\n     let module_ = noop_fold_mod(module_, fld);\n \n@@ -228,18 +221,18 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n         item.attrs.rev_iter().fold(~[*item], |items, attr| {\n             let mname = attr.name();\n \n-            match (*extsbox).find(&intern(mname)) {\n+            match (*fld.extsbox).find(&intern(mname)) {\n               Some(@SE(ItemDecorator(dec_fn))) => {\n-                  cx.bt_push(ExpnInfo {\n+                  fld.cx.bt_push(ExpnInfo {\n                       call_site: attr.span,\n                       callee: NameAndSpan {\n                           name: mname,\n                           format: MacroAttribute,\n                           span: None\n                       }\n                   });\n-                  let r = dec_fn(cx, attr.span, attr.node.value, items);\n-                  cx.bt_pop();\n+                  let r = dec_fn(fld.cx, attr.span, attr.node.value, items);\n+                  fld.cx.bt_pop();\n                   r\n               },\n               _ => items,\n@@ -270,20 +263,16 @@ macro_rules! with_exts_frame (\n static special_block_name : &'static str = \" block\";\n \n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(extsbox: @mut SyntaxEnv,\n-                   cx: &ExtCtxt,\n-                   it: @ast::item,\n-                   fld: &MacroExpander)\n-                   -> SmallVector<@ast::item> {\n+pub fn expand_item(it: @ast::item, fld: &MacroExpander) -> SmallVector<@ast::item> {\n     match it.node {\n-        ast::item_mac(..) => expand_item_mac(extsbox, cx, it, fld),\n+        ast::item_mac(..) => expand_item_mac(it, fld),\n         ast::item_mod(_) | ast::item_foreign_mod(_) => {\n-            cx.mod_push(it.ident);\n+            fld.cx.mod_push(it.ident);\n             let macro_escape = contains_macro_escape(it.attrs);\n-            let result = with_exts_frame!(extsbox,\n+            let result = with_exts_frame!(fld.extsbox,\n                                           macro_escape,\n                                           noop_fold_item(it, fld));\n-            cx.mod_pop();\n+            fld.cx.mod_pop();\n             result\n         },\n         _ => noop_fold_item(it, fld)\n@@ -297,10 +286,7 @@ pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n-                       cx: &ExtCtxt,\n-                       it: @ast::item,\n-                       fld: &MacroExpander)\n+pub fn expand_item_mac(it: @ast::item, fld: &MacroExpander)\n                        -> SmallVector<@ast::item> {\n     let (pth, tts, ctxt) = match it.node {\n         item_mac(codemap::Spanned {\n@@ -309,24 +295,24 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         }) => {\n             (pth, (*tts).clone(), ctxt)\n         }\n-        _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n+        _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n     let fm = fresh_mark();\n-    let expanded = match (*extsbox).find(&extname.name) {\n-        None => cx.span_fatal(pth.span,\n-                              format!(\"macro undefined: '{}!'\", extnamestr)),\n+    let expanded = match (*fld.extsbox).find(&extname.name) {\n+        None => fld.cx.span_fatal(pth.span,\n+                                  format!(\"macro undefined: '{}!'\", extnamestr)),\n \n         Some(@SE(NormalTT(expander, span))) => {\n             if it.ident.name != parse::token::special_idents::invalid.name {\n-                cx.span_fatal(pth.span,\n-                              format!(\"macro {}! expects no ident argument, \\\n-                                    given '{}'\", extnamestr,\n-                                   ident_to_str(&it.ident)));\n+                fld.cx.span_fatal(pth.span,\n+                                  format!(\"macro {}! expects no ident argument, \\\n+                                           given '{}'\", extnamestr,\n+                                           ident_to_str(&it.ident)));\n             }\n-            cx.bt_push(ExpnInfo {\n+            fld.cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n@@ -337,15 +323,15 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             // mark before expansion:\n             let marked_before = mark_tts(tts,fm);\n             let marked_ctxt = new_mark(fm,ctxt);\n-            expander.expand(cx, it.span, marked_before, marked_ctxt)\n+            expander.expand(fld.cx, it.span, marked_before, marked_ctxt)\n         }\n         Some(@SE(IdentTT(expander, span))) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n-                cx.span_fatal(pth.span,\n-                              format!(\"macro {}! expects an ident argument\",\n-                                   extnamestr));\n+                fld.cx.span_fatal(pth.span,\n+                                  format!(\"macro {}! expects an ident argument\",\n+                                          extnamestr));\n             }\n-            cx.bt_push(ExpnInfo {\n+            fld.cx.bt_push(ExpnInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n@@ -356,10 +342,11 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             // mark before expansion:\n             let marked_tts = mark_tts(tts,fm);\n             let marked_ctxt = new_mark(fm,ctxt);\n-            expander.expand(cx, it.span, it.ident, marked_tts, marked_ctxt)\n+            expander.expand(fld.cx, it.span, it.ident, marked_tts, marked_ctxt)\n         }\n-        _ => cx.span_fatal(\n-            it.span, format!(\"{}! is not legal in item position\", extnamestr))\n+        _ => fld.cx.span_fatal(it.span,\n+                               format!(\"{}! is not legal in item position\",\n+                                       extnamestr))\n     };\n \n     let items = match expanded {\n@@ -369,7 +356,8 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                 .collect()\n         }\n         MRExpr(_) => {\n-            cx.span_fatal(pth.span, format!(\"expr macro in item position: {}\", extnamestr))\n+            fld.cx.span_fatal(pth.span, format!(\"expr macro in item position: {}\",\n+                                                extnamestr))\n         }\n         MRAny(any_macro) => {\n             any_macro.make_items().move_iter()\n@@ -380,11 +368,11 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         MRDef(ref mdef) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one.\n-            insert_macro(*extsbox,intern(mdef.name), @SE((*mdef).ext));\n+            insert_macro(*fld.extsbox,intern(mdef.name), @SE((*mdef).ext));\n             SmallVector::zero()\n         }\n     };\n-    cx.bt_pop();\n+    fld.cx.bt_pop();\n     return items;\n }\n \n@@ -406,11 +394,7 @@ fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n }\n \n // expand a stmt\n-pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n-                   cx: &ExtCtxt,\n-                   s: &Stmt,\n-                   fld: &MacroExpander)\n-                   -> SmallVector<@Stmt> {\n+pub fn expand_stmt(s: &Stmt, fld: &MacroExpander) -> SmallVector<@Stmt> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n     let (pth, tts, semi, ctxt) = match s.node {\n@@ -421,21 +405,21 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 }\n             }\n         }\n-        _ => return expand_non_macro_stmt(*extsbox, s, fld)\n+        _ => return expand_non_macro_stmt(s, fld)\n     };\n     if (pth.segments.len() > 1u) {\n-        cx.span_fatal(pth.span,\n-                      \"expected macro name without module separators\");\n+        fld.cx.span_fatal(pth.span,\n+                          \"expected macro name without module separators\");\n     }\n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n-    let fully_expanded: SmallVector<@Stmt> = match (*extsbox).find(&extname.name) {\n+    let fully_expanded: SmallVector<@Stmt> = match (*fld.extsbox).find(&extname.name) {\n         None => {\n-            cx.span_fatal(pth.span, format!(\"macro undefined: '{}'\", extnamestr))\n+            fld.cx.span_fatal(pth.span, format!(\"macro undefined: '{}'\", extnamestr))\n         }\n \n         Some(@SE(NormalTT(expandfun, exp_span))) => {\n-            cx.bt_push(ExpnInfo {\n+            fld.cx.bt_push(ExpnInfo {\n                 call_site: s.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n@@ -450,9 +434,9 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n             // See the comment in expand_expr for why we want the original span,\n             // not the current mac.span.\n-            let mac_span = original_span(cx);\n+            let mac_span = original_span(fld.cx);\n \n-            let expanded = match expandfun.expand(cx,\n+            let expanded = match expandfun.expand(fld.cx,\n                                                   mac_span.call_site,\n                                                   marked_tts,\n                                                   marked_ctxt) {\n@@ -463,7 +447,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                     }\n                 }\n                 MRAny(any_macro) => any_macro.make_stmt(),\n-                _ => cx.span_fatal(\n+                _ => fld.cx.span_fatal(\n                     pth.span,\n                     format!(\"non-stmt macro in stmt pos: {}\", extnamestr))\n             };\n@@ -472,18 +456,19 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             // Keep going, outside-in.\n             let fully_expanded = fld.fold_stmt(marked_after);\n             if fully_expanded.is_empty() {\n-                cx.span_fatal(pth.span,\n+                fld.cx.span_fatal(pth.span,\n                               \"macro didn't expand to a statement\");\n             }\n-            cx.bt_pop();\n+            fld.cx.bt_pop();\n             fully_expanded.move_iter()\n                     .map(|s| @Spanned { span: s.span, node: s.node.clone() })\n                     .collect()\n         }\n \n         _ => {\n-            cx.span_fatal(pth.span,\n-                          format!(\"'{}' is not a tt-style macro\", extnamestr))\n+            fld.cx.span_fatal(pth.span,\n+                              format!(\"'{}' is not a tt-style macro\",\n+                                      extnamestr))\n         }\n     };\n \n@@ -502,7 +487,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n-fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n+fn expand_non_macro_stmt(s: &Stmt, fld: &MacroExpander)\n                          -> SmallVector<@Stmt> {\n     // is it a let?\n     match s.node {\n@@ -511,7 +496,7 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n             span: stmt_span\n         },\n         node_id) => {\n-            let block_info = get_block_info(exts);\n+            let block_info = get_block_info(*fld.extsbox);\n             let pending_renames = block_info.pending_renames;\n \n             // take it apart:\n@@ -624,20 +609,15 @@ pub fn new_name_finder(idents: ~[ast::Ident]) -> NewNameFinderContext {\n }\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n-pub fn expand_block(extsbox: @mut SyntaxEnv,\n-                    _: &ExtCtxt,\n-                    blk: &Block,\n-                    fld: &MacroExpander)\n-                    -> P<Block> {\n+pub fn expand_block(blk: &Block, fld: &MacroExpander) -> P<Block> {\n     // see note below about treatment of exts table\n-    with_exts_frame!(extsbox,false,\n-                     expand_block_elts(*extsbox, blk, fld))\n+    with_exts_frame!(fld.extsbox,false,\n+                     expand_block_elts(blk, fld))\n }\n \n // expand the elements of a block.\n-pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n-                         -> P<Block> {\n-    let block_info = get_block_info(exts);\n+pub fn expand_block_elts(b: &Block, fld: &MacroExpander) -> P<Block> {\n+    let block_info = get_block_info(*fld.extsbox);\n     let pending_renames = block_info.pending_renames;\n     let rename_fld = renames_to_fold(pending_renames);\n     let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n@@ -956,38 +936,23 @@ pub struct MacroExpander<'a> {\n \n impl<'a> ast_fold for MacroExpander<'a> {\n     fn fold_expr(&self, expr: @ast::Expr) -> @ast::Expr {\n-        expand_expr(self.extsbox,\n-                    self.cx,\n-                    expr,\n-                    self)\n+        expand_expr(expr, self)\n     }\n \n     fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n-        expand_mod_items(self.extsbox,\n-                         self.cx,\n-                         module,\n-                         self)\n+        expand_mod_items(module, self)\n     }\n \n     fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n-        expand_item(self.extsbox,\n-                    self.cx,\n-                    item,\n-                    self)\n+        expand_item(item, self)\n     }\n \n     fn fold_stmt(&self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n-        expand_stmt(self.extsbox,\n-                    self.cx,\n-                    stmt,\n-                    self)\n+        expand_stmt(stmt, self)\n     }\n \n     fn fold_block(&self, block: P<Block>) -> P<Block> {\n-        expand_block(self.extsbox,\n-                     self.cx,\n-                     block,\n-                     self)\n+        expand_block(block, self)\n     }\n \n     fn new_span(&self, span: Span) -> Span {"}]}