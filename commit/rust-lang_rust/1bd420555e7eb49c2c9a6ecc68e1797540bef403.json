{"sha": "1bd420555e7eb49c2c9a6ecc68e1797540bef403", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZDQyMDU1NWU3ZWI0OWMyYzlhNmVjYzY4ZTE3OTc1NDBiZWY0MDM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-25T20:06:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-05-21T15:47:30Z"}, "message": "rustc: const-qualify `const fn` function and method calls.", "tree": {"sha": "4f6d735d8defa838107ad0a765994c527b0862a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f6d735d8defa838107ad0a765994c527b0862a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bd420555e7eb49c2c9a6ecc68e1797540bef403", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bd420555e7eb49c2c9a6ecc68e1797540bef403", "html_url": "https://github.com/rust-lang/rust/commit/1bd420555e7eb49c2c9a6ecc68e1797540bef403", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bd420555e7eb49c2c9a6ecc68e1797540bef403/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af3795721cd9ffc591eeeb077df16d3658be150f", "url": "https://api.github.com/repos/rust-lang/rust/commits/af3795721cd9ffc591eeeb077df16d3658be150f", "html_url": "https://github.com/rust-lang/rust/commit/af3795721cd9ffc591eeeb077df16d3658be150f"}], "stats": {"total": 345, "additions": 288, "deletions": 57}, "files": [{"sha": "901afc1d1904e76ff34cb658c813b22dde6b116b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=1bd420555e7eb49c2c9a6ecc68e1797540bef403", "patch": "@@ -262,3 +262,5 @@ pub const tag_item_super_predicates: usize = 0xa3;\n pub const tag_defaulted_trait: usize = 0xa4;\n \n pub const tag_impl_coerce_unsized_kind: usize = 0xa5;\n+\n+pub const tag_items_data_item_constness: usize = 0xa6;"}, {"sha": "f834076e8eab5a8602309addfd9034bb51ec9c25", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=1bd420555e7eb49c2c9a6ecc68e1797540bef403", "patch": "@@ -384,6 +384,11 @@ pub fn is_typedef(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n     decoder::is_typedef(&*cdata, did.node)\n }\n \n+pub fn is_const_fn(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n+    let cdata = cstore.get_crate_data(did.krate);\n+    decoder::is_const_fn(&*cdata, did.node)\n+}\n+\n pub fn get_stability(cstore: &cstore::CStore,\n                      def: ast::DefId)\n                      -> Option<attr::Stability> {"}, {"sha": "ee5fd0202d69e90e1c8652e53bfd7535ebadaaa9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1bd420555e7eb49c2c9a6ecc68e1797540bef403", "patch": "@@ -178,6 +178,19 @@ fn item_visibility(item: rbml::Doc) -> ast::Visibility {\n     }\n }\n \n+fn fn_constness(item: rbml::Doc) -> ast::Constness {\n+    match reader::maybe_get_doc(item, tag_items_data_item_constness) {\n+        None => ast::Constness::NotConst,\n+        Some(constness_doc) => {\n+            match reader::doc_as_u8(constness_doc) as char {\n+                'c' => ast::Constness::Const,\n+                'n' => ast::Constness::NotConst,\n+                _ => panic!(\"unknown constness character\")\n+            }\n+        }\n+    }\n+}\n+\n fn item_sort(item: rbml::Doc) -> Option<char> {\n     let mut ret = None;\n     reader::tagged_docs(item, tag_item_trait_item_sort, |doc| {\n@@ -1525,6 +1538,14 @@ pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n     }\n }\n \n+pub fn is_const_fn(cdata: Cmd, id: ast::NodeId) -> bool {\n+    let item_doc = lookup_item(id, cdata.data());\n+    match fn_constness(item_doc) {\n+        ast::Constness::Const => true,\n+        ast::Constness::NotConst => false,\n+    }\n+}\n+\n fn doc_generics<'tcx>(base_doc: rbml::Doc,\n                       tcx: &ty::ctxt<'tcx>,\n                       cdata: Cmd,"}, {"sha": "f721bb700ed02a590a49d3ca1b4af6b1e22e7e47", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1bd420555e7eb49c2c9a6ecc68e1797540bef403", "patch": "@@ -581,6 +581,16 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n     rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n }\n \n+fn encode_constness(rbml_w: &mut Encoder, constness: ast::Constness) {\n+    rbml_w.start_tag(tag_items_data_item_constness);\n+    let ch = match constness {\n+        ast::Constness::Const => 'c',\n+        ast::Constness::NotConst => 'n',\n+    };\n+    rbml_w.wr_str(&ch.to_string());\n+    rbml_w.end_tag();\n+}\n+\n fn encode_explicit_self(rbml_w: &mut Encoder,\n                         explicit_self: &ty::ExplicitSelfCategory) {\n     let tag = tag_item_trait_method_explicit_self;\n@@ -867,10 +877,14 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_attributes(rbml_w, &impl_item.attrs);\n             let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n-            if any_types || is_default_impl || attr::requests_inline(&impl_item.attrs) {\n+            let needs_inline = any_types || is_default_impl ||\n+                               attr::requests_inline(&impl_item.attrs);\n+            let constness = ast_method.pe_constness();\n+            if needs_inline || constness == ast::Constness::Const {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                impl_item));\n             }\n+            encode_constness(rbml_w, constness);\n             if !any_types {\n                 encode_symbol(ecx, rbml_w, m.def_id.node);\n             }\n@@ -1049,7 +1063,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ast::ItemFn(ref decl, _, _, _, ref generics, _) => {\n+      ast::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1059,12 +1073,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n-        if tps_len > 0 || attr::requests_inline(&item.attrs) {\n+        let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n+        if needs_inline || constness == ast::Constness::Const {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {\n             encode_symbol(ecx, rbml_w, item.id);\n         }\n+        encode_constness(rbml_w, constness);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         encode_method_argument_names(rbml_w, &**decl);"}, {"sha": "aca2e2b473e4ec86747203eb899cec52c9a0a0f6", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 156, "deletions": 37, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=1bd420555e7eb49c2c9a6ecc68e1797540bef403", "patch": "@@ -36,6 +36,7 @@ use util::nodemap::NodeMap;\n use util::ppaux::Repr;\n \n use syntax::ast;\n+use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::visit::{self, Visitor};\n \n@@ -79,6 +80,7 @@ bitflags! {\n #[derive(Copy, Clone, Eq, PartialEq)]\n enum Mode {\n     Const,\n+    ConstFn,\n     Static,\n     StaticMut,\n \n@@ -136,10 +138,87 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         })\n     }\n \n+    fn fn_like(&mut self,\n+               fk: visit::FnKind,\n+               fd: &ast::FnDecl,\n+               b: &ast::Block,\n+               s: Span,\n+               fn_id: ast::NodeId)\n+               -> ConstQualif {\n+        match self.tcx.const_qualif_map.borrow_mut().entry(fn_id) {\n+            Entry::Occupied(entry) => return *entry.get(),\n+            Entry::Vacant(entry) => {\n+                // Prevent infinite recursion on re-entry.\n+                entry.insert(PURE_CONST);\n+            }\n+        }\n+\n+        let mode = match fk {\n+            visit::FkItemFn(_, _, _, ast::Constness::Const, _) => {\n+                Mode::ConstFn\n+            }\n+            visit::FkMethod(_, _, m) => {\n+                if m.pe_constness() == ast::Constness::Const {\n+                    Mode::ConstFn\n+                } else {\n+                    Mode::Var\n+                }\n+            }\n+            _ => Mode::Var\n+        };\n+\n+        // Ensure the arguments are simple, not mutable/by-ref or patterns.\n+        if mode == Mode::ConstFn {\n+            for arg in &fd.inputs {\n+                match arg.pat.node {\n+                    ast::PatIdent(ast::BindByValue(ast::MutImmutable), _, None) => {}\n+                    _ => {\n+                        span_err!(self.tcx.sess, arg.pat.span, E0022,\n+                                  \"arguments of constant functions can only \\\n+                                   be immutable by-value bindings\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        let qualif = self.with_mode(mode, |this| {\n+            this.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, b));\n+            visit::walk_fn(this, fk, fd, b, s);\n+            this.qualif\n+        });\n+\n+        // Keep only bits that aren't affected by function body (NON_ZERO_SIZED),\n+        // and bits that don't change semantics, just optimizations (PREFER_IN_PLACE).\n+        let qualif = qualif & (NON_ZERO_SIZED | PREFER_IN_PLACE);\n+\n+        self.tcx.const_qualif_map.borrow_mut().insert(fn_id, qualif);\n+        qualif\n+    }\n+\n     fn add_qualif(&mut self, qualif: ConstQualif) {\n         self.qualif = self.qualif | qualif;\n     }\n \n+    /// Returns true if the call is to a const fn or method.\n+    fn handle_const_fn_call(&mut self, def_id: ast::DefId, ret_ty: Ty<'tcx>) -> bool {\n+        if let Some(fn_like) = const_eval::lookup_const_fn_by_id(self.tcx, def_id) {\n+            let qualif = self.fn_like(fn_like.kind(),\n+                                      fn_like.decl(),\n+                                      fn_like.body(),\n+                                      fn_like.span(),\n+                                      fn_like.id());\n+            self.add_qualif(qualif);\n+\n+            if ty::type_contents(self.tcx, ret_ty).interior_unsafe() {\n+                self.add_qualif(MUTABLE_MEM);\n+            }\n+\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn record_borrow(&mut self, id: ast::NodeId, mutbl: ast::Mutability) {\n         match self.rvalue_borrows.entry(id) {\n             Entry::Occupied(mut entry) => {\n@@ -158,6 +237,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn msg(&self) -> &'static str {\n         match self.mode {\n             Mode::Const => \"constant\",\n+            Mode::ConstFn => \"constant function\",\n             Mode::StaticMut | Mode::Static => \"static\",\n             Mode::Var => unreachable!(),\n         }\n@@ -251,9 +331,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 b: &'v ast::Block,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n-        assert!(self.mode == Mode::Var);\n-        self.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, b));\n-        visit::walk_fn(self, fk, fd, b, s);\n+        self.fn_like(fk, fd, b, s, fn_id);\n     }\n \n     fn visit_pat(&mut self, p: &ast::Pat) {\n@@ -269,6 +347,35 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_block(&mut self, block: &ast::Block) {\n+        // Check all statements in the block\n+        for stmt in &block.stmts {\n+            let span = match stmt.node {\n+                ast::StmtDecl(ref decl, _) => {\n+                    match decl.node {\n+                        ast::DeclLocal(_) => decl.span,\n+\n+                        // Item statements are allowed\n+                        ast::DeclItem(_) => continue\n+                    }\n+                }\n+                ast::StmtExpr(ref expr, _) => expr.span,\n+                ast::StmtSemi(ref semi, _) => semi.span,\n+                ast::StmtMac(..) => {\n+                    self.tcx.sess.span_bug(stmt.span, \"unexpanded statement \\\n+                                                       macro in const?!\")\n+                }\n+            };\n+            self.add_qualif(NOT_CONST);\n+            if self.mode != Mode::Var {\n+                span_err!(self.tcx.sess, span, E0016,\n+                          \"blocks in {}s are limited to items and \\\n+                           tail expressions\", self.msg());\n+            }\n+        }\n+        visit::walk_block(self, block);\n+    }\n+\n     fn visit_expr(&mut self, ex: &ast::Expr) {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n@@ -473,10 +580,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 Some(def::DefStatic(..)) => {\n                     match v.mode {\n                         Mode::Static | Mode::StaticMut => {}\n-                        Mode::Const => {\n+                        Mode::Const | Mode::ConstFn => {\n                             span_err!(v.tcx.sess, e.span, E0013,\n-                                \"constants cannot refer to other statics, \\\n-                                 insert an intermediate constant instead\");\n+                                \"{}s cannot refer to other statics, insert \\\n+                                 an intermediate constant instead\", v.msg());\n                         }\n                         Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n                     }\n@@ -493,6 +600,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                                              doesn't point to a constant\");\n                     }\n                 }\n+                Some(def::DefLocal(_)) if v.mode == Mode::ConstFn => {\n+                    // Sadly, we can't determine whether the types are zero-sized.\n+                    v.add_qualif(NOT_CONST | NON_ZERO_SIZED);\n+                }\n                 def => {\n                     v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n@@ -517,19 +628,26 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 };\n             }\n             let def = v.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n-            match def {\n-                Some(def::DefStruct(..)) => {}\n+            let is_const = match def {\n+                Some(def::DefStruct(..)) => true,\n                 Some(def::DefVariant(..)) => {\n                     // Count the discriminator.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n+                    true\n                 }\n-                _ => {\n-                    v.add_qualif(ConstQualif::NOT_CONST);\n-                    if v.mode != Mode::Var {\n-                        span_err!(v.tcx.sess, e.span, E0015,\n-                                  \"function calls in {}s are limited to \\\n-                                   struct and enum constructors\", v.msg());\n-                    }\n+                Some(def::DefMethod(did, def::FromImpl(_))) |\n+                Some(def::DefFn(did, _)) => {\n+                    v.handle_const_fn_call(did, node_ty)\n+                }\n+                _ => false\n+            };\n+            if !is_const {\n+                v.add_qualif(ConstQualif::NOT_CONST);\n+                if v.mode != Mode::Var {\n+                    span_err!(v.tcx.sess, e.span, E0015,\n+                              \"function calls in {}s are limited to \\\n+                               constant functions, \\\n+                               struct and enum constructors\", v.msg());\n                 }\n             }\n         }\n@@ -538,27 +656,28 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             let mut block_span_err = |span| {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n-                    span_err!(v.tcx.sess, span, E0016,\n-                              \"blocks in {}s are limited to items and \\\n-                               tail expressions\", v.msg());\n+                    span_err!(v.tcx.sess, e.span, E0015,\n+                              \"function calls in {}s are limited to \\\n+                               constant functions, \\\n+                               struct and enum constructors\", v.msg());\n                 }\n+            }\n+        }\n+        ast::ExprMethodCall(..) => {\n+            let method_did = match v.tcx.method_map.borrow()[method_call].origin {\n+                ty::MethodStatic(did) => Some(did),\n+                _ => None\n             };\n-            for stmt in &block.stmts {\n-                match stmt.node {\n-                    ast::StmtDecl(ref decl, _) => {\n-                        match decl.node {\n-                            ast::DeclLocal(_) => block_span_err(decl.span),\n-\n-                            // Item statements are allowed\n-                            ast::DeclItem(_) => {}\n-                        }\n-                    }\n-                    ast::StmtExpr(ref expr, _) => block_span_err(expr.span),\n-                    ast::StmtSemi(ref semi, _) => block_span_err(semi.span),\n-                    ast::StmtMac(..) => {\n-                        v.tcx.sess.span_bug(e.span, \"unexpanded statement \\\n-                                                     macro in const?!\")\n-                    }\n+            let is_const = match method_did {\n+                Some(did) => v.handle_const_fn_call(did, node_ty),\n+                None => false\n+            };\n+            if !is_const {\n+                v.add_qualif(NOT_CONST);\n+                if v.mode != Mode::Var {\n+                    span_err!(v.tcx.sess, e.span, E0021,\n+                              \"method calls in {}s are limited to \\\n+                               constant inherent methods\", v.msg());\n                 }\n             }\n         }\n@@ -579,7 +698,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         }\n \n         ast::ExprClosure(..) => {\n-            // Paths in constant constexts cannot refer to local variables,\n+            // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n             if ty::with_freevars(v.tcx, e.id, |fv| !fv.is_empty()) {\n                 assert!(v.mode == Mode::Var,\n@@ -588,6 +707,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n \n+        ast::ExprBlock(_) |\n         ast::ExprUnary(..) |\n         ast::ExprBinary(..) |\n         ast::ExprIndex(..) |\n@@ -616,8 +736,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         // Miscellaneous expressions that could be implemented.\n         ast::ExprRange(..) |\n \n-        // Various other expressions.\n-        ast::ExprMethodCall(..) |\n+        // Expressions with side-effects.\n         ast::ExprAssign(..) |\n         ast::ExprAssignOp(..) |\n         ast::ExprInlineAsm(_) |"}, {"sha": "8daf17cb0033e33975438cfd4ec6223233d80643", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=1bd420555e7eb49c2c9a6ecc68e1797540bef403", "patch": "@@ -24,11 +24,13 @@ use util::num::ToPrimitive;\n use util::ppaux::Repr;\n \n use syntax::ast::{self, Expr};\n+use syntax::ast_map::blocks::FnLikeNode;\n+use syntax::ast_util::{self, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::feature_gate;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n-use syntax::{ast_map, ast_util, codemap};\n+use syntax::{ast_map, codemap, visit};\n \n use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n@@ -198,6 +200,63 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     }\n }\n \n+fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: ast::DefId)\n+                                       -> Option<ast::NodeId> {\n+    match tcx.extern_const_fns.borrow().get(&def_id) {\n+        Some(&ast::DUMMY_NODE_ID) => return None,\n+        Some(&fn_id) => return Some(fn_id),\n+        None => {}\n+    }\n+\n+    if !csearch::is_const_fn(&tcx.sess.cstore, def_id) {\n+        tcx.extern_const_fns.borrow_mut().insert(def_id, ast::DUMMY_NODE_ID);\n+        return None;\n+    }\n+\n+    let fn_id = match csearch::maybe_get_item_ast(tcx, def_id,\n+        box |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n+        csearch::FoundAst::Found(&ast::IIItem(ref item)) => Some(item.id),\n+        csearch::FoundAst::Found(&ast::IIImplItem(_, ast::MethodImplItem(ref m))) => Some(m.id),\n+        _ => None\n+    };\n+    tcx.extern_const_fns.borrow_mut().insert(def_id,\n+                                             fn_id.unwrap_or(ast::DUMMY_NODE_ID));\n+    fn_id\n+}\n+\n+pub fn lookup_const_fn_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n+                                 -> Option<FnLikeNode<'a>> {\n+\n+    let fn_id = if !ast_util::is_local(def_id) {\n+        if let Some(fn_id) = inline_const_fn_from_external_crate(tcx, def_id) {\n+            fn_id\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        def_id.node\n+    };\n+\n+    let fn_like = match FnLikeNode::from_node(tcx.map.get(fn_id)) {\n+        Some(fn_like) => fn_like,\n+        None => return None\n+    };\n+\n+    match fn_like.kind() {\n+        visit::FkItemFn(_, _, _, ast::Constness::Const, _) => {\n+            Some(fn_like)\n+        }\n+        visit::FkMethod(_, _, m) => {\n+            if m.pe_constness() == ast::Constness::Const {\n+                Some(fn_like)\n+            } else {\n+                None\n+            }\n+        }\n+        _ => None\n+    }\n+}\n+\n #[derive(Clone, PartialEq)]\n pub enum const_val {\n     const_float(f64),"}, {"sha": "5ff6ee3c8b0817c77cc348ee9ce18db8d2defc69", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1bd420555e7eb49c2c9a6ecc68e1797540bef403", "patch": "@@ -775,10 +775,10 @@ pub struct ctxt<'tcx> {\n     /// Borrows\n     pub upvar_capture_map: RefCell<UpvarCaptureMap>,\n \n-    /// These two caches are used by const_eval when decoding external statics\n-    /// and variants that are found.\n+    /// These caches are used by const_eval when decoding external constants.\n     pub extern_const_statics: RefCell<DefIdMap<ast::NodeId>>,\n     pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n+    pub extern_const_fns: RefCell<DefIdMap<ast::NodeId>>,\n \n     pub method_map: MethodMap<'tcx>,\n \n@@ -2808,6 +2808,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         upvar_capture_map: RefCell::new(FnvHashMap()),\n         extern_const_statics: RefCell::new(DefIdMap()),\n         extern_const_variants: RefCell::new(DefIdMap()),\n+        extern_const_fns: RefCell::new(DefIdMap()),\n         method_map: RefCell::new(FnvHashMap()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n         closure_kinds: RefCell::new(DefIdMap()),"}, {"sha": "58627b37a8766c6b394f7c3f4ed2a081287990f1", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bd420555e7eb49c2c9a6ecc68e1797540bef403/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=1bd420555e7eb49c2c9a6ecc68e1797540bef403", "patch": "@@ -96,20 +96,10 @@ impl<'a> Code<'a> {\n \n     /// Attempts to construct a Code from presumed FnLike or Block node input.\n     pub fn from_node(node: Node) -> Option<Code> {\n-        fn new(node: Node) -> FnLikeNode { FnLikeNode { node: node } }\n-        match node {\n-            ast_map::NodeItem(item) if item.is_fn_like() =>\n-                Some(FnLikeCode(new(node))),\n-            ast_map::NodeTraitItem(tm) if tm.is_fn_like() =>\n-                Some(FnLikeCode(new(node))),\n-            ast_map::NodeImplItem(_) =>\n-                Some(FnLikeCode(new(node))),\n-            ast_map::NodeExpr(e) if e.is_fn_like() =>\n-                Some(FnLikeCode(new(node))),\n-            ast_map::NodeBlock(block) =>\n-                Some(BlockCode(block)),\n-            _ =>\n-                None,\n+        if let ast_map::NodeBlock(block) = node {\n+            Some(BlockCode(block))\n+        } else {\n+            FnLikeNode::from_node(node).map(|fn_like| FnLikeCode(fn_like))\n         }\n     }\n }\n@@ -145,6 +135,24 @@ impl<'a> ClosureParts<'a> {\n }\n \n impl<'a> FnLikeNode<'a> {\n+    /// Attempts to construct a FnLikeNode from presumed FnLike node input.\n+    pub fn from_node(node: Node) -> Option<FnLikeNode> {\n+        let fn_like = match node {\n+            ast_map::NodeItem(item) => item.is_fn_like(),\n+            ast_map::NodeTraitItem(tm) => tm.is_fn_like(),\n+            ast_map::NodeImplItem(_) => true,\n+            ast_map::NodeExpr(e) => e.is_fn_like(),\n+            _ => false\n+        };\n+        if fn_like {\n+            Some(FnLikeNode {\n+                node: node\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn to_fn_parts(self) -> FnParts<'a> {\n         FnParts {\n             decl: self.decl(),"}]}