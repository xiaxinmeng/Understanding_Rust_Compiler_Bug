{"sha": "ce468e643a9e048900e5495948737efdf5bb2385", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNDY4ZTY0M2E5ZTA0ODkwMGU1NDk1OTQ4NzM3ZWZkZjViYjIzODU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-21T07:22:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-21T07:22:45Z"}, "message": "auto merge of #19946 : cgaebel/rust/hashmap-drain-iter, r=gankro\n\nIt is useful to move all the elements out of a hashmap without deallocating\nthe underlying buffer. It came up in IRC, and this patch implements it as\n`drain`.\n\nr? @Gankro\ncc: @frankmcsherry", "tree": {"sha": "8e07b9c8b42ba241bd6e9ecc51a1d35be064ad07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e07b9c8b42ba241bd6e9ecc51a1d35be064ad07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce468e643a9e048900e5495948737efdf5bb2385", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce468e643a9e048900e5495948737efdf5bb2385", "html_url": "https://github.com/rust-lang/rust/commit/ce468e643a9e048900e5495948737efdf5bb2385", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce468e643a9e048900e5495948737efdf5bb2385/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf", "html_url": "https://github.com/rust-lang/rust/commit/cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf"}, {"sha": "d57f25907bc4247b4d98efce5ab6948c35baa12d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d57f25907bc4247b4d98efce5ab6948c35baa12d", "html_url": "https://github.com/rust-lang/rust/commit/d57f25907bc4247b4d98efce5ab6948c35baa12d"}], "stats": {"total": 488, "additions": 470, "deletions": 18}, "files": [{"sha": "a12bfcdbd189391e51785cddec7a194c69dec92f", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=ce468e643a9e048900e5495948737efdf5bb2385", "patch": "@@ -551,9 +551,18 @@ impl<T: Ord> BinaryHeap<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n+    /// Clears the queue, returning an iterator over the removed elements.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n+        Drain {\n+            iter: self.data.drain(),\n+        }\n+    }\n+\n     /// Drops all items from the queue.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn clear(&mut self) { self.data.truncate(0) }\n+    pub fn clear(&mut self) { self.drain(); }\n }\n \n /// `BinaryHeap` iterator.\n@@ -596,6 +605,26 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n \n impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n \n+/// An iterator that drains a `BinaryHeap`.\n+pub struct Drain<'a, T: 'a> {\n+    iter: vec::Drain<'a, T>,\n+}\n+\n+impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+\n+impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n+\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     fn from_iter<Iter: Iterator<T>>(iter: Iter) -> BinaryHeap<T> {\n         let vec: Vec<T> = iter.collect();\n@@ -819,4 +848,14 @@ mod tests {\n             assert_eq!(q.pop().unwrap(), x);\n         }\n     }\n+\n+    #[test]\n+    fn test_drain() {\n+        let mut q: BinaryHeap<_> =\n+            [9u, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n+\n+        assert_eq!(q.drain().take(5).count(), 5);\n+\n+        assert!(q.is_empty());\n+    }\n }"}, {"sha": "59784f001a23de4074c82476fe754322f70db627", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 126, "deletions": 4, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=ce468e643a9e048900e5495948737efdf5bb2385", "patch": "@@ -491,6 +491,27 @@ impl<T> RingBuf<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n+    /// Creates a draining iterator that clears the `RingBuf` and iterates over\n+    /// the removed items from start to end.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut v = RingBuf::new();\n+    /// v.push_back(1i);\n+    /// assert_eq!(v.drain().next(), Some(1));\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n+        Drain {\n+            inner: self,\n+        }\n+    }\n+\n     /// Clears the buffer, removing all values.\n     ///\n     /// # Examples\n@@ -504,10 +525,9 @@ impl<T> RingBuf<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[inline]\n     pub fn clear(&mut self) {\n-        while self.pop_front().is_some() {}\n-        self.head = 0;\n-        self.tail = 0;\n+        self.drain();\n     }\n \n     /// Provides a reference to the front element, or `None` if the sequence is\n@@ -1230,9 +1250,44 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n     }\n }\n \n-\n impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n \n+/// A draining RingBuf iterator\n+pub struct Drain<'a, T: 'a> {\n+    inner: &'a mut RingBuf<T>,\n+}\n+\n+#[unsafe_destructor]\n+impl<'a, T: 'a> Drop for Drain<'a, T> {\n+    fn drop(&mut self) {\n+        for _ in *self {}\n+        self.inner.head = 0;\n+        self.inner.tail = 0;\n+    }\n+}\n+\n+impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop_front()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let len = self.inner.len();\n+        (len, Some(len))\n+    }\n+}\n+\n+impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.pop_back()\n+    }\n+}\n+\n+impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n+\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.len() == other.len() &&\n@@ -1841,6 +1896,73 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_drain() {\n+\n+        // Empty iter\n+        {\n+            let mut d: RingBuf<int> = RingBuf::new();\n+\n+            {\n+                let mut iter = d.drain();\n+\n+                assert_eq!(iter.size_hint(), (0, Some(0)));\n+                assert_eq!(iter.next(), None);\n+                assert_eq!(iter.size_hint(), (0, Some(0)));\n+            }\n+\n+            assert!(d.is_empty());\n+        }\n+\n+        // simple iter\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+\n+            assert_eq!(d.drain().collect::<Vec<int>>(), [0, 1, 2, 3, 4]);\n+            assert!(d.is_empty());\n+        }\n+\n+        // wrapped iter\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+            for i in range(6, 9) {\n+                d.push_front(i);\n+            }\n+\n+            assert_eq!(d.drain().collect::<Vec<int>>(), [8,7,6,0,1,2,3,4]);\n+            assert!(d.is_empty());\n+        }\n+\n+        // partially used\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+            for i in range(6, 9) {\n+                d.push_front(i);\n+            }\n+\n+            {\n+                let mut it = d.drain();\n+                assert_eq!(it.size_hint(), (8, Some(8)));\n+                assert_eq!(it.next(), Some(8));\n+                assert_eq!(it.size_hint(), (7, Some(7)));\n+                assert_eq!(it.next_back(), Some(4));\n+                assert_eq!(it.size_hint(), (6, Some(6)));\n+                assert_eq!(it.next(), Some(7));\n+                assert_eq!(it.size_hint(), (5, Some(5)));\n+            }\n+            assert!(d.is_empty());\n+        }\n+    }\n+\n     #[test]\n     fn test_from_iter() {\n         use core::iter;"}, {"sha": "faea37d12786bd1e7b412335814e32f0891771a2", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 147, "deletions": 3, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=ce468e643a9e048900e5495948737efdf5bb2385", "patch": "@@ -1117,6 +1117,38 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Creates a draining iterator that clears the `Vec` and iterates over\n+    /// the removed items from start to end.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = vec![\"a\".to_string(), \"b\".to_string()];\n+    /// for s in v.drain() {\n+    ///     // s has type String, not &String\n+    ///     println!(\"{}\", s);\n+    /// }\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n+        unsafe {\n+            let begin = self.ptr as *const T;\n+            let end = if mem::size_of::<T>() == 0 {\n+                (self.ptr as uint + self.len()) as *const T\n+            } else {\n+                self.ptr.offset(self.len() as int) as *const T\n+            };\n+            self.set_len(0);\n+            Drain {\n+                ptr: begin,\n+                end: end,\n+                marker: ContravariantLifetime,\n+            }\n+        }\n+    }\n+\n     /// Clears the vector, removing all values.\n     ///\n     /// # Examples\n@@ -1373,8 +1405,9 @@ pub struct MoveItems<T> {\n }\n \n impl<T> MoveItems<T> {\n-    #[inline]\n     /// Drops all items that have not yet been moved and returns the empty vector.\n+    #[inline]\n+    #[unstable]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self { }\n@@ -1384,8 +1417,8 @@ impl<T> MoveItems<T> {\n         }\n     }\n \n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n+    /// Deprecated, use .into_inner() instead\n+    #[deprecated = \"use .into_inner() instead\"]\n     pub fn unwrap(self) -> Vec<T> { self.into_inner() }\n }\n \n@@ -1461,6 +1494,84 @@ impl<T> Drop for MoveItems<T> {\n     }\n }\n \n+/// An iterator that drains a vector.\n+#[unsafe_no_drop_flag]\n+pub struct Drain<'a, T> {\n+    ptr: *const T,\n+    end: *const T,\n+    marker: ContravariantLifetime<'a>,\n+}\n+\n+impl<'a, T> Iterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            if self.ptr == self.end {\n+                None\n+            } else {\n+                if mem::size_of::<T>() == 0 {\n+                    // purposefully don't use 'ptr.offset' because for\n+                    // vectors with 0-size elements this would return the\n+                    // same pointer.\n+                    self.ptr = mem::transmute(self.ptr as uint + 1);\n+\n+                    // Use a non-null pointer value\n+                    Some(ptr::read(mem::transmute(1u)))\n+                } else {\n+                    let old = self.ptr;\n+                    self.ptr = self.ptr.offset(1);\n+\n+                    Some(ptr::read(old))\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let diff = (self.end as uint) - (self.ptr as uint);\n+        let size = mem::size_of::<T>();\n+        let exact = diff / (if size == 0 {1} else {size});\n+        (exact, Some(exact))\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        unsafe {\n+            if self.end == self.ptr {\n+                None\n+            } else {\n+                if mem::size_of::<T>() == 0 {\n+                    // See above for why 'ptr.offset' isn't used\n+                    self.end = mem::transmute(self.end as uint - 1);\n+\n+                    // Use a non-null pointer value\n+                    Some(ptr::read(mem::transmute(1u)))\n+                } else {\n+                    self.end = self.end.offset(-1);\n+\n+                    Some(ptr::read(self.end))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T> ExactSizeIterator<T> for Drain<'a, T> {}\n+\n+#[unsafe_destructor]\n+impl<'a, T> Drop for Drain<'a, T> {\n+    fn drop(&mut self) {\n+        // self.ptr == self.end == null if drop has already been called,\n+        // so we can use #[unsafe_no_drop_flag].\n+\n+        // destroy the remaining elements\n+        for _x in *self {}\n+    }\n+}\n+\n /// Converts an iterator of pairs into a pair of vectors.\n ///\n /// Returns a tuple containing two vectors where the i-th element of the first vector contains the\n@@ -2267,6 +2378,39 @@ mod tests {\n         assert!(vec2 == vec![(), (), ()]);\n     }\n \n+    #[test]\n+    fn test_drain_items() {\n+        let mut vec = vec![1, 2, 3];\n+        let mut vec2: Vec<i32> = vec![];\n+        for i in vec.drain() {\n+            vec2.push(i);\n+        }\n+        assert_eq!(vec, []);\n+        assert_eq!(vec2, [ 1, 2, 3 ]);\n+    }\n+\n+    #[test]\n+    fn test_drain_items_reverse() {\n+        let mut vec = vec![1, 2, 3];\n+        let mut vec2: Vec<i32> = vec![];\n+        for i in vec.drain().rev() {\n+            vec2.push(i);\n+        }\n+        assert_eq!(vec, []);\n+        assert_eq!(vec2, [ 3, 2, 1 ]);\n+    }\n+\n+    #[test]\n+    fn test_drain_items_zero_sized() {\n+        let mut vec = vec![(), (), ()];\n+        let mut vec2: Vec<()> = vec![];\n+        for i in vec.drain() {\n+            vec2.push(i);\n+        }\n+        assert_eq!(vec, []);\n+        assert_eq!(vec2, [(), (), ()]);\n+    }\n+\n     #[test]\n     fn test_into_boxed_slice() {\n         let xs = vec![1u, 2, 3];"}, {"sha": "0b04edf67761f7738bed799e267eef1e1bb30d76", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=ce468e643a9e048900e5495948737efdf5bb2385", "patch": "@@ -982,6 +982,35 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n+    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n+    /// allocated memory for reuse.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// a.insert(1u, \"a\");\n+    /// a.insert(2u, \"b\");\n+    ///\n+    /// for (k, v) in a.drain().take(1) {\n+    ///     assert!(k == 1 || k == 2);\n+    ///     assert!(v == \"a\" || v == \"b\");\n+    /// }\n+    ///\n+    /// assert!(a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain(&mut self) -> Drain<K, V> {\n+        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n+\n+        Drain {\n+            inner: self.table.drain().map(last_two),\n+        }\n+    }\n+\n     /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n     /// for reuse.\n     ///\n@@ -996,16 +1025,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert!(a.is_empty());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[inline]\n     pub fn clear(&mut self) {\n-        let cap = self.table.capacity();\n-        let mut buckets = Bucket::first(&mut self.table);\n-\n-        while buckets.index() != cap {\n-            buckets = match buckets.peek() {\n-                Empty(b)   => b.next(),\n-                Full(full) => full.take().0.next(),\n-            };\n-        }\n+        self.drain();\n     }\n \n     /// Deprecated: Renamed to `get`.\n@@ -1306,6 +1328,16 @@ pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n+/// HashMap drain iterator\n+pub struct Drain<'a, K: 'a, V: 'a> {\n+    inner: iter::Map<\n+        (SafeHash, K, V),\n+        (K, V),\n+        table::Drain<'a, K, V>,\n+        fn((SafeHash, K, V)) -> (K, V),\n+    >\n+}\n+\n /// A view into a single occupied location in a HashMap\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n@@ -1360,6 +1392,17 @@ impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+impl<'a, K: 'a, V: 'a> Iterator<(K, V)> for Drain<'a, K, V> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry\n     pub fn get(&self) -> &V {"}, {"sha": "ee701b5473dffe913e2e777379c96c01d4bac699", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=ce468e643a9e048900e5495948737efdf5bb2385", "patch": "@@ -21,7 +21,7 @@ use iter::{Iterator, IteratorExt, FromIterator, Map, FilterMap, Chain, Repeat, Z\n use option::Option::{Some, None, mod};\n use result::Result::{Ok, Err};\n \n-use super::map::{HashMap, MoveEntries, Keys, INITIAL_CAPACITY};\n+use super::map::{mod, HashMap, MoveEntries, Keys, INITIAL_CAPACITY};\n \n // FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n \n@@ -420,6 +420,14 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n \n+    /// Clears the set, returning all elements in an iterator.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain(&mut self) -> Drain<T> {\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        Drain { iter: self.map.drain().map(first) }\n+    }\n+\n     /// Clears the set, removing all values.\n     ///\n     /// # Example\n@@ -626,6 +634,11 @@ pub struct SetMoveItems<K> {\n     iter: Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>\n }\n \n+/// HashSet drain iterator\n+pub struct Drain<'a, K: 'a> {\n+    iter: Map<(K, ()), K, map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n+}\n+\n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n /// Set operations iterator, used directly for intersection and difference\n@@ -658,6 +671,11 @@ impl<K> Iterator<K> for SetMoveItems<K> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+impl<'a, K: 'a> Iterator<K> for Drain<'a, K> {\n+    fn next(&mut self) -> Option<K> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n impl<'a, T, H> Iterator<&'a T> for SetAlgebraItems<'a, T, H> {\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n@@ -913,4 +931,41 @@ mod test_set {\n         assert!(set_str == \"{1, 2}\" || set_str == \"{2, 1}\");\n         assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n+\n+    #[test]\n+    fn test_trivial_drain() {\n+        let mut s = HashSet::<int>::new();\n+        for _ in s.drain() {}\n+        assert!(s.is_empty());\n+        drop(s);\n+\n+        let mut s = HashSet::<int>::new();\n+        drop(s.drain());\n+        assert!(s.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_drain() {\n+        let mut s: HashSet<int> = range(1, 100).collect();\n+\n+        // try this a bunch of times to make sure we don't screw up internal state.\n+        for _ in range(0i, 20) {\n+            assert_eq!(s.len(), 99);\n+\n+            {\n+                let mut last_i = 0;\n+                let mut d = s.drain();\n+                for (i, x) in d.by_ref().take(50).enumerate() {\n+                    last_i = i;\n+                    assert!(x != 0);\n+                }\n+                assert_eq!(last_i, 49);\n+            }\n+\n+            for _ in s.iter() { panic!(\"s should be empty!\"); }\n+\n+            // reset to try again.\n+            s.extend(range(1, 100));\n+        }\n+    }\n }"}, {"sha": "115edcabca1e9847af4de61b6a091ef8af71b383", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce468e643a9e048900e5495948737efdf5bb2385/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=ce468e643a9e048900e5495948737efdf5bb2385", "patch": "@@ -684,6 +684,19 @@ impl<K, V> RawTable<K, V> {\n         }\n     }\n \n+    pub fn drain(&mut self) -> Drain<K, V> {\n+        let RawBuckets { raw, hashes_end, .. } = self.raw_buckets();\n+        // Replace the marker regardless of lifetime bounds on parameters.\n+        Drain {\n+            iter: RawBuckets {\n+                raw: raw,\n+                hashes_end: hashes_end,\n+                marker: marker::ContravariantLifetime::<'static>,\n+            },\n+            table: self,\n+        }\n+    }\n+\n     /// Returns an iterator that copies out each entry. Used while the table\n     /// is being dropped.\n     unsafe fn rev_move_buckets(&mut self) -> RevMoveBuckets<K, V> {\n@@ -774,6 +787,12 @@ pub struct MoveEntries<K, V> {\n     iter: RawBuckets<'static, K, V>\n }\n \n+/// Iterator over the entries in a table, clearing the table.\n+pub struct Drain<'a, K: 'a, V: 'a> {\n+    table: &'a mut RawTable<K, V>,\n+    iter: RawBuckets<'static, K, V>,\n+}\n+\n impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         self.iter.next().map(|bucket| {\n@@ -828,6 +847,36 @@ impl<K, V> Iterator<(SafeHash, K, V)> for MoveEntries<K, V> {\n     }\n }\n \n+impl<'a, K: 'a, V: 'a> Iterator<(SafeHash, K, V)> for Drain<'a, K, V> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(SafeHash, K, V)> {\n+        self.iter.next().map(|bucket| {\n+            self.table.size -= 1;\n+            unsafe {\n+                (\n+                    SafeHash {\n+                        hash: ptr::replace(bucket.hash, EMPTY_BUCKET),\n+                    },\n+                    ptr::read(bucket.key as *const K),\n+                    ptr::read(bucket.val as *const V)\n+                )\n+            }\n+        })\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let size = self.table.size();\n+        (size, Some(size))\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> {\n+    fn drop(&mut self) {\n+        for _ in *self {}\n+    }\n+}\n+\n impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n     fn clone(&self) -> RawTable<K, V> {\n         unsafe {"}]}