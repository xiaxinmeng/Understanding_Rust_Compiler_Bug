{"sha": "2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYzEzN2I3MGY5ZDQ1NTY3NmNjOTlhMWE1YzdlNmUxMGMzZTdjYzI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-28T19:16:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-28T19:16:51Z"}, "message": "Merge #7813\n\n7813: Inline TypeCtor into Ty r=flodiebold a=Veykril\n\nThis removes the `ApplicationTy` variant from `Ty` bringing the representation a lot closer to chalk's `TyKind`.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "b9bc6434404e99a0829d01b08285d37f6faa3d2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9bc6434404e99a0829d01b08285d37f6faa3d2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgO+wjCRBK7hj4Ov3rIwAAdHIIAGCwocxp2tFd0D1V79FjjoX0\nTBmSbaCMDpr86X7iWcz9uOlQNa5Am9rK4PcJngbYDvPiqeFP7XiMHGf2lF5dXc1y\njeKGc7p6YZDELwLVpR3P/KfWAvPBnIgmSqsIOE0p4PVJcJxKncxzXWa2nImB0COk\nUa+woO9ZaVQ4n6ddn3DsF42oOGZtX9CChQvUH9lPWojhlDK3FZecpJggeYmboRFk\nuyXt+ExNZnDUYrt4vfoTQYCZT0ta+CWs4iXHyjN8OckXWisPHqOpxOzTN5gr2aYK\nHa5P8UzPllaj9SY6Uw+YHVEk+6xPNDM2vdpoXsDp8uavl9ZK1jftf2cYNiBVj3s=\n=5bZh\n-----END PGP SIGNATURE-----\n", "payload": "tree b9bc6434404e99a0829d01b08285d37f6faa3d2d\nparent 0a913fd11194faff9c0100bc78f2d4fe682075aa\nparent faf2dd49e4845e1437b704a28bb5603be5fd605b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614539811 +0000\ncommitter GitHub <noreply@github.com> 1614539811 +0000\n\nMerge #7813\n\n7813: Inline TypeCtor into Ty r=flodiebold a=Veykril\n\nThis removes the `ApplicationTy` variant from `Ty` bringing the representation a lot closer to chalk's `TyKind`.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "html_url": "https://github.com/rust-lang/rust/commit/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a913fd11194faff9c0100bc78f2d4fe682075aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a913fd11194faff9c0100bc78f2d4fe682075aa", "html_url": "https://github.com/rust-lang/rust/commit/0a913fd11194faff9c0100bc78f2d4fe682075aa"}, {"sha": "faf2dd49e4845e1437b704a28bb5603be5fd605b", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf2dd49e4845e1437b704a28bb5603be5fd605b", "html_url": "https://github.com/rust-lang/rust/commit/faf2dd49e4845e1437b704a28bb5603be5fd605b"}], "stats": {"total": 1652, "additions": 709, "deletions": 943}, "files": [{"sha": "cdb54eca2af3407e7acba3041450c22522944e17", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 56, "deletions": 95, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -31,9 +31,9 @@ use hir_ty::{\n     display::{write_bounds_like_dyn_trait_with_prefix, HirDisplayError, HirFormatter},\n     method_resolution,\n     traits::{FnTrait, Solution, SolutionVariables},\n-    ApplicationTy, BoundVar, CallableDefId, Canonical, DebruijnIndex, FnSig, GenericPredicate,\n-    InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment,\n-    Ty, TyDefId, TyKind, TypeCtor,\n+    BoundVar, CallableDefId, Canonical, DebruijnIndex, FnSig, GenericPredicate, InEnvironment,\n+    Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment, Ty, TyDefId,\n+    TyKind,\n };\n use rustc_hash::FxHashSet;\n use stdx::{format_to, impl_from};\n@@ -1547,28 +1547,19 @@ impl Type {\n     }\n \n     pub fn is_unit(&self) -> bool {\n-        matches!(\n-            self.ty.value,\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple { cardinality: 0 }, .. })\n-        )\n+        matches!(self.ty.value, Ty::Tuple { cardinality: 0, .. })\n     }\n     pub fn is_bool(&self) -> bool {\n-        matches!(\n-            self.ty.value,\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Scalar(Scalar::Bool), .. })\n-        )\n+        matches!(self.ty.value, Ty::Scalar(Scalar::Bool))\n     }\n \n     pub fn is_mutable_reference(&self) -> bool {\n-        matches!(\n-            self.ty.value,\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(Mutability::Mut), .. })\n-        )\n+        matches!(self.ty.value, Ty::Ref(Mutability::Mut, ..))\n     }\n \n     pub fn remove_ref(&self) -> Option<Type> {\n-        if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(_), .. }) = self.ty.value {\n-            self.ty.value.substs().map(|substs| self.derived(substs[0].clone()))\n+        if let Ty::Ref(.., substs) = &self.ty.value {\n+            Some(self.derived(substs[0].clone()))\n         } else {\n             None\n         }\n@@ -1688,7 +1679,7 @@ impl Type {\n \n     pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n         let def = match self.ty.value {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(def), parameters: _ }) => Some(def),\n+            Ty::FnDef(def, _) => Some(def),\n             _ => None,\n         };\n \n@@ -1697,20 +1688,16 @@ impl Type {\n     }\n \n     pub fn is_closure(&self) -> bool {\n-        matches!(&self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::Closure { .. }, .. }))\n+        matches!(&self.ty.value, Ty::Closure { .. })\n     }\n \n     pub fn is_fn(&self) -> bool {\n-        matches!(\n-            &self.ty.value,\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(..), .. })\n-                | Ty::Apply(ApplicationTy { ctor: TypeCtor::FnPtr { .. }, .. })\n-        )\n+        matches!(&self.ty.value, Ty::FnDef(..) | Ty::FnPtr { .. })\n     }\n \n     pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n         let adt_id = match self.ty.value {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_id), .. }) => adt_id,\n+            Ty::Adt(adt_id, ..) => adt_id,\n             _ => return false,\n         };\n \n@@ -1722,7 +1709,7 @@ impl Type {\n     }\n \n     pub fn is_raw_ptr(&self) -> bool {\n-        matches!(&self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(..), .. }))\n+        matches!(&self.ty.value, Ty::RawPtr(..))\n     }\n \n     pub fn contains_unknown(&self) -> bool {\n@@ -1731,44 +1718,34 @@ impl Type {\n         fn go(ty: &Ty) -> bool {\n             match ty {\n                 Ty::Unknown => true,\n-                Ty::Apply(a_ty) => a_ty.parameters.iter().any(go),\n-                _ => false,\n+                _ => ty.substs().map_or(false, |substs| substs.iter().any(go)),\n             }\n         }\n     }\n \n     pub fn fields(&self, db: &dyn HirDatabase) -> Vec<(Field, Type)> {\n-        if let Ty::Apply(a_ty) = &self.ty.value {\n-            let variant_id = match a_ty.ctor {\n-                TypeCtor::Adt(AdtId::StructId(s)) => s.into(),\n-                TypeCtor::Adt(AdtId::UnionId(u)) => u.into(),\n-                _ => return Vec::new(),\n-            };\n-\n-            return db\n-                .field_types(variant_id)\n-                .iter()\n-                .map(|(local_id, ty)| {\n-                    let def = Field { parent: variant_id.into(), id: local_id };\n-                    let ty = ty.clone().subst(&a_ty.parameters);\n-                    (def, self.derived(ty))\n-                })\n-                .collect();\n+        let (variant_id, substs) = match self.ty.value {\n+            Ty::Adt(AdtId::StructId(s), ref substs) => (s.into(), substs),\n+            Ty::Adt(AdtId::UnionId(u), ref substs) => (u.into(), substs),\n+            _ => return Vec::new(),\n         };\n-        Vec::new()\n+\n+        db.field_types(variant_id)\n+            .iter()\n+            .map(|(local_id, ty)| {\n+                let def = Field { parent: variant_id.into(), id: local_id };\n+                let ty = ty.clone().subst(substs);\n+                (def, self.derived(ty))\n+            })\n+            .collect()\n     }\n \n     pub fn tuple_fields(&self, _db: &dyn HirDatabase) -> Vec<Type> {\n-        let mut res = Vec::new();\n-        if let Ty::Apply(a_ty) = &self.ty.value {\n-            if let TypeCtor::Tuple { .. } = a_ty.ctor {\n-                for ty in a_ty.parameters.iter() {\n-                    let ty = ty.clone();\n-                    res.push(self.derived(ty));\n-                }\n-            }\n-        };\n-        res\n+        if let Ty::Tuple { substs, .. } = &self.ty.value {\n+            substs.iter().map(|ty| self.derived(ty.clone())).collect()\n+        } else {\n+            Vec::new()\n+        }\n     }\n \n     pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n@@ -1805,15 +1782,13 @@ impl Type {\n     }\n \n     pub fn type_parameters(&self) -> impl Iterator<Item = Type> + '_ {\n-        let ty = self.ty.value.strip_references();\n-        let substs = match ty {\n-            Ty::Apply(apply_ty) => &apply_ty.parameters,\n-            Ty::Opaque(opaque_ty) => &opaque_ty.parameters,\n-            _ => return Either::Left(iter::empty()),\n-        };\n-\n-        let iter = substs.iter().map(move |ty| self.derived(ty.clone()));\n-        Either::Right(iter)\n+        self.ty\n+            .value\n+            .strip_references()\n+            .substs()\n+            .into_iter()\n+            .flat_map(|substs| substs.iter())\n+            .map(move |ty| self.derived(ty.clone()))\n     }\n \n     pub fn iterate_method_candidates<T>(\n@@ -1903,17 +1878,8 @@ impl Type {\n \n     // FIXME: provide required accessors such that it becomes implementable from outside.\n     pub fn is_equal_for_find_impls(&self, other: &Type) -> bool {\n-        match (&self.ty.value, &other.ty.value) {\n-            (Ty::Apply(a_original_ty), Ty::Apply(ApplicationTy { ctor, parameters })) => match ctor\n-            {\n-                TypeCtor::Ref(..) => match parameters.as_single() {\n-                    Ty::Apply(a_ty) => a_original_ty.ctor == a_ty.ctor,\n-                    _ => false,\n-                },\n-                _ => a_original_ty.ctor == *ctor,\n-            },\n-            _ => false,\n-        }\n+        let rref = other.remove_ref();\n+        self.ty.value.equals_ctor(rref.as_ref().map_or(&other.ty.value, |it| &it.ty.value))\n     }\n \n     fn derived(&self, ty: Ty) -> Type {\n@@ -1958,26 +1924,18 @@ impl Type {\n         fn walk_type(db: &dyn HirDatabase, type_: &Type, cb: &mut impl FnMut(Type)) {\n             let ty = type_.ty.value.strip_references();\n             match ty {\n-                Ty::Apply(ApplicationTy { ctor, parameters }) => {\n-                    match ctor {\n-                        TypeCtor::Adt(_) => {\n-                            cb(type_.derived(ty.clone()));\n-                        }\n-                        TypeCtor::AssociatedType(_) => {\n-                            if let Some(_) = ty.associated_type_parent_trait(db) {\n-                                cb(type_.derived(ty.clone()));\n-                            }\n-                        }\n-                        TypeCtor::OpaqueType(..) => {\n-                            if let Some(bounds) = ty.impl_trait_bounds(db) {\n-                                walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n-                            }\n-                        }\n-                        _ => (),\n+                Ty::Adt(..) => {\n+                    cb(type_.derived(ty.clone()));\n+                }\n+                Ty::AssociatedType(..) => {\n+                    if let Some(_) = ty.associated_type_parent_trait(db) {\n+                        cb(type_.derived(ty.clone()));\n+                    }\n+                }\n+                Ty::OpaqueType(..) => {\n+                    if let Some(bounds) = ty.impl_trait_bounds(db) {\n+                        walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n                     }\n-\n-                    // adt params, tuples, etc...\n-                    walk_substs(db, type_, parameters, cb);\n                 }\n                 Ty::Opaque(opaque_ty) => {\n                     if let Some(bounds) = ty.impl_trait_bounds(db) {\n@@ -1995,7 +1953,10 @@ impl Type {\n                     walk_bounds(db, &type_.derived(ty.clone()), bounds.as_ref(), cb);\n                 }\n \n-                _ => (),\n+                _ => {}\n+            }\n+            if let Some(substs) = ty.substs() {\n+                walk_substs(db, type_, &substs, cb);\n             }\n         }\n "}, {"sha": "64ce4add15955ee6d33fa43c0d082b9c5263153e", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -20,7 +20,7 @@ use hir_def::{\n use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n use hir_ty::{\n     diagnostics::{record_literal_missing_fields, record_pattern_missing_fields},\n-    InferenceResult, Substs, Ty,\n+    InferenceResult, Substs,\n };\n use syntax::{\n     ast::{self, AstNode},\n@@ -299,14 +299,11 @@ impl SourceAnalyzer {\n         let infer = self.infer.as_ref()?;\n \n         let expr_id = self.expr_id(db, &literal.clone().into())?;\n-        let substs = match &infer.type_of_expr[expr_id] {\n-            Ty::Apply(a_ty) => &a_ty.parameters,\n-            _ => return None,\n-        };\n+        let substs = infer.type_of_expr[expr_id].substs()?;\n \n         let (variant, missing_fields, _exhaustive) =\n             record_literal_missing_fields(db, infer, expr_id, &body[expr_id])?;\n-        let res = self.missing_fields(db, krate, substs, variant, missing_fields);\n+        let res = self.missing_fields(db, krate, &substs, variant, missing_fields);\n         Some(res)\n     }\n \n@@ -320,14 +317,11 @@ impl SourceAnalyzer {\n         let infer = self.infer.as_ref()?;\n \n         let pat_id = self.pat_id(&pattern.clone().into())?;\n-        let substs = match &infer.type_of_pat[pat_id] {\n-            Ty::Apply(a_ty) => &a_ty.parameters,\n-            _ => return None,\n-        };\n+        let substs = infer.type_of_pat[pat_id].substs()?;\n \n         let (variant, missing_fields, _exhaustive) =\n             record_pattern_missing_fields(db, infer, pat_id, &body[pat_id])?;\n-        let res = self.missing_fields(db, krate, substs, variant, missing_fields);\n+        let res = self.missing_fields(db, krate, &substs, variant, missing_fields);\n         Some(res)\n     }\n "}, {"sha": "66a88e2b62831b9a0b536eb753d2de94aa3ae10e", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -17,7 +17,7 @@ use crate::{\n         MissingPatFields, RemoveThisSemicolon,\n     },\n     utils::variant_data,\n-    ApplicationTy, InferenceResult, Ty, TypeCtor,\n+    InferenceResult, Ty,\n };\n \n pub(crate) use hir_def::{\n@@ -381,14 +381,11 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             _ => return,\n         };\n \n-        let core_result_ctor = TypeCtor::Adt(AdtId::EnumId(core_result_enum));\n-        let core_option_ctor = TypeCtor::Adt(AdtId::EnumId(core_option_enum));\n-\n-        let (params, required) = match &mismatch.expected {\n-            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &core_result_ctor => {\n+        let (params, required) = match mismatch.expected {\n+            Ty::Adt(AdtId::EnumId(enum_id), ref parameters) if enum_id == core_result_enum => {\n                 (parameters, \"Ok\".to_string())\n             }\n-            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &core_option_ctor => {\n+            Ty::Adt(AdtId::EnumId(enum_id), ref parameters) if enum_id == core_option_enum => {\n                 (parameters, \"Some\".to_string())\n             }\n             _ => return,"}, {"sha": "86fee0050f2c64abfd8bef1a8bce768ab22e9dda", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -227,7 +227,7 @@ use hir_def::{\n use la_arena::Idx;\n use smallvec::{smallvec, SmallVec};\n \n-use crate::{db::HirDatabase, ApplicationTy, InferenceResult, Ty, TypeCtor};\n+use crate::{db::HirDatabase, InferenceResult, Ty};\n \n #[derive(Debug, Clone, Copy)]\n /// Either a pattern from the source code being analyzed, represented as\n@@ -627,14 +627,12 @@ pub(super) fn is_useful(\n     // - `!` type\n     // In those cases, no match arm is useful.\n     match cx.infer[cx.match_expr].strip_references() {\n-        Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(AdtId::EnumId(enum_id)), .. }) => {\n+        Ty::Adt(AdtId::EnumId(enum_id), ..) => {\n             if cx.db.enum_data(*enum_id).variants.is_empty() {\n                 return Ok(Usefulness::NotUseful);\n             }\n         }\n-        Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }) => {\n-            return Ok(Usefulness::NotUseful);\n-        }\n+        Ty::Never => return Ok(Usefulness::NotUseful),\n         _ => (),\n     }\n "}, {"sha": "b439915c7adfd612cc87fc5c66fd74d410db1a3f", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -11,9 +11,7 @@ use hir_def::{\n };\n use hir_expand::diagnostics::DiagnosticSink;\n \n-use crate::{\n-    db::HirDatabase, diagnostics::MissingUnsafe, ApplicationTy, InferenceResult, Ty, TypeCtor,\n-};\n+use crate::{db::HirDatabase, diagnostics::MissingUnsafe, InferenceResult, Ty};\n \n pub(super) struct UnsafeValidator<'a, 'b: 'a> {\n     owner: DefWithBodyId,\n@@ -112,7 +110,7 @@ fn walk_unsafe(\n             }\n         }\n         Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n-            if let Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(..), .. }) = &infer[*expr] {\n+            if let Ty::RawPtr(..) = &infer[*expr] {\n                 unsafe_exprs.push(UnsafeExpr { expr: current, inside_unsafe_block });\n             }\n         }"}, {"sha": "cd9dcf6c0a553af36d8b4780bbee6ce17994c21f", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 78, "deletions": 97, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -3,9 +3,8 @@\n use std::{borrow::Cow, fmt};\n \n use crate::{\n-    db::HirDatabase, primitive, utils::generics, ApplicationTy, CallableDefId, FnSig,\n-    GenericPredicate, Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Scalar, Substs,\n-    TraitRef, Ty, TypeCtor,\n+    db::HirDatabase, primitive, utils::generics, CallableDefId, FnSig, GenericPredicate, Lifetime,\n+    Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Scalar, Substs, TraitRef, Ty,\n };\n use arrayvec::ArrayVec;\n use hir_def::{\n@@ -235,39 +234,62 @@ impl HirDisplay for &Ty {\n     }\n }\n \n-impl HirDisplay for ApplicationTy {\n+impl HirDisplay for ProjectionTy {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n \n-        match self.ctor {\n-            TypeCtor::Scalar(Scalar::Bool) => write!(f, \"bool\")?,\n-            TypeCtor::Scalar(Scalar::Char) => write!(f, \"char\")?,\n-            TypeCtor::Scalar(Scalar::Float(t)) => {\n-                write!(f, \"{}\", primitive::float_ty_to_string(t))?\n-            }\n-            TypeCtor::Scalar(Scalar::Int(t)) => write!(f, \"{}\", primitive::int_ty_to_string(t))?,\n-            TypeCtor::Scalar(Scalar::Uint(t)) => write!(f, \"{}\", primitive::uint_ty_to_string(t))?,\n-            TypeCtor::Str => write!(f, \"str\")?,\n-            TypeCtor::Slice => {\n-                let t = self.parameters.as_single();\n+        let trait_ = f.db.trait_data(self.trait_(f.db));\n+        let first_parameter = self.parameters[0].into_displayable(\n+            f.db,\n+            f.max_size,\n+            f.omit_verbose_types,\n+            f.display_target,\n+        );\n+        write!(f, \"<{} as {}\", first_parameter, trait_.name)?;\n+        if self.parameters.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.parameters[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        write!(f, \">::{}\", f.db.type_alias_data(self.associated_ty).name)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        match self {\n+            Ty::Never => write!(f, \"!\")?,\n+            Ty::Str => write!(f, \"str\")?,\n+            Ty::Scalar(Scalar::Bool) => write!(f, \"bool\")?,\n+            Ty::Scalar(Scalar::Char) => write!(f, \"char\")?,\n+            &Ty::Scalar(Scalar::Float(t)) => write!(f, \"{}\", primitive::float_ty_to_string(t))?,\n+            &Ty::Scalar(Scalar::Int(t)) => write!(f, \"{}\", primitive::int_ty_to_string(t))?,\n+            &Ty::Scalar(Scalar::Uint(t)) => write!(f, \"{}\", primitive::uint_ty_to_string(t))?,\n+            Ty::Slice(parameters) => {\n+                let t = parameters.as_single();\n                 write!(f, \"[\")?;\n                 t.hir_fmt(f)?;\n                 write!(f, \"]\")?;\n             }\n-            TypeCtor::Array => {\n-                let t = self.parameters.as_single();\n+            Ty::Array(parameters) => {\n+                let t = parameters.as_single();\n                 write!(f, \"[\")?;\n                 t.hir_fmt(f)?;\n                 write!(f, \"; _]\")?;\n             }\n-            TypeCtor::RawPtr(m) | TypeCtor::Ref(m) => {\n-                let t = self.parameters.as_single();\n+            Ty::RawPtr(m, parameters) | Ty::Ref(m, parameters) => {\n+                let t = parameters.as_single();\n                 let ty_display =\n                     t.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n \n-                if matches!(self.ctor, TypeCtor::RawPtr(_)) {\n+                if matches!(self, Ty::RawPtr(..)) {\n                     write!(f, \"*{}\", m.as_keyword_for_ptr())?;\n                 } else {\n                     write!(f, \"&{}\", m.as_keyword_for_ref())?;\n@@ -308,25 +330,24 @@ impl HirDisplay for ApplicationTy {\n                     write!(f, \"{}\", ty_display)?;\n                 }\n             }\n-            TypeCtor::Never => write!(f, \"!\")?,\n-            TypeCtor::Tuple { .. } => {\n-                let ts = &self.parameters;\n-                if ts.len() == 1 {\n+            Ty::Tuple { substs, .. } => {\n+                if substs.len() == 1 {\n                     write!(f, \"(\")?;\n-                    ts[0].hir_fmt(f)?;\n+                    substs[0].hir_fmt(f)?;\n                     write!(f, \",)\")?;\n                 } else {\n                     write!(f, \"(\")?;\n-                    f.write_joined(&*ts.0, \", \")?;\n+                    f.write_joined(&*substs.0, \", \")?;\n                     write!(f, \")\")?;\n                 }\n             }\n-            TypeCtor::FnPtr { is_varargs, .. } => {\n-                let sig = FnSig::from_fn_ptr_substs(&self.parameters, is_varargs);\n+            Ty::FnPtr { is_varargs, substs, .. } => {\n+                let sig = FnSig::from_fn_ptr_substs(&substs, *is_varargs);\n                 sig.hir_fmt(f)?;\n             }\n-            TypeCtor::FnDef(def) => {\n-                let sig = f.db.callable_item_signature(def).subst(&self.parameters);\n+            Ty::FnDef(def, parameters) => {\n+                let def = *def;\n+                let sig = f.db.callable_item_signature(def).subst(parameters);\n                 match def {\n                     CallableDefId::FunctionId(ff) => {\n                         write!(f, \"fn {}\", f.db.function_data(ff).name)?\n@@ -336,15 +357,15 @@ impl HirDisplay for ApplicationTy {\n                         write!(f, \"{}\", f.db.enum_data(e.parent).variants[e.local_id].name)?\n                     }\n                 };\n-                if self.parameters.len() > 0 {\n+                if parameters.len() > 0 {\n                     let generics = generics(f.db.upcast(), def.into());\n                     let (parent_params, self_param, type_params, _impl_trait_params) =\n                         generics.provenance_split();\n                     let total_len = parent_params + self_param + type_params;\n                     // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n                     if total_len > 0 {\n                         write!(f, \"<\")?;\n-                        f.write_joined(&self.parameters.0[..total_len], \", \")?;\n+                        f.write_joined(&parameters.0[..total_len], \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 }\n@@ -363,10 +384,10 @@ impl HirDisplay for ApplicationTy {\n                     write!(f, \" -> {}\", ret_display)?;\n                 }\n             }\n-            TypeCtor::Adt(def_id) => {\n+            Ty::Adt(def_id, parameters) => {\n                 match f.display_target {\n                     DisplayTarget::Diagnostics | DisplayTarget::Test => {\n-                        let name = match def_id {\n+                        let name = match *def_id {\n                             AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n                             AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n                             AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n@@ -376,7 +397,7 @@ impl HirDisplay for ApplicationTy {\n                     DisplayTarget::SourceCode { module_id } => {\n                         if let Some(path) = find_path::find_path(\n                             f.db.upcast(),\n-                            ItemInNs::Types(def_id.into()),\n+                            ItemInNs::Types((*def_id).into()),\n                             module_id,\n                         ) {\n                             write!(f, \"{}\", path)?;\n@@ -388,38 +409,37 @@ impl HirDisplay for ApplicationTy {\n                     }\n                 }\n \n-                if self.parameters.len() > 0 {\n+                if parameters.len() > 0 {\n                     let parameters_to_write =\n                         if f.display_target.is_source_code() || f.omit_verbose_types() {\n                             match self\n-                                .ctor\n                                 .as_generic_def()\n                                 .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n                                 .filter(|defaults| !defaults.is_empty())\n                             {\n-                                None => self.parameters.0.as_ref(),\n+                                None => parameters.0.as_ref(),\n                                 Some(default_parameters) => {\n                                     let mut default_from = 0;\n-                                    for (i, parameter) in self.parameters.iter().enumerate() {\n+                                    for (i, parameter) in parameters.iter().enumerate() {\n                                         match (parameter, default_parameters.get(i)) {\n                                             (&Ty::Unknown, _) | (_, None) => {\n                                                 default_from = i + 1;\n                                             }\n                                             (_, Some(default_parameter)) => {\n                                                 let actual_default = default_parameter\n                                                     .clone()\n-                                                    .subst(&self.parameters.prefix(i));\n+                                                    .subst(&parameters.prefix(i));\n                                                 if parameter != &actual_default {\n                                                     default_from = i + 1;\n                                                 }\n                                             }\n                                         }\n                                     }\n-                                    &self.parameters.0[0..default_from]\n+                                    &parameters.0[0..default_from]\n                                 }\n                             }\n                         } else {\n-                            self.parameters.0.as_ref()\n+                            parameters.0.as_ref()\n                         };\n                     if !parameters_to_write.is_empty() {\n                         write!(f, \"<\")?;\n@@ -428,61 +448,59 @@ impl HirDisplay for ApplicationTy {\n                     }\n                 }\n             }\n-            TypeCtor::AssociatedType(type_alias) => {\n+            Ty::AssociatedType(type_alias, parameters) => {\n                 let trait_ = match type_alias.lookup(f.db.upcast()).container {\n                     AssocContainerId::TraitId(it) => it,\n                     _ => panic!(\"not an associated type\"),\n                 };\n                 let trait_ = f.db.trait_data(trait_);\n-                let type_alias_data = f.db.type_alias_data(type_alias);\n+                let type_alias_data = f.db.type_alias_data(*type_alias);\n \n                 // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n                 if f.display_target.is_test() {\n                     write!(f, \"{}::{}\", trait_.name, type_alias_data.name)?;\n-                    if self.parameters.len() > 0 {\n+                    if parameters.len() > 0 {\n                         write!(f, \"<\")?;\n-                        f.write_joined(&*self.parameters.0, \", \")?;\n+                        f.write_joined(&*parameters.0, \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 } else {\n-                    let projection_ty = ProjectionTy {\n-                        associated_ty: type_alias,\n-                        parameters: self.parameters.clone(),\n-                    };\n+                    let projection_ty =\n+                        ProjectionTy { associated_ty: *type_alias, parameters: parameters.clone() };\n \n                     projection_ty.hir_fmt(f)?;\n                 }\n             }\n-            TypeCtor::ForeignType(type_alias) => {\n-                let type_alias = f.db.type_alias_data(type_alias);\n+            Ty::ForeignType(type_alias, parameters) => {\n+                let type_alias = f.db.type_alias_data(*type_alias);\n                 write!(f, \"{}\", type_alias.name)?;\n-                if self.parameters.len() > 0 {\n+                if parameters.len() > 0 {\n                     write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    f.write_joined(&*parameters.0, \", \")?;\n                     write!(f, \">\")?;\n                 }\n             }\n-            TypeCtor::OpaqueType(opaque_ty_id) => {\n+            Ty::OpaqueType(opaque_ty_id, parameters) => {\n                 match opaque_ty_id {\n-                    OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n+                    &OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n                             f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        let bounds = data.subst(&self.parameters);\n+                        let bounds = data.subst(&parameters);\n                         write_bounds_like_dyn_trait_with_prefix(\"impl\", &bounds.value, f)?;\n                         // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n                     }\n                     OpaqueTyId::AsyncBlockTypeImplTrait(..) => {\n                         write!(f, \"impl Future<Output = \")?;\n-                        self.parameters[0].hir_fmt(f)?;\n+                        parameters[0].hir_fmt(f)?;\n                         write!(f, \">\")?;\n                     }\n                 }\n             }\n-            TypeCtor::Closure { .. } => {\n-                let sig = self.parameters[0].callable_sig(f.db);\n+            Ty::Closure { substs, .. } => {\n+                let sig = substs[0].callable_sig(f.db);\n                 if let Some(sig) = sig {\n                     if sig.params().is_empty() {\n                         write!(f, \"||\")?;\n@@ -505,43 +523,6 @@ impl HirDisplay for ApplicationTy {\n                     write!(f, \"{{closure}}\")?;\n                 }\n             }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        let trait_ = f.db.trait_data(self.trait_(f.db));\n-        let first_parameter = self.parameters[0].into_displayable(\n-            f.db,\n-            f.max_size,\n-            f.omit_verbose_types,\n-            f.display_target,\n-        );\n-        write!(f, \"<{} as {}\", first_parameter, trait_.name)?;\n-        if self.parameters.len() > 1 {\n-            write!(f, \"<\")?;\n-            f.write_joined(&self.parameters[1..], \", \")?;\n-            write!(f, \">\")?;\n-        }\n-        write!(f, \">::{}\", f.db.type_alias_data(self.associated_ty).name)?;\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        match self {\n-            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n             Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n             Ty::Placeholder(id) => {\n                 let generics = generics(f.db.upcast(), id.parent);"}, {"sha": "a1769729ffcf703dff138c07eaece91cbbe01f44", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -38,23 +38,14 @@ use syntax::SmolStr;\n use super::{\n     primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n+    InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeWalk,\n };\n use crate::{\n     db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode, Scalar,\n };\n \n pub(crate) use unify::unify;\n \n-macro_rules! ty_app {\n-    ($ctor:pat, $param:pat) => {\n-        crate::Ty::Apply(crate::ApplicationTy { ctor: $ctor, parameters: $param })\n-    };\n-    ($ctor:pat) => {\n-        ty_app!($ctor, _)\n-    };\n-}\n-\n mod unify;\n mod path;\n mod expr;\n@@ -684,9 +675,9 @@ impl InferTy {\n     fn fallback_value(self) -> Ty {\n         match self {\n             InferTy::TypeVar(..) => Ty::Unknown,\n-            InferTy::IntVar(..) => Ty::simple(TypeCtor::Scalar(Scalar::Int(IntTy::I32))),\n-            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Scalar(Scalar::Float(FloatTy::F64))),\n-            InferTy::MaybeNeverTypeVar(..) => Ty::simple(TypeCtor::Never),\n+            InferTy::IntVar(..) => Ty::Scalar(Scalar::Int(IntTy::I32)),\n+            InferTy::FloatVar(..) => Ty::Scalar(Scalar::Float(FloatTy::F64)),\n+            InferTy::MaybeNeverTypeVar(..) => Ty::Never,\n         }\n     }\n }"}, {"sha": "cd5fb3252876fd00d196a866f28650bf220dd860", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 36, "deletions": 43, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -7,7 +7,7 @@\n use hir_def::{lang_item::LangItemTarget, type_ref::Mutability};\n use test_utils::mark;\n \n-use crate::{autoderef, traits::Solution, Obligation, Substs, TraitRef, Ty, TypeCtor};\n+use crate::{autoderef, traits::Solution, Obligation, Substs, TraitRef, Ty};\n \n use super::{unify::TypeVarValue, InEnvironment, InferTy, InferenceContext};\n \n@@ -33,7 +33,7 @@ impl<'a> InferenceContext<'a> {\n         } else if self.coerce(ty2, ty1) {\n             ty1.clone()\n         } else {\n-            if let (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnDef(_))) = (ty1, ty2) {\n+            if let (Ty::FnDef(..), Ty::FnDef(..)) = (ty1, ty2) {\n                 mark::hit!(coerce_fn_reification);\n                 // Special case: two function types. Try to coerce both to\n                 // pointers to have a chance at getting a match. See\n@@ -53,12 +53,12 @@ impl<'a> InferenceContext<'a> {\n     fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n         match (&from_ty, to_ty) {\n             // Never type will make type variable to fallback to Never Type instead of Unknown.\n-            (ty_app!(TypeCtor::Never), Ty::Infer(InferTy::TypeVar(tv))) => {\n+            (Ty::Never, Ty::Infer(InferTy::TypeVar(tv))) => {\n                 let var = self.table.new_maybe_never_type_var();\n                 self.table.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n                 return true;\n             }\n-            (ty_app!(TypeCtor::Never), _) => return true,\n+            (Ty::Never, _) => return true,\n \n             // Trivial cases, this should go after `never` check to\n             // avoid infer result type to be never\n@@ -71,38 +71,33 @@ impl<'a> InferenceContext<'a> {\n \n         // Pointer weakening and function to pointer\n         match (&mut from_ty, to_ty) {\n-            // `*mut T`, `&mut T, `&T`` -> `*const T`\n+            // `*mut T` -> `*const T`\n             // `&mut T` -> `&T`\n-            // `&mut T` -> `*mut T`\n-            (ty_app!(c1@TypeCtor::RawPtr(_)), ty_app!(c2@TypeCtor::RawPtr(Mutability::Shared)))\n-            | (ty_app!(c1@TypeCtor::Ref(_)), ty_app!(c2@TypeCtor::RawPtr(Mutability::Shared)))\n-            | (ty_app!(c1@TypeCtor::Ref(_)), ty_app!(c2@TypeCtor::Ref(Mutability::Shared)))\n-            | (ty_app!(c1@TypeCtor::Ref(Mutability::Mut)), ty_app!(c2@TypeCtor::RawPtr(_))) => {\n-                *c1 = *c2;\n+            (Ty::RawPtr(m1, ..), Ty::RawPtr(m2 @ Mutability::Shared, ..))\n+            | (Ty::Ref(m1, ..), Ty::Ref(m2 @ Mutability::Shared, ..)) => {\n+                *m1 = *m2;\n+            }\n+            // `&T` -> `*const T`\n+            // `&mut T` -> `*mut T`/`*const T`\n+            (Ty::Ref(.., substs), &Ty::RawPtr(m2 @ Mutability::Shared, ..))\n+            | (Ty::Ref(Mutability::Mut, substs), &Ty::RawPtr(m2, ..)) => {\n+                from_ty = Ty::RawPtr(m2, substs.clone());\n             }\n \n-            // Illegal mutablity conversion\n-            (\n-                ty_app!(TypeCtor::RawPtr(Mutability::Shared)),\n-                ty_app!(TypeCtor::RawPtr(Mutability::Mut)),\n-            )\n-            | (\n-                ty_app!(TypeCtor::Ref(Mutability::Shared)),\n-                ty_app!(TypeCtor::Ref(Mutability::Mut)),\n-            ) => return false,\n+            // Illegal mutability conversion\n+            (Ty::RawPtr(Mutability::Shared, ..), Ty::RawPtr(Mutability::Mut, ..))\n+            | (Ty::Ref(Mutability::Shared, ..), Ty::Ref(Mutability::Mut, ..)) => return false,\n \n             // `{function_type}` -> `fn()`\n-            (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnPtr { .. })) => {\n-                match from_ty.callable_sig(self.db) {\n-                    None => return false,\n-                    Some(sig) => {\n-                        from_ty = Ty::fn_ptr(sig);\n-                    }\n+            (Ty::FnDef(..), Ty::FnPtr { .. }) => match from_ty.callable_sig(self.db) {\n+                None => return false,\n+                Some(sig) => {\n+                    from_ty = Ty::fn_ptr(sig);\n                 }\n-            }\n+            },\n \n-            (ty_app!(TypeCtor::Closure { .. }, params), ty_app!(TypeCtor::FnPtr { .. })) => {\n-                from_ty = params[0].clone();\n+            (Ty::Closure { substs, .. }, Ty::FnPtr { .. }) => {\n+                from_ty = substs[0].clone();\n             }\n \n             _ => {}\n@@ -115,9 +110,7 @@ impl<'a> InferenceContext<'a> {\n         // Auto Deref if cannot coerce\n         match (&from_ty, to_ty) {\n             // FIXME: DerefMut\n-            (ty_app!(TypeCtor::Ref(_), st1), ty_app!(TypeCtor::Ref(_), st2)) => {\n-                self.unify_autoderef_behind_ref(&st1[0], &st2[0])\n-            }\n+            (Ty::Ref(_, st1), Ty::Ref(_, st2)) => self.unify_autoderef_behind_ref(&st1[0], &st2[0]),\n \n             // Otherwise, normal unify\n             _ => self.unify(&from_ty, to_ty),\n@@ -178,17 +171,17 @@ impl<'a> InferenceContext<'a> {\n             },\n         ) {\n             let derefed_ty = canonicalized.decanonicalize_ty(derefed_ty.value);\n-            match (&*self.resolve_ty_shallow(&derefed_ty), &*to_ty) {\n-                // Stop when constructor matches.\n-                (ty_app!(from_ctor, st1), ty_app!(to_ctor, st2)) if from_ctor == to_ctor => {\n-                    // It will not recurse to `coerce`.\n-                    return self.table.unify_substs(st1, st2, 0);\n-                }\n-                _ => {\n-                    if self.table.unify_inner_trivial(&derefed_ty, &to_ty, 0) {\n-                        return true;\n-                    }\n-                }\n+            let from_ty = self.resolve_ty_shallow(&derefed_ty);\n+            // Stop when constructor matches.\n+            if from_ty.equals_ctor(&to_ty) {\n+                // It will not recurse to `coerce`.\n+                return match (from_ty.substs(), to_ty.substs()) {\n+                    (Some(st1), Some(st2)) => self.table.unify_substs(st1, st2, 0),\n+                    (None, None) => true,\n+                    _ => false,\n+                };\n+            } else if self.table.unify_inner_trivial(&derefed_ty, &to_ty, 0) {\n+                return true;\n             }\n         }\n "}, {"sha": "2369c9bef02710bebc3001758695e29388fca647", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 95, "deletions": 143, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -18,8 +18,8 @@ use crate::{\n     primitive::{self, UintTy},\n     traits::{FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, Binders, CallableDefId, InferTy, Mutability, Obligation, OpaqueTyId, Rawness,\n-    Scalar, Substs, TraitRef, Ty, TypeCtor,\n+    Binders, CallableDefId, InferTy, Mutability, Obligation, OpaqueTyId, Rawness, Scalar, Substs,\n+    TraitRef, Ty,\n };\n \n use super::{\n@@ -82,10 +82,7 @@ impl<'a> InferenceContext<'a> {\n             arg_tys.push(arg);\n         }\n         let parameters = param_builder.build();\n-        let arg_ty = Ty::Apply(ApplicationTy {\n-            ctor: TypeCtor::Tuple { cardinality: num_args as u16 },\n-            parameters,\n-        });\n+        let arg_ty = Ty::Tuple { cardinality: num_args as u16, substs: parameters };\n         let substs =\n             Substs::build_for_generics(&generic_params).push(ty.clone()).push(arg_ty).build();\n \n@@ -120,10 +117,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::Missing => Ty::Unknown,\n             Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n-                self.infer_expr(\n-                    *condition,\n-                    &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool))),\n-                );\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Scalar(Scalar::Bool)));\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut both_arms_diverge = Diverges::Always;\n@@ -178,7 +172,7 @@ impl<'a> InferenceContext<'a> {\n                 // existenail type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n                 let inner_ty = self.infer_expr(*body, &Expectation::none());\n                 let opaque_ty_id = OpaqueTyId::AsyncBlockTypeImplTrait(self.owner, *body);\n-                Ty::apply_one(TypeCtor::OpaqueType(opaque_ty_id), inner_ty)\n+                Ty::OpaqueType(opaque_ty_id, Substs::single(inner_ty))\n             }\n             Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n@@ -196,7 +190,7 @@ impl<'a> InferenceContext<'a> {\n                 if ctxt.may_break {\n                     ctxt.break_ty\n                 } else {\n-                    Ty::simple(TypeCtor::Never)\n+                    Ty::Never\n                 }\n             }\n             Expr::While { condition, body, label } => {\n@@ -206,10 +200,7 @@ impl<'a> InferenceContext<'a> {\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 // while let is desugared to a match loop, so this is always simple while\n-                self.infer_expr(\n-                    *condition,\n-                    &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool))),\n-                );\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Scalar(Scalar::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 // the body may not run, so it diverging doesn't mean we diverge\n@@ -256,12 +247,13 @@ impl<'a> InferenceContext<'a> {\n                     None => self.table.new_type_var(),\n                 };\n                 sig_tys.push(ret_ty.clone());\n-                let sig_ty = Ty::apply(\n-                    TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1, is_varargs: false },\n-                    Substs(sig_tys.clone().into()),\n-                );\n+                let sig_ty = Ty::FnPtr {\n+                    num_args: sig_tys.len() as u16 - 1,\n+                    is_varargs: false,\n+                    substs: Substs(sig_tys.clone().into()),\n+                };\n                 let closure_ty =\n-                    Ty::apply_one(TypeCtor::Closure { def: self.owner, expr: tgt_expr }, sig_ty);\n+                    Ty::Closure { def: self.owner, expr: tgt_expr, substs: Substs::single(sig_ty) };\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n@@ -312,11 +304,8 @@ impl<'a> InferenceContext<'a> {\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n \n-                let mut result_ty = if arms.is_empty() {\n-                    Ty::simple(TypeCtor::Never)\n-                } else {\n-                    self.table.new_type_var()\n-                };\n+                let mut result_ty =\n+                    if arms.is_empty() { Ty::Never } else { self.table.new_type_var() };\n \n                 let matchee_diverges = self.diverges;\n                 let mut all_arms_diverge = Diverges::Always;\n@@ -327,7 +316,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,\n-                            &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool))),\n+                            &Expectation::has_type(Ty::Scalar(Scalar::Bool)),\n                         );\n                     }\n \n@@ -345,7 +334,7 @@ impl<'a> InferenceContext<'a> {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n-            Expr::Continue { .. } => Ty::simple(TypeCtor::Never),\n+            Expr::Continue { .. } => Ty::Never,\n             Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::none())\n@@ -370,8 +359,7 @@ impl<'a> InferenceContext<'a> {\n                         expr: tgt_expr,\n                     });\n                 }\n-\n-                Ty::simple(TypeCtor::Never)\n+                Ty::Never\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n@@ -380,14 +368,14 @@ impl<'a> InferenceContext<'a> {\n                     let unit = Ty::unit();\n                     self.coerce(&unit, &self.return_ty.clone());\n                 }\n-                Ty::simple(TypeCtor::Never)\n+                Ty::Never\n             }\n             Expr::Yield { expr } => {\n                 // FIXME: track yield type for coercion\n                 if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n-                Ty::simple(TypeCtor::Never)\n+                Ty::Never\n             }\n             Expr::RecordLit { path, fields, spread } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n@@ -397,7 +385,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.unify(&ty, &expected.ty);\n \n-                let substs = ty.substs().unwrap_or_else(Substs::empty);\n+                let substs = ty.substs().cloned().unwrap_or_else(Substs::empty);\n                 let field_types = def_id.map(|it| self.db.field_types(it)).unwrap_or_default();\n                 let variant_data = def_id.map(|it| variant_data(self.db.upcast(), it));\n                 for (field_idx, field) in fields.iter().enumerate() {\n@@ -436,30 +424,23 @@ impl<'a> InferenceContext<'a> {\n                     },\n                 )\n                 .find_map(|derefed_ty| match canonicalized.decanonicalize_ty(derefed_ty.value) {\n-                    Ty::Apply(a_ty) => match a_ty.ctor {\n-                        TypeCtor::Tuple { .. } => name\n-                            .as_tuple_index()\n-                            .and_then(|idx| a_ty.parameters.0.get(idx).cloned()),\n-                        TypeCtor::Adt(AdtId::StructId(s)) => {\n-                            self.db.struct_data(s).variant_data.field(name).map(|local_id| {\n-                                let field = FieldId { parent: s.into(), local_id };\n-                                self.write_field_resolution(tgt_expr, field);\n-                                self.db.field_types(s.into())[field.local_id]\n-                                    .clone()\n-                                    .subst(&a_ty.parameters)\n-                            })\n-                        }\n-                        TypeCtor::Adt(AdtId::UnionId(u)) => {\n-                            self.db.union_data(u).variant_data.field(name).map(|local_id| {\n-                                let field = FieldId { parent: u.into(), local_id };\n-                                self.write_field_resolution(tgt_expr, field);\n-                                self.db.field_types(u.into())[field.local_id]\n-                                    .clone()\n-                                    .subst(&a_ty.parameters)\n-                            })\n-                        }\n-                        _ => None,\n-                    },\n+                    Ty::Tuple { substs, .. } => {\n+                        name.as_tuple_index().and_then(|idx| substs.0.get(idx).cloned())\n+                    }\n+                    Ty::Adt(AdtId::StructId(s), parameters) => {\n+                        self.db.struct_data(s).variant_data.field(name).map(|local_id| {\n+                            let field = FieldId { parent: s.into(), local_id };\n+                            self.write_field_resolution(tgt_expr, field);\n+                            self.db.field_types(s.into())[field.local_id].clone().subst(&parameters)\n+                        })\n+                    }\n+                    Ty::Adt(AdtId::UnionId(u), parameters) => {\n+                        self.db.union_data(u).variant_data.field(name).map(|local_id| {\n+                            let field = FieldId { parent: u.into(), local_id };\n+                            self.write_field_resolution(tgt_expr, field);\n+                            self.db.field_types(u.into())[field.local_id].clone().subst(&parameters)\n+                        })\n+                    }\n                     _ => None,\n                 })\n                 .unwrap_or(Ty::Unknown);\n@@ -497,19 +478,18 @@ impl<'a> InferenceContext<'a> {\n                     Expectation::none()\n                 };\n                 let inner_ty = self.infer_expr_inner(*expr, &expectation);\n-                let ty = match rawness {\n-                    Rawness::RawPtr => TypeCtor::RawPtr(*mutability),\n-                    Rawness::Ref => TypeCtor::Ref(*mutability),\n-                };\n-                Ty::apply_one(ty, inner_ty)\n+                match rawness {\n+                    Rawness::RawPtr => Ty::RawPtr(*mutability, Substs::single(inner_ty)),\n+                    Rawness::Ref => Ty::Ref(*mutability, Substs::single(inner_ty)),\n+                }\n             }\n             Expr::Box { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 if let Some(box_) = self.resolve_boxed_box() {\n-                    let mut sb = Substs::build_for_type_ctor(self.db, TypeCtor::Adt(box_));\n+                    let mut sb = Substs::builder(generics(self.db.upcast(), box_.into()).len());\n                     sb = sb.push(inner_ty);\n                     sb = sb.fill(repeat_with(|| self.table.new_type_var()));\n-                    Ty::apply(TypeCtor::Adt(box_), sb.build())\n+                    Ty::Adt(box_, sb.build())\n                 } else {\n                     Ty::Unknown\n                 }\n@@ -539,14 +519,9 @@ impl<'a> InferenceContext<'a> {\n                     UnaryOp::Neg => {\n                         match &inner_ty {\n                             // Fast path for builtins\n-                            Ty::Apply(ApplicationTy {\n-                                ctor: TypeCtor::Scalar(Scalar::Int(_)),\n-                                ..\n-                            })\n-                            | Ty::Apply(ApplicationTy {\n-                                ctor: TypeCtor::Scalar(Scalar::Float(_)),\n-                                ..\n-                            })\n+                            Ty::Scalar(Scalar::Int(_))\n+                            | Ty::Scalar(Scalar::Uint(_))\n+                            | Ty::Scalar(Scalar::Float(_))\n                             | Ty::Infer(InferTy::IntVar(..))\n                             | Ty::Infer(InferTy::FloatVar(..)) => inner_ty,\n                             // Otherwise we resolve via the std::ops::Neg trait\n@@ -557,18 +532,9 @@ impl<'a> InferenceContext<'a> {\n                     UnaryOp::Not => {\n                         match &inner_ty {\n                             // Fast path for builtins\n-                            Ty::Apply(ApplicationTy {\n-                                ctor: TypeCtor::Scalar(Scalar::Bool),\n-                                ..\n-                            })\n-                            | Ty::Apply(ApplicationTy {\n-                                ctor: TypeCtor::Scalar(Scalar::Int(_)),\n-                                ..\n-                            })\n-                            | Ty::Apply(ApplicationTy {\n-                                ctor: TypeCtor::Scalar(Scalar::Uint(_)),\n-                                ..\n-                            })\n+                            Ty::Scalar(Scalar::Bool)\n+                            | Ty::Scalar(Scalar::Int(_))\n+                            | Ty::Scalar(Scalar::Uint(_))\n                             | Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n                             // Otherwise we resolve via the std::ops::Not trait\n                             _ => self\n@@ -580,9 +546,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::BinaryOp { lhs, rhs, op } => match op {\n                 Some(op) => {\n                     let lhs_expectation = match op {\n-                        BinaryOp::LogicOp(..) => {\n-                            Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool)))\n-                        }\n+                        BinaryOp::LogicOp(..) => Expectation::has_type(Ty::Scalar(Scalar::Bool)),\n                         _ => Expectation::none(),\n                     };\n                     let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n@@ -613,31 +577,31 @@ impl<'a> InferenceContext<'a> {\n                 let rhs_ty = rhs.map(|e| self.infer_expr(e, &rhs_expect));\n                 match (range_type, lhs_ty, rhs_ty) {\n                     (RangeOp::Exclusive, None, None) => match self.resolve_range_full() {\n-                        Some(adt) => Ty::simple(TypeCtor::Adt(adt)),\n+                        Some(adt) => Ty::Adt(adt, Substs::empty()),\n                         None => Ty::Unknown,\n                     },\n                     (RangeOp::Exclusive, None, Some(ty)) => match self.resolve_range_to() {\n-                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        Some(adt) => Ty::Adt(adt, Substs::single(ty)),\n                         None => Ty::Unknown,\n                     },\n                     (RangeOp::Inclusive, None, Some(ty)) => {\n                         match self.resolve_range_to_inclusive() {\n-                            Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                            Some(adt) => Ty::Adt(adt, Substs::single(ty)),\n                             None => Ty::Unknown,\n                         }\n                     }\n                     (RangeOp::Exclusive, Some(_), Some(ty)) => match self.resolve_range() {\n-                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        Some(adt) => Ty::Adt(adt, Substs::single(ty)),\n                         None => Ty::Unknown,\n                     },\n                     (RangeOp::Inclusive, Some(_), Some(ty)) => {\n                         match self.resolve_range_inclusive() {\n-                            Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                            Some(adt) => Ty::Adt(adt, Substs::single(ty)),\n                             None => Ty::Unknown,\n                         }\n                     }\n                     (RangeOp::Exclusive, Some(ty), None) => match self.resolve_range_from() {\n-                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        Some(adt) => Ty::Adt(adt, Substs::single(ty)),\n                         None => Ty::Unknown,\n                     },\n                     (RangeOp::Inclusive, _, None) => Ty::Unknown,\n@@ -671,7 +635,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Tuple { exprs } => {\n                 let mut tys = match &expected.ty {\n-                    ty_app!(TypeCtor::Tuple { .. }, st) => st\n+                    Ty::Tuple { substs, .. } => substs\n                         .iter()\n                         .cloned()\n                         .chain(repeat_with(|| self.table.new_type_var()))\n@@ -684,15 +648,11 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_expr_coerce(*expr, &Expectation::has_type(ty.clone()));\n                 }\n \n-                Ty::apply(TypeCtor::Tuple { cardinality: tys.len() as u16 }, Substs(tys.into()))\n+                Ty::Tuple { cardinality: tys.len() as u16, substs: Substs(tys.into()) }\n             }\n             Expr::Array(array) => {\n                 let elem_ty = match &expected.ty {\n-                    // FIXME: remove when https://github.com/rust-lang/rust/issues/80501 is fixed\n-                    #[allow(unreachable_patterns)]\n-                    ty_app!(TypeCtor::Array, st) | ty_app!(TypeCtor::Slice, st) => {\n-                        st.as_single().clone()\n-                    }\n+                    Ty::Array(st) | Ty::Slice(st) => st.as_single().clone(),\n                     _ => self.table.new_type_var(),\n                 };\n \n@@ -709,42 +669,38 @@ impl<'a> InferenceContext<'a> {\n                         );\n                         self.infer_expr(\n                             *repeat,\n-                            &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Uint(\n-                                UintTy::Usize,\n-                            )))),\n+                            &Expectation::has_type(Ty::Scalar(Scalar::Uint(UintTy::Usize))),\n                         );\n                     }\n                 }\n \n-                Ty::apply_one(TypeCtor::Array, elem_ty)\n+                Ty::Array(Substs::single(elem_ty))\n             }\n             Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => Ty::simple(TypeCtor::Scalar(Scalar::Bool)),\n-                Literal::String(..) => {\n-                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), Ty::simple(TypeCtor::Str))\n-                }\n+                Literal::Bool(..) => Ty::Scalar(Scalar::Bool),\n+                Literal::String(..) => Ty::Ref(Mutability::Shared, Substs::single(Ty::Str)),\n                 Literal::ByteString(..) => {\n-                    let byte_type = Ty::simple(TypeCtor::Scalar(Scalar::Uint(UintTy::U8)));\n-                    let array_type = Ty::apply_one(TypeCtor::Array, byte_type);\n-                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), array_type)\n+                    let byte_type = Ty::Scalar(Scalar::Uint(UintTy::U8));\n+                    let array_type = Ty::Array(Substs::single(byte_type));\n+                    Ty::Ref(Mutability::Shared, Substs::single(array_type))\n                 }\n-                Literal::Char(..) => Ty::simple(TypeCtor::Scalar(Scalar::Char)),\n+                Literal::Char(..) => Ty::Scalar(Scalar::Char),\n                 Literal::Int(_v, ty) => match ty {\n-                    Some(int_ty) => Ty::simple(TypeCtor::Scalar(Scalar::Int(\n-                        primitive::int_ty_from_builtin(*int_ty),\n-                    ))),\n+                    Some(int_ty) => {\n+                        Ty::Scalar(Scalar::Int(primitive::int_ty_from_builtin(*int_ty)))\n+                    }\n                     None => self.table.new_integer_var(),\n                 },\n                 Literal::Uint(_v, ty) => match ty {\n-                    Some(int_ty) => Ty::simple(TypeCtor::Scalar(Scalar::Uint(\n-                        primitive::uint_ty_from_builtin(*int_ty),\n-                    ))),\n+                    Some(int_ty) => {\n+                        Ty::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(*int_ty)))\n+                    }\n                     None => self.table.new_integer_var(),\n                 },\n                 Literal::Float(_v, ty) => match ty {\n-                    Some(float_ty) => Ty::simple(TypeCtor::Scalar(Scalar::Float(\n-                        primitive::float_ty_from_builtin(*float_ty),\n-                    ))),\n+                    Some(float_ty) => {\n+                        Ty::Scalar(Scalar::Float(primitive::float_ty_from_builtin(*float_ty)))\n+                    }\n                     None => self.table.new_float_var(),\n                 },\n             },\n@@ -857,7 +813,7 @@ impl<'a> InferenceContext<'a> {\n         // Apply autoref so the below unification works correctly\n         // FIXME: return correct autorefs from lookup_method\n         let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n-            Some((_, mutability)) => Ty::apply_one(TypeCtor::Ref(mutability), derefed_receiver_ty),\n+            Some((_, mutability)) => Ty::Ref(mutability, Substs::single(derefed_receiver_ty)),\n             _ => derefed_receiver_ty,\n         };\n         self.unify(&expected_receiver_ty, &actual_receiver_ty);\n@@ -934,30 +890,26 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn register_obligations_for_call(&mut self, callable_ty: &Ty) {\n-        if let Ty::Apply(a_ty) = callable_ty {\n-            if let TypeCtor::FnDef(def) = a_ty.ctor {\n-                let generic_predicates = self.db.generic_predicates(def.into());\n-                for predicate in generic_predicates.iter() {\n-                    let predicate = predicate.clone().subst(&a_ty.parameters);\n-                    if let Some(obligation) = Obligation::from_predicate(predicate) {\n-                        self.obligations.push(obligation);\n-                    }\n+        if let &Ty::FnDef(def, ref parameters) = callable_ty {\n+            let generic_predicates = self.db.generic_predicates(def.into());\n+            for predicate in generic_predicates.iter() {\n+                let predicate = predicate.clone().subst(parameters);\n+                if let Some(obligation) = Obligation::from_predicate(predicate) {\n+                    self.obligations.push(obligation);\n                 }\n-                // add obligation for trait implementation, if this is a trait method\n-                match def {\n-                    CallableDefId::FunctionId(f) => {\n-                        if let AssocContainerId::TraitId(trait_) =\n-                            f.lookup(self.db.upcast()).container\n-                        {\n-                            // construct a TraitDef\n-                            let substs = a_ty\n-                                .parameters\n-                                .prefix(generics(self.db.upcast(), trait_.into()).len());\n-                            self.obligations.push(Obligation::Trait(TraitRef { trait_, substs }));\n-                        }\n+            }\n+            // add obligation for trait implementation, if this is a trait method\n+            match def {\n+                CallableDefId::FunctionId(f) => {\n+                    if let AssocContainerId::TraitId(trait_) = f.lookup(self.db.upcast()).container\n+                    {\n+                        // construct a TraitDef\n+                        let substs =\n+                            parameters.prefix(generics(self.db.upcast(), trait_.into()).len());\n+                        self.obligations.push(Obligation::Trait(TraitRef { trait_, substs }));\n                     }\n-                    CallableDefId::StructId(_) | CallableDefId::EnumVariantId(_) => {}\n                 }\n+                CallableDefId::StructId(_) | CallableDefId::EnumVariantId(_) => {}\n             }\n         }\n     }"}, {"sha": "e96e08c3cf816ebcec8bbae5f903e450439c18aa", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -13,7 +13,7 @@ use hir_expand::name::Name;\n use test_utils::mark;\n \n use super::{BindingMode, Expectation, InferenceContext};\n-use crate::{utils::variant_data, Substs, Ty, TypeCtor};\n+use crate::{utils::variant_data, Substs, Ty};\n \n impl<'a> InferenceContext<'a> {\n     fn infer_tuple_struct_pat(\n@@ -32,7 +32,7 @@ impl<'a> InferenceContext<'a> {\n         }\n         self.unify(&ty, expected);\n \n-        let substs = ty.substs().unwrap_or_else(Substs::empty);\n+        let substs = ty.substs().cloned().unwrap_or_else(Substs::empty);\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         let (pre, post) = match ellipsis {\n@@ -71,7 +71,7 @@ impl<'a> InferenceContext<'a> {\n \n         self.unify(&ty, expected);\n \n-        let substs = ty.substs().unwrap_or_else(Substs::empty);\n+        let substs = ty.substs().cloned().unwrap_or_else(Substs::empty);\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         for subpat in subpats {\n@@ -138,10 +138,7 @@ impl<'a> InferenceContext<'a> {\n                 inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns).cloned());\n                 inner_tys.extend(post.iter().zip(expectations_iter).map(infer_pat));\n \n-                Ty::apply(\n-                    TypeCtor::Tuple { cardinality: inner_tys.len() as u16 },\n-                    Substs(inner_tys.into()),\n-                )\n+                Ty::Tuple { cardinality: inner_tys.len() as u16, substs: Substs(inner_tys.into()) }\n             }\n             Pat::Or(ref pats) => {\n                 if let Some((first_pat, rest)) = pats.split_first() {\n@@ -165,7 +162,7 @@ impl<'a> InferenceContext<'a> {\n                     _ => &Ty::Unknown,\n                 };\n                 let subty = self.infer_pat(*pat, expectation, default_bm);\n-                Ty::apply_one(TypeCtor::Ref(*mutability), subty)\n+                Ty::Ref(*mutability, Substs::single(subty))\n             }\n             Pat::TupleStruct { path: p, args: subpats, ellipsis } => self.infer_tuple_struct_pat(\n                 p.as_ref(),\n@@ -198,7 +195,7 @@ impl<'a> InferenceContext<'a> {\n \n                 let bound_ty = match mode {\n                     BindingMode::Ref(mutability) => {\n-                        Ty::apply_one(TypeCtor::Ref(mutability), inner_ty.clone())\n+                        Ty::Ref(mutability, Substs::single(inner_ty.clone()))\n                     }\n                     BindingMode::Move => inner_ty.clone(),\n                 };\n@@ -207,17 +204,17 @@ impl<'a> InferenceContext<'a> {\n                 return inner_ty;\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n-                let (container_ty, elem_ty) = match &expected {\n-                    ty_app!(TypeCtor::Array, st) => (TypeCtor::Array, st.as_single().clone()),\n-                    ty_app!(TypeCtor::Slice, st) => (TypeCtor::Slice, st.as_single().clone()),\n-                    _ => (TypeCtor::Slice, Ty::Unknown),\n+                let (container_ty, elem_ty): (fn(_) -> _, _) = match &expected {\n+                    Ty::Array(st) => (Ty::Array, st.as_single().clone()),\n+                    Ty::Slice(st) => (Ty::Slice, st.as_single().clone()),\n+                    _ => (Ty::Slice, Ty::Unknown),\n                 };\n \n                 for pat_id in prefix.iter().chain(suffix) {\n                     self.infer_pat(*pat_id, &elem_ty, default_bm);\n                 }\n \n-                let pat_ty = Ty::apply_one(container_ty, elem_ty);\n+                let pat_ty = container_ty(Substs::single(elem_ty));\n                 if let Some(slice_pat_id) = slice {\n                     self.infer_pat(*slice_pat_id, &pat_ty, default_bm);\n                 }\n@@ -239,7 +236,7 @@ impl<'a> InferenceContext<'a> {\n                     };\n \n                     let inner_ty = self.infer_pat(*inner, inner_expected, default_bm);\n-                    Ty::apply_one(TypeCtor::Adt(box_adt), inner_ty)\n+                    Ty::Adt(box_adt, Substs::single(inner_ty))\n                 }\n                 None => Ty::Unknown,\n             },"}, {"sha": "2852ad5bf72fa80e557f651261abfb1dd17a19a5", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -9,7 +9,7 @@ use test_utils::mark;\n use super::{InferenceContext, Obligation};\n use crate::{\n     BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferTy, Scalar, Substs,\n-    Ty, TyKind, TypeCtor, TypeWalk,\n+    Ty, TyKind, TypeWalk,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -257,12 +257,14 @@ impl InferenceTable {\n         // try to resolve type vars first\n         let ty1 = self.resolve_ty_shallow(ty1);\n         let ty2 = self.resolve_ty_shallow(ty2);\n-        match (&*ty1, &*ty2) {\n-            (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n-                self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n+        if ty1.equals_ctor(&ty2) {\n+            match (ty1.substs(), ty2.substs()) {\n+                (Some(st1), Some(st2)) => self.unify_substs(st1, st2, depth + 1),\n+                (None, None) => true,\n+                _ => false,\n             }\n-\n-            _ => self.unify_inner_trivial(&ty1, &ty2, depth),\n+        } else {\n+            self.unify_inner_trivial(&ty1, &ty2, depth)\n         }\n     }\n \n@@ -300,24 +302,12 @@ impl InferenceTable {\n             | (other, Ty::Infer(InferTy::TypeVar(tv)))\n             | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n             | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Scalar(Scalar::Int(_))))\n-            | (other @ ty_app!(TypeCtor::Scalar(Scalar::Int(_))), Ty::Infer(InferTy::IntVar(tv)))\n-            | (\n-                Ty::Infer(InferTy::IntVar(tv)),\n-                other @ ty_app!(TypeCtor::Scalar(Scalar::Uint(_))),\n-            )\n-            | (\n-                other @ ty_app!(TypeCtor::Scalar(Scalar::Uint(_))),\n-                Ty::Infer(InferTy::IntVar(tv)),\n-            )\n-            | (\n-                Ty::Infer(InferTy::FloatVar(tv)),\n-                other @ ty_app!(TypeCtor::Scalar(Scalar::Float(_))),\n-            )\n-            | (\n-                other @ ty_app!(TypeCtor::Scalar(Scalar::Float(_))),\n-                Ty::Infer(InferTy::FloatVar(tv)),\n-            ) => {\n+            | (Ty::Infer(InferTy::IntVar(tv)), other @ Ty::Scalar(Scalar::Int(_)))\n+            | (other @ Ty::Scalar(Scalar::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n+            | (Ty::Infer(InferTy::IntVar(tv)), other @ Ty::Scalar(Scalar::Uint(_)))\n+            | (other @ Ty::Scalar(Scalar::Uint(_)), Ty::Infer(InferTy::IntVar(tv)))\n+            | (Ty::Infer(InferTy::FloatVar(tv)), other @ Ty::Scalar(Scalar::Float(_)))\n+            | (other @ Ty::Scalar(Scalar::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n                 // the type var is unknown since we tried to resolve it\n                 self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n                 true"}, {"sha": "117d69f01f36e40587ee7711017bab8f9c8e5a07", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 213, "deletions": 277, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -25,7 +25,7 @@ mod test_db;\n \n use std::{iter, mem, ops::Deref, sync::Arc};\n \n-use base_db::{salsa, CrateId};\n+use base_db::salsa;\n use hir_def::{\n     builtin_type::BuiltinType,\n     expr::ExprId,\n@@ -57,192 +57,6 @@ pub enum Lifetime {\n     Static,\n }\n \n-/// A type constructor or type name: this might be something like the primitive\n-/// type `bool`, a struct like `Vec`, or things like function pointers or\n-/// tuples.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum TypeCtor {\n-    /// a scalar type like `bool` or `u32`\n-    Scalar(Scalar),\n-\n-    /// Structures, enumerations and unions.\n-    Adt(AdtId),\n-\n-    /// The pointee of a string slice. Written as `str`.\n-    Str,\n-\n-    /// The pointee of an array slice.  Written as `[T]`.\n-    Slice,\n-\n-    /// An array with the given length. Written as `[T; n]`.\n-    Array,\n-\n-    /// A raw pointer. Written as `*mut T` or `*const T`\n-    RawPtr(Mutability),\n-\n-    /// A reference; a pointer with an associated lifetime. Written as\n-    /// `&'a mut T` or `&'a T`.\n-    Ref(Mutability),\n-\n-    /// The anonymous type of a function declaration/definition. Each\n-    /// function has a unique type, which is output (for a function\n-    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n-    ///\n-    /// This includes tuple struct / enum variant constructors as well.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar = foo; // bar: fn() -> i32 {foo}\n-    /// ```\n-    FnDef(CallableDefId),\n-\n-    /// A pointer to a function.  Written as `fn() -> i32`.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar: fn() -> i32 = foo;\n-    /// ```\n-    // FIXME make this a Ty variant like in Chalk\n-    FnPtr { num_args: u16, is_varargs: bool },\n-\n-    /// The never type `!`.\n-    Never,\n-\n-    /// A tuple type.  For example, `(i32, bool)`.\n-    Tuple { cardinality: u16 },\n-\n-    /// Represents an associated item like `Iterator::Item`.  This is used\n-    /// when we have tried to normalize a projection like `T::Item` but\n-    /// couldn't find a better representation.  In that case, we generate\n-    /// an **application type** like `(Iterator::Item)<T>`.\n-    AssociatedType(TypeAliasId),\n-\n-    /// This represents a placeholder for an opaque type in situations where we\n-    /// don't know the hidden type (i.e. currently almost always). This is\n-    /// analogous to the `AssociatedType` type constructor.\n-    /// It is also used as the type of async block, with one type parameter\n-    /// representing the Future::Output type.\n-    OpaqueType(OpaqueTyId),\n-\n-    /// Represents a foreign type declared in external blocks.\n-    ForeignType(TypeAliasId),\n-\n-    /// The type of a specific closure.\n-    ///\n-    /// The closure signature is stored in a `FnPtr` type in the first type\n-    /// parameter.\n-    Closure { def: DefWithBodyId, expr: ExprId },\n-}\n-\n-impl TypeCtor {\n-    pub fn num_ty_params(self, db: &dyn HirDatabase) -> usize {\n-        match self {\n-            TypeCtor::Scalar(_)\n-            | TypeCtor::Str\n-            | TypeCtor::Never => 0,\n-            TypeCtor::Slice\n-            | TypeCtor::Array\n-            | TypeCtor::RawPtr(_)\n-            | TypeCtor::Ref(_)\n-            | TypeCtor::Closure { .. } // 1 param representing the signature of the closure\n-            => 1,\n-            TypeCtor::Adt(adt) => {\n-                let generic_params = generics(db.upcast(), adt.into());\n-                generic_params.len()\n-            }\n-            TypeCtor::FnDef(callable) => {\n-                let generic_params = generics(db.upcast(), callable.into());\n-                generic_params.len()\n-            }\n-            TypeCtor::AssociatedType(type_alias) => {\n-                let generic_params = generics(db.upcast(), type_alias.into());\n-                generic_params.len()\n-            }\n-            TypeCtor::ForeignType(type_alias) => {\n-                let generic_params = generics(db.upcast(), type_alias.into());\n-                generic_params.len()\n-            }\n-            TypeCtor::OpaqueType(opaque_ty_id) => {\n-                match opaque_ty_id {\n-                    OpaqueTyId::ReturnTypeImplTrait(func, _) => {\n-                        let generic_params = generics(db.upcast(), func.into());\n-                        generic_params.len()\n-                    }\n-                    // 1 param representing Future::Output type.\n-                    OpaqueTyId::AsyncBlockTypeImplTrait(..) => 1,\n-                }\n-            }\n-            TypeCtor::FnPtr { num_args, is_varargs: _ } => num_args as usize + 1,\n-            TypeCtor::Tuple { cardinality } => cardinality as usize,\n-        }\n-    }\n-\n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<CrateId> {\n-        match self {\n-            TypeCtor::Scalar(_)\n-            | TypeCtor::Str\n-            | TypeCtor::Never\n-            | TypeCtor::Slice\n-            | TypeCtor::Array\n-            | TypeCtor::RawPtr(_)\n-            | TypeCtor::Ref(_)\n-            | TypeCtor::FnPtr { .. }\n-            | TypeCtor::Tuple { .. } => None,\n-            // Closure's krate is irrelevant for coherence I would think?\n-            TypeCtor::Closure { .. } => None,\n-            TypeCtor::Adt(adt) => Some(adt.module(db.upcast()).krate()),\n-            TypeCtor::FnDef(callable) => Some(callable.krate(db)),\n-            TypeCtor::AssociatedType(type_alias) => {\n-                Some(type_alias.lookup(db.upcast()).module(db.upcast()).krate())\n-            }\n-            TypeCtor::ForeignType(type_alias) => {\n-                Some(type_alias.lookup(db.upcast()).module(db.upcast()).krate())\n-            }\n-            TypeCtor::OpaqueType(opaque_ty_id) => match opaque_ty_id {\n-                OpaqueTyId::ReturnTypeImplTrait(func, _) => {\n-                    Some(func.lookup(db.upcast()).module(db.upcast()).krate())\n-                }\n-                OpaqueTyId::AsyncBlockTypeImplTrait(def, _) => {\n-                    Some(def.module(db.upcast()).krate())\n-                }\n-            },\n-        }\n-    }\n-\n-    pub fn as_generic_def(self) -> Option<GenericDefId> {\n-        match self {\n-            TypeCtor::Scalar(_)\n-            | TypeCtor::Str\n-            | TypeCtor::Never\n-            | TypeCtor::Slice\n-            | TypeCtor::Array\n-            | TypeCtor::RawPtr(_)\n-            | TypeCtor::Ref(_)\n-            | TypeCtor::FnPtr { .. }\n-            | TypeCtor::Tuple { .. }\n-            | TypeCtor::Closure { .. } => None,\n-            TypeCtor::Adt(adt) => Some(adt.into()),\n-            TypeCtor::FnDef(callable) => Some(callable.into()),\n-            TypeCtor::AssociatedType(type_alias) => Some(type_alias.into()),\n-            TypeCtor::ForeignType(type_alias) => Some(type_alias.into()),\n-            TypeCtor::OpaqueType(_impl_trait_id) => None,\n-        }\n-    }\n-}\n-\n-/// A nominal type with (maybe 0) type parameters. This might be a primitive\n-/// type like `bool`, a struct, tuple, function pointer, reference or\n-/// several other things.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct ApplicationTy {\n-    pub ctor: TypeCtor,\n-    pub parameters: Substs,\n-}\n-\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct OpaqueTy {\n     pub opaque_ty_id: OpaqueTyId,\n@@ -293,10 +107,80 @@ impl TypeWalk for ProjectionTy {\n /// This should be cheap to clone.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum Ty {\n-    /// A nominal type with (maybe 0) type parameters. This might be a primitive\n-    /// type like `bool`, a struct, tuple, function pointer, reference or\n-    /// several other things.\n-    Apply(ApplicationTy),\n+    /// Structures, enumerations and unions.\n+    Adt(AdtId, Substs),\n+\n+    /// Represents an associated item like `Iterator::Item`.  This is used\n+    /// when we have tried to normalize a projection like `T::Item` but\n+    /// couldn't find a better representation.  In that case, we generate\n+    /// an **application type** like `(Iterator::Item)<T>`.\n+    AssociatedType(TypeAliasId, Substs),\n+\n+    /// a scalar type like `bool` or `u32`\n+    Scalar(Scalar),\n+\n+    /// A tuple type.  For example, `(i32, bool)`.\n+    Tuple { cardinality: u16, substs: Substs },\n+\n+    /// An array with the given length. Written as `[T; n]`.\n+    Array(Substs),\n+\n+    /// The pointee of an array slice.  Written as `[T]`.\n+    Slice(Substs),\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    RawPtr(Mutability, Substs),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&'a mut T` or `&'a T`.\n+    Ref(Mutability, Substs),\n+\n+    /// This represents a placeholder for an opaque type in situations where we\n+    /// don't know the hidden type (i.e. currently almost always). This is\n+    /// analogous to the `AssociatedType` type constructor.\n+    /// It is also used as the type of async block, with one type parameter\n+    /// representing the Future::Output type.\n+    OpaqueType(OpaqueTyId, Substs),\n+\n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type, which is output (for a function\n+    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n+    ///\n+    /// This includes tuple struct / enum variant constructors as well.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n+    FnDef(CallableDefId, Substs),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    Str,\n+\n+    /// The never type `!`.\n+    Never,\n+\n+    /// The type of a specific closure.\n+    ///\n+    /// The closure signature is stored in a `FnPtr` type in the first type\n+    /// parameter.\n+    Closure { def: DefWithBodyId, expr: ExprId, substs: Substs },\n+\n+    /// Represents a foreign type declared in external blocks.\n+    ForeignType(TypeAliasId, Substs),\n+\n+    /// A pointer to a function.  Written as `fn() -> i32`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar: fn() -> i32 = foo;\n+    /// ```\n+    // FIXME make this a Ty variant like in Chalk\n+    FnPtr { num_args: u16, is_varargs: bool, substs: Substs },\n \n     /// A \"projection\" type corresponds to an (unnormalized)\n     /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n@@ -420,10 +304,6 @@ impl Substs {\n         Substs::builder(generic_params.len())\n     }\n \n-    pub fn build_for_type_ctor(db: &dyn HirDatabase, type_ctor: TypeCtor) -> SubstsBuilder {\n-        Substs::builder(type_ctor.num_ty_params(db))\n-    }\n-\n     fn builder(param_count: usize) -> SubstsBuilder {\n         SubstsBuilder { vec: Vec::with_capacity(param_count), param_count }\n     }\n@@ -701,54 +581,42 @@ impl TypeWalk for FnSig {\n }\n \n impl Ty {\n-    pub fn simple(ctor: TypeCtor) -> Ty {\n-        Ty::Apply(ApplicationTy { ctor, parameters: Substs::empty() })\n-    }\n-    pub fn apply_one(ctor: TypeCtor, param: Ty) -> Ty {\n-        Ty::Apply(ApplicationTy { ctor, parameters: Substs::single(param) })\n-    }\n-    pub fn apply(ctor: TypeCtor, parameters: Substs) -> Ty {\n-        Ty::Apply(ApplicationTy { ctor, parameters })\n-    }\n     pub fn unit() -> Self {\n-        Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n+        Ty::Tuple { cardinality: 0, substs: Substs::empty() }\n     }\n+\n     pub fn fn_ptr(sig: FnSig) -> Self {\n-        Ty::apply(\n-            TypeCtor::FnPtr { num_args: sig.params().len() as u16, is_varargs: sig.is_varargs },\n-            Substs(sig.params_and_return),\n-        )\n+        Ty::FnPtr {\n+            num_args: sig.params().len() as u16,\n+            is_varargs: sig.is_varargs,\n+            substs: Substs(sig.params_and_return),\n+        }\n     }\n+\n     pub fn builtin(builtin: BuiltinType) -> Self {\n-        Ty::simple(match builtin {\n-            BuiltinType::Char => TypeCtor::Scalar(Scalar::Char),\n-            BuiltinType::Bool => TypeCtor::Scalar(Scalar::Bool),\n-            BuiltinType::Str => TypeCtor::Str,\n-            BuiltinType::Int(t) => TypeCtor::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))),\n-            BuiltinType::Uint(t) => {\n-                TypeCtor::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t)))\n-            }\n-            BuiltinType::Float(t) => {\n-                TypeCtor::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t)))\n-            }\n-        })\n+        match builtin {\n+            BuiltinType::Char => Ty::Scalar(Scalar::Char),\n+            BuiltinType::Bool => Ty::Scalar(Scalar::Bool),\n+            BuiltinType::Str => Ty::Str,\n+            BuiltinType::Int(t) => Ty::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))),\n+            BuiltinType::Uint(t) => Ty::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t))),\n+            BuiltinType::Float(t) => Ty::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t))),\n+        }\n     }\n \n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(mutability), parameters }) => {\n-                Some((parameters.as_single(), *mutability))\n-            }\n+            Ty::Ref(mutability, parameters) => Some((parameters.as_single(), *mutability)),\n             _ => None,\n         }\n     }\n \n     pub fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)> {\n         match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(mutability), parameters }) => {\n+            Ty::Ref(mutability, parameters) => {\n                 Some((parameters.as_single(), Rawness::Ref, *mutability))\n             }\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(mutability), parameters }) => {\n+            Ty::RawPtr(mutability, parameters) => {\n                 Some((parameters.as_single(), Rawness::RawPtr, *mutability))\n             }\n             _ => None,\n@@ -758,7 +626,7 @@ impl Ty {\n     pub fn strip_references(&self) -> &Ty {\n         let mut t: &Ty = self;\n \n-        while let Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(_mutability), parameters }) = t {\n+        while let Ty::Ref(_mutability, parameters) = t {\n             t = parameters.as_single();\n         }\n \n@@ -767,30 +635,64 @@ impl Ty {\n \n     pub fn as_adt(&self) -> Option<(AdtId, &Substs)> {\n         match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_def), parameters }) => {\n-                Some((*adt_def, parameters))\n-            }\n+            Ty::Adt(adt_def, parameters) => Some((*adt_def, parameters)),\n             _ => None,\n         }\n     }\n \n     pub fn as_tuple(&self) -> Option<&Substs> {\n         match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Tuple { .. }, parameters }) => {\n-                Some(parameters)\n-            }\n+            Ty::Tuple { substs: parameters, .. } => Some(parameters),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_generic_def(&self) -> Option<GenericDefId> {\n+        match *self {\n+            Ty::Adt(adt, ..) => Some(adt.into()),\n+            Ty::FnDef(callable, ..) => Some(callable.into()),\n+            Ty::AssociatedType(type_alias, ..) => Some(type_alias.into()),\n+            Ty::ForeignType(type_alias, ..) => Some(type_alias.into()),\n             _ => None,\n         }\n     }\n \n     pub fn is_never(&self) -> bool {\n-        matches!(self, Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }))\n+        matches!(self, Ty::Never)\n     }\n \n     pub fn is_unknown(&self) -> bool {\n         matches!(self, Ty::Unknown)\n     }\n \n+    pub fn equals_ctor(&self, other: &Ty) -> bool {\n+        match (self, other) {\n+            (Ty::Adt(adt, ..), Ty::Adt(adt2, ..)) => adt == adt2,\n+            (Ty::Slice(_), Ty::Slice(_)) | (Ty::Array(_), Ty::Array(_)) => true,\n+            (Ty::FnDef(def_id, ..), Ty::FnDef(def_id2, ..)) => def_id == def_id2,\n+            (Ty::OpaqueType(ty_id, ..), Ty::OpaqueType(ty_id2, ..)) => ty_id == ty_id2,\n+            (Ty::AssociatedType(ty_id, ..), Ty::AssociatedType(ty_id2, ..))\n+            | (Ty::ForeignType(ty_id, ..), Ty::ForeignType(ty_id2, ..)) => ty_id == ty_id2,\n+            (Ty::Closure { def, expr, .. }, Ty::Closure { def: def2, expr: expr2, .. }) => {\n+                expr == expr2 && def == def2\n+            }\n+            (Ty::Ref(mutability, ..), Ty::Ref(mutability2, ..))\n+            | (Ty::RawPtr(mutability, ..), Ty::RawPtr(mutability2, ..)) => {\n+                mutability == mutability2\n+            }\n+            (\n+                Ty::FnPtr { num_args, is_varargs, .. },\n+                Ty::FnPtr { num_args: num_args2, is_varargs: is_varargs2, .. },\n+            ) => num_args == num_args2 && is_varargs == is_varargs2,\n+            (Ty::Tuple { cardinality, .. }, Ty::Tuple { cardinality: cardinality2, .. }) => {\n+                cardinality == cardinality2\n+            }\n+            (Ty::Str, Ty::Str) | (Ty::Never, Ty::Never) => true,\n+            (Ty::Scalar(scalar), Ty::Scalar(scalar2)) => scalar == scalar2,\n+            _ => false,\n+        }\n+    }\n+\n     /// If this is a `dyn Trait` type, this returns the `Trait` part.\n     pub fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n         match self {\n@@ -809,41 +711,32 @@ impl Ty {\n \n     fn builtin_deref(&self) -> Option<Ty> {\n         match self {\n-            Ty::Apply(a_ty) => match a_ty.ctor {\n-                TypeCtor::Ref(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n-                TypeCtor::RawPtr(..) => Some(Ty::clone(a_ty.parameters.as_single())),\n-                _ => None,\n-            },\n+            Ty::Ref(.., parameters) => Some(Ty::clone(parameters.as_single())),\n+            Ty::RawPtr(.., parameters) => Some(Ty::clone(parameters.as_single())),\n             _ => None,\n         }\n     }\n \n     pub fn as_fn_def(&self) -> Option<FunctionId> {\n         match self {\n-            &Ty::Apply(ApplicationTy {\n-                ctor: TypeCtor::FnDef(CallableDefId::FunctionId(func)),\n-                ..\n-            }) => Some(func),\n+            &Ty::FnDef(CallableDefId::FunctionId(func), ..) => Some(func),\n             _ => None,\n         }\n     }\n \n     pub fn callable_sig(&self, db: &dyn HirDatabase) -> Option<FnSig> {\n         match self {\n-            Ty::Apply(a_ty) => match a_ty.ctor {\n-                TypeCtor::FnPtr { is_varargs, .. } => {\n-                    Some(FnSig::from_fn_ptr_substs(&a_ty.parameters, is_varargs))\n-                }\n-                TypeCtor::FnDef(def) => {\n-                    let sig = db.callable_item_signature(def);\n-                    Some(sig.subst(&a_ty.parameters))\n-                }\n-                TypeCtor::Closure { .. } => {\n-                    let sig_param = &a_ty.parameters[0];\n-                    sig_param.callable_sig(db)\n-                }\n-                _ => None,\n-            },\n+            Ty::FnPtr { is_varargs, substs: parameters, .. } => {\n+                Some(FnSig::from_fn_ptr_substs(&parameters, *is_varargs))\n+            }\n+            Ty::FnDef(def, parameters) => {\n+                let sig = db.callable_item_signature(*def);\n+                Some(sig.subst(&parameters))\n+            }\n+            Ty::Closure { substs: parameters, .. } => {\n+                let sig_param = &parameters[0];\n+                sig_param.callable_sig(db)\n+            }\n             _ => None,\n         }\n     }\n@@ -852,28 +745,69 @@ impl Ty {\n     /// the `Substs` for these type parameters with the given ones. (So e.g. if\n     /// `self` is `Option<_>` and the substs contain `u32`, we'll have\n     /// `Option<u32>` afterwards.)\n-    pub fn apply_substs(self, substs: Substs) -> Ty {\n-        match self {\n-            Ty::Apply(ApplicationTy { ctor, parameters: previous_substs }) => {\n-                assert_eq!(previous_substs.len(), substs.len());\n-                Ty::Apply(ApplicationTy { ctor, parameters: substs })\n+    pub fn apply_substs(mut self, new_substs: Substs) -> Ty {\n+        match &mut self {\n+            Ty::Adt(_, substs)\n+            | Ty::Slice(substs)\n+            | Ty::Array(substs)\n+            | Ty::RawPtr(_, substs)\n+            | Ty::Ref(_, substs)\n+            | Ty::FnDef(_, substs)\n+            | Ty::FnPtr { substs, .. }\n+            | Ty::Tuple { substs, .. }\n+            | Ty::OpaqueType(_, substs)\n+            | Ty::AssociatedType(_, substs)\n+            | Ty::ForeignType(_, substs)\n+            | Ty::Closure { substs, .. } => {\n+                assert_eq!(substs.len(), new_substs.len());\n+                *substs = new_substs;\n             }\n-            _ => self,\n+            _ => (),\n         }\n+        self\n     }\n \n     /// Returns the type parameters of this type if it has some (i.e. is an ADT\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n-    pub fn substs(&self) -> Option<Substs> {\n+    pub fn substs(&self) -> Option<&Substs> {\n+        match self {\n+            Ty::Adt(_, substs)\n+            | Ty::Slice(substs)\n+            | Ty::Array(substs)\n+            | Ty::RawPtr(_, substs)\n+            | Ty::Ref(_, substs)\n+            | Ty::FnDef(_, substs)\n+            | Ty::FnPtr { substs, .. }\n+            | Ty::Tuple { substs, .. }\n+            | Ty::OpaqueType(_, substs)\n+            | Ty::AssociatedType(_, substs)\n+            | Ty::ForeignType(_, substs)\n+            | Ty::Closure { substs, .. } => Some(substs),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn substs_mut(&mut self) -> Option<&mut Substs> {\n         match self {\n-            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n+            Ty::Adt(_, substs)\n+            | Ty::Slice(substs)\n+            | Ty::Array(substs)\n+            | Ty::RawPtr(_, substs)\n+            | Ty::Ref(_, substs)\n+            | Ty::FnDef(_, substs)\n+            | Ty::FnPtr { substs, .. }\n+            | Ty::Tuple { substs, .. }\n+            | Ty::OpaqueType(_, substs)\n+            | Ty::AssociatedType(_, substs)\n+            | Ty::ForeignType(_, substs)\n+            | Ty::Closure { substs, .. } => Some(substs),\n             _ => None,\n         }\n     }\n \n     pub fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<GenericPredicate>> {\n         match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::OpaqueType(opaque_ty_id), .. }) => {\n+            Ty::OpaqueType(opaque_ty_id, ..) => {\n                 match opaque_ty_id {\n                     OpaqueTyId::AsyncBlockTypeImplTrait(def, _expr) => {\n                         let krate = def.module(db.upcast()).krate();\n@@ -934,7 +868,7 @@ impl Ty {\n \n     pub fn associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<TraitId> {\n         match self {\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::AssociatedType(type_alias_id), .. }) => {\n+            Ty::AssociatedType(type_alias_id, ..) => {\n                 match type_alias_id.lookup(db.upcast()).container {\n                     AssocContainerId::TraitId(trait_id) => Some(trait_id),\n                     _ => None,\n@@ -1049,11 +983,6 @@ pub trait TypeWalk {\n impl TypeWalk for Ty {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self {\n-            Ty::Apply(a_ty) => {\n-                for t in a_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n             Ty::Projection(p_ty) => {\n                 for t in p_ty.parameters.iter() {\n                     t.walk(f);\n@@ -1069,7 +998,13 @@ impl TypeWalk for Ty {\n                     t.walk(f);\n                 }\n             }\n-            Ty::Placeholder { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n+            _ => {\n+                if let Some(substs) = self.substs() {\n+                    for t in substs.iter() {\n+                        t.walk(f);\n+                    }\n+                }\n+            }\n         }\n         f(self);\n     }\n@@ -1080,9 +1015,6 @@ impl TypeWalk for Ty {\n         binders: DebruijnIndex,\n     ) {\n         match self {\n-            Ty::Apply(a_ty) => {\n-                a_ty.parameters.walk_mut_binders(f, binders);\n-            }\n             Ty::Projection(p_ty) => {\n                 p_ty.parameters.walk_mut_binders(f, binders);\n             }\n@@ -1094,7 +1026,11 @@ impl TypeWalk for Ty {\n             Ty::Opaque(o_ty) => {\n                 o_ty.parameters.walk_mut_binders(f, binders);\n             }\n-            Ty::Placeholder { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n+            _ => {\n+                if let Some(substs) = self.substs_mut() {\n+                    substs.walk_mut_binders(f, binders);\n+                }\n+            }\n         }\n         f(self, binders);\n     }"}, {"sha": "6b919a09ede1ebcd0641cd1298b16246bc10bbb5", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -33,7 +33,7 @@ use crate::{\n     },\n     Binders, BoundVar, DebruijnIndex, FnSig, GenericPredicate, OpaqueTy, OpaqueTyId, PolyFnSig,\n     ProjectionPredicate, ProjectionTy, ReturnTypeImplTrait, ReturnTypeImplTraits, Substs,\n-    TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n+    TraitEnvironment, TraitRef, Ty, TypeWalk,\n };\n \n #[derive(Debug)]\n@@ -145,13 +145,10 @@ impl Ty {\n     pub fn from_hir_ext(ctx: &TyLoweringContext<'_>, type_ref: &TypeRef) -> (Self, Option<TypeNs>) {\n         let mut res = None;\n         let ty = match type_ref {\n-            TypeRef::Never => Ty::simple(TypeCtor::Never),\n+            TypeRef::Never => Ty::Never,\n             TypeRef::Tuple(inner) => {\n                 let inner_tys: Arc<[Ty]> = inner.iter().map(|tr| Ty::from_hir(ctx, tr)).collect();\n-                Ty::apply(\n-                    TypeCtor::Tuple { cardinality: inner_tys.len() as u16 },\n-                    Substs(inner_tys),\n-                )\n+                Ty::Tuple { cardinality: inner_tys.len() as u16, substs: Substs(inner_tys) }\n             }\n             TypeRef::Path(path) => {\n                 let (ty, res_) = Ty::from_hir_path(ctx, path);\n@@ -160,27 +157,24 @@ impl Ty {\n             }\n             TypeRef::RawPtr(inner, mutability) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n-                Ty::apply_one(TypeCtor::RawPtr(*mutability), inner_ty)\n+                Ty::RawPtr(*mutability, Substs::single(inner_ty))\n             }\n             TypeRef::Array(inner) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n-                Ty::apply_one(TypeCtor::Array, inner_ty)\n+                Ty::Array(Substs::single(inner_ty))\n             }\n             TypeRef::Slice(inner) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n-                Ty::apply_one(TypeCtor::Slice, inner_ty)\n+                Ty::Slice(Substs::single(inner_ty))\n             }\n             TypeRef::Reference(inner, _, mutability) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n-                Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n+                Ty::Ref(*mutability, Substs::single(inner_ty))\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params, is_varargs) => {\n                 let sig = Substs(params.iter().map(|tr| Ty::from_hir(ctx, tr)).collect());\n-                Ty::apply(\n-                    TypeCtor::FnPtr { num_args: sig.len() as u16 - 1, is_varargs: *is_varargs },\n-                    sig,\n-                )\n+                Ty::FnPtr { num_args: sig.len() as u16 - 1, is_varargs: *is_varargs, substs: sig }\n             }\n             TypeRef::DynTrait(bounds) => {\n                 let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n@@ -414,7 +408,6 @@ impl Ty {\n             // FIXME: report error\n             TypeNs::EnumVariantId(_) => return (Ty::Unknown, None),\n         };\n-\n         Ty::from_type_relative_path(ctx, ty, Some(resolution), remaining_segments)\n     }\n \n@@ -1025,7 +1018,7 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), def.into());\n     let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n-    Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n+    Binders::new(substs.len(), Ty::FnDef(def.into(), substs))\n }\n \n /// Build the declared type of a const.\n@@ -1068,7 +1061,7 @@ fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<T\n     }\n     let generics = generics(db.upcast(), def.into());\n     let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n-    Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n+    Binders::new(substs.len(), Ty::FnDef(def.into(), substs))\n }\n \n fn fn_sig_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -> PolyFnSig {\n@@ -1093,13 +1086,13 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n     }\n     let generics = generics(db.upcast(), def.parent.into());\n     let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n-    Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n+    Binders::new(substs.len(), Ty::FnDef(def.into(), substs))\n }\n \n fn type_for_adt(db: &dyn HirDatabase, adt: AdtId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), adt.into());\n     let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n-    Binders::new(substs.len(), Ty::apply(TypeCtor::Adt(adt), substs))\n+    Binders::new(substs.len(), Ty::Adt(adt, substs))\n }\n \n fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n@@ -1109,7 +1102,7 @@ fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     if db.type_alias_data(t).is_extern {\n-        Binders::new(substs.len(), Ty::apply(TypeCtor::ForeignType(t), substs))\n+        Binders::new(substs.len(), Ty::ForeignType(t, substs))\n     } else {\n         let type_ref = &db.type_alias_data(t).type_ref;\n         let inner = Ty::from_hir(&ctx, type_ref.as_ref().unwrap_or(&TypeRef::Error));"}, {"sha": "087b67935f430211b67891373f38edca7592f390", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 71, "deletions": 55, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -7,8 +7,8 @@ use std::{iter, sync::Arc};\n use arrayvec::ArrayVec;\n use base_db::CrateId;\n use hir_def::{\n-    lang_item::LangItemTarget, type_ref::Mutability, AssocContainerId, AssocItemId, FunctionId,\n-    GenericDefId, HasModule, ImplId, Lookup, ModuleId, TraitId,\n+    lang_item::LangItemTarget, type_ref::Mutability, AdtId, AssocContainerId, AssocItemId,\n+    FunctionId, GenericDefId, HasModule, ImplId, Lookup, ModuleId, TraitId, TypeAliasId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -18,48 +18,69 @@ use crate::{\n     db::HirDatabase,\n     primitive::{self, FloatTy, IntTy, UintTy},\n     utils::all_super_traits,\n-    ApplicationTy, Canonical, DebruijnIndex, InEnvironment, Scalar, Substs, TraitEnvironment,\n-    TraitRef, Ty, TyKind, TypeCtor, TypeWalk,\n+    Canonical, DebruijnIndex, InEnvironment, Scalar, Substs, TraitEnvironment, TraitRef, Ty,\n+    TyKind, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum TyFingerprint {\n-    Apply(TypeCtor),\n+    Str,\n+    Slice,\n+    Array,\n+    Never,\n+    RawPtr(Mutability),\n+    Scalar(Scalar),\n+    Adt(AdtId),\n     Dyn(TraitId),\n+    Tuple { cardinality: u16 },\n+    ForeignType(TypeAliasId),\n+    FnPtr { num_args: u16, is_varargs: bool },\n }\n \n impl TyFingerprint {\n     /// Creates a TyFingerprint for looking up an impl. Only certain types can\n     /// have impls: if we have some `struct S`, we can have an `impl S`, but not\n     /// `impl &S`. Hence, this will return `None` for reference types and such.\n     pub(crate) fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n-        match ty {\n-            Ty::Apply(a_ty) => Some(TyFingerprint::Apply(a_ty.ctor)),\n-            Ty::Dyn(_) => ty.dyn_trait().map(|trait_| TyFingerprint::Dyn(trait_)),\n-            _ => None,\n-        }\n+        let fp = match ty {\n+            &Ty::Str => TyFingerprint::Str,\n+            &Ty::Never => TyFingerprint::Never,\n+            &Ty::Slice(..) => TyFingerprint::Slice,\n+            &Ty::Array(..) => TyFingerprint::Array,\n+            &Ty::Scalar(scalar) => TyFingerprint::Scalar(scalar),\n+            &Ty::Adt(adt, _) => TyFingerprint::Adt(adt),\n+            &Ty::Tuple { cardinality: u16, .. } => TyFingerprint::Tuple { cardinality: u16 },\n+            &Ty::RawPtr(mutability, ..) => TyFingerprint::RawPtr(mutability),\n+            &Ty::ForeignType(alias_id, ..) => TyFingerprint::ForeignType(alias_id),\n+            &Ty::FnPtr { num_args, is_varargs, .. } => {\n+                TyFingerprint::FnPtr { num_args, is_varargs }\n+            }\n+            Ty::Dyn(_) => ty.dyn_trait().map(|trait_| TyFingerprint::Dyn(trait_))?,\n+            _ => return None,\n+        };\n+        Some(fp)\n     }\n }\n \n pub(crate) const ALL_INT_FPS: [TyFingerprint; 12] = [\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I8))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I16))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I32))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I64))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I128))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::Isize))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U8))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U16))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U32))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U64))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U128))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::Usize))),\n+    TyFingerprint::Scalar(Scalar::Int(IntTy::I8)),\n+    TyFingerprint::Scalar(Scalar::Int(IntTy::I16)),\n+    TyFingerprint::Scalar(Scalar::Int(IntTy::I32)),\n+    TyFingerprint::Scalar(Scalar::Int(IntTy::I64)),\n+    TyFingerprint::Scalar(Scalar::Int(IntTy::I128)),\n+    TyFingerprint::Scalar(Scalar::Int(IntTy::Isize)),\n+    TyFingerprint::Scalar(Scalar::Uint(UintTy::U8)),\n+    TyFingerprint::Scalar(Scalar::Uint(UintTy::U16)),\n+    TyFingerprint::Scalar(Scalar::Uint(UintTy::U32)),\n+    TyFingerprint::Scalar(Scalar::Uint(UintTy::U64)),\n+    TyFingerprint::Scalar(Scalar::Uint(UintTy::U128)),\n+    TyFingerprint::Scalar(Scalar::Uint(UintTy::Usize)),\n ];\n \n pub(crate) const ALL_FLOAT_FPS: [TyFingerprint; 2] = [\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Float(FloatTy::F32))),\n-    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Float(FloatTy::F64))),\n+    TyFingerprint::Scalar(Scalar::Float(FloatTy::F32)),\n+    TyFingerprint::Scalar(Scalar::Float(FloatTy::F64)),\n ];\n \n /// Trait impls defined or available in some crate.\n@@ -211,32 +232,29 @@ impl Ty {\n         let mod_to_crate_ids = |module: ModuleId| Some(std::iter::once(module.krate()).collect());\n \n         let lang_item_targets = match self {\n-            Ty::Apply(a_ty) => match a_ty.ctor {\n-                TypeCtor::Adt(def_id) => {\n-                    return mod_to_crate_ids(def_id.module(db.upcast()));\n-                }\n-                TypeCtor::ForeignType(type_alias_id) => {\n-                    return mod_to_crate_ids(type_alias_id.lookup(db.upcast()).module(db.upcast()));\n-                }\n-                TypeCtor::Scalar(Scalar::Bool) => lang_item_crate!(\"bool\"),\n-                TypeCtor::Scalar(Scalar::Char) => lang_item_crate!(\"char\"),\n-                TypeCtor::Scalar(Scalar::Float(f)) => match f {\n-                    // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n-                    FloatTy::F32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n-                    FloatTy::F64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n-                },\n-                TypeCtor::Scalar(Scalar::Int(t)) => {\n-                    lang_item_crate!(primitive::int_ty_to_string(t))\n-                }\n-                TypeCtor::Scalar(Scalar::Uint(t)) => {\n-                    lang_item_crate!(primitive::uint_ty_to_string(t))\n-                }\n-                TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n-                TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n-                TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),\n-                TypeCtor::RawPtr(Mutability::Mut) => lang_item_crate!(\"mut_ptr\"),\n-                _ => return None,\n+            Ty::Adt(def_id, _) => {\n+                return mod_to_crate_ids(def_id.module(db.upcast()));\n+            }\n+            Ty::ForeignType(type_alias_id, _) => {\n+                return mod_to_crate_ids(type_alias_id.lookup(db.upcast()).module(db.upcast()));\n+            }\n+            Ty::Scalar(Scalar::Bool) => lang_item_crate!(\"bool\"),\n+            Ty::Scalar(Scalar::Char) => lang_item_crate!(\"char\"),\n+            Ty::Scalar(Scalar::Float(f)) => match f {\n+                // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n+                FloatTy::F32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n+                FloatTy::F64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n             },\n+            &Ty::Scalar(Scalar::Int(t)) => {\n+                lang_item_crate!(primitive::int_ty_to_string(t))\n+            }\n+            &Ty::Scalar(Scalar::Uint(t)) => {\n+                lang_item_crate!(primitive::uint_ty_to_string(t))\n+            }\n+            Ty::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n+            Ty::Slice(_) => lang_item_crate!(\"slice_alloc\", \"slice\"),\n+            Ty::RawPtr(Mutability::Shared, _) => lang_item_crate!(\"const_ptr\"),\n+            Ty::RawPtr(Mutability::Mut, _) => lang_item_crate!(\"mut_ptr\"),\n             Ty::Dyn(_) => {\n                 return self.dyn_trait().and_then(|trait_| {\n                     mod_to_crate_ids(GenericDefId::TraitId(trait_).module(db.upcast()))\n@@ -413,7 +431,7 @@ fn iterate_method_candidates_with_autoref(\n     }\n     let refed = Canonical {\n         kinds: deref_chain[0].kinds.clone(),\n-        value: Ty::apply_one(TypeCtor::Ref(Mutability::Shared), deref_chain[0].value.clone()),\n+        value: Ty::Ref(Mutability::Shared, Substs::single(deref_chain[0].value.clone())),\n     };\n     if iterate_method_candidates_by_receiver(\n         &refed,\n@@ -429,7 +447,7 @@ fn iterate_method_candidates_with_autoref(\n     }\n     let ref_muted = Canonical {\n         kinds: deref_chain[0].kinds.clone(),\n-        value: Ty::apply_one(TypeCtor::Ref(Mutability::Mut), deref_chain[0].value.clone()),\n+        value: Ty::Ref(Mutability::Mut, Substs::single(deref_chain[0].value.clone())),\n     };\n     if iterate_method_candidates_by_receiver(\n         &ref_muted,\n@@ -756,11 +774,9 @@ fn autoderef_method_receiver(\n ) -> Vec<Canonical<Ty>> {\n     let mut deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty).collect();\n     // As a last step, we can do array unsizing (that's the only unsizing that rustc does for method receivers!)\n-    if let Some(Ty::Apply(ApplicationTy { ctor: TypeCtor::Array, parameters })) =\n-        deref_chain.last().map(|ty| &ty.value)\n-    {\n+    if let Some(Ty::Array(parameters)) = deref_chain.last().map(|ty| &ty.value) {\n         let kinds = deref_chain.last().unwrap().kinds.clone();\n-        let unsized_ty = Ty::apply(TypeCtor::Slice, parameters.clone());\n+        let unsized_ty = Ty::Slice(parameters.clone());\n         deref_chain.push(Canonical { value: unsized_ty, kinds })\n     }\n     deref_chain"}, {"sha": "1c01a67ade1f24a6c034e60e84832784535e5fd5", "filename": "crates/hir_ty/src/op.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fop.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -1,30 +1,23 @@\n //! Helper functions for binary operator type inference.\n use hir_def::expr::{ArithOp, BinaryOp, CmpOp};\n \n-use super::{InferTy, Ty, TypeCtor};\n-use crate::{ApplicationTy, Scalar};\n+use crate::{InferTy, Scalar, Ty};\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => Ty::simple(TypeCtor::Scalar(Scalar::Bool)),\n+        BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => Ty::Scalar(Scalar::Bool),\n         BinaryOp::Assignment { .. } => Ty::unit(),\n         BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => match lhs_ty {\n-            Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Scalar(Scalar::Int(_))\n-                | TypeCtor::Scalar(Scalar::Uint(_))\n-                | TypeCtor::Scalar(Scalar::Float(_)) => lhs_ty,\n-                _ => Ty::Unknown,\n-            },\n+            Ty::Scalar(Scalar::Int(_))\n+            | Ty::Scalar(Scalar::Uint(_))\n+            | Ty::Scalar(Scalar::Float(_)) => lhs_ty,\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::ArithOp(_) => match rhs_ty {\n-            Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Scalar(Scalar::Int(_))\n-                | TypeCtor::Scalar(Scalar::Uint(_))\n-                | TypeCtor::Scalar(Scalar::Float(_)) => rhs_ty,\n-                _ => Ty::Unknown,\n-            },\n+            Ty::Scalar(Scalar::Int(_))\n+            | Ty::Scalar(Scalar::Uint(_))\n+            | Ty::Scalar(Scalar::Float(_)) => rhs_ty,\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => rhs_ty,\n             _ => Ty::Unknown,\n         },\n@@ -33,26 +26,20 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n \n pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::LogicOp(..) => Ty::simple(TypeCtor::Scalar(Scalar::Bool)),\n+        BinaryOp::LogicOp(..) => Ty::Scalar(Scalar::Bool),\n         BinaryOp::Assignment { op: None } => lhs_ty,\n         BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty {\n-            Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Scalar(_) | TypeCtor::Str => lhs_ty,\n-                _ => Ty::Unknown,\n-            },\n+            Ty::Scalar(_) | Ty::Str => lhs_ty,\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => Ty::Unknown,\n         BinaryOp::CmpOp(CmpOp::Ord { .. })\n         | BinaryOp::Assignment { op: Some(_) }\n         | BinaryOp::ArithOp(_) => match lhs_ty {\n-            Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Scalar(Scalar::Int(_))\n-                | TypeCtor::Scalar(Scalar::Uint(_))\n-                | TypeCtor::Scalar(Scalar::Float(_)) => lhs_ty,\n-                _ => Ty::Unknown,\n-            },\n+            Ty::Scalar(Scalar::Int(_))\n+            | Ty::Scalar(Scalar::Uint(_))\n+            | Ty::Scalar(Scalar::Float(_)) => lhs_ty,\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n             _ => Ty::Unknown,\n         },"}, {"sha": "c53e327daf7d3b905bd73a2b76ceec21c6532953", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     utils::generics,\n     BoundVar, CallableDefId, DebruijnIndex, FnSig, GenericPredicate, ProjectionPredicate,\n-    ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    ProjectionTy, Substs, TraitRef, Ty,\n };\n use mapping::{\n     convert_where_clauses, generic_predicate_to_inline_bound, make_binders, TypeAliasAsAssocType,\n@@ -489,10 +489,11 @@ pub(crate) fn struct_datum_query(\n     struct_id: AdtId,\n ) -> Arc<StructDatum> {\n     debug!(\"struct_datum {:?}\", struct_id);\n-    let type_ctor = TypeCtor::Adt(from_chalk(db, struct_id));\n+    let adt_id = from_chalk(db, struct_id);\n+    let type_ctor = Ty::Adt(adt_id, Substs::empty());\n     debug!(\"struct {:?} = {:?}\", struct_id, type_ctor);\n-    let num_params = type_ctor.num_ty_params(db);\n-    let upstream = type_ctor.krate(db) != Some(krate);\n+    let num_params = generics(db.upcast(), adt_id.into()).len();\n+    let upstream = adt_id.module(db.upcast()).krate() != krate;\n     let where_clauses = type_ctor\n         .as_generic_def()\n         .map(|generic_def| {"}, {"sha": "297ddeabdb42a829a3c286a9348d0fa92e9c71be", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 85, "deletions": 104, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=2fc137b70f9d455676cc99a1a5c7e6e10c3e7cc2", "patch": "@@ -16,9 +16,8 @@ use crate::{\n     db::HirDatabase,\n     primitive::UintTy,\n     traits::{Canonical, Obligation},\n-    ApplicationTy, CallableDefId, GenericPredicate, InEnvironment, OpaqueTy, OpaqueTyId,\n-    ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment, TraitRef, Ty, TyKind,\n-    TypeCtor,\n+    CallableDefId, GenericPredicate, InEnvironment, OpaqueTy, OpaqueTyId, ProjectionPredicate,\n+    ProjectionTy, Scalar, Substs, TraitEnvironment, TraitRef, Ty, TyKind,\n };\n \n use super::interner::*;\n@@ -28,75 +27,71 @@ impl ToChalk for Ty {\n     type Chalk = chalk_ir::Ty<Interner>;\n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n         match self {\n-            Ty::Apply(apply_ty) => match apply_ty.ctor {\n-                TypeCtor::Ref(m) => ref_to_chalk(db, m, apply_ty.parameters),\n-                TypeCtor::Array => array_to_chalk(db, apply_ty.parameters),\n-                TypeCtor::FnPtr { num_args: _, is_varargs } => {\n-                    let substitution =\n-                        chalk_ir::FnSubst(apply_ty.parameters.to_chalk(db).shifted_in(&Interner));\n-                    chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n-                        num_binders: 0,\n-                        sig: chalk_ir::FnSig {\n-                            abi: (),\n-                            safety: chalk_ir::Safety::Safe,\n-                            variadic: is_varargs,\n-                        },\n-                        substitution,\n-                    })\n-                    .intern(&Interner)\n-                }\n-                TypeCtor::AssociatedType(type_alias) => {\n-                    let assoc_type = TypeAliasAsAssocType(type_alias);\n-                    let assoc_type_id = assoc_type.to_chalk(db);\n-                    let substitution = apply_ty.parameters.to_chalk(db);\n-                    chalk_ir::TyKind::AssociatedType(assoc_type_id, substitution).intern(&Interner)\n-                }\n+            Ty::Ref(m, parameters) => ref_to_chalk(db, m, parameters),\n+            Ty::Array(parameters) => array_to_chalk(db, parameters),\n+            Ty::FnPtr { num_args: _, is_varargs, substs } => {\n+                let substitution = chalk_ir::FnSubst(substs.to_chalk(db).shifted_in(&Interner));\n+                chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n+                    num_binders: 0,\n+                    sig: chalk_ir::FnSig {\n+                        abi: (),\n+                        safety: chalk_ir::Safety::Safe,\n+                        variadic: is_varargs,\n+                    },\n+                    substitution,\n+                })\n+                .intern(&Interner)\n+            }\n+            Ty::AssociatedType(type_alias, substs) => {\n+                let assoc_type = TypeAliasAsAssocType(type_alias);\n+                let assoc_type_id = assoc_type.to_chalk(db);\n+                let substitution = substs.to_chalk(db);\n+                chalk_ir::TyKind::AssociatedType(assoc_type_id, substitution).intern(&Interner)\n+            }\n \n-                TypeCtor::OpaqueType(impl_trait_id) => {\n-                    let id = impl_trait_id.to_chalk(db);\n-                    let substitution = apply_ty.parameters.to_chalk(db);\n-                    chalk_ir::TyKind::OpaqueType(id, substitution).intern(&Interner)\n-                }\n+            Ty::OpaqueType(impl_trait_id, substs) => {\n+                let id = impl_trait_id.to_chalk(db);\n+                let substitution = substs.to_chalk(db);\n+                chalk_ir::TyKind::OpaqueType(id, substitution).intern(&Interner)\n+            }\n \n-                TypeCtor::ForeignType(type_alias) => {\n-                    let foreign_type = TypeAliasAsForeignType(type_alias);\n-                    let foreign_type_id = foreign_type.to_chalk(db);\n-                    chalk_ir::TyKind::Foreign(foreign_type_id).intern(&Interner)\n-                }\n+            Ty::ForeignType(type_alias, _) => {\n+                let foreign_type = TypeAliasAsForeignType(type_alias);\n+                let foreign_type_id = foreign_type.to_chalk(db);\n+                chalk_ir::TyKind::Foreign(foreign_type_id).intern(&Interner)\n+            }\n \n-                TypeCtor::Scalar(scalar) => chalk_ir::TyKind::Scalar(scalar).intern(&Interner),\n+            Ty::Scalar(scalar) => chalk_ir::TyKind::Scalar(scalar).intern(&Interner),\n \n-                TypeCtor::Tuple { cardinality } => {\n-                    let substitution = apply_ty.parameters.to_chalk(db);\n-                    chalk_ir::TyKind::Tuple(cardinality.into(), substitution).intern(&Interner)\n-                }\n-                TypeCtor::RawPtr(mutability) => {\n-                    let ty = apply_ty.parameters[0].clone().to_chalk(db);\n-                    chalk_ir::TyKind::Raw(mutability.to_chalk(db), ty).intern(&Interner)\n-                }\n-                TypeCtor::Slice => {\n-                    chalk_ir::TyKind::Slice(apply_ty.parameters[0].clone().to_chalk(db))\n-                        .intern(&Interner)\n-                }\n-                TypeCtor::Str => chalk_ir::TyKind::Str.intern(&Interner),\n-                TypeCtor::FnDef(callable_def) => {\n-                    let id = callable_def.to_chalk(db);\n-                    let substitution = apply_ty.parameters.to_chalk(db);\n-                    chalk_ir::TyKind::FnDef(id, substitution).intern(&Interner)\n-                }\n-                TypeCtor::Never => chalk_ir::TyKind::Never.intern(&Interner),\n+            Ty::Tuple { cardinality, substs } => {\n+                let substitution = substs.to_chalk(db);\n+                chalk_ir::TyKind::Tuple(cardinality.into(), substitution).intern(&Interner)\n+            }\n+            Ty::RawPtr(mutability, substs) => {\n+                let ty = substs[0].clone().to_chalk(db);\n+                chalk_ir::TyKind::Raw(mutability.to_chalk(db), ty).intern(&Interner)\n+            }\n+            Ty::Slice(substs) => {\n+                chalk_ir::TyKind::Slice(substs[0].clone().to_chalk(db)).intern(&Interner)\n+            }\n+            Ty::Str => chalk_ir::TyKind::Str.intern(&Interner),\n+            Ty::FnDef(callable_def, substs) => {\n+                let id = callable_def.to_chalk(db);\n+                let substitution = substs.to_chalk(db);\n+                chalk_ir::TyKind::FnDef(id, substitution).intern(&Interner)\n+            }\n+            Ty::Never => chalk_ir::TyKind::Never.intern(&Interner),\n \n-                TypeCtor::Closure { def, expr } => {\n-                    let closure_id = db.intern_closure((def, expr));\n-                    let substitution = apply_ty.parameters.to_chalk(db);\n-                    chalk_ir::TyKind::Closure(closure_id.into(), substitution).intern(&Interner)\n-                }\n+            Ty::Closure { def, expr, substs } => {\n+                let closure_id = db.intern_closure((def, expr));\n+                let substitution = substs.to_chalk(db);\n+                chalk_ir::TyKind::Closure(closure_id.into(), substitution).intern(&Interner)\n+            }\n \n-                TypeCtor::Adt(adt_id) => {\n-                    let substitution = apply_ty.parameters.to_chalk(db);\n-                    chalk_ir::TyKind::Adt(chalk_ir::AdtId(adt_id), substitution).intern(&Interner)\n-                }\n-            },\n+            Ty::Adt(adt_id, substs) => {\n+                let substitution = substs.to_chalk(db);\n+                chalk_ir::TyKind::Adt(chalk_ir::AdtId(adt_id), substitution).intern(&Interner)\n+            }\n             Ty::Projection(proj_ty) => {\n                 let associated_ty_id = TypeAliasAsAssocType(proj_ty.associated_ty).to_chalk(db);\n                 let substitution = proj_ty.parameters.to_chalk(db);\n@@ -143,9 +138,7 @@ impl ToChalk for Ty {\n     fn from_chalk(db: &dyn HirDatabase, chalk: chalk_ir::Ty<Interner>) -> Self {\n         match chalk.data(&Interner).kind.clone() {\n             chalk_ir::TyKind::Error => Ty::Unknown,\n-            chalk_ir::TyKind::Array(ty, _size) => {\n-                Ty::apply(TypeCtor::Array, Substs::single(from_chalk(db, ty)))\n-            }\n+            chalk_ir::TyKind::Array(ty, _size) => Ty::Array(Substs::single(from_chalk(db, ty))),\n             chalk_ir::TyKind::Placeholder(idx) => {\n                 assert_eq!(idx.ui, UniverseIndex::ROOT);\n                 let interned_id = crate::db::GlobalTypeParamId::from_intern_id(\n@@ -175,13 +168,11 @@ impl ToChalk for Ty {\n                     db,\n                     substitution.0.shifted_out(&Interner).expect(\"fn ptr should have no binders\"),\n                 );\n-                Ty::Apply(ApplicationTy {\n-                    ctor: TypeCtor::FnPtr {\n-                        num_args: (parameters.len() - 1) as u16,\n-                        is_varargs: variadic,\n-                    },\n-                    parameters,\n-                })\n+                Ty::FnPtr {\n+                    num_args: (parameters.len() - 1) as u16,\n+                    is_varargs: variadic,\n+                    substs: parameters,\n+                }\n             }\n             chalk_ir::TyKind::BoundVar(idx) => Ty::Bound(idx),\n             chalk_ir::TyKind::InferenceVar(_iv, _kind) => Ty::Unknown,\n@@ -196,60 +187,50 @@ impl ToChalk for Ty {\n                 Ty::Dyn(predicates)\n             }\n \n-            chalk_ir::TyKind::Adt(struct_id, subst) => {\n-                apply_ty_from_chalk(db, TypeCtor::Adt(struct_id.0), subst)\n-            }\n-            chalk_ir::TyKind::AssociatedType(type_id, subst) => apply_ty_from_chalk(\n-                db,\n-                TypeCtor::AssociatedType(from_chalk::<TypeAliasAsAssocType, _>(db, type_id).0),\n-                subst,\n+            chalk_ir::TyKind::Adt(struct_id, subst) => Ty::Adt(struct_id.0, from_chalk(db, subst)),\n+            chalk_ir::TyKind::AssociatedType(type_id, subst) => Ty::AssociatedType(\n+                from_chalk::<TypeAliasAsAssocType, _>(db, type_id).0,\n+                from_chalk(db, subst),\n             ),\n+\n             chalk_ir::TyKind::OpaqueType(opaque_type_id, subst) => {\n-                apply_ty_from_chalk(db, TypeCtor::OpaqueType(from_chalk(db, opaque_type_id)), subst)\n+                Ty::OpaqueType(from_chalk(db, opaque_type_id), from_chalk(db, subst))\n             }\n \n-            chalk_ir::TyKind::Scalar(scalar) => Ty::simple(TypeCtor::Scalar(scalar)),\n+            chalk_ir::TyKind::Scalar(scalar) => Ty::Scalar(scalar),\n             chalk_ir::TyKind::Tuple(cardinality, subst) => {\n-                apply_ty_from_chalk(db, TypeCtor::Tuple { cardinality: cardinality as u16 }, subst)\n+                Ty::Tuple { cardinality: cardinality as u16, substs: from_chalk(db, subst) }\n             }\n             chalk_ir::TyKind::Raw(mutability, ty) => {\n-                Ty::apply_one(TypeCtor::RawPtr(from_chalk(db, mutability)), from_chalk(db, ty))\n+                Ty::RawPtr(from_chalk(db, mutability), Substs::single(from_chalk(db, ty)))\n             }\n-            chalk_ir::TyKind::Slice(ty) => Ty::apply_one(TypeCtor::Slice, from_chalk(db, ty)),\n+            chalk_ir::TyKind::Slice(ty) => Ty::Slice(Substs::single(from_chalk(db, ty))),\n             chalk_ir::TyKind::Ref(mutability, _lifetime, ty) => {\n-                Ty::apply_one(TypeCtor::Ref(from_chalk(db, mutability)), from_chalk(db, ty))\n+                Ty::Ref(from_chalk(db, mutability), Substs::single(from_chalk(db, ty)))\n             }\n-            chalk_ir::TyKind::Str => Ty::simple(TypeCtor::Str),\n-            chalk_ir::TyKind::Never => Ty::simple(TypeCtor::Never),\n+            chalk_ir::TyKind::Str => Ty::Str,\n+            chalk_ir::TyKind::Never => Ty::Never,\n \n             chalk_ir::TyKind::FnDef(fn_def_id, subst) => {\n-                let callable_def = from_chalk(db, fn_def_id);\n-                apply_ty_from_chalk(db, TypeCtor::FnDef(callable_def), subst)\n+                Ty::FnDef(from_chalk(db, fn_def_id), from_chalk(db, subst))\n             }\n \n             chalk_ir::TyKind::Closure(id, subst) => {\n                 let id: crate::db::ClosureId = id.into();\n                 let (def, expr) = db.lookup_intern_closure(id);\n-                apply_ty_from_chalk(db, TypeCtor::Closure { def, expr }, subst)\n+                Ty::Closure { def, expr, substs: from_chalk(db, subst) }\n             }\n \n-            chalk_ir::TyKind::Foreign(foreign_def_id) => Ty::simple(TypeCtor::ForeignType(\n+            chalk_ir::TyKind::Foreign(foreign_def_id) => Ty::ForeignType(\n                 from_chalk::<TypeAliasAsForeignType, _>(db, foreign_def_id).0,\n-            )),\n+                Substs::empty(),\n+            ),\n             chalk_ir::TyKind::Generator(_, _) => unimplemented!(), // FIXME\n             chalk_ir::TyKind::GeneratorWitness(_, _) => unimplemented!(), // FIXME\n         }\n     }\n }\n \n-fn apply_ty_from_chalk(\n-    db: &dyn HirDatabase,\n-    ctor: TypeCtor,\n-    subst: chalk_ir::Substitution<Interner>,\n-) -> Ty {\n-    Ty::Apply(ApplicationTy { ctor, parameters: from_chalk(db, subst) })\n-}\n-\n /// We currently don't model lifetimes, but Chalk does. So, we have to insert a\n /// fake lifetime here, because Chalks built-in logic may expect it to be there.\n fn ref_to_chalk("}]}