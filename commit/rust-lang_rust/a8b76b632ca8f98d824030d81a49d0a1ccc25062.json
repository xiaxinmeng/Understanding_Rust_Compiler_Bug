{"sha": "a8b76b632ca8f98d824030d81a49d0a1ccc25062", "node_id": "C_kwDOAAsO6NoAKGE4Yjc2YjYzMmNhOGY5OGQ4MjQwMzBkODFhNDlkMGExY2NjMjUwNjI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-10T19:53:50Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-10T19:53:50Z"}, "message": "Expand into pseudo-derive attribute expansions in completions", "tree": {"sha": "deaa4340482c31ebd0a801d744d15b80666cf0f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deaa4340482c31ebd0a801d744d15b80666cf0f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8b76b632ca8f98d824030d81a49d0a1ccc25062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8b76b632ca8f98d824030d81a49d0a1ccc25062", "html_url": "https://github.com/rust-lang/rust/commit/a8b76b632ca8f98d824030d81a49d0a1ccc25062", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8b76b632ca8f98d824030d81a49d0a1ccc25062/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "533f178a524dabe6c56ee533966f2a2be1a4104b", "url": "https://api.github.com/repos/rust-lang/rust/commits/533f178a524dabe6c56ee533966f2a2be1a4104b", "html_url": "https://github.com/rust-lang/rust/commit/533f178a524dabe6c56ee533966f2a2be1a4104b"}], "stats": {"total": 253, "additions": 197, "deletions": 56}, "files": [{"sha": "45544559eabaae7d1a4cc6369d2745d968dddb0b", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -151,6 +151,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.expand_attr_macro(item)\n     }\n \n+    pub fn expand_derive_as_pseudo_attr_macro(&self, attr: &ast::Attr) -> Option<SyntaxNode> {\n+        self.imp.expand_derive_as_pseudo_attr_macro(attr)\n+    }\n+\n     pub fn resolve_derive_macro(&self, derive: &ast::Attr) -> Option<Vec<Option<Macro>>> {\n         self.imp.resolve_derive_macro(derive)\n     }\n@@ -185,6 +189,19 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.speculative_expand_attr(actual_macro_call, speculative_args, token_to_map)\n     }\n \n+    pub fn speculative_expand_derive_as_pseudo_attr_macro(\n+        &self,\n+        actual_macro_call: &ast::Attr,\n+        speculative_args: &ast::Attr,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        self.imp.speculative_expand_derive_as_pseudo_attr_macro(\n+            actual_macro_call,\n+            speculative_args,\n+            token_to_map,\n+        )\n+    }\n+\n     /// Descend the token into macrocalls to its first mapped counterpart.\n     pub fn descend_into_macros_single(&self, token: SyntaxToken) -> SyntaxToken {\n         self.imp.descend_into_macros_single(token)\n@@ -438,9 +455,16 @@ impl<'db> SemanticsImpl<'db> {\n     fn expand_attr_macro(&self, item: &ast::Item) -> Option<SyntaxNode> {\n         let src = self.wrap_node_infile(item.clone());\n         let macro_call_id = self.with_ctx(|ctx| ctx.item_to_macro_call(src))?;\n-        let file_id = macro_call_id.as_file();\n-        let node = self.parse_or_expand(file_id)?;\n-        Some(node)\n+        self.parse_or_expand(macro_call_id.as_file())\n+    }\n+\n+    fn expand_derive_as_pseudo_attr_macro(&self, attr: &ast::Attr) -> Option<SyntaxNode> {\n+        let src = self.wrap_node_infile(attr.clone());\n+        let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n+        let call_id = self.with_ctx(|ctx| {\n+            ctx.attr_to_derive_macro_call(src.with_value(&adt), src).map(|(_, it, _)| it)\n+        })?;\n+        self.parse_or_expand(call_id.as_file())\n     }\n \n     fn resolve_derive_macro(&self, attr: &ast::Attr) -> Option<Vec<Option<Macro>>> {\n@@ -533,6 +557,25 @@ impl<'db> SemanticsImpl<'db> {\n         )\n     }\n \n+    fn speculative_expand_derive_as_pseudo_attr_macro(\n+        &self,\n+        actual_macro_call: &ast::Attr,\n+        speculative_args: &ast::Attr,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        let attr = self.wrap_node_infile(actual_macro_call.clone());\n+        let adt = actual_macro_call.syntax().parent().and_then(ast::Adt::cast)?;\n+        let macro_call_id = self.with_ctx(|ctx| {\n+            ctx.attr_to_derive_macro_call(attr.with_value(&adt), attr).map(|(_, it, _)| it)\n+        })?;\n+        hir_expand::db::expand_speculative(\n+            self.db.upcast(),\n+            macro_call_id,\n+            speculative_args.syntax(),\n+            token_to_map,\n+        )\n+    }\n+\n     // This might not be the correct way to do this, but it works for now\n     fn descend_node_into_attributes<N: AstNode>(&self, node: N) -> SmallVec<[N; 1]> {\n         let mut res = smallvec![];"}, {"sha": "0c886ac4da9dbc3b0d67f65fe500f178e8feb450", "filename": "crates/hir_expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -1,7 +1,5 @@\n //! Builtin attributes.\n \n-use itertools::Itertools;\n-\n use crate::{db::AstDatabase, name, ExpandResult, MacroCallId, MacroCallKind};\n \n macro_rules! register_builtin {\n@@ -98,10 +96,16 @@ fn derive_attr_expand(\n ) -> ExpandResult<tt::Subtree> {\n     let loc = db.lookup_intern_macro_call(id);\n     let derives = match &loc.kind {\n-        MacroCallKind::Attr { attr_args, .. } => &attr_args.0,\n-        _ => return ExpandResult::ok(tt.clone()),\n+        MacroCallKind::Attr { attr_args, is_derive: true, .. } => &attr_args.0,\n+        _ => return ExpandResult::ok(Default::default()),\n     };\n+    pseudo_derive_attr_expansion(tt, derives)\n+}\n \n+pub fn pseudo_derive_attr_expansion(\n+    tt: &tt::Subtree,\n+    args: &tt::Subtree,\n+) -> ExpandResult<tt::Subtree> {\n     let mk_leaf = |char| {\n         tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n             char,\n@@ -111,21 +115,12 @@ fn derive_attr_expand(\n     };\n \n     let mut token_trees = Vec::new();\n-    for (comma, group) in &derives\n-        .token_trees\n-        .iter()\n-        .filter_map(|tt| match tt {\n-            tt::TokenTree::Leaf(l) => Some(l),\n-            tt::TokenTree::Subtree(_) => None,\n-        })\n-        .group_by(|l| matches!(l, tt::Leaf::Punct(tt::Punct { char: ',', .. })))\n+    for tt in (&args.token_trees)\n+        .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: ',', .. }))))\n     {\n-        if comma {\n-            continue;\n-        }\n         token_trees.push(mk_leaf('#'));\n         token_trees.push(mk_leaf('['));\n-        token_trees.extend(group.cloned().map(tt::TokenTree::Leaf));\n+        token_trees.extend(tt.iter().cloned());\n         token_trees.push(mk_leaf(']'));\n     }\n     token_trees.push(mk_leaf('('));"}, {"sha": "9fe414de264ee53e9a9d065219aab7f281941527", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -14,10 +14,10 @@ use syntax::{\n };\n \n use crate::{\n-    ast_id_map::AstIdMap, fixup, hygiene::HygieneFrame, BuiltinAttrExpander, BuiltinDeriveExpander,\n-    BuiltinFnLikeExpander, ExpandError, ExpandResult, ExpandTo, HirFileId, HirFileIdRepr,\n-    MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile,\n-    ProcMacroExpander,\n+    ast_id_map::AstIdMap, builtin_attr_macro::pseudo_derive_attr_expansion, fixup,\n+    hygiene::HygieneFrame, BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n+    ExpandError, ExpandResult, ExpandTo, HirFileId, HirFileIdRepr, MacroCallId, MacroCallKind,\n+    MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -161,14 +161,16 @@ pub fn expand_speculative(\n     );\n \n     let (attr_arg, token_id) = match loc.kind {\n-        MacroCallKind::Attr { invoc_attr_index, .. } => {\n-            // Attributes may have an input token tree, build the subtree and map for this as well\n-            // then try finding a token id for our token if it is inside this input subtree.\n-            let item = ast::Item::cast(speculative_args.clone())?;\n-            let attr = item\n-                .doc_comments_and_attrs()\n-                .nth(invoc_attr_index as usize)\n-                .and_then(Either::left)?;\n+        MacroCallKind::Attr { invoc_attr_index, is_derive, .. } => {\n+            let attr = if is_derive {\n+                // for pseudo-derive expansion we actually pass the attribute itself only\n+                ast::Attr::cast(speculative_args.clone())\n+            } else {\n+                // Attributes may have an input token tree, build the subtree and map for this as well\n+                // then try finding a token id for our token if it is inside this input subtree.\n+                let item = ast::Item::cast(speculative_args.clone())?;\n+                item.doc_comments_and_attrs().nth(invoc_attr_index as usize).and_then(Either::left)\n+            }?;\n             match attr.token_tree() {\n                 Some(token_tree) => {\n                     let (mut tree, map) = syntax_node_to_token_tree(attr.token_tree()?.syntax());\n@@ -205,11 +207,15 @@ pub fn expand_speculative(\n \n     // Do the actual expansion, we need to directly expand the proc macro due to the attribute args\n     // Otherwise the expand query will fetch the non speculative attribute args and pass those instead.\n-    let mut speculative_expansion = if let MacroDefKind::ProcMacro(expander, ..) = loc.def.kind {\n-        tt.delimiter = None;\n-        expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n-    } else {\n-        macro_def.expand(db, actual_macro_call, &tt)\n+    let mut speculative_expansion = match loc.def.kind {\n+        MacroDefKind::ProcMacro(expander, ..) => {\n+            tt.delimiter = None;\n+            expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n+        }\n+        MacroDefKind::BuiltInAttr(BuiltinAttrExpander::Derive, _) => {\n+            pseudo_derive_attr_expansion(&tt, attr_arg.as_ref()?)\n+        }\n+        _ => macro_def.expand(db, actual_macro_call, &tt),\n     };\n \n     let expand_to = macro_expand_to(db, actual_macro_call);"}, {"sha": "ebea2d5dea8db74641ac33ecfddd545bd2f6f71e", "filename": "crates/ide_assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -32,7 +32,7 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     }\n \n     let mac_input = tt.syntax().children_with_tokens().skip(1).take_while(|it| *it != r_delim);\n-    let input_expressions = mac_input.into_iter().group_by(|tok| tok.kind() == T![,]);\n+    let input_expressions = mac_input.group_by(|tok| tok.kind() == T![,]);\n     let input_expressions = input_expressions\n         .into_iter()\n         .filter_map(|(is_sep, group)| (!is_sep).then(|| group))"}, {"sha": "6b51e19bbbe33c81829070d9df31ba3f331f6b5e", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -29,6 +29,8 @@ mod derive;\n mod lint;\n mod repr;\n \n+pub(crate) use self::derive::complete_derive;\n+\n /// Complete inputs to known builtin attributes as well as derive attributes\n pub(crate) fn complete_known_attribute_input(\n     acc: &mut Completions,\n@@ -46,7 +48,6 @@ pub(crate) fn complete_known_attribute_input(\n \n     match path.text().as_str() {\n         \"repr\" => repr::complete_repr(acc, ctx, tt),\n-        \"derive\" => derive::complete_derive(acc, ctx, ctx.attr.as_ref()?),\n         \"feature\" => lint::complete_lint(acc, ctx, &parse_tt_as_comma_sep_paths(tt)?, FEATURES),\n         \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n             let existing_lints = parse_tt_as_comma_sep_paths(tt)?;\n@@ -62,9 +63,7 @@ pub(crate) fn complete_known_attribute_input(\n \n             lint::complete_lint(acc, ctx, &existing_lints, &lints);\n         }\n-        \"cfg\" => {\n-            cfg::complete_cfg(acc, ctx);\n-        }\n+        \"cfg\" => cfg::complete_cfg(acc, ctx),\n         _ => (),\n     }\n     Some(())\n@@ -347,7 +346,7 @@ fn parse_comma_sep_expr(input: ast::TokenTree) -> Option<Vec<ast::Expr>> {\n         .children_with_tokens()\n         .skip(1)\n         .take_while(|it| it.as_token() != Some(&r_paren));\n-    let input_expressions = tokens.into_iter().group_by(|tok| tok.kind() == T![,]);\n+    let input_expressions = tokens.group_by(|tok| tok.kind() == T![,]);\n     Some(\n         input_expressions\n             .into_iter()"}, {"sha": "fdac579c020bcdd72824afb48ee874848dc53e8f", "filename": "crates/ide_completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -6,14 +6,21 @@ use ide_db::{\n };\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n-use syntax::{ast, SmolStr, SyntaxKind};\n+use syntax::{SmolStr, SyntaxKind};\n \n use crate::{\n-    completions::flyimport::compute_fuzzy_completion_order_key, context::CompletionContext,\n-    item::CompletionItem, Completions, ImportEdit,\n+    completions::flyimport::compute_fuzzy_completion_order_key,\n+    context::{CompletionContext, PathCompletionCtx, PathKind},\n+    item::CompletionItem,\n+    Completions, ImportEdit,\n };\n \n-pub(super) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext, attr: &ast::Attr) {\n+pub(crate) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext) {\n+    let attr = match (&ctx.path_context, ctx.attr.as_ref()) {\n+        (Some(PathCompletionCtx { kind: Some(PathKind::Derive), .. }), Some(attr)) => attr,\n+        _ => return,\n+    };\n+\n     let core = ctx.famous_defs().core();\n     let existing_derives: FxHashSet<_> =\n         ctx.sema.resolve_derive_macro(attr).into_iter().flatten().flatten().collect();"}, {"sha": "a613dd574beda05fb80a909f95a7c8be75861d98", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -153,7 +153,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         };\n         match (kind, import.original_item) {\n             // Aren't handled in flyimport\n-            (PathKind::Vis { .. } | PathKind::Use, _) => false,\n+            (PathKind::Vis { .. } | PathKind::Use | PathKind::Derive, _) => false,\n             // modules are always fair game\n             (_, ItemInNs::Types(hir::ModuleDef::Module(_))) => true,\n             // and so are macros(except for attributes)"}, {"sha": "bf389fb6ebda6237a19b681352288265d47f0731", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -63,7 +63,13 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     }\n \n     match kind {\n-        Some(PathKind::Pat | PathKind::Attr { .. } | PathKind::Vis { .. } | PathKind::Use) => {\n+        Some(\n+            PathKind::Pat\n+            | PathKind::Attr { .. }\n+            | PathKind::Vis { .. }\n+            | PathKind::Use\n+            | PathKind::Derive,\n+        ) => {\n             return;\n         }\n         _ => {"}, {"sha": "c89102e1c3687647c3cd5bfad167dacea9062571", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -19,10 +19,11 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         Some(PathCompletionCtx {\n             kind:\n                 Some(\n-                    PathKind::Vis { .. }\n-                    | PathKind::Attr { .. }\n+                    PathKind::Attr { .. }\n+                    | PathKind::Derive\n+                    | PathKind::Pat\n                     | PathKind::Use { .. }\n-                    | PathKind::Pat,\n+                    | PathKind::Vis { .. },\n                 ),\n             ..\n         }) => return,"}, {"sha": "f29a609c1cdabad16b129aec5416cd5bcfc13426", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -43,11 +43,12 @@ pub(crate) enum Visible {\n     No,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(super) enum PathKind {\n     Expr,\n     Type,\n     Attr { kind: AttrKind, annotated_item_kind: Option<SyntaxKind> },\n+    Derive,\n     Mac,\n     Pat,\n     Vis { has_in_token: bool },\n@@ -472,6 +473,8 @@ impl<'a> CompletionContext<'a> {\n         mut fake_ident_token: SyntaxToken,\n     ) {\n         let _p = profile::span(\"CompletionContext::expand_and_fill\");\n+        let mut derive_ctx = None;\n+\n         'expansion: loop {\n             let parent_item =\n                 |item: &ast::Item| item.syntax().ancestors().skip(1).find_map(ast::Item::cast);\n@@ -509,11 +512,45 @@ impl<'a> CompletionContext<'a> {\n                     _ => break 'expansion,\n                 }\n             }\n+            let orig_tt = match find_node_at_offset::<ast::TokenTree>(&original_file, offset) {\n+                Some(it) => it,\n+                None => break,\n+            };\n+            let spec_tt = match find_node_at_offset::<ast::TokenTree>(&speculative_file, offset) {\n+                Some(it) => it,\n+                None => break,\n+            };\n+\n+            // Expand pseudo-derive expansion\n+            if let (Some(orig_attr), Some(spec_attr)) = (\n+                orig_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+                spec_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+            ) {\n+                match (\n+                    self.sema.expand_derive_as_pseudo_attr_macro(&orig_attr),\n+                    self.sema.speculative_expand_derive_as_pseudo_attr_macro(\n+                        &orig_attr,\n+                        &spec_attr,\n+                        fake_ident_token.clone(),\n+                    ),\n+                ) {\n+                    // Clearly not a derive macro\n+                    (None, None) => (),\n+                    // successful expansions\n+                    (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n+                        let new_offset = fake_mapped_token.text_range().start();\n+                        derive_ctx = Some((actual_expansion, fake_expansion, new_offset));\n+                        break 'expansion;\n+                    }\n+                    // exactly one expansion failed, inconsistent state so stop expanding completely\n+                    _ => break 'expansion,\n+                }\n+            }\n \n             // Expand fn-like macro calls\n             if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n-                find_node_at_offset::<ast::MacroCall>(&original_file, offset),\n-                find_node_at_offset::<ast::MacroCall>(&speculative_file, offset),\n+                orig_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n+                spec_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n             ) {\n                 let mac_call_path0 = actual_macro_call.path().as_ref().map(|s| s.syntax().text());\n                 let mac_call_path1 =\n@@ -553,7 +590,7 @@ impl<'a> CompletionContext<'a> {\n             break;\n         }\n \n-        self.fill(&original_file, speculative_file, offset);\n+        self.fill(&original_file, speculative_file, offset, derive_ctx);\n     }\n \n     fn expected_type_and_name(&self) -> (Option<Type>, Option<NameOrNameRef>) {\n@@ -697,6 +734,7 @@ impl<'a> CompletionContext<'a> {\n         original_file: &SyntaxNode,\n         file_with_fake_ident: SyntaxNode,\n         offset: TextSize,\n+        derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize)>,\n     ) {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n         let syntax_element = NodeOrToken::Token(fake_ident_token);\n@@ -724,6 +762,21 @@ impl<'a> CompletionContext<'a> {\n         self.expected_type = expected_type;\n         self.expected_name = expected_name;\n \n+        // Overwrite the path kind for derives\n+        if let Some((original_file, file_with_fake_ident, offset)) = derive_ctx {\n+            if let Some(ast::NameLike::NameRef(name_ref)) =\n+                find_node_at_offset(&file_with_fake_ident, offset)\n+            {\n+                if let Some((path_ctx, _)) =\n+                    Self::classify_name_ref(&self.sema, &original_file, name_ref)\n+                {\n+                    self.path_context =\n+                        Some(PathCompletionCtx { kind: Some(PathKind::Derive), ..path_ctx });\n+                }\n+            }\n+            return;\n+        }\n+\n         let name_like = match find_node_at_offset(&file_with_fake_ident, offset) {\n             Some(it) => it,\n             None => return,\n@@ -743,6 +796,7 @@ impl<'a> CompletionContext<'a> {\n             .token_ancestors_with_macros(self.token.clone())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::Fn::cast);\n+\n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n                 self.lifetime_ctx ="}, {"sha": "86a6947b1dda8212372c910cd7585d6a61cc52ce", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -152,6 +152,7 @@ pub fn completions(\n \n     let mut acc = Completions::default();\n     completions::attribute::complete_attribute(&mut acc, &ctx);\n+    completions::attribute::complete_derive(&mut acc, &ctx);\n     completions::attribute::complete_known_attribute_input(&mut acc, &ctx);\n     completions::dot::complete_dot(&mut acc, &ctx);\n     completions::extern_abi::complete_extern_abi(&mut acc, &ctx);"}, {"sha": "2c96add22eaa8bd8abc095056b7d502c046d7341", "filename": "crates/ide_completion/src/tests/attribute.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -760,6 +760,7 @@ mod derive {\n         check_derive(\n             r#\"\n //- proc_macros: derive_identity\n+//- minicore: derive\n #[derive(der$0)] struct Test;\n \"#,\n             expect![[r#\"\n@@ -769,6 +770,7 @@ mod derive {\n         check_derive(\n             r#\"\n //- proc_macros: derive_identity\n+//- minicore: derive\n use proc_macros::DeriveIdentity;\n #[derive(der$0)] struct Test;\n \"#,\n@@ -784,6 +786,7 @@ use proc_macros::DeriveIdentity;\n             \"DeriveIdentity\",\n             r#\"\n //- proc_macros: derive_identity\n+//- minicore: derive\n #[derive(der$0)] struct Test;\n \"#,\n             r#\"\n@@ -793,6 +796,32 @@ use proc_macros::DeriveIdentity;\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn qualified() {\n+        check_derive(\n+            r#\"\n+//- proc_macros: derive_identity\n+//- minicore: derive, copy, clone\n+#[derive(proc_macros::$0)] struct Test;\n+\"#,\n+            expect![[r#\"\n+                de Clone, Copy\n+                de Clone\n+            \"#]],\n+        );\n+        check_derive(\n+            r#\"\n+//- proc_macros: derive_identity\n+//- minicore: derive, copy, clone\n+#[derive(proc_macros::C$0)] struct Test;\n+\"#,\n+            expect![[r#\"\n+                de Clone, Copy\n+                de Clone\n+            \"#]],\n+        );\n+    }\n }\n \n mod lint {"}, {"sha": "c0f052996631b21ea3a7d952a4ea67bcc3b47f53", "filename": "crates/ide_db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b76b632ca8f98d824030d81a49d0a1ccc25062/crates%2Fide_db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=a8b76b632ca8f98d824030d81a49d0a1ccc25062", "patch": "@@ -443,7 +443,7 @@ pub fn parse_tt_as_comma_sep_paths(input: ast::TokenTree) -> Option<Vec<ast::Pat\n             None => None,\n             Some(tok) => Some(tok),\n         });\n-    let input_expressions = tokens.into_iter().group_by(|tok| tok.kind() == T![,]);\n+    let input_expressions = tokens.group_by(|tok| tok.kind() == T![,]);\n     let paths = input_expressions\n         .into_iter()\n         .filter_map(|(is_sep, group)| (!is_sep).then(|| group))"}]}