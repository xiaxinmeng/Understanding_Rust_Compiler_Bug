{"sha": "7596fcfba7e524977f42f24933173414f3e23cd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1OTZmY2ZiYTdlNTI0OTc3ZjQyZjI0OTMzMTczNDE0ZjNlMjNjZDE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-20T21:34:17Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-20T21:34:17Z"}, "message": "rustc: Define type hashing inductively", "tree": {"sha": "37b21e440db1194fde884c9a5f0f619cfdac2e5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37b21e440db1194fde884c9a5f0f619cfdac2e5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7596fcfba7e524977f42f24933173414f3e23cd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7596fcfba7e524977f42f24933173414f3e23cd1", "html_url": "https://github.com/rust-lang/rust/commit/7596fcfba7e524977f42f24933173414f3e23cd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7596fcfba7e524977f42f24933173414f3e23cd1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "276a0f2de8d132e40ff1d29c32249ba1963bd73e", "url": "https://api.github.com/repos/rust-lang/rust/commits/276a0f2de8d132e40ff1d29c32249ba1963bd73e", "html_url": "https://github.com/rust-lang/rust/commit/276a0f2de8d132e40ff1d29c32249ba1963bd73e"}], "stats": {"total": 109, "additions": 97, "deletions": 12}, "files": [{"sha": "a694a20300011805a910e57b9993e497daeb5424", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 97, "deletions": 12, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/7596fcfba7e524977f42f24933173414f3e23cd1/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7596fcfba7e524977f42f24933173414f3e23cd1/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=7596fcfba7e524977f42f24933173414f3e23cd1", "patch": "@@ -756,28 +756,113 @@ fn simple_ty_code(&sty st) -> uint {\n // Type hashing. This function is private to this module (and slow); external\n // users should use `hash_ty()` instead.\n fn hash_type_structure(&sty st) -> uint {\n+    fn hash_uint(uint id, uint n) -> uint {\n+        auto h = id;\n+        h += h << 5u + n;\n+        ret h;\n+    }\n \n-    auto s = simple_ty_code(st);\n-    if (s != 0xffffu) {\n-        ret s;\n+    fn hash_def(uint id, ast.def_id did) -> uint {\n+        auto h = id;\n+        h += h << 5u + (did._0 as uint);\n+        h += h << 5u + (did._1 as uint);\n+        ret h;\n     }\n-    auto f = def_to_str;\n \n-    // FIXME: Gross. Use structural hashing when we have it.\n-    auto fake_ty = @rec(struct=st, cname=none[str], hash=0u);\n-    ret _str.hash(metadata.ty_str(fake_ty, f));\n+    fn hash_subty(uint id, @t subty) -> uint {\n+        auto h = id;\n+        h += h << 5u + hash_ty(subty);\n+        ret h;\n+    }\n+\n+    fn hash_fn(uint id, vec[arg] args, @t rty) -> uint {\n+        auto h = id;\n+        for (arg a in args) {\n+            h += h << 5u + hash_ty(a.ty);\n+        }\n+        h += h << 5u + hash_ty(rty);\n+        ret h;\n+    }\n+\n+    alt (st) {\n+        case (ty_nil) { ret 0u; }\n+        case (ty_bool) { ret 1u; }\n+        case (ty_int) { ret 2u; }\n+        case (ty_float) { ret 3u; }\n+        case (ty_uint) { ret 4u; }\n+        case (ty_machine(?tm)) {\n+            alt (tm) {\n+                case (common.ty_i8) { ret 5u; }\n+                case (common.ty_i16) { ret 6u; }\n+                case (common.ty_i32) { ret 7u; }\n+                case (common.ty_i64) { ret 8u; }\n+\n+                case (common.ty_u8) { ret 9u; }\n+                case (common.ty_u16) { ret 10u; }\n+                case (common.ty_u32) { ret 11u; }\n+                case (common.ty_u64) { ret 12u; }\n+\n+                case (common.ty_f32) { ret 13u; }\n+                case (common.ty_f64) { ret 14u; }\n+            }\n+        }\n+        case (ty_char) { ret 15u; }\n+        case (ty_str) { ret 16u; }\n+        case (ty_tag(?did, ?tys)) {\n+            auto h = hash_def(17u, did);\n+            for (@ty.t typ in tys) {\n+                h += h << 5u + hash_ty(typ);\n+            }\n+            ret h;\n+        }\n+        case (ty_box(?mt)) { ret hash_subty(18u, mt.ty); }\n+        case (ty_vec(?mt)) { ret hash_subty(19u, mt.ty); }\n+        case (ty_port(?typ)) { ret hash_subty(20u, typ); }\n+        case (ty_chan(?typ)) { ret hash_subty(21u, typ); }\n+        case (ty_task) { ret 22u; }\n+        case (ty_tup(?mts)) {\n+            auto h = 23u;\n+            for (mt tm in mts) {\n+                h += h << 5u + hash_ty(tm.ty);\n+            }\n+            ret h;\n+        }\n+        case (ty_rec(?fields)) {\n+            auto h = 24u;\n+            for (field f in fields) {\n+                h += h << 5u + hash_ty(f.mt.ty);\n+            }\n+            ret h;\n+        }\n+        case (ty_fn(_, ?args, ?rty)) { ret hash_fn(25u, args, rty); }\n+        case (ty_native_fn(_, ?args, ?rty)) { ret hash_fn(26u, args, rty); }\n+        case (ty_obj(?methods)) {\n+            auto h = 27u;\n+            for (method m in methods) {\n+                h += h << 5u + _str.hash(m.ident);\n+            }\n+            ret h;\n+        }\n+        case (ty_var(?v)) { ret hash_uint(28u, v as uint); }\n+        case (ty_local(?did)) { ret hash_def(29u, did); }\n+        case (ty_param(?pid)) { ret hash_uint(30u, pid); }\n+        case (ty_bound_param(?pid)) { ret hash_uint(31u, pid); }\n+        case (ty_type) { ret 32u; }\n+        case (ty_native) { ret 33u; }\n+    }\n }\n \n fn hash_ty(&@t typ) -> uint { ret typ.hash; }\n \n fn eq_ty(&@t a, &@t b) -> bool {\n-\n-    auto sa = simple_ty_code(a.struct);\n-    if (sa != 0xffffu) {\n-        auto sb = simple_ty_code(b.struct);\n-        ret sa == sb;\n+    auto sa = hash_type_structure(a.struct);\n+    auto sb = hash_type_structure(b.struct);\n+    if (sa != sb) {\n+        ret false;\n     }\n \n+    // TODO: shortcut for simple types\n+\n     // FIXME: this is gross, but I think it's safe, and I don't think writing\n     // a giant function to handle all the cases is necessary when structural\n     // equality will someday save the day."}]}