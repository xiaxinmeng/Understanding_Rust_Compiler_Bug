{"sha": "b80b659d674fa19b2b48142e4f7974544bc8d5f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MGI2NTlkNjc0ZmExOWIyYjQ4MTQyZTRmNzk3NDU0NGJjOGQ1ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-07T01:32:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-07T01:32:13Z"}, "message": "Auto merge of #42125 - petrochenkov:privty, r=nikomatsakis\n\nCheck types for privacy\n\nThis PR implements late post factum checking of type privacy, as opposed to early preventive \"private-in-public\" checking.\nThis will allow to turn private-in-public checks into a lint and make them more heuristic-based, and more aligned with what people may expect (e.g. reachability-based behavior).\n\nTypes are privacy-checked if they are written explicitly, and also if they are inferred as expression or pattern types.\nThis PR checks \"semantic\" types and does it unhygienically, this significantly restricts what macros 2.0 (as implemented in https://github.com/rust-lang/rust/pull/40847) can do (sorry @jseyfried) - they still can use private *names*, but can't use private *types*.\nThis is the most conservative solution, but hopefully it's temporary and can be relaxed in the future, probably using macro contexts of expression/pattern spans.\n\nTraits are also checked in preparation for [trait aliases](https://github.com/rust-lang/rust/issues/41517), which will be able to leak private traits, and macros 2.0 which will be able to leak pretty much anything.\n\nThis is a [breaking-change], but the code that is not contrived and can be broken by this patch should be guarded by `private_in_public` lint. [Previous crater run](https://github.com/rust-lang/rust/issues/34537#issuecomment-262865768) discovered a few abandoned crates that weren't updated since `private_in_public` has been introduced in 2015.\n\ncc https://github.com/rust-lang/rust/issues/34537 https://internals.rust-lang.org/t/lang-team-minutes-private-in-public-rules/4504\nFixes https://github.com/rust-lang/rust/issues/30476\nFixes https://github.com/rust-lang/rust/issues/33479\n\ncc @nikomatsakis\nr? @eddyb", "tree": {"sha": "69ad9cba4eb4766925363fd617b58fcf5587a13c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69ad9cba4eb4766925363fd617b58fcf5587a13c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b80b659d674fa19b2b48142e4f7974544bc8d5f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b80b659d674fa19b2b48142e4f7974544bc8d5f6", "html_url": "https://github.com/rust-lang/rust/commit/b80b659d674fa19b2b48142e4f7974544bc8d5f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b80b659d674fa19b2b48142e4f7974544bc8d5f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2ebb12a1d6f6599f9171a65a2160e523b53ccdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ebb12a1d6f6599f9171a65a2160e523b53ccdf", "html_url": "https://github.com/rust-lang/rust/commit/d2ebb12a1d6f6599f9171a65a2160e523b53ccdf"}, {"sha": "a27f8cf8a36f3d69267ed25602504144fab1d896", "url": "https://api.github.com/repos/rust-lang/rust/commits/a27f8cf8a36f3d69267ed25602504144fab1d896", "html_url": "https://github.com/rust-lang/rust/commit/a27f8cf8a36f3d69267ed25602504144fab1d896"}], "stats": {"total": 673, "additions": 665, "deletions": 8}, "files": [{"sha": "0db2b86b15f5725109d89fa6d2522ce040e4a1a6", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -87,7 +87,7 @@ impl ProcMacro for Quoter {\n         let mut info = cx.current_expansion.mark.expn_info().unwrap();\n         info.callee.allow_internal_unstable = true;\n         cx.current_expansion.mark.set_expn_info(info);\n-        ::__internal::set_sess(cx, || quote!(::TokenStream((quote stream))))\n+        ::__internal::set_sess(cx, || quote!(::TokenStream { 0: (quote stream) }))\n     }\n }\n "}, {"sha": "051b89219c1f54cd8141472d03f9daacacac3348", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 350, "deletions": 2, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -18,13 +18,13 @@\n \n #![feature(rustc_diagnostic_macros)]\n \n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::{LOCAL_CRATE, CrateNum, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::lint;\n@@ -537,6 +537,344 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////////////////\n+/// Type privacy visitor, checks types for privacy and reports violations.\n+/// Both explicitly written types and inferred types of expressions and patters are checked.\n+/// Checks are performed on \"semantic\" types regardless of names and their hygiene.\n+////////////////////////////////////////////////////////////////////////////////////////////\n+\n+struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::TypeckTables<'tcx>,\n+    current_item: DefId,\n+    span: Span,\n+}\n+\n+impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n+    fn def_id_visibility(&self, did: DefId) -> ty::Visibility {\n+        match self.tcx.hir.as_local_node_id(did) {\n+            Some(node_id) => {\n+                let vis = match self.tcx.hir.get(node_id) {\n+                    hir::map::NodeItem(item) => &item.vis,\n+                    hir::map::NodeForeignItem(foreign_item) => &foreign_item.vis,\n+                    hir::map::NodeImplItem(impl_item) => &impl_item.vis,\n+                    hir::map::NodeTraitItem(..) |\n+                    hir::map::NodeVariant(..) => {\n+                        return self.def_id_visibility(self.tcx.hir.get_parent_did(node_id));\n+                    }\n+                    hir::map::NodeStructCtor(vdata) => {\n+                        let struct_node_id = self.tcx.hir.get_parent(node_id);\n+                        let struct_vis = match self.tcx.hir.get(struct_node_id) {\n+                            hir::map::NodeItem(item) => &item.vis,\n+                            node => bug!(\"unexpected node kind: {:?}\", node),\n+                        };\n+                        let mut ctor_vis\n+                            = ty::Visibility::from_hir(struct_vis, struct_node_id, self.tcx);\n+                        for field in vdata.fields() {\n+                            let field_vis = ty::Visibility::from_hir(&field.vis, node_id, self.tcx);\n+                            if ctor_vis.is_at_least(field_vis, self.tcx) {\n+                                ctor_vis = field_vis;\n+                            }\n+                        }\n+                        return ctor_vis;\n+                    }\n+                    node => bug!(\"unexpected node kind: {:?}\", node)\n+                };\n+                ty::Visibility::from_hir(vis, node_id, self.tcx)\n+            }\n+            None => self.tcx.sess.cstore.visibility(did),\n+        }\n+    }\n+\n+    fn item_is_accessible(&self, did: DefId) -> bool {\n+        self.def_id_visibility(did).is_accessible_from(self.current_item, self.tcx)\n+    }\n+\n+    // Take node ID of an expression or pattern and check its type for privacy.\n+    fn check_expr_pat_type(&mut self, id: ast::NodeId, span: Span) -> bool {\n+        self.span = span;\n+        if let Some(ty) = self.tables.node_id_to_type_opt(id) {\n+            if ty.visit_with(self) {\n+                return true;\n+            }\n+        }\n+        if self.tables.node_substs(id).visit_with(self) {\n+            return true;\n+        }\n+        if let Some(adjustments) = self.tables.adjustments.get(&id) {\n+            for adjustment in adjustments {\n+                if adjustment.target.visit_with(self) {\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n+    fn check_item(&mut self, item_id: ast::NodeId) -> &mut Self {\n+        self.current_item = self.tcx.hir.local_def_id(item_id);\n+        self.span = self.tcx.hir.span(item_id);\n+        self\n+    }\n+\n+    // Convenience methods for checking item interfaces\n+    fn ty(&mut self) -> &mut Self {\n+        self.tcx.type_of(self.current_item).visit_with(self);\n+        self\n+    }\n+\n+    fn generics(&mut self) -> &mut Self {\n+        for def in &self.tcx.generics_of(self.current_item).types {\n+            if def.has_default {\n+                self.tcx.type_of(def.def_id).visit_with(self);\n+            }\n+        }\n+        self\n+    }\n+\n+    fn predicates(&mut self) -> &mut Self {\n+        self.tcx.predicates_of(self.current_item).visit_with(self);\n+        self\n+    }\n+\n+    fn impl_trait_ref(&mut self) -> &mut Self {\n+        self.tcx.impl_trait_ref(self.current_item).visit_with(self);\n+        self\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.tcx.hir)\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n+        let body = self.tcx.hir.body(body);\n+        self.visit_body(body);\n+        self.tables = orig_tables;\n+    }\n+\n+    // Check types of expressions\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        if self.check_expr_pat_type(expr.id, expr.span) {\n+            // Do not check nested expressions if the error already happened.\n+            return;\n+        }\n+        match expr.node {\n+            hir::ExprAssign(.., ref rhs) | hir::ExprMatch(ref rhs, ..) => {\n+                // Do not report duplicate errors for `x = y` and `match x { ... }`.\n+                if self.check_expr_pat_type(rhs.id, rhs.span) {\n+                    return;\n+                }\n+            }\n+            hir::ExprMethodCall(name, ..) => {\n+                // Method calls have to be checked specially.\n+                let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                self.span = name.span;\n+                if self.tcx.type_of(def_id).visit_with(self) {\n+                    return;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn visit_qpath(&mut self, qpath: &'tcx hir::QPath, id: ast::NodeId, span: Span) {\n+        // Inherent associated constants don't have self type in substs,\n+        // we have to check it additionally.\n+        if let hir::QPath::TypeRelative(..) = *qpath {\n+            if let Some(def) = self.tables.type_dependent_defs.get(&id).cloned() {\n+                if let Some(assoc_item) = self.tcx.opt_associated_item(def.def_id()) {\n+                    if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n+                        if self.tcx.type_of(impl_def_id).visit_with(self) {\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        intravisit::walk_qpath(self, qpath, id, span);\n+    }\n+\n+    // Check types of patterns\n+    fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n+        if self.check_expr_pat_type(pattern.id, pattern.span) {\n+            // Do not check nested patterns if the error already happened.\n+            return;\n+        }\n+\n+        intravisit::walk_pat(self, pattern);\n+    }\n+\n+    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+        if let Some(ref init) = local.init {\n+            if self.check_expr_pat_type(init.id, init.span) {\n+                // Do not report duplicate errors for `let x = y`.\n+                return;\n+            }\n+        }\n+\n+        intravisit::walk_local(self, local);\n+    }\n+\n+    // Check types in item interfaces\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let orig_current_item = self.current_item;\n+\n+        match item.node {\n+            hir::ItemExternCrate(..) | hir::ItemMod(..) |\n+            hir::ItemUse(..) | hir::ItemGlobalAsm(..) => {}\n+            hir::ItemConst(..) | hir::ItemStatic(..) |\n+            hir::ItemTy(..) | hir::ItemFn(..) => {\n+                self.check_item(item.id).generics().predicates().ty();\n+            }\n+            hir::ItemTrait(.., ref trait_item_refs) => {\n+                self.check_item(item.id).generics().predicates();\n+                for trait_item_ref in trait_item_refs {\n+                    let mut check = self.check_item(trait_item_ref.id.node_id);\n+                    check.generics().predicates();\n+                    if trait_item_ref.kind != hir::AssociatedItemKind::Type ||\n+                       trait_item_ref.defaultness.has_value() {\n+                        check.ty();\n+                    }\n+                }\n+            }\n+            hir::ItemEnum(ref def, _) => {\n+                self.check_item(item.id).generics().predicates();\n+                for variant in &def.variants {\n+                    for field in variant.node.data.fields() {\n+                        self.check_item(field.id).ty();\n+                    }\n+                }\n+            }\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    self.check_item(foreign_item.id).generics().predicates().ty();\n+                }\n+            }\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n+                self.check_item(item.id).generics().predicates();\n+                for field in struct_def.fields() {\n+                    self.check_item(field.id).ty();\n+                }\n+            }\n+            hir::ItemDefaultImpl(..) => {\n+                self.check_item(item.id).impl_trait_ref();\n+            }\n+            hir::ItemImpl(.., ref trait_ref, _, ref impl_item_refs) => {\n+                {\n+                    let mut check = self.check_item(item.id);\n+                    check.ty().generics().predicates();\n+                    if trait_ref.is_some() {\n+                        check.impl_trait_ref();\n+                    }\n+                }\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n+                    self.check_item(impl_item.id).generics().predicates().ty();\n+                }\n+            }\n+        }\n+\n+        self.current_item = self.tcx.hir.local_def_id(item.id);\n+        intravisit::walk_item(self, item);\n+        self.current_item = orig_current_item;\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        match ty.sty {\n+            ty::TyAdt(&ty::AdtDef { did: def_id, .. }, ..) | ty::TyFnDef(def_id, ..) => {\n+                if !self.item_is_accessible(def_id) {\n+                    let msg = format!(\"type `{}` is private\", ty);\n+                    self.tcx.sess.span_err(self.span, &msg);\n+                    return true;\n+                }\n+                if let ty::TyFnDef(..) = ty.sty {\n+                    if self.tcx.fn_sig(def_id).visit_with(self) {\n+                        return true;\n+                    }\n+                }\n+                // Inherent static methods don't have self type in substs,\n+                // we have to check it additionally.\n+                if let Some(assoc_item) = self.tcx.opt_associated_item(def_id) {\n+                    if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n+                        if self.tcx.type_of(impl_def_id).visit_with(self) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            ty::TyDynamic(ref predicates, ..) => {\n+                let is_private = predicates.skip_binder().iter().any(|predicate| {\n+                    let def_id = match *predicate {\n+                        ty::ExistentialPredicate::Trait(trait_ref) => trait_ref.def_id,\n+                        ty::ExistentialPredicate::Projection(proj) => proj.trait_ref.def_id,\n+                        ty::ExistentialPredicate::AutoTrait(def_id) => def_id,\n+                    };\n+                    !self.item_is_accessible(def_id)\n+                });\n+                if is_private {\n+                    let msg = format!(\"type `{}` is private\", ty);\n+                    self.tcx.sess.span_err(self.span, &msg);\n+                    return true;\n+                }\n+            }\n+            ty::TyAnon(def_id, ..) => {\n+                for predicate in &self.tcx.predicates_of(def_id).predicates {\n+                    let trait_ref = match *predicate {\n+                        ty::Predicate::Trait(ref poly_trait_predicate) => {\n+                            Some(poly_trait_predicate.skip_binder().trait_ref)\n+                        }\n+                        ty::Predicate::Projection(ref poly_projection_predicate) => {\n+                            if poly_projection_predicate.skip_binder().ty.visit_with(self) {\n+                                return true;\n+                            }\n+                            Some(poly_projection_predicate.skip_binder().projection_ty.trait_ref)\n+                        }\n+                        ty::Predicate::TypeOutlives(..) => None,\n+                        _ => bug!(\"unexpected predicate: {:?}\", predicate),\n+                    };\n+                    if let Some(trait_ref) = trait_ref {\n+                        if !self.item_is_accessible(trait_ref.def_id) {\n+                            let msg = format!(\"trait `{}` is private\", trait_ref);\n+                            self.tcx.sess.span_err(self.span, &msg);\n+                            return true;\n+                        }\n+                        // `Self` here is the same `TyAnon`, so skip it to avoid infinite recursion\n+                        for subst in trait_ref.substs.iter().skip(1) {\n+                            if subst.visit_with(self) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        ty.super_visit_with(self)\n+    }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n+        if !self.item_is_accessible(trait_ref.def_id) {\n+            let msg = format!(\"trait `{}` is private\", trait_ref);\n+            self.tcx.sess.span_err(self.span, &msg);\n+            return true;\n+        }\n+\n+        trait_ref.super_visit_with(self)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////////\n /// Obsolete visitors for checking for private items in public interfaces.\n /// These visitors are supposed to be kept in frozen state and produce an\n@@ -1225,6 +1563,16 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n \n+    // Check privacy of explicitly written types and traits as well as\n+    // inferred types of expressions and patterns.\n+    let mut visitor = TypePrivacyVisitor {\n+        tcx: tcx,\n+        tables: &ty::TypeckTables::empty(),\n+        current_item: DefId::local(CRATE_DEF_INDEX),\n+        span: krate.span,\n+    };\n+    intravisit::walk_crate(&mut visitor, krate);\n+\n     // Build up a set of all exported items in the AST. This is a set of all\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {"}, {"sha": "7627f5dc0cd09e70b7163062ab5e3b597303d725", "filename": "src/test/compile-fail/auxiliary/private-inferred-type.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fprivate-inferred-type.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+fn priv_fn() {}\n+enum PrivEnum { Variant }\n+pub enum PubEnum { Variant }\n+trait PrivTrait { fn method() {} }\n+impl PrivTrait for u8 {}\n+pub trait PubTrait { fn method() {} }\n+impl PubTrait for u8 {}\n+struct PrivTupleStruct(u8);\n+pub struct PubTupleStruct(u8);\n+impl PubTupleStruct { fn method() {} }\n+\n+struct Priv;\n+pub type Alias = Priv;\n+pub struct Pub<T = Alias>(pub T);\n+\n+impl Pub<Priv> {\n+    pub fn static_method() {}\n+}\n+impl Pub<u8> {\n+    fn priv_method(&self) {}\n+}\n+\n+pub macro m() {\n+    priv_fn;\n+    PrivEnum::Variant;\n+    PubEnum::Variant;\n+    <u8 as PrivTrait>::method;\n+    <u8 as PubTrait>::method;\n+    PrivTupleStruct;\n+    PubTupleStruct;\n+    Pub(0u8).priv_method();\n+}"}, {"sha": "aa67e5c5f4db7bcaf1d43feb2d228b63982cca6e", "filename": "src/test/compile-fail/hygiene/auxiliary/intercrate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fauxiliary%2Fintercrate.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "previous_filename": "src/test/run-pass/hygiene/auxiliary/intercrate.rs"}, {"sha": "64217770b13c9ad278b1381f4697ba86dde7e3ec", "filename": "src/test/compile-fail/hygiene/fields.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fhygiene%2Ffields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fhygiene%2Ffields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Ffields.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -22,11 +22,11 @@ mod foo {\n             x: i32,\n         }\n \n-        let s = S { x: 0 };\n-        let _ = s.x;\n+        let s = S { x: 0 }; //~ ERROR type `foo::S` is private\n+        let _ = s.x; //~ ERROR type `foo::S` is private\n \n-        let t = T(0);\n-        let _ = t.0;\n+        let t = T(0); //~ ERROR type `foo::T` is private\n+        let _ = t.0; //~ ERROR type `foo::T` is private\n \n         let s = $S { $x: 0, x: 1 };\n         assert_eq!((s.$x, s.x), (0, 1));", "previous_filename": "src/test/run-pass/hygiene/fields.rs"}, {"sha": "445aa62f2361ee0ebf02dfe089430934a60c0116", "filename": "src/test/compile-fail/hygiene/impl_items.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -19,7 +19,7 @@ mod foo {\n     }\n \n     pub macro m() {\n-        let _: () = S.f();\n+        let _: () = S.f(); //~ ERROR type `fn(&foo::S) {foo::S::f}` is private\n     }\n }\n ", "previous_filename": "src/test/run-pass/hygiene/impl_items.rs"}, {"sha": "50fc985ba34faea982f93aa51efb5f468af4f073", "filename": "src/test/compile-fail/hygiene/intercrate.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fintercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fintercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fintercrate.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -12,6 +12,8 @@\n \n // aux-build:intercrate.rs\n \n+// error-pattern:type `fn() -> u32 {intercrate::foo::bar::f}` is private\n+\n #![feature(decl_macro)]\n \n extern crate intercrate;", "previous_filename": "src/test/run-pass/hygiene/intercrate.rs"}, {"sha": "ba8b3d1810a05dc605c62a152113d23d4b811604", "filename": "src/test/compile-fail/private-inferred-type-1.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-1.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Arr0 {\n+    fn arr0_secret(&self);\n+}\n+trait TyParam {\n+    fn ty_param_secret(&self);\n+}\n+\n+mod m {\n+    struct Priv;\n+\n+    impl ::Arr0 for [Priv; 0] { fn arr0_secret(&self) {} }\n+    impl ::TyParam for Option<Priv> { fn ty_param_secret(&self) {} }\n+}\n+\n+fn main() {\n+    [].arr0_secret(); //~ ERROR type `m::Priv` is private\n+    None.ty_param_secret(); //~ ERROR type `m::Priv` is private\n+}"}, {"sha": "e981f1257501511c0d8f881b6b001b439d45cc0f", "filename": "src/test/compile-fail/private-inferred-type-2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-2.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:private-inferred-type.rs\n+\n+extern crate private_inferred_type as ext;\n+\n+mod m {\n+    struct Priv;\n+    pub struct Pub<T>(pub T);\n+\n+    impl Pub<Priv> {\n+        pub fn get_priv() -> Priv { Priv }\n+        pub fn static_method() {}\n+    }\n+}\n+\n+fn main() {\n+    m::Pub::get_priv; //~ ERROR type `m::Priv` is private\n+    m::Pub::static_method; //~ ERROR type `m::Priv` is private\n+    ext::Pub::static_method; //~ ERROR type `ext::Priv` is private\n+}"}, {"sha": "fdd9166ef29997938b62f3560d578cb8602429c6", "filename": "src/test/compile-fail/private-inferred-type-3.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:private-inferred-type.rs\n+\n+// error-pattern:type `fn() {ext::priv_fn}` is private\n+// error-pattern:type `ext::PrivEnum` is private\n+// error-pattern:type `fn() {<u8 as ext::PrivTrait>::method}` is private\n+// error-pattern:type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct::{{constructor}}}` is pr\n+// error-pattern:type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct::{{constructor}}}` is priv\n+// error-pattern:type `fn(&ext::Pub<u8>) {<ext::Pub<u8>>::priv_method}` is private\n+\n+#![feature(decl_macro)]\n+\n+extern crate private_inferred_type as ext;\n+\n+fn main() {\n+    ext::m!();\n+}"}, {"sha": "140891027d5f0f7305c21141f69453d36e97b8e5", "filename": "src/test/compile-fail/private-inferred-type.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -0,0 +1,139 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+#![feature(conservative_impl_trait)]\n+#![feature(decl_macro)]\n+\n+mod m {\n+    fn priv_fn() {}\n+    enum PrivEnum { Variant }\n+    pub enum PubEnum { Variant }\n+    trait PrivTrait { fn method() {} }\n+    impl PrivTrait for u8 {}\n+    pub trait PubTrait { fn method() {} }\n+    impl PubTrait for u8 {}\n+    struct PrivTupleStruct(u8);\n+    pub struct PubTupleStruct(u8);\n+    impl PubTupleStruct { fn method() {} }\n+\n+    struct Priv;\n+    pub type Alias = Priv;\n+    pub struct Pub<T = Alias>(pub T);\n+\n+    impl Pub<Priv> {\n+        pub fn static_method() {}\n+        pub const INHERENT_ASSOC_CONST: u8 = 0;\n+    }\n+    impl<T> Pub<T> {\n+        pub fn static_method_generic_self() {}\n+        pub const INHERENT_ASSOC_CONST_GENERIC_SELF: u8 = 0;\n+    }\n+    impl Pub<u8> {\n+        fn priv_method(&self) {}\n+        pub fn method_with_substs<T>(&self) {}\n+        pub fn method_with_priv_params(&self, _: Priv) {}\n+    }\n+    impl TraitWithAssocConst for Priv {}\n+    impl TraitWithAssocTy for Priv { type AssocTy = u8; }\n+\n+    pub macro m() {\n+        priv_fn; //~ ERROR type `fn() {m::priv_fn}` is private\n+        PrivEnum::Variant; //~ ERROR type `m::PrivEnum` is private\n+        PubEnum::Variant; // OK\n+        <u8 as PrivTrait>::method; //~ ERROR type `fn() {<u8 as m::PrivTrait>::method}` is private\n+        <u8 as PubTrait>::method; // OK\n+        PrivTupleStruct;\n+        //~^ ERROR type `fn(u8) -> m::PrivTupleStruct {m::PrivTupleStruct::{{constructor}}}` is priv\n+        PubTupleStruct;\n+        //~^ ERROR type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct::{{constructor}}}` is privat\n+        Pub(0u8).priv_method();\n+        //~^ ERROR type `fn(&m::Pub<u8>) {<m::Pub<u8>>::priv_method}` is private\n+    }\n+\n+    trait Trait {}\n+    pub trait TraitWithTyParam<T> {}\n+    pub trait TraitWithTyParam2<T> { fn pub_method() {} }\n+    pub trait TraitWithAssocTy { type AssocTy; }\n+    pub trait TraitWithAssocConst { const TRAIT_ASSOC_CONST: u8 = 0; }\n+    impl Trait for u8 {}\n+    impl<T> TraitWithTyParam<T> for u8 {}\n+    impl TraitWithTyParam2<Priv> for u8 {}\n+    impl TraitWithAssocTy for u8 { type AssocTy = Priv; }\n+\n+    pub fn leak_anon1() -> impl Trait + 'static { 0 }\n+    pub fn leak_anon2() -> impl TraitWithTyParam<Alias> { 0 }\n+    pub fn leak_anon3() -> impl TraitWithAssocTy<AssocTy = Alias> { 0 }\n+\n+    pub fn leak_dyn1() -> Box<Trait + 'static> { Box::new(0) }\n+    pub fn leak_dyn2() -> Box<TraitWithTyParam<Alias>> { Box::new(0) }\n+    pub fn leak_dyn3() -> Box<TraitWithAssocTy<AssocTy = Alias>> { Box::new(0) }\n+}\n+\n+mod adjust {\n+    // Construct a chain of derefs with a private type in the middle\n+    use std::ops::Deref;\n+\n+    pub struct S1;\n+    struct S2;\n+    pub type S2Alias = S2;\n+    pub struct S3;\n+\n+    impl Deref for S1 {\n+        type Target = S2Alias;\n+        fn deref(&self) -> &Self::Target { loop {} }\n+    }\n+    impl Deref for S2 {\n+        type Target = S3;\n+        fn deref(&self) -> &Self::Target { loop {} }\n+    }\n+\n+    impl S3 {\n+        pub fn method_s3(&self) {}\n+    }\n+}\n+\n+fn main() {\n+    let _: m::Alias; //~ ERROR type `m::Priv` is private\n+    let _: <m::Alias as m::TraitWithAssocTy>::AssocTy; // FIXME\n+    m::Alias {}; //~ ERROR type `m::Priv` is private\n+    m::Pub { 0: m::Alias {} }; //~ ERROR type `m::Priv` is private\n+    m::Pub { 0: loop {} }; // FIXME\n+    m::Pub::static_method; //~ ERROR type `m::Priv` is private\n+    m::Pub::INHERENT_ASSOC_CONST; //~ ERROR type `m::Priv` is private\n+    m::Pub(0u8).method_with_substs::<m::Alias>(); //~ ERROR type `m::Priv` is private\n+    m::Pub(0u8).method_with_priv_params(loop{}); //~ ERROR type `m::Priv` is private\n+    <m::Alias as m::TraitWithAssocConst>::TRAIT_ASSOC_CONST; //~ ERROR type `m::Priv` is private\n+    <m::Pub<m::Alias>>::INHERENT_ASSOC_CONST; //~ ERROR type `m::Priv` is private\n+    <m::Pub<m::Alias>>::INHERENT_ASSOC_CONST_GENERIC_SELF; //~ ERROR type `m::Priv` is private\n+    <m::Pub<m::Alias>>::static_method_generic_self; //~ ERROR type `m::Priv` is private\n+    use m::TraitWithTyParam2;\n+    u8::pub_method; //~ ERROR type `m::Priv` is private\n+\n+    adjust::S1.method_s3(); //~ ERROR type `adjust::S2` is private\n+\n+    m::m!();\n+\n+    m::leak_anon1(); //~ ERROR trait `m::Trait` is private\n+    m::leak_anon2(); //~ ERROR type `m::Priv` is private\n+    m::leak_anon3(); //~ ERROR type `m::Priv` is private\n+\n+    m::leak_dyn1(); //~ ERROR type `m::Trait + 'static` is private\n+    m::leak_dyn2(); //~ ERROR type `m::Priv` is private\n+    m::leak_dyn3(); //~ ERROR type `m::Priv` is private\n+\n+    // Check that messages are not duplicated for various kinds of assignments\n+    let a = m::Alias {}; //~ ERROR type `m::Priv` is private\n+    let mut b = a; //~ ERROR type `m::Priv` is private\n+    b = a; //~ ERROR type `m::Priv` is private\n+    match a { //~ ERROR type `m::Priv` is private\n+        _ => {}\n+    }\n+}"}, {"sha": "925d692f8ae6bf3fa14ff3d7b9335e62b6142c84", "filename": "src/test/compile-fail/private-type-in-interface.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80b659d674fa19b2b48142e4f7974544bc8d5f6/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs?ref=b80b659d674fa19b2b48142e4f7974544bc8d5f6", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:private-inferred-type.rs\n+\n+#![feature(conservative_impl_trait)]\n+\n+extern crate private_inferred_type as ext;\n+\n+mod m {\n+    struct Priv;\n+    pub type Alias = Priv;\n+\n+    pub trait Trait { type X; }\n+    impl Trait for Priv { type X = u8; }\n+}\n+\n+fn f(_: m::Alias) {} //~ ERROR type `m::Priv` is private\n+                     //~^ ERROR type `m::Priv` is private\n+fn f_ext(_: ext::Alias) {} //~ ERROR type `ext::Priv` is private\n+                           //~^ ERROR type `ext::Priv` is private\n+\n+trait Tr1 {}\n+impl m::Alias {} //~ ERROR type `m::Priv` is private\n+impl Tr1 for ext::Alias {} //~ ERROR type `ext::Priv` is private\n+                           //~^ ERROR type `ext::Priv` is private\n+type A = <m::Alias as m::Trait>::X; //~ ERROR type `m::Priv` is private\n+\n+trait Tr2<T> {}\n+impl<T> Tr2<T> for u8 {}\n+fn g() -> impl Tr2<m::Alias> { 0 } //~ ERROR type `m::Priv` is private\n+fn g_ext() -> impl Tr2<ext::Alias> { 0 } //~ ERROR type `ext::Priv` is private\n+\n+fn main() {}"}]}