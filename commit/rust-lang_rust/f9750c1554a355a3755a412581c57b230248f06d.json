{"sha": "f9750c1554a355a3755a412581c57b230248f06d", "node_id": "C_kwDOAAsO6NoAKGY5NzUwYzE1NTRhMzU1YTM3NTVhNDEyNTgxYzU3YjIzMDI0OGYwNmQ", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-07-27T07:27:52Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-11-25T09:28:43Z"}, "message": "Add empty ConstKind::Abstract\n\nInitial pass at expr/abstract const/s\n\nAddress comments\n\nSwitch to using a list instead of &[ty::Const], rm `AbstractConst`\n\nRemove try_unify_abstract_consts\n\nUpdate comments\n\nAdd edits\n\nRecurse more\n\nMore edits\n\nPrevent equating associated consts\n\nMove failing test to ui\n\nChanges this test from incremental to ui, and mark it as failing and a known bug.\nDoes not cause the compiler to ICE, so should be ok.", "tree": {"sha": "f4c25eaeccc34e79cc0e711108592ca7d0fa1ce0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4c25eaeccc34e79cc0e711108592ca7d0fa1ce0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9750c1554a355a3755a412581c57b230248f06d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9750c1554a355a3755a412581c57b230248f06d", "html_url": "https://github.com/rust-lang/rust/commit/f9750c1554a355a3755a412581c57b230248f06d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9750c1554a355a3755a412581c57b230248f06d/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41e0363055ade59584cff667c79f64937e6ef3f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/41e0363055ade59584cff667c79f64937e6ef3f9", "html_url": "https://github.com/rust-lang/rust/commit/41e0363055ade59584cff667c79f64937e6ef3f9"}], "stats": {"total": 1615, "additions": 837, "deletions": 778}, "files": [{"sha": "6619a40b08567c575918ac9f9ae11cddf569089a", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -561,6 +561,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Param(_) | ty::ConstKind::Placeholder(..) => {\n                 throw_inval!(TooGeneric)\n             }\n+            ty::ConstKind::Expr(_) => throw_inval!(TooGeneric),\n             ty::ConstKind::Error(reported) => {\n                 throw_inval!(AlreadyReported(reported))\n             }"}, {"sha": "2754a9a05bce03356160b572a6d5d3b488427550", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -193,6 +193,18 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                     ty::PredicateKind::ConstEvaluatable(a),\n                     ty::PredicateKind::ConstEvaluatable(b),\n                 ) => relator.relate(predicate.rebind(a), predicate.rebind(b)).is_ok(),\n+                /*\n+                ) => {\n+                    if let (Ok(Some(a)), Ok(Some(b))) = (\n+                        tcx.expand_bound_abstract_const(tcx.bound_abstract_const(a.def), a.substs),\n+                        tcx.expand_bound_abstract_const(tcx.bound_abstract_const(b.def), b.substs),\n+                    ) && a.ty() == b.ty() {\n+                        return relator.relate(a, b).is_ok();\n+                    } else {\n+                        false\n+                    }\n+                }\n+                */\n                 (\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, lt_a)),\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_b, lt_b)),"}, {"sha": "27a94ec5e30e105cea6c5fe923344c0086d758e2", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -248,6 +248,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ConstKind::Param(_)\n             | ty::ConstKind::Value(_)\n             | ty::ConstKind::Unevaluated(..)\n+            | ty::ConstKind::Expr(..)\n             | ty::ConstKind::Error(_) => ct.super_fold_with(self),\n         }\n     }"}, {"sha": "06df1dc3a8e1c3717f540fe91423a5b18d64b6ef", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -23,7 +23,6 @@ use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKin\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::select;\n-use rustc_middle::ty::abstract_const::{AbstractConst, FailureKind};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::BoundVarReplacerDelegate;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -713,32 +712,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         TypeErrCtxt { infcx: self, typeck_results: None, fallback_has_occurred: false }\n     }\n \n-    /// calls `tcx.try_unify_abstract_consts` after\n-    /// canonicalizing the consts.\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn try_unify_abstract_consts(\n-        &self,\n-        a: ty::UnevaluatedConst<'tcx>,\n-        b: ty::UnevaluatedConst<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        // Reject any attempt to unify two unevaluated constants that contain inference\n-        // variables, since inference variables in queries lead to ICEs.\n-        if a.substs.has_non_region_infer()\n-            || b.substs.has_non_region_infer()\n-            || param_env.has_non_region_infer()\n-        {\n-            debug!(\"a or b or param_env contain infer vars in its substs -> cannot unify\");\n-            return false;\n-        }\n-\n-        let param_env_and = param_env.and((a, b));\n-        let erased = self.tcx.erase_regions(param_env_and);\n-        debug!(\"after erase_regions: {:?}\", erased);\n-\n-        self.tcx.try_unify_abstract_consts(erased)\n-    }\n-\n     pub fn is_in_snapshot(&self) -> bool {\n         self.in_snapshot.get()\n     }\n@@ -1646,34 +1619,39 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         // Postpone the evaluation of constants whose substs depend on inference\n         // variables\n+        let tcx = self.tcx;\n         if substs.has_non_region_infer() {\n-            let ac = AbstractConst::new(self.tcx, unevaluated);\n+            let substs_erased = tcx.erase_regions(unevaluated.substs);\n+            let ac = tcx.expand_bound_abstract_const(\n+                tcx.bound_abstract_const(unevaluated.def),\n+                substs_erased,\n+            );\n             match ac {\n                 Ok(None) => {\n-                    substs = InternalSubsts::identity_for_item(self.tcx, unevaluated.def.did);\n+                    substs = InternalSubsts::identity_for_item(tcx, unevaluated.def.did);\n                     param_env = self.tcx.param_env(unevaluated.def.did);\n                 }\n                 Ok(Some(ct)) => {\n-                    if ct.unify_failure_kind(self.tcx) == FailureKind::Concrete {\n-                        substs = replace_param_and_infer_substs_with_placeholder(self.tcx, substs);\n-                    } else {\n+                    if ct.has_non_region_infer() || ct.has_non_region_param() {\n                         return Err(ErrorHandled::TooGeneric);\n+                    } else {\n+                        substs = replace_param_and_infer_substs_with_placeholder(tcx, substs);\n                     }\n                 }\n                 Err(guar) => return Err(ErrorHandled::Reported(guar)),\n             }\n         }\n \n-        let param_env_erased = self.tcx.erase_regions(param_env);\n-        let substs_erased = self.tcx.erase_regions(substs);\n+        let param_env_erased = tcx.erase_regions(param_env);\n+        let substs_erased = tcx.erase_regions(substs);\n         debug!(?param_env_erased);\n         debug!(?substs_erased);\n \n         let unevaluated = ty::UnevaluatedConst { def: unevaluated.def, substs: substs_erased };\n \n         // The return value is the evaluated value which doesn't contain any reference to inference\n         // variables, thus we don't need to substitute back the original values.\n-        self.tcx.const_eval_resolve_for_typeck(param_env_erased, unevaluated, span)\n+        tcx.const_eval_resolve_for_typeck(param_env_erased, unevaluated, span)\n     }\n \n     /// `ty_or_const_infer_var_changed` is equivalent to one of these two:"}, {"sha": "3fae6694add0a02766b5594514d594ac7bda3715", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -644,12 +644,6 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Symbol {\n     }\n }\n \n-impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [ty::abstract_const::Node<'tcx>] {\n-    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {\n-        ty::codec::RefDecodable::decode(d)\n-    }\n-}\n-\n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {\n         ty::codec::RefDecodable::decode(d)"}, {"sha": "c51b8f96c715191cd96d648c267d88b0793995dd", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -366,7 +366,7 @@ define_tables! {\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n     // FIXME(compiler-errors): Why isn't this a LazyArray?\n-    thir_abstract_const: Table<DefIndex, LazyValue<&'static [ty::abstract_const::Node<'static>]>>,\n+    thir_abstract_const: Table<DefIndex, LazyValue<ty::Const<'static>>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     constness: Table<DefIndex, hir::Constness>,"}, {"sha": "1cac656674d697a407dcb858cfe7967338c533e1", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -476,6 +476,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n                     // These variants shouldn't exist in the MIR.\n                     ty::ConstKind::Placeholder(_)\n                     | ty::ConstKind::Infer(_)\n+                    | ty::ConstKind::Expr(_)\n                     | ty::ConstKind::Bound(..) => bug!(\"unexpected MIR constant: {:?}\", literal),\n                 },\n                 ConstantKind::Unevaluated(uv, _) => {"}, {"sha": "f2030b91b9b65e679cfe1b12d16b5d888c00381b", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -1185,15 +1185,17 @@ pub enum NullOp {\n     AlignOf,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(HashStable, TyEncodable, TyDecodable, TypeFoldable, TypeVisitable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n     Not,\n     /// The `-` operator for negation\n     Neg,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Ord, Eq, Hash)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub enum BinOp {\n     /// The `+` operator (addition)\n     Add,"}, {"sha": "0705b4cff53ad788c76c95a8654eac8bfbc8575a", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -16,9 +16,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     UserTypeAnnotationIndex,\n     BorrowKind,\n     CastKind,\n-    BinOp,\n     NullOp,\n-    UnOp,\n     hir::Movability,\n     BasicBlock,\n     SwitchTargets,"}, {"sha": "36cdb50958caaa1ffbfee0f6982ed45efca3585e", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -400,7 +400,7 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const(\n         key: DefId\n-    ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n         desc {\n             |tcx| \"building an abstract representation for `{}`\", tcx.def_path_str(key),\n         }\n@@ -409,23 +409,14 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const_of_const_arg(\n         key: (LocalDefId, DefId)\n-    ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n         desc {\n             |tcx|\n             \"building an abstract representation for the const argument `{}`\",\n             tcx.def_path_str(key.0.to_def_id()),\n         }\n     }\n \n-    query try_unify_abstract_consts(key:\n-        ty::ParamEnvAnd<'tcx, (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>\n-    )>) -> bool {\n-        desc {\n-            |tcx| \"trying to unify the generic constants `{}` and `{}`\",\n-            tcx.def_path_str(key.value.0.def.did), tcx.def_path_str(key.value.1.def.did)\n-        }\n-    }\n-\n     query mir_drops_elaborated_and_const_checked(\n         key: ty::WithOptConstParam<LocalDefId>\n     ) -> &'tcx Steal<mir::Body<'tcx>> {"}, {"sha": "8a8c46d6f216e87d8000860a641a3955297635bc", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 58, "deletions": 149, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -1,115 +1,17 @@\n //! A subset of a mir body used for const evaluatability checking.\n-use crate::mir;\n-use crate::ty::visit::TypeVisitable;\n-use crate::ty::{self, EarlyBinder, SubstsRef, Ty, TyCtxt};\n+use crate::ty::{self, Const, EarlyBinder, FallibleTypeFolder, GenericArg, TyCtxt, TypeFoldable};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n-use std::cmp;\n-use std::ops::ControlFlow;\n \n-rustc_index::newtype_index! {\n-    /// An index into an `AbstractConst`.\n-    pub struct NodeId {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"n{}\",\n-    }\n-}\n-\n-/// A tree representing an anonymous constant.\n-///\n-/// This is only able to represent a subset of `MIR`,\n-/// and should not leak any information about desugarings.\n-#[derive(Debug, Clone, Copy)]\n-pub struct AbstractConst<'tcx> {\n-    // FIXME: Consider adding something like `IndexSlice`\n-    // and use this here.\n-    inner: &'tcx [Node<'tcx>],\n-    substs: SubstsRef<'tcx>,\n-}\n-\n-impl<'tcx> AbstractConst<'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        uv: ty::UnevaluatedConst<'tcx>,\n-    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n-        let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n-        debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n-        Ok(inner.map(|inner| AbstractConst { inner, substs: tcx.erase_regions(uv.substs) }))\n-    }\n-\n-    pub fn from_const(\n-        tcx: TyCtxt<'tcx>,\n-        ct: ty::Const<'tcx>,\n-    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n-        match ct.kind() {\n-            ty::ConstKind::Unevaluated(uv) => AbstractConst::new(tcx, uv),\n-            ty::ConstKind::Error(reported) => Err(reported),\n-            _ => Ok(None),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n-        AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n-    }\n-\n-    #[inline]\n-    pub fn root(self, tcx: TyCtxt<'tcx>) -> Node<'tcx> {\n-        let node = self.inner.last().copied().unwrap();\n-        match node {\n-            Node::Leaf(leaf) => Node::Leaf(EarlyBinder(leaf).subst(tcx, self.substs)),\n-            Node::Cast(kind, operand, ty) => {\n-                Node::Cast(kind, operand, EarlyBinder(ty).subst(tcx, self.substs))\n-            }\n-            // Don't perform substitution on the following as they can't directly contain generic params\n-            Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => node,\n-        }\n-    }\n-\n-    pub fn unify_failure_kind(self, tcx: TyCtxt<'tcx>) -> FailureKind {\n-        let mut failure_kind = FailureKind::Concrete;\n-        walk_abstract_const::<!, _>(tcx, self, |node| {\n-            match node.root(tcx) {\n-                Node::Leaf(leaf) => {\n-                    if leaf.has_non_region_infer() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if leaf.has_non_region_param() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-                }\n-                Node::Cast(_, _, ty) => {\n-                    if ty.has_non_region_infer() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if ty.has_non_region_param() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-                }\n-                Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {}\n-            }\n-            ControlFlow::CONTINUE\n-        });\n-        failure_kind\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Hash, Debug, Clone, Copy, Ord, PartialOrd, PartialEq, Eq)]\n+#[derive(TyDecodable, TyEncodable, HashStable, TypeVisitable, TypeFoldable)]\n pub enum CastKind {\n     /// thir::ExprKind::As\n     As,\n     /// thir::ExprKind::Use\n     Use,\n }\n \n-/// A node of an `AbstractConst`.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum Node<'tcx> {\n-    Leaf(ty::Const<'tcx>),\n-    Binop(mir::BinOp, NodeId, NodeId),\n-    UnaryOp(mir::UnOp, NodeId),\n-    FunctionCall(NodeId, &'tcx [NodeId]),\n-    Cast(CastKind, NodeId, Ty<'tcx>),\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n pub enum NotConstEvaluatable {\n     Error(ErrorGuaranteed),\n@@ -127,68 +29,75 @@ TrivialTypeTraversalAndLiftImpls! {\n     NotConstEvaluatable,\n }\n \n+pub type BoundAbstractConst<'tcx> = Result<Option<EarlyBinder<ty::Const<'tcx>>>, ErrorGuaranteed>;\n+\n impl<'tcx> TyCtxt<'tcx> {\n+    /// Returns a const with substs applied by\n+    pub fn bound_abstract_const(\n+        self,\n+        uv: ty::WithOptConstParam<DefId>,\n+    ) -> BoundAbstractConst<'tcx> {\n+        self.thir_abstract_const_opt_const_arg(uv).map(|ac| ac.map(|ac| EarlyBinder(ac)))\n+    }\n     #[inline]\n     pub fn thir_abstract_const_opt_const_arg(\n         self,\n         def: ty::WithOptConstParam<DefId>,\n-    ) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n         if let Some((did, param_did)) = def.as_const_arg() {\n             self.thir_abstract_const_of_const_arg((did, param_did))\n         } else {\n             self.thir_abstract_const(def.did)\n         }\n     }\n-}\n \n-#[instrument(skip(tcx, f), level = \"debug\")]\n-pub fn walk_abstract_const<'tcx, R, F>(\n-    tcx: TyCtxt<'tcx>,\n-    ct: AbstractConst<'tcx>,\n-    mut f: F,\n-) -> ControlFlow<R>\n-where\n-    F: FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n-{\n-    #[instrument(skip(tcx, f), level = \"debug\")]\n-    fn recurse<'tcx, R>(\n-        tcx: TyCtxt<'tcx>,\n-        ct: AbstractConst<'tcx>,\n-        f: &mut dyn FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n-    ) -> ControlFlow<R> {\n-        f(ct)?;\n-        let root = ct.root(tcx);\n-        debug!(?root);\n-        match root {\n-            Node::Leaf(_) => ControlFlow::CONTINUE,\n-            Node::Binop(_, l, r) => {\n-                recurse(tcx, ct.subtree(l), f)?;\n-                recurse(tcx, ct.subtree(r), f)\n+    pub fn expand_bound_abstract_const(\n+        self,\n+        ct: BoundAbstractConst<'tcx>,\n+        substs: &[GenericArg<'tcx>],\n+    ) -> Result<Option<Const<'tcx>>, ErrorGuaranteed> {\n+        struct Expander<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n+        }\n+        impl<'tcx> FallibleTypeFolder<'tcx> for Expander<'tcx> {\n+            type Error = ErrorGuaranteed;\n+            fn tcx(&self) -> TyCtxt<'tcx> {\n+                self.tcx\n             }\n-            Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n-            Node::FunctionCall(func, args) => {\n-                recurse(tcx, ct.subtree(func), f)?;\n-                args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n+            fn try_fold_const(&mut self, c: Const<'tcx>) -> Result<Const<'tcx>, ErrorGuaranteed> {\n+                use ty::ConstKind::*;\n+                let uv = match c.kind() {\n+                    Unevaluated(uv) => uv,\n+                    Param(..) | Infer(..) | Bound(..) | Placeholder(..) | Value(..) | Error(..) => {\n+                        return Ok(c);\n+                    }\n+                    Expr(e) => {\n+                        let new_expr = match e {\n+                            ty::Expr::Binop(op, l, r) => {\n+                                ty::Expr::Binop(op, l.try_fold_with(self)?, r.try_fold_with(self)?)\n+                            }\n+                            ty::Expr::UnOp(op, v) => ty::Expr::UnOp(op, v.try_fold_with(self)?),\n+                            ty::Expr::Cast(k, c, t) => {\n+                                ty::Expr::Cast(k, c.try_fold_with(self)?, t.try_fold_with(self)?)\n+                            }\n+                            ty::Expr::FunctionCall(func, args) => ty::Expr::FunctionCall(\n+                                func.try_fold_with(self)?,\n+                                args.try_fold_with(self)?,\n+                            ),\n+                        };\n+                        return Ok(self.tcx().mk_const(ty::ConstKind::Expr(new_expr), c.ty()));\n+                    }\n+                };\n+                let bac = self.tcx.bound_abstract_const(uv.def);\n+                let ac = self.tcx.expand_bound_abstract_const(bac, uv.substs);\n+                if let Ok(Some(ac)) = ac { ac.try_fold_with(self) } else { Ok(c) }\n             }\n-            Node::Cast(_, operand, _) => recurse(tcx, ct.subtree(operand), f),\n         }\n-    }\n \n-    recurse(tcx, ct, &mut f)\n-}\n-\n-// We were unable to unify the abstract constant with\n-// a constant found in the caller bounds, there are\n-// now three possible cases here.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub enum FailureKind {\n-    /// The abstract const still references an inference\n-    /// variable, in this case we return `TooGeneric`.\n-    MentionsInfer,\n-    /// The abstract const references a generic parameter,\n-    /// this means that we emit an error here.\n-    MentionsParam,\n-    /// The substs are concrete enough that we can simply\n-    /// try and evaluate the given constant.\n-    Concrete,\n+        let Some(ac) = ct? else {\n+            return Ok(None);\n+        };\n+        let ac = ac.subst(self, substs);\n+        Ok(Some(ac.try_fold_with(&mut Expander { tcx: self })?))\n+    }\n }"}, {"sha": "b22b3961f34ea9a93aa61a0831e88b1089beabcf", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -346,33 +346,22 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n }\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for [ty::abstract_const::Node<'tcx>]\n-{\n-    fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.interner().arena.alloc_from_iter(\n-            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n-        )\n-    }\n-}\n-\n-impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for [ty::abstract_const::NodeId]\n+    for ty::List<ty::BoundVariableKind>\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.interner().arena.alloc_from_iter(\n-            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n+        let len = decoder.read_usize();\n+        decoder.interner().mk_bound_variable_kinds(\n+            (0..len).map::<ty::BoundVariableKind, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for ty::List<ty::BoundVariableKind>\n-{\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for ty::List<ty::Const<'tcx>> {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.interner().mk_bound_variable_kinds(\n-            (0..len).map::<ty::BoundVariableKind, _>(|_| Decodable::decode(decoder)),\n-        )\n+        decoder\n+            .interner()\n+            .mk_const_list((0..len).map::<ty::Const<'tcx>, _>(|_| Decodable::decode(decoder)))\n     }\n }\n "}, {"sha": "de63dae8a3df6455eb311d18c3eef5b717535591", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -1,10 +1,12 @@\n use std::convert::TryInto;\n \n+use super::Const;\n use crate::mir;\n use crate::mir::interpret::{AllocId, ConstValue, Scalar};\n+use crate::ty::abstract_const::CastKind;\n use crate::ty::subst::{InternalSubsts, SubstsRef};\n use crate::ty::ParamEnv;\n-use crate::ty::{self, TyCtxt, TypeVisitable};\n+use crate::ty::{self, List, Ty, TyCtxt, TypeVisitable};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n@@ -70,8 +72,23 @@ pub enum ConstKind<'tcx> {\n     /// A placeholder for a const which could not be computed; this is\n     /// propagated to avoid useless error messages.\n     Error(ErrorGuaranteed),\n+\n+    /// Expr which contains an expression which has partially evaluated items.\n+    Expr(Expr<'tcx>),\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n+#[derive(HashStable, TyEncodable, TyDecodable, TypeVisitable, TypeFoldable)]\n+pub enum Expr<'tcx> {\n+    Binop(mir::BinOp, Const<'tcx>, Const<'tcx>),\n+    UnOp(mir::UnOp, Const<'tcx>),\n+    FunctionCall(Const<'tcx>, &'tcx List<Const<'tcx>>),\n+    Cast(CastKind, Const<'tcx>, Ty<'tcx>),\n }\n \n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(Expr<'_>, 24);\n+\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ConstKind<'_>, 32);\n "}, {"sha": "f627dc7ceb192f6b86dc133c1b46d99d4c71f40e", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -2714,6 +2714,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    pub fn mk_const_list<I: InternAs<[ty::Const<'tcx>], &'tcx List<ty::Const<'tcx>>>>(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n+        iter.intern_with(|xs| self.intern_const_list(xs))\n+    }\n+\n+    pub fn intern_const_list(self, cs: &[ty::Const<'tcx>]) -> &'tcx List<ty::Const<'tcx>> {\n+        if cs.is_empty() { List::empty() } else { List::from_arena(self.arena, cs) }\n+    }\n+\n     pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx List<Ty<'tcx>> {\n         if ts.is_empty() {\n             List::empty()"}, {"sha": "c9c09c93a3e1c470a9e94b68d6e8d2c7086f575c", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -356,7 +356,10 @@ impl DeepRejectCtxt {\n \n     pub fn consts_may_unify(self, obligation_ct: ty::Const<'_>, impl_ct: ty::Const<'_>) -> bool {\n         match impl_ct.kind() {\n-            ty::ConstKind::Param(_) | ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => {\n+            ty::ConstKind::Expr(_)\n+            | ty::ConstKind::Param(_)\n+            | ty::ConstKind::Unevaluated(_)\n+            | ty::ConstKind::Error(_) => {\n                 return true;\n             }\n             ty::ConstKind::Value(_) => {}\n@@ -374,7 +377,9 @@ impl DeepRejectCtxt {\n \n             // As we don't necessarily eagerly evaluate constants,\n             // they might unify with any value.\n-            ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => true,\n+            ty::ConstKind::Expr(_) | ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => {\n+                true\n+            }\n             ty::ConstKind::Value(obl) => match k {\n                 ty::ConstKind::Value(imp) => obl == imp,\n                 _ => true,"}, {"sha": "bbd050d7cae28c72845e64641e6381ba2e87d972", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -307,6 +307,26 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n             ty::ConstKind::Value(_) => {}\n+            ty::ConstKind::Expr(e) => {\n+                use ty::Expr;\n+                match e {\n+                    Expr::Binop(_, l, r) => {\n+                        self.add_const(l);\n+                        self.add_const(r);\n+                    }\n+                    Expr::UnOp(_, v) => self.add_const(v),\n+                    Expr::FunctionCall(f, args) => {\n+                        self.add_const(f);\n+                        for arg in args {\n+                            self.add_const(arg);\n+                        }\n+                    }\n+                    Expr::Cast(_, c, t) => {\n+                        self.add_ty(t);\n+                        self.add_const(c);\n+                    }\n+                }\n+            }\n             ty::ConstKind::Error(_) => self.add_flags(TypeFlags::HAS_ERROR),\n         }\n     }"}, {"sha": "9928340d9217198009f845dab0d719566b55423b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -77,7 +77,7 @@ pub use self::closure::{\n     CAPTURE_STRUCT_LOCAL,\n };\n pub use self::consts::{\n-    Const, ConstInt, ConstKind, ConstS, InferConst, ScalarInt, UnevaluatedConst, ValTree,\n+    Const, ConstInt, ConstKind, ConstS, Expr, InferConst, ScalarInt, UnevaluatedConst, ValTree,\n };\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,"}, {"sha": "b2bcf0e29cd9d7578219c412eb249e2f9359e3bc", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -4,7 +4,6 @@ use rustc_index::vec::{Idx, IndexVec};\n \n use crate::middle::exported_symbols::ExportedSymbol;\n use crate::mir::Body;\n-use crate::ty::abstract_const::Node;\n use crate::ty::{\n     self, Const, FnSig, GeneratorDiagnosticData, GenericPredicates, Predicate, TraitRef, Ty,\n };\n@@ -124,6 +123,5 @@ parameterized_over_tcx! {\n     Predicate,\n     GeneratorDiagnosticData,\n     Body,\n-    Node,\n     ExportedSymbol,\n }"}, {"sha": "249004cbc5ca8e8d0dca70b00e89077f546f2fa2", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -1253,6 +1253,9 @@ pub trait PrettyPrinter<'tcx>:\n                 self.pretty_print_bound_var(debruijn, bound_var)?\n             }\n             ty::ConstKind::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n+            // FIXME(generic_const_exprs):\n+            // write out some legible representation of an abstract const?\n+            ty::ConstKind::Expr(_) => p!(\"[Const Expr]\"),\n             ty::ConstKind::Error(_) => p!(\"[const error]\"),\n         };\n         Ok(self)"}, {"sha": "4249decc88f46499b6556def0379daa87763793d", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -5,7 +5,7 @@\n //! subtyping, type equality, etc.\n \n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::ty::{self, ImplSubject, Term, TermKind, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, Expr, ImplSubject, Term, TermKind, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_hir as ast;\n use rustc_hir::def_id::DefId;\n@@ -613,7 +613,10 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     if a_ty != b_ty {\n         relation.tcx().sess.delay_span_bug(\n             DUMMY_SP,\n-            &format!(\"cannot relate constants of different types: {} != {}\", a_ty, b_ty),\n+            &format!(\n+                \"cannot relate constants ({:?}, {:?}) of different types: {} != {}\",\n+                a, b, a_ty, b_ty\n+            ),\n         );\n     }\n \n@@ -647,13 +650,21 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n             if tcx.features().generic_const_exprs =>\n         {\n-            tcx.try_unify_abstract_consts(relation.param_env().and((au, bu)))\n+            if let (Ok(Some(a)), Ok(Some(b))) = (\n+                tcx.expand_bound_abstract_const(tcx.bound_abstract_const(au.def), au.substs),\n+                tcx.expand_bound_abstract_const(tcx.bound_abstract_const(bu.def), bu.substs),\n+            ) && a.ty() == b.ty() {\n+                return relation.consts(a, b);\n+            } else {\n+                false\n+            }\n         }\n \n         // While this is slightly incorrect, it shouldn't matter for `min_const_generics`\n         // and is the better alternative to waiting until `generic_const_exprs` can\n         // be stabilized.\n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu)) if au.def == bu.def => {\n+            assert_eq!(a.ty(), b.ty());\n             let substs = relation.relate_with_variance(\n                 ty::Variance::Invariant,\n                 ty::VarianceDiagInfo::default(),\n@@ -665,6 +676,50 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n                 a.ty(),\n             ));\n         }\n+        // Before calling relate on exprs, it is necessary to ensure that the nested consts\n+        // have identical types.\n+        (ty::ConstKind::Expr(ae), ty::ConstKind::Expr(be)) => {\n+            let r = relation;\n+\n+            // FIXME(julianknodt): is it possible to relate two consts which are not identical\n+            // exprs? Should we care about that?\n+            let expr = match (ae, be) {\n+                (Expr::Binop(a_op, al, ar), Expr::Binop(b_op, bl, br))\n+                    if a_op == b_op && al.ty() == bl.ty() && ar.ty() == br.ty() =>\n+                {\n+                    Expr::Binop(a_op, r.consts(al, bl)?, r.consts(ar, br)?)\n+                }\n+                (Expr::UnOp(a_op, av), Expr::UnOp(b_op, bv))\n+                    if a_op == b_op && av.ty() == bv.ty() =>\n+                {\n+                    Expr::UnOp(a_op, r.consts(av, bv)?)\n+                }\n+                (Expr::Cast(ak, av, at), Expr::Cast(bk, bv, bt))\n+                    if ak == bk && av.ty() == bv.ty() =>\n+                {\n+                    Expr::Cast(ak, r.consts(av, bv)?, r.tys(at, bt)?)\n+                }\n+                (Expr::FunctionCall(af, aa), Expr::FunctionCall(bf, ba))\n+                    if aa.len() == ba.len()\n+                        && af.ty() == bf.ty()\n+                        && aa\n+                            .iter()\n+                            .zip(ba.iter())\n+                            .all(|(a_arg, b_arg)| a_arg.ty() == b_arg.ty()) =>\n+                {\n+                    let func = r.consts(af, bf)?;\n+                    let mut related_args = Vec::with_capacity(aa.len());\n+                    for (a_arg, b_arg) in aa.iter().zip(ba.iter()) {\n+                        related_args.push(r.consts(a_arg, b_arg)?);\n+                    }\n+                    let related_args = tcx.mk_const_list(related_args.iter());\n+                    Expr::FunctionCall(func, related_args)\n+                }\n+                _ => return Err(TypeError::ConstMismatch(expected_found(r, a, b))),\n+            };\n+            let kind = ty::ConstKind::Expr(expr);\n+            return Ok(tcx.mk_const(kind, a.ty()));\n+        }\n         _ => false,\n     };\n     if is_match { Ok(a) } else { Err(TypeError::ConstMismatch(expected_found(relation, a, b))) }"}, {"sha": "7726ab8e5abb251ceff902f80ca211f5ef792e3c", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -593,6 +593,12 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::PolyExistentialPredicate<'t\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Const<'tcx>> {\n+    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        ty::util::fold_list(self, folder, |tcx, v| tcx.mk_const_list(v.iter()))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_projs(v))"}, {"sha": "4fab5abe909d40c39042aee829a86bff88e51f7b", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -214,6 +214,24 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 | ty::ConstKind::Value(_)\n                 | ty::ConstKind::Error(_) => {}\n \n+                ty::ConstKind::Expr(expr) => match expr {\n+                    ty::Expr::UnOp(_, v) => push_inner(stack, v.into()),\n+                    ty::Expr::Binop(_, l, r) => {\n+                        push_inner(stack, r.into());\n+                        push_inner(stack, l.into())\n+                    }\n+                    ty::Expr::FunctionCall(func, args) => {\n+                        for a in args.iter().rev() {\n+                            push_inner(stack, a.into());\n+                        }\n+                        push_inner(stack, func.into());\n+                    }\n+                    ty::Expr::Cast(_, c, t) => {\n+                        push_inner(stack, t.into());\n+                        push_inner(stack, c.into());\n+                    }\n+                },\n+\n                 ty::ConstKind::Unevaluated(ct) => {\n                     stack.extend(ct.substs.iter().rev());\n                 }"}, {"sha": "580a9eb091c6cb7227749509656f1896332046e4", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -3,6 +3,7 @@\n #![feature(control_flow_enum)]\n #![feature(rustc_private)]\n #![feature(try_blocks)]\n+#![feature(let_chains)]\n #![recursion_limit = \"256\"]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n@@ -25,7 +26,6 @@ use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n use rustc_middle::span_bug;\n-use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst, Node as ACNode};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Const, DefIdTree, GenericParamDefKind};\n@@ -286,17 +286,15 @@ where\n     fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         self.visit_ty(c.ty())?;\n         let tcx = self.def_id_visitor.tcx();\n-        if let Ok(Some(ct)) = AbstractConst::from_const(tcx, c) {\n-            walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n-                ACNode::Leaf(leaf) => self.visit_const(leaf),\n-                ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n-                ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {\n-                    ControlFlow::CONTINUE\n-                }\n-            })\n-        } else {\n-            ControlFlow::CONTINUE\n+        if let ty::ConstKind::Unevaluated(uv) = c.kind() &&\n+           let Ok(Some(ct)) = tcx.expand_bound_abstract_const(tcx.bound_abstract_const(uv.def),\n+           uv.substs) {\n+            ct.visit_with(self)?;\n         }\n+        if let ty::ConstKind::Expr(e) = c.kind() {\n+            e.visit_with(self)?;\n+        }\n+        ControlFlow::CONTINUE\n     }\n }\n "}, {"sha": "c61d2a9c2d0c6f713407c4af0f31bd055054f415", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -812,12 +812,6 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     }\n }\n \n-impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [ty::abstract_const::Node<'tcx>] {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n-        RefDecodable::decode(d)\n-    }\n-}\n-\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)"}, {"sha": "b6378af7ba09c5693fa621282b2f3dc6b7f2351b", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -575,6 +575,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n             // a path), even for it we still need to encode a placeholder, as\n             // the path could refer back to e.g. an `impl` using the constant.\n             ty::ConstKind::Unevaluated(_)\n+            | ty::ConstKind::Expr(_)\n             | ty::ConstKind::Param(_)\n             | ty::ConstKind::Infer(_)\n             | ty::ConstKind::Bound(..)"}, {"sha": "284ec6b5e3a25f4da095c3d388025ba82096eec6", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 64, "deletions": 171, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -8,152 +8,15 @@\n //! In this case we try to build an abstract representation of this constant using\n //! `thir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n-use rustc_errors::ErrorGuaranteed;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::ty::abstract_const::{\n-    walk_abstract_const, AbstractConst, FailureKind, Node, NotConstEvaluatable,\n-};\n-use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n-use rustc_span::Span;\n-\n-use std::iter;\n-use std::ops::ControlFlow;\n-\n-pub struct ConstUnifyCtxt<'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'tcx> ConstUnifyCtxt<'tcx> {\n-    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n-    // ConstKind::Unevaluated could be turned into an AbstractConst that would unify e.g.\n-    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n-    #[inline]\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn try_replace_substs_in_root(\n-        &self,\n-        mut abstr_const: AbstractConst<'tcx>,\n-    ) -> Option<AbstractConst<'tcx>> {\n-        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n-            match AbstractConst::from_const(self.tcx, ct) {\n-                Ok(Some(act)) => abstr_const = act,\n-                Ok(None) => break,\n-                Err(_) => return None,\n-            }\n-        }\n-\n-        Some(abstr_const)\n-    }\n-\n-    /// Tries to unify two abstract constants using structural equality.\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n-        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n-            a\n-        } else {\n-            return true;\n-        };\n-\n-        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n-            b\n-        } else {\n-            return true;\n-        };\n \n-        let a_root = a.root(self.tcx);\n-        let b_root = b.root(self.tcx);\n-        debug!(?a_root, ?b_root);\n+use rustc_middle::traits::ObligationCause;\n+use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n+use rustc_middle::ty::{self, TyCtxt, TypeVisitable, TypeVisitor};\n \n-        match (a_root, b_root) {\n-            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n-                let a_ct = a_ct.eval(self.tcx, self.param_env);\n-                debug!(\"a_ct evaluated: {:?}\", a_ct);\n-                let b_ct = b_ct.eval(self.tcx, self.param_env);\n-                debug!(\"b_ct evaluated: {:?}\", b_ct);\n-\n-                if a_ct.ty() != b_ct.ty() {\n-                    return false;\n-                }\n-\n-                match (a_ct.kind(), b_ct.kind()) {\n-                    // We can just unify errors with everything to reduce the amount of\n-                    // emitted errors here.\n-                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n-                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n-                        a_param == b_param\n-                    }\n-                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n-                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n-                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n-                    // means that we only allow inference variables if they are equal.\n-                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n-                    // We expand generic anonymous constants at the start of this function, so this\n-                    // branch should only be taking when dealing with associated constants, at\n-                    // which point directly comparing them seems like the desired behavior.\n-                    //\n-                    // FIXME(generic_const_exprs): This isn't actually the case.\n-                    // We also take this branch for concrete anonymous constants and\n-                    // expand generic anonymous constants with concrete substs.\n-                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n-                        a_uv == b_uv\n-                    }\n-                    // FIXME(generic_const_exprs): We may want to either actually try\n-                    // to evaluate `a_ct` and `b_ct` if they are fully concrete or something like\n-                    // this, for now we just return false here.\n-                    _ => false,\n-                }\n-            }\n-            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n-                self.try_unify(a.subtree(al), b.subtree(bl))\n-                    && self.try_unify(a.subtree(ar), b.subtree(br))\n-            }\n-            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n-                self.try_unify(a.subtree(av), b.subtree(bv))\n-            }\n-            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n-                if a_args.len() == b_args.len() =>\n-            {\n-                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n-                    && iter::zip(a_args, b_args)\n-                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n-            }\n-            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n-                if (a_ty == b_ty) && (a_kind == b_kind) =>\n-            {\n-                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n-            }\n-            // use this over `_ => false` to make adding variants to `Node` less error prone\n-            (Node::Cast(..), _)\n-            | (Node::FunctionCall(..), _)\n-            | (Node::UnaryOp(..), _)\n-            | (Node::Binop(..), _)\n-            | (Node::Leaf(..), _) => false,\n-        }\n-    }\n-}\n-\n-#[instrument(skip(tcx), level = \"debug\")]\n-pub fn try_unify_abstract_consts<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (a, b): (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>),\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> bool {\n-    (|| {\n-        if let Some(a) = AbstractConst::new(tcx, a)? {\n-            if let Some(b) = AbstractConst::new(tcx, b)? {\n-                let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n-                return Ok(const_unify_ctxt.try_unify(a, b));\n-            }\n-        }\n-\n-        Ok(false)\n-    })()\n-    .unwrap_or_else(|_: ErrorGuaranteed| true)\n-    // FIXME(generic_const_exprs): We should instead have this\n-    // method return the resulting `ty::Const` and return `ConstKind::Error`\n-    // on `ErrorGuaranteed`.\n-}\n+use rustc_span::Span;\n+use std::ops::ControlFlow;\n \n /// Check if a given constant can be evaluated.\n #[instrument(skip(infcx), level = \"debug\")]\n@@ -166,6 +29,8 @@ pub fn is_const_evaluatable<'tcx>(\n     let tcx = infcx.tcx;\n     let uv = match ct.kind() {\n         ty::ConstKind::Unevaluated(uv) => uv,\n+        // should be recursivee fixes.\n+        ty::ConstKind::Expr(..) => todo!(),\n         ty::ConstKind::Param(_)\n         | ty::ConstKind::Bound(_, _)\n         | ty::ConstKind::Placeholder(_)\n@@ -175,19 +40,17 @@ pub fn is_const_evaluatable<'tcx>(\n     };\n \n     if tcx.features().generic_const_exprs {\n-        if let Some(ct) = AbstractConst::new(tcx, uv)? {\n-            if satisfied_from_param_env(tcx, ct, param_env)? {\n+        let substs = tcx.erase_regions(uv.substs);\n+        if let Some(ct) =\n+            tcx.expand_bound_abstract_const(tcx.bound_abstract_const(uv.def), substs)?\n+        {\n+            if satisfied_from_param_env(tcx, infcx, ct, param_env)? {\n                 return Ok(());\n             }\n-            match ct.unify_failure_kind(tcx) {\n-                FailureKind::MentionsInfer => {\n-                    return Err(NotConstEvaluatable::MentionsInfer);\n-                }\n-                FailureKind::MentionsParam => {\n-                    return Err(NotConstEvaluatable::MentionsParam);\n-                }\n-                // returned below\n-                FailureKind::Concrete => {}\n+            if ct.has_non_region_infer() {\n+                return Err(NotConstEvaluatable::MentionsInfer);\n+            } else if ct.has_non_region_param() {\n+                return Err(NotConstEvaluatable::MentionsParam);\n             }\n         }\n         let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n@@ -212,13 +75,16 @@ pub fn is_const_evaluatable<'tcx>(\n         // See #74595 for more details about this.\n         let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n \n+        let substs = tcx.erase_regions(uv.substs);\n         match concrete {\n           // If we're evaluating a foreign constant, under a nightly compiler without generic\n           // const exprs, AND it would've passed if that expression had been evaluated with\n           // generic const exprs, then suggest using generic const exprs.\n           Err(_) if tcx.sess.is_nightly_build()\n-            && let Ok(Some(ct)) = AbstractConst::new(tcx, uv)\n-            && satisfied_from_param_env(tcx, ct, param_env) == Ok(true) => {\n+            && let Ok(Some(ct)) =\n+            tcx.expand_bound_abstract_const(tcx.bound_abstract_const(uv.def), substs)\n+            && let ty::ConstKind::Expr(_expr) = ct.kind()\n+            && satisfied_from_param_env(tcx, infcx, ct, param_env) == Ok(true) => {\n               tcx.sess\n                   .struct_span_fatal(\n                       // Slightly better span than just using `span` alone\n@@ -253,33 +119,60 @@ pub fn is_const_evaluatable<'tcx>(\n     }\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n+#[instrument(skip(infcx, tcx), level = \"debug\")]\n fn satisfied_from_param_env<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    ct: AbstractConst<'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n+    ct: ty::Const<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> Result<bool, NotConstEvaluatable> {\n     for pred in param_env.caller_bounds() {\n         match pred.kind().skip_binder() {\n             ty::PredicateKind::ConstEvaluatable(uv) => {\n-                if let Some(b_ct) = AbstractConst::from_const(tcx, uv)? {\n-                    let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n+                let ty::ConstKind::Unevaluated(uv) = uv.kind() else {\n+                    continue\n+                };\n+                let substs = tcx.erase_regions(uv.substs);\n+                let Some(b_ct) =\n+                tcx.expand_bound_abstract_const(tcx.bound_abstract_const(uv.def), substs)? else {\n+                    return Ok(false);\n+                };\n \n-                    // Try to unify with each subtree in the AbstractConst to allow for\n-                    // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n-                    // predicate for `(N + 1) * 2`\n-                    let result = walk_abstract_const(tcx, b_ct, |b_ct| {\n-                        match const_unify_ctxt.try_unify(ct, b_ct) {\n-                            true => ControlFlow::BREAK,\n-                            false => ControlFlow::CONTINUE,\n-                        }\n-                    });\n+                // Try to unify with each subtree in the AbstractConst to allow for\n+                // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n+                // predicate for `(N + 1) * 2`\n+                struct Visitor<'a, 'tcx> {\n+                    ct: ty::Const<'tcx>,\n+                    param_env: ty::ParamEnv<'tcx>,\n \n-                    if let ControlFlow::Break(()) = result {\n-                        debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n-                        return Ok(true);\n+                    infcx: &'a InferCtxt<'tcx>,\n+                }\n+                impl<'a, 'tcx> TypeVisitor<'tcx> for Visitor<'a, 'tcx> {\n+                    type BreakTy = ();\n+                    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                        if c.ty() == self.ct.ty()\n+                            && let Ok(_nested_obligations) = self\n+                                .infcx\n+                                .at(&ObligationCause::dummy(), self.param_env)\n+                                .eq(c, self.ct)\n+                        {\n+                            //let obligations = nested_obligations.into_obligations();\n+                            ControlFlow::BREAK\n+                        } else if let ty::ConstKind::Expr(e) = c.kind() {\n+                            e.visit_with(self)\n+                        } else {\n+                            ControlFlow::CONTINUE\n+                        }\n                     }\n                 }\n+\n+                let mut v = Visitor { ct, infcx, param_env };\n+                let result = b_ct.visit_with(&mut v);\n+\n+                if let ControlFlow::Break(()) = result {\n+                    debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n+                    return Ok(true);\n+                }\n             }\n             _ => {} // don't care\n         }"}, {"sha": "652bbeeeffbedd9e0685fccbe3d49533e984305c", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -3,6 +3,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n+use rustc_hir::def::DefKind;\n use rustc_infer::traits::ProjectionCacheKey;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n@@ -452,21 +453,49 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::ConstEquate(c1, c2) => {\n+                    let tcx = self.selcx.tcx();\n                     assert!(\n-                        self.selcx.tcx().features().generic_const_exprs,\n+                        tcx.features().generic_const_exprs,\n                         \"`ConstEquate` without a feature gate: {c1:?} {c2:?}\",\n                     );\n                     debug!(?c1, ?c2, \"equating consts\");\n                     // FIXME: we probably should only try to unify abstract constants\n                     // if the constants depend on generic parameters.\n                     //\n                     // Let's just see where this breaks :shrug:\n-                    if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n-                        (c1.kind(), c2.kind())\n-                    {\n-                        if infcx.try_unify_abstract_consts(a, b, obligation.param_env) {\n-                            return ProcessResult::Changed(vec![]);\n+                    match (c1.kind(), c2.kind()) {\n+                        (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) => {\n+                            if tcx.def_kind(a.def.did) == DefKind::AssocConst\n+                                || tcx.def_kind(b.def.did) == DefKind::AssocConst\n+                            {\n+                                // Two different constants using generic parameters ~> error.\n+                                let expected_found = ExpectedFound::new(true, c1, c2);\n+                                return ProcessResult::Error(\n+                                    FulfillmentErrorCode::CodeConstEquateError(\n+                                        expected_found,\n+                                        TypeError::ConstMismatch(expected_found),\n+                                    ),\n+                                );\n+                            }\n+                            if let (Ok(Some(a)), Ok(Some(b))) = (\n+                                    tcx.expand_bound_abstract_const(\n+                                        tcx.bound_abstract_const(a.def),\n+                                        a.substs,\n+                                    ),\n+                                    tcx.expand_bound_abstract_const(\n+                                        tcx.bound_abstract_const(b.def),\n+                                        b.substs,\n+                                    ),\n+                                ) && a.ty() == b.ty() &&\n+                                  let Ok(new_obligations) = infcx\n+                                      .at(&obligation.cause, obligation.param_env)\n+                                      .eq(a, b) {\n+                                            return ProcessResult::Changed(mk_pending(\n+                                                new_obligations.into_obligations(),\n+                                            ));\n+                                }\n                         }\n+                        _ => {}\n                     }\n \n                     let stalled_on = &mut pending_obligation.stalled_on;"}, {"sha": "4df5308989057720fb6f63fde5e6248354c90ce3", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -929,10 +929,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n         is_impossible_method,\n-        try_unify_abstract_consts: |tcx, param_env_and| {\n-            let (param_env, (a, b)) = param_env_and.into_parts();\n-            const_evaluatable::try_unify_abstract_consts(tcx, (a, b), param_env)\n-        },\n         ..*providers\n     };\n }"}, {"sha": "bc8abc0eb9036949c6e16fc979be97aadba74459", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -17,11 +17,10 @@ use hir::def::DefKind;\n use rustc_errors::{DelayDm, FatalError, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst};\n+use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{\n     self, EarlyBinder, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n-use rustc_middle::ty::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{Predicate, ToPredicate};\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n@@ -843,15 +842,19 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n             //\n             // If `AbstractConst::from_const` returned an error we already failed compilation\n             // so we don't have to emit an additional error here.\n-            use rustc_middle::ty::abstract_const::Node;\n-            if let Ok(Some(ct)) = AbstractConst::from_const(self.tcx, ct) {\n-                walk_abstract_const(self.tcx, ct, |node| match node.root(self.tcx) {\n-                    Node::Leaf(leaf) => self.visit_const(leaf),\n-                    Node::Cast(_, _, ty) => self.visit_ty(ty),\n-                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n-                        ControlFlow::CONTINUE\n-                    }\n-                })\n+            //\n+            // We currently recurse into abstract consts here but do not recurse in\n+            // `is_const_evaluatable`. This means that the object safety check is more\n+            // liberal than the const eval check.\n+            //\n+            // This shouldn't really matter though as we can't really use any\n+            // constants which are not considered const evaluatable.\n+            if let ty::ConstKind::Unevaluated(uv) = ct.kind() &&\n+                let Ok(Some(ct)) = self\n+                .tcx\n+                .expand_bound_abstract_const(self.tcx.bound_abstract_const(uv.def), uv.substs)\n+            {\n+                self.visit_const(ct)\n             } else {\n                 ct.super_visit_with(self)\n             }"}, {"sha": "da0a36731b9d07996c253905b1f562f2976d1e63", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -657,8 +657,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 ty::PredicateKind::ConstEquate(c1, c2) => {\n+                    let tcx = self.tcx();\n                     assert!(\n-                        self.tcx().features().generic_const_exprs,\n+                        tcx.features().generic_const_exprs,\n                         \"`ConstEquate` without a feature gate: {c1:?} {c2:?}\",\n                     );\n                     debug!(?c1, ?c2, \"evaluate_predicate_recursively: equating consts\");\n@@ -670,9 +671,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n                         (c1.kind(), c2.kind())\n                     {\n-                        if self.infcx.try_unify_abstract_consts(a, b, obligation.param_env) {\n-                            return Ok(EvaluatedToOk);\n-                        }\n+                        if let (Ok(Some(a)), Ok(Some(b))) = (\n+                                tcx.expand_bound_abstract_const(\n+                                    tcx.bound_abstract_const(a.def),\n+                                    a.substs,\n+                                ),\n+                                tcx.expand_bound_abstract_const(\n+                                    tcx.bound_abstract_const(b.def),\n+                                    b.substs,\n+                                ),\n+                            ) && a.ty() == b.ty() && let Ok(new_obligations) =\n+                                    self.infcx.at(&obligation.cause, obligation.param_env).eq(a, b)\n+                                {\n+                                    let mut obligations = new_obligations.obligations;\n+                                    self.add_depth(\n+                                        obligations.iter_mut(),\n+                                        obligation.recursion_depth,\n+                                    );\n+                                    return self.evaluate_predicates_recursively(\n+                                        previous_stack,\n+                                        obligations.into_iter(),\n+                                    );\n+                                }\n                     }\n \n                     let evaluate = |c: ty::Const<'tcx>| {"}, {"sha": "74f6850c2b81534722ea11615f6497b188dcdea4", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -476,6 +476,10 @@ impl<'tcx> WfPredicates<'tcx> {\n                                 ty::Binder::dummy(ty::PredicateKind::WellFormed(ct.into())),\n                             ));\n                         }\n+                        // FIXME(julianknodt): need to infer any nested consts here\n+                        // so walk and search recursively?\n+                        ty::ConstKind::Expr(_) => unimplemented!(),\n+\n                         ty::ConstKind::Error(_)\n                         | ty::ConstKind::Param(_)\n                         | ty::ConstKind::Bound(..)"}, {"sha": "d0705da971c11674de258b4047ca213d7d8ca1c9", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 280, "deletions": 296, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -1,10 +1,11 @@\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_index::vec::IndexVec;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n-use rustc_middle::ty::abstract_const::{CastKind, Node, NodeId};\n-use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n+use rustc_middle::thir::visit;\n+use rustc_middle::thir::visit::Visitor;\n+use rustc_middle::ty::abstract_const::CastKind;\n+use rustc_middle::ty::{self, ConstKind, Expr, TyCtxt, TypeVisitable};\n use rustc_middle::{mir, thir};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n@@ -76,334 +77,310 @@ pub(crate) fn destructure_const<'tcx>(\n     ty::DestructuredConst { variant, fields }\n }\n \n-pub struct AbstractConstBuilder<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    body_id: thir::ExprId,\n-    body: &'a thir::Thir<'tcx>,\n-    /// The current WIP node tree.\n-    nodes: IndexVec<NodeId, Node<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n-    fn root_span(&self) -> Span {\n-        self.body.exprs[self.body_id].span\n-    }\n-\n-    fn error(&mut self, sub: GenericConstantTooComplexSub) -> Result<!, ErrorGuaranteed> {\n-        let reported = self.tcx.sess.emit_err(GenericConstantTooComplex {\n-            span: self.root_span(),\n-            maybe_supported: None,\n-            sub,\n-        });\n-\n-        Err(reported)\n+/// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n+fn check_binop(op: mir::BinOp) -> bool {\n+    use mir::BinOp::*;\n+    match op {\n+        Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr | Eq | Lt | Le | Ne\n+        | Ge | Gt => true,\n+        Offset => false,\n     }\n+}\n \n-    fn maybe_supported_error(\n-        &mut self,\n-        sub: GenericConstantTooComplexSub,\n-    ) -> Result<!, ErrorGuaranteed> {\n-        let reported = self.tcx.sess.emit_err(GenericConstantTooComplex {\n-            span: self.root_span(),\n-            maybe_supported: Some(()),\n-            sub,\n-        });\n-\n-        Err(reported)\n+/// While we currently allow all unary operations, we still want to explicitly guard against\n+/// future changes here.\n+fn check_unop(op: mir::UnOp) -> bool {\n+    use mir::UnOp::*;\n+    match op {\n+        Not | Neg => true,\n     }\n+}\n \n-    #[instrument(skip(tcx, body, body_id), level = \"debug\")]\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        (body, body_id): (&'a thir::Thir<'tcx>, thir::ExprId),\n-    ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorGuaranteed> {\n-        let builder = AbstractConstBuilder { tcx, body_id, body, nodes: IndexVec::new() };\n-\n-        struct IsThirPolymorphic<'a, 'tcx> {\n-            is_poly: bool,\n-            thir: &'a thir::Thir<'tcx>,\n+fn recurse_build<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &thir::Thir<'tcx>,\n+    node: thir::ExprId,\n+    root_span: Span,\n+) -> Result<ty::Const<'tcx>, ErrorGuaranteed> {\n+    use thir::ExprKind;\n+    let node = &body.exprs[node];\n+    Ok(match &node.kind {\n+        // I dont know if handling of these 3 is correct\n+        &ExprKind::Scope { value, .. } => recurse_build(tcx, body, value, root_span)?,\n+        &ExprKind::PlaceTypeAscription { source, .. }\n+        | &ExprKind::ValueTypeAscription { source, .. } => {\n+            recurse_build(tcx, body, source, root_span)?\n         }\n-\n-        use crate::rustc_middle::thir::visit::Visitor;\n-        use thir::visit;\n-\n-        impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n-            fn expr_is_poly(&mut self, expr: &thir::Expr<'tcx>) -> bool {\n-                if expr.ty.has_non_region_param() {\n-                    return true;\n+        &ExprKind::Literal { lit, neg } => {\n+            let sp = node.span;\n+            match tcx.at(sp).lit_to_const(LitToConstInput { lit: &lit.node, ty: node.ty, neg }) {\n+                Ok(c) => c,\n+                Err(LitToConstError::Reported(guar)) => {\n+                    tcx.const_error_with_guaranteed(node.ty, guar)\n                 }\n-\n-                match expr.kind {\n-                    thir::ExprKind::NamedConst { substs, .. } => substs.has_non_region_param(),\n-                    thir::ExprKind::ConstParam { .. } => true,\n-                    thir::ExprKind::Repeat { value, count } => {\n-                        self.visit_expr(&self.thir()[value]);\n-                        count.has_non_region_param()\n-                    }\n-                    _ => false,\n+                Err(LitToConstError::TypeError) => {\n+                    bug!(\"encountered type error in lit_to_const\")\n                 }\n             }\n+        }\n+        &ExprKind::NonHirLiteral { lit, user_ty: _ } => {\n+            let val = ty::ValTree::from_scalar_int(lit);\n+            ty::Const::from_value(tcx, val, node.ty)\n+        }\n+        &ExprKind::ZstLiteral { user_ty: _ } => {\n+            let val = ty::ValTree::zst();\n+            ty::Const::from_value(tcx, val, node.ty)\n+        }\n+        &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n+            let uneval = ty::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            tcx.mk_const(ty::ConstKind::Unevaluated(uneval), node.ty)\n+        }\n+        ExprKind::ConstParam { param, .. } => tcx.mk_const(ty::ConstKind::Param(*param), node.ty),\n \n-            fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {\n-                if pat.ty.has_non_region_param() {\n-                    return true;\n-                }\n+        ExprKind::Call { fun, args, .. } => {\n+            let fun = recurse_build(tcx, body, *fun, root_span)?;\n \n-                match pat.kind {\n-                    thir::PatKind::Constant { value } => value.has_non_region_param(),\n-                    thir::PatKind::Range(box thir::PatRange { lo, hi, .. }) => {\n-                        lo.has_non_region_param() || hi.has_non_region_param()\n-                    }\n-                    _ => false,\n-                }\n+            let mut new_args = Vec::<ty::Const<'tcx>>::with_capacity(args.len());\n+            for &id in args.iter() {\n+                new_args.push(recurse_build(tcx, body, id, root_span)?);\n             }\n+            let new_args = tcx.mk_const_list(new_args.iter());\n+            tcx.mk_const(ConstKind::Expr(Expr::FunctionCall(fun, new_args)), node.ty)\n         }\n-\n-        impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n-            fn thir(&self) -> &'a thir::Thir<'tcx> {\n-                &self.thir\n-            }\n-\n-            #[instrument(skip(self), level = \"debug\")]\n-            fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n-                self.is_poly |= self.expr_is_poly(expr);\n-                if !self.is_poly {\n-                    visit::walk_expr(self, expr)\n-                }\n+        &ExprKind::Binary { op, lhs, rhs } if check_binop(op) => {\n+            let lhs = recurse_build(tcx, body, lhs, root_span)?;\n+            let rhs = recurse_build(tcx, body, rhs, root_span)?;\n+            tcx.mk_const(ConstKind::Expr(Expr::Binop(op, lhs, rhs)), node.ty)\n+        }\n+        &ExprKind::Unary { op, arg } if check_unop(op) => {\n+            let arg = recurse_build(tcx, body, arg, root_span)?;\n+            tcx.mk_const(ConstKind::Expr(Expr::UnOp(op, arg)), node.ty)\n+        }\n+        // This is necessary so that the following compiles:\n+        //\n+        // ```\n+        // fn foo<const N: usize>(a: [(); N + 1]) {\n+        //     bar::<{ N + 1 }>();\n+        // }\n+        // ```\n+        ExprKind::Block { block } => {\n+            if let thir::Block { stmts: box [], expr: Some(e), .. } = &body.blocks[*block] {\n+                recurse_build(tcx, body, *e, root_span)?\n+            } else {\n+                maybe_supported_error(\n+                    tcx,\n+                    GenericConstantTooComplexSub::BlockNotSupported(node.span),\n+                    root_span,\n+                )?\n             }\n-\n-            #[instrument(skip(self), level = \"debug\")]\n-            fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n-                self.is_poly |= self.pat_is_poly(pat);\n-                if !self.is_poly {\n-                    visit::walk_pat(self, pat);\n-                }\n+        }\n+        // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n+        // \"coercion cast\" i.e. using a coercion or is a no-op.\n+        // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n+        &ExprKind::Use { source } => {\n+            let arg = recurse_build(tcx, body, source, root_span)?;\n+            tcx.mk_const(ConstKind::Expr(Expr::Cast(CastKind::Use, arg, node.ty)), node.ty)\n+        }\n+        &ExprKind::Cast { source } => {\n+            let arg = recurse_build(tcx, body, source, root_span)?;\n+            tcx.mk_const(ConstKind::Expr(Expr::Cast(CastKind::As, arg, node.ty)), node.ty)\n+        }\n+        ExprKind::Borrow { arg, .. } => {\n+            let arg_node = &body.exprs[*arg];\n+\n+            // Skip reborrows for now until we allow Deref/Borrow/AddressOf\n+            // expressions.\n+            // FIXME(generic_const_exprs): Verify/explain why this is sound\n+            if let ExprKind::Deref { arg } = arg_node.kind {\n+                recurse_build(tcx, body, arg, root_span)?\n+            } else {\n+                maybe_supported_error(\n+                    tcx,\n+                    GenericConstantTooComplexSub::BorrowNotSupported(node.span),\n+                    root_span,\n+                )?\n             }\n         }\n-\n-        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n-        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n-        debug!(\"AbstractConstBuilder: is_poly={}\", is_poly_vis.is_poly);\n-        if !is_poly_vis.is_poly {\n-            return Ok(None);\n+        // FIXME(generic_const_exprs): We may want to support these.\n+        ExprKind::AddressOf { .. } | ExprKind::Deref { .. } => maybe_supported_error(\n+            tcx,\n+            GenericConstantTooComplexSub::AddressAndDerefNotSupported(node.span),\n+            root_span,\n+        )?,\n+        ExprKind::Repeat { .. } | ExprKind::Array { .. } => maybe_supported_error(\n+            tcx,\n+            GenericConstantTooComplexSub::ArrayNotSupported(node.span),\n+            root_span,\n+        )?,\n+        ExprKind::NeverToAny { .. } => maybe_supported_error(\n+            tcx,\n+            GenericConstantTooComplexSub::NeverToAnyNotSupported(node.span),\n+            root_span,\n+        )?,\n+        ExprKind::Tuple { .. } => maybe_supported_error(\n+            tcx,\n+            GenericConstantTooComplexSub::TupleNotSupported(node.span),\n+            root_span,\n+        )?,\n+        ExprKind::Index { .. } => maybe_supported_error(\n+            tcx,\n+            GenericConstantTooComplexSub::IndexNotSupported(node.span),\n+            root_span,\n+        )?,\n+        ExprKind::Field { .. } => maybe_supported_error(\n+            tcx,\n+            GenericConstantTooComplexSub::FieldNotSupported(node.span),\n+            root_span,\n+        )?,\n+        ExprKind::ConstBlock { .. } => maybe_supported_error(\n+            tcx,\n+            GenericConstantTooComplexSub::ConstBlockNotSupported(node.span),\n+            root_span,\n+        )?,\n+        ExprKind::Adt(_) => maybe_supported_error(\n+            tcx,\n+            GenericConstantTooComplexSub::AdtNotSupported(node.span),\n+            root_span,\n+        )?,\n+        // dont know if this is correct\n+        ExprKind::Pointer { .. } => {\n+            error(tcx, GenericConstantTooComplexSub::PointerNotSupported(node.span), root_span)?\n+        }\n+        ExprKind::Yield { .. } => {\n+            error(tcx, GenericConstantTooComplexSub::YieldNotSupported(node.span), root_span)?\n+        }\n+        ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => {\n+            error(tcx, GenericConstantTooComplexSub::LoopNotSupported(node.span), root_span)?\n+        }\n+        ExprKind::Box { .. } => {\n+            error(tcx, GenericConstantTooComplexSub::BoxNotSupported(node.span), root_span)?\n         }\n \n-        Ok(Some(builder))\n-    }\n-\n-    /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n-    fn check_binop(op: mir::BinOp) -> bool {\n-        use mir::BinOp::*;\n-        match op {\n-            Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr | Eq | Lt | Le\n-            | Ne | Ge | Gt => true,\n-            Offset => false,\n+        ExprKind::Unary { .. } => unreachable!(),\n+        // we handle valid unary/binary ops above\n+        ExprKind::Binary { .. } => {\n+            error(tcx, GenericConstantTooComplexSub::BinaryNotSupported(node.span), root_span)?\n+        }\n+        ExprKind::LogicalOp { .. } => {\n+            error(tcx, GenericConstantTooComplexSub::LogicalOpNotSupported(node.span), root_span)?\n+        }\n+        ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n+            error(tcx, GenericConstantTooComplexSub::AssignNotSupported(node.span), root_span)?\n+        }\n+        ExprKind::Closure { .. } | ExprKind::Return { .. } => error(\n+            tcx,\n+            GenericConstantTooComplexSub::ClosureAndReturnNotSupported(node.span),\n+            root_span,\n+        )?,\n+        // let expressions imply control flow\n+        ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } => {\n+            error(tcx, GenericConstantTooComplexSub::ControlFlowNotSupported(node.span), root_span)?\n+        }\n+        ExprKind::InlineAsm { .. } => {\n+            error(tcx, GenericConstantTooComplexSub::InlineAsmNotSupported(node.span), root_span)?\n         }\n-    }\n \n-    /// While we currently allow all unary operations, we still want to explicitly guard against\n-    /// future changes here.\n-    fn check_unop(op: mir::UnOp) -> bool {\n-        use mir::UnOp::*;\n-        match op {\n-            Not | Neg => true,\n+        // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n+        ExprKind::VarRef { .. }\n+        | ExprKind::UpvarRef { .. }\n+        | ExprKind::StaticRef { .. }\n+        | ExprKind::ThreadLocalRef(_) => {\n+            error(tcx, GenericConstantTooComplexSub::OperationNotSupported(node.span), root_span)?\n         }\n-    }\n+    })\n+}\n \n-    /// Builds the abstract const by walking the thir and bailing out when\n-    /// encountering an unsupported operation.\n-    pub fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorGuaranteed> {\n-        debug!(\"AbstractConstBuilder::build: body={:?}\", &*self.body);\n-        self.recurse_build(self.body_id)?;\n+struct IsThirPolymorphic<'a, 'tcx> {\n+    is_poly: bool,\n+    thir: &'a thir::Thir<'tcx>,\n+}\n \n-        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter()))\n-    }\n+fn error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sub: GenericConstantTooComplexSub,\n+    root_span: Span,\n+) -> Result<!, ErrorGuaranteed> {\n+    let reported = tcx.sess.emit_err(GenericConstantTooComplex {\n+        span: root_span,\n+        maybe_supported: None,\n+        sub,\n+    });\n+\n+    Err(reported)\n+}\n \n-    fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorGuaranteed> {\n-        use thir::ExprKind;\n-        let node = &self.body.exprs[node];\n-        Ok(match &node.kind {\n-            // I dont know if handling of these 3 is correct\n-            &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n-            &ExprKind::PlaceTypeAscription { source, .. }\n-            | &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n-            &ExprKind::Literal { lit, neg } => {\n-                let sp = node.span;\n-                let constant = match self.tcx.at(sp).lit_to_const(LitToConstInput {\n-                    lit: &lit.node,\n-                    ty: node.ty,\n-                    neg,\n-                }) {\n-                    Ok(c) => c,\n-                    Err(LitToConstError::Reported(guar)) => {\n-                        self.tcx.const_error_with_guaranteed(node.ty, guar)\n-                    }\n-                    Err(LitToConstError::TypeError) => {\n-                        bug!(\"encountered type error in lit_to_const\")\n-                    }\n-                };\n-\n-                self.nodes.push(Node::Leaf(constant))\n-            }\n-            &ExprKind::NonHirLiteral { lit, user_ty: _ } => {\n-                let val = ty::ValTree::from_scalar_int(lit);\n-                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n-            }\n-            &ExprKind::ZstLiteral { user_ty: _ } => {\n-                let val = ty::ValTree::zst();\n-                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n-            }\n-            &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n-                let uneval =\n-                    ty::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+fn maybe_supported_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sub: GenericConstantTooComplexSub,\n+    root_span: Span,\n+) -> Result<!, ErrorGuaranteed> {\n+    let reported = tcx.sess.emit_err(GenericConstantTooComplex {\n+        span: root_span,\n+        maybe_supported: Some(()),\n+        sub,\n+    });\n+\n+    Err(reported)\n+}\n \n-                let constant = self.tcx.mk_const(ty::ConstKind::Unevaluated(uneval), node.ty);\n+impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n+    fn expr_is_poly(&mut self, expr: &thir::Expr<'tcx>) -> bool {\n+        if expr.ty.has_non_region_param() {\n+            return true;\n+        }\n \n-                self.nodes.push(Node::Leaf(constant))\n+        match expr.kind {\n+            thir::ExprKind::NamedConst { substs, .. } => substs.has_non_region_param(),\n+            thir::ExprKind::ConstParam { .. } => true,\n+            thir::ExprKind::Repeat { value, count } => {\n+                self.visit_expr(&self.thir()[value]);\n+                count.has_non_region_param()\n             }\n+            _ => false,\n+        }\n+    }\n+    fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {\n+        if pat.ty.has_non_region_param() {\n+            return true;\n+        }\n \n-            ExprKind::ConstParam { param, .. } => {\n-                let const_param = self.tcx.mk_const(ty::ConstKind::Param(*param), node.ty);\n-                self.nodes.push(Node::Leaf(const_param))\n+        match pat.kind {\n+            thir::PatKind::Constant { value } => value.has_non_region_param(),\n+            thir::PatKind::Range(box thir::PatRange { lo, hi, .. }) => {\n+                lo.has_non_region_param() || hi.has_non_region_param()\n             }\n+            _ => false,\n+        }\n+    }\n+}\n \n-            ExprKind::Call { fun, args, .. } => {\n-                let fun = self.recurse_build(*fun)?;\n-\n-                let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n-                for &id in args.iter() {\n-                    new_args.push(self.recurse_build(id)?);\n-                }\n-                let new_args = self.tcx.arena.alloc_slice(&new_args);\n-                self.nodes.push(Node::FunctionCall(fun, new_args))\n-            }\n-            &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n-                let lhs = self.recurse_build(lhs)?;\n-                let rhs = self.recurse_build(rhs)?;\n-                self.nodes.push(Node::Binop(op, lhs, rhs))\n-            }\n-            &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n-                let arg = self.recurse_build(arg)?;\n-                self.nodes.push(Node::UnaryOp(op, arg))\n-            }\n-            // This is necessary so that the following compiles:\n-            //\n-            // ```\n-            // fn foo<const N: usize>(a: [(); N + 1]) {\n-            //     bar::<{ N + 1 }>();\n-            // }\n-            // ```\n-            ExprKind::Block { block } => {\n-                if let thir::Block { stmts: box [], expr: Some(e), .. } = &self.body.blocks[*block]\n-                {\n-                    self.recurse_build(*e)?\n-                } else {\n-                    self.maybe_supported_error(GenericConstantTooComplexSub::BlockNotSupported(\n-                        node.span,\n-                    ))?\n-                }\n-            }\n-            // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n-            // \"coercion cast\" i.e. using a coercion or is a no-op.\n-            // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n-            &ExprKind::Use { source } => {\n-                let arg = self.recurse_build(source)?;\n-                self.nodes.push(Node::Cast(CastKind::Use, arg, node.ty))\n-            }\n-            &ExprKind::Cast { source } => {\n-                let arg = self.recurse_build(source)?;\n-                self.nodes.push(Node::Cast(CastKind::As, arg, node.ty))\n-            }\n-            ExprKind::Borrow { arg, .. } => {\n-                let arg_node = &self.body.exprs[*arg];\n-\n-                // Skip reborrows for now until we allow Deref/Borrow/AddressOf\n-                // expressions.\n-                // FIXME(generic_const_exprs): Verify/explain why this is sound\n-                if let ExprKind::Deref { arg } = arg_node.kind {\n-                    self.recurse_build(arg)?\n-                } else {\n-                    self.maybe_supported_error(GenericConstantTooComplexSub::BorrowNotSupported(\n-                        node.span,\n-                    ))?\n-                }\n-            }\n-            // FIXME(generic_const_exprs): We may want to support these.\n-            ExprKind::AddressOf { .. } | ExprKind::Deref { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::AddressAndDerefNotSupported(node.span),\n-            )?,\n-            ExprKind::Repeat { .. } | ExprKind::Array { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::ArrayNotSupported(node.span),\n-            )?,\n-            ExprKind::NeverToAny { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::NeverToAnyNotSupported(node.span),\n-            )?,\n-            ExprKind::Tuple { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::TupleNotSupported(node.span),\n-            )?,\n-            ExprKind::Index { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::IndexNotSupported(node.span),\n-            )?,\n-            ExprKind::Field { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::FieldNotSupported(node.span),\n-            )?,\n-            ExprKind::ConstBlock { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::ConstBlockNotSupported(node.span),\n-            )?,\n-            ExprKind::Adt(_) => self\n-                .maybe_supported_error(GenericConstantTooComplexSub::AdtNotSupported(node.span))?,\n-            // dont know if this is correct\n-            ExprKind::Pointer { .. } => {\n-                self.error(GenericConstantTooComplexSub::PointerNotSupported(node.span))?\n-            }\n-            ExprKind::Yield { .. } => {\n-                self.error(GenericConstantTooComplexSub::YieldNotSupported(node.span))?\n-            }\n-            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => {\n-                self.error(GenericConstantTooComplexSub::LoopNotSupported(node.span))?\n-            }\n-            ExprKind::Box { .. } => {\n-                self.error(GenericConstantTooComplexSub::BoxNotSupported(node.span))?\n-            }\n+impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n+    fn thir(&self) -> &'a thir::Thir<'tcx> {\n+        &self.thir\n+    }\n \n-            ExprKind::Unary { .. } => unreachable!(),\n-            // we handle valid unary/binary ops above\n-            ExprKind::Binary { .. } => {\n-                self.error(GenericConstantTooComplexSub::BinaryNotSupported(node.span))?\n-            }\n-            ExprKind::LogicalOp { .. } => {\n-                self.error(GenericConstantTooComplexSub::LogicalOpNotSupported(node.span))?\n-            }\n-            ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n-                self.error(GenericConstantTooComplexSub::AssignNotSupported(node.span))?\n-            }\n-            ExprKind::Closure { .. } | ExprKind::Return { .. } => {\n-                self.error(GenericConstantTooComplexSub::ClosureAndReturnNotSupported(node.span))?\n-            }\n-            // let expressions imply control flow\n-            ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } => {\n-                self.error(GenericConstantTooComplexSub::ControlFlowNotSupported(node.span))?\n-            }\n-            ExprKind::InlineAsm { .. } => {\n-                self.error(GenericConstantTooComplexSub::InlineAsmNotSupported(node.span))?\n-            }\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n+        self.is_poly |= self.expr_is_poly(expr);\n+        if !self.is_poly {\n+            visit::walk_expr(self, expr)\n+        }\n+    }\n \n-            // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n-            ExprKind::VarRef { .. }\n-            | ExprKind::UpvarRef { .. }\n-            | ExprKind::StaticRef { .. }\n-            | ExprKind::ThreadLocalRef(_) => {\n-                self.error(GenericConstantTooComplexSub::OperationNotSupported(node.span))?\n-            }\n-        })\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n+        self.is_poly |= self.pat_is_poly(pat);\n+        if !self.is_poly {\n+            visit::walk_pat(self, pat);\n+        }\n     }\n }\n \n /// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n pub fn thir_abstract_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n+) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n     if tcx.features().generic_const_exprs {\n         match tcx.def_kind(def.did) {\n             // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n@@ -416,10 +393,17 @@ pub fn thir_abstract_const<'tcx>(\n         }\n \n         let body = tcx.thir_body(def)?;\n+        let (body, body_id) = (&*body.0.borrow(), body.1);\n+\n+        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n+        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n+        if !is_poly_vis.is_poly {\n+            return Ok(None);\n+        }\n+\n+        let root_span = body.exprs[body_id].span;\n \n-        AbstractConstBuilder::new(tcx, (&*body.0.borrow(), body.1))?\n-            .map(AbstractConstBuilder::build)\n-            .transpose()\n+        Some(recurse_build(tcx, body, body_id, root_span)).transpose()\n     } else {\n         Ok(None)\n     }"}, {"sha": "f7ab8b83cb6b69d21c00596c9cc996b1c07be852", "filename": "src/test/ui/const-generics/invariant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Finvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Finvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvariant.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -24,10 +24,10 @@ where\n fn covariant(\n     v: &'static Foo<for<'a> fn(&'a ())>\n ) -> &'static Foo<fn(&'static ())> {\n-    v //~ ERROR mismatched types\n+    v\n }\n \n fn main() {\n-    let y = covariant(&Foo([], PhantomData));\n+    let y = covariant(&Foo([], PhantomData)); //~ ERROR mismatched types\n     println!(\"{:?}\", y.0);\n }"}, {"sha": "9f43d77c8059f0821c597b780b7b35883151abb9", "filename": "src/test/ui/const-generics/invariant.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Finvariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Finvariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvariant.stderr?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -13,13 +13,13 @@ LL | impl SadBee for fn(&'static ()) {\n    = note: `#[warn(coherence_leak_check)]` on by default\n \n error[E0308]: mismatched types\n-  --> $DIR/invariant.rs:27:5\n+  --> $DIR/invariant.rs:31:28\n    |\n-LL |     v\n-   |     ^ one type is more general than the other\n+LL |     let y = covariant(&Foo([], PhantomData));\n+   |                            ^^ expected `<_ as SadBee>::ASSOC`, found `<for<'a> fn(&'a ()) as SadBee>::ASSOC`\n    |\n-   = note: expected reference `&Foo<fn(&())>`\n-              found reference `&Foo<for<'a> fn(&'a ())>`\n+   = note: expected constant `<_ as SadBee>::ASSOC`\n+              found constant `<for<'a> fn(&'a ()) as SadBee>::ASSOC`\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "43dc94b9ced018d65ab3ed07253ff3ffd2189d17", "filename": "src/test/ui/const-generics/issues/issue-83249.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -15,9 +15,9 @@ fn foo<T: Foo>(_: [u8; T::N]) -> T {\n \n pub fn bar() {\n     let _: u8 = foo([0; 1]);\n+    //~^ ERROR mismatched types\n \n     let _ = foo([0; 1]);\n-    //~^ ERROR type annotations needed\n }\n \n fn main() {}"}, {"sha": "d55e1ea5900b3661d260a70ff45f7ef89fe315da", "filename": "src/test/ui/const-generics/issues/issue-83249.stderr", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.stderr?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -1,14 +1,12 @@\n-error[E0282]: type annotations needed\n-  --> $DIR/issue-83249.rs:19:9\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83249.rs:17:21\n    |\n-LL |     let _ = foo([0; 1]);\n-   |         ^\n+LL |     let _: u8 = foo([0; 1]);\n+   |                     ^^^^^^ expected `<_ as Foo>::N`, found `<u8 as Foo>::N`\n    |\n-help: consider giving this pattern a type\n-   |\n-LL |     let _: _ = foo([0; 1]);\n-   |          +++\n+   = note: expected constant `<_ as Foo>::N`\n+              found constant `<u8 as Foo>::N`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "79ca330526fd5cf2ffd1a7260681e69537939fd9", "filename": "src/test/ui/const-generics/issues/issue-83765.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -3,7 +3,6 @@\n \n trait TensorDimension {\n     const DIM: usize;\n-    //~^ ERROR cycle detected when resolving instance\n     // FIXME Given the current state of the compiler its expected that we cycle here,\n     // but the cycle is still wrong.\n     const ISSCALAR: bool = Self::DIM == 0;\n@@ -48,19 +47,23 @@ impl<'a, T: Broadcastable, const DIM: usize> TensorDimension for LazyUpdim<'a, T\n \n impl<'a, T: Broadcastable, const DIM: usize> TensorSize for LazyUpdim<'a, T, { T::DIM }, DIM> {\n     fn size(&self) -> [usize; DIM] {\n+      //~^ ERROR method not compatible\n         self.size\n     }\n }\n \n impl<'a, T: Broadcastable, const DIM: usize> Broadcastable for LazyUpdim<'a, T, { T::DIM }, DIM> {\n     type Element = T::Element;\n     fn bget(&self, index: [usize; DIM]) -> Option<Self::Element> {\n+        //~^ ERROR method not compatible\n         assert!(DIM >= T::DIM);\n         if !self.inbounds(index) {\n+            //~^ ERROR mismatched types\n             return None;\n         }\n         let size = self.size();\n         let newindex: [usize; T::DIM] = Default::default();\n+        //~^ ERROR the trait bound\n         self.reference.bget(newindex)\n     }\n }\n@@ -79,7 +82,10 @@ impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> TensorSi\n     for BMap<'a, R, T, F, DIM>\n {\n     fn size(&self) -> [usize; DIM] {\n+        //~^ ERROR method not compatible\n         self.reference.size()\n+        //~^ ERROR unconstrained\n+        //~| ERROR mismatched types\n     }\n }\n \n@@ -88,7 +94,10 @@ impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> Broadcas\n {\n     type Element = R;\n     fn bget(&self, index: [usize; DIM]) -> Option<Self::Element> {\n+        //~^ ERROR method not compatible\n         self.reference.bget(index).map(&self.closure)\n+        //~^ ERROR unconstrained generic constant\n+        //~| ERROR mismatched types\n     }\n }\n \n@@ -111,6 +120,8 @@ fn main() {\n     let v = vec![1, 2, 3];\n     let bv = v.lazy_updim([3, 4]);\n     let bbv = bv.bmap(|x| x * x);\n+    //~^ ERROR mismatched types\n \n     println!(\"The size of v is {:?}\", bbv.bget([0, 2]).expect(\"Out of bounds.\"));\n+    //~^ ERROR mismatched types\n }"}, {"sha": "c0e4ae66a899d197ef0c362da7c830975372cd4c", "filename": "src/test/ui/const-generics/issues/issue-83765.stderr", "status": "modified", "additions": 116, "deletions": 15, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -1,21 +1,122 @@\n-error[E0391]: cycle detected when resolving instance `<LazyUpdim<'_, T, { T::DIM }, DIM> as TensorDimension>::DIM`\n-  --> $DIR/issue-83765.rs:5:5\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:49:5\n    |\n-LL |     const DIM: usize;\n-   |     ^^^^^^^^^^^^^^^^\n+LL |     fn size(&self) -> [usize; DIM] {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n    |\n-note: ...which requires computing candidate for `<LazyUpdim<'_, T, { T::DIM }, DIM> as TensorDimension>`...\n-  --> $DIR/issue-83765.rs:4:1\n+   = note: expected constant `Self::DIM`\n+              found constant `DIM`\n+\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:57:5\n+   |\n+LL |     fn bget(&self, index: [usize; DIM]) -> Option<Self::Element> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected constant `Self::DIM`\n+              found constant `DIM`\n+\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:84:5\n+   |\n+LL |     fn size(&self) -> [usize; DIM] {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected constant `Self::DIM`\n+              found constant `DIM`\n+\n+error[E0308]: method not compatible with trait\n+  --> $DIR/issue-83765.rs:96:5\n+   |\n+LL |     fn bget(&self, index: [usize; DIM]) -> Option<Self::Element> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected constant `Self::DIM`\n+              found constant `DIM`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:60:27\n+   |\n+LL |         if !self.inbounds(index) {\n+   |                           ^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected constant `Self::DIM`\n+              found constant `DIM`\n+\n+error[E0277]: the trait bound `[usize; _]: Default` is not satisfied\n+  --> $DIR/issue-83765.rs:65:41\n+   |\n+LL |         let newindex: [usize; T::DIM] = Default::default();\n+   |                                         ^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `[usize; _]`\n+   |\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n+   |\n+LL | impl<'a, T: Broadcastable, const DIM: usize> Broadcastable for LazyUpdim<'a, T, { T::DIM }, DIM> where [usize; _]: Default {\n+   |                                                                                                  +++++++++++++++++++++++++\n+\n+error: unconstrained generic constant\n+  --> $DIR/issue-83765.rs:86:24\n+   |\n+LL |         self.reference.size()\n+   |                        ^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n+note: required by a bound in `TensorSize::size`\n+  --> $DIR/issue-83765.rs:15:31\n+   |\n+LL |     fn size(&self) -> [usize; Self::DIM];\n+   |                               ^^^^^^^^^ required by this bound in `TensorSize::size`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:86:9\n+   |\n+LL |         self.reference.size()\n+   |         ^^^^^^^^^^^^^^^^^^^^^ expected `DIM`, found `Self::DIM`\n+   |\n+   = note: expected constant `DIM`\n+              found constant `Self::DIM`\n+\n+error: unconstrained generic constant\n+  --> $DIR/issue-83765.rs:98:24\n+   |\n+LL |         self.reference.bget(index).map(&self.closure)\n+   |                        ^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n+note: required by a bound in `Broadcastable::bget`\n+  --> $DIR/issue-83765.rs:23:35\n+   |\n+LL |     fn bget(&self, index: [usize; Self::DIM]) -> Option<Self::Element>;\n+   |                                   ^^^^^^^^^ required by this bound in `Broadcastable::bget`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:98:29\n+   |\n+LL |         self.reference.bget(index).map(&self.closure)\n+   |                             ^^^^^ expected `Self::DIM`, found `DIM`\n+   |\n+   = note: expected constant `Self::DIM`\n+              found constant `DIM`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:122:15\n+   |\n+LL |     let bbv = bv.bmap(|x| x * x);\n+   |               ^^^^^^^^^^^^^^^^^^ expected `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`, found `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n+   |\n+   = note: expected constant `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n+              found constant `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-83765.rs:125:43\n    |\n-LL | trait TensorDimension {\n-   | ^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires resolving instance `<LazyUpdim<'_, T, { T::DIM }, DIM> as TensorDimension>::DIM`, completing the cycle\n-note: cycle used when computing candidate for `<LazyUpdim<'_, T, { T::DIM }, DIM> as TensorDimension>`\n-  --> $DIR/issue-83765.rs:4:1\n+LL |     println!(\"The size of v is {:?}\", bbv.bget([0, 2]).expect(\"Out of bounds.\"));\n+   |                                           ^^^^ expected `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`, found `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n    |\n-LL | trait TensorDimension {\n-   | ^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected constant `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n+              found constant `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n \n-error: aborting due to previous error\n+error: aborting due to 12 previous errors\n \n-For more information about this error, try `rustc --explain E0391`.\n+Some errors have detailed explanations: E0277, E0308.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "4908fb29692ccfd211e4ac4bf1a83ee05311fac2", "filename": "src/test/ui/const-generics/issues/issue-85031-2.rs", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.rs?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -1,13 +1,17 @@\n-// revisions: cfail\n+// check-pass\n+// known-bug\n+\n+// This should not compile, as the compiler should not know\n+// `A - 0` is satisfied `?x - 0` if `?x` is inferred to `A`.\n #![allow(incomplete_features)]\n #![feature(generic_const_exprs)]\n \n pub struct Ref<'a>(&'a i32);\n \n impl<'a> Ref<'a> {\n     pub fn foo<const A: usize>() -> [(); A - 0] {\n+        //~^ WARN function cannot\n         Self::foo()\n-        //~^ error: type annotations needed\n     }\n }\n ", "previous_filename": "src/test/incremental/const-generics/try_unify_abstract_const_regression_tests/issue-85031-2.rs"}, {"sha": "fc690576875209fd5c91ecaf96252dc43dfab39f", "filename": "src/test/ui/const-generics/issues/issue-85031-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9750c1554a355a3755a412581c57b230248f06d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.stderr?ref=f9750c1554a355a3755a412581c57b230248f06d", "patch": "@@ -0,0 +1,14 @@\n+warning: function cannot return without recursing\n+  --> $DIR/issue-85031-2.rs:12:5\n+   |\n+LL |     pub fn foo<const A: usize>() -> [(); A - 0] {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n+LL |\n+LL |         Self::foo()\n+   |         ----------- recursive call site\n+   |\n+   = help: a `loop` may express intention better if this is on purpose\n+   = note: `#[warn(unconditional_recursion)]` on by default\n+\n+warning: 1 warning emitted\n+"}]}