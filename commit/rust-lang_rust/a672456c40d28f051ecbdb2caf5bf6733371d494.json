{"sha": "a672456c40d28f051ecbdb2caf5bf6733371d494", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NzI0NTZjNDBkMjhmMDUxZWNiZGIyY2FmNWJmNjczMzM3MWQ0OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-10T21:41:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-10T21:41:36Z"}, "message": "auto merge of #15353 : aturon/rust/env-hashmap, r=alexcrichton\n\nThis commit adds `env_insert` and `env_remove` methods to the `Command`\r\nbuilder, easing updates to the environment variables for the child\r\nprocess. The existing method, `env`, is still available for overriding\r\nthe entire environment in one shot (after which the `env_insert` and\r\n`env_remove` methods can be used to make further adjustments).\r\n\r\nTo support these new methods, the internal `env` representation for\r\n`Command` has been changed to an optional `HashMap` holding owned\r\n`CString`s (to support non-utf8 data). The `HashMap` is only\r\nmaterialized if the environment is updated. The implementation does not\r\ntry hard to avoid allocation, since the cost of launching a process will\r\ndwarf any allocation cost.\r\n\r\nThis patch also adds `PartialOrd`, `Eq`, and `Hash` implementations for\r\n`CString`.", "tree": {"sha": "1ce9d7ff9d26425e9c581d7ce377531c1155da0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ce9d7ff9d26425e9c581d7ce377531c1155da0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a672456c40d28f051ecbdb2caf5bf6733371d494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a672456c40d28f051ecbdb2caf5bf6733371d494", "html_url": "https://github.com/rust-lang/rust/commit/a672456c40d28f051ecbdb2caf5bf6733371d494", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a672456c40d28f051ecbdb2caf5bf6733371d494/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bbf598d50960087342667fc47f5d38f4a9c2165", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bbf598d50960087342667fc47f5d38f4a9c2165", "html_url": "https://github.com/rust-lang/rust/commit/8bbf598d50960087342667fc47f5d38f4a9c2165"}, {"sha": "bfa853f8ed45d1908c98ec350f52c7a6790661da", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa853f8ed45d1908c98ec350f52c7a6790661da", "html_url": "https://github.com/rust-lang/rust/commit/bfa853f8ed45d1908c98ec350f52c7a6790661da"}], "stats": {"total": 211, "additions": 138, "deletions": 73}, "files": [{"sha": "1ee6f2b500c138fbceec3c74baa53be31cef3e52", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::os;\n use std::str;\n use std::io::process::{ProcessExit, Command, Process, ProcessOutput};\n use std::dynamic_lib::DynamicLibrary;\n \n-fn target_env(lib_path: &str, aux_path: Option<&str>) -> Vec<(String, String)> {\n+fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // Need to be sure to put both the lib_path and the aux path in the dylib\n     // search path for the child.\n     let mut path = DynamicLibrary::search_path();\n@@ -23,19 +22,11 @@ fn target_env(lib_path: &str, aux_path: Option<&str>) -> Vec<(String, String)> {\n     }\n     path.insert(0, Path::new(lib_path));\n \n-    // Remove the previous dylib search path var\n-    let var = DynamicLibrary::envvar();\n-    let mut env: Vec<(String,String)> = os::env();\n-    match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n-        Some(i) => { env.remove(i); }\n-        None => {}\n-    }\n-\n     // Add the new dylib search path var\n+    let var = DynamicLibrary::envvar();\n     let newpath = DynamicLibrary::create_path(path.as_slice());\n     let newpath = str::from_utf8(newpath.as_slice()).unwrap().to_string();\n-    env.push((var.to_string(), newpath));\n-    return env;\n+    cmd.env(var.to_string(), newpath);\n }\n \n pub struct Result {pub status: ProcessExit, pub out: String, pub err: String}\n@@ -47,8 +38,14 @@ pub fn run(lib_path: &str,\n            env: Vec<(String, String)> ,\n            input: Option<String>) -> Option<Result> {\n \n-    let env = env.clone().append(target_env(lib_path, aux_path).as_slice());\n-    match Command::new(prog).args(args).env(env.as_slice()).spawn() {\n+    let mut cmd = Command::new(prog);\n+    cmd.args(args);\n+    add_target_env(&mut cmd, lib_path, aux_path);\n+    for (key, val) in env.move_iter() {\n+        cmd.env(key, val);\n+    }\n+\n+    match cmd.spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n                 process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();\n@@ -73,8 +70,14 @@ pub fn run_background(lib_path: &str,\n            env: Vec<(String, String)> ,\n            input: Option<String>) -> Option<Process> {\n \n-    let env = env.clone().append(target_env(lib_path, aux_path).as_slice());\n-    match Command::new(prog).args(args).env(env.as_slice()).spawn() {\n+    let mut cmd = Command::new(prog);\n+    cmd.args(args);\n+    add_target_env(&mut cmd, lib_path, aux_path);\n+    for (key, val) in env.move_iter() {\n+        cmd.env(key, val);\n+    }\n+\n+    match cmd.spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n                 process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();"}, {"sha": "f28604908e0b3fb938b99aca02e7bd630b698d28", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -574,7 +574,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n         cmd.arg(\"./src/etc/lldb_batchmode.py\")\n            .arg(test_executable)\n            .arg(debugger_script)\n-           .env([(\"PYTHONPATH\", config.lldb_python_dir.clone().unwrap().as_slice())]);\n+           .env_set_all([(\"PYTHONPATH\", config.lldb_python_dir.clone().unwrap().as_slice())]);\n \n         let (status, out, err) = match cmd.spawn() {\n             Ok(process) => {"}, {"sha": "21da0104c2f8d70eb2539791fde4d2b22a7c681a", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -729,7 +729,7 @@ fn with_argv<T>(prog: &CString, args: &[CString],\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: Option<&[(CString, CString)]>,\n+fn with_envp<T>(env: Option<&[(&CString, &CString)]>,\n                 cb: proc(*const c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\0\" strings. Since we must create\n@@ -762,7 +762,7 @@ fn with_envp<T>(env: Option<&[(CString, CString)]>,\n }\n \n #[cfg(windows)]\n-fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: |*mut c_void| -> T) -> T {\n+fn with_envp<T>(env: Option<&[(&CString, &CString)]>, cb: |*mut c_void| -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate."}, {"sha": "0a7376cf99b01668cbe8fd1ffc2de553b81b34a3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -176,26 +176,15 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     // environment to ensure that the target loads the right libraries at\n     // runtime. It would be a sad day if the *host* libraries were loaded as a\n     // mistake.\n-    let exe = outdir.path().join(\"rust_out\");\n-    let env = {\n+    let mut cmd = Command::new(outdir.path().join(\"rust_out\"));\n+    let newpath = {\n         let mut path = DynamicLibrary::search_path();\n         path.insert(0, libdir.clone());\n-\n-        // Remove the previous dylib search path var\n-        let var = DynamicLibrary::envvar();\n-        let mut env: Vec<(String,String)> = os::env().move_iter().collect();\n-        match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n-            Some(i) => { env.remove(i); }\n-            None => {}\n-        };\n-\n-        // Add the new dylib search path var\n-        let newpath = DynamicLibrary::create_path(path.as_slice());\n-        env.push((var.to_string(),\n-                  str::from_utf8(newpath.as_slice()).unwrap().to_string()));\n-        env\n+        DynamicLibrary::create_path(path.as_slice())\n     };\n-    match Command::new(exe).env(env.as_slice()).output() {\n+    cmd.env(DynamicLibrary::envvar(), newpath.as_slice());\n+\n+    match cmd.output() {\n         Err(e) => fail!(\"couldn't run the test: {}{}\", e,\n                         if e.kind == io::PermissionDenied {\n                             \" - maybe your tempdir is mounted with noexec?\""}, {"sha": "396d51f4fcb13a4128d62046199608646d72c385", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -69,6 +69,7 @@ use core::prelude::*;\n \n use alloc::libc_heap::malloc_raw;\n use collections::string::String;\n+use collections::hash;\n use core::kinds::marker;\n use core::mem;\n use core::ptr;\n@@ -116,6 +117,22 @@ impl PartialEq for CString {\n     }\n }\n \n+impl PartialOrd for CString {\n+    #[inline]\n+    fn partial_cmp(&self, other: &CString) -> Option<Ordering> {\n+        self.as_bytes().partial_cmp(&other.as_bytes())\n+    }\n+}\n+\n+impl Eq for CString {}\n+\n+impl<S: hash::Writer> hash::Hash<S> for CString {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_bytes().hash(state)\n+    }\n+}\n+\n impl CString {\n     /// Create a C String from a pointer.\n     pub unsafe fn new(buf: *const libc::c_char, owns_buffer: bool) -> CString {"}, {"sha": "c830b2e122ec03c549d06e0d1e10731b55c1ad2e", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -17,7 +17,7 @@\n        html_root_url = \"http://doc.rust-lang.org/0.11.0/\")]\n \n #![feature(macro_rules, phase, globs, thread_local, managed_boxes, asm)]\n-#![feature(linkage, lang_items, unsafe_destructor)]\n+#![feature(linkage, lang_items, unsafe_destructor, default_type_params)]\n #![no_std]\n #![experimental]\n "}, {"sha": "7a91cca6265a0a782e29492eca9d0a69f7ed1e00", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -75,7 +75,7 @@ pub struct ProcessConfig<'a> {\n \n     /// Optional environment to specify for the program. If this is None, then\n     /// it will inherit the current process's environment.\n-    pub env: Option<&'a [(CString, CString)]>,\n+    pub env: Option<&'a [(&'a CString, &'a CString)]>,\n \n     /// Optional working directory for the new process. If this is None, then\n     /// the current directory of the running process is inherited."}, {"sha": "0486f376bc80658bfb0c7bf39480e1db195e32e1", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -193,7 +193,7 @@ fn with_argv<T>(prog: &CString, args: &[CString],\n }\n \n /// Converts the environment to the env array expected by libuv\n-fn with_env<T>(env: Option<&[(CString, CString)]>,\n+fn with_env<T>(env: Option<&[(&CString, &CString)]>,\n                cb: |*const *const libc::c_char| -> T) -> T {\n     // We can pass a char** for envp, which is a null-terminated array\n     // of \"k=v\\0\" strings. Since we must create these strings locally,"}, {"sha": "6ef730237795cd243d0395c737a11b74943ff06d", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 86, "deletions": 20, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -16,6 +16,7 @@ use prelude::*;\n \n use str;\n use fmt;\n+use os;\n use io::{IoResult, IoError};\n use io;\n use libc;\n@@ -24,6 +25,7 @@ use owned::Box;\n use rt::rtio::{RtioProcess, ProcessConfig, IoFactory, LocalIo};\n use rt::rtio;\n use c_str::CString;\n+use collections::HashMap;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n@@ -78,6 +80,9 @@ pub struct Process {\n     pub extra_io: Vec<Option<io::PipeStream>>,\n }\n \n+/// A HashMap representation of environment variables.\n+pub type EnvMap = HashMap<CString, CString>;\n+\n /// The `Command` type acts as a process builder, providing fine-grained control\n /// over how a new process should be spawned. A default configuration can be\n /// generated using `Command::new(program)`, where `program` gives a path to the\n@@ -100,7 +105,7 @@ pub struct Command {\n     // methods below, and serialized into rt::rtio::ProcessConfig.\n     program: CString,\n     args: Vec<CString>,\n-    env: Option<Vec<(CString, CString)>>,\n+    env: Option<EnvMap>,\n     cwd: Option<CString>,\n     stdin: StdioContainer,\n     stdout: StdioContainer,\n@@ -147,31 +152,53 @@ impl Command {\n     }\n \n     /// Add an argument to pass to the program.\n-    pub fn arg<'a, T:ToCStr>(&'a mut self, arg: T) -> &'a mut Command {\n+    pub fn arg<'a, T: ToCStr>(&'a mut self, arg: T) -> &'a mut Command {\n         self.args.push(arg.to_c_str());\n         self\n     }\n \n     /// Add multiple arguments to pass to the program.\n-    pub fn args<'a, T:ToCStr>(&'a mut self, args: &[T]) -> &'a mut Command {\n+    pub fn args<'a, T: ToCStr>(&'a mut self, args: &[T]) -> &'a mut Command {\n         self.args.extend(args.iter().map(|arg| arg.to_c_str()));;\n         self\n     }\n+    // Get a mutable borrow of the environment variable map for this `Command`.\n+    fn get_env_map<'a>(&'a mut self) -> &'a mut EnvMap {\n+        match self.env {\n+            Some(ref mut map) => map,\n+            None => {\n+                // if the env is currently just inheriting from the parent's,\n+                // materialize the parent's env into a hashtable.\n+                self.env = Some(os::env_as_bytes().move_iter()\n+                                   .map(|(k, v)| (k.as_slice().to_c_str(),\n+                                                  v.as_slice().to_c_str()))\n+                                   .collect());\n+                self.env.as_mut().unwrap()\n+            }\n+        }\n+    }\n \n-    /// Sets the environment for the child process (rather than inheriting it\n-    /// from the current process).\n-\n-    // FIXME (#13851): We should change this interface to allow clients to (1)\n-    // build up the env vector incrementally and (2) allow both inheriting the\n-    // current process's environment AND overriding/adding additional\n-    // environment variables. The underlying syscalls assume that the\n-    // environment has no duplicate names, so we really want to use a hashtable\n-    // to compute the environment to pass down to the syscall; resolving issue\n-    // #13851 will make it possible to use the standard hashtable.\n-    pub fn env<'a, T:ToCStr>(&'a mut self, env: &[(T,T)]) -> &'a mut Command {\n-        self.env = Some(env.iter().map(|&(ref name, ref val)| {\n-            (name.to_c_str(), val.to_c_str())\n-        }).collect());\n+    /// Inserts or updates an environment variable mapping.\n+    pub fn env<'a, T: ToCStr, U: ToCStr>(&'a mut self, key: T, val: U)\n+                                         -> &'a mut Command {\n+        self.get_env_map().insert(key.to_c_str(), val.to_c_str());\n+        self\n+    }\n+\n+    /// Removes an environment variable mapping.\n+    pub fn env_remove<'a, T: ToCStr>(&'a mut self, key: T) -> &'a mut Command {\n+        self.get_env_map().remove(&key.to_c_str());\n+        self\n+    }\n+\n+    /// Sets the entire environment map for the child process.\n+    ///\n+    /// If the given slice contains multiple instances of an environment\n+    /// variable, the *rightmost* instance will determine the value.\n+    pub fn env_set_all<'a, T: ToCStr, U: ToCStr>(&'a mut self, env: &[(T,U)])\n+                                                 -> &'a mut Command {\n+        self.env = Some(env.iter().map(|&(ref k, ref v)| (k.to_c_str(), v.to_c_str()))\n+                                  .collect());\n         self\n     }\n \n@@ -245,10 +272,15 @@ impl Command {\n         let extra_io: Vec<rtio::StdioContainer> =\n             self.extra_io.iter().map(|x| to_rtio(*x)).collect();\n         LocalIo::maybe_raise(|io| {\n+            let env = match self.env {\n+                None => None,\n+                Some(ref env_map) =>\n+                    Some(env_map.iter().collect::<Vec<_>>())\n+            };\n             let cfg = ProcessConfig {\n                 program: &self.program,\n                 args: self.args.as_slice(),\n-                env: self.env.as_ref().map(|env| env.as_slice()),\n+                env: env.as_ref().map(|e| e.as_slice()),\n                 cwd: self.cwd.as_ref(),\n                 stdin: to_rtio(self.stdin),\n                 stdout: to_rtio(self.stdout),\n@@ -872,16 +904,50 @@ mod tests {\n         }\n     })\n \n-    iotest!(fn test_add_to_env() {\n+    iotest!(fn test_override_env() {\n         let new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n-        let prog = env_cmd().env(new_env.as_slice()).spawn().unwrap();\n+        let prog = env_cmd().env_set_all(new_env.as_slice()).spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n         let output = str::from_utf8_lossy(result.output.as_slice()).into_string();\n \n         assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n     })\n \n+    iotest!(fn test_add_to_env() {\n+        let prog = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").spawn().unwrap();\n+        let result = prog.wait_with_output().unwrap();\n+        let output = str::from_utf8_lossy(result.output.as_slice()).into_string();\n+\n+        assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n+                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n+    })\n+\n+    iotest!(fn test_remove_from_env() {\n+        use os;\n+\n+        // save original environment\n+        let old_env = os::getenv(\"RUN_TEST_NEW_ENV\");\n+\n+        os::setenv(\"RUN_TEST_NEW_ENV\", \"123\");\n+        let prog = env_cmd().env_remove(\"RUN_TEST_NEW_ENV\").spawn().unwrap();\n+        let result = prog.wait_with_output().unwrap();\n+        let output = str::from_utf8_lossy(result.output.as_slice()).into_string();\n+\n+        // restore original environment\n+        match old_env {\n+            None => {\n+                os::unsetenv(\"RUN_TEST_NEW_ENV\");\n+            }\n+            Some(val) => {\n+                os::setenv(\"RUN_TEST_NEW_ENV\", val.as_slice());\n+            }\n+        }\n+\n+        assert!(!output.as_slice().contains(\"RUN_TEST_NEW_ENV\"),\n+                \"found RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n+    })\n+\n     #[cfg(unix)]\n     pub fn sleeper() -> Process {\n         Command::new(\"sleep\").arg(\"1000\").spawn().unwrap()"}, {"sha": "c2a1c01b919ab05f3a29bb9b63f5acde3778424a", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -37,19 +37,8 @@ fn double() {\n }\n \n fn runtest(me: &str) {\n-    let mut env = os::env().move_iter()\n-                           .map(|(ref k, ref v)| {\n-                               (k.to_string(), v.to_string())\n-                           }).collect::<Vec<(String,String)>>();\n-    match env.iter()\n-             .position(|&(ref s, _)| \"RUST_BACKTRACE\" == s.as_slice()) {\n-        Some(i) => { env.remove(i); }\n-        None => {}\n-    }\n-    env.push((\"RUST_BACKTRACE\".to_string(), \"1\".to_string()));\n-\n     // Make sure that the stack trace is printed\n-    let mut p = Command::new(me).arg(\"fail\").env(env.as_slice()).spawn().unwrap();\n+    let mut p = Command::new(me).arg(\"fail\").env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n@@ -73,7 +62,8 @@ fn runtest(me: &str) {\n             \"bad output3: {}\", s);\n \n     // Make sure a stack trace isn't printed too many times\n-    let mut p = Command::new(me).arg(\"double-fail\").env(env.as_slice()).spawn().unwrap();\n+    let mut p = Command::new(me).arg(\"double-fail\")\n+                                .env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();"}, {"sha": "de86ca179b7d75c0cf9c1e0bf525a71a6c591632", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a672456c40d28f051ecbdb2caf5bf6733371d494/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=a672456c40d28f051ecbdb2caf5bf6733371d494", "patch": "@@ -58,7 +58,7 @@ fn main() {\n         let p = Command::new(&child_path)\n                         .arg(arg)\n                         .cwd(&cwd)\n-                        .env(my_env.append_one(env).as_slice())\n+                        .env_set_all(my_env.append_one(env).as_slice())\n                         .spawn().unwrap().wait_with_output().unwrap();\n \n         // display the output"}]}