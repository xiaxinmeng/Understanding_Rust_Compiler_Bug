{"sha": "0f578f0d2ef1943d8a3a1123520eba90f926e757", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNTc4ZjBkMmVmMTk0M2Q4YTNhMTEyMzUyMGViYTkwZjkyNmU3NTc=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-22T11:00:43Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-22T11:00:43Z"}, "message": "fully implement `size_of_val` and add various tests that now succeed", "tree": {"sha": "d594b35704f177aae34b438ab6b2a3be610f2ca6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d594b35704f177aae34b438ab6b2a3be610f2ca6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f578f0d2ef1943d8a3a1123520eba90f926e757", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX47nbAAoJEFbW7qD8Z6xGFHQP/AqEI2cLBx/bEcMkn9ebcbos\nWawisxoSpJDfLveC4teCA1y1XN9h/zWJZqp802SdikZXYT12u/scz54Z2iKcI7Kv\nWPNqp/WPCWtrQpiPjIGYEcGlM5rok/cX86io6nElP4FjtHImb+BnMcrz9FnS7qoH\nVfCd9VwL1i4J56R+94zLPwlgbZMQfUM24ZDS6z7u1A/H357XyrIDlcS3Xf2jOHD6\ne+4M3x5yTHaNFkh4HL9KJSyuQfNLqSWHvgtCMXpIL0RRt6qArWW/UX3zEEbRsx1C\nEKfcambP7HY9j6aeJlFQtCH5G67sFilqV0viy7CSjHcv/NZUPJ+LfwIUMBcpzkPq\naUW06I/gvyhJp4NSMznxWH3O+GO0SdHFtifMYkK3ZctJn97vnWiW8OwHfqc2J/h1\nhAMcMe0UNFFCaq12VFvpEsrXFbB/B1QrWzs+jlNHcBrw3N8TuGcjDT59iFQOIauo\nEJbHzuRRQY/GcT8FkqMm/IIKJVuYM46UE/3kQE/jBPXPKXVirID4WfyPH6sv90ee\nR01xgXJME/lUarca2t3YI/XisVLfwqRJb0sPWqD+a5CU4n3kaVLqCTzQ0XJO/5PU\nA/ls2MsZ2UE8z2KJN+37vT0prMpSWhGkYCsxiVCeW+BtHRlHgDhopVIKh/61RvkA\nLHMRzbzF8xOBFCT+v0tR\n=Bk0v\n-----END PGP SIGNATURE-----", "payload": "tree d594b35704f177aae34b438ab6b2a3be610f2ca6\nparent 17e336c7d9f2d2fe02f8403cff0eb1122630a81c\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474542043 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474542043 +0200\n\nfully implement `size_of_val` and add various tests that now succeed"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f578f0d2ef1943d8a3a1123520eba90f926e757", "html_url": "https://github.com/rust-lang/rust/commit/0f578f0d2ef1943d8a3a1123520eba90f926e757", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f578f0d2ef1943d8a3a1123520eba90f926e757/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "url": "https://api.github.com/repos/rust-lang/rust/commits/17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "html_url": "https://github.com/rust-lang/rust/commit/17e336c7d9f2d2fe02f8403cff0eb1122630a81c"}], "stats": {"total": 568, "additions": 551, "deletions": 17}, "files": [{"sha": "b590905264e66a54de0e52a52c51e45ffa5a75cf", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f578f0d2ef1943d8a3a1123520eba90f926e757/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f578f0d2ef1943d8a3a1123520eba90f926e757/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=0f578f0d2ef1943d8a3a1123520eba90f926e757", "patch": "@@ -621,6 +621,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let src = self.eval_operand_to_ptr(operand)?;\n                         let src_ty = self.operand_ty(operand);\n                         let dest_ty = self.monomorphize(dest_ty, self.substs());\n+                        // FIXME: cases where dest_ty is not a fat pointer. e.g. Arc<Struct> -> Arc<Trait>\n                         assert!(self.type_is_fat_ptr(dest_ty));\n                         let (ptr, extra) = self.get_fat_ptr(dest);\n                         self.move_(src, ptr, src_ty)?;\n@@ -883,6 +884,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let offset = variant.field_offset(field.index()).bytes();\n                         let ptr = base.ptr.offset(offset as isize);\n                         match (&field_ty.sty, base.extra) {\n+                            (&ty::TyStr, extra @ LvalueExtra::Length(_)) |\n+                            (&ty::TySlice(_), extra @ LvalueExtra::Length(_)) |\n                             (&ty::TyTrait(_), extra @ LvalueExtra::Vtable(_)) => return Ok(Lvalue {\n                                 ptr: ptr,\n                                 extra: extra,"}, {"sha": "f7fa1588b5610b11163574a626d575956d39582b", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 112, "deletions": 16, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0f578f0d2ef1943d8a3a1123520eba90f926e757/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f578f0d2ef1943d8a3a1123520eba90f926e757/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=0f578f0d2ef1943d8a3a1123520eba90f926e757", "patch": "@@ -188,22 +188,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n-                if self.type_is_sized(ty) {\n-                    let size = self.type_size(ty) as u64;\n-                    self.memory.write_uint(dest, size, pointer_size)?;\n-                } else {\n-                    match ty.sty {\n-                        ty::TySlice(_) | ty::TyStr => {\n-                            let elem_ty = ty.sequence_element_type(self.tcx);\n-                            let elem_size = self.type_size(elem_ty) as u64;\n-                            let ptr_size = self.memory.pointer_size() as isize;\n-                            let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n-                            self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n-                        }\n-\n-                        _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n-                    }\n-                }\n+                let (size, _) = self.size_and_align_of_dst(ty, args_ptrs[0])?;\n+                self.memory.write_uint(dest, size, pointer_size)?;\n             }\n             // FIXME: wait for eval_operand_to_ptr to be gone\n             /*\n@@ -248,4 +234,114 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // current frame.\n         Ok(())\n     }\n+\n+    fn size_and_align_of_dst(\n+        &self,\n+        ty: ty::Ty<'tcx>,\n+        value: Pointer,\n+    ) -> EvalResult<'tcx, (u64, u64)> {\n+        let pointer_size = self.memory.pointer_size();\n+        if self.type_is_sized(ty) {\n+            Ok((self.type_size(ty) as u64, self.type_align(ty) as u64))\n+        } else {\n+            match ty.sty {\n+                ty::TyAdt(def, substs) => {\n+                    // First get the size of all statically known fields.\n+                    // Don't use type_of::sizing_type_of because that expects t to be sized,\n+                    // and it also rounds up to alignment, which we want to avoid,\n+                    // as the unsized field's alignment could be smaller.\n+                    assert!(!ty.is_simd());\n+                    let layout = self.type_layout(ty);\n+                    debug!(\"DST {} layout: {:?}\", ty, layout);\n+\n+                    // Returns size in bytes of all fields except the last one\n+                    // (we will be recursing on the last one).\n+                    fn local_prefix_bytes(variant: &ty::layout::Struct) -> u64 {\n+                        let fields = variant.offset_after_field.len();\n+                        if fields > 1 {\n+                            variant.offset_after_field[fields - 2].bytes()\n+                        } else {\n+                            0\n+                        }\n+                    }\n+\n+                    let (sized_size, sized_align) = match *layout {\n+                        ty::layout::Layout::Univariant { ref variant, .. } => {\n+                            (local_prefix_bytes(variant), variant.align.abi())\n+                        }\n+                        _ => {\n+                            bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n+                                 ty, layout);\n+                        }\n+                    };\n+                    debug!(\"DST {} statically sized prefix size: {} align: {}\",\n+                           ty, sized_size, sized_align);\n+\n+                    // Recurse to get the size of the dynamically sized field (must be\n+                    // the last field).\n+                    let last_field = def.struct_variant().fields.last().unwrap();\n+                    let field_ty = self.field_ty(substs, last_field);\n+                    let (unsized_size, unsized_align) = self.size_and_align_of_dst(field_ty, value)?;\n+\n+                    // FIXME (#26403, #27023): We should be adding padding\n+                    // to `sized_size` (to accommodate the `unsized_align`\n+                    // required of the unsized field that follows) before\n+                    // summing it with `sized_size`. (Note that since #26403\n+                    // is unfixed, we do not yet add the necessary padding\n+                    // here. But this is where the add would go.)\n+\n+                    // Return the sum of sizes and max of aligns.\n+                    let size = sized_size + unsized_size;\n+\n+                    // Choose max of two known alignments (combined value must\n+                    // be aligned according to more restrictive of the two).\n+                    let align = ::std::cmp::max(sized_align, unsized_align);\n+\n+                    // Issue #27023: must add any necessary padding to `size`\n+                    // (to make it a multiple of `align`) before returning it.\n+                    //\n+                    // Namely, the returned size should be, in C notation:\n+                    //\n+                    //   `size + ((size & (align-1)) ? align : 0)`\n+                    //\n+                    // emulated via the semi-standard fast bit trick:\n+                    //\n+                    //   `(size + (align-1)) & -align`\n+\n+                    if size & (align - 1) != 0 {\n+                        Ok((size + align, align))\n+                    } else {\n+                        Ok((size, align))\n+                    }\n+                }\n+                ty::TyTrait(..) => {\n+                    let (_, vtable) = self.get_fat_ptr(value);\n+                    let vtable = self.memory.read_ptr(vtable)?;\n+                    // the second entry in the vtable is the dynamic size of the object.\n+                    let size = self.memory.read_usize(vtable.offset(pointer_size as isize))?;\n+                    let align = self.memory.read_usize(vtable.offset(pointer_size as isize * 2))?;\n+                    Ok((size, align))\n+                }\n+\n+                ty::TySlice(_) | ty::TyStr => {\n+                    let elem_ty = ty.sequence_element_type(self.tcx);\n+                    let elem_size = self.type_size(elem_ty) as u64;\n+                    let (_, len_ptr) = self.get_fat_ptr(value);\n+                    let n = self.memory.read_usize(len_ptr)?;\n+                    let align = self.type_align(elem_ty);\n+                    Ok((n * elem_size, align as u64))\n+                }\n+\n+                _ => bug!(\"size_of_val::<{:?}>\", ty),\n+            }\n+        }\n+    }\n+    /// Returns the normalized type of a struct field\n+    fn field_ty(\n+        &self,\n+        param_substs: &Substs<'tcx>,\n+        f: ty::FieldDef<'tcx>,\n+    )-> ty::Ty<'tcx> {\n+        self.tcx.normalize_associated_type(&f.ty(self.tcx, param_substs))\n+    }\n }"}, {"sha": "980f9ca728bb57f631d762648feed7ddbdae6ded", "filename": "src/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f578f0d2ef1943d8a3a1123520eba90f926e757/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f578f0d2ef1943d8a3a1123520eba90f926e757/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=0f578f0d2ef1943d8a3a1123520eba90f926e757", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             bytes: Vec::new(),\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(0),\n-            align: 1,\n+            align: 8, // should be infinity?\n             immutable: false, // must be mutable, because sometimes we \"move out\" of a ZST\n         };\n         mem.alloc_map.insert(ZST_ALLOC_ID, alloc);"}, {"sha": "3a9f24ad4cc7c7bb1bef2788755583bb35d3b303", "filename": "tests/run-pass/cast-rfc0401-vtable-kinds.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs?ref=0f578f0d2ef1943d8a3a1123520eba90f926e757", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that you can cast between different pointers to trait objects\n+// whose vtable have the same kind (both lengths, or both trait pointers).\n+\n+trait Foo<T> {\n+    fn foo(&self, _: T) -> u32 { 42 }\n+}\n+\n+trait Bar {\n+    fn bar(&self) { println!(\"Bar!\"); }\n+}\n+\n+impl<T> Foo<T> for () {}\n+impl Foo<u32> for u32 { fn foo(&self, _: u32) -> u32 { self+43 } }\n+impl Bar for () {}\n+\n+unsafe fn round_trip_and_call<'a>(t: *const (Foo<u32>+'a)) -> u32 {\n+    let foo_e : *const Foo<u16> = t as *const _;\n+    let r_1 = foo_e as *mut Foo<u32>;\n+\n+    (&*r_1).foo(0)\n+}\n+\n+#[repr(C)]\n+struct FooS<T:?Sized>(T);\n+#[repr(C)]\n+struct BarS<T:?Sized>(T);\n+\n+fn foo_to_bar<T:?Sized>(u: *const FooS<T>) -> *const BarS<T> {\n+    u as *const BarS<T>\n+}\n+\n+fn main() {\n+    let x = 4u32;\n+    let y : &Foo<u32> = &x;\n+    let fl = unsafe { round_trip_and_call(y as *const Foo<u32>) };\n+    assert_eq!(fl, (43+4));\n+\n+    let s = FooS([0,1,2]);\n+    let u: &FooS<[u32]> = &s;\n+    let u: *const FooS<[u32]> = u;\n+    let bar_ref : *const BarS<[u32]> = foo_to_bar(u);\n+    let z : &BarS<[u32]> = unsafe{&*bar_ref};\n+    assert_eq!(&z.0, &[0,1,2]);\n+}"}, {"sha": "9f8067f372aef89cae35b5d49d1c7e952b192510", "filename": "tests/run-pass/dst-irrefutable-bind.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fdst-irrefutable-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fdst-irrefutable-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-irrefutable-bind.rs?ref=0f578f0d2ef1943d8a3a1123520eba90f926e757", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Test<T: ?Sized>(T);\n+\n+fn main() {\n+    let x = Test([1,2,3]);\n+    let x : &Test<[i32]> = &x;\n+\n+    let & ref _y = x;\n+\n+    // Make sure binding to a fat pointer behind a reference\n+    // still works\n+    let slice = &[1,2,3];\n+    let x = Test(&slice);\n+    let Test(&_slice) = x;\n+}"}, {"sha": "3a74626b0299f2be8af8229e70da2ad5ded479db", "filename": "tests/run-pass/dst-raw.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-raw.rs?ref=0f578f0d2ef1943d8a3a1123520eba90f926e757", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test DST raw pointers\n+\n+\n+trait Trait {\n+    fn foo(&self) -> isize;\n+}\n+\n+struct A {\n+    f: isize\n+}\n+impl Trait for A {\n+    fn foo(&self) -> isize {\n+        self.f\n+    }\n+}\n+\n+struct Foo<T: ?Sized> {\n+    f: T\n+}\n+\n+pub fn main() {\n+    // raw trait object\n+    let x = A { f: 42 };\n+    let z: *const Trait = &x;\n+    let r = unsafe {\n+        (&*z).foo()\n+    };\n+    assert_eq!(r, 42);\n+\n+    // raw DST struct\n+    let p = Foo {f: A { f: 42 }};\n+    let o: *const Foo<Trait> = &p;\n+    let r = unsafe {\n+        (&*o).f.foo()\n+    };\n+    assert_eq!(r, 42);\n+\n+    // raw slice\n+    let a: *const [_] = &[1, 2, 3];\n+    unsafe {\n+        let b = (*a)[2];\n+        assert_eq!(b, 3);\n+        let len = (*a).len();\n+        assert_eq!(len, 3);\n+    }\n+\n+    // raw slice with explicit cast\n+    let a = &[1, 2, 3] as *const [i32];\n+    unsafe {\n+        let b = (*a)[2];\n+        assert_eq!(b, 3);\n+        let len = (*a).len();\n+        assert_eq!(len, 3);\n+    }\n+\n+    // raw DST struct with slice\n+    let c: *const Foo<[_]> = &Foo {f: [1, 2, 3]};\n+    unsafe {\n+        let b = (&*c).f[0];\n+        assert_eq!(b, 1);\n+        let len = (&*c).f.len();\n+        assert_eq!(len, 3);\n+    }\n+\n+    // all of the above with *mut\n+    let mut x = A { f: 42 };\n+    let z: *mut Trait = &mut x;\n+    let r = unsafe {\n+        (&*z).foo()\n+    };\n+    assert_eq!(r, 42);\n+\n+    let mut p = Foo {f: A { f: 42 }};\n+    let o: *mut Foo<Trait> = &mut p;\n+    let r = unsafe {\n+        (&*o).f.foo()\n+    };\n+    assert_eq!(r, 42);\n+\n+    let a: *mut [_] = &mut [1, 2, 3];\n+    unsafe {\n+        let b = (*a)[2];\n+        assert_eq!(b, 3);\n+        let len = (*a).len();\n+        assert_eq!(len, 3);\n+    }\n+\n+    let a = &mut [1, 2, 3] as *mut [i32];\n+    unsafe {\n+        let b = (*a)[2];\n+        assert_eq!(b, 3);\n+        let len = (*a).len();\n+        assert_eq!(len, 3);\n+    }\n+\n+    let c: *mut Foo<[_]> = &mut Foo {f: [1, 2, 3]};\n+    unsafe {\n+        let b = (&*c).f[0];\n+        assert_eq!(b, 1);\n+        let len = (&*c).f.len();\n+        assert_eq!(len, 3);\n+    }\n+}"}, {"sha": "58d7b35a5275cc2de0351d2e97ecd6342818c05d", "filename": "tests/run-pass/dst-struct-sole.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-struct-sole.rs?ref=0f578f0d2ef1943d8a3a1123520eba90f926e757", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// As dst-struct.rs, but the unsized field is the only field in the struct.\n+\n+\n+struct Fat<T: ?Sized> {\n+    ptr: T\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[isize]>) {\n+    let y = &x.ptr;\n+    assert_eq!(x.ptr.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.ptr[1], 2);\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.ptr;\n+    let bar = Bar;\n+    assert_eq!(x.ptr.len(), 3);\n+    assert_eq!(y[0].to_bar(), bar);\n+    assert_eq!(x.ptr[1].to_bar(), bar);\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = Fat { ptr: [1, 2, 3] };\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[isize]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[isize]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[isize]> = &Fat { ptr: [1, 2, 3] };\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = Fat { ptr: [bar, bar, bar] };\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &Fat { ptr: [bar, bar, bar] };\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[isize]> = &mut Fat { ptr: [1, 2, 3] };\n+    f5.ptr[1] = 34;\n+    assert_eq!(f5.ptr[0], 1);\n+    assert_eq!(f5.ptr[1], 34);\n+    assert_eq!(f5.ptr[2], 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[isize]> = &Fat { ptr: [] };\n+    assert!(f5.ptr.is_empty());\n+    let f5: &Fat<[Bar]> = &Fat { ptr: [] };\n+    assert!(f5.ptr.is_empty());\n+}"}, {"sha": "fc806f5429a47c320a9c55a37aa204b8f3bdcf5a", "filename": "tests/run-pass/issue-23261.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fissue-23261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fissue-23261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-23261.rs?ref=0f578f0d2ef1943d8a3a1123520eba90f926e757", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Matching on a DST struct should not trigger an LLVM assertion.\n+\n+struct Foo<T: ?Sized> {\n+    a: i32,\n+    inner: T\n+}\n+\n+trait Get {\n+    fn get(&self) -> i32;\n+}\n+\n+impl Get for i32 {\n+    fn get(&self) -> i32 {\n+        *self\n+    }\n+}\n+\n+fn check_val(val: &Foo<[u8]>) {\n+    match *val {\n+        Foo { a, .. } => {\n+            assert_eq!(a, 32);\n+        }\n+    }\n+}\n+\n+fn check_dst_val(val: &Foo<[u8]>) {\n+    match *val {\n+        Foo { ref inner, .. } => {\n+            assert_eq!(inner, [1, 2, 3]);\n+        }\n+    }\n+}\n+\n+fn check_both(val: &Foo<[u8]>) {\n+    match *val {\n+        Foo { a, ref inner } => {\n+            assert_eq!(a, 32);\n+            assert_eq!(inner, [1, 2, 3]);\n+        }\n+    }\n+}\n+\n+fn check_trait_obj(val: &Foo<Get>) {\n+    match *val {\n+        Foo { a, ref inner } => {\n+            assert_eq!(a, 32);\n+            assert_eq!(inner.get(), 32);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let foo: &Foo<[u8]> = &Foo { a: 32, inner: [1, 2, 3] };\n+    check_val(foo);\n+    check_dst_val(foo);\n+    check_both(foo);\n+\n+    let foo: &Foo<Get> = &Foo { a: 32, inner: 32 };\n+    check_trait_obj(foo);\n+}"}, {"sha": "95269d0569dec11e7fb6532ee671b799be609217", "filename": "tests/run-pass/issue-36278-prefix-nesting.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fissue-36278-prefix-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fissue-36278-prefix-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-36278-prefix-nesting.rs?ref=0f578f0d2ef1943d8a3a1123520eba90f926e757", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 36278: On an unsized struct with >1 level of nontrivial\n+// nesting, ensure we are computing dynamic size of prefix correctly.\n+\n+use std::mem;\n+\n+const SZ: usize = 100;\n+struct P<T: ?Sized>([u8; SZ], T);\n+\n+type Ack<T> = P<P<T>>;\n+\n+fn main() {\n+    let size_of_sized; let size_of_unsized;\n+    let x: Box<Ack<[u8; 0]>> = Box::new(P([0; SZ], P([0; SZ], [0; 0])));\n+    size_of_sized = mem::size_of_val::<Ack<_>>(&x);\n+    let y: Box<Ack<[u8   ]>> = x;\n+    size_of_unsized = mem::size_of_val::<Ack<_>>(&y);\n+    assert_eq!(size_of_sized, size_of_unsized);\n+}"}, {"sha": "e5c9e3577d1c302a1cd6458eccf6019e01e1845b", "filename": "tests/run-pass/mir_fat_ptr.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fmir_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f578f0d2ef1943d8a3a1123520eba90f926e757/tests%2Frun-pass%2Fmir_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmir_fat_ptr.rs?ref=0f578f0d2ef1943d8a3a1123520eba90f926e757", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// test that ordinary fat pointer operations work.\n+\n+struct Wrapper<T: ?Sized>(u32, T);\n+\n+struct FatPtrContainer<'a> {\n+    ptr: &'a [u8]\n+}\n+\n+fn fat_ptr_project(a: &Wrapper<[u8]>) -> &[u8] {\n+    &a.1\n+}\n+\n+fn fat_ptr_simple(a: &[u8]) -> &[u8] {\n+    a\n+}\n+\n+fn fat_ptr_via_local(a: &[u8]) -> &[u8] {\n+    let x = a;\n+    x\n+}\n+\n+fn fat_ptr_from_struct(s: FatPtrContainer) -> &[u8] {\n+    s.ptr\n+}\n+\n+fn fat_ptr_to_struct(a: &[u8]) -> FatPtrContainer {\n+    FatPtrContainer { ptr: a }\n+}\n+\n+fn fat_ptr_store_to<'a>(a: &'a [u8], b: &mut &'a [u8]) {\n+    *b = a;\n+}\n+\n+fn fat_ptr_constant() -> &'static str {\n+    \"HELLO\"\n+}\n+\n+fn main() {\n+    let a = Wrapper(4, [7,6,5]);\n+\n+    let p = fat_ptr_project(&a);\n+    let p = fat_ptr_simple(p);\n+    let p = fat_ptr_via_local(p);\n+    let p = fat_ptr_from_struct(fat_ptr_to_struct(p));\n+\n+    let mut target : &[u8] = &[42];\n+    fat_ptr_store_to(p, &mut target);\n+    assert_eq!(target, &a.1);\n+\n+    assert_eq!(fat_ptr_constant(), \"HELLO\");\n+}"}]}