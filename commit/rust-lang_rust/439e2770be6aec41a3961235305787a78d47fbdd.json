{"sha": "439e2770be6aec41a3961235305787a78d47fbdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzOWUyNzcwYmU2YWVjNDFhMzk2MTIzNTMwNTc4N2E3OGQ0N2ZiZGQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-05T21:37:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-07T20:00:52Z"}, "message": "Extract privacy checking from name resolution\n\nThis commit is the culmination of my recent effort to refine Rust's notion of\nprivacy and visibility among crates. The major goals of this commit were to\nremove privacy checking from resolve for the sake of sane error messages, and to\nattempt a much more rigid and well-tested implementation of visibility\nthroughout rust. The implemented rules for name visibility are:\n\n1. Everything pub from the root namespace is visible to anyone\n2. You may access any private item of your ancestors.\n\n\"Accessing a private item\" depends on what the item is, so for a function this\nmeans that you can call it, but for a module it means that you can look inside\nof it. Once you look inside a private module, any accessed item must be \"pub\nfrom the root\" where the new root is the private module that you looked into.\nThese rules required some more analysis results to get propagated from trans to\nprivacy in the form of a few hash tables.\n\nI added a new test in which my goal was to showcase all of the privacy nuances\nof the language, and I hope to place any new bugs into this file to prevent\nregressions.\n\nOverall, I was unable to completely remove the notion of privacy from resolve.\nOne use of privacy is for dealing with glob imports. Essentially a glob import\ncan only import *public* items from the destination, and because this must be\ndone at namespace resolution time, resolve must maintain the notion of \"what\nitems are public in a module\". There are some sad approximations of privacy, but\nI unfortunately can't see clear methods to extract them outside.\n\nThe other use case of privacy in resolve now is one that must stick around\nregardless of glob imports. When dealing with privacy, checking a private path\nneeds to know \"what the last private thing was\" when looking at a path. Resolve\nis the only compiler pass which knows the answer to this question, so it\nmaintains the answer on a per-path resolution basis (works similarly to the\ndef_map generated).\n\nCloses #8215", "tree": {"sha": "33bd20091c1cb95f8123f88c2693c43e35dfa6df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33bd20091c1cb95f8123f88c2693c43e35dfa6df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/439e2770be6aec41a3961235305787a78d47fbdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/439e2770be6aec41a3961235305787a78d47fbdd", "html_url": "https://github.com/rust-lang/rust/commit/439e2770be6aec41a3961235305787a78d47fbdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/439e2770be6aec41a3961235305787a78d47fbdd/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eb28bb7dcd77ac9e804ab2d75b387ca3f47f9d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb28bb7dcd77ac9e804ab2d75b387ca3f47f9d4", "html_url": "https://github.com/rust-lang/rust/commit/8eb28bb7dcd77ac9e804ab2d75b387ca3f47f9d4"}], "stats": {"total": 2562, "additions": 1459, "deletions": 1103}, "files": [{"sha": "4681c37fce833262a82827bb99c980fbf6bde94e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -199,7 +199,6 @@ pub fn phase_2_configure_and_expand(sess: Session,\n \n pub struct CrateAnalysis {\n     exp_map2: middle::resolve::ExportMap2,\n-    exported_items: @middle::privacy::ExportedItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n     reachable: @mut HashSet<ast::NodeId>\n@@ -229,7 +228,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     let middle::resolve::CrateMap {\n         def_map: def_map,\n         exp_map2: exp_map2,\n-        trait_map: trait_map\n+        trait_map: trait_map,\n+        external_exports: external_exports,\n+        last_private_map: last_private_map\n     } =\n         time(time_passes, \"resolution\", (), |_|\n              middle::resolve::resolve_crate(sess, lang_items, crate));\n@@ -261,9 +262,10 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n          middle::check_const::check_crate(sess, crate, ast_map, def_map,\n                                           method_map, ty_cx));\n \n-    let exported_items =\n-        time(time_passes, \"privacy checking\", (), |_|\n-             middle::privacy::check_crate(ty_cx, &method_map, &exp_map2, crate));\n+    let maps = (external_exports, last_private_map);\n+    time(time_passes, \"privacy checking\", maps, |(a, b)|\n+         middle::privacy::check_crate(ty_cx, &method_map, &exp_map2,\n+                                      a, b, crate));\n \n     time(time_passes, \"effect checking\", (), |_|\n          middle::effect::check_crate(ty_cx, method_map, crate));\n@@ -305,7 +307,6 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n \n     CrateAnalysis {\n         exp_map2: exp_map2,\n-        exported_items: @exported_items,\n         ty_cx: ty_cx,\n         maps: astencode::Maps {\n             root_map: root_map,"}, {"sha": "be01d3cbfc9d5b68adf691b77c51c58e26648ba4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -837,8 +837,9 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                 let def_like = item_to_def_like(child_item_doc,\n                                                 child_def_id,\n                                                 cdata.cnum);\n-                callback(def_like, token::str_to_ident(name),\n-                         item_visibility(child_item_doc));\n+                // These items have a public visibility because they're part of\n+                // a public re-export.\n+                callback(def_like, token::str_to_ident(name), ast::public);\n             }\n         }\n "}, {"sha": "ad190dfcfb127530b484d88ed34ae1632f82fdb8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -58,7 +58,6 @@ pub struct EncodeParams<'self> {\n     diag: @mut span_handler,\n     tcx: ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n-    exported_items: @middle::privacy::ExportedItems,\n     item_symbols: &'self HashMap<ast::NodeId, ~str>,\n     discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n     non_inlineable_statics: &'self HashSet<ast::NodeId>,\n@@ -89,7 +88,6 @@ pub struct EncodeContext<'self> {\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n     reexports2: middle::resolve::ExportMap2,\n-    exported_items: @middle::privacy::ExportedItems,\n     item_symbols: &'self HashMap<ast::NodeId, ~str>,\n     discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n     non_inlineable_statics: &'self HashSet<ast::NodeId>,\n@@ -1277,12 +1275,7 @@ fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n             let mut ebml_w = ebml_w.clone();\n             // See above\n             let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n-            let vis = if ecx.exported_items.contains(&i.id) {\n-                ast::public\n-            } else {\n-                ast::inherited\n-            };\n-            encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, vis);\n+            encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, i.vis);\n         }\n         _ => fail2!(\"bad item\")\n     }\n@@ -1628,7 +1621,7 @@ impl<'self> Visitor<()> for ImplVisitor<'self> {\n \n                 // Load eagerly if this is an implementation of the Drop trait\n                 // or if the trait is not defined in this crate.\n-                if def_id == self.ecx.tcx.lang_items.drop_trait().unwrap() ||\n+                if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n                         def_id.crate != LOCAL_CRATE {\n                     self.ebml_w.start_tag(tag_impls_impl);\n                     encode_def_id(self.ebml_w, local_def(item.id));\n@@ -1744,7 +1737,6 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         diag,\n         tcx,\n         reexports2,\n-        exported_items,\n         discrim_symbols,\n         cstore,\n         encode_inlined_item,\n@@ -1760,7 +1752,6 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         tcx: tcx,\n         stats: stats,\n         reexports2: reexports2,\n-        exported_items: exported_items,\n         item_symbols: item_symbols,\n         discrim_symbols: discrim_symbols,\n         non_inlineable_statics: non_inlineable_statics,"}, {"sha": "f395231124b64c705f2ce5e30d3d7d4cd0a14722", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 647, "deletions": 575, "changes": 1222, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -12,221 +12,362 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-use std::hashmap::HashSet;\n+use std::hashmap::{HashSet, HashMap};\n \n-use metadata::csearch;\n-use middle::resolve::ExportMap2;\n-use middle::ty::{ty_struct, ty_enum};\n+use middle::resolve;\n use middle::ty;\n use middle::typeck::{method_map, method_origin, method_param};\n use middle::typeck::{method_static, method_object};\n \n-use std::util::ignore;\n-use syntax::ast::{DeclItem, Def, DefFn, DefId, DefStaticMethod};\n-use syntax::ast::{DefVariant, ExprField, ExprMethodCall, ExprPath};\n-use syntax::ast::{ExprStruct, ExprUnary, Ident, inherited, item_enum};\n-use syntax::ast::{item_foreign_mod, item_fn, item_impl, item_struct};\n-use syntax::ast::{item_trait, LOCAL_CRATE, NodeId, PatStruct, Path};\n-use syntax::ast::{private, provided, public, required, StmtDecl, visibility};\n use syntax::ast;\n-use syntax::ast_map::{node_foreign_item, node_item, node_method};\n-use syntax::ast_map::{node_trait_method};\n use syntax::ast_map;\n-use syntax::ast_util::{Private, Public, is_local};\n-use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n+use syntax::ast_util::is_local;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::opt_vec;\n use syntax::visit;\n use syntax::visit::Visitor;\n-use syntax::ast::{_mod,Expr,item,Block,Pat};\n \n-// This set is a set of all item nodes which can be used by external crates if\n-// we're building a library. The necessary qualifications for this are that all\n-// items leading down to the current item (excluding an `impl`) must be `pub`.\n-pub type ExportedItems = HashSet<NodeId>;\n+type Context<'self> = (&'self method_map, &'self resolve::ExportMap2);\n \n-type Context<'self> = (&'self method_map, &'self ExportMap2);\n-\n-struct PrivacyVisitor {\n-    tcx: ty::ctxt,\n-    privileged_items: @mut ~[NodeId],\n-\n-    // A set of all items which are re-exported to be used across crates\n-    exported_items: ExportedItems,\n-\n-    // A flag as to whether the current path is public all the way down to the\n-    // current point or not\n-    path_all_public: bool,\n+// This visitor is used to determine the parent of all nodes in question when it\n+// comes to privacy. This is used to determine later on if a usage is actually\n+// valid or not.\n+struct ParentVisitor<'self> {\n+    parents: &'self mut HashMap<ast::NodeId, ast::NodeId>,\n+    curparent: ast::NodeId,\n }\n \n-impl PrivacyVisitor {\n-    // Adds an item to its scope.\n-    fn add_privileged_item(&mut self, item: @ast::item, count: &mut uint) {\n+impl<'self> Visitor<()> for ParentVisitor<'self> {\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        self.parents.insert(item.id, self.curparent);\n+\n+        let prev = self.curparent;\n         match item.node {\n-            item_struct(*) | item_trait(*) | item_enum(*) |\n-            item_fn(*) => {\n-                self.privileged_items.push(item.id);\n-                *count += 1;\n-            }\n-            item_impl(_, _, _, ref methods) => {\n-                for method in methods.iter() {\n-                    self.privileged_items.push(method.id);\n-                    *count += 1;\n-                }\n-                self.privileged_items.push(item.id);\n-                *count += 1;\n-            }\n-            item_foreign_mod(ref foreign_mod) => {\n-                for foreign_item in foreign_mod.items.iter() {\n-                    self.privileged_items.push(foreign_item.id);\n-                    *count += 1;\n+            ast::item_mod(*) => { self.curparent = item.id; }\n+            // Enum variants are parented to the enum definition itself beacuse\n+            // they inherit privacy\n+            ast::item_enum(ref def, _) => {\n+                for variant in def.variants.iter() {\n+                    // If variants are private, then their logical \"parent\" is\n+                    // the enclosing module because everyone in the enclosing\n+                    // module can still use the private variant\n+                    if variant.node.vis == ast::private {\n+                        self.parents.insert(variant.node.id, self.curparent);\n+\n+                    // Otherwise, if the variant is public, then the parent is\n+                    // considered the enclosing enum because the enum will\n+                    // dictate the privacy visibility of this variant instead.\n+                    } else {\n+                        self.parents.insert(variant.node.id, item.id);\n+                    }\n                 }\n             }\n             _ => {}\n         }\n+        visit::walk_item(self, item, ());\n+        self.curparent = prev;\n     }\n \n-    // Adds items that are privileged to this scope.\n-    fn add_privileged_items(&mut self, items: &[@ast::item]) -> uint {\n-        let mut count = 0;\n-        for &item in items.iter() {\n-            self.add_privileged_item(item, &mut count);\n-        }\n-        count\n+    fn visit_trait_method(&mut self, m: &ast::trait_method, _: ()) {\n+        match *m {\n+            ast::provided(ref m) => self.parents.insert(m.id, self.curparent),\n+            ast::required(ref m) => self.parents.insert(m.id, self.curparent),\n+        };\n+        visit::walk_trait_method(self, m, ());\n     }\n \n-    // Checks that an enum variant is in scope\n-    fn check_variant(&mut self, span: Span, enum_id: ast::DefId) {\n-        let variant_info = ty::enum_variants(self.tcx, enum_id)[0];\n-        let parental_privacy = if is_local(enum_id) {\n-            let parent_vis = ast_map::node_item_query(self.tcx.items,\n-                                                      enum_id.node,\n-                                   |it| { it.vis },\n-                                   ~\"unbound enum parent when checking \\\n-                                    dereference of enum type\");\n-            visibility_to_privacy(parent_vis)\n+    fn visit_foreign_item(&mut self, a: @ast::foreign_item, _: ()) {\n+        self.parents.insert(a.id, self.curparent);\n+        visit::walk_foreign_item(self, a, ());\n+    }\n+\n+    fn visit_fn(&mut self, a: &visit::fn_kind, b: &ast::fn_decl,\n+                c: &ast::Block, d: Span, id: ast::NodeId, _: ()) {\n+        self.parents.insert(id, self.curparent);\n+        visit::walk_fn(self, a, b, c, d, id, ());\n+    }\n+\n+    fn visit_struct_def(&mut self, s: @ast::struct_def, i: ast::Ident,\n+                        g: &ast::Generics, n: ast::NodeId, _: ()) {\n+        // Struct constructors are parented to their struct definitions because\n+        // they essentially are the struct definitions.\n+        match s.ctor_id {\n+            Some(id) => { self.parents.insert(id, n); }\n+            None => {}\n         }\n-        else {\n-            // WRONG\n-            Public\n-        };\n-        debug2!(\"parental_privacy = {:?}\", parental_privacy);\n-        debug2!(\"vis = {:?}, priv = {:?}\",\n-               variant_info.vis,\n-               visibility_to_privacy(variant_info.vis))\n-        // inherited => privacy of the enum item\n-        if variant_visibility_to_privacy(variant_info.vis,\n-                                         parental_privacy == Public)\n-                                         == Private {\n-            self.tcx.sess.span_err(span,\n-                \"can only dereference enums \\\n-                 with a single, public variant\");\n+\n+        // While we have the id of the struct definition, go ahead and parent\n+        // all the fields.\n+        for field in s.fields.iter() {\n+            let vis = match field.node.kind {\n+                ast::named_field(_, vis) => vis,\n+                ast::unnamed_field => continue\n+            };\n+\n+            // Private fields are scoped to this module, so parent them directly\n+            // to the module instead of the struct. This is similar to the case\n+            // of private enum variants.\n+            if vis == ast::private {\n+                self.parents.insert(field.node.id, self.curparent);\n+\n+            // Otherwise public fields are scoped to the visibility of the\n+            // struct itself\n+            } else {\n+                self.parents.insert(field.node.id, n);\n+            }\n         }\n+        visit::walk_struct_def(self, s, i, g, n, ())\n     }\n+}\n \n-    // Returns true if a crate-local method is private and false otherwise.\n-    fn method_is_private(&mut self, span: Span, method_id: NodeId) -> bool {\n-        let check = |vis: visibility, container_id: DefId| {\n-            let mut is_private = false;\n-            if vis == private {\n-                is_private = true;\n-            } else if vis == public {\n-                is_private = false;\n-            } else {\n-                // Look up the enclosing impl.\n-                if container_id.crate != LOCAL_CRATE {\n-                    self.tcx.sess.span_bug(span,\n-                                      \"local method isn't in local \\\n-                                       impl?!\");\n-                }\n+// This visitor is used to determine which items of the ast are embargoed,\n+// otherwise known as not exported.\n+struct EmbargoVisitor<'self> {\n+    exported_items: &'self mut HashSet<ast::NodeId>,\n+    exp_map2: &'self resolve::ExportMap2,\n+    path_all_public: bool,\n+}\n \n-                match self.tcx.items.find(&container_id.node) {\n-                    Some(&node_item(item, _)) => {\n-                        match item.node {\n-                            item_impl(_, None, _, _)\n-                                    if item.vis != public => {\n-                                is_private = true;\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                    Some(_) => {\n-                        self.tcx.sess.span_bug(span, \"impl wasn't an item?!\");\n-                    }\n-                    None => {\n-                        self.tcx.sess.span_bug(span, \"impl wasn't in AST map?!\");\n+impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        let orig_all_pub = self.path_all_public;\n+        match item.node {\n+            // impls/extern blocks do not break the \"public chain\" because they\n+            // cannot have visibility qualifiers on them anyway\n+            ast::item_impl(*) | ast::item_foreign_mod(*) => {}\n+\n+            // Private by default, hence we only retain the \"public chain\" if\n+            // `pub` is explicitly listed.\n+            _ => {\n+                self.path_all_public = orig_all_pub && item.vis == ast::public;\n+            }\n+        }\n+\n+        if self.path_all_public {\n+            self.exported_items.insert(item.id);\n+        }\n+\n+        match item.node {\n+            // Enum variants inherit from their parent, so if the enum is\n+            // public all variants are public unless they're explicitly priv\n+            ast::item_enum(ref def, _) if self.path_all_public => {\n+                for variant in def.variants.iter() {\n+                    if variant.node.vis != ast::private {\n+                        self.exported_items.insert(variant.node.id);\n                     }\n                 }\n             }\n \n-            is_private\n-        };\n-\n-        match self.tcx.items.find(&method_id) {\n-            Some(&node_method(method, impl_id, _)) => {\n-                check(method.vis, impl_id)\n+            // Methods which are public at the source are totally public.\n+            ast::item_impl(_, None, _, ref methods) => {\n+                for method in methods.iter() {\n+                    let public = match method.explicit_self.node {\n+                        ast::sty_static => self.path_all_public,\n+                        _ => true,\n+                    } && method.vis == ast::public;\n+                    if public {\n+                        self.exported_items.insert(method.id);\n+                    }\n+                }\n             }\n-            Some(&node_trait_method(trait_method, trait_id, _)) => {\n-                match *trait_method {\n-                    required(_) => check(public, trait_id),\n-                    provided(method) => check(method.vis, trait_id),\n+\n+            // Trait implementation methods are all completely public\n+            ast::item_impl(_, Some(*), _, ref methods) => {\n+                for method in methods.iter() {\n+                    debug2!(\"exporting: {}\", method.id);\n+                    self.exported_items.insert(method.id);\n                 }\n             }\n-            Some(_) => {\n-                self.tcx.sess.span_bug(span,\n-                                  format!(\"method_is_private: method was a {}?!\",\n-                                       ast_map::node_id_to_str(\n-                                            self.tcx.items,\n-                                            method_id,\n-                                           token::get_ident_interner())));\n+\n+            // Default methods on traits are all public so long as the trait is\n+            // public\n+            ast::item_trait(_, _, ref methods) if self.path_all_public => {\n+                for method in methods.iter() {\n+                    match *method {\n+                        ast::provided(ref m) => {\n+                            debug2!(\"provided {}\", m.id);\n+                            self.exported_items.insert(m.id);\n+                        }\n+                        ast::required(ref m) => {\n+                            debug2!(\"required {}\", m.id);\n+                            self.exported_items.insert(m.id);\n+                        }\n+                    }\n+                }\n             }\n-            None => {\n-                self.tcx.sess.span_bug(span, \"method not found in \\\n-                                         AST map?!\");\n+\n+            // Default methods on traits are all public so long as the trait is\n+            // public\n+            ast::item_struct(ref def, _) if self.path_all_public => {\n+                match def.ctor_id {\n+                    Some(id) => { self.exported_items.insert(id); }\n+                    None => {}\n+                }\n             }\n+\n+            _ => {}\n         }\n+\n+        visit::walk_item(self, item, ());\n+\n+        self.path_all_public = orig_all_pub;\n     }\n \n-    // Returns true if the given local item is private and false otherwise.\n-    fn local_item_is_private(&mut self, span: Span, item_id: NodeId) -> bool {\n-        let mut f: &fn(NodeId) -> bool = |_| false;\n-        f = |item_id| {\n-            match self.tcx.items.find(&item_id) {\n-                Some(&node_item(item, _)) => item.vis != public,\n-                Some(&node_foreign_item(*)) => false,\n-                Some(&node_method(method, impl_did, _)) => {\n-                    match method.vis {\n-                        private => true,\n-                        public => false,\n-                        inherited => f(impl_did.node)\n+    fn visit_foreign_item(&mut self, a: @ast::foreign_item, _: ()) {\n+        if self.path_all_public && a.vis == ast::public {\n+            self.exported_items.insert(a.id);\n+        }\n+    }\n+}\n+\n+struct PrivacyVisitor<'self> {\n+    tcx: ty::ctxt,\n+    curitem: ast::NodeId,\n+\n+    // Results of previous analyses necessary for privacy checking.\n+    exported_items: &'self HashSet<ast::NodeId>,\n+    method_map: &'self method_map,\n+    parents: &'self HashMap<ast::NodeId, ast::NodeId>,\n+    external_exports: resolve::ExternalExports,\n+    last_private_map: resolve::LastPrivateMap,\n+}\n+\n+impl<'self> PrivacyVisitor<'self> {\n+    // used when debugging\n+    fn nodestr(&self, id: ast::NodeId) -> ~str {\n+        ast_map::node_id_to_str(self.tcx.items, id, token::get_ident_interner())\n+    }\n+\n+    // Determines whether the given definition is public from the point of view\n+    // of the current item.\n+    fn def_public(&self, did: ast::DefId) -> bool {\n+        if !is_local(did) {\n+            if self.external_exports.contains(&did) {\n+                debug2!(\"privacy - {:?} was externally exported\", did);\n+                return true;\n+            }\n+            debug2!(\"privacy - is {:?} a public method\", did);\n+            return match self.tcx.methods.find(&did) {\n+                Some(meth) => {\n+                    debug2!(\"privacy - well at least it's a method: {:?}\", meth);\n+                    match meth.container {\n+                        ty::TraitContainer(id) => {\n+                            debug2!(\"privacy - recursing on trait {:?}\", id);\n+                            self.def_public(id)\n+                        }\n+                        ty::ImplContainer(id) => {\n+                            match ty::impl_trait_ref(self.tcx, id) {\n+                                Some(t) => {\n+                                    debug2!(\"privacy - impl of trait {:?}\", id);\n+                                    self.def_public(t.def_id)\n+                                }\n+                                None => {\n+                                    debug2!(\"privacy - found a method {:?}\",\n+                                            meth.vis);\n+                                    meth.vis == ast::public\n+                                }\n+                            }\n+                        }\n                     }\n                 }\n-                Some(&node_trait_method(_, trait_did, _)) => f(trait_did.node),\n-                Some(_) => {\n-                    self.tcx.sess.span_bug(span,\n-                                      format!(\"local_item_is_private: item was \\\n-                                            a {}?!\",\n-                                           ast_map::node_id_to_str(\n-                                                self.tcx.items,\n-                                                item_id,\n-                                               token::get_ident_interner())));\n-                }\n                 None => {\n-                    self.tcx.sess.span_bug(span, \"item not found in AST map?!\");\n+                    debug2!(\"privacy - nope, not even a method\");\n+                    false\n                 }\n+            };\n+        } else if self.exported_items.contains(&did.node) {\n+            debug2!(\"privacy - exported item {}\", self.nodestr(did.node));\n+            return true;\n+        }\n+\n+        debug2!(\"privacy - local {:?} not public all the way down\", did);\n+        // return quickly for things in the same module\n+        if self.parents.find(&did.node) == self.parents.find(&self.curitem) {\n+            debug2!(\"privacy - same parent, we're done here\");\n+            return true;\n+        }\n+\n+        // We now know that there is at least one private member between the\n+        // destination and the root.\n+        let mut closest_private_id = did.node;\n+        loop {\n+            debug2!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n+            let vis = match self.tcx.items.find(&closest_private_id) {\n+                Some(&ast_map::node_item(it, _)) => it.vis,\n+                Some(&ast_map::node_method(ref m, _, _)) => m.vis,\n+                Some(&ast_map::node_foreign_item(_, _, v, _)) => v,\n+                Some(&ast_map::node_variant(ref v, _, _)) => {\n+                    // sadly enum variants still inherit visibility, so only\n+                    // break out of this is explicitly private\n+                    if v.node.vis == ast::private { break }\n+                    ast::public // need to move up a level (to the enum)\n+                }\n+                _ => ast::public,\n+            };\n+            if vis != ast::public { break }\n+            closest_private_id = *self.parents.get(&closest_private_id);\n+\n+            // If we reached the top, then we should have been public all the\n+            // way down in the first place...\n+            assert!(closest_private_id != ast::DUMMY_NODE_ID);\n+        }\n+        debug2!(\"privacy - closest priv {}\", self.nodestr(closest_private_id));\n+        return self.private_accessible(closest_private_id);\n+    }\n+\n+    /// For a local private node in the AST, this function will determine\n+    /// whether the node is accessible by the current module that iteration is\n+    /// inside.\n+    fn private_accessible(&self, id: ast::NodeId) -> bool {\n+        let parent = *self.parents.get(&id);\n+        debug2!(\"privacy - accessible parent {}\", self.nodestr(parent));\n+\n+        // After finding `did`'s closest private member, we roll ourselves back\n+        // to see if this private member's parent is anywhere in our ancestry.\n+        // By the privacy rules, we can access all of our ancestor's private\n+        // members, so that's why we test the parent, and not the did itself.\n+        let mut cur = self.curitem;\n+        loop {\n+            debug2!(\"privacy - questioning {}\", self.nodestr(cur));\n+            match cur {\n+                // If the relevant parent is in our history, then we're allowed\n+                // to look inside any of our ancestor's immediate private items,\n+                // so this access is valid.\n+                x if x == parent => return true,\n+\n+                // If we've reached the root, then we couldn't access this item\n+                // in the first place\n+                ast::DUMMY_NODE_ID => return false,\n+\n+                // Keep going up\n+                _ => {}\n             }\n-        };\n-        f(item_id)\n+\n+            cur = *self.parents.get(&cur);\n+        }\n     }\n \n-    // Checks that a private field is in scope.\n+    // Checks that a dereference of a univariant enum can occur.\n+    fn check_variant(&self, span: Span, enum_id: ast::DefId) {\n+        let variant_info = ty::enum_variants(self.tcx, enum_id)[0];\n+        if !self.def_public(variant_info.id) {\n+            self.tcx.sess.span_err(span, \"can only dereference enums \\\n+                                          with a single, public variant\");\n+        }\n+    }\n+\n+    // Checks that a field is in scope.\n     // FIXME #6993: change type (and name) from Ident to Name\n     fn check_field(&mut self, span: Span, id: ast::DefId, ident: ast::Ident) {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         for field in fields.iter() {\n             if field.name != ident.name { continue; }\n-            if field.vis == private {\n+            // public fields are public everywhere\n+            if field.vis != ast::private { break }\n+            if !is_local(field.id) ||\n+               !self.private_accessible(field.id.node) {\n                 self.tcx.sess.span_err(span, format!(\"field `{}` is private\",\n                                              token::ident_to_str(&ident)));\n             }\n@@ -235,78 +376,59 @@ impl PrivacyVisitor {\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n-    fn check_method_common(&mut self, span: Span, method_id: DefId, name: &Ident) {\n+    fn check_static_method(&mut self, span: Span, method_id: ast::DefId,\n+                           name: &ast::Ident) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n-        // Having to do this this is really unfortunate.\n-        let method_id = ty::method(self.tcx, method_id).provided_source.unwrap_or(method_id);\n-\n-        if method_id.crate == LOCAL_CRATE {\n-            let is_private = self.method_is_private(span, method_id.node);\n-            let container_id = ty::method(self.tcx, method_id).container_id();\n-            if is_private &&\n-                    (container_id.crate != LOCAL_CRATE ||\n-                     !self.privileged_items.iter().any(|x| x == &(container_id.node))) {\n-                self.tcx.sess.span_err(span,\n-                                  format!(\"method `{}` is private\",\n-                                       token::ident_to_str(name)));\n-            }\n-        } else {\n-            let visibility =\n-                csearch::get_item_visibility(self.tcx.sess.cstore, method_id);\n-            if visibility != public {\n-                self.tcx.sess.span_err(span,\n-                                  format!(\"method `{}` is private\",\n-                                       token::ident_to_str(name)));\n-            }\n+        let method_id = ty::method(self.tcx, method_id).provided_source\n+                                                       .unwrap_or(method_id);\n+\n+        if !self.def_public(method_id) {\n+            debug2!(\"private: {:?}\", method_id);\n+            self.tcx.sess.span_err(span, format!(\"method `{}` is private\",\n+                                                 token::ident_to_str(name)));\n         }\n     }\n \n-    // Checks that a private path is in scope.\n-    fn check_path(&mut self, span: Span, def: Def, path: &Path) {\n-        debug2!(\"checking path\");\n-        match def {\n-            DefStaticMethod(method_id, _, _) => {\n-                debug2!(\"found static method def, checking it\");\n-                self.check_method_common(span,\n-                                         method_id,\n-                                         &path.segments.last().identifier)\n-            }\n-            DefFn(def_id, _) => {\n-                if def_id.crate == LOCAL_CRATE {\n-                    if self.local_item_is_private(span, def_id.node) &&\n-                            !self.privileged_items.iter().any(|x| x == &def_id.node) {\n-                        self.tcx.sess.span_err(span,\n-                                          format!(\"function `{}` is private\",\n-                                               token::ident_to_str(\n-                                                &path.segments\n-                                                     .last()\n-                                                     .identifier)));\n-                    }\n-                //} else if csearch::get_item_visibility(self.tcx.sess.cstore,\n-                //                                       def_id) != public {\n-                //    self.tcx.sess.span_err(span,\n-                //                      format!(\"function `{}` is private\",\n-                //                           token::ident_to_str(\n-                //                                &path.segments\n-                //                                     .last()\n-                //                                     .identifier)));\n-                }\n-                // If this is a function from a non-local crate, then the\n-                // privacy check is enforced during resolve. All public items\n-                // will be tagged as such in the crate metadata and then usage\n-                // of the private items will be blocked during resolve. Hence,\n-                // if this isn't from the local crate, nothing to check.\n+    // Checks that a path is in scope.\n+    fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n+        debug2!(\"privacy - path {}\", self.nodestr(path_id));\n+        let ck = |tyname: &str| {\n+            let last_private = *self.last_private_map.get(&path_id);\n+            debug2!(\"privacy - {:?}\", last_private);\n+            let public = match last_private {\n+                resolve::AllPublic => true,\n+                resolve::DependsOn(def) => self.def_public(def),\n+            };\n+            if !public {\n+                debug2!(\"denying {:?}\", path);\n+                let name = token::ident_to_str(&path.segments.last()\n+                                                    .identifier);\n+                self.tcx.sess.span_err(span,\n+                                  format!(\"{} `{}` is private\", tyname, name));\n             }\n+        };\n+        match self.tcx.def_map.get_copy(&path_id) {\n+            ast::DefStaticMethod(*) => ck(\"static method\"),\n+            ast::DefFn(*) => ck(\"function\"),\n+            ast::DefStatic(*) => ck(\"static\"),\n+            ast::DefVariant(*) => ck(\"variant\"),\n+            ast::DefTy(*) => ck(\"type\"),\n+            ast::DefTrait(*) => ck(\"trait\"),\n+            ast::DefStruct(*) => ck(\"struct\"),\n+            ast::DefMethod(_, Some(*)) => ck(\"trait method\"),\n+            ast::DefMethod(*) => ck(\"method\"),\n+            ast::DefMod(*) => ck(\"module\"),\n             _ => {}\n         }\n     }\n \n-    // Checks that a private method is in scope.\n-    fn check_method(&mut self, span: Span, origin: &method_origin, ident: ast::Ident) {\n+    // Checks that a method is in scope.\n+    fn check_method(&mut self, span: Span, origin: &method_origin,\n+                    ident: ast::Ident) {\n         match *origin {\n             method_static(method_id) => {\n-                self.check_method_common(span, method_id, &ident)\n+                self.check_static_method(span, method_id, &ident)\n             }\n             method_param(method_param {\n                 trait_id: trait_id,\n@@ -318,426 +440,376 @@ impl PrivacyVisitor {\n                 method_num: method_num,\n                  _\n             }) => {\n-                if trait_id.crate == LOCAL_CRATE {\n-                    match self.tcx.items.find(&trait_id.node) {\n-                        Some(&node_item(item, _)) => {\n-                            match item.node {\n-                                item_trait(_, _, ref methods) => {\n-                                    if method_num >= (*methods).len() {\n-                                        self.tcx.sess.span_bug(span,\n-                                                               \"method number out of range?!\");\n+                if !self.def_public(trait_id) {\n+                    self.tcx.sess.span_err(span, \"source trait is private\");\n+                    return;\n+                }\n+                match self.tcx.items.find(&trait_id.node) {\n+                    Some(&ast_map::node_item(item, _)) => {\n+                        match item.node {\n+                            ast::item_trait(_, _, ref methods) => {\n+                                match methods[method_num] {\n+                                    ast::provided(ref method) => {\n+                                        let def = ast::DefId {\n+                                            node: method.id,\n+                                            crate: trait_id.crate,\n+                                        };\n+                                        if self.def_public(def) { return }\n+                                        let msg = format!(\"method `{}` is \\\n+                                                           private\",\n+                                                          token::ident_to_str(\n+                                                              &method.ident));\n+                                        self.tcx.sess.span_err(span, msg);\n                                     }\n-                                    match (*methods)[method_num] {\n-                                        provided(method)\n-                                             if method.vis == private &&\n-                                             !self.privileged_items.iter()\n-                                             .any(|x| x == &(trait_id.node)) => {\n-                                            self.tcx.sess.span_err(span,\n-                                                              format!(\"method `{}` is private\",\n-                                                                   token::ident_to_str(&method\n-                                                                                        .ident)));\n-                                        }\n-                                        provided(_) | required(_) => {\n-                                            // Required methods can't be\n-                                            // private.\n-                                        }\n+                                    ast::required(_) => {\n+                                        // Required methods can't be private.\n                                     }\n                                 }\n-                                _ => {\n-                                    self.tcx.sess.span_bug(span, \"trait wasn't actually a trait?!\");\n-                                }\n                             }\n-                        }\n-                        Some(_) => {\n-                            self.tcx.sess.span_bug(span, \"trait wasn't an item?!\");\n-                        }\n-                        None => {\n-                            self.tcx.sess.span_bug(span,\n-                                                   \"trait item wasn't found in the AST map?!\");\n+                            _ => self.tcx.sess.span_bug(span, \"trait wasn't \\\n+                                                               actually a trait?!\"),\n                         }\n                     }\n-                } else {\n-                    // FIXME #4732: External crates.\n+                    Some(_) => self.tcx.sess.span_bug(span, \"trait wasn't an \\\n+                                                             item?!\"),\n+                    None => self.tcx.sess.span_bug(span, \"trait item wasn't \\\n+                                                          found in the AST \\\n+                                                          map?!\"),\n                 }\n             }\n         }\n     }\n-}\n-\n-impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n-\n-    fn visit_mod(&mut self, the_module:&_mod, _:Span, _:NodeId,\n-                 cx: Context<'self>) {\n-\n-            let n_added = self.add_privileged_items(the_module.items);\n \n-            visit::walk_mod(self, the_module, cx);\n-\n-            do n_added.times {\n-                ignore(self.privileged_items.pop());\n+    /// Validates all of the visibility qualifers placed on the item given. This\n+    /// ensures that there are no extraneous qualifiers that don't actually do\n+    /// anything. In theory these qualifiers wouldn't parse, but that may happen\n+    /// later on down the road...\n+    fn check_sane_privacy(&self, item: @ast::item) {\n+        let tcx = self.tcx;\n+        let check_inherited = |sp: Span, vis: ast::visibility, note: &str| {\n+            if vis != ast::inherited {\n+                tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n+                if note.len() > 0 {\n+                    tcx.sess.span_note(sp, note);\n+                }\n             }\n-    }\n-\n-    fn visit_item(&mut self, item:@item, cx: Context<'self>) {\n-\n-        // Do not check privacy inside items with the resolve_unexported\n-        // attribute. This is used for the test runner.\n-        if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n-            return;\n-        }\n-\n-        // Disallow unnecessary visibility qualifiers\n-        check_sane_privacy(self.tcx, item);\n-\n-        // Keep track of whether this item is available for export or not.\n-        let orig_all_pub = self.path_all_public;\n+        };\n+        let check_not_priv = |sp: Span, vis: ast::visibility, note: &str| {\n+            if vis == ast::private {\n+                tcx.sess.span_err(sp, \"unnecessary `priv` qualifier\");\n+                if note.len() > 0 {\n+                    tcx.sess.span_note(sp, note);\n+                }\n+            }\n+        };\n         match item.node {\n-            // impls/extern blocks do not break the \"public chain\" because they\n-            // cannot have visibility qualifiers on them anyway\n-            ast::item_impl(*) | ast::item_foreign_mod(*) => {}\n-\n-            // Private by default, hence we only retain the \"public chain\" if\n-            // `pub` is explicitly listed.\n-            _ => {\n-                self.path_all_public = orig_all_pub && item.vis == ast::public;\n+            // implementations of traits don't need visibility qualifiers because\n+            // that's controlled by having the trait in scope.\n+            ast::item_impl(_, Some(*), _, ref methods) => {\n+                check_inherited(item.span, item.vis,\n+                                \"visibility qualifiers have no effect on trait \\\n+                                 impls\");\n+                for m in methods.iter() {\n+                    check_inherited(m.span, m.vis, \"\");\n+                }\n             }\n-        }\n-        debug2!(\"public path at {}: {}\", item.id, self.path_all_public);\n \n-        if self.path_all_public {\n-            debug2!(\"all the way public {}\", item.id);\n-            self.exported_items.insert(item.id);\n+            ast::item_impl(_, _, _, ref methods) => {\n+                check_inherited(item.span, item.vis,\n+                                \"place qualifiers on individual methods instead\");\n+                for i in methods.iter() {\n+                    check_not_priv(i.span, i.vis, \"functions are private by \\\n+                                                   default\");\n+                }\n+            }\n+            ast::item_foreign_mod(ref fm) => {\n+                check_inherited(item.span, item.vis,\n+                                \"place qualifiers on individual functions \\\n+                                 instead\");\n+                for i in fm.items.iter() {\n+                    check_not_priv(i.span, i.vis, \"functions are private by \\\n+                                                   default\");\n+                }\n+            }\n \n-            // All re-exported items in a module which is public should also be\n-            // public (in terms of how they should get encoded)\n-            match item.node {\n-                ast::item_mod(*) => {\n-                    let (_, exp_map2) = cx;\n-                    match exp_map2.find(&item.id) {\n-                        Some(exports) => {\n-                            for export in exports.iter() {\n-                                if export.reexport && is_local(export.def_id) {\n-                                    debug2!(\"found reexported {:?}\", export);\n-                                    let id = export.def_id.node;\n-                                    self.exported_items.insert(id);\n-                                }\n+            ast::item_enum(ref def, _) => {\n+                for v in def.variants.iter() {\n+                    match v.node.vis {\n+                        ast::public => {\n+                            if item.vis == ast::public {\n+                                tcx.sess.span_err(v.span, \"unnecessary `pub` \\\n+                                                           visibility\");\n+                            }\n+                        }\n+                        ast::private => {\n+                            if item.vis != ast::public {\n+                                tcx.sess.span_err(v.span, \"unnecessary `priv` \\\n+                                                           visibility\");\n                             }\n                         }\n-                        None => {}\n+                        ast::inherited => {}\n                     }\n                 }\n-                _ => {}\n             }\n-        }\n-\n-        visit::walk_item(self, item, cx);\n-\n-        self.path_all_public = orig_all_pub;\n-    }\n-\n-    fn visit_block(&mut self, block:&Block, cx: Context<'self>) {\n \n-            // Gather up all the privileged items.\n-            let mut n_added = 0;\n-            for stmt in block.stmts.iter() {\n-                match stmt.node {\n-                    StmtDecl(decl, _) => {\n-                        match decl.node {\n-                            DeclItem(item) => {\n-                                self.add_privileged_item(item, &mut n_added);\n-                            }\n-                            _ => {}\n+            ast::item_struct(ref def, _) => {\n+                for f in def.fields.iter() {\n+                   match f.node.kind {\n+                        ast::named_field(_, ast::public) => {\n+                            tcx.sess.span_err(f.span, \"unnecessary `pub` \\\n+                                                       visibility\");\n                         }\n+                        ast::named_field(_, ast::private) => {\n+                            // Fields should really be private by default...\n+                        }\n+                        ast::named_field(*) | ast::unnamed_field => {}\n                     }\n-                    _ => {}\n                 }\n             }\n \n-            visit::walk_block(self, block, cx);\n+            ast::item_trait(_, _, ref methods) => {\n+                for m in methods.iter() {\n+                    match *m {\n+                        ast::provided(ref m) => {\n+                            check_inherited(m.span, m.vis,\n+                                            \"unnecessary visibility\");\n+                        }\n+                        ast::required(*) => {}\n+                    }\n+                }\n+            }\n \n-            do n_added.times {\n-                ignore(self.privileged_items.pop());\n+            ast::item_static(*) |\n+            ast::item_fn(*) | ast::item_mod(*) | ast::item_ty(*) |\n+            ast::item_mac(*) => {\n+                check_not_priv(item.span, item.vis, \"items are private by \\\n+                                                     default\");\n             }\n+        }\n+    }\n+}\n+\n+impl<'self> Visitor<()> for PrivacyVisitor<'self> {\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        // Do not check privacy inside items with the resolve_unexported\n+        // attribute. This is used for the test runner.\n+        if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n+            return;\n+        }\n+\n+        // Disallow unnecessary visibility qualifiers\n+        self.check_sane_privacy(item);\n \n+        let orig_curitem = self.curitem;\n+        self.curitem = item.id;\n+        visit::walk_item(self, item, ());\n+        self.curitem = orig_curitem;\n     }\n \n-    fn visit_expr(&mut self, expr:@Expr, cx: Context<'self>) {\n-        let (method_map, _) = cx;\n-            match expr.node {\n-                ExprField(base, ident, _) => {\n-                    // Method calls are now a special syntactic form,\n-                    // so `a.b` should always be a field.\n-                    assert!(!method_map.contains_key(&expr.id));\n-\n-                    // With type_autoderef, make sure we don't\n-                    // allow pointers to violate privacy\n-                    match ty::get(ty::type_autoderef(self.tcx, ty::expr_ty(self.tcx,\n-                                                          base))).sty {\n-                        ty_struct(id, _)\n-                        if id.crate != LOCAL_CRATE || !self.privileged_items.iter()\n-                                .any(|x| x == &(id.node)) => {\n-                            debug2!(\"(privacy checking) checking field access\");\n-                            self.check_field(expr.span, id, ident);\n-                        }\n-                        _ => {}\n-                    }\n+    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n+        match expr.node {\n+            ast::ExprField(base, ident, _) => {\n+                // Method calls are now a special syntactic form,\n+                // so `a.b` should always be a field.\n+                assert!(!self.method_map.contains_key(&expr.id));\n+\n+                // With type_autoderef, make sure we don't\n+                // allow pointers to violate privacy\n+                let t = ty::type_autoderef(self.tcx,\n+                                           ty::expr_ty(self.tcx, base));\n+                match ty::get(t).sty {\n+                    ty::ty_struct(id, _) => self.check_field(expr.span, id, ident),\n+                    _ => {}\n                 }\n-                ExprMethodCall(_, base, ident, _, _, _) => {\n-                    // Ditto\n-                    match ty::get(ty::type_autoderef(self.tcx, ty::expr_ty(self.tcx,\n-                                                          base))).sty {\n-                        ty_enum(id, _) |\n-                        ty_struct(id, _)\n-                        if id.crate != LOCAL_CRATE ||\n-                           !self.privileged_items.iter().any(|x| x == &(id.node)) => {\n-                            match method_map.find(&expr.id) {\n-                                None => {\n-                                    self.tcx.sess.span_bug(expr.span,\n-                                                      \"method call not in \\\n-                                                       method map\");\n-                                }\n-                                Some(ref entry) => {\n-                                    debug2!(\"(privacy checking) checking \\\n-                                            impl method\");\n-                                    self.check_method(expr.span, &entry.origin, ident);\n-                                }\n+            }\n+            ast::ExprMethodCall(_, base, ident, _, _, _) => {\n+                // see above\n+                let t = ty::type_autoderef(self.tcx,\n+                                           ty::expr_ty(self.tcx, base));\n+                match ty::get(t).sty {\n+                    ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n+                        let entry = match self.method_map.find(&expr.id) {\n+                            None => {\n+                                self.tcx.sess.span_bug(expr.span,\n+                                                       \"method call not in \\\n+                                                        method map\");\n                             }\n-                        }\n-                        _ => {}\n+                            Some(entry) => entry\n+                        };\n+                        debug2!(\"(privacy checking) checking impl method\");\n+                        self.check_method(expr.span, &entry.origin, ident);\n                     }\n+                    _ => {}\n                 }\n-                ExprPath(ref path) => {\n-                    self.check_path(expr.span, self.tcx.def_map.get_copy(&expr.id), path);\n-                }\n-                ExprStruct(_, ref fields, _) => {\n-                    match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n-                        ty_struct(id, _) => {\n-                            if id.crate != LOCAL_CRATE ||\n-                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n-                                for field in (*fields).iter() {\n-                                        debug2!(\"(privacy checking) checking \\\n-                                                field in struct literal\");\n-                                    self.check_field(expr.span, id, field.ident);\n-                                }\n-                            }\n+            }\n+            ast::ExprPath(ref path) => {\n+                self.check_path(expr.span, expr.id, path);\n+            }\n+            ast::ExprStruct(_, ref fields, _) => {\n+                match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for field in (*fields).iter() {\n+                            self.check_field(expr.span, id, field.ident);\n                         }\n-                        ty_enum(id, _) => {\n-                            if id.crate != LOCAL_CRATE ||\n-                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n-                                match self.tcx.def_map.get_copy(&expr.id) {\n-                                    DefVariant(_, variant_id, _) => {\n-                                        for field in (*fields).iter() {\n-                                                debug2!(\"(privacy checking) \\\n-                                                        checking field in \\\n-                                                        struct variant \\\n-                                                        literal\");\n-                                            self.check_field(expr.span, variant_id, field.ident);\n-                                        }\n-                                    }\n-                                    _ => {\n-                                        self.tcx.sess.span_bug(expr.span,\n-                                                          \"resolve didn't \\\n-                                                           map enum struct \\\n-                                                           constructor to a \\\n-                                                           variant def\");\n-                                    }\n+                    }\n+                    ty::ty_enum(_, _) => {\n+                        match self.tcx.def_map.get_copy(&expr.id) {\n+                            ast::DefVariant(_, variant_id, _) => {\n+                                for field in fields.iter() {\n+                                    self.check_field(expr.span, variant_id,\n+                                                     field.ident);\n                                 }\n                             }\n-                        }\n-                        _ => {\n-                            self.tcx.sess.span_bug(expr.span, \"struct expr \\\n-                                                          didn't have \\\n-                                                          struct type?!\");\n+                            _ => self.tcx.sess.span_bug(expr.span,\n+                                                        \"resolve didn't \\\n+                                                         map enum struct \\\n+                                                         constructor to a \\\n+                                                         variant def\"),\n                         }\n                     }\n+                    _ => self.tcx.sess.span_bug(expr.span, \"struct expr \\\n+                                                            didn't have \\\n+                                                            struct type?!\"),\n                 }\n-                ExprUnary(_, ast::UnDeref, operand) => {\n-                    // In *e, we need to check that if e's type is an\n-                    // enum type t, then t's first variant is public or\n-                    // privileged. (We can assume it has only one variant\n-                    // since typeck already happened.)\n-                    match ty::get(ty::expr_ty(self.tcx, operand)).sty {\n-                        ty_enum(id, _) => {\n-                            if id.crate != LOCAL_CRATE ||\n-                                !self.privileged_items.iter().any(|x| x == &(id.node)) {\n-                                self.check_variant(expr.span, id);\n-                            }\n-                        }\n-                        _ => { /* No check needed */ }\n+            }\n+            ast::ExprUnary(_, ast::UnDeref, operand) => {\n+                // In *e, we need to check that if e's type is an\n+                // enum type t, then t's first variant is public or\n+                // privileged. (We can assume it has only one variant\n+                // since typeck already happened.)\n+                match ty::get(ty::expr_ty(self.tcx, operand)).sty {\n+                    ty::ty_enum(id, _) => {\n+                        self.check_variant(expr.span, id);\n                     }\n+                    _ => { /* No check needed */ }\n                 }\n-                _ => {}\n             }\n+            _ => {}\n+        }\n \n-            visit::walk_expr(self, expr, cx);\n-\n+        visit::walk_expr(self, expr, ());\n     }\n \n-    fn visit_pat(&mut self, pattern:@Pat, cx: Context<'self>) {\n+    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+        match t.node {\n+            ast::ty_path(ref path, _, id) => self.check_path(t.span, id, path),\n+            _ => {}\n+        }\n+        visit::walk_ty(self, t, ());\n+    }\n \n-            match pattern.node {\n-                PatStruct(_, ref fields, _) => {\n-                    match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n-                        ty_struct(id, _) => {\n-                            if id.crate != LOCAL_CRATE ||\n-                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n-                                for field in fields.iter() {\n-                                        debug2!(\"(privacy checking) checking \\\n-                                                struct pattern\");\n-                                    self.check_field(pattern.span, id, field.ident);\n-                                }\n-                            }\n+    fn visit_view_item(&mut self, a: &ast::view_item, _: ()) {\n+        match a.node {\n+            ast::view_item_extern_mod(*) => {}\n+            ast::view_item_use(ref uses) => {\n+                for vpath in uses.iter() {\n+                    match vpath.node {\n+                        ast::view_path_simple(_, ref path, id) |\n+                        ast::view_path_glob(ref path, id) => {\n+                            debug2!(\"privacy - glob/simple {}\", id);\n+                            self.check_path(vpath.span, id, path);\n                         }\n-                        ty_enum(enum_id, _) => {\n-                            if enum_id.crate != LOCAL_CRATE ||\n-                                    !self.privileged_items.iter().any(|x| x == &enum_id.node) {\n-                                match self.tcx.def_map.find(&pattern.id) {\n-                                    Some(&DefVariant(_, variant_id, _)) => {\n-                                        for field in fields.iter() {\n-                                            debug2!(\"(privacy checking) \\\n-                                                    checking field in \\\n-                                                    struct variant pattern\");\n-                                            self.check_field(pattern.span, variant_id, field.ident);\n-                                        }\n-                                    }\n-                                    _ => {\n-                                        self.tcx.sess.span_bug(pattern.span,\n-                                                          \"resolve didn't \\\n-                                                           map enum struct \\\n-                                                           pattern to a \\\n-                                                           variant def\");\n-                                    }\n-                                }\n+                        ast::view_path_list(_, ref list, _) => {\n+                            for pid in list.iter() {\n+                                debug2!(\"privacy - list {}\", pid.node.id);\n+                                let seg = ast::PathSegment {\n+                                    identifier: pid.node.name,\n+                                    lifetime: None,\n+                                    types: opt_vec::Empty,\n+                                };\n+                                let segs = ~[seg];\n+                                let path = ast::Path {\n+                                    global: false,\n+                                    span: pid.span,\n+                                    segments: segs,\n+                                };\n+                                self.check_path(pid.span, pid.node.id, &path);\n                             }\n                         }\n-                        _ => {\n-                            self.tcx.sess.span_bug(pattern.span,\n-                                              \"struct pattern didn't have \\\n-                                               struct type?!\");\n-                        }\n                     }\n                 }\n-                _ => {}\n-            }\n-\n-            visit::walk_pat(self, pattern, cx);\n-    }\n-}\n-\n-pub fn check_crate(tcx: ty::ctxt,\n-                   method_map: &method_map,\n-                   exp_map2: &ExportMap2,\n-                   crate: &ast::Crate) -> ExportedItems {\n-    let privileged_items = @mut ~[];\n-\n-    let mut visitor = PrivacyVisitor {\n-        tcx: tcx,\n-        privileged_items: privileged_items,\n-        exported_items: HashSet::new(),\n-        path_all_public: true, // start out as public\n-    };\n-    visit::walk_crate(&mut visitor, crate, (method_map, exp_map2));\n-    return visitor.exported_items;\n-}\n-\n-/// Validates all of the visibility qualifers placed on the item given. This\n-/// ensures that there are no extraneous qualifiers that don't actually do\n-/// anything. In theory these qualifiers wouldn't parse, but that may happen\n-/// later on down the road...\n-fn check_sane_privacy(tcx: ty::ctxt, item: @ast::item) {\n-    let check_inherited = |sp: Span, vis: ast::visibility, note: &str| {\n-        if vis != ast::inherited {\n-            tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n-            if note.len() > 0 {\n-                tcx.sess.span_note(sp, note);\n-            }\n-        }\n-    };\n-    let check_not_priv = |sp: Span, vis: ast::visibility, note: &str| {\n-        if vis == ast::private {\n-            tcx.sess.span_err(sp, \"unnecessary `priv` qualifier\");\n-            if note.len() > 0 {\n-                tcx.sess.span_note(sp, note);\n-            }\n-        }\n-    };\n-    match item.node {\n-        // implementations of traits don't need visibility qualifiers because\n-        // that's controlled by having the trait in scope.\n-        ast::item_impl(_, Some(*), _, ref methods) => {\n-            check_inherited(item.span, item.vis,\n-                            \"visibility qualifiers have no effect on trait impls\");\n-            for m in methods.iter() {\n-                check_inherited(m.span, m.vis, \"\");\n-            }\n-        }\n-\n-        ast::item_impl(_, _, _, ref methods) => {\n-            check_inherited(item.span, item.vis,\n-                            \"place qualifiers on individual methods instead\");\n-            for i in methods.iter() {\n-                check_not_priv(i.span, i.vis, \"functions are private by default\");\n-            }\n-        }\n-        ast::item_foreign_mod(ref fm) => {\n-            check_inherited(item.span, item.vis,\n-                            \"place qualifiers on individual functions instead\");\n-            for i in fm.items.iter() {\n-                check_not_priv(i.span, i.vis, \"functions are private by default\");\n             }\n         }\n+    }\n \n-        ast::item_enum(ref def, _) => {\n-            for v in def.variants.iter() {\n-                match v.node.vis {\n-                    ast::public => {\n-                        if item.vis == ast::public {\n-                            tcx.sess.span_err(v.span, \"unnecessary `pub` \\\n-                                                       visibility\");\n+    fn visit_pat(&mut self, pattern: @ast::Pat, _: ()) {\n+        match pattern.node {\n+            ast::PatStruct(_, ref fields, _) => {\n+                match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for field in fields.iter() {\n+                            self.check_field(pattern.span, id, field.ident);\n                         }\n                     }\n-                    ast::private => {\n-                        if item.vis != ast::public {\n-                            tcx.sess.span_err(v.span, \"unnecessary `priv` \\\n-                                                       visibility\");\n+                    ty::ty_enum(_, _) => {\n+                        match self.tcx.def_map.find(&pattern.id) {\n+                            Some(&ast::DefVariant(_, variant_id, _)) => {\n+                                for field in fields.iter() {\n+                                    self.check_field(pattern.span, variant_id,\n+                                                     field.ident);\n+                                }\n+                            }\n+                            _ => self.tcx.sess.span_bug(pattern.span,\n+                                                        \"resolve didn't \\\n+                                                         map enum struct \\\n+                                                         pattern to a \\\n+                                                         variant def\"),\n                         }\n                     }\n-                    ast::inherited => {}\n+                    _ => self.tcx.sess.span_bug(pattern.span,\n+                                                \"struct pattern didn't have \\\n+                                                 struct type?!\"),\n                 }\n             }\n+            _ => {}\n         }\n \n-        ast::item_struct(ref def, _) => {\n-            for f in def.fields.iter() {\n-                match f.node.kind {\n-                    ast::named_field(_, ast::public) => {\n-                        tcx.sess.span_err(f.span, \"unnecessary `pub` \\\n-                                                   visibility\");\n-                    }\n-                    ast::named_field(_, ast::private) => {\n-                        // Fields should really be private by default...\n-                    }\n-                    ast::named_field(*) | ast::unnamed_field => {}\n-                }\n-            }\n-        }\n+        visit::walk_pat(self, pattern, ());\n+    }\n+}\n \n-        ast::item_trait(_, _, ref methods) => {\n-            for m in methods.iter() {\n-                match *m {\n-                    ast::provided(ref m) => {\n-                        check_inherited(m.span, m.vis,\n-                                        \"unnecessary visibility\");\n-                    }\n-                    ast::required(*) => {}\n-                }\n-            }\n-        }\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: &method_map,\n+                   exp_map2: &resolve::ExportMap2,\n+                   external_exports: resolve::ExternalExports,\n+                   last_private_map: resolve::LastPrivateMap,\n+                   crate: &ast::Crate) {\n+    let mut parents = HashMap::new();\n+    let mut exported_items = HashSet::new();\n+\n+    // First, figure out who everyone's parent is\n+    {\n+        let mut visitor = ParentVisitor {\n+            parents: &mut parents,\n+            curparent: ast::DUMMY_NODE_ID,\n+        };\n+        visit::walk_crate(&mut visitor, crate, ());\n+    }\n \n-        ast::item_static(*) |\n-        ast::item_fn(*) | ast::item_mod(*) | ast::item_ty(*) |\n-        ast::item_mac(*) => {\n-            check_not_priv(item.span, item.vis, \"items are private by default\");\n-        }\n+    // Next, build up the list of all exported items from this crate\n+    {\n+        // Initialize the exported items with resolve's id for the \"root crate\"\n+        // to resolve references to `super` leading to the root and such.\n+        exported_items.insert(0);\n+        let mut visitor = EmbargoVisitor {\n+            exported_items: &mut exported_items,\n+            exp_map2: exp_map2,\n+            path_all_public: true, // start out as public\n+        };\n+        visit::walk_crate(&mut visitor, crate, ());\n+    }\n+\n+    // And then actually check the privacy of everything.\n+    {\n+        let mut visitor = PrivacyVisitor {\n+            curitem: ast::DUMMY_NODE_ID,\n+            tcx: tcx,\n+            exported_items: &exported_items,\n+            parents: &parents,\n+            method_map: method_map,\n+            external_exports: external_exports,\n+            last_private_map: last_private_map,\n+        };\n+        visit::walk_crate(&mut visitor, crate, ());\n     }\n }"}, {"sha": "447f1075585c805ef6393f57a9982b3a004e3ff1", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 487, "deletions": 478, "changes": 965, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd"}, {"sha": "73b197ec3619909700d2c084772d701dab4118c6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -3034,7 +3034,6 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n             diag: diag,\n             tcx: cx.tcx,\n             reexports2: cx.exp_map2,\n-            exported_items: cx.exported_items,\n             item_symbols: item_symbols,\n             discrim_symbols: discrim_symbols,\n             non_inlineable_statics: &cx.non_inlineable_statics,\n@@ -3116,7 +3115,6 @@ pub fn trans_crate(sess: session::Session,\n                                      llmod_id,\n                                      analysis.ty_cx,\n                                      analysis.exp_map2,\n-                                     analysis.exported_items,\n                                      analysis.maps,\n                                      symbol_hasher,\n                                      link_meta,"}, {"sha": "2b3874e0bf0d85249acaeb853df5faf111930ac2", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -49,7 +49,6 @@ pub struct CrateContext {\n      intrinsics: HashMap<&'static str, ValueRef>,\n      item_vals: HashMap<ast::NodeId, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n-     exported_items: @privacy::ExportedItems,\n      reachable: @mut HashSet<ast::NodeId>,\n      item_symbols: HashMap<ast::NodeId, ~str>,\n      link_meta: LinkMeta,\n@@ -125,7 +124,6 @@ impl CrateContext {\n                name: &str,\n                tcx: ty::ctxt,\n                emap2: resolve::ExportMap2,\n-               exported_items: @privacy::ExportedItems,\n                maps: astencode::Maps,\n                symbol_hasher: hash::State,\n                link_meta: LinkMeta,\n@@ -185,7 +183,6 @@ impl CrateContext {\n                   intrinsics: intrinsics,\n                   item_vals: HashMap::new(),\n                   exp_map2: emap2,\n-                  exported_items: exported_items,\n                   reachable: reachable,\n                   item_symbols: HashMap::new(),\n                   link_meta: link_meta,"}, {"sha": "926d1997465ab223cee3e31eb60c5a7006bdedc8", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -702,32 +702,6 @@ pub fn struct_def_is_tuple_like(struct_def: &ast::struct_def) -> bool {\n     struct_def.ctor_id.is_some()\n }\n \n-pub fn visibility_to_privacy(visibility: visibility) -> Privacy {\n-    match visibility {\n-        public => Public,\n-        inherited | private => Private\n-    }\n-}\n-\n-pub fn variant_visibility_to_privacy(visibility: visibility,\n-                                     enclosing_is_public: bool)\n-                                  -> Privacy {\n-    if enclosing_is_public {\n-        match visibility {\n-            public | inherited => Public,\n-            private => Private\n-        }\n-    } else {\n-        visibility_to_privacy(visibility)\n-    }\n-}\n-\n-#[deriving(Eq)]\n-pub enum Privacy {\n-    Private,\n-    Public\n-}\n-\n /// Returns true if the given pattern consists solely of an identifier\n /// and false otherwise.\n pub fn pat_is_ident(pat: @ast::Pat) -> bool {"}, {"sha": "a0004f98ecf27fca84ad9afd2f148349bfeabeea", "filename": "src/test/compile-fail/glob-resolve1.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure that globs only bring in public things.\n+\n+use bar::*;\n+\n+mod bar {\n+    use import = self::fpriv;\n+    fn fpriv() {}\n+    extern {\n+        fn epriv();\n+    }\n+    enum A { A1 }\n+    pub enum B { B1 }\n+\n+    struct C;\n+\n+    type D = int;\n+}\n+\n+fn foo<T>() {}\n+\n+fn main() {\n+    fpriv(); //~ ERROR: unresolved\n+    epriv(); //~ ERROR: unresolved\n+    A1; //~ ERROR: unresolved\n+    B1;\n+    C; //~ ERROR: unresolved\n+    import(); //~ ERROR: unresolved\n+\n+    foo::<A>(); //~ ERROR: undeclared\n+    //~^ ERROR: undeclared\n+    foo::<C>(); //~ ERROR: undeclared\n+    //~^ ERROR: undeclared\n+    foo::<D>(); //~ ERROR: undeclared\n+    //~^ ERROR: undeclared\n+}"}, {"sha": "2e2b53331cafae42543151c64c24c0a0d7ceb5ab", "filename": "src/test/compile-fail/privacy1.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -0,0 +1,168 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[no_std]; // makes debugging this test *a lot* easier (during resolve)\n+\n+mod bar {\n+    // shouln't bring in too much\n+    pub use self::glob::*;\n+\n+    // can't publicly re-export private items\n+    pub use self::baz::{foo, bar};\n+    //~^ ERROR: function `bar` is private\n+\n+    pub use self::private::ppriv;\n+    //~^ ERROR: function `ppriv` is private\n+\n+    pub struct A;\n+    impl A {\n+        pub fn foo() {}\n+        fn bar() {}\n+\n+        pub fn foo2(&self) {}\n+        fn bar2(&self) {}\n+    }\n+\n+    pub enum Enum {\n+        priv Priv,\n+        Pub\n+    }\n+\n+    mod baz {\n+        pub struct A;\n+        impl A {\n+            pub fn foo() {}\n+            fn bar() {}\n+\n+            pub fn foo2(&self) {}\n+            fn bar2(&self) {}\n+        }\n+\n+        // both of these are re-exported by `bar`, but only one should be\n+        // validly re-exported\n+        pub fn foo() {}\n+        fn bar() {}\n+    }\n+\n+    extern {\n+        fn epriv();\n+        pub fn epub();\n+    }\n+\n+    fn test() {\n+        self::Priv;\n+        self::Pub;\n+        unsafe {\n+            epriv();\n+            epub();\n+        }\n+        self::baz::A;\n+        self::baz::A::foo();\n+        self::baz::A::bar(); //~ ERROR: method `bar` is private\n+        self::baz::A.foo2();\n+        self::baz::A.bar2(); //~ ERROR: method `bar2` is private\n+\n+        // this used to cause an ICE in privacy traversal.\n+        super::gpub();\n+    }\n+\n+    mod glob {\n+        pub fn gpub() {}\n+        fn gpriv() {}\n+    }\n+\n+    mod private {\n+        fn ppriv() {}\n+    }\n+}\n+\n+pub fn gpub() {}\n+\n+fn lol() {\n+    bar::A;\n+    bar::A::foo();\n+    bar::A::bar(); //~ ERROR: method `bar` is private\n+    bar::A.foo2();\n+    bar::A.bar2(); //~ ERROR: method `bar2` is private\n+}\n+\n+mod foo {\n+    fn test() {\n+        ::bar::A::foo();\n+        ::bar::A::bar();        //~ ERROR: method `bar` is private\n+        ::bar::A.foo2();\n+        ::bar::A.bar2();        //~ ERROR: method `bar2` is private\n+        ::bar::baz::A::foo();   //~ ERROR: method `foo` is private\n+        ::bar::baz::A::bar();   //~ ERROR: method `bar` is private\n+        ::bar::baz::A.foo2();   //~ ERROR: struct `A` is private\n+        ::bar::baz::A.bar2();   //~ ERROR: struct `A` is private\n+                                //~^ ERROR: method `bar2` is private\n+        ::lol();\n+\n+        ::bar::Priv; //~ ERROR: variant `Priv` is private\n+        ::bar::Pub;\n+\n+        unsafe {\n+            ::bar::epriv(); //~ ERROR: function `epriv` is private\n+            ::bar::epub();\n+        }\n+\n+        ::bar::foo();\n+        ::bar::bar();\n+\n+        ::bar::gpub();\n+\n+        ::bar::baz::foo(); //~ ERROR: function `foo` is private\n+        ::bar::baz::bar(); //~ ERROR: function `bar` is private\n+    }\n+\n+    fn test2() {\n+        use bar::baz::{foo, bar};\n+        //~^ ERROR: function `foo` is private\n+        //~^^ ERROR: function `bar` is private\n+        foo();\n+        bar();\n+    }\n+\n+    fn test3() {\n+        use bar::baz;\n+        //~^ ERROR: module `baz` is private\n+    }\n+\n+    fn test4() {\n+        use bar::{foo, bar};\n+        foo();\n+        bar();\n+    }\n+\n+    fn test5() {\n+        use bar;\n+        bar::foo();\n+        bar::bar();\n+    }\n+}\n+\n+pub mod mytest {\n+    // Even though the inner `A` struct is a publicly exported item (usable from\n+    // external crates through `foo::foo`, it should not be accessible through\n+    // its definition path (which has the private `i` module).\n+    use self::foo::foo;\n+    use self::foo::i::A; //~ ERROR: type `A` is private\n+\n+    pub mod foo {\n+        pub use foo = self::i::A;\n+\n+        mod i {\n+            pub struct A;\n+        }\n+    }\n+}\n+\n+#[start] fn main(_: int, _: **u8) -> int { 3 }"}, {"sha": "e8e21021cccd630c6b6a03a11df6a06350206bfb", "filename": "src/test/compile-fail/privacy2.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[no_std]; // makes debugging this test *a lot* easier (during resolve)\n+\n+// Test to make sure that globs don't leak in regular `use` statements.\n+\n+mod bar {\n+    pub use self::glob::*;\n+\n+    mod glob {\n+        use foo;\n+    }\n+}\n+\n+pub fn foo() {}\n+\n+fn test1() {\n+    use bar::foo; //~ ERROR: unresolved import\n+    //~^ ERROR: failed to resolve\n+}\n+\n+fn test2() {\n+    use bar::glob::foo;\n+    //~^ ERROR: there is no\n+    //~^^ ERROR: failed to resolve\n+}\n+\n+#[start] fn main(_: int, _: **u8) -> int { 3 }\n+"}, {"sha": "523d4cd4b8dddafd4297b325c268707d3a1f5b64", "filename": "src/test/compile-fail/privacy3.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[no_std]; // makes debugging this test *a lot* easier (during resolve)\n+\n+// Test to make sure that private items imported through globs remain private\n+// when  they're used.\n+\n+mod bar {\n+    pub use self::glob::*;\n+\n+    mod glob {\n+        fn gpriv() {}\n+    }\n+}\n+\n+pub fn foo() {}\n+\n+fn test1() {\n+    use bar::gpriv; //~ ERROR: unresolved import\n+    //~^ ERROR: failed to resolve\n+    gpriv();\n+}\n+\n+#[start] fn main(_: int, _: **u8) -> int { 3 }"}, {"sha": "88a9b2f30580be0f3e7fd94ff339be2275aea59e", "filename": "src/test/compile-fail/privacy4.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/439e2770be6aec41a3961235305787a78d47fbdd/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439e2770be6aec41a3961235305787a78d47fbdd/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs?ref=439e2770be6aec41a3961235305787a78d47fbdd", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[no_std]; // makes debugging this test *a lot* easier (during resolve)\n+\n+// Test to make sure that private items imported through globs remain private\n+// when  they're used.\n+\n+mod bar {\n+    pub use self::glob::*;\n+\n+    mod glob {\n+        fn gpriv() {}\n+    }\n+}\n+\n+pub fn foo() {}\n+\n+fn test2() {\n+    use bar::glob::gpriv; //~ ERROR: function `gpriv` is private\n+    gpriv();\n+}\n+\n+#[start] fn main(_: int, _: **u8) -> int { 3 }"}]}