{"sha": "42abbd8878d3b67238f3611b0587c704ba94f39c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYWJiZDg4NzhkM2I2NzIzOGYzNjExYjA1ODdjNzA0YmE5NGYzOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-07T13:43:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-07T13:43:30Z"}, "message": "Auto merge of #70884 - Dylan-DPC:rollup-r3raqdf, r=jonas-schievink\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #70201 (Small tweaks in ToOwned::clone_into)\n - #70762 (Miri leak check: memory reachable through globals is not leaked)\n - #70846 (Keep codegen units unmerged when building compiler builtins)\n - #70854 (Use assoc int submodules)\n - #70857 (Don't import integer and float modules, use assoc consts 2)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "f993f7af10bd88484c767278196a488c6ee5bebf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f993f7af10bd88484c767278196a488c6ee5bebf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42abbd8878d3b67238f3611b0587c704ba94f39c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42abbd8878d3b67238f3611b0587c704ba94f39c", "html_url": "https://github.com/rust-lang/rust/commit/42abbd8878d3b67238f3611b0587c704ba94f39c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42abbd8878d3b67238f3611b0587c704ba94f39c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "html_url": "https://github.com/rust-lang/rust/commit/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0"}, {"sha": "89d661f15d8249f8e808b75b1129ce28e0889ba0", "url": "https://api.github.com/repos/rust-lang/rust/commits/89d661f15d8249f8e808b75b1129ce28e0889ba0", "html_url": "https://github.com/rust-lang/rust/commit/89d661f15d8249f8e808b75b1129ce28e0889ba0"}], "stats": {"total": 411, "additions": 255, "deletions": 156}, "files": [{"sha": "6eb24d6e9c0773d4aee68ed5fca121ce3cdf676a", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1 +1 @@\n-Subproject commit 411197b0e77590c967e37e8f6ec681abd359afe8\n+Subproject commit 6eb24d6e9c0773d4aee68ed5fca121ce3cdf676a"}, {"sha": "a6638463efc7631bc0e8dc67ccd256d4e1b61f1a", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1 +1 @@\n-Subproject commit edd2a7e687358712608896730c083cb76c7b401a\n+Subproject commit a6638463efc7631bc0e8dc67ccd256d4e1b61f1a"}, {"sha": "0780b33e53ae6f207a7aed3156efad46582dbf95", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -608,7 +608,7 @@ unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n-    if mem::size_of::<usize>() < 8 && alloc_size > core::isize::MAX as usize {\n+    if mem::size_of::<usize>() < 8 && alloc_size > isize::MAX as usize {\n         Err(CapacityOverflow)\n     } else {\n         Ok(())"}, {"sha": "cd750d2558035f8ace5078b10cb5f10f70d6dfc0", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -733,14 +733,14 @@ impl<T: Clone> ToOwned for [T] {\n     fn clone_into(&self, target: &mut Vec<T>) {\n         // drop anything in target that will not be overwritten\n         target.truncate(self.len());\n-        let len = target.len();\n-\n-        // reuse the contained values' allocations/resources.\n-        target.clone_from_slice(&self[..len]);\n \n         // target.len <= self.len due to the truncate above, so the\n-        // slice here is always in-bounds.\n-        target.extend_from_slice(&self[len..]);\n+        // slices here are always in-bounds.\n+        let (init, tail) = self.split_at(target.len());\n+\n+        // reuse the contained values' allocations/resources.\n+        target.clone_from_slice(init);\n+        target.extend_from_slice(tail);\n     }\n }\n "}, {"sha": "c02ba267056d6dd391e51cd97bbbdbaf4906302e", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -50,7 +50,7 @@ fn trait_object() {\n \n #[test]\n fn float_nan_ne() {\n-    let x = Arc::new(std::f32::NAN);\n+    let x = Arc::new(f32::NAN);\n     assert!(x != x);\n     assert!(!(x == x));\n }"}, {"sha": "96b6c32a1fa8ec4c3a6ae68e55758e2dd9ff1cb1", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -475,7 +475,7 @@ fn test_range_large() {\n \n #[test]\n fn test_range_inclusive_max_value() {\n-    let max = std::usize::MAX;\n+    let max = usize::MAX;\n     let map: BTreeMap<_, _> = vec![(max, 0)].into_iter().collect();\n \n     assert_eq!(map.range(max..=max).collect::<Vec<_>>(), &[(&max, &0)]);"}, {"sha": "501b4f0f816be3f861bf768de3fecc45576875db", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -50,7 +50,7 @@ fn trait_object() {\n \n #[test]\n fn float_nan_ne() {\n-    let x = Rc::new(std::f32::NAN);\n+    let x = Rc::new(f32::NAN);\n     assert!(x != x);\n     assert!(!(x == x));\n }"}, {"sha": "305baa68729eb2a2fb512cac2a98b6bc7b33dd4b", "filename": "src/libcore/benches/num/dec2flt/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1,4 +1,3 @@\n-use std::f64;\n use test::Bencher;\n \n #[bench]"}, {"sha": "a1ce33d0bb49ef90f8f065874273e4cda9f39a3e", "filename": "src/libcore/benches/num/flt2dec/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -5,7 +5,6 @@ mod strategy {\n \n use core::num::flt2dec::MAX_SIG_DIGITS;\n use core::num::flt2dec::{decode, DecodableFloat, Decoded, FullDecoded};\n-use std::f64;\n use std::io::Write;\n use std::vec::Vec;\n use test::Bencher;"}, {"sha": "1a1dbcd7b871aaab2e22a1c847a521fd097b0dd2", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -76,7 +76,6 @@ fn test_cmp_by() {\n #[test]\n fn test_partial_cmp_by() {\n     use core::cmp::Ordering;\n-    use core::f64;\n \n     let f = |x: i32, y: i32| (x * x).partial_cmp(&y);\n     let xs = || [1, 2, 3, 4].iter().copied();\n@@ -2894,7 +2893,7 @@ fn test_is_sorted() {\n     assert!(![1, 3, 2].iter().is_sorted());\n     assert!([0].iter().is_sorted());\n     assert!(std::iter::empty::<i32>().is_sorted());\n-    assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted());\n+    assert!(![0.0, 1.0, f32::NAN].iter().is_sorted());\n     assert!([-2, -1, 0, 3].iter().is_sorted());\n     assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n     assert!(![\"c\", \"bb\", \"aaa\"].iter().is_sorted());"}, {"sha": "c098b9c2ba27ddf1618fe74d97f1b8913e12ef62", "filename": "src/libcore/tests/num/dec2flt/rawfp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1,8 +1,6 @@\n use core::num::dec2flt::rawfp::RawFloat;\n use core::num::dec2flt::rawfp::{fp_to_float, next_float, prev_float, round_normal};\n use core::num::diy_float::Fp;\n-use std::f32;\n-use std::f64;\n \n fn integer_decode(f: f64) -> (u64, i16, i8) {\n     RawFloat::integer_decode(f)"}, {"sha": "181bbb8e18784c3515d03f2d6b58d576a222c400", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -205,8 +205,6 @@ test_impl_from! { test_u32f64, u32, f64 }\n // Float -> Float\n #[test]\n fn test_f32f64() {\n-    use core::f32;\n-\n     let max: f64 = f32::MAX.into();\n     assert_eq!(max as f32, f32::MAX);\n     assert!(max.is_normal());\n@@ -704,5 +702,5 @@ macro_rules! test_float {\n     };\n }\n \n-test_float!(f32, f32, ::core::f32::INFINITY, ::core::f32::NEG_INFINITY, ::core::f32::NAN);\n-test_float!(f64, f64, ::core::f64::INFINITY, ::core::f64::NEG_INFINITY, ::core::f64::NAN);\n+test_float!(f32, f32, f32::INFINITY, f32::NEG_INFINITY, f32::NAN);\n+test_float!(f64, f64, f64::INFINITY, f64::NEG_INFINITY, f64::NAN);"}, {"sha": "3c83f0f2300038ca4a4ddf5a1204f256e63193af", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -61,25 +61,23 @@ fn test_range_inclusive() {\n \n #[test]\n fn test_range_is_empty() {\n-    use core::f32::*;\n-\n     assert!(!(0.0..10.0).is_empty());\n     assert!((-0.0..0.0).is_empty());\n     assert!((10.0..0.0).is_empty());\n \n-    assert!(!(NEG_INFINITY..INFINITY).is_empty());\n-    assert!((EPSILON..NAN).is_empty());\n-    assert!((NAN..EPSILON).is_empty());\n-    assert!((NAN..NAN).is_empty());\n+    assert!(!(f32::NEG_INFINITY..f32::INFINITY).is_empty());\n+    assert!((f32::EPSILON..f32::NAN).is_empty());\n+    assert!((f32::NAN..f32::EPSILON).is_empty());\n+    assert!((f32::NAN..f32::NAN).is_empty());\n \n     assert!(!(0.0..=10.0).is_empty());\n     assert!(!(-0.0..=0.0).is_empty());\n     assert!((10.0..=0.0).is_empty());\n \n-    assert!(!(NEG_INFINITY..=INFINITY).is_empty());\n-    assert!((EPSILON..=NAN).is_empty());\n-    assert!((NAN..=EPSILON).is_empty());\n-    assert!((NAN..=NAN).is_empty());\n+    assert!(!(f32::NEG_INFINITY..=f32::INFINITY).is_empty());\n+    assert!((f32::EPSILON..=f32::NAN).is_empty());\n+    assert!((f32::NAN..=f32::EPSILON).is_empty());\n+    assert!((f32::NAN..=f32::NAN).is_empty());\n }\n \n #[test]"}, {"sha": "9b9420cc13f85fc35623863030252519c126d466", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1108,14 +1108,14 @@ mod slice_index {\n \n             // note: using 0 specifically ensures that the result of overflowing is 0..0,\n             //       so that `get` doesn't simply return None for the wrong reason.\n-            bad: data[0 ..= ::std::usize::MAX];\n+            bad: data[0 ..= usize::MAX];\n             message: \"maximum usize\";\n         }\n \n         in mod rangetoinclusive_overflow {\n             data: [0, 1];\n \n-            bad: data[..= ::std::usize::MAX];\n+            bad: data[..= usize::MAX];\n             message: \"maximum usize\";\n         }\n     } // panic_cases!\n@@ -1709,7 +1709,7 @@ fn test_is_sorted() {\n     assert!(![1, 3, 2].is_sorted());\n     assert!([0].is_sorted());\n     assert!(empty.is_sorted());\n-    assert!(![0.0, 1.0, std::f32::NAN].is_sorted());\n+    assert!(![0.0, 1.0, f32::NAN].is_sorted());\n     assert!([-2, -1, 0, 3].is_sorted());\n     assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));\n     assert!(![\"c\", \"bb\", \"aaa\"].is_sorted());"}, {"sha": "7a6675dc82fa6ef70e9f526c206c100cb95f9ee4", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -14,7 +14,7 @@ fn creation() {\n #[test]\n #[should_panic]\n fn new_overflow() {\n-    let _ = Duration::new(::core::u64::MAX, 1_000_000_000);\n+    let _ = Duration::new(u64::MAX, 1_000_000_000);\n }\n \n #[test]\n@@ -86,7 +86,7 @@ fn checked_add() {\n         Duration::new(0, 500_000_000).checked_add(Duration::new(0, 500_000_001)),\n         Some(Duration::new(1, 1))\n     );\n-    assert_eq!(Duration::new(1, 0).checked_add(Duration::new(::core::u64::MAX, 0)), None);\n+    assert_eq!(Duration::new(1, 0).checked_add(Duration::new(u64::MAX, 0)), None);\n }\n \n #[test]\n@@ -133,7 +133,7 @@ fn checked_mul() {\n     assert_eq!(Duration::new(1, 1).checked_mul(3), Some(Duration::new(3, 3)));\n     assert_eq!(Duration::new(0, 500_000_001).checked_mul(4), Some(Duration::new(2, 4)));\n     assert_eq!(Duration::new(0, 500_000_001).checked_mul(4000), Some(Duration::new(2000, 4000)));\n-    assert_eq!(Duration::new(::core::u64::MAX - 1, 0).checked_mul(2), None);\n+    assert_eq!(Duration::new(u64::MAX - 1, 0).checked_mul(2), None);\n }\n \n #[test]"}, {"sha": "ea1e281425c8904b02c1266809e769e289678f54", "filename": "src/libcore/tests/tuple.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibcore%2Ftests%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftuple.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1,5 +1,4 @@\n use std::cmp::Ordering::{Equal, Greater, Less};\n-use std::f64::NAN;\n \n #[test]\n fn test_clone() {\n@@ -34,12 +33,12 @@ fn test_partial_ord() {\n     assert!(big >= small);\n     assert!(big >= big);\n \n-    assert!(!((1.0f64, 2.0f64) < (NAN, 3.0)));\n-    assert!(!((1.0f64, 2.0f64) <= (NAN, 3.0)));\n-    assert!(!((1.0f64, 2.0f64) > (NAN, 3.0)));\n-    assert!(!((1.0f64, 2.0f64) >= (NAN, 3.0)));\n-    assert!(((1.0f64, 2.0f64) < (2.0, NAN)));\n-    assert!(!((2.0f64, 2.0f64) < (2.0, NAN)));\n+    assert!(!((1.0f64, 2.0f64) < (f64::NAN, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) <= (f64::NAN, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) > (f64::NAN, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) >= (f64::NAN, 3.0)));\n+    assert!(((1.0f64, 2.0f64) < (2.0, f64::NAN)));\n+    assert!(!((2.0f64, 2.0f64) < (2.0, f64::NAN)));\n }\n \n #[test]"}, {"sha": "ca349a7890a580278ab090e2733f92b50233f580", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1528,7 +1528,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     }\n }\n \n-pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n+pub const CODEGEN_WORKER_ID: usize = usize::MAX;\n \n /// `FatalError` is explicitly not `Send`.\n #[must_use]"}, {"sha": "8bd4ffd0a565ecedbc24bda2ad1d4be876b51353", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -507,7 +507,7 @@ fn get_argc_argv<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n+pub const CODEGEN_WORKER_ID: usize = usize::MAX;\n \n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,"}, {"sha": "3f5738a93a96d8f64e0347efed242e18e186ff45", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1361,7 +1361,7 @@ impl EmitterWriter {\n                 let mut multilines = FxHashMap::default();\n \n                 // Get the left-side margin to remove it\n-                let mut whitespace_margin = std::usize::MAX;\n+                let mut whitespace_margin = usize::MAX;\n                 for line_idx in 0..annotated_file.lines.len() {\n                     let file = annotated_file.file.clone();\n                     let line = &annotated_file.lines[line_idx];\n@@ -1373,19 +1373,19 @@ impl EmitterWriter {\n                         }\n                     }\n                 }\n-                if whitespace_margin == std::usize::MAX {\n+                if whitespace_margin == usize::MAX {\n                     whitespace_margin = 0;\n                 }\n \n                 // Left-most column any visible span points at.\n-                let mut span_left_margin = std::usize::MAX;\n+                let mut span_left_margin = usize::MAX;\n                 for line in &annotated_file.lines {\n                     for ann in &line.annotations {\n                         span_left_margin = min(span_left_margin, ann.start_col);\n                         span_left_margin = min(span_left_margin, ann.end_col);\n                     }\n                 }\n-                if span_left_margin == std::usize::MAX {\n+                if span_left_margin == usize::MAX {\n                     span_left_margin = 0;\n                 }\n \n@@ -1421,7 +1421,7 @@ impl EmitterWriter {\n                 } else {\n                     termize::dimensions()\n                         .map(|(w, _)| w.saturating_sub(code_offset))\n-                        .unwrap_or(std::usize::MAX)\n+                        .unwrap_or(usize::MAX)\n                 };\n \n                 let margin = Margin::new("}, {"sha": "46c38840516e2bc133ad393d7ed9f0d108bc25be", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -307,7 +307,7 @@ impl<'a, T: Idx> BitIter<'a, T> {\n         // additional state about whether we have started.\n         BitIter {\n             word: 0,\n-            offset: std::usize::MAX - (WORD_BITS - 1),\n+            offset: usize::MAX - (WORD_BITS - 1),\n             iter: words.iter(),\n             marker: PhantomData,\n         }"}, {"sha": "23e39f433f53b1ffcef60a091f32804b3f8974a6", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -51,7 +51,7 @@ pub trait AllocMap<K: Hash + Eq, V> {\n     where\n         K: Borrow<Q>;\n \n-    /// Returns data based the keys and values in the map.\n+    /// Returns data based on the keys and values in the map.\n     fn filter_map_collect<T>(&self, f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T>;\n \n     /// Returns a reference to entry `k`. If no such entry exists, call\n@@ -79,7 +79,7 @@ pub trait AllocMap<K: Hash + Eq, V> {\n /// and some use case dependent behaviour can instead be applied.\n pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKind: ::std::fmt::Debug + MayLeak + Eq + 'static;\n+    type MemoryKind: ::std::fmt::Debug + ::std::fmt::Display + MayLeak + Eq + 'static;\n \n     /// Tag tracked alongside every pointer. This is used to implement \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>."}, {"sha": "c16c59715e40c4992979552b19e9570a885c23ac", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 70, "deletions": 48, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -9,6 +9,7 @@\n use std::borrow::Cow;\n use std::collections::VecDeque;\n use std::convert::TryFrom;\n+use std::fmt;\n use std::ptr;\n \n use rustc_ast::ast::Mutability;\n@@ -20,6 +21,7 @@ use super::{\n     AllocId, AllocMap, Allocation, AllocationExtra, CheckInAllocMsg, ErrorHandled, GlobalAlloc,\n     GlobalId, InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Scalar,\n };\n+use crate::util::pretty;\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n pub enum MemoryKind<T> {\n@@ -45,6 +47,17 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n     }\n }\n \n+impl<T: fmt::Display> fmt::Display for MemoryKind<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            MemoryKind::Stack => write!(f, \"stack variable\"),\n+            MemoryKind::Vtable => write!(f, \"vtable\"),\n+            MemoryKind::CallerLocation => write!(f, \"caller location\"),\n+            MemoryKind::Machine(m) => write!(f, \"{}\", m),\n+        }\n+    }\n+}\n+\n /// Used by `get_size_and_align` to indicate whether the allocation needs to be live.\n #[derive(Debug, Copy, Clone)]\n pub enum AllocCheck {\n@@ -258,7 +271,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         if alloc_kind != kind {\n             throw_ub_format!(\n-                \"deallocating `{:?}` memory using `{:?}` deallocation operation\",\n+                \"deallocating {} memory using {} deallocation operation\",\n                 alloc_kind,\n                 kind\n             );\n@@ -644,81 +657,90 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.dump_allocs(vec![id]);\n     }\n \n-    fn dump_alloc_helper<Tag, Extra>(\n-        &self,\n-        allocs_seen: &mut FxHashSet<AllocId>,\n-        allocs_to_print: &mut VecDeque<AllocId>,\n-        alloc: &Allocation<Tag, Extra>,\n-    ) {\n-        for &(_, (_, target_id)) in alloc.relocations().iter() {\n-            if allocs_seen.insert(target_id) {\n-                allocs_to_print.push_back(target_id);\n-            }\n-        }\n-        crate::util::pretty::write_allocation(self.tcx.tcx, alloc, &mut std::io::stderr(), \"\")\n-            .unwrap();\n-    }\n-\n     /// Print a list of allocations and all allocations they point to, recursively.\n     /// This prints directly to stderr, ignoring RUSTC_LOG! It is up to the caller to\n     /// control for this.\n     pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n+        // Cannot be a closure because it is generic in `Tag`, `Extra`.\n+        fn write_allocation_track_relocs<'tcx, Tag, Extra>(\n+            tcx: TyCtxtAt<'tcx>,\n+            allocs_to_print: &mut VecDeque<AllocId>,\n+            alloc: &Allocation<Tag, Extra>,\n+        ) {\n+            for &(_, target_id) in alloc.relocations().values() {\n+                allocs_to_print.push_back(target_id);\n+            }\n+            pretty::write_allocation(tcx.tcx, alloc, &mut std::io::stderr()).unwrap();\n+        }\n+\n         allocs.sort();\n         allocs.dedup();\n         let mut allocs_to_print = VecDeque::from(allocs);\n-        let mut allocs_seen = FxHashSet::default();\n+        // `allocs_printed` contains all allocations that we have already printed.\n+        let mut allocs_printed = FxHashSet::default();\n \n         while let Some(id) = allocs_to_print.pop_front() {\n-            eprint!(\"Alloc {:<5}: \", id);\n-            fn msg<Tag, Extra>(alloc: &Allocation<Tag, Extra>, extra: &str) {\n-                eprintln!(\n-                    \"({} bytes, alignment {}){}\",\n-                    alloc.size.bytes(),\n-                    alloc.align.bytes(),\n-                    extra\n-                )\n-            };\n+            if !allocs_printed.insert(id) {\n+                // Already printed, so skip this.\n+                continue;\n+            }\n \n-            // normal alloc?\n-            match self.alloc_map.get_or(id, || Err(())) {\n-                Ok((kind, alloc)) => {\n-                    match kind {\n-                        MemoryKind::Stack => msg(alloc, \" (stack)\"),\n-                        MemoryKind::Vtable => msg(alloc, \" (vtable)\"),\n-                        MemoryKind::CallerLocation => msg(alloc, \" (caller_location)\"),\n-                        MemoryKind::Machine(m) => msg(alloc, &format!(\" ({:?})\", m)),\n-                    };\n-                    self.dump_alloc_helper(&mut allocs_seen, &mut allocs_to_print, alloc);\n+            eprint!(\"{}\", id);\n+            match self.alloc_map.get(id) {\n+                Some(&(kind, ref alloc)) => {\n+                    // normal alloc\n+                    eprint!(\" ({}, \", kind);\n+                    write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n                 }\n-                Err(()) => {\n-                    // global alloc?\n+                None => {\n+                    // global alloc\n                     match self.tcx.alloc_map.lock().get(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n-                            msg(alloc, \" (immutable)\");\n-                            self.dump_alloc_helper(&mut allocs_seen, &mut allocs_to_print, alloc);\n+                            eprint!(\" (unchanged global, \");\n+                            write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n                         }\n                         Some(GlobalAlloc::Function(func)) => {\n-                            eprintln!(\"{}\", func);\n+                            eprint!(\" (fn: {})\", func);\n                         }\n                         Some(GlobalAlloc::Static(did)) => {\n-                            eprintln!(\"{:?}\", did);\n+                            eprint!(\" (static: {})\", self.tcx.def_path_str(did));\n                         }\n                         None => {\n-                            eprintln!(\"(deallocated)\");\n+                            eprint!(\" (deallocated)\");\n                         }\n                     }\n                 }\n-            };\n+            }\n+            eprintln!();\n         }\n     }\n \n     pub fn leak_report(&self) -> usize {\n-        let leaks: Vec<_> = self\n-            .alloc_map\n-            .filter_map_collect(|&id, &(kind, _)| if kind.may_leak() { None } else { Some(id) });\n+        // Collect the set of allocations that are *reachable* from `Global` allocations.\n+        let reachable = {\n+            let mut reachable = FxHashSet::default();\n+            let global_kind = M::GLOBAL_KIND.map(MemoryKind::Machine);\n+            let mut todo: Vec<_> = self.alloc_map.filter_map_collect(move |&id, &(kind, _)| {\n+                if Some(kind) == global_kind { Some(id) } else { None }\n+            });\n+            while let Some(id) = todo.pop() {\n+                if reachable.insert(id) {\n+                    // This is a new allocation, add its relocations to `todo`.\n+                    if let Some((_, alloc)) = self.alloc_map.get(id) {\n+                        todo.extend(alloc.relocations().values().map(|&(_, target_id)| target_id));\n+                    }\n+                }\n+            }\n+            reachable\n+        };\n+\n+        // All allocations that are *not* `reachable` and *not* `may_leak` are considered leaking.\n+        let leaks: Vec<_> = self.alloc_map.filter_map_collect(|&id, &(kind, _)| {\n+            if kind.may_leak() || reachable.contains(&id) { None } else { Some(id) }\n+        });\n         let n = leaks.len();\n         if n > 0 {\n-            eprintln!(\"### LEAK REPORT ###\");\n+            eprintln!(\"The following memory was leaked:\");\n             self.dump_allocs(leaks);\n         }\n         n"}, {"sha": "44aa9a710b65343629f21bc4def713aef493a2f2", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -455,11 +455,18 @@ fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibilit\n fn merge_codegen_units<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-    target_cgu_count: usize,\n+    mut target_cgu_count: usize,\n ) {\n     assert!(target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n+    if tcx.is_compiler_builtins(LOCAL_CRATE) {\n+        // Compiler builtins require some degree of control over how mono items\n+        // are partitioned into compilation units. Provide it by keeping the\n+        // original partitioning when compiling the compiler builtins crate.\n+        target_cgu_count = codegen_units.len();\n+    }\n+\n     // Note that at this point in time the `codegen_units` here may not be in a\n     // deterministic order (but we know they're deterministically the same set).\n     // We want this merging to produce a deterministic ordering of codegen units"}, {"sha": "64221c41bffe4f56f1b373f99eced4b42d48d152", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -567,26 +567,21 @@ pub fn write_allocations<'tcx>(\n     }\n     let mut visitor = CollectAllocIds(Default::default());\n     body.visit_with(&mut visitor);\n+    // `seen` contains all seen allocations, including the ones we have *not* printed yet.\n+    // The protocol is to first `insert` into `seen`, and only if that returns `true`\n+    // then push to `todo`.\n     let mut seen = visitor.0;\n     let mut todo: Vec<_> = seen.iter().copied().collect();\n     while let Some(id) = todo.pop() {\n-        let mut write_header_and_allocation =\n+        let mut write_allocation_track_relocs =\n             |w: &mut dyn Write, alloc: &Allocation| -> io::Result<()> {\n-                write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n-                if alloc.size == Size::ZERO {\n-                    write!(w, \" {{}}\")?;\n-                } else {\n-                    writeln!(w, \" {{\")?;\n-                    write_allocation(tcx, alloc, w, \"    \")?;\n-                    write!(w, \"}}\")?;\n-                    // `.rev()` because we are popping them from the back of the `todo` vector.\n-                    for id in alloc_ids_from_alloc(alloc).rev() {\n-                        if seen.insert(id) {\n-                            todo.push(id);\n-                        }\n+                // `.rev()` because we are popping them from the back of the `todo` vector.\n+                for id in alloc_ids_from_alloc(alloc).rev() {\n+                    if seen.insert(id) {\n+                        todo.push(id);\n                     }\n                 }\n-                Ok(())\n+                write_allocation(tcx, alloc, w)\n             };\n         write!(w, \"\\n{}\", id)?;\n         let alloc = tcx.alloc_map.lock().get(id);\n@@ -599,7 +594,7 @@ pub fn write_allocations<'tcx>(\n                 match tcx.const_eval_poly(did) {\n                     Ok(ConstValue::ByRef { alloc, .. }) => {\n                         write!(w, \" (static: {}, \", tcx.def_path_str(did))?;\n-                        write_header_and_allocation(w, alloc)?;\n+                        write_allocation_track_relocs(w, alloc)?;\n                     }\n                     Ok(_) => {\n                         span_bug!(tcx.def_span(did), \" static item without `ByRef` initializer\")\n@@ -616,15 +611,46 @@ pub fn write_allocations<'tcx>(\n             }\n             Some(GlobalAlloc::Memory(alloc)) => {\n                 write!(w, \" (\")?;\n-                write_header_and_allocation(w, alloc)?\n+                write_allocation_track_relocs(w, alloc)?\n             }\n         }\n-\n         writeln!(w)?;\n     }\n     Ok(())\n }\n \n+/// Dumps the size and metadata and content of an allocation to the given writer.\n+/// The expectation is that the caller first prints other relevant metadata, so the exact\n+/// format of this function is (*without* leading or trailing newline):\n+/// ```\n+/// size: {}, align: {}) {\n+///     <bytes>\n+/// }\n+/// ```\n+///\n+/// The byte format is similar to how hex editors print bytes. Each line starts with the address of\n+/// the start of the line, followed by all bytes in hex format (space separated).\n+/// If the allocation is small enough to fit into a single line, no start address is given.\n+/// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n+/// characters or characters whose value is larger than 127) with a `.`\n+/// This also prints relocations adequately.\n+pub fn write_allocation<Tag, Extra>(\n+    tcx: TyCtxt<'tcx>,\n+    alloc: &Allocation<Tag, Extra>,\n+    w: &mut dyn Write,\n+) -> io::Result<()> {\n+    write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n+    if alloc.size == Size::ZERO {\n+        // We are done.\n+        return write!(w, \" {{}}\");\n+    }\n+    // Write allocation bytes.\n+    writeln!(w, \" {{\")?;\n+    write_allocation_bytes(tcx, alloc, w, \"    \")?;\n+    write!(w, \"}}\")?;\n+    Ok(())\n+}\n+\n fn write_allocation_endline(w: &mut dyn Write, ascii: &str) -> io::Result<()> {\n     for _ in 0..(BYTES_PER_LINE - ascii.chars().count()) {\n         write!(w, \"   \")?;\n@@ -649,18 +675,10 @@ fn write_allocation_newline(\n     Ok(line_start)\n }\n \n-/// Dumps the bytes of an allocation to the given writer. This also prints relocations instead of\n-/// the raw bytes where applicable.\n-/// The byte format is similar to how hex editors print bytes. Each line starts with the address of\n-/// the start of the line, followed by all bytes in hex format (space separated).\n-/// If the allocation is small enough to fit into a single line, no start address is given.\n-/// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n-/// characters or characters whose value is larger than 127) with a `.`\n-///\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-pub fn write_allocation<Tag, Extra>(\n+fn write_allocation_bytes<Tag, Extra>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &Allocation<Tag, Extra>,\n     w: &mut dyn Write,"}, {"sha": "3cb250891ef934de3f86473ee2be89fc84e45680", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -612,7 +612,7 @@ fn receiver_is_dispatchable<'tcx>(\n     // FIXME(mikeyhew) this is a total hack. Once object_safe_for_dispatch is stabilized, we can\n     // replace this with `dyn Trait`\n     let unsized_self_ty: Ty<'tcx> =\n-        tcx.mk_ty_param(::std::u32::MAX, Symbol::intern(\"RustaceansAreAwesome\"));\n+        tcx.mk_ty_param(u32::MAX, Symbol::intern(\"RustaceansAreAwesome\"));\n \n     // `Receiver[Self => U]`\n     let unsized_receiver_ty ="}, {"sha": "56e4ac5c72a49df2f5f554c502f5aa6629a852cf", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -3650,11 +3650,7 @@ struct ProvisionalEvaluation {\n \n impl<'tcx> Default for ProvisionalEvaluationCache<'tcx> {\n     fn default() -> Self {\n-        Self {\n-            dfn: Cell::new(0),\n-            reached_depth: Cell::new(std::usize::MAX),\n-            map: Default::default(),\n-        }\n+        Self { dfn: Cell::new(0), reached_depth: Cell::new(usize::MAX), map: Default::default() }\n     }\n }\n \n@@ -3753,7 +3749,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n             op(fresh_trait_ref, eval.result);\n         }\n \n-        self.reached_depth.set(std::usize::MAX);\n+        self.reached_depth.set(usize::MAX);\n     }\n }\n "}, {"sha": "c5e9a288c9ce89994a7ebea3211cd587f5451736", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -2620,13 +2620,13 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<usize> {\n         _ => None,\n     };\n     if let Some(Lit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) = sole_meta_list {\n-        if *ordinal <= std::usize::MAX as u128 {\n+        if *ordinal <= usize::MAX as u128 {\n             Some(*ordinal as usize)\n         } else {\n             let msg = format!(\"ordinal value in `link_ordinal` is too large: `{}`\", &ordinal);\n             tcx.sess\n                 .struct_span_err(attr.span, &msg)\n-                .note(\"the value may not exceed `std::usize::MAX`\")\n+                .note(\"the value may not exceed `usize::MAX`\")\n                 .emit();\n             None\n         }"}, {"sha": "cacc28b6e60e4e9e50b3a029365c721fdfc87860", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -198,7 +198,7 @@ use std::num::FpCategory as Fp;\n use std::ops::Index;\n use std::str::FromStr;\n use std::string;\n-use std::{char, f64, fmt, str};\n+use std::{char, fmt, str};\n \n use crate::Encodable;\n "}, {"sha": "a6ec1580aca36a5d13605c538ea76609724c0c17", "filename": "src/libserialize/tests/opaque.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibserialize%2Ftests%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibserialize%2Ftests%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Ftests%2Fopaque.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -53,63 +53,63 @@ fn test_unit() {\n #[test]\n fn test_u8() {\n     let mut vec = vec![];\n-    for i in ::std::u8::MIN..::std::u8::MAX {\n+    for i in u8::MIN..u8::MAX {\n         vec.push(i);\n     }\n     check_round_trip(vec);\n }\n \n #[test]\n fn test_u16() {\n-    for i in ::std::u16::MIN..::std::u16::MAX {\n+    for i in u16::MIN..u16::MAX {\n         check_round_trip(vec![1, 2, 3, i, i, i]);\n     }\n }\n \n #[test]\n fn test_u32() {\n-    check_round_trip(vec![1, 2, 3, ::std::u32::MIN, 0, 1, ::std::u32::MAX, 2, 1]);\n+    check_round_trip(vec![1, 2, 3, u32::MIN, 0, 1, u32::MAX, 2, 1]);\n }\n \n #[test]\n fn test_u64() {\n-    check_round_trip(vec![1, 2, 3, ::std::u64::MIN, 0, 1, ::std::u64::MAX, 2, 1]);\n+    check_round_trip(vec![1, 2, 3, u64::MIN, 0, 1, u64::MAX, 2, 1]);\n }\n \n #[test]\n fn test_usize() {\n-    check_round_trip(vec![1, 2, 3, ::std::usize::MIN, 0, 1, ::std::usize::MAX, 2, 1]);\n+    check_round_trip(vec![1, 2, 3, usize::MIN, 0, 1, usize::MAX, 2, 1]);\n }\n \n #[test]\n fn test_i8() {\n     let mut vec = vec![];\n-    for i in ::std::i8::MIN..::std::i8::MAX {\n+    for i in i8::MIN..i8::MAX {\n         vec.push(i);\n     }\n     check_round_trip(vec);\n }\n \n #[test]\n fn test_i16() {\n-    for i in ::std::i16::MIN..::std::i16::MAX {\n+    for i in i16::MIN..i16::MAX {\n         check_round_trip(vec![-1, 2, -3, i, i, i, 2]);\n     }\n }\n \n #[test]\n fn test_i32() {\n-    check_round_trip(vec![-1, 2, -3, ::std::i32::MIN, 0, 1, ::std::i32::MAX, 2, 1]);\n+    check_round_trip(vec![-1, 2, -3, i32::MIN, 0, 1, i32::MAX, 2, 1]);\n }\n \n #[test]\n fn test_i64() {\n-    check_round_trip(vec![-1, 2, -3, ::std::i64::MIN, 0, 1, ::std::i64::MAX, 2, 1]);\n+    check_round_trip(vec![-1, 2, -3, i64::MIN, 0, 1, i64::MAX, 2, 1]);\n }\n \n #[test]\n fn test_isize() {\n-    check_round_trip(vec![-1, 2, -3, ::std::isize::MIN, 0, 1, ::std::isize::MAX, 2, 1]);\n+    check_round_trip(vec![-1, 2, -3, isize::MIN, 0, 1, isize::MAX, 2, 1]);\n }\n \n #[test]"}, {"sha": "d1cb8e92d5688a9af19c95dba6aa14775a675355", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -2617,7 +2617,6 @@ mod test_map {\n     use crate::cell::RefCell;\n     use rand::{thread_rng, Rng};\n     use realstd::collections::TryReserveError::*;\n-    use realstd::usize;\n \n     // https://github.com/rust-lang/rust/issues/62301\n     fn _assert_hashmap_is_unwind_safe() {"}, {"sha": "0a4802fb2c80dd7f8a87dfca09f8e179f0a03a0a", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1329,6 +1329,12 @@ impl ToOwned for CStr {\n     fn to_owned(&self) -> CString {\n         CString { inner: self.to_bytes_with_nul().into() }\n     }\n+\n+    fn clone_into(&self, target: &mut CString) {\n+        let mut b = Vec::from(mem::take(&mut target.inner));\n+        self.to_bytes_with_nul().clone_into(&mut b);\n+        target.inner = b.into_boxed_slice();\n+    }\n }\n \n #[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n@@ -1510,6 +1516,17 @@ mod tests {\n         assert_eq!(boxed.to_bytes_with_nul(), &[0]);\n     }\n \n+    #[test]\n+    fn test_c_str_clone_into() {\n+        let mut c_string = CString::new(\"lorem\").unwrap();\n+        let c_ptr = c_string.as_ptr();\n+        let c_str = CStr::from_bytes_with_nul(b\"ipsum\\0\").unwrap();\n+        c_str.clone_into(&mut c_string);\n+        assert_eq!(c_str, c_string.as_c_str());\n+        // The exact same size shouldn't have needed to move its allocation\n+        assert_eq!(c_ptr, c_string.as_ptr());\n+    }\n+\n     #[test]\n     fn into_rc() {\n         let orig: &[u8] = b\"Hello, world!\\0\";"}, {"sha": "4fde33169733e60268a505f881a55962e596d3e2", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1120,8 +1120,7 @@ impl ToOwned for OsStr {\n         self.to_os_string()\n     }\n     fn clone_into(&self, target: &mut OsString) {\n-        target.clear();\n-        target.push(self);\n+        self.inner.clone_into(&mut target.inner)\n     }\n }\n "}, {"sha": "2f5fc72ab44c2553ede8bffee6c8e506ee94957a", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -159,6 +159,10 @@ impl Slice {\n         Buf { inner: buf }\n     }\n \n+    pub fn clone_into(&self, buf: &mut Buf) {\n+        self.inner.clone_into(&mut buf.inner)\n+    }\n+\n     #[inline]\n     pub fn into_box(&self) -> Box<Slice> {\n         unsafe { mem::transmute(self.inner.into_box()) }"}, {"sha": "984c032e2a388829d5f0c0b13d6cd35c9d380a90", "filename": "src/libstd/sys_common/os_str_bytes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -173,6 +173,10 @@ impl Slice {\n         Buf { inner: self.inner.to_vec() }\n     }\n \n+    pub fn clone_into(&self, buf: &mut Buf) {\n+        self.inner.clone_into(&mut buf.inner)\n+    }\n+\n     #[inline]\n     pub fn into_box(&self) -> Box<Slice> {\n         let boxed: Box<[u8]> = self.inner.into();"}, {"sha": "a98407da44850f50bc0de5e684177172a748baa5", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -613,6 +613,10 @@ impl Wtf8 {\n         }\n     }\n \n+    pub fn clone_into(&self, buf: &mut Wtf8Buf) {\n+        self.bytes.clone_into(&mut buf.bytes)\n+    }\n+\n     /// Boxes this `Wtf8`.\n     #[inline]\n     pub fn into_box(&self) -> Box<Wtf8> {"}, {"sha": "3a6e8401bf1abe17641255857394246634f57554", "filename": "src/libtest/stats/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibtest%2Fstats%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Flibtest%2Fstats%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats%2Ftests.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -2,7 +2,6 @@ use super::*;\n \n extern crate test;\n use self::test::test::Bencher;\n-use std::f64;\n use std::io;\n use std::io::prelude::*;\n "}, {"sha": "1a577bd78e84e357e29c5336ff8beb432873046b", "filename": "src/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstdarch?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -1 +1 @@\n-Subproject commit abe96ca3b87fcca6aa1dfcefd40d8c8d92d2e673\n+Subproject commit 1a577bd78e84e357e29c5336ff8beb432873046b"}, {"sha": "25195743b04007360ab92f5e8cf6d337ee021333", "filename": "src/test/codegen-units/partitioning/compiler-builtins.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fcompiler-builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fcompiler-builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fcompiler-builtins.rs?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -0,0 +1,40 @@\n+// Verifies that during compiler_builtins compilation the codegen units are kept\n+// unmerged. Even when only a single codegen unit is requested with -Ccodegen-units=1.\n+//\n+// compile-flags: -Zprint-mono-items=eager -Ccodegen-units=1\n+\n+#![compiler_builtins]\n+#![crate_type=\"lib\"]\n+#![feature(compiler_builtins)]\n+\n+mod atomics {\n+    //~ MONO_ITEM fn compiler_builtins::atomics[0]::sync_1[0] @@ compiler_builtins-cgu.0[External]\n+    #[no_mangle]\n+    pub extern \"C\" fn sync_1() {}\n+\n+    //~ MONO_ITEM fn compiler_builtins::atomics[0]::sync_2[0] @@ compiler_builtins-cgu.0[External]\n+    #[no_mangle]\n+    pub extern \"C\" fn sync_2() {}\n+\n+    //~ MONO_ITEM fn compiler_builtins::atomics[0]::sync_3[0] @@ compiler_builtins-cgu.0[External]\n+    #[no_mangle]\n+    pub extern \"C\" fn sync_3() {}\n+}\n+\n+mod x {\n+    //~ MONO_ITEM fn compiler_builtins::x[0]::x[0] @@ compiler_builtins-cgu.1[External]\n+    #[no_mangle]\n+    pub extern \"C\" fn x() {}\n+}\n+\n+mod y {\n+    //~ MONO_ITEM fn compiler_builtins::y[0]::y[0] @@ compiler_builtins-cgu.2[External]\n+    #[no_mangle]\n+    pub extern \"C\" fn y() {}\n+}\n+\n+mod z {\n+    //~ MONO_ITEM fn compiler_builtins::z[0]::z[0] @@ compiler_builtins-cgu.3[External]\n+    #[no_mangle]\n+    pub extern \"C\" fn z() {}\n+}"}, {"sha": "b9b877aa0566c8c8404da64323d95d645c9377c1", "filename": "src/test/ui/rfc-2627-raw-dylib/link-ordinal-too-large.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Ftest%2Fui%2Frfc-2627-raw-dylib%2Flink-ordinal-too-large.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42abbd8878d3b67238f3611b0587c704ba94f39c/src%2Ftest%2Fui%2Frfc-2627-raw-dylib%2Flink-ordinal-too-large.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2627-raw-dylib%2Flink-ordinal-too-large.stderr?ref=42abbd8878d3b67238f3611b0587c704ba94f39c", "patch": "@@ -12,7 +12,7 @@ error: ordinal value in `link_ordinal` is too large: `18446744073709551616`\n LL |     #[link_ordinal(18446744073709551616)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: the value may not exceed `std::usize::MAX`\n+   = note: the value may not exceed `usize::MAX`\n \n error: aborting due to previous error\n "}]}