{"sha": "e93654c96d0288e6f2f00075d95dd4958b4cb4dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MzY1NGM5NmQwMjg4ZTZmMmYwMDA3NWQ5NWRkNDk1OGI0Y2I0ZGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-21T03:33:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-22T15:49:45Z"}, "message": "Pass the fmt! buffer to each conversion method\n\nAchieves a little more speedup and avoids allocations around some strings in\nconv_str", "tree": {"sha": "5fc8b18de7acef9b31c276beec3315d24d374bef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fc8b18de7acef9b31c276beec3315d24d374bef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e93654c96d0288e6f2f00075d95dd4958b4cb4dc", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e93654c96d0288e6f2f00075d95dd4958b4cb4dc", "html_url": "https://github.com/rust-lang/rust/commit/e93654c96d0288e6f2f00075d95dd4958b4cb4dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e93654c96d0288e6f2f00075d95dd4958b4cb4dc/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0bbc6242fa80d7431cc7ea99a3b20f4eb8595ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0bbc6242fa80d7431cc7ea99a3b20f4eb8595ab", "html_url": "https://github.com/rust-lang/rust/commit/c0bbc6242fa80d7431cc7ea99a3b20f4eb8595ab"}], "stats": {"total": 326, "additions": 268, "deletions": 58}, "files": [{"sha": "7527a6afb557526e8f8ac24e3b373e1f0cb33cd7", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/e93654c96d0288e6f2f00075d95dd4958b4cb4dc/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93654c96d0288e6f2f00075d95dd4958b4cb4dc/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=e93654c96d0288e6f2f00075d95dd4958b4cb4dc", "patch": "@@ -470,6 +470,215 @@ pub mod ct {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it this way, I think.\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+#[doc(hidden)]\n+pub mod rt {\n+    use float;\n+    use str;\n+    use sys;\n+    use int;\n+    use uint;\n+    use vec;\n+    use option::{Some, None, Option};\n+\n+    pub const flag_none : u32 = 0u32;\n+    pub const flag_left_justify   : u32 = 0b00000000000001u32;\n+    pub const flag_left_zero_pad  : u32 = 0b00000000000010u32;\n+    pub const flag_space_for_sign : u32 = 0b00000000000100u32;\n+    pub const flag_sign_always    : u32 = 0b00000000001000u32;\n+    pub const flag_alternate      : u32 = 0b00000000010000u32;\n+\n+    pub enum Count { CountIs(uint), CountImplied, }\n+\n+    pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n+\n+    pub struct Conv {\n+        flags: u32,\n+        width: Count,\n+        precision: Count,\n+        ty: Ty,\n+    }\n+\n+    pub pure fn conv_int(cv: Conv, i: int, buf: &mut ~str) {\n+        let radix = 10;\n+        let prec = get_int_precision(cv);\n+        let mut s : ~str = uint_to_str_prec(int::abs(i) as uint, radix, prec);\n+\n+        let head = if i >= 0 {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                Some('+')\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                Some(' ')\n+            } else {\n+                None\n+            }\n+        } else { Some('-') };\n+        unsafe { pad(cv, s, head, PadSigned, buf) };\n+    }\n+    pub pure fn conv_uint(cv: Conv, u: uint, buf: &mut ~str) {\n+        let prec = get_int_precision(cv);\n+        let mut rs =\n+            match cv.ty {\n+              TyDefault => uint_to_str_prec(u, 10, prec),\n+              TyHexLower => uint_to_str_prec(u, 16, prec),\n+              TyHexUpper => str::to_upper(uint_to_str_prec(u, 16, prec)),\n+              TyBits => uint_to_str_prec(u, 2, prec),\n+              TyOctal => uint_to_str_prec(u, 8, prec)\n+            };\n+        unsafe { pad(cv, rs, None, PadUnsigned, buf) };\n+    }\n+    pub pure fn conv_bool(cv: Conv, b: bool, buf: &mut ~str) {\n+        let s = if b { \"true\" } else { \"false\" };\n+        // run the boolean conversion through the string conversion logic,\n+        // giving it the same rules for precision, etc.\n+        conv_str(cv, s, buf);\n+    }\n+    pub pure fn conv_char(cv: Conv, c: char, buf: &mut ~str) {\n+        unsafe { pad(cv, \"\", Some(c), PadNozero, buf) };\n+    }\n+    pub pure fn conv_str(cv: Conv, s: &str, buf: &mut ~str) {\n+        // For strings, precision is the maximum characters\n+        // displayed\n+        let mut unpadded = match cv.precision {\n+          CountImplied => s,\n+          CountIs(max) => if (max as uint) < str::char_len(s) {\n+            str::slice(s, 0, max as uint)\n+          } else {\n+            s\n+          }\n+        };\n+        unsafe { pad(cv, unpadded, None, PadNozero, buf) };\n+    }\n+    pub pure fn conv_float(cv: Conv, f: float, buf: &mut ~str) {\n+        let (to_str, digits) = match cv.precision {\n+              CountIs(c) => (float::to_str_exact, c as uint),\n+              CountImplied => (float::to_str_digits, 6u)\n+        };\n+        let mut s = unsafe { to_str(f, digits) };\n+        let head = if 0.0 <= f {\n+            if have_flag(cv.flags, flag_sign_always) {\n+                Some('+')\n+            } else if have_flag(cv.flags, flag_space_for_sign) {\n+                Some(' ')\n+            } else {\n+                None\n+            }\n+        } else { None };\n+        unsafe { pad(cv, s, head, PadFloat, buf) };\n+    }\n+    pub pure fn conv_poly<T>(cv: Conv, v: &T, buf: &mut ~str) {\n+        let s = sys::log_str(v);\n+        conv_str(cv, s, buf);\n+    }\n+\n+    // Convert a uint to string with a minimum number of digits.  If precision\n+    // is 0 and num is 0 then the result is the empty string. Could move this\n+    // to uint: but it doesn't seem all that useful.\n+    pub pure fn uint_to_str_prec(num: uint, radix: uint,\n+                                 prec: uint) -> ~str {\n+        return if prec == 0u && num == 0u {\n+                ~\"\"\n+            } else {\n+                let s = uint::to_str_radix(num, radix);\n+                let len = str::char_len(s);\n+                if len < prec {\n+                    let diff = prec - len;\n+                    let pad = str::from_chars(vec::from_elem(diff, '0'));\n+                    pad + s\n+                } else { s }\n+            };\n+    }\n+    pub pure fn get_int_precision(cv: Conv) -> uint {\n+        return match cv.precision {\n+              CountIs(c) => c as uint,\n+              CountImplied => 1u\n+            };\n+    }\n+\n+    #[deriving(Eq)]\n+    pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n+\n+    pub fn pad(cv: Conv, mut s: &str, head: Option<char>, mode: PadMode,\n+               buf: &mut ~str) {\n+        let headsize = match head { Some(_) => 1, _ => 0 };\n+        let uwidth : uint = match cv.width {\n+            CountImplied => {\n+                for head.each |&c| {\n+                    buf.push_char(c);\n+                }\n+                return buf.push_str(s);\n+            }\n+            CountIs(width) => { width as uint }\n+        };\n+        let strlen = str::char_len(s) + headsize;\n+        if uwidth <= strlen {\n+            for head.each |&c| {\n+                buf.push_char(c);\n+            }\n+            return buf.push_str(s);\n+        }\n+        let mut padchar = ' ';\n+        let diff = uwidth - strlen;\n+        if have_flag(cv.flags, flag_left_justify) {\n+            for head.each |&c| {\n+                buf.push_char(c);\n+            }\n+            buf.push_str(s);\n+            for diff.times {\n+                buf.push_char(padchar);\n+            }\n+            return;\n+        }\n+        let (might_zero_pad, signed) = match mode {\n+          PadNozero   => (false, true),\n+          PadSigned   => (true, true),\n+          PadFloat    => (true, true),\n+          PadUnsigned => (true, false)\n+        };\n+        pure fn have_precision(cv: Conv) -> bool {\n+            return match cv.precision { CountImplied => false, _ => true };\n+        }\n+        let zero_padding = {\n+            if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n+                (!have_precision(cv) || mode == PadFloat) {\n+                padchar = '0';\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+        let padstr = str::from_chars(vec::from_elem(diff, padchar));\n+        // This is completely heinous. If we have a signed value then\n+        // potentially rip apart the intermediate result and insert some\n+        // zeros. It may make sense to convert zero padding to a precision\n+        // instead.\n+\n+        if signed && zero_padding {\n+            for head.each |&head| {\n+                if head == '+' || head == '-' || head == ' ' {\n+                    buf.push_char(head);\n+                    buf.push_str(padstr);\n+                    buf.push_str(s);\n+                    return;\n+                }\n+            }\n+        }\n+        buf.push_str(padstr);\n+        for head.each |&c| {\n+            buf.push_char(c);\n+        }\n+        buf.push_str(s);\n+    }\n+    #[inline(always)]\n+    pub pure fn have_flag(flags: u32, f: u32) -> bool {\n+        flags & f != 0\n+    }\n+}\n+\n+// XXX: remove after a snapshot of the above changes have gone in\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub mod rt {\n     use float;"}, {"sha": "3ebe844950a40cd2599fe93b49c52b4d466df44e", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/e93654c96d0288e6f2f00075d95dd4958b4cb4dc/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e93654c96d0288e6f2f00075d95dd4958b4cb4dc/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=e93654c96d0288e6f2f00075d95dd4958b4cb4dc", "patch": "@@ -139,19 +139,17 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         make_conv_struct(cx, sp, rt_conv_flags, rt_conv_width,\n                          rt_conv_precision, rt_conv_ty)\n     }\n-    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: ~str, cnv: &Conv,\n-                      arg: @ast::expr) -> @ast::expr {\n+    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: &str, cnv: &Conv,\n+                      arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(cx, @fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n-        let args = ~[cnv_expr, arg];\n+        let args = ~[cnv_expr, arg, buf];\n         return mk_call_global(cx, arg.span, path, args);\n     }\n \n-    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: &Conv, arg: @ast::expr) ->\n-       @ast::expr {\n-        // FIXME: Move validation code into core::extfmt (Issue #2249)\n-\n+    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: &Conv,\n+                     arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         fn is_signed_type(cnv: &Conv) -> bool {\n             match cnv.ty {\n               TyInt(s) => match s {\n@@ -198,27 +196,17 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n           CountIs(_) => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n-        match cnv.ty {\n-          TyStr => return make_conv_call(cx, arg.span, ~\"str\", cnv, arg),\n-          TyInt(sign) => match sign {\n-            Signed => return make_conv_call(cx, arg.span, ~\"int\", cnv, arg),\n-            Unsigned => {\n-                return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg)\n-            }\n-          },\n-          TyBool => return make_conv_call(cx, arg.span, ~\"bool\", cnv, arg),\n-          TyChar => return make_conv_call(cx, arg.span, ~\"char\", cnv, arg),\n-          TyHex(_) => {\n-            return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n-          }\n-          TyBits => return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg),\n-          TyOctal => return make_conv_call(cx, arg.span, ~\"uint\", cnv, arg),\n-          TyFloat => {\n-            return make_conv_call(cx, arg.span, ~\"float\", cnv, arg);\n-          }\n-          TyPoly => return make_conv_call(cx, arg.span, ~\"poly\", cnv,\n-                       mk_addr_of(cx, sp, arg))\n-        }\n+        let (name, actual_arg) = match cnv.ty {\n+            TyStr => (\"str\", arg),\n+            TyInt(Signed) => (\"int\", arg),\n+            TyBool => (\"bool\", arg),\n+            TyChar => (\"char\", arg),\n+            TyBits | TyOctal | TyHex(_) | TyInt(Unsigned) => (\"uint\", arg),\n+            TyFloat => (\"float\", arg),\n+            TyPoly => (\"poly\", mk_addr_of(cx, sp, arg))\n+        };\n+        return make_conv_call(cx, arg.span, name, cnv, actual_arg,\n+                              mk_mut_addr_of(cx, arg.span, buf));\n     }\n     fn log_conv(c: &Conv) {\n         debug!(\"Building conversion:\");\n@@ -270,57 +258,70 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         }\n     }\n \n-    /* Translate each piece (portion of the fmt expression) into a ~str\n-       expression to be concatenated below */\n     let fmt_sp = args[0].span;\n     let mut n = 0u;\n     let nargs = args.len();\n-    let pieces = do vec::map_consume(pieces) |pc| {\n+\n+    /* 'ident' is the local buffer building up the result of fmt! */\n+    let ident = cx.parse_sess().interner.intern(@~\"__fmtbuf\");\n+    let buf = || mk_path(cx, fmt_sp, ~[ident]);\n+    let str_ident = cx.parse_sess().interner.intern(@~\"str\");\n+    let push_ident = cx.parse_sess().interner.intern(@~\"push_str\");\n+    let mut stms = ~[];\n+\n+    /* Translate each piece (portion of the fmt expression) by invoking the\n+       corresponding function in core::unstable::extfmt. Each function takes a\n+       buffer to insert data into along with the data being formatted. */\n+    do vec::consume(pieces) |i, pc| {\n         match pc {\n-            PieceString(s) => mk_uniq_str(cx, fmt_sp, s),\n+            /* Raw strings get appended via str::push_str */\n+            PieceString(s) => {\n+                let portion = mk_uniq_str(cx, fmt_sp, s);\n+\n+                /* If this is the first portion, then initialize the local\n+                   buffer with it directly */\n+                if i == 0 {\n+                    stms.push(mk_local(cx, fmt_sp, true, ident, portion));\n+                } else {\n+                    let args = ~[mk_mut_addr_of(cx, fmt_sp, buf()), portion];\n+                    let call = mk_call_global(cx,\n+                                              fmt_sp,\n+                                              ~[str_ident, push_ident],\n+                                              args);\n+                    stms.push(mk_stmt(cx, fmt_sp, call));\n+                }\n+            }\n+\n+            /* Invoke the correct conv function in extfmt */\n             PieceConv(ref conv) => {\n                 n += 1u;\n                 if n >= nargs {\n                     cx.span_fatal(sp,\n                                   ~\"not enough arguments to fmt! \" +\n                                   ~\"for the given format string\");\n                 }\n+\n                 log_conv(conv);\n-                make_new_conv(cx, fmt_sp, conv, args[n])\n+                /* If the first portion is a conversion, then the local buffer\n+                   must be initialized as an empty string */\n+                if i == 0 {\n+                    stms.push(mk_local(cx, fmt_sp, true, ident,\n+                                       mk_uniq_str(cx, fmt_sp, ~\"\")));\n+                }\n+                stms.push(mk_stmt(cx, fmt_sp,\n+                                  make_new_conv(cx, fmt_sp, conv,\n+                                                args[n], buf())));\n             }\n         }\n-    };\n+    }\n+\n     let expected_nargs = n + 1u; // n conversions + the fmt string\n     if expected_nargs < nargs {\n         cx.span_fatal\n             (sp, fmt!(\"too many arguments to fmt!. found %u, expected %u\",\n                            nargs, expected_nargs));\n     }\n \n-    /* Concatenate all of the strings together with str::push_str. This\n-       involves storing the first piece into a local variable, and then\n-       pushing each other piece onto the local. The local is contained in its\n-       own block to not conflict with other names as much as possible */\n-    let ident = cx.parse_sess().interner.intern(@~\"__fmtbuf\");\n-    let buf = || mk_path(cx, fmt_sp, ~[ident]);\n-    let str_ident = cx.parse_sess().interner.intern(@~\"str\");\n-    let push_ident = cx.parse_sess().interner.intern(@~\"push_str\");\n-\n-    let mut first = true;\n-    let stms = do vec::map_consume(pieces) |pc| {\n-        if first {\n-            first = false;\n-            mk_local(cx, fmt_sp, true, ident, pc)\n-        } else {\n-            let call = mk_call_global(cx,\n-                                      fmt_sp,\n-                                      ~[str_ident, push_ident],\n-                                      ~[mk_mut_addr_of(cx, fmt_sp, buf()),\n-                                        pc]);\n-            mk_stmt(cx, fmt_sp, call)\n-        }\n-    };\n-\n     return mk_block(cx, fmt_sp, ~[], stms, Some(buf()));\n }\n //"}]}