{"sha": "68594142b112305d3a19e425724405802efd7806", "node_id": "C_kwDOAAsO6NoAKDY4NTk0MTQyYjExMjMwNWQzYTE5ZTQyNTcyNDQwNTgwMmVmZDc4MDY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-08T16:30:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-08T16:30:22Z"}, "message": "Rollup merge of #111004 - clubby789:migrate-mir-transform, r=oli-obk\n\nMigrate `mir_transform` to translatable diagnostics\n\ncc #100717", "tree": {"sha": "c2f0a0a6481753a24932a136caf1d7eddb40c845", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2f0a0a6481753a24932a136caf1d7eddb40c845"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68594142b112305d3a19e425724405802efd7806", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkWSOeCRBK7hj4Ov3rIwAA6U4IAHSmI/ZXsOgefE5MvXfzMI0/\n/U02wOrpJ//f93VV6vgdiYP+kCEPFkri4jXvWGSRiNn2yVFhB9dbqE8UY/38tM8U\nCYdU9pobadRwgi3ejQPVSBrczl4wOGKjO2/LcIBEQ0Wr6XKVg3ilex/hk/BDOMbJ\nFa2LG5TygF3cIkU1o2jbMX2goI96NqWDYJcEdjI5nirOzEmpYR957cQnsVSNNNrN\nGe6lIa4AF+h9+DI04t5swuIQhO7Spgz4vaqi9utk04afDHFOOBPSSjT0fY+vuSCt\n7iGrMIXnPyPH3QEY9xU1Oby1pK2qlIzH/+lDMbdbklYMwVWK9jrRh7vnuBs2dd4=\n=jQBD\n-----END PGP SIGNATURE-----\n", "payload": "tree c2f0a0a6481753a24932a136caf1d7eddb40c845\nparent 29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15\nparent d5bc581f5db6ba5198ccec45d938422778f56bff\nauthor Michael Goulet <michael@errs.io> 1683563422 -0700\ncommitter GitHub <noreply@github.com> 1683563422 -0700\n\nRollup merge of #111004 - clubby789:migrate-mir-transform, r=oli-obk\n\nMigrate `mir_transform` to translatable diagnostics\n\ncc #100717\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68594142b112305d3a19e425724405802efd7806", "html_url": "https://github.com/rust-lang/rust/commit/68594142b112305d3a19e425724405802efd7806", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68594142b112305d3a19e425724405802efd7806/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "html_url": "https://github.com/rust-lang/rust/commit/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15"}, {"sha": "d5bc581f5db6ba5198ccec45d938422778f56bff", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5bc581f5db6ba5198ccec45d938422778f56bff", "html_url": "https://github.com/rust-lang/rust/commit/d5bc581f5db6ba5198ccec45d938422778f56bff"}], "stats": {"total": 670, "additions": 470, "deletions": 200}, "files": [{"sha": "cd665f6e7d95f96cf974f86c3b889e7085405502", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -3353,6 +3353,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_mir_build\",\n  \"rustc_mir_dataflow\",\n+ \"rustc_mir_transform\",\n  \"rustc_monomorphize\",\n  \"rustc_parse\",\n  \"rustc_passes\",\n@@ -3861,8 +3862,10 @@ dependencies = [\n  \"rustc_const_eval\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_fluent_macro\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_mir_dataflow\",\n  \"rustc_serialize\","}, {"sha": "d7d97fcc3e7b7154382bcc6513e245e2576a05dd", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -51,6 +51,7 @@ rustc_interface = { path = \"../rustc_interface\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n+rustc_mir_transform = { path = \"../rustc_mir_transform\" }\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\"\n@@ -64,5 +65,8 @@ features = [\n [features]\n llvm = ['rustc_interface/llvm']\n max_level_info = ['rustc_log/max_level_info']\n-rustc_use_parallel_compiler = ['rustc_data_structures/rustc_use_parallel_compiler', 'rustc_interface/rustc_use_parallel_compiler',\n-    'rustc_middle/rustc_use_parallel_compiler']\n+rustc_use_parallel_compiler = [\n+    'rustc_data_structures/rustc_use_parallel_compiler',\n+    'rustc_interface/rustc_use_parallel_compiler',\n+    'rustc_middle/rustc_use_parallel_compiler'\n+]"}, {"sha": "9b16f246193f783a1f993b96f90528b0d9eb3b55", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -99,6 +99,7 @@ pub static DEFAULT_LOCALE_RESOURCES: &[&str] = &[\n     rustc_middle::DEFAULT_LOCALE_RESOURCE,\n     rustc_mir_build::DEFAULT_LOCALE_RESOURCE,\n     rustc_mir_dataflow::DEFAULT_LOCALE_RESOURCE,\n+    rustc_mir_transform::DEFAULT_LOCALE_RESOURCE,\n     rustc_monomorphize::DEFAULT_LOCALE_RESOURCE,\n     rustc_parse::DEFAULT_LOCALE_RESOURCE,\n     rustc_passes::DEFAULT_LOCALE_RESOURCE,"}, {"sha": "db97d96fccd181eeb8cd156f7f6fb3ad3441532d", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -571,6 +571,14 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         Some((diagnostic, handler))\n     }\n \n+    /// Retrieves the [`Handler`] if available\n+    pub fn handler(&self) -> Option<&Handler> {\n+        match self.inner.state {\n+            DiagnosticBuilderState::Emittable(handler) => Some(handler),\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => None,\n+        }\n+    }\n+\n     /// Buffers the diagnostic for later emission,\n     /// unless handler has disabled such buffering.\n     pub fn buffer(self, buffered_diagnostics: &mut Vec<Diagnostic>) {"}, {"sha": "eca5f98a2c01cd22cfa1362a751fe36db913e2d5", "filename": "compiler/rustc_mir_transform/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2FCargo.toml?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -24,6 +24,8 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_span = { path = \"../rustc_span\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n \n [dev-dependencies]\n coverage_test_macros = { path = \"src/coverage/test_macros\" }"}, {"sha": "8c85cb5f76d8627076b9f7f7dc5d50e2678dfb03", "filename": "compiler/rustc_mir_transform/messages.ftl", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fmessages.ftl?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -0,0 +1,66 @@\n+mir_transform_const_modify = attempting to modify a `const` item\n+    .note = each usage of a `const` item creates a new temporary; the original `const` item will not be modified\n+\n+mir_transform_const_mut_borrow = taking a mutable reference to a `const` item\n+    .note = each usage of a `const` item creates a new temporary\n+    .note2 = the mutable reference will refer to this temporary, not the original `const` item\n+    .note3 = mutable reference created due to call to this method\n+\n+mir_transform_const_defined_here = `const` item defined here\n+\n+mir_transform_unaligned_packed_ref = reference to packed field is unaligned\n+    .note = packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\n+    .note_ub = creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+    .help = copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+mir_transform_unused_unsafe = unnecessary `unsafe` block\n+    .label = because it's nested under this `unsafe` block\n+\n+mir_transform_requires_unsafe = {$details} is unsafe and requires unsafe {$op_in_unsafe_fn_allowed ->\n+    [true] function or block\n+    *[false] block\n+    }\n+    .not_inherited = items do not inherit unsafety from separate enclosing items\n+\n+mir_transform_call_to_unsafe_label = call to unsafe function\n+mir_transform_call_to_unsafe_note = consult the function's documentation for information on how to avoid undefined behavior\n+mir_transform_use_of_asm_label = use of inline assembly\n+mir_transform_use_of_asm_note = inline assembly is entirely unchecked and can cause undefined behavior\n+mir_transform_initializing_valid_range_label = initializing type with `rustc_layout_scalar_valid_range` attr\n+mir_transform_initializing_valid_range_note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+mir_transform_const_ptr2int_label = cast of pointer to int\n+mir_transform_const_ptr2int_note = casting pointers to integers in constants\n+mir_transform_use_of_static_mut_label = use of mutable static\n+mir_transform_use_of_static_mut_note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+mir_transform_use_of_extern_static_label = use of extern static\n+mir_transform_use_of_extern_static_note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+mir_transform_deref_ptr_label = dereference of raw pointer\n+mir_transform_deref_ptr_note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+mir_transform_union_access_label = access to union field\n+mir_transform_union_access_note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+mir_transform_mutation_layout_constrained_label = mutation of layout constrained field\n+mir_transform_mutation_layout_constrained_note = mutating layout constrained fields cannot statically be checked for valid values\n+mir_transform_mutation_layout_constrained_borrow_label = borrow of layout constrained field with interior mutability\n+mir_transform_mutation_layout_constrained_borrow_note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+mir_transform_target_feature_call_label = call to function with `#[target_feature]`\n+mir_transform_target_feature_call_note = can only be called if the required target features are available\n+\n+mir_transform_unsafe_op_in_unsafe_fn = {$details} is unsafe and requires unsafe block (error E0133)\n+\n+mir_transform_arithmetic_overflow = this arithmetic operation will overflow\n+mir_transform_operation_will_panic = this operation will panic at runtime\n+\n+mir_transform_ffi_unwind_call = call to {$foreign ->\n+    [true] foreign function\n+    *[false] function pointer\n+    } with FFI-unwind ABI\n+\n+mir_transform_fn_item_ref = taking a reference to a function item does not give a function pointer\n+    .suggestion = cast `{$ident}` to obtain a function pointer\n+\n+mir_transform_must_not_suspend = {$pre}`{$def_path}`{$post} held across a suspend point, but should not be\n+    .label = the value is held across this suspend point\n+    .note = {$reason}\n+    .help = consider using a block (`{\"{ ... }\"}`) to shrink the value's scope, ending before the suspend point\n+\n+mir_transform_simd_shuffle_last_const = last argument of `simd_shuffle` is required to be a `const` item"}, {"sha": "b79150737d6129fc5cd9936b82b69333b177d6b1", "filename": "compiler/rustc_mir_transform/src/check_const_item_mutation.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -1,11 +1,12 @@\n-use rustc_errors::{DiagnosticBuilder, DiagnosticMessage};\n+use rustc_hir::HirId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::CONST_ITEM_MUTATION;\n use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n \n-use crate::MirLint;\n+use crate::{errors, MirLint};\n \n pub struct CheckConstItemMutation;\n \n@@ -58,16 +59,14 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n         }\n     }\n \n-    fn lint_const_item_usage(\n+    /// If we should lint on this usage, return the [`HirId`], source [`Span`]\n+    /// and [`Span`] of the const item to use in the lint.\n+    fn should_lint_const_item_usage(\n         &self,\n         place: &Place<'tcx>,\n         const_item: DefId,\n         location: Location,\n-        msg: impl Into<DiagnosticMessage>,\n-        decorate: impl for<'a, 'b> FnOnce(\n-            &'a mut DiagnosticBuilder<'b, ()>,\n-        ) -> &'a mut DiagnosticBuilder<'b, ()>,\n-    ) {\n+    ) -> Option<(HirId, Span, Span)> {\n         // Don't lint on borrowing/assigning when a dereference is involved.\n         // If we 'leave' the temporary via a dereference, we must\n         // be modifying something else\n@@ -83,16 +82,9 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n                 .assert_crate_local()\n                 .lint_root;\n \n-            self.tcx.struct_span_lint_hir(\n-                CONST_ITEM_MUTATION,\n-                lint_root,\n-                source_info.span,\n-                msg,\n-                |lint| {\n-                    decorate(lint)\n-                        .span_note(self.tcx.def_span(const_item), \"`const` item defined here\")\n-                },\n-            );\n+            Some((lint_root, source_info.span, self.tcx.def_span(const_item)))\n+        } else {\n+            None\n         }\n     }\n }\n@@ -104,10 +96,14 @@ impl<'tcx> Visitor<'tcx> for ConstMutationChecker<'_, 'tcx> {\n             // Assigning directly to a constant (e.g. `FOO = true;`) is a hard error,\n             // so emitting a lint would be redundant.\n             if !lhs.projection.is_empty() {\n-                if let Some(def_id) = self.is_const_item_without_destructor(lhs.local) {\n-                    self.lint_const_item_usage(&lhs, def_id, loc, \"attempting to modify a `const` item\",|lint| {\n-                        lint.note(\"each usage of a `const` item creates a new temporary; the original `const` item will not be modified\")\n-                    })\n+                if let Some(def_id) = self.is_const_item_without_destructor(lhs.local)\n+                    && let Some((lint_root, span, item)) = self.should_lint_const_item_usage(&lhs, def_id, loc) {\n+                        self.tcx.emit_spanned_lint(\n+                            CONST_ITEM_MUTATION,\n+                            lint_root,\n+                            span,\n+                            errors::ConstMutate::Modify { konst: item }\n+                        );\n                 }\n             }\n             // We are looking for MIR of the form:\n@@ -143,17 +139,22 @@ impl<'tcx> Visitor<'tcx> for ConstMutationChecker<'_, 'tcx> {\n                 });\n                 let lint_loc =\n                     if method_did.is_some() { self.body.terminator_loc(loc.block) } else { loc };\n-                self.lint_const_item_usage(place, def_id, lint_loc, \"taking a mutable reference to a `const` item\", |lint| {\n-                    lint\n-                        .note(\"each usage of a `const` item creates a new temporary\")\n-                        .note(\"the mutable reference will refer to this temporary, not the original `const` item\");\n-\n-                    if let Some((method_did, _substs)) = method_did {\n-                        lint.span_note(self.tcx.def_span(method_did), \"mutable reference created due to call to this method\");\n-                    }\n \n-                    lint\n-                });\n+                let method_call = if let Some((method_did, _)) = method_did {\n+                    Some(self.tcx.def_span(method_did))\n+                } else {\n+                    None\n+                };\n+                if let Some((lint_root, span, item)) =\n+                    self.should_lint_const_item_usage(place, def_id, lint_loc)\n+                {\n+                    self.tcx.emit_spanned_lint(\n+                        CONST_ITEM_MUTATION,\n+                        lint_root,\n+                        span,\n+                        errors::ConstMutate::MutBorrow { method_call, konst: item },\n+                    );\n+                }\n             }\n         }\n         self.super_rvalue(rvalue, loc);"}, {"sha": "2e6cf603d5968938b463e0b85291388dd70ba6be", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -1,10 +1,9 @@\n-use rustc_errors::struct_span_err;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n \n-use crate::util;\n use crate::MirLint;\n+use crate::{errors, util};\n \n pub struct CheckPackedRef;\n \n@@ -49,25 +48,7 @@ impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n                     // shouldn't do.\n                     span_bug!(self.source_info.span, \"builtin derive created an unaligned reference\");\n                 } else {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        self.source_info.span,\n-                        E0793,\n-                        \"reference to packed field is unaligned\"\n-                    )\n-                    .note(\n-                        \"packed structs are only aligned by one byte, and many modern architectures \\\n-                        penalize unaligned field accesses\"\n-                    )\n-                    .note(\n-                        \"creating a misaligned reference is undefined behavior (even if that \\\n-                        reference is never dereferenced)\",\n-                    ).help(\n-                        \"copy the field contents to a local variable, or replace the \\\n-                        reference with a raw pointer and use `read_unaligned`/`write_unaligned` \\\n-                        (loads and stores via `*p` must be properly aligned even when using raw pointers)\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(errors::UnalignedPackedRef { span: self.source_info.span });\n                 }\n             }\n         }"}, {"sha": "bdb4f20da10590c31a132c42c2ca8fec238c784c", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -1,5 +1,4 @@\n use rustc_data_structures::unord::{UnordItems, UnordSet};\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -15,6 +14,8 @@ use rustc_session::lint::Level;\n \n use std::ops::Bound;\n \n+use crate::errors;\n+\n pub struct UnsafetyChecker<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     body_did: LocalDefId,\n@@ -509,21 +510,12 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def: LocalDefId) -> &UnsafetyCheckResu\n \n fn report_unused_unsafe(tcx: TyCtxt<'_>, kind: UnusedUnsafe, id: HirId) {\n     let span = tcx.sess.source_map().guess_head_span(tcx.hir().span(id));\n-    let msg = \"unnecessary `unsafe` block\";\n-    tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg, |lint| {\n-        lint.span_label(span, msg);\n-        match kind {\n-            UnusedUnsafe::Unused => {}\n-            UnusedUnsafe::InUnsafeBlock(id) => {\n-                lint.span_label(\n-                    tcx.sess.source_map().guess_head_span(tcx.hir().span(id)),\n-                    \"because it's nested under this `unsafe` block\",\n-                );\n-            }\n-        }\n-\n-        lint\n-    });\n+    let nested_parent = if let UnusedUnsafe::InUnsafeBlock(id) = kind {\n+        Some(tcx.sess.source_map().guess_head_span(tcx.hir().span(id)))\n+    } else {\n+        None\n+    };\n+    tcx.emit_spanned_lint(UNUSED_UNSAFE, id, span, errors::UnusedUnsafe { span, nested_parent });\n }\n \n pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n@@ -537,26 +529,11 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let UnsafetyCheckResult { violations, unused_unsafes, .. } = tcx.unsafety_check_result(def_id);\n \n     for &UnsafetyViolation { source_info, lint_root, kind, details } in violations.iter() {\n-        let (description, note) = details.description_and_note();\n+        let details = errors::RequiresUnsafeDetail { violation: details, span: source_info.span };\n \n         match kind {\n             UnsafetyViolationKind::General => {\n-                // once\n-                let unsafe_fn_msg = if unsafe_op_in_unsafe_fn_allowed(tcx, lint_root) {\n-                    \" function or\"\n-                } else {\n-                    \"\"\n-                };\n-\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    source_info.span,\n-                    E0133,\n-                    \"{} is unsafe and requires unsafe{} block\",\n-                    description,\n-                    unsafe_fn_msg,\n-                );\n-                err.span_label(source_info.span, description).note(note);\n+                let op_in_unsafe_fn_allowed = unsafe_op_in_unsafe_fn_allowed(tcx, lint_root);\n                 let note_non_inherited = tcx.hir().parent_iter(lint_root).find(|(id, node)| {\n                     if let Node::Expr(block) = node\n                         && let ExprKind::Block(block, _) = block.kind\n@@ -572,22 +549,23 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                         false\n                     }\n                 });\n-                if let Some((id, _)) = note_non_inherited {\n-                    let span = tcx.hir().span(id);\n-                    err.span_label(\n-                        tcx.sess.source_map().guess_head_span(span),\n-                        \"items do not inherit unsafety from separate enclosing items\",\n-                    );\n-                }\n-\n-                err.emit();\n+                let enclosing = if let Some((id, _)) = note_non_inherited {\n+                    Some(tcx.sess.source_map().guess_head_span(tcx.hir().span(id)))\n+                } else {\n+                    None\n+                };\n+                tcx.sess.emit_err(errors::RequiresUnsafe {\n+                    span: source_info.span,\n+                    enclosing,\n+                    details,\n+                    op_in_unsafe_fn_allowed,\n+                });\n             }\n-            UnsafetyViolationKind::UnsafeFn => tcx.struct_span_lint_hir(\n+            UnsafetyViolationKind::UnsafeFn => tcx.emit_spanned_lint(\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 lint_root,\n                 source_info.span,\n-                format!(\"{} is unsafe and requires unsafe block (error E0133)\", description,),\n-                |lint| lint.span_label(source_info.span, description).note(note),\n+                errors::UnsafeOpInUnsafeFn { details },\n             ),\n         }\n     }"}, {"sha": "adb09c509d287e8f8a646beb0df113f21c56eb1d", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -1,6 +1,8 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n+use std::fmt::Debug;\n+\n use either::Left;\n \n use rustc_const_eval::interpret::Immediate;\n@@ -17,14 +19,14 @@ use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{\n     self, ConstInt, Instance, ParamEnv, ScalarInt, Ty, TyCtxt, TypeVisitableExt,\n };\n-use rustc_session::lint;\n use rustc_span::Span;\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n use rustc_trait_selection::traits;\n \n use crate::const_prop::CanConstProp;\n use crate::const_prop::ConstPropMachine;\n use crate::const_prop::ConstPropMode;\n+use crate::errors::AssertLint;\n use crate::MirLint;\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -311,18 +313,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn report_assert_as_lint(\n-        &self,\n-        lint: &'static lint::Lint,\n-        location: Location,\n-        message: &'static str,\n-        panic: AssertKind<impl std::fmt::Debug>,\n-    ) {\n-        let source_info = self.body().source_info(location);\n+    fn report_assert_as_lint(&self, source_info: &SourceInfo, lint: AssertLint<impl Debug>) {\n         if let Some(lint_root) = self.lint_root(*source_info) {\n-            self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, message, |lint| {\n-                lint.span_label(source_info.span, format!(\"{:?}\", panic))\n-            });\n+            self.tcx.emit_spanned_lint(lint.lint(), lint_root, source_info.span, lint);\n         }\n     }\n \n@@ -335,11 +328,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n             // appropriate to use.\n             assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n+            let source_info = self.body().source_info(location);\n             self.report_assert_as_lint(\n-                lint::builtin::ARITHMETIC_OVERFLOW,\n-                location,\n-                \"this arithmetic operation will overflow\",\n-                AssertKind::OverflowNeg(val.to_const_int()),\n+                source_info,\n+                AssertLint::ArithmeticOverflow(\n+                    source_info.span,\n+                    AssertKind::OverflowNeg(val.to_const_int()),\n+                ),\n             );\n             return None;\n         }\n@@ -370,23 +365,23 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let r_bits = r.to_scalar().to_bits(right_size).ok();\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n                 debug!(\"check_binary_op: reporting assert for {:?}\", location);\n+                let source_info = self.body().source_info(location);\n+                let panic = AssertKind::Overflow(\n+                    op,\n+                    match l {\n+                        Some(l) => l.to_const_int(),\n+                        // Invent a dummy value, the diagnostic ignores it anyway\n+                        None => ConstInt::new(\n+                            ScalarInt::try_from_uint(1_u8, left_size).unwrap(),\n+                            left_ty.is_signed(),\n+                            left_ty.is_ptr_sized_integral(),\n+                        ),\n+                    },\n+                    r.to_const_int(),\n+                );\n                 self.report_assert_as_lint(\n-                    lint::builtin::ARITHMETIC_OVERFLOW,\n-                    location,\n-                    \"this arithmetic operation will overflow\",\n-                    AssertKind::Overflow(\n-                        op,\n-                        match l {\n-                            Some(l) => l.to_const_int(),\n-                            // Invent a dummy value, the diagnostic ignores it anyway\n-                            None => ConstInt::new(\n-                                ScalarInt::try_from_uint(1_u8, left_size).unwrap(),\n-                                left_ty.is_signed(),\n-                                left_ty.is_ptr_sized_integral(),\n-                            ),\n-                        },\n-                        r.to_const_int(),\n-                    ),\n+                    source_info,\n+                    AssertLint::ArithmeticOverflow(source_info.span, panic),\n                 );\n                 return None;\n             }\n@@ -398,11 +393,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, &l, &r)?;\n                 Ok(overflow)\n             })? {\n+                let source_info = self.body().source_info(location);\n                 self.report_assert_as_lint(\n-                    lint::builtin::ARITHMETIC_OVERFLOW,\n-                    location,\n-                    \"this arithmetic operation will overflow\",\n-                    AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n+                    source_info,\n+                    AssertLint::ArithmeticOverflow(\n+                        source_info.span,\n+                        AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n+                    ),\n                 );\n                 return None;\n             }\n@@ -543,11 +540,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 // Need proper const propagator for these.\n                 _ => return None,\n             };\n+            let source_info = self.body().source_info(location);\n             self.report_assert_as_lint(\n-                lint::builtin::UNCONDITIONAL_PANIC,\n-                location,\n-                \"this operation will panic at runtime\",\n-                msg,\n+                source_info,\n+                AssertLint::UnconditionalPanic(source_info.span, msg),\n             );\n         }\n "}, {"sha": "602e40d513104c0517da0a89a135dcadf4307de2", "filename": "compiler/rustc_mir_transform/src/errors.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -0,0 +1,245 @@\n+use rustc_errors::{\n+    DecorateLint, DiagnosticBuilder, DiagnosticMessage, EmissionGuarantee, Handler, IntoDiagnostic,\n+};\n+use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_middle::mir::{AssertKind, UnsafetyViolationDetails};\n+use rustc_session::lint::{self, Lint};\n+use rustc_span::Span;\n+\n+#[derive(LintDiagnostic)]\n+pub(crate) enum ConstMutate {\n+    #[diag(mir_transform_const_modify)]\n+    #[note]\n+    Modify {\n+        #[note(mir_transform_const_defined_here)]\n+        konst: Span,\n+    },\n+    #[diag(mir_transform_const_mut_borrow)]\n+    #[note]\n+    #[note(mir_transform_note2)]\n+    MutBorrow {\n+        #[note(mir_transform_note3)]\n+        method_call: Option<Span>,\n+        #[note(mir_transform_const_defined_here)]\n+        konst: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_transform_unaligned_packed_ref, code = \"E0793\")]\n+#[note]\n+#[note(mir_transform_note_ub)]\n+#[help]\n+pub(crate) struct UnalignedPackedRef {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_unused_unsafe)]\n+pub(crate) struct UnusedUnsafe {\n+    #[label(mir_transform_unused_unsafe)]\n+    pub span: Span,\n+    #[label]\n+    pub nested_parent: Option<Span>,\n+}\n+\n+pub(crate) struct RequiresUnsafe {\n+    pub span: Span,\n+    pub details: RequiresUnsafeDetail,\n+    pub enclosing: Option<Span>,\n+    pub op_in_unsafe_fn_allowed: bool,\n+}\n+\n+// The primary message for this diagnostic should be '{$label} is unsafe and...',\n+// so we need to eagerly translate the label here, which isn't supported by the derive API\n+// We could also exhaustively list out the primary messages for all unsafe violations,\n+// but this would result in a lot of duplication.\n+impl<'sess, G: EmissionGuarantee> IntoDiagnostic<'sess, G> for RequiresUnsafe {\n+    #[track_caller]\n+    fn into_diagnostic(self, handler: &'sess Handler) -> DiagnosticBuilder<'sess, G> {\n+        let mut diag =\n+            handler.struct_diagnostic(crate::fluent_generated::mir_transform_requires_unsafe);\n+        diag.code(rustc_errors::DiagnosticId::Error(\"E0133\".to_string()));\n+        diag.set_span(self.span);\n+        diag.span_label(self.span, self.details.label());\n+        diag.note(self.details.note());\n+        let desc = handler.eagerly_translate_to_string(self.details.label(), [].into_iter());\n+        diag.set_arg(\"details\", desc);\n+        diag.set_arg(\"op_in_unsafe_fn_allowed\", self.op_in_unsafe_fn_allowed);\n+        if let Some(sp) = self.enclosing {\n+            diag.span_label(sp, crate::fluent_generated::mir_transform_not_inherited);\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub(crate) struct RequiresUnsafeDetail {\n+    pub span: Span,\n+    pub violation: UnsafetyViolationDetails,\n+}\n+\n+impl RequiresUnsafeDetail {\n+    fn note(self) -> DiagnosticMessage {\n+        use UnsafetyViolationDetails::*;\n+        match self.violation {\n+            CallToUnsafeFunction => crate::fluent_generated::mir_transform_call_to_unsafe_note,\n+            UseOfInlineAssembly => crate::fluent_generated::mir_transform_use_of_asm_note,\n+            InitializingTypeWith => {\n+                crate::fluent_generated::mir_transform_initializing_valid_range_note\n+            }\n+            CastOfPointerToInt => crate::fluent_generated::mir_transform_const_ptr2int_note,\n+            UseOfMutableStatic => crate::fluent_generated::mir_transform_use_of_static_mut_note,\n+            UseOfExternStatic => crate::fluent_generated::mir_transform_use_of_extern_static_note,\n+            DerefOfRawPointer => crate::fluent_generated::mir_transform_deref_ptr_note,\n+            AccessToUnionField => crate::fluent_generated::mir_transform_union_access_note,\n+            MutationOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_note\n+            }\n+            BorrowOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_borrow_note\n+            }\n+            CallToFunctionWith => crate::fluent_generated::mir_transform_target_feature_call_note,\n+        }\n+    }\n+\n+    fn label(self) -> DiagnosticMessage {\n+        use UnsafetyViolationDetails::*;\n+        match self.violation {\n+            CallToUnsafeFunction => crate::fluent_generated::mir_transform_call_to_unsafe_label,\n+            UseOfInlineAssembly => crate::fluent_generated::mir_transform_use_of_asm_label,\n+            InitializingTypeWith => {\n+                crate::fluent_generated::mir_transform_initializing_valid_range_label\n+            }\n+            CastOfPointerToInt => crate::fluent_generated::mir_transform_const_ptr2int_label,\n+            UseOfMutableStatic => crate::fluent_generated::mir_transform_use_of_static_mut_label,\n+            UseOfExternStatic => crate::fluent_generated::mir_transform_use_of_extern_static_label,\n+            DerefOfRawPointer => crate::fluent_generated::mir_transform_deref_ptr_label,\n+            AccessToUnionField => crate::fluent_generated::mir_transform_union_access_label,\n+            MutationOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_label\n+            }\n+            BorrowOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_borrow_label\n+            }\n+            CallToFunctionWith => crate::fluent_generated::mir_transform_target_feature_call_label,\n+        }\n+    }\n+}\n+\n+pub(crate) struct UnsafeOpInUnsafeFn {\n+    pub details: RequiresUnsafeDetail,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for UnsafeOpInUnsafeFn {\n+    #[track_caller]\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut DiagnosticBuilder<'a, ()> {\n+        let desc = diag\n+            .handler()\n+            .expect(\"lint should not yet be emitted\")\n+            .eagerly_translate_to_string(self.details.label(), [].into_iter());\n+        diag.set_arg(\"details\", desc);\n+        diag.span_label(self.details.span, self.details.label());\n+        diag.note(self.details.note());\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        crate::fluent_generated::mir_transform_unsafe_op_in_unsafe_fn\n+    }\n+}\n+\n+pub(crate) enum AssertLint<P> {\n+    ArithmeticOverflow(Span, AssertKind<P>),\n+    UnconditionalPanic(Span, AssertKind<P>),\n+}\n+\n+impl<'a, P: std::fmt::Debug> DecorateLint<'a, ()> for AssertLint<P> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut DiagnosticBuilder<'a, ()> {\n+        diag.span_label(self.span(), format!(\"{:?}\", self.panic()));\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        match self {\n+            AssertLint::ArithmeticOverflow(..) => {\n+                crate::fluent_generated::mir_transform_arithmetic_overflow\n+            }\n+            AssertLint::UnconditionalPanic(..) => {\n+                crate::fluent_generated::mir_transform_operation_will_panic\n+            }\n+        }\n+    }\n+}\n+\n+impl<P> AssertLint<P> {\n+    pub fn lint(&self) -> &'static Lint {\n+        match self {\n+            AssertLint::ArithmeticOverflow(..) => lint::builtin::ARITHMETIC_OVERFLOW,\n+            AssertLint::UnconditionalPanic(..) => lint::builtin::UNCONDITIONAL_PANIC,\n+        }\n+    }\n+    pub fn span(&self) -> Span {\n+        match self {\n+            AssertLint::ArithmeticOverflow(sp, _) | AssertLint::UnconditionalPanic(sp, _) => *sp,\n+        }\n+    }\n+    pub fn panic(&self) -> &AssertKind<P> {\n+        match self {\n+            AssertLint::ArithmeticOverflow(_, p) | AssertLint::UnconditionalPanic(_, p) => p,\n+        }\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_ffi_unwind_call)]\n+pub(crate) struct FfiUnwindCall {\n+    #[label(mir_transform_ffi_unwind_call)]\n+    pub span: Span,\n+    pub foreign: bool,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_fn_item_ref)]\n+pub(crate) struct FnItemRef {\n+    #[suggestion(code = \"{sugg}\", applicability = \"unspecified\")]\n+    pub span: Span,\n+    pub sugg: String,\n+    pub ident: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_must_not_suspend)]\n+pub(crate) struct MustNotSupend<'a> {\n+    #[label]\n+    pub yield_sp: Span,\n+    #[subdiagnostic]\n+    pub reason: Option<MustNotSuspendReason>,\n+    #[help]\n+    pub src_sp: Span,\n+    pub pre: &'a str,\n+    pub def_path: String,\n+    pub post: &'a str,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(mir_transform_note)]\n+pub(crate) struct MustNotSuspendReason {\n+    #[primary_span]\n+    pub span: Span,\n+    pub reason: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_transform_simd_shuffle_last_const)]\n+pub(crate) struct SimdShuffleLastConst {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "ac1de989a7204406d2a4f47a940c57e41042dac3", "filename": "compiler/rustc_mir_transform/src/ffi_unwind_calls.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -8,6 +8,8 @@ use rustc_session::lint::builtin::FFI_UNWIND_CALLS;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::PanicStrategy;\n \n+use crate::errors;\n+\n fn abi_can_unwind(abi: Abi) -> bool {\n     use Abi::*;\n     match abi {\n@@ -107,13 +109,13 @@ fn has_ffi_unwind_calls(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> bool {\n                 .lint_root;\n             let span = terminator.source_info.span;\n \n-            let msg = match fn_def_id {\n-                Some(_) => \"call to foreign function with FFI-unwind ABI\",\n-                None => \"call to function pointer with FFI-unwind ABI\",\n-            };\n-            tcx.struct_span_lint_hir(FFI_UNWIND_CALLS, lint_root, span, msg, |lint| {\n-                lint.span_label(span, msg)\n-            });\n+            let foreign = fn_def_id.is_some();\n+            tcx.emit_spanned_lint(\n+                FFI_UNWIND_CALLS,\n+                lint_root,\n+                span,\n+                errors::FfiUnwindCall { span, foreign },\n+            );\n \n             tainted = true;\n         }"}, {"sha": "5989dbebf2db9badf1fd699a1135044768281de0", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -1,5 +1,4 @@\n use itertools::Itertools;\n-use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n@@ -8,7 +7,7 @@ use rustc_session::lint::builtin::FUNCTION_ITEM_REFERENCES;\n use rustc_span::{symbol::sym, Span};\n use rustc_target::spec::abi::Abi;\n \n-use crate::MirLint;\n+use crate::{errors, MirLint};\n \n pub struct FunctionItemReferences;\n \n@@ -174,27 +173,21 @@ impl<'tcx> FunctionItemRefChecker<'_, 'tcx> {\n         let num_args = fn_sig.inputs().map_bound(|inputs| inputs.len()).skip_binder();\n         let variadic = if fn_sig.c_variadic() { \", ...\" } else { \"\" };\n         let ret = if fn_sig.output().skip_binder().is_unit() { \"\" } else { \" -> _\" };\n-        self.tcx.struct_span_lint_hir(\n+        let sugg = format!(\n+            \"{} as {}{}fn({}{}){}\",\n+            if params.is_empty() { ident.clone() } else { format!(\"{}::<{}>\", ident, params) },\n+            unsafety,\n+            abi,\n+            vec![\"_\"; num_args].join(\", \"),\n+            variadic,\n+            ret,\n+        );\n+\n+        self.tcx.emit_spanned_lint(\n             FUNCTION_ITEM_REFERENCES,\n             lint_root,\n             span,\n-            \"taking a reference to a function item does not give a function pointer\",\n-            |lint| {\n-                lint.span_suggestion(\n-                    span,\n-                    format!(\"cast `{}` to obtain a function pointer\", ident),\n-                    format!(\n-                        \"{} as {}{}fn({}{}){}\",\n-                        if params.is_empty() { ident } else { format!(\"{}::<{}>\", ident, params) },\n-                        unsafety,\n-                        abi,\n-                        vec![\"_\"; num_args].join(\", \"),\n-                        variadic,\n-                        ret,\n-                    ),\n-                    Applicability::Unspecified,\n-                )\n-            },\n+            errors::FnItemRef { span, sugg, ident },\n         );\n     }\n }"}, {"sha": "c9144729145b6143bb51dbcd4505b1878764a07e", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -51,6 +51,7 @@\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n use crate::deref_separator::deref_finder;\n+use crate::errors;\n use crate::simplify;\n use crate::MirPass;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -1891,36 +1892,21 @@ fn check_must_not_suspend_def(\n     data: SuspendCheckData<'_>,\n ) -> bool {\n     if let Some(attr) = tcx.get_attr(def_id, sym::must_not_suspend) {\n-        let msg = rustc_errors::DelayDm(|| {\n-            format!(\n-                \"{}`{}`{} held across a suspend point, but should not be\",\n-                data.descr_pre,\n-                tcx.def_path_str(def_id),\n-                data.descr_post,\n-            )\n+        let reason = attr.value_str().map(|s| errors::MustNotSuspendReason {\n+            span: data.source_span,\n+            reason: s.as_str().to_string(),\n         });\n-        tcx.struct_span_lint_hir(\n+        tcx.emit_spanned_lint(\n             rustc_session::lint::builtin::MUST_NOT_SUSPEND,\n             hir_id,\n             data.source_span,\n-            msg,\n-            |lint| {\n-                // add span pointing to the offending yield/await\n-                lint.span_label(data.yield_span, \"the value is held across this suspend point\");\n-\n-                // Add optional reason note\n-                if let Some(note) = attr.value_str() {\n-                    // FIXME(guswynn): consider formatting this better\n-                    lint.span_note(data.source_span, note.as_str());\n-                }\n-\n-                // Add some quick suggestions on what to do\n-                // FIXME: can `drop` work as a suggestion here as well?\n-                lint.span_help(\n-                    data.source_span,\n-                    \"consider using a block (`{ ... }`) \\\n-                    to shrink the value's scope, ending before the suspend point\",\n-                )\n+            errors::MustNotSupend {\n+                yield_sp: data.yield_span,\n+                reason,\n+                src_sp: data.source_span,\n+                pre: data.descr_pre,\n+                def_path: tcx.def_path_str(def_id),\n+                post: data.descr_post,\n             },\n         );\n "}, {"sha": "5c4b1ead4e9b4519cfe45d228e63125e382a1cf6", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -1,4 +1,6 @@\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(let_chains)]\n@@ -69,6 +71,7 @@ pub mod dump_mir;\n mod early_otherwise_branch;\n mod elaborate_box_derefs;\n mod elaborate_drops;\n+mod errors;\n mod ffi_unwind_calls;\n mod function_item_references;\n mod generator;\n@@ -105,6 +108,11 @@ use rustc_const_eval::transform::promote_consts;\n use rustc_const_eval::transform::validate;\n use rustc_mir_dataflow::rustc_peek;\n \n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_fluent_macro::fluent_messages;\n+\n+fluent_messages! { \"../messages.ftl\" }\n+\n pub fn provide(providers: &mut Providers) {\n     check_unsafety::provide(providers);\n     coverage::query::provide(providers);"}, {"sha": "dae01e41e5f3d3f466cf7729fabd258d1f537f51", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68594142b112305d3a19e425724405802efd7806/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=68594142b112305d3a19e425724405802efd7806", "patch": "@@ -1,6 +1,6 @@\n //! Lowers intrinsic calls\n \n-use crate::MirPass;\n+use crate::{errors, MirPass};\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -310,11 +310,7 @@ fn resolve_rust_intrinsic<'tcx>(\n }\n \n fn validate_simd_shuffle<'tcx>(tcx: TyCtxt<'tcx>, args: &[Operand<'tcx>], span: Span) {\n-    match &args[2] {\n-        Operand::Constant(_) => {} // all good\n-        _ => {\n-            let msg = \"last argument of `simd_shuffle` is required to be a `const` item\";\n-            tcx.sess.span_err(span, msg);\n-        }\n+    if !matches!(args[2], Operand::Constant(_)) {\n+        tcx.sess.emit_err(errors::SimdShuffleLastConst { span });\n     }\n }"}]}