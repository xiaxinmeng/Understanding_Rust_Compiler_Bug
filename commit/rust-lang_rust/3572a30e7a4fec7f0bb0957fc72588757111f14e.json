{"sha": "3572a30e7a4fec7f0bb0957fc72588757111f14e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NzJhMzBlN2E0ZmVjN2YwYmIwOTU3ZmM3MjU4ODc1NzExMWYxNGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T07:47:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-23T16:45:20Z"}, "message": "sync: Move the Mutex type to using &self\n\nThis also uses the Unsafe type for any interior mutability in the type to avoid\ntransmutes.", "tree": {"sha": "2de3cb5de028ae335a839cf4da36bc47ce3c9a3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2de3cb5de028ae335a839cf4da36bc47ce3c9a3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3572a30e7a4fec7f0bb0957fc72588757111f14e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3572a30e7a4fec7f0bb0957fc72588757111f14e", "html_url": "https://github.com/rust-lang/rust/commit/3572a30e7a4fec7f0bb0957fc72588757111f14e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3572a30e7a4fec7f0bb0957fc72588757111f14e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6b3f1f231350798f019fdb09f6c4979fb23b8d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b3f1f231350798f019fdb09f6c4979fb23b8d4", "html_url": "https://github.com/rust-lang/rust/commit/d6b3f1f231350798f019fdb09f6c4979fb23b8d4"}], "stats": {"total": 143, "additions": 82, "deletions": 61}, "files": [{"sha": "b01c82eb7ac464f5c497e02f4c8ab5e30fb0243c", "filename": "src/libsync/mutex.rs", "status": "renamed", "additions": 82, "deletions": 61, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/3572a30e7a4fec7f0bb0957fc72588757111f14e/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3572a30e7a4fec7f0bb0957fc72588757111f14e/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=3572a30e7a4fec7f0bb0957fc72588757111f14e", "patch": "@@ -57,13 +57,16 @@\n // times in order to manage a few flags about who's blocking where and whether\n // it's locked or not.\n \n+use std::kinds::marker;\n+use std::mem;\n use std::rt::local::Local;\n use std::rt::task::{BlockedTask, Task};\n use std::rt::thread::Thread;\n use std::sync::atomics;\n+use std::ty::Unsafe;\n use std::unstable::mutex;\n \n-use q = sync::mpsc_intrusive;\n+use q = mpsc_intrusive;\n \n pub static LOCKED: uint = 1 << 0;\n pub static GREEN_BLOCKED: uint = 1 << 1;\n@@ -85,7 +88,7 @@ pub static NATIVE_BLOCKED: uint = 1 << 2;\n /// ```rust\n /// use sync::mutex::Mutex;\n ///\n-/// let mut m = Mutex::new();\n+/// let m = Mutex::new();\n /// let guard = m.lock();\n /// // do some work\n /// drop(guard); // unlock the lock\n@@ -126,14 +129,15 @@ enum Flavor {\n pub struct StaticMutex {\n     /// Current set of flags on this mutex\n     priv state: atomics::AtomicUint,\n+    /// an OS mutex used by native threads\n+    priv lock: mutex::StaticNativeMutex,\n+\n     /// Type of locking operation currently on this mutex\n-    priv flavor: Flavor,\n+    priv flavor: Unsafe<Flavor>,\n     /// uint-cast of the green thread waiting for this mutex\n-    priv green_blocker: uint,\n+    priv green_blocker: Unsafe<uint>,\n     /// uint-cast of the native thread waiting for this mutex\n-    priv native_blocker: uint,\n-    /// an OS mutex used by native threads\n-    priv lock: mutex::StaticNativeMutex,\n+    priv native_blocker: Unsafe<uint>,\n \n     /// A concurrent mpsc queue used by green threads, along with a count used\n     /// to figure out when to dequeue and enqueue.\n@@ -145,21 +149,24 @@ pub struct StaticMutex {\n /// dropped (falls out of scope), the lock will be unlocked.\n #[must_use]\n pub struct Guard<'a> {\n-    priv lock: &'a mut StaticMutex,\n+    priv lock: &'a StaticMutex,\n }\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n pub static MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: mutex::NATIVE_MUTEX_INIT,\n     state: atomics::INIT_ATOMIC_UINT,\n-    flavor: Unlocked,\n-    green_blocker: 0,\n-    native_blocker: 0,\n+    flavor: Unsafe { value: Unlocked, marker1: marker::InvariantType },\n+    green_blocker: Unsafe { value: 0, marker1: marker::InvariantType },\n+    native_blocker: Unsafe { value: 0, marker1: marker::InvariantType },\n     green_cnt: atomics::INIT_ATOMIC_UINT,\n     q: q::Queue {\n         head: atomics::INIT_ATOMIC_UINT,\n-        tail: 0 as *mut q::Node<uint>,\n+        tail: Unsafe {\n+            value: 0 as *mut q::Node<uint>,\n+            marker1: marker::InvariantType,\n+        },\n         stub: q::DummyNode {\n             next: atomics::INIT_ATOMIC_UINT,\n         }\n@@ -168,34 +175,34 @@ pub static MUTEX_INIT: StaticMutex = StaticMutex {\n \n impl StaticMutex {\n     /// Attempts to grab this lock, see `Mutex::try_lock`\n-    pub fn try_lock<'a>(&'a mut self) -> Option<Guard<'a>> {\n+    pub fn try_lock<'a>(&'a self) -> Option<Guard<'a>> {\n         // Attempt to steal the mutex from an unlocked state.\n         //\n         // FIXME: this can mess up the fairness of the mutex, seems bad\n         match self.state.compare_and_swap(0, LOCKED, atomics::SeqCst) {\n             0 => {\n-                assert!(self.flavor == Unlocked);\n-                self.flavor = TryLockAcquisition;\n+                // After acquiring the mutex, we can safely access the inner\n+                // fields.\n+                let prev = unsafe {\n+                    mem::replace(&mut *self.flavor.get(), TryLockAcquisition)\n+                };\n+                assert_eq!(prev, Unlocked);\n                 Some(Guard::new(self))\n             }\n             _ => None\n         }\n     }\n \n     /// Acquires this lock, see `Mutex::lock`\n-    pub fn lock<'a>(&'a mut self) -> Guard<'a> {\n+    pub fn lock<'a>(&'a self) -> Guard<'a> {\n         // First, attempt to steal the mutex from an unlocked state. The \"fast\n         // path\" needs to have as few atomic instructions as possible, and this\n         // one cmpxchg is already pretty expensive.\n         //\n         // FIXME: this can mess up the fairness of the mutex, seems bad\n-        match self.state.compare_and_swap(0, LOCKED, atomics::SeqCst) {\n-            0 => {\n-                assert!(self.flavor == Unlocked);\n-                self.flavor = TryLockAcquisition;\n-                return Guard::new(self)\n-            }\n-            _ => {}\n+        match self.try_lock() {\n+            Some(guard) => return guard,\n+            None => {}\n         }\n \n         // After we've failed the fast path, then we delegate to the differnet\n@@ -219,11 +226,14 @@ impl StaticMutex {\n         let mut old = match self.state.compare_and_swap(0, LOCKED,\n                                                         atomics::SeqCst) {\n             0 => {\n-                self.flavor = if can_block {\n+                let flavor = if can_block {\n                     NativeAcquisition\n                 } else {\n                     GreenAcquisition\n                 };\n+                // We've acquired the lock, so this unsafe access to flavor is\n+                // allowed.\n+                unsafe { *self.flavor.get() = flavor; }\n                 return Guard::new(self)\n             }\n             old => old,\n@@ -237,13 +247,15 @@ impl StaticMutex {\n         let t: ~Task = Local::take();\n         t.deschedule(1, |task| {\n             let task = unsafe { task.cast_to_uint() };\n-            if can_block {\n-                assert_eq!(self.native_blocker, 0);\n-                self.native_blocker = task;\n+\n+            // These accesses are protected by the respective native/green\n+            // mutexes which were acquired above.\n+            let prev = if can_block {\n+                unsafe { mem::replace(&mut *self.native_blocker.get(), task) }\n             } else {\n-                assert_eq!(self.green_blocker, 0);\n-                self.green_blocker = task;\n-            }\n+                unsafe { mem::replace(&mut *self.green_blocker.get(), task) }\n+            };\n+            assert_eq!(prev, 0);\n \n             loop {\n                 assert_eq!(old & native_bit, 0);\n@@ -264,14 +276,23 @@ impl StaticMutex {\n                                                             old | LOCKED,\n                                                             atomics::SeqCst) {\n                         n if n == old => {\n-                            assert_eq!(self.flavor, Unlocked);\n-                            if can_block {\n-                                self.native_blocker = 0;\n-                                self.flavor = NativeAcquisition;\n+                            // After acquiring the lock, we have access to the\n+                            // flavor field, and we've regained access to our\n+                            // respective native/green blocker field.\n+                            let prev = if can_block {\n+                                unsafe {\n+                                    *self.native_blocker.get() = 0;\n+                                    mem::replace(&mut *self.flavor.get(),\n+                                                 NativeAcquisition)\n+                                }\n                             } else {\n-                                self.green_blocker = 0;\n-                                self.flavor = GreenAcquisition;\n-                            }\n+                                unsafe {\n+                                    *self.green_blocker.get() = 0;\n+                                    mem::replace(&mut *self.flavor.get(),\n+                                                 GreenAcquisition)\n+                                }\n+                            };\n+                            assert_eq!(prev, Unlocked);\n                             return Err(unsafe {\n                                 BlockedTask::cast_from_uint(task)\n                             })\n@@ -287,16 +308,16 @@ impl StaticMutex {\n \n     // Tasks which can block are super easy. These tasks just call the blocking\n     // `lock()` function on an OS mutex\n-    fn native_lock(&mut self, t: ~Task) {\n+    fn native_lock(&self, t: ~Task) {\n         Local::put(t);\n         unsafe { self.lock.lock_noguard(); }\n     }\n \n-    fn native_unlock(&mut self) {\n+    fn native_unlock(&self) {\n         unsafe { self.lock.unlock_noguard(); }\n     }\n \n-    fn green_lock(&mut self, t: ~Task) {\n+    fn green_lock(&self, t: ~Task) {\n         // Green threads flag their presence with an atomic counter, and if they\n         // fail to be the first to the mutex, they enqueue themselves on a\n         // concurrent internal queue with a stack-allocated node.\n@@ -318,7 +339,7 @@ impl StaticMutex {\n         });\n     }\n \n-    fn green_unlock(&mut self) {\n+    fn green_unlock(&self) {\n         // If we're the only green thread, then no need to check the queue,\n         // otherwise the fixme above forces us to spin for a bit.\n         if self.green_cnt.fetch_sub(1, atomics::SeqCst) == 1 { return }\n@@ -333,7 +354,7 @@ impl StaticMutex {\n         task.wake().map(|t| t.reawaken());\n     }\n \n-    fn unlock(&mut self) {\n+    fn unlock(&self) {\n         // Unlocking this mutex is a little tricky. We favor any task that is\n         // manually blocked (not in each of the separate locks) in order to help\n         // provide a little fairness (green threads will wake up the pending\n@@ -351,8 +372,7 @@ impl StaticMutex {\n         // task needs to be woken, and in this case it's ok that the \"mutex\n         // halves\" are unlocked, we're just mainly dealing with the atomic state\n         // of the outer mutex.\n-        let flavor = self.flavor;\n-        self.flavor = Unlocked;\n+        let flavor = unsafe { mem::replace(&mut *self.flavor.get(), Unlocked) };\n \n         let mut state = self.state.load(atomics::SeqCst);\n         let mut unlocked = false;\n@@ -362,18 +382,18 @@ impl StaticMutex {\n             if state & GREEN_BLOCKED != 0 {\n                 self.unset(state, GREEN_BLOCKED);\n                 task = unsafe {\n-                    BlockedTask::cast_from_uint(self.green_blocker)\n+                    *self.flavor.get() = GreenAcquisition;\n+                    let task = mem::replace(&mut *self.green_blocker.get(), 0);\n+                    BlockedTask::cast_from_uint(task)\n                 };\n-                self.green_blocker = 0;\n-                self.flavor = GreenAcquisition;\n                 break;\n             } else if state & NATIVE_BLOCKED != 0 {\n                 self.unset(state, NATIVE_BLOCKED);\n                 task = unsafe {\n-                    BlockedTask::cast_from_uint(self.native_blocker)\n+                    *self.flavor.get() = NativeAcquisition;\n+                    let task = mem::replace(&mut *self.native_blocker.get(), 0);\n+                    BlockedTask::cast_from_uint(task)\n                 };\n-                self.native_blocker = 0;\n-                self.flavor = NativeAcquisition;\n                 break;\n             } else {\n                 assert_eq!(state, LOCKED);\n@@ -405,7 +425,7 @@ impl StaticMutex {\n     }\n \n     /// Loops around a CAS to unset the `bit` in `state`\n-    fn unset(&mut self, mut state: uint, bit: uint) {\n+    fn unset(&self, mut state: uint, bit: uint) {\n         loop {\n             assert!(state & bit != 0);\n             let new = state ^ bit;\n@@ -426,7 +446,7 @@ impl StaticMutex {\n     /// *all* platforms. It may be the case that some platforms do not leak\n     /// memory if this method is not called, but this is not guaranteed to be\n     /// true on all platforms.\n-    pub unsafe fn destroy(&mut self) {\n+    pub unsafe fn destroy(&self) {\n         self.lock.destroy()\n     }\n }\n@@ -437,9 +457,9 @@ impl Mutex {\n         Mutex {\n             lock: StaticMutex {\n                 state: atomics::AtomicUint::new(0),\n-                flavor: Unlocked,\n-                green_blocker: 0,\n-                native_blocker: 0,\n+                flavor: Unsafe::new(Unlocked),\n+                green_blocker: Unsafe::new(0),\n+                native_blocker: Unsafe::new(0),\n                 green_cnt: atomics::AtomicUint::new(0),\n                 q: q::Queue::new(),\n                 lock: unsafe { mutex::StaticNativeMutex::new() },\n@@ -454,7 +474,7 @@ impl Mutex {\n     /// guard is dropped.\n     ///\n     /// This function does not block.\n-    pub fn try_lock<'a>(&'a mut self) -> Option<Guard<'a>> {\n+    pub fn try_lock<'a>(&'a self) -> Option<Guard<'a>> {\n         self.lock.try_lock()\n     }\n \n@@ -464,13 +484,14 @@ impl Mutex {\n     /// the mutex. Upon returning, the task is the only task with the mutex\n     /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n     /// the guard goes out of scope, the mutex will be unlocked.\n-    pub fn lock<'a>(&'a mut self) -> Guard<'a> { self.lock.lock() }\n+    pub fn lock<'a>(&'a self) -> Guard<'a> { self.lock.lock() }\n }\n \n impl<'a> Guard<'a> {\n-    fn new<'b>(lock: &'b mut StaticMutex) -> Guard<'b> {\n+    fn new<'b>(lock: &'b StaticMutex) -> Guard<'b> {\n         if cfg!(debug) {\n-            assert!(lock.flavor != Unlocked);\n+            // once we've acquired a lock, it's ok to access the flavor\n+            assert!(unsafe { *lock.flavor.get() != Unlocked });\n             assert!(lock.state.load(atomics::SeqCst) & LOCKED != 0);\n         }\n         Guard { lock: lock }\n@@ -501,7 +522,7 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        let mut m = Mutex::new();\n+        let m = Mutex::new();\n         drop(m.lock());\n         drop(m.lock());\n     }\n@@ -552,7 +573,7 @@ mod test {\n \n     #[test]\n     fn trylock() {\n-        let mut m = Mutex::new();\n+        let m = Mutex::new();\n         assert!(m.try_lock().is_some());\n     }\n }", "previous_filename": "src/libsync/sync/mutex.rs"}]}