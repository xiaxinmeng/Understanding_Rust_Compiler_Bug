{"sha": "608dc492ea9adaed2ae0cfee03fd5a6e398032c5", "node_id": "C_kwDOAAsO6NoAKDYwOGRjNDkyZWE5YWRhZWQyYWUwY2ZlZTAzZmQ1YTZlMzk4MDMyYzU", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-21T20:34:49Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-21T20:36:05Z"}, "message": "Move `is_inside_unsafe` to `Semantics` impl", "tree": {"sha": "06ef674b15c398ae7a89fc19d1120d863e54ba65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06ef674b15c398ae7a89fc19d1120d863e54ba65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/608dc492ea9adaed2ae0cfee03fd5a6e398032c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/608dc492ea9adaed2ae0cfee03fd5a6e398032c5", "html_url": "https://github.com/rust-lang/rust/commit/608dc492ea9adaed2ae0cfee03fd5a6e398032c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/608dc492ea9adaed2ae0cfee03fd5a6e398032c5/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bfe7040e8321e8fbe3c5bdc8660dae1488838d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bfe7040e8321e8fbe3c5bdc8660dae1488838d1", "html_url": "https://github.com/rust-lang/rust/commit/3bfe7040e8321e8fbe3c5bdc8660dae1488838d1"}], "stats": {"total": 147, "additions": 74, "deletions": 73}, "files": [{"sha": "2933d488a186af2c92ec8964f34f555f65d7be74", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/608dc492ea9adaed2ae0cfee03fd5a6e398032c5/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608dc492ea9adaed2ae0cfee03fd5a6e398032c5/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=608dc492ea9adaed2ae0cfee03fd5a6e398032c5", "patch": "@@ -50,8 +50,8 @@ use hir_def::{\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n-    AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, EnumId, EnumVariantId,\n-    FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n+    AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n+    EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n     LocalEnumVariantId, LocalFieldId, Lookup, MacroExpander, MacroId, ModuleId, StaticId, StructId,\n     TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,\n };\n@@ -107,16 +107,13 @@ pub use {\n     hir_def::{\n         adt::StructKind,\n         attr::{Attr, Attrs, AttrsWithOwner, Documentation},\n-        body::{Body, BodySourceMap},\n         builtin_attr::AttributeTemplate,\n-        expr::Expr,\n         find_path::PrefixKind,\n         import_map,\n         nameres::ModuleSource,\n         path::{ModPath, PathKind},\n         type_ref::{Mutability, TypeRef},\n         visibility::Visibility,\n-        DefWithBodyId,\n     },\n     hir_expand::{\n         name::{known, Name},"}, {"sha": "8d75e01029b24f9e45082fe6ce467ce7bf58c0a9", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/608dc492ea9adaed2ae0cfee03fd5a6e398032c5/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608dc492ea9adaed2ae0cfee03fd5a6e398032c5/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=608dc492ea9adaed2ae0cfee03fd5a6e398032c5", "patch": "@@ -5,11 +5,14 @@ mod source_to_def;\n use std::{cell::RefCell, fmt, iter, mem, ops};\n \n use base_db::{FileId, FileRange};\n+use either::Either;\n use hir_def::{\n-    body, macro_id_to_def_id,\n+    body,\n+    expr::Expr,\n+    macro_id_to_def_id,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     type_ref::Mutability,\n-    AsMacroCall, FunctionId, MacroId, TraitId, VariantId,\n+    AsMacroCall, DefWithBodyId, FunctionId, MacroId, TraitId, VariantId,\n };\n use hir_expand::{\n     db::AstDatabase,\n@@ -438,8 +441,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     }\n \n     pub fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n-        let src = self.imp.find_file(src.syntax()).with_value(src).cloned();\n-        T::to_def(&self.imp, src)\n+        self.imp.to_def(src)\n     }\n \n     pub fn to_module_def(&self, file: FileId) -> Option<Module> {\n@@ -481,6 +483,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn is_unsafe_ident_pat(&self, ident_pat: &ast::IdentPat) -> bool {\n         self.imp.is_unsafe_ident_pat(ident_pat)\n     }\n+\n+    /// Returns `true` if the `node` is inside an `unsafe` context.\n+    pub fn is_inside_unsafe(&self, node: &SyntaxNode) -> bool {\n+        self.imp.is_inside_unsafe(node)\n+    }\n }\n \n impl<'db> SemanticsImpl<'db> {\n@@ -1243,6 +1250,11 @@ impl<'db> SemanticsImpl<'db> {\n         f(&mut ctx)\n     }\n \n+    fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n+        let src = self.find_file(src.syntax()).with_value(src).cloned();\n+        T::to_def(&self, src)\n+    }\n+\n     fn to_module_def(&self, file: FileId) -> impl Iterator<Item = Module> {\n         self.with_ctx(|ctx| ctx.file_to_def(file)).into_iter().map(Module::from)\n     }\n@@ -1458,6 +1470,59 @@ impl<'db> SemanticsImpl<'db> {\n             .map(|ty| ty.original.is_packed(self.db))\n             .unwrap_or(false)\n     }\n+\n+    fn is_inside_unsafe(&self, node: &SyntaxNode) -> bool {\n+        let item_or_variant = |ancestor: SyntaxNode| {\n+            if ast::Item::can_cast(ancestor.kind()) {\n+                ast::Item::cast(ancestor).map(Either::Left)\n+            } else {\n+                ast::Variant::cast(ancestor).map(Either::Right)\n+            }\n+        };\n+        let Some(enclosing_item) = node.ancestors().find_map(item_or_variant) else { return false };\n+\n+        let def = match &enclosing_item {\n+            Either::Left(ast::Item::Fn(it)) => {\n+                self.to_def(it).map(<_>::into).map(DefWithBodyId::FunctionId)\n+            }\n+            Either::Left(ast::Item::Const(it)) => {\n+                self.to_def(it).map(<_>::into).map(DefWithBodyId::ConstId)\n+            }\n+            Either::Left(ast::Item::Static(it)) => {\n+                self.to_def(it).map(<_>::into).map(DefWithBodyId::StaticId)\n+            }\n+            Either::Left(_) => None,\n+            Either::Right(it) => self.to_def(it).map(<_>::into).map(DefWithBodyId::VariantId),\n+        };\n+        let Some(def) = def else { return false };\n+        let enclosing_node = enclosing_item.as_ref().either(|i| i.syntax(), |v| v.syntax());\n+\n+        if ast::Fn::cast(enclosing_node.clone()).and_then(|f| f.unsafe_token()).is_some() {\n+            return true;\n+        }\n+\n+        let (body, source_map) = self.db.body_with_source_map(def);\n+\n+        let file_id = self.find_file(node).file_id;\n+\n+        let Some(mut parent) = node.parent() else { return false };\n+        loop {\n+            if &parent == enclosing_node {\n+                break false;\n+            }\n+\n+            if let Some(parent) = ast::Expr::cast(parent.clone()) {\n+                if let Some(expr_id) = source_map.node_expr(InFile { file_id, value: &parent }) {\n+                    if let Expr::Unsafe { .. } = body[expr_id] {\n+                        break true;\n+                    }\n+                }\n+            }\n+\n+            let Some(parent_) = parent.parent() else { break false };\n+            parent = parent_;\n+        }\n+    }\n }\n \n fn macro_call_to_macro_id("}, {"sha": "e7ebaa1d4680059f0508a2ce1661832e72c9a810", "filename": "crates/ide/src/inlay_hints/adjustment.rs", "status": "modified", "additions": 3, "deletions": 64, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/608dc492ea9adaed2ae0cfee03fd5a6e398032c5/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608dc492ea9adaed2ae0cfee03fd5a6e398032c5/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=608dc492ea9adaed2ae0cfee03fd5a6e398032c5", "patch": "@@ -3,17 +3,9 @@\n //! let _: u32  = /* <never-to-any> */ loop {};\n //! let _: &u32 = /* &* */ &mut 0;\n //! ```\n-use either::Either;\n-use hir::{\n-    db::DefDatabase, Adjust, AutoBorrow, InFile, Mutability, OverloadedDeref, PointerCast, Safety,\n-    Semantics,\n-};\n+use hir::{Adjust, AutoBorrow, Mutability, OverloadedDeref, PointerCast, Safety, Semantics};\n use ide_db::RootDatabase;\n-\n-use syntax::{\n-    ast::{self, AstNode},\n-    SyntaxNode,\n-};\n+use syntax::ast::{self, AstNode};\n \n use crate::{AdjustmentHints, InlayHint, InlayHintsConfig, InlayKind};\n \n@@ -23,7 +15,7 @@ pub(super) fn hints(\n     config: &InlayHintsConfig,\n     expr: &ast::Expr,\n ) -> Option<()> {\n-    if config.adjustment_hints_hide_outside_unsafe && !is_inside_unsafe(sema, expr.syntax()) {\n+    if config.adjustment_hints_hide_outside_unsafe && !sema.is_inside_unsafe(expr.syntax()) {\n         return None;\n     }\n \n@@ -121,59 +113,6 @@ pub(super) fn hints(\n     Some(())\n }\n \n-fn is_inside_unsafe(sema: &Semantics<'_, RootDatabase>, node: &SyntaxNode) -> bool {\n-    let item_or_variant = |ancestor: SyntaxNode| {\n-        if ast::Item::can_cast(ancestor.kind()) {\n-            ast::Item::cast(ancestor).map(Either::Left)\n-        } else {\n-            ast::Variant::cast(ancestor).map(Either::Right)\n-        }\n-    };\n-    let Some(enclosing_item) = node.ancestors().find_map(item_or_variant) else { return false };\n-\n-    let def = match &enclosing_item {\n-        Either::Left(ast::Item::Fn(it)) => {\n-            sema.to_def(it).map(<_>::into).map(hir::DefWithBodyId::FunctionId)\n-        }\n-        Either::Left(ast::Item::Const(it)) => {\n-            sema.to_def(it).map(<_>::into).map(hir::DefWithBodyId::ConstId)\n-        }\n-        Either::Left(ast::Item::Static(it)) => {\n-            sema.to_def(it).map(<_>::into).map(hir::DefWithBodyId::StaticId)\n-        }\n-        Either::Left(_) => None,\n-        Either::Right(it) => sema.to_def(it).map(<_>::into).map(hir::DefWithBodyId::VariantId),\n-    };\n-    let Some(def) = def else { return false };\n-    let enclosing_node = enclosing_item.as_ref().either(|i| i.syntax(), |v| v.syntax());\n-\n-    if ast::Fn::cast(enclosing_node.clone()).and_then(|f| f.unsafe_token()).is_some() {\n-        return true;\n-    }\n-\n-    let (body, source_map) = sema.db.body_with_source_map(def);\n-\n-    let file_id = sema.hir_file_for(node);\n-\n-    let Some(mut parent) = node.parent() else { return false };\n-    loop {\n-        if &parent == enclosing_node {\n-            break false;\n-        }\n-\n-        if let Some(parent) = ast::Expr::cast(parent.clone()) {\n-            if let Some(expr_id) = source_map.node_expr(InFile { file_id, value: &parent }) {\n-                if let hir::Expr::Unsafe { .. } = body[expr_id] {\n-                    break true;\n-                }\n-            }\n-        }\n-\n-        let Some(parent_) = parent.parent() else { break false };\n-        parent = parent_;\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::{"}]}