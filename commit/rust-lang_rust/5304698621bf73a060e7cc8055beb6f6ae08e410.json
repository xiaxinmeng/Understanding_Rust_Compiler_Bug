{"sha": "5304698621bf73a060e7cc8055beb6f6ae08e410", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMDQ2OTg2MjFiZjczYTA2MGU3Y2M4MDU1YmViNmY2YWUwOGU0MTA=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-06-25T15:02:34Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-29T22:41:56Z"}, "message": "std: net::ip::get_addr is working w/ happy path test. needs more.", "tree": {"sha": "878e2216ca26520f5af3b73b7b5e2a162b40a92d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/878e2216ca26520f5af3b73b7b5e2a162b40a92d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5304698621bf73a060e7cc8055beb6f6ae08e410", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5304698621bf73a060e7cc8055beb6f6ae08e410", "html_url": "https://github.com/rust-lang/rust/commit/5304698621bf73a060e7cc8055beb6f6ae08e410", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5304698621bf73a060e7cc8055beb6f6ae08e410/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcc341f5fb1d4c530ee21890ee800779e9c4235b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcc341f5fb1d4c530ee21890ee800779e9c4235b", "html_url": "https://github.com/rust-lang/rust/commit/bcc341f5fb1d4c530ee21890ee800779e9c4235b"}], "stats": {"total": 109, "additions": 77, "deletions": 32}, "files": [{"sha": "9f19a3dcba8c1a2725a2b1953dbd9a9374368119", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 64, "deletions": 21, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/5304698621bf73a060e7cc8055beb6f6ae08e410/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5304698621bf73a060e7cc8055beb6f6ae08e410/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=5304698621bf73a060e7cc8055beb6f6ae08e410", "patch": "@@ -17,9 +17,10 @@ import uv_ip4_name = uv::ll::ip4_name;\n import uv_ip6_addr = uv::ll::ip6_addr;\n import uv_ip6_name = uv::ll::ip6_name;\n import uv_getaddrinfo = uv::ll::getaddrinfo;\n+import uv_freeaddrinfo = uv::ll::freeaddrinfo;\n import create_uv_getaddrinfo_t = uv::ll::getaddrinfo_t;\n-import set_data_for_uv_handle = uv::ll::set_data_for_uv_handle;\n-import get_data_for_uv_handle = uv::ll::get_data_for_uv_handle;\n+import set_data_for_req = uv::ll::set_data_for_req;\n+import get_data_for_req = uv::ll::get_data_for_req;\n import ll = uv::ll;\n \n export ip_addr, parse_addr_err;\n@@ -77,43 +78,65 @@ type get_addr_data = {\n \n crust fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                      res: *addrinfo) unsafe {\n-    let handle_data = get_data_for_uv_handle(handle) as\n+    log(debug, \"in get_addr_cb\");\n+    let handle_data = get_data_for_req(handle) as\n         *get_addr_data;\n     if status == 0i32 {\n         if res != (ptr::null::<addrinfo>()) {\n             let mut out_vec = [];\n+            let mut addr_strings = [];\n+            log(debug, #fmt(\"initial addrinfo: %?\", res));\n             let mut curr_addr = res;\n             loop {\n-                if ll::is_ipv4_addrinfo(curr_addr) {\n-                    out_vec +=\n-                        [ipv4(copy((\n-                            *ll::addrinfo_as_sockaddr_in(curr_addr))))];\n+                let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n+                    ipv4(copy((\n+                        *ll::addrinfo_as_sockaddr_in(curr_addr))))\n                 }\n                 else {\n-                    out_vec +=\n-                        [ipv6(copy((\n-                            *ll::addrinfo_as_sockaddr_in6(curr_addr))))];\n+                    ipv6(copy((\n+                        *ll::addrinfo_as_sockaddr_in6(curr_addr))))\n+                };\n+                // we're doing this check to avoid adding multiple\n+                // ip_addrs to the out_vec that are duplicates.. on\n+                // 64bit unbuntu a call to uv_getaddrinfo against\n+                // localhost seems to return three addrinfos, all\n+                // distinct (by ptr addr), that are all ipv4\n+                // addresses and all point to 127.0.0.1\n+                let addr_str = format_addr(new_ip_addr);\n+                if !vec::contains(addr_strings, addr_str) {\n+                    addr_strings += [addr_str];\n+                    out_vec += [new_ip_addr];\n                 }\n \n                 let next_addr = ll::get_next_addrinfo(curr_addr);\n                 if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n+                    log(debug, \"null next_addr encountered. no mas\");\n                     break;\n                 }\n                 else {\n-                    curr_addr = next_addr\n+                    curr_addr = next_addr;\n+                    log(debug, #fmt(\"next_addr addrinfo: %?\", curr_addr));\n                 }\n             }\n+            log(debug, #fmt(\"successful process addrinfo result, len: %?\",\n+                            vec::len(out_vec)));\n             (*handle_data).output_ch.send(result::ok(out_vec));\n         }\n         else {\n+            log(debug, \"addrinfo pointer is NULL\");\n             (*handle_data).output_ch.send(\n                 result::err(get_addr_unknown_error));\n         }\n     }\n     else {\n+        log(debug, \"status != 0 error in get_addr_cb\");\n         (*handle_data).output_ch.send(\n             result::err(get_addr_unknown_error));\n     }\n+    if res != (ptr::null::<addrinfo>()) {\n+        uv_freeaddrinfo(res);\n+    }\n+    log(debug, \"leaving get_addr_cb\");\n }\n \n #[doc=\"\n@@ -128,7 +151,7 @@ fn get_addr(++node: str, iotask: iotask)\n         -> result::result<[ip_addr], ip_get_addr_err> unsafe {\n     comm::listen {|output_ch|\n         str::unpack_slice(node) {|node_ptr, len|\n-            log(debug, #fmt(\"sliace len %?\", len));\n+            log(debug, #fmt(\"slice len %?\", len));\n             let handle = create_uv_getaddrinfo_t();\n             let handle_ptr = ptr::addr_of(handle);\n             let handle_data: get_addr_data = {\n@@ -145,7 +168,7 @@ fn get_addr(++node: str, iotask: iotask)\n                     ptr::null());\n                 alt result {\n                   0i32 {\n-                    set_data_for_uv_handle(handle_ptr, handle_data_ptr);\n+                    set_data_for_req(handle_ptr, handle_data_ptr);\n                   }\n                   _ {\n                     output_ch.send(result::err(get_addr_unknown_error));\n@@ -175,9 +198,6 @@ mod v4 {\n     \"]\n     fn parse_addr(ip: str) -> ip_addr {\n         alt try_parse_addr(ip) {\n-          // FIXME: more copies brought to light to due the implicit\n-          // copy compiler warning.. what can be done? out pointers,\n-          // ala c#?\n           result::ok(addr) { copy(addr) }\n           result::err(err_data) {\n             fail err_data.err_msg\n@@ -198,7 +218,7 @@ mod v4 {\n                                            ip)})\n             }\n             else {\n-                result::ok(ipv4(new_addr))\n+                result::ok(ipv4(copy(new_addr)))\n             }\n         }\n     }\n@@ -221,9 +241,6 @@ mod v6 {\n     \"]\n     fn parse_addr(ip: str) -> ip_addr {\n         alt try_parse_addr(ip) {\n-          // FIXME: more copies brought to light to due the implicit\n-          // copy compiler warning.. what can be done? out pointers,\n-          // ala c#?\n           result::ok(addr) { copy(addr) }\n           result::err(err_data) {\n             fail err_data.err_msg\n@@ -250,7 +267,7 @@ mod v6 {\n     }\n }\n \n-//#[cfg(test)]\n+#[cfg(test)]\n mod test {\n     #[test]\n     fn test_ipv4_parse_and_format_ip() {\n@@ -290,4 +307,30 @@ mod test {\n           }\n         }\n     }\n+    #[test]\n+    fn test_get_addr() {\n+        let localhost_name = \"localhost\";\n+        let iotask = uv::global_loop::get();\n+        let ga_result = get_addr(localhost_name, iotask);\n+        if result::is_err(ga_result) {\n+            fail \"got err result from net::ip::get_addr();\"\n+        }\n+        // note really sure how to realiably test/assert\n+        // this.. mostly just wanting to see it work, atm.\n+        let results = result::unwrap(ga_result);\n+        log(debug, #fmt(\"test_get_addr: Number of results for %s: %?\",\n+                        localhost_name, vec::len(results)));\n+        for vec::each(results) {|r|\n+            let ipv_prefix = alt r {\n+              ipv4(_) {\n+                \"IPv4\"\n+              }\n+              ipv6(_) {\n+                \"IPv6\"\n+              }\n+            };\n+            log(debug, #fmt(\"test_get_addr: result %s: '%s'\",\n+                            ipv_prefix, format_addr(r)));\n+        }\n+    }\n }\n\\ No newline at end of file"}, {"sha": "d4fd6509339071e90a1a88d598a04fdc9b861716", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5304698621bf73a060e7cc8055beb6f6ae08e410/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5304698621bf73a060e7cc8055beb6f6ae08e410/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=5304698621bf73a060e7cc8055beb6f6ae08e410", "patch": "@@ -418,7 +418,7 @@ net::tcp::listen(remote_ip, remote_port, backlog)\n     let cont_ch = comm::chan(cont_po);\n     task::spawn {||\n         let accept_result = net::tcp::accept(new_conn);\n-        if accept_result.is_failure() {\n+        if accept_result.is_err() {\n             comm::send(cont_ch, result::get_err(accept_result));\n             // fail?\n         }\n@@ -754,7 +754,7 @@ impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n         }\n         else {\n             let read_result = read((*self).sock, 0u);\n-            if read_result.is_failure() {\n+            if read_result.is_err() {\n                 let err_data = read_result.get_err();\n                 log(debug, #fmt(\"ERROR sock_buf as io::reader.read err %? %?\",\n                                  err_data.err_name, err_data.err_msg));\n@@ -771,9 +771,7 @@ impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n         self.read_bytes(1u)[0] as int\n     }\n     fn unread_byte(amt: int) {\n-        // FIXME: stubbing this out pending the\n-        // return of vec::unshift\n-        //vec::unshift((*self).buf, amt as u8);\n+        vec::unshift((*self).buf, amt as u8);\n     }\n     fn eof() -> bool {\n         false // noop\n@@ -798,7 +796,7 @@ impl tcp_socket_buf of io::writer for @tcp_socket_buf {\n         };\n         let write_buf_vec_ptr = ptr::addr_of(write_buf_vec);\n         let w_result = write_common_impl(socket_data_ptr, write_buf_vec_ptr);\n-        if w_result.is_failure() {\n+        if w_result.is_err() {\n             let err_data = w_result.get_err();\n             log(debug, #fmt(\"ERROR sock_buf as io::writer.writer err: %? %?\",\n                              err_data.err_name, err_data.err_msg));\n@@ -1321,7 +1319,7 @@ mod test {\n                 client_ch,\n                 hl_loop)\n         };\n-        assert actual_resp_result.is_success();\n+        assert actual_resp_result.is_ok();\n         let actual_resp = actual_resp_result.get();\n         let actual_req = comm::recv(server_result_po);\n         log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n@@ -1453,7 +1451,7 @@ mod test {\n         // client\n         let server_addr = ip::v4::parse_addr(server_ip);\n         let conn_result = connect(server_addr, server_port, iotask);\n-        if result::is_failure(conn_result) {\n+        if result::is_err(conn_result) {\n             assert false;\n         }\n         let sock_buf = @socket_buf(result::unwrap(conn_result));\n@@ -1589,7 +1587,7 @@ mod test {\n                            new_conn, kill_ch);\n         });\n         // err check on listen_result\n-        if result::is_failure(listen_result) {\n+        if result::is_err(listen_result) {\n             result::get_err(listen_result)\n         }\n         else {"}, {"sha": "09f8c61d45d48bdac18928ee47e20fb8ef325773", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5304698621bf73a060e7cc8055beb6f6ae08e410/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5304698621bf73a060e7cc8055beb6f6ae08e410/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=5304698621bf73a060e7cc8055beb6f6ae08e410", "patch": "@@ -567,6 +567,7 @@ native mod rustrt {\n                            service_name_ptr: *u8,\n                            // should probably only pass ptr::null()\n                            hints: *addrinfo) -> libc::c_int;\n+    fn rust_uv_freeaddrinfo(res: *addrinfo);\n \n     // data accessors/helpers for rust-mapped uv structs\n     fn rust_uv_is_ipv4_addrinfo(input: *addrinfo) -> bool;\n@@ -755,7 +756,7 @@ unsafe fn ip4_name(src: &sockaddr_in) -> str {\n         rustrt::rust_uv_ip4_name(src as *sockaddr_in,\n                                               dst_buf, size);\n         // FIXME: seems that checking the result of uv_ip4_name\n-        // doesn't work too well.. \n+        // doesn't work too well..\n         // libuv will actually map a malformed input ip to INADDR_NONE,\n         // which is going to be 255.255.255.255 on most\n         // platforms.\n@@ -810,6 +811,9 @@ unsafe fn getaddrinfo(loop_ptr: *libc::c_void,\n                            service_name_ptr,\n                            hints)\n }\n+unsafe fn freeaddrinfo(res: *addrinfo) {\n+    rustrt::rust_uv_freeaddrinfo(res);\n+}\n \n // libuv struct initializers\n unsafe fn tcp_t() -> uv_tcp_t {\n@@ -1544,7 +1548,7 @@ mod test {\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n-    \n+\n     #[test]\n     #[ignore(cfg(target_os = \"freebsd\"))]\n     fn test_uv_ll_struct_size_uv_getaddrinfo_t() {"}]}