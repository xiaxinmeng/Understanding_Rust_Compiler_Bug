{"sha": "a691f1eefea586f154700be6ee1b991158f82b7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OTFmMWVlZmVhNTg2ZjE1NDcwMGJlNmVlMWI5OTExNThmODJiN2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-15T08:21:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-15T08:21:43Z"}, "message": "Auto merge of #24426 - alexcrichton:windows-pipes, r=aturon\n\nThis commit removes the last remnants of file descriptors from the Windows\r\nimplementation of `std::sys` by using `CreatePipe` to create anonymous pipes\r\ninstead of the `pipe` shim provided in msvcrt.", "tree": {"sha": "66bb95a8b8bd3716715e83ba6d983bbd507797f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66bb95a8b8bd3716715e83ba6d983bbd507797f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a691f1eefea586f154700be6ee1b991158f82b7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a691f1eefea586f154700be6ee1b991158f82b7f", "html_url": "https://github.com/rust-lang/rust/commit/a691f1eefea586f154700be6ee1b991158f82b7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a691f1eefea586f154700be6ee1b991158f82b7f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af1c39cbd90a03f22dbb2b144ac1e543dbe0fe1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/af1c39cbd90a03f22dbb2b144ac1e543dbe0fe1d", "html_url": "https://github.com/rust-lang/rust/commit/af1c39cbd90a03f22dbb2b144ac1e543dbe0fe1d"}, {"sha": "5e073293064a227ebf454053c8aa35d7d8bdcf52", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e073293064a227ebf454053c8aa35d7d8bdcf52", "html_url": "https://github.com/rust-lang/rust/commit/5e073293064a227ebf454053c8aa35d7d8bdcf52"}], "stats": {"total": 128, "additions": 46, "deletions": 82}, "files": [{"sha": "45f389f0aebf8bb369b0513bfb55115036c466f6", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a691f1eefea586f154700be6ee1b991158f82b7f/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a691f1eefea586f154700be6ee1b991158f82b7f/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=a691f1eefea586f154700be6ee1b991158f82b7f", "patch": "@@ -465,6 +465,10 @@ extern \"system\" {\n                            nOutBufferSize: libc::DWORD,\n                            lpBytesReturned: libc::LPDWORD,\n                            lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n+    pub fn CreatePipe(hReadPipe: libc::LPHANDLE,\n+                      hWritePipe: libc::LPHANDLE,\n+                      lpPipeAttributes: libc::LPSECURITY_ATTRIBUTES,\n+                      nSize: libc::DWORD) -> libc::BOOL;\n }\n \n #[link(name = \"userenv\")]"}, {"sha": "c3a30aae9e0e87dd23b5c5630c6d6d4f7a7ddef7", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a691f1eefea586f154700be6ee1b991158f82b7f/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a691f1eefea586f154700be6ee1b991158f82b7f/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=a691f1eefea586f154700be6ee1b991158f82b7f", "patch": "@@ -36,11 +36,34 @@ impl Handle {\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        read(self.0, buf)\n+        let mut read = 0;\n+        let res = cvt(unsafe {\n+            libc::ReadFile(self.0, buf.as_ptr() as libc::LPVOID,\n+                           buf.len() as libc::DWORD, &mut read,\n+                           ptr::null_mut())\n+        });\n+\n+        match res {\n+            Ok(_) => Ok(read as usize),\n+\n+            // The special treatment of BrokenPipe is to deal with Windows\n+            // pipe semantics, which yields this error when *reading* from\n+            // a pipe after the other end has closed; we interpret that as\n+            // EOF on the pipe.\n+            Err(ref e) if e.kind() == ErrorKind::BrokenPipe => Ok(0),\n+\n+            Err(e) => Err(e)\n+        }\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        write(self.0, buf)\n+        let mut amt = 0;\n+        try!(cvt(unsafe {\n+            libc::WriteFile(self.0, buf.as_ptr() as libc::LPVOID,\n+                            buf.len() as libc::DWORD, &mut amt,\n+                            ptr::null_mut())\n+        }));\n+        Ok(amt as usize)\n     }\n }\n \n@@ -49,35 +72,3 @@ impl Drop for Handle {\n         unsafe { let _ = libc::CloseHandle(self.0); }\n     }\n }\n-\n-\n-pub fn read(h: HANDLE, buf: &mut [u8]) -> io::Result<usize> {\n-    let mut read = 0;\n-    let res = cvt(unsafe {\n-        libc::ReadFile(h, buf.as_ptr() as libc::LPVOID,\n-                       buf.len() as libc::DWORD, &mut read,\n-                       ptr::null_mut())\n-    });\n-\n-    match res {\n-        Ok(_) => Ok(read as usize),\n-\n-        // The special treatment of BrokenPipe is to deal with Windows\n-        // pipe semantics, which yields this error when *reading* from\n-        // a pipe after the other end has closed; we interpret that as\n-        // EOF on the pipe.\n-        Err(ref e) if e.kind() == ErrorKind::BrokenPipe => Ok(0),\n-\n-        Err(e) => Err(e)\n-    }\n-}\n-\n-pub fn write(h: HANDLE, buf: &[u8]) -> io::Result<usize> {\n-    let mut amt = 0;\n-    try!(cvt(unsafe {\n-        libc::WriteFile(h, buf.as_ptr() as libc::LPVOID,\n-                        buf.len() as libc::DWORD, &mut amt,\n-                        ptr::null_mut())\n-    }));\n-    Ok(amt as usize)\n-}"}, {"sha": "b441d8beedbc04dd7ab3569aafab81af3fc399c6", "filename": "src/libstd/sys/windows/pipe2.rs", "status": "modified", "additions": 16, "deletions": 47, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a691f1eefea586f154700be6ee1b991158f82b7f/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a691f1eefea586f154700be6ee1b991158f82b7f/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs?ref=a691f1eefea586f154700be6ee1b991158f82b7f", "patch": "@@ -10,70 +10,39 @@\n \n use prelude::v1::*;\n \n-use sys::handle;\n use io;\n-use libc::{self, c_int, HANDLE};\n+use libc;\n+use sys::cvt;\n+use sys::c;\n+use sys::handle::Handle;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Anonymous pipes\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct AnonPipe {\n-    fd: c_int\n+    inner: Handle,\n }\n \n pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n-    // Windows pipes work subtly differently than unix pipes, and their\n-    // inheritance has to be handled in a different way that I do not\n-    // fully understand. Here we explicitly make the pipe non-inheritable,\n-    // which means to pass it to a subprocess they need to be duplicated\n-    // first, as in std::run.\n-    let mut fds = [0; 2];\n-    unsafe {\n-        match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n-                         (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n-            0 => {\n-                assert!(fds[0] != -1 && fds[0] != 0);\n-                assert!(fds[1] != -1 && fds[1] != 0);\n-\n-                Ok((AnonPipe::from_fd(fds[0]), AnonPipe::from_fd(fds[1])))\n-            }\n-            _ => Err(io::Error::last_os_error()),\n-        }\n-    }\n+    let mut reader = libc::INVALID_HANDLE_VALUE;\n+    let mut writer = libc::INVALID_HANDLE_VALUE;\n+    try!(cvt(unsafe {\n+        c::CreatePipe(&mut reader, &mut writer, 0 as *mut _, 0)\n+    }));\n+    let reader = Handle::new(reader);\n+    let writer = Handle::new(writer);\n+    Ok((AnonPipe { inner: reader }, AnonPipe { inner: writer }))\n }\n \n impl AnonPipe {\n-    pub fn from_fd(fd: libc::c_int) -> AnonPipe {\n-        AnonPipe { fd: fd }\n-    }\n-\n-    pub fn raw(&self) -> HANDLE {\n-        unsafe { libc::get_osfhandle(self.fd) as libc::HANDLE }\n-    }\n+    pub fn handle(&self) -> &Handle { &self.inner }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        handle::read(self.raw(), buf)\n+        self.inner.read(buf)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        handle::write(self.raw(), buf)\n-    }\n-}\n-\n-impl Drop for AnonPipe {\n-    fn drop(&mut self) {\n-        // closing stdio file handles makes no sense, so never do it. Also, note\n-        // that errors are ignored when closing a file descriptor. The reason\n-        // for this is that if an error occurs we don't actually know if the\n-        // file descriptor was closed or not, and if we retried (for something\n-        // like EINTR), we might close another valid file descriptor (opened\n-        // after we closed ours.\n-        if self.fd > libc::STDERR_FILENO {\n-            let n = unsafe { libc::close(self.fd) };\n-            if n != 0 {\n-                println!(\"error {} when closing file descriptor {}\", n, self.fd);\n-            }\n-        }\n+        self.inner.write(buf)\n     }\n }"}, {"sha": "fdb47eb8c8084763832efc2c59a11ed09d7a21ba", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a691f1eefea586f154700be6ee1b991158f82b7f/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a691f1eefea586f154700be6ee1b991158f82b7f/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=a691f1eefea586f154700be6ee1b991158f82b7f", "patch": "@@ -199,7 +199,7 @@ impl Process {\n                         }\n                     }\n                     Stdio::Piped(ref pipe) => {\n-                        let orig = pipe.raw();\n+                        let orig = pipe.handle().raw();\n                         if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n                                            0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n                             return Err(Error::last_os_error())"}]}