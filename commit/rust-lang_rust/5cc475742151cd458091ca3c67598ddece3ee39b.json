{"sha": "5cc475742151cd458091ca3c67598ddece3ee39b", "node_id": "C_kwDOAAsO6NoAKDVjYzQ3NTc0MjE1MWNkNDU4MDkxY2EzYzY3NTk4ZGRlY2UzZWUzOWI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-03T01:35:51Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-12T23:20:12Z"}, "message": "More accurate argument blames, add some comments", "tree": {"sha": "2f71c5201c70785bda76ecc7249221cbb3ef4fa1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f71c5201c70785bda76ecc7249221cbb3ef4fa1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cc475742151cd458091ca3c67598ddece3ee39b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc475742151cd458091ca3c67598ddece3ee39b", "html_url": "https://github.com/rust-lang/rust/commit/5cc475742151cd458091ca3c67598ddece3ee39b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cc475742151cd458091ca3c67598ddece3ee39b/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a71029dd3b54046fbd6144de20e320db539820f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a71029dd3b54046fbd6144de20e320db539820f", "html_url": "https://github.com/rust-lang/rust/commit/5a71029dd3b54046fbd6144de20e320db539820f"}], "stats": {"total": 94, "additions": 69, "deletions": 25}, "files": [{"sha": "13442c3164928305d4c9fc4a51fbc6858a9de8f2", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 54, "deletions": 21, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5cc475742151cd458091ca3c67598ddece3ee39b/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc475742151cd458091ca3c67598ddece3ee39b/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=5cc475742151cd458091ca3c67598ddece3ee39b", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Notes the point at which a variable is constrained to some type incompatible\n-    /// with `expected_ty`.\n+    /// with some expectation given by `source`.\n     pub fn note_source_of_type_mismatch_constraint(\n         &self,\n         err: &mut Diagnostic,\n@@ -265,7 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         use rustc_infer::infer::type_variable::*;\n         use rustc_middle::infer::unify_key::*;\n-\n+        // Replaces all of the variables in the given type with a fresh inference variable.\n         let mut fudger = BottomUpFolder {\n             tcx: self.tcx,\n             ty_op: |ty| {\n@@ -301,7 +301,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let expected_ty = match source {\n             TypeMismatchSource::Ty(expected_ty) => expected_ty,\n-            TypeMismatchSource::Arg(call_expr, idx) => {\n+            // Try to deduce what the possible value of `expr` would be if the\n+            // incompatible arg were compatible. For example, given `Vec<i32>`\n+            // and `vec.push(1u32)`, we ideally want to deduce that the type of\n+            // `vec` *should* have been `Vec<u32>`. This will allow us to then\n+            // run the subsequent code with this expectation, finding out exactly\n+            // when this type diverged from our expectation.\n+            TypeMismatchSource::Arg { call_expr, incompatible_arg: idx } => {\n                 let hir::ExprKind::MethodCall(segment, _, args, _) = call_expr.kind else {\n                     return false;\n                 };\n@@ -310,6 +316,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 let possible_rcvr_ty = expr_finder.uses.iter().find_map(|binding| {\n                     let possible_rcvr_ty = self.node_ty_opt(binding.hir_id)?;\n+                    // Fudge the receiver, so we can do new inference on it.\n                     let possible_rcvr_ty = possible_rcvr_ty.fold_with(&mut fudger);\n                     let method = self\n                         .lookup_method(\n@@ -321,6 +328,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             args,\n                         )\n                         .ok()?;\n+                    // Unify the method signature with our incompatible arg, to\n+                    // do inference in the *opposite* direction and to find out\n+                    // what our ideal rcvr ty would look like.\n                     let _ = self\n                         .at(&ObligationCause::dummy(), self.param_env)\n                         .eq(DefineOpaqueTypes::No, method.sig.inputs()[idx + 1], arg_ty)\n@@ -339,11 +349,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n+        // If our expected_ty does not equal init_ty, then it *began* as incompatible.\n+        // No need to note in this case...\n         if !self.can_eq(self.param_env, expected_ty, init_ty.fold_with(&mut fudger)) {\n             return false;\n         }\n \n         for window in expr_finder.uses.windows(2) {\n+            // Bindings always update their recorded type after the fact, so we\n+            // need to look at the *following* usage's type to see when the\n+            // binding became incompatible.\n             let [binding, next_usage] = *window else { continue; };\n \n             // Don't go past the binding (always gonna be a nonsense label if so)\n@@ -363,6 +378,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 && let hir::ExprKind::MethodCall(segment, rcvr, args, _) = parent_expr.kind\n                 && rcvr.hir_id == binding.hir_id\n             {\n+                // If our binding became incompatible while it was a receiver\n+                // to a method call, we may be able to make a better guess to\n+                // the source of a type mismatch.\n                 let Some(rcvr_ty) = self.node_ty_opt(rcvr.hir_id) else { continue; };\n                 let rcvr_ty = rcvr_ty.fold_with(&mut fudger);\n                 let Ok(method) =\n@@ -371,14 +389,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     continue;\n                 };\n \n-                // NOTE: For future removers of `fudge_inference_if_ok`, you\n-                // can replace  this with another call to `lookup_method` but\n-                // using `expected_ty` as the rcvr.\n-                let ideal_method_sig: Result<_, TypeError<'tcx>> = self.fudge_inference_if_ok(|| {\n-                    let _ = self.at(&ObligationCause::dummy(), self.param_env).eq(rcvr_ty, expected_ty)?;\n-                    Ok(method.sig)\n-                });\n+                let ideal_rcvr_ty = rcvr_ty.fold_with(&mut fudger);\n+                let ideal_method = self\n+                    .lookup_method(ideal_rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr, args)\n+                    .ok()\n+                    .and_then(|method| {\n+                        let _ = self.at(&ObligationCause::dummy(), self.param_env)\n+                            .eq(DefineOpaqueTypes::No, ideal_rcvr_ty, expected_ty)\n+                            .ok()?;\n+                        Some(method)\n+                    });\n \n+                // Find what argument caused our rcvr to become incompatible\n+                // with the expected ty.\n                 for (idx, (expected_arg_ty, arg_expr)) in\n                     std::iter::zip(&method.sig.inputs()[1..], args).enumerate()\n                 {\n@@ -391,35 +414,40 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         AllowTwoPhase::No,\n                         None,\n                     );\n+                    self.select_obligations_where_possible(|errs| {\n+                        // Yeet the errors, we're already reporting errors.\n+                        errs.clear();\n+                    });\n+                    // If our rcvr, after inference due to unifying the signature\n+                    // with the expected argument type, is still compatible with\n+                    // the rcvr, then it must've not been the source of blame.\n                     if self.can_eq(self.param_env, rcvr_ty, expected_ty) {\n                         continue;\n                     }\n-                    err.span_label(\n-                        arg_expr.span,\n-                        format!(\"this argument has type `{arg_ty}`...\"),\n-                    );\n+                    err.span_label(arg_expr.span, format!(\"this argument has type `{arg_ty}`...\"));\n                     err.span_label(\n                         binding.span,\n-                        format!(\n-                            \"... which constrains `{ident}` to have type `{next_use_ty}`\"\n-                        ),\n+                        format!(\"... which causes `{ident}` to have type `{next_use_ty}`\"),\n                     );\n+                    // Using our \"ideal\" method signature, suggest a fix to this\n+                    // blame arg, if possible. Don't do this if we're coming from\n+                    // arg mismatch code, because we'll possibly suggest a mutually\n+                    // incompatible fix at the original mismatch site.\n                     if matches!(source, TypeMismatchSource::Ty(_))\n-                        && let Ok(ideal_method_sig) = ideal_method_sig\n+                        && let Some(ideal_method) = ideal_method\n                     {\n                         self.emit_type_mismatch_suggestions(\n                             err,\n                             arg_expr,\n                             arg_ty,\n-                            ideal_method_sig.inputs()[idx + 1],\n+                            self.resolve_vars_if_possible(ideal_method.sig.inputs()[idx + 1]),\n                             None,\n                             None,\n                         );\n                     }\n                     return true;\n                 }\n             }\n-\n             err.span_label(\n                 binding.span,\n                 format!(\"here the type of `{ident}` is inferred to be `{next_use_ty}`\"),\n@@ -2092,6 +2120,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n pub enum TypeMismatchSource<'tcx> {\n+    /// Expected the binding to have the given type, but it was found to have\n+    /// a different type. Find out when that type first became incompatible.\n     Ty(Ty<'tcx>),\n-    Arg(&'tcx hir::Expr<'tcx>, usize),\n+    /// When we fail during method argument checking, try to find out if a previous\n+    /// expression has constrained the method's receiver in a way that makes the\n+    /// argument's type incompatible.\n+    Arg { call_expr: &'tcx hir::Expr<'tcx>, incompatible_arg: usize },\n }"}, {"sha": "ea1b52daaa5e59b368422b93678b1bd40a7079d8", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cc475742151cd458091ca3c67598ddece3ee39b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc475742151cd458091ca3c67598ddece3ee39b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=5cc475742151cd458091ca3c67598ddece3ee39b", "patch": "@@ -814,7 +814,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.note_source_of_type_mismatch_constraint(\n                     &mut err,\n                     rcvr,\n-                    crate::demand::TypeMismatchSource::Arg(call_expr, provided_idx.as_usize()),\n+                    crate::demand::TypeMismatchSource::Arg {\n+                        call_expr,\n+                        incompatible_arg: provided_idx.as_usize(),\n+                    },\n                 );\n             }\n "}, {"sha": "3deb234c2751e308bd2f877eda759e745e2bba21", "filename": "tests/ui/type/type-check/point-at-inference-4.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5cc475742151cd458091ca3c67598ddece3ee39b/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc475742151cd458091ca3c67598ddece3ee39b/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs?ref=5cc475742151cd458091ca3c67598ddece3ee39b", "patch": "@@ -11,9 +11,11 @@ fn main() {\n     let s = S(None);\n     s.infer(0i32);\n     //~^ ERROR this method takes 2 arguments but 1 argument was supplied\n-    //~| NOTE here the type of `s` is inferred to be `S<i32, _>`\n+    //~| NOTE this argument has type `i32`...\n+    //~| NOTE ... which causes `s` to have type `S<i32, _>`\n     //~| NOTE an argument is missing\n     //~| HELP provide the argument\n+    //~| HELP change the type of the numeric literal from `i32` to `u32`\n     let t: S<u32, _> = s;\n     //~^ ERROR mismatched types\n     //~| NOTE expected `S<u32, _>`, found `S<i32, _>`"}, {"sha": "5f7bb8b9367ec6d256fb523bb059b95ac7071ce5", "filename": "tests/ui/type/type-check/point-at-inference-4.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5cc475742151cd458091ca3c67598ddece3ee39b/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5cc475742151cd458091ca3c67598ddece3ee39b/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr?ref=5cc475742151cd458091ca3c67598ddece3ee39b", "patch": "@@ -15,10 +15,12 @@ LL |     s.infer(0i32, /* b */);\n    |            ~~~~~~~~~~~~~~~\n \n error[E0308]: mismatched types\n-  --> $DIR/point-at-inference-4.rs:17:24\n+  --> $DIR/point-at-inference-4.rs:19:24\n    |\n LL |     s.infer(0i32);\n-   |     - here the type of `s` is inferred to be `S<i32, _>`\n+   |     -       ---- this argument has type `i32`...\n+   |     |\n+   |     ... which causes `s` to have type `S<i32, _>`\n ...\n LL |     let t: S<u32, _> = s;\n    |            ---------   ^ expected `S<u32, _>`, found `S<i32, _>`\n@@ -27,6 +29,10 @@ LL |     let t: S<u32, _> = s;\n    |\n    = note: expected struct `S<u32, _>`\n               found struct `S<i32, _>`\n+help: change the type of the numeric literal from `i32` to `u32`\n+   |\n+LL |     s.infer(0u32);\n+   |              ~~~\n \n error: aborting due to 2 previous errors\n "}]}