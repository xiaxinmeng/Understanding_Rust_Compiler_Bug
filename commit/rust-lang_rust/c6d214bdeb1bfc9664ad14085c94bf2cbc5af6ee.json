{"sha": "c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZDIxNGJkZWIxYmZjOTY2NGFkMTQwODVjOTRiZjJjYmM1YWY2ZWU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T19:55:19Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T16:19:50Z"}, "message": "trans: Revamp and empower cabi::FnType.", "tree": {"sha": "0ae2ea287d1e8e8659e30ba1b8595735e224c160", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ae2ea287d1e8e8659e30ba1b8595735e224c160"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "html_url": "https://github.com/rust-lang/rust/commit/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9221b9118b96d668e2cf5d701b10c0566aa072e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9221b9118b96d668e2cf5d701b10c0566aa072e9", "html_url": "https://github.com/rust-lang/rust/commit/9221b9118b96d668e2cf5d701b10c0566aa072e9"}], "stats": {"total": 849, "additions": 318, "deletions": 531}, "files": [{"sha": "5325c667eb683b3f0e0603a1c8ec2455e0eb4b37", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 173, "deletions": 36, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -10,8 +10,9 @@\n \n pub use self::ArgKind::*;\n \n-use llvm::Attribute;\n-use std::option;\n+use llvm::{self, AttrHelper, ValueRef};\n+use trans::attributes;\n+use trans::common::return_type_is_void;\n use trans::context::CrateContext;\n use trans::cabi_x86;\n use trans::cabi_x86_64;\n@@ -23,6 +24,11 @@ use trans::cabi_powerpc64;\n use trans::cabi_mips;\n use trans::cabi_asmjs;\n use trans::type_::Type;\n+use trans::type_of;\n+\n+use middle::ty::{self, Ty};\n+\n+use syntax::abi::Abi;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum ArgKind {\n@@ -45,17 +51,17 @@ pub struct ArgType {\n     /// Original LLVM type\n     pub ty: Type,\n     /// Coerced LLVM Type\n-    pub cast: option::Option<Type>,\n+    pub cast: Option<Type>,\n     /// Dummy argument, which is emitted before the real argument\n-    pub pad: option::Option<Type>,\n+    pub pad: Option<Type>,\n     /// LLVM attribute of argument\n-    pub attr: option::Option<Attribute>\n+    pub attr: Option<llvm::Attribute>\n }\n \n impl ArgType {\n-    pub fn direct(ty: Type, cast: option::Option<Type>,\n-                            pad: option::Option<Type>,\n-                            attr: option::Option<Attribute>) -> ArgType {\n+    pub fn direct(ty: Type, cast: Option<Type>,\n+                            pad: Option<Type>,\n+                            attr: Option<llvm::Attribute>) -> ArgType {\n         ArgType {\n             kind: Direct,\n             ty: ty,\n@@ -65,12 +71,12 @@ impl ArgType {\n         }\n     }\n \n-    pub fn indirect(ty: Type, attr: option::Option<Attribute>) -> ArgType {\n+    pub fn indirect(ty: Type, attr: Option<llvm::Attribute>) -> ArgType {\n         ArgType {\n             kind: Indirect,\n             ty: ty,\n-            cast: option::Option::None,\n-            pad: option::Option::None,\n+            cast: Option::None,\n+            pad: Option::None,\n             attr: attr\n         }\n     }\n@@ -94,44 +100,175 @@ impl ArgType {\n     }\n }\n \n+fn c_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n+    if ty.is_bool() {\n+        Type::i1(cx)\n+    } else {\n+        type_of::type_of(cx, ty)\n+    }\n+}\n+\n /// Metadata describing how the arguments to a native function\n /// should be passed in order to respect the native ABI.\n ///\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n pub struct FnType {\n     /// The LLVM types of each argument.\n-    pub arg_tys: Vec<ArgType> ,\n+    pub args: Vec<ArgType>,\n \n     /// LLVM return type.\n-    pub ret_ty: ArgType,\n+    pub ret: ArgType,\n+\n+    pub variadic: bool,\n+\n+    pub cconv: llvm::CallConv\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    match &ccx.sess().target.target.arch[..] {\n-        \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n-        \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n-            cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n+impl FnType {\n+    pub fn new<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                         abi: Abi,\n+                         sig: &ty::FnSig<'tcx>,\n+                         extra_args: &[Ty<'tcx>]) -> FnType {\n+        use syntax::abi::Abi::*;\n+        let cconv = match ccx.sess().target.target.adjust_abi(abi) {\n+            RustIntrinsic => {\n+                // Intrinsics are emitted at the call site\n+                ccx.sess().bug(\"asked to register intrinsic fn\");\n+            }\n+            PlatformIntrinsic => {\n+                // Intrinsics are emitted at the call site\n+                ccx.sess().bug(\"asked to register platform intrinsic fn\");\n+            }\n+\n+            Rust => {\n+                // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n+                ccx.sess().unimpl(\"foreign functions with Rust ABI\");\n+            }\n+\n+            RustCall => {\n+                // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n+                ccx.sess().unimpl(\"foreign functions with RustCall ABI\");\n+            }\n+\n+            // It's the ABI's job to select this, not us.\n+            System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n+\n+            Stdcall => llvm::X86StdcallCallConv,\n+            Fastcall => llvm::X86FastcallCallConv,\n+            Vectorcall => llvm::X86_VectorCall,\n+            C => llvm::CCallConv,\n+            Win64 => llvm::X86_64_Win64,\n+\n+            // These API constants ought to be more specific...\n+            Cdecl => llvm::CCallConv,\n+            Aapcs => llvm::CCallConv,\n+        };\n+\n+        let rty = match sig.output {\n+            ty::FnConverging(ret_ty) if !return_type_is_void(ccx, ret_ty) => {\n+                c_type_of(ccx, ret_ty)\n+            }\n+            _ => Type::void(ccx)\n+        };\n+\n+        let mut fty = FnType {\n+            args: sig.inputs.iter().chain(extra_args.iter()).map(|&ty| {\n+                ArgType::direct(c_type_of(ccx, ty), None, None, None)\n+            }).collect(),\n+            ret: ArgType::direct(rty, None, None, None),\n+            variadic: sig.variadic,\n+            cconv: cconv\n+        };\n+\n+        match &ccx.sess().target.target.arch[..] {\n+            \"x86\" => cabi_x86::compute_abi_info(ccx, &mut fty),\n+            \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n+                cabi_x86_win64::compute_abi_info(ccx, &mut fty);\n+            } else {\n+                cabi_x86_64::compute_abi_info(ccx, &mut fty);\n+            },\n+            \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, &mut fty),\n+            \"arm\" => {\n+                let flavor = if ccx.sess().target.target.target_os == \"ios\" {\n+                    cabi_arm::Flavor::Ios\n+                } else {\n+                    cabi_arm::Flavor::General\n+                };\n+                cabi_arm::compute_abi_info(ccx, &mut fty, flavor);\n+            },\n+            \"mips\" => cabi_mips::compute_abi_info(ccx, &mut fty),\n+            \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, &mut fty),\n+            \"powerpc64\" => cabi_powerpc64::compute_abi_info(ccx, &mut fty),\n+            \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, &mut fty),\n+            a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n+        }\n+\n+        fty\n+    }\n+\n+    pub fn to_llvm(&self, ccx: &CrateContext) -> Type {\n+        let mut llargument_tys = Vec::new();\n+\n+        let llreturn_ty = if self.ret.is_indirect() {\n+            llargument_tys.push(self.ret.ty.ptr_to());\n+            Type::void(ccx)\n         } else {\n-            cabi_x86_64::compute_abi_info(ccx, atys, rty, ret_def)\n-        },\n-        \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, atys, rty, ret_def),\n-        \"arm\" => {\n-            let flavor = if ccx.sess().target.target.target_os == \"ios\" {\n-                cabi_arm::Flavor::Ios\n+            self.ret.cast.unwrap_or(self.ret.ty)\n+        };\n+\n+        for arg in &self.args {\n+            if arg.is_ignore() {\n+                continue;\n+            }\n+            // add padding\n+            if let Some(ty) = arg.pad {\n+                llargument_tys.push(ty);\n+            }\n+\n+            let llarg_ty = if arg.is_indirect() {\n+                arg.ty.ptr_to()\n             } else {\n-                cabi_arm::Flavor::General\n+                arg.cast.unwrap_or(arg.ty)\n             };\n-            cabi_arm::compute_abi_info(ccx, atys, rty, ret_def, flavor)\n-        },\n-        \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n-        \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, atys, rty, ret_def),\n-        \"powerpc64\" => cabi_powerpc64::compute_abi_info(ccx, atys, rty, ret_def),\n-        \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, atys, rty, ret_def),\n-        a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)\n-                              ),\n+\n+            llargument_tys.push(llarg_ty);\n+        }\n+\n+        if self.variadic {\n+            Type::variadic_func(&llargument_tys, &llreturn_ty)\n+        } else {\n+            Type::func(&llargument_tys, &llreturn_ty)\n+        }\n+    }\n+\n+    pub fn add_attributes(&self, llfn: ValueRef) {\n+        let mut i = if self.ret.is_indirect() {\n+            1\n+        } else {\n+            0\n+        };\n+\n+        if let Some(attr) = self.ret.attr {\n+            attr.apply_llfn(i, llfn);\n+        }\n+\n+        i += 1;\n+\n+        for arg in &self.args {\n+            if arg.is_ignore() {\n+                continue;\n+            }\n+            // skip padding\n+            if arg.pad.is_some() { i += 1; }\n+\n+            if let Some(attr) = arg.attr {\n+                attr.apply_llfn(i, llfn);\n+            }\n+\n+            i += 1;\n+        }\n+\n+        attributes::unwind(llfn, false);\n     }\n }"}, {"sha": "745cc3ba6d6f55c9ca93d5913382695a4decc7f4", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -228,24 +228,12 @@ fn is_reg_ty(ty: Type) -> bool {\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let mut arg_tys = Vec::new();\n-    for &aty in atys {\n-        let ty = classify_arg_ty(ccx, aty);\n-        arg_tys.push(ty);\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if fty.ret.ty != Type::void(ccx) {\n+        fty.ret = classify_ret_ty(ccx, fty.ret.ty);\n     }\n \n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    for arg in &mut fty.args {\n+        *arg = classify_arg_ty(ccx, arg.ty);\n+    }\n }"}, {"sha": "c65fb588e7218d2572b3e040c747bfaac3051a06", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -174,30 +174,17 @@ fn is_reg_ty(ty: Type) -> bool {\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool,\n-                        flavor: Flavor) -> FnType {\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n     let align_fn = match flavor {\n         Flavor::General => general_ty_align as TyAlignFn,\n         Flavor::Ios => ios_ty_align as TyAlignFn,\n     };\n \n-    let mut arg_tys = Vec::new();\n-    for &aty in atys {\n-        let ty = classify_arg_ty(ccx, aty, align_fn);\n-        arg_tys.push(ty);\n+    if fty.ret.ty != Type::void(ccx) {\n+        fty.ret = classify_ret_ty(ccx, fty.ret.ty, align_fn);\n     }\n \n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty, align_fn)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    for arg in &mut fty.args {\n+        *arg = classify_arg_ty(ccx, arg.ty, align_fn);\n+    }\n }"}, {"sha": "dd62194a892a70888d7fdb5b5cc88aa4f33f8e83", "filename": "src/librustc_trans/trans/cabi_asmjs.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -49,24 +49,12 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let mut arg_tys = Vec::new();\n-    for &aty in atys {\n-        let ty = classify_arg_ty(ccx, aty);\n-        arg_tys.push(ty);\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if fty.ret.ty != Type::void(ccx) {\n+        fty.ret = classify_ret_ty(ccx, fty.ret.ty);\n     }\n \n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    for arg in &mut fty.args {\n+        *arg = classify_arg_ty(ccx, arg.ty);\n+    }\n }"}, {"sha": "74fdc0828f203fa93a185bd4993ae692284bdccb", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -161,27 +161,13 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n     Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    let sret = ret_ty.is_indirect();\n-    let mut arg_tys = Vec::new();\n-    let mut offset = if sret { 4 } else { 0 };\n-\n-    for aty in atys {\n-        let ty = classify_arg_ty(ccx, *aty, &mut offset);\n-        arg_tys.push(ty);\n-    };\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if fty.ret.ty != Type::void(ccx) {\n+        fty.ret = classify_ret_ty(ccx, fty.ret.ty);\n+    }\n \n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n+    for arg in &mut fty.args {\n+        *arg = classify_arg_ty(ccx, arg.ty, &mut offset);\n+    }\n }"}, {"sha": "57d49926fae5d2fc8f8edfd1b88c33a5c853e666", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -156,27 +156,13 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n     Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    let sret = ret_ty.is_indirect();\n-    let mut arg_tys = Vec::new();\n-    let mut offset = if sret { 4 } else { 0 };\n-\n-    for aty in atys {\n-        let ty = classify_arg_ty(ccx, *aty, &mut offset);\n-        arg_tys.push(ty);\n-    };\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if fty.ret.ty != Type::void(ccx) {\n+        fty.ret = classify_ret_ty(ccx, fty.ret.ty);\n+    }\n \n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n+    for arg in &mut fty.args {\n+        *arg = classify_arg_ty(ccx, arg.ty, &mut offset);\n+    }\n }"}, {"sha": "dd50b1164517d206c614f8c0871f716ddb03d970", "filename": "src/librustc_trans/trans/cabi_powerpc64.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -236,24 +236,12 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n     Type::struct_(ccx, &coerce_to_long(ccx, size), false)\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    let mut arg_tys = Vec::new();\n-    for &aty in atys {\n-        let ty = classify_arg_ty(ccx, aty);\n-        arg_tys.push(ty);\n-    };\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if fty.ret.ty != Type::void(ccx) {\n+        fty.ret = classify_ret_ty(ccx, fty.ret.ty);\n+    }\n \n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    for arg in &mut fty.args {\n+        *arg = classify_arg_ty(ccx, arg.ty);\n+    }\n }"}, {"sha": "81fb9d71210d861cbaaa4d1dd07705ff8572db86", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 23, "deletions": 53, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -8,78 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::Strategy::*;\n use llvm::*;\n use trans::cabi::{ArgType, FnType};\n use trans::type_::Type;\n use super::common::*;\n use super::machine::*;\n \n-enum Strategy { RetValue(Type), RetPointer }\n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let mut arg_tys = Vec::new();\n-\n-    let ret_ty;\n-    if !ret_def {\n-        ret_ty = ArgType::direct(Type::void(ccx), None, None, None);\n-    } else if rty.kind() == Struct {\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if fty.ret.ty.kind() == Struct {\n         // Returning a structure. Most often, this will use\n         // a hidden first argument. On some platforms, though,\n         // small structs are returned as integers.\n         //\n         // Some links:\n         // http://www.angelcode.com/dev/callconv/callconv.html\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n+        let indirect = ArgType::indirect(fty.ret.ty, Some(Attribute::StructRet));\n \n         let t = &ccx.sess().target.target;\n-        let strategy = if t.options.is_like_osx || t.options.is_like_windows {\n-            match llsize_of_alloc(ccx, rty) {\n-                1 => RetValue(Type::i8(ccx)),\n-                2 => RetValue(Type::i16(ccx)),\n-                4 => RetValue(Type::i32(ccx)),\n-                8 => RetValue(Type::i64(ccx)),\n-                _ => RetPointer\n+        if t.options.is_like_osx || t.options.is_like_windows {\n+            match llsize_of_alloc(ccx, fty.ret.ty) {\n+                1 => fty.ret.cast = Some(Type::i8(ccx)),\n+                2 => fty.ret.cast = Some(Type::i16(ccx)),\n+                4 => fty.ret.cast = Some(Type::i32(ccx)),\n+                8 => fty.ret.cast = Some(Type::i64(ccx)),\n+                _ => fty.ret = indirect\n             }\n         } else {\n-            RetPointer\n-        };\n-\n-        match strategy {\n-            RetValue(t) => {\n-                ret_ty = ArgType::direct(rty, Some(t), None, None);\n-            }\n-            RetPointer => {\n-                ret_ty = ArgType::indirect(rty, Some(Attribute::StructRet));\n-            }\n+            fty.ret = indirect;\n         }\n-    } else {\n-        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ret_ty = ArgType::direct(rty, None, None, attr);\n+    } else if fty.ret.ty == Type::i1(ccx) {\n+        fty.ret.attr = Some(Attribute::ZExt);\n     }\n \n-    for &t in atys {\n-        let ty = match t.kind() {\n-            Struct => {\n-                let size = llsize_of_alloc(ccx, t);\n-                if size == 0 {\n-                    ArgType::ignore(t)\n-                } else {\n-                    ArgType::indirect(t, Some(Attribute::ByVal))\n-                }\n-            }\n-            _ => {\n-                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-                ArgType::direct(t, None, None, attr)\n-            }\n-        };\n-        arg_tys.push(ty);\n+    for arg in &mut fty.args {\n+        if arg.ty.kind() == Struct {\n+            *arg = if llsize_of_alloc(ccx, arg.ty) == 0 {\n+                ArgType::ignore(arg.ty)\n+            } else {\n+                ArgType::indirect(arg.ty, Some(Attribute::ByVal))\n+            };\n+        } else if arg.ty == Type::i1(ccx) {\n+            arg.attr = Some(Attribute::ZExt);\n+        }\n     }\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n }"}, {"sha": "5946aa4a8c3668bfbae737eccd5a1d8f5d2785a3", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -383,10 +383,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     fn x86_64_ty<F>(ccx: &CrateContext,\n                     ty: Type,\n                     is_mem_cls: F,\n@@ -413,23 +410,20 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n     let mut sse_regs = 8; // XMM0-7\n \n-    let ret_ty = if ret_def {\n-        x86_64_ty(ccx, rty, |cls| {\n+    if fty.ret.ty != Type::void(ccx) {\n+        fty.ret = x86_64_ty(ccx, fty.ret.ty, |cls| {\n             if cls.is_ret_bysret() {\n                 // `sret` parameter thus one less register available\n                 int_regs -= 1;\n                 true\n             } else {\n                 false\n             }\n-        }, Attribute::StructRet)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n+        }, Attribute::StructRet);\n+    }\n \n-    let mut arg_tys = Vec::new();\n-    for t in atys {\n-        let ty = x86_64_ty(ccx, *t, |cls| {\n+    for arg in &mut fty.args {\n+        *arg = x86_64_ty(ccx, arg.ty, |cls| {\n             let needed_int = cls.iter().filter(|&&c| c == Int).count() as isize;\n             let needed_sse = cls.iter().filter(|c| c.is_sse()).count() as isize;\n             let in_mem = cls.is_pass_byval() ||\n@@ -445,20 +439,14 @@ pub fn compute_abi_info(ccx: &CrateContext,\n             }\n             in_mem\n         }, Attribute::ByVal);\n-        arg_tys.push(ty);\n \n         // An integer, pointer, double or float parameter\n         // thus the above closure passed to `x86_64_ty` won't\n         // get called.\n-        if t.kind() == Integer || t.kind() == Pointer {\n-            int_regs -= 1;\n-        } else if t.kind() == Double || t.kind() == Float {\n-            sse_regs -= 1;\n+        match arg.ty.kind() {\n+            Integer | Pointer => int_regs -= 1,\n+            Double | Float => sse_regs -= 1,\n+            _ => {}\n         }\n     }\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n }"}, {"sha": "21c746a1e88967729b904e084223727317dc70f7", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 17, "deletions": 43, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -16,49 +16,23 @@ use trans::type_::Type;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                          atys: &[Type],\n-                          rty: Type,\n-                          ret_def: bool) -> FnType {\n-    let mut arg_tys = Vec::new();\n-\n-    let ret_ty;\n-    if !ret_def {\n-        ret_ty = ArgType::direct(Type::void(ccx), None, None, None);\n-    } else if rty.kind() == Struct {\n-        ret_ty = match llsize_of_alloc(ccx, rty) {\n-            1 => ArgType::direct(rty, Some(Type::i8(ccx)), None, None),\n-            2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n-            4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n-            8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-            _ => ArgType::indirect(rty, Some(Attribute::StructRet))\n-        };\n-    } else {\n-        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ret_ty = ArgType::direct(rty, None, None, attr);\n-    }\n-\n-    for &t in atys {\n-        let ty = match t.kind() {\n-            Struct => {\n-                match llsize_of_alloc(ccx, t) {\n-                    1 => ArgType::direct(t, Some(Type::i8(ccx)), None, None),\n-                    2 => ArgType::direct(t, Some(Type::i16(ccx)), None, None),\n-                    4 => ArgType::direct(t, Some(Type::i32(ccx)), None, None),\n-                    8 => ArgType::direct(t, Some(Type::i64(ccx)), None, None),\n-                    _ => ArgType::indirect(t, None)\n-                }\n-            }\n-            _ => {\n-                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-                ArgType::direct(t, None, None, attr)\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    let fixup = |a: &mut ArgType, indirect_attr| {\n+        if a.ty.kind() == Struct {\n+            match llsize_of_alloc(ccx, a.ty) {\n+                1 => a.cast = Some(Type::i8(ccx)),\n+                2 => a.cast = Some(Type::i16(ccx)),\n+                4 => a.cast = Some(Type::i32(ccx)),\n+                8 => a.cast = Some(Type::i64(ccx)),\n+                _ => *a = ArgType::indirect(a.ty, indirect_attr)\n             }\n-        };\n-        arg_tys.push(ty);\n-    }\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n+        } else if a.ty == Type::i1(ccx) {\n+            a.attr = Some(Attribute::ZExt);\n+        }\n     };\n+\n+    fixup(&mut fty.ret, Some(Attribute::StructRet));\n+    for arg in &mut fty.args {\n+        fixup(arg, None);\n+    }\n }"}, {"sha": "99df9c181856c7103111e7f03f352c4f685460a1", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 49, "deletions": 246, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -17,7 +17,7 @@ use trans::attributes;\n use trans::base::{llvm_linkage_by_name, push_ctxt};\n use trans::base;\n use trans::build::*;\n-use trans::cabi;\n+use trans::cabi::FnType;\n use trans::common::*;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n@@ -45,83 +45,15 @@ use syntax::attr::AttrMetaMethods;\n use rustc_front::print::pprust;\n use rustc_front::hir;\n \n-///////////////////////////////////////////////////////////////////////////\n-// Type definitions\n-\n-struct ForeignTypes<'tcx> {\n-    /// Rust signature of the function\n-    fn_sig: ty::FnSig<'tcx>,\n-\n-    /// Adapter object for handling native ABI rules (trust me, you\n-    /// don't want to know)\n-    fn_ty: cabi::FnType,\n-\n-    /// LLVM types that will appear on the foreign function\n-    llsig: LlvmSignature,\n-}\n-\n-struct LlvmSignature {\n-    // LLVM versions of the types of this function's arguments.\n-    llarg_tys: Vec<Type> ,\n-\n-    // LLVM version of the type that this function returns.  Note that\n-    // this *may not be* the declared return type of the foreign\n-    // function, because the foreign function may opt to return via an\n-    // out pointer.\n-    llret_ty: Type,\n-\n-    /// True if there is a return value (not bottom, not unit)\n-    ret_def: bool,\n-}\n-\n-\n ///////////////////////////////////////////////////////////////////////////\n // Calls to external functions\n \n-pub fn llvm_calling_convention(ccx: &CrateContext,\n-                               abi: Abi) -> CallConv {\n-    use syntax::abi::Abi::*;\n-    match ccx.sess().target.target.adjust_abi(abi) {\n-        RustIntrinsic => {\n-            // Intrinsics are emitted at the call site\n-            ccx.sess().bug(\"asked to register intrinsic fn\");\n-        }\n-        PlatformIntrinsic => {\n-            // Intrinsics are emitted at the call site\n-            ccx.sess().bug(\"asked to register platform intrinsic fn\");\n-        }\n-\n-        Rust => {\n-            // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-            ccx.sess().unimpl(\"foreign functions with Rust ABI\");\n-        }\n-\n-        RustCall => {\n-            // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-            ccx.sess().unimpl(\"foreign functions with RustCall ABI\");\n-        }\n-\n-        // It's the ABI's job to select this, not us.\n-        System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n-\n-        Stdcall => llvm::X86StdcallCallConv,\n-        Fastcall => llvm::X86FastcallCallConv,\n-        Vectorcall => llvm::X86_VectorCall,\n-        C => llvm::CCallConv,\n-        Win64 => llvm::X86_64_Win64,\n-\n-        // These API constants ought to be more specific...\n-        Cdecl => llvm::CCallConv,\n-        Aapcs => llvm::CCallConv,\n-    }\n-}\n-\n pub fn register_static(ccx: &CrateContext,\n                        foreign_item: &hir::ForeignItem) -> ValueRef {\n     let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n     let llty = type_of::type_of(ccx, ty);\n \n-    let ident = link_name(foreign_item);\n+    let ident = link_name(foreign_item.name, &foreign_item.attrs);\n     let c = match attr::first_attr_value_str_by_name(&foreign_item.attrs,\n                                                      \"linkage\") {\n         // If this is a static with a linkage specified, then we need to handle\n@@ -265,22 +197,18 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n     let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n     let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n-    let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[..]);\n-    let fn_type = cabi::compute_abi_info(ccx,\n-                                         &llsig.llarg_tys,\n-                                         llsig.llret_ty,\n-                                         llsig.ret_def);\n \n-    let arg_tys: &[cabi::ArgType] = &fn_type.arg_tys;\n+    let extra_args = &passed_arg_tys[fn_sig.inputs.len()..];\n+    let fn_type = FnType::new(ccx, fn_abi, &fn_sig, extra_args);\n \n     let mut llargs_foreign = Vec::new();\n \n     // If the foreign ABI expects return value by pointer, supply the\n     // pointer that Rust gave us. Sometimes we have to bitcast\n     // because foreign fns return slightly different (but equivalent)\n     // views on the same type (e.g., i64 in place of {i32,i32}).\n-    if fn_type.ret_ty.is_indirect() {\n-        match fn_type.ret_ty.cast {\n+    if fn_type.ret.is_indirect() {\n+        match fn_type.ret.cast {\n             Some(ty) => {\n                 let llcastedretptr =\n                     BitCast(bcx, llretptr, ty.ptr_to());\n@@ -293,7 +221,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let mut offset = 0;\n-    for (i, arg_ty) in arg_tys.iter().enumerate() {\n+    for (i, arg_ty) in fn_type.args.iter().enumerate() {\n         let mut llarg_rust = llargs_rust[i + offset];\n \n         if arg_ty.is_ignore() {\n@@ -359,15 +287,13 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         llargs_foreign.push(llarg_foreign);\n     }\n \n-    let cc = llvm_calling_convention(ccx, fn_abi);\n-\n     // A function pointer is called without the declaration available, so we have to apply\n     // any attributes with ABI implications directly to the call instruction.\n     let mut attrs = llvm::AttrBuilder::new();\n \n     // Add attributes that are always applicable, independent of the concrete foreign ABI\n-    if fn_type.ret_ty.is_indirect() {\n-        let llret_sz = machine::llsize_of_real(ccx, fn_type.ret_ty.ty);\n+    if fn_type.ret.is_indirect() {\n+        let llret_sz = machine::llsize_of_real(ccx, fn_type.ret.ty);\n \n         // The outptr can be noalias and nocapture because it's entirely\n         // invisible to the program. We also know it's nonnull as well\n@@ -378,14 +304,14 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     // Add attributes that depend on the concrete foreign ABI\n-    let mut arg_idx = if fn_type.ret_ty.is_indirect() { 1 } else { 0 };\n-    match fn_type.ret_ty.attr {\n+    let mut arg_idx = if fn_type.ret.is_indirect() { 1 } else { 0 };\n+    match fn_type.ret.attr {\n         Some(attr) => { attrs.arg(arg_idx, attr); },\n         _ => ()\n     }\n \n     arg_idx += 1;\n-    for arg_ty in &fn_type.arg_tys {\n+    for arg_ty in &fn_type.args {\n         if arg_ty.is_ignore() {\n             continue;\n         }\n@@ -402,7 +328,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n                                         &llargs_foreign[..],\n-                                        cc,\n+                                        fn_type.cconv,\n                                         Some(attrs),\n                                         call_debug_loc);\n \n@@ -411,11 +337,11 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // type to match because some ABIs will use a different type than\n     // the Rust type. e.g., a {u32,u32} struct could be returned as\n     // u64.\n-    if llsig.ret_def && !fn_type.ret_ty.is_indirect() {\n-        let llrust_ret_ty = llsig.llret_ty;\n-        let llforeign_ret_ty = match fn_type.ret_ty.cast {\n+    if fn_type.ret.ty != Type::void(ccx) && !fn_type.ret.is_indirect() {\n+        let llrust_ret_ty = fn_type.ret.ty;\n+        let llforeign_ret_ty = match fn_type.ret.cast {\n             Some(ty) => ty,\n-            None => fn_type.ret_ty.ty\n+            None => fn_type.ret.ty\n         };\n \n         debug!(\"llretptr={:?}\", Value(llretptr));\n@@ -543,14 +469,20 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let fnty = ccx.tcx().node_id_to_type(id);\n     let mty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fnty);\n-    let tys = foreign_types_for_fn_ty(ccx, mty);\n+    let (fn_abi, fn_sig) = match mty.sty {\n+        ty::TyFnDef(_, _, ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n+        _ => ccx.sess().bug(\"trans_rust_fn_with_foreign_abi called on non-function type\")\n+    };\n+    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n+    let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n+    let fn_ty = FnType::new(ccx, fn_abi, &fn_sig, &[]);\n \n     unsafe { // unsafe because we call LLVM operations\n         // Build up the Rust function (`foo0` above).\n         let llrustfn = build_rust_fn(ccx, decl, body, param_substs, attrs, id, hash);\n \n         // Build up the foreign wrapper (`foo` above).\n-        return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys, mty);\n+        return build_wrap_fn(ccx, llrustfn, llwrapfn, &fn_sig, &fn_ty, mty);\n     }\n \n     fn build_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -568,31 +500,35 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let t = monomorphize::apply_param_substs(tcx, param_substs, &t);\n \n         let path =\n-            tcx.map.def_path_from_id(id)\n+            tcx.map.def_path(tcx.map.local_def_id(id))\n                    .into_iter()\n                    .map(|e| e.data.as_interned_str())\n                    .chain(once(special_idents::clownshoe_abi.name.as_str()));\n         let ps = link::mangle(path, hash);\n \n         // Compute the type that the function would have if it were just a\n         // normal Rust function. This will be the type of the wrappee fn.\n-        match t.sty {\n-            ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f)=> {\n+        let rust_fn_ty = match t.sty {\n+            ty::TyFnDef(_, _, ref f) => {\n                 assert!(f.abi != Abi::Rust);\n                 assert!(f.abi != Abi::RustIntrinsic);\n                 assert!(f.abi != Abi::PlatformIntrinsic);\n+                tcx.mk_fn_ptr(ty::BareFnTy {\n+                    unsafety: f.unsafety,\n+                    abi: Abi::Rust,\n+                    sig: f.sig.clone()\n+                })\n             }\n             _ => {\n-                ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {:?}, \\\n-                                        expected a bare fn ty\",\n-                                       ccx.tcx().map.path_to_string(id),\n-                                       t));\n+                unreachable!(\"build_rust_fn: extern fn {} has ty {:?}, \\\n+                              expected a fn item type\",\n+                              tcx.map.path_to_string(id), t);\n             }\n         };\n \n-        debug!(\"build_rust_fn: path={} id={} t={:?}\",\n+        debug!(\"build_rust_fn: path={} id={} ty={:?}\",\n                ccx.tcx().map.path_to_string(id),\n-               id, t);\n+               id, rust_fn_ty);\n \n         let llfn = declare::define_internal_rust_fn(ccx, &ps, t);\n         attributes::from_fn_attrs(ccx, attrs, llfn);\n@@ -603,7 +539,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     unsafe fn build_wrap_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                       llrustfn: ValueRef,\n                                       llwrapfn: ValueRef,\n-                                      tys: &ForeignTypes<'tcx>,\n+                                      fn_sig: &ty::FnSig<'tcx>,\n+                                      fn_ty: &FnType,\n                                       t: Ty<'tcx>) {\n         let _icx = push_ctxt(\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n@@ -650,7 +587,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         // If there is an out pointer on the foreign function\n         let foreign_outptr = {\n-            if tys.fn_ty.ret_ty.is_indirect() {\n+            if fn_ty.ret.is_indirect() {\n                 Some(get_param(llwrapfn, next_foreign_arg(false)))\n             } else {\n                 None\n@@ -660,7 +597,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let rustfn_ty = Type::from_ref(llvm::LLVMTypeOf(llrustfn)).element_type();\n         let mut rust_param_tys = rustfn_ty.func_params().into_iter();\n         // Push Rust return pointer, using null if it will be unused.\n-        let rust_uses_outptr = match tys.fn_sig.output {\n+        let rust_uses_outptr = match fn_sig.output {\n             ty::FnConverging(ret_ty) => type_of::return_uses_outptr(ccx, ret_ty),\n             ty::FnDiverging => false\n         };\n@@ -696,7 +633,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             return_ty={:?}\",\n                            Value(slot),\n                            llrust_ret_ty,\n-                           tys.fn_sig.output);\n+                           fn_sig.output);\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n                 }\n@@ -711,16 +648,16 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Build up the arguments to the call to the rust function.\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n-        for i in 0..tys.fn_sig.inputs.len() {\n-            let rust_ty = tys.fn_sig.inputs[i];\n+        for i in 0..fn_sig.inputs.len() {\n+            let rust_ty = fn_sig.inputs[i];\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n             let llty = rust_param_tys.next().expect(\"Not enough parameter types!\");\n             let llrust_ty = if rust_indirect {\n                 llty.element_type()\n             } else {\n                 llty\n             };\n-            let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n+            let llforeign_arg_ty = fn_ty.args[i];\n             let foreign_indirect = llforeign_arg_ty.is_indirect();\n \n             if llforeign_arg_ty.is_ignore() {\n@@ -802,12 +739,12 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                           None, Some(attributes));\n \n         // Get the return value where the foreign fn expects it.\n-        let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {\n+        let llforeign_ret_ty = match fn_ty.ret.cast {\n             Some(ty) => ty,\n-            None => tys.fn_ty.ret_ty.ty\n+            None => fn_ty.ret.ty\n         };\n         match foreign_outptr {\n-            None if !tys.llsig.ret_def => {\n+            None if fn_ty.ret.ty == Type::void(ccx) => {\n                 // Function returns `()` or `bot`, which in Rust is the LLVM\n                 // type \"{}\" but in foreign ABIs is \"Void\".\n                 builder.ret_void();\n@@ -874,140 +811,6 @@ pub fn link_name(name: ast::Name, attrs: &[ast::Attribute]) -> InternedString {\n         }\n     }\n }\n-\n-/// The ForeignSignature is the LLVM types of the arguments/return type of a function. Note that\n-/// these LLVM types are not quite the same as the LLVM types would be for a native Rust function\n-/// because foreign functions just plain ignore modes. They also don't pass aggregate values by\n-/// pointer like we do.\n-fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               fn_sig: &ty::FnSig<'tcx>,\n-                               arg_tys: &[Ty<'tcx>])\n-                               -> LlvmSignature {\n-    let llarg_tys = arg_tys.iter().map(|&arg| foreign_arg_type_of(ccx, arg)).collect();\n-    let (llret_ty, ret_def) = match fn_sig.output {\n-        ty::FnConverging(ret_ty) =>\n-            (type_of::foreign_arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n-        ty::FnDiverging =>\n-            (Type::nil(ccx), false)\n-    };\n-    LlvmSignature {\n-        llarg_tys: llarg_tys,\n-        llret_ty: llret_ty,\n-        ret_def: ret_def\n-    }\n-}\n-\n-fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     ty: Ty<'tcx>) -> ForeignTypes<'tcx> {\n-    let fn_sig = match ty.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) | ty::TyFnPtr(ref fn_ty) => &fn_ty.sig,\n-        _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n-    };\n-    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n-    let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n-    let llsig = foreign_signature(ccx, &fn_sig, &fn_sig.inputs);\n-    let fn_ty = cabi::compute_abi_info(ccx,\n-                                       &llsig.llarg_tys,\n-                                       llsig.llret_ty,\n-                                       llsig.ret_def);\n-    debug!(\"foreign_types_for_fn_ty(\\\n-           ty={:?}, \\\n-           llsig={:?} -> {:?}, \\\n-           fn_ty={:?} -> {:?}, \\\n-           ret_def={}\",\n-           ty,\n-           llsig.llarg_tys,\n-           llsig.llret_ty,\n-           fn_ty.arg_tys,\n-           fn_ty.ret_ty,\n-           llsig.ret_def);\n-\n-    ForeignTypes {\n-        fn_sig: fn_sig,\n-        llsig: llsig,\n-        fn_ty: fn_ty\n-    }\n-}\n-\n-fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> Type {\n-    let mut llargument_tys = Vec::new();\n-\n-    let ret_ty = tys.fn_ty.ret_ty;\n-    let llreturn_ty = if ret_ty.is_indirect() {\n-        llargument_tys.push(ret_ty.ty.ptr_to());\n-        Type::void(ccx)\n-    } else {\n-        match ret_ty.cast {\n-            Some(ty) => ty,\n-            None => ret_ty.ty\n-        }\n-    };\n-\n-    for &arg_ty in &tys.fn_ty.arg_tys {\n-        if arg_ty.is_ignore() {\n-            continue;\n-        }\n-        // add padding\n-        match arg_ty.pad {\n-            Some(ty) => llargument_tys.push(ty),\n-            None => ()\n         }\n-\n-        let llarg_ty = if arg_ty.is_indirect() {\n-            arg_ty.ty.ptr_to()\n-        } else {\n-            match arg_ty.cast {\n-                Some(ty) => ty,\n-                None => arg_ty.ty\n-            }\n-        };\n-\n-        llargument_tys.push(llarg_ty);\n-    }\n-\n-    if tys.fn_sig.variadic {\n-        Type::variadic_func(&llargument_tys, &llreturn_ty)\n-    } else {\n-        Type::func(&llargument_tys[..], &llreturn_ty)\n-    }\n-}\n-\n-pub fn lltype_for_foreign_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       ty: Ty<'tcx>) -> Type {\n-    lltype_for_fn_from_foreign_types(ccx, &foreign_types_for_fn_ty(ccx, ty))\n-}\n-\n-fn add_argument_attributes(tys: &ForeignTypes,\n-                           llfn: ValueRef) {\n-    let mut i = if tys.fn_ty.ret_ty.is_indirect() {\n-        1\n-    } else {\n-        0\n-    };\n-\n-    match tys.fn_ty.ret_ty.attr {\n-        Some(attr) => unsafe {\n-            llvm::LLVMAddFunctionAttribute(llfn, i as c_uint, attr.bits() as u64);\n-        },\n-        None => {}\n-    }\n-\n-    i += 1;\n-\n-    for &arg_ty in &tys.fn_ty.arg_tys {\n-        if arg_ty.is_ignore() {\n-            continue;\n-        }\n-        // skip padding\n-        if arg_ty.pad.is_some() { i += 1; }\n-\n-        match arg_ty.attr {\n-            Some(attr) => unsafe {\n-                llvm::LLVMAddFunctionAttribute(llfn, i as c_uint, attr.bits() as u64);\n-            },\n-            None => ()\n-        }\n-\n-        i += 1;\n     }\n }"}, {"sha": "ee2d84a7be7e0be68b4ec63ce6acf239e8b9f5d7", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "patch": "@@ -14,8 +14,8 @@ use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n use trans::adt;\n+use trans::cabi::FnType;\n use trans::common::*;\n-use trans::foreign;\n use trans::machine;\n use middle::ty::{self, Ty, TypeFoldable};\n \n@@ -239,14 +239,6 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     llsizingty\n }\n \n-pub fn foreign_arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    if t.is_bool() {\n-        Type::i1(cx)\n-    } else {\n-        type_of(cx, t)\n-    }\n-}\n-\n pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     if t.is_bool() {\n         Type::i1(cx)\n@@ -390,12 +382,12 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n       ty::TyFnDef(..) => Type::nil(cx),\n       ty::TyFnPtr(f) => {\n+        let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n+        let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n         if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n-            let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n-            let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n             type_of_rust_fn(cx, None, &sig, f.abi).ptr_to()\n         } else {\n-            foreign::lltype_for_foreign_fn(cx, t).ptr_to()\n+            FnType::new(cx, f.abi, &sig, &[]).to_llvm(cx).ptr_to()\n         }\n       }\n       ty::TyTuple(ref tys) if tys.is_empty() => Type::nil(cx),"}]}