{"sha": "7bb279b365e54ee0051e09ead5aa157ff6be917b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYjI3OWIzNjVlNTRlZTAwNTFlMDllYWQ1YWExNTdmZjZiZTkxN2I=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-06T18:51:42Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-07T13:54:23Z"}, "message": "Implement autoderef for field accesses", "tree": {"sha": "7a495d68453ea1e3c7a726e97bbbe19f9bc90532", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a495d68453ea1e3c7a726e97bbbe19f9bc90532"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bb279b365e54ee0051e09ead5aa157ff6be917b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bb279b365e54ee0051e09ead5aa157ff6be917b", "html_url": "https://github.com/rust-lang/rust/commit/7bb279b365e54ee0051e09ead5aa157ff6be917b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bb279b365e54ee0051e09ead5aa157ff6be917b/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6071c9f4c8441b4b8f2e970bc055d66cc9be5f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6071c9f4c8441b4b8f2e970bc055d66cc9be5f0", "html_url": "https://github.com/rust-lang/rust/commit/a6071c9f4c8441b4b8f2e970bc055d66cc9be5f0"}], "stats": {"total": 228, "additions": 185, "deletions": 43}, "files": [{"sha": "5d4e60dc525c40c39ad415da5d2bd58b3c0e44f9", "filename": "crates/ra_analysis/src/completion/complete_dot.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=7bb279b365e54ee0051e09ead5aa157ff6be917b", "patch": "@@ -23,31 +23,35 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Ca\n }\n \n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) -> Cancelable<()> {\n-    // TODO: autoderef etc.\n-    match receiver {\n-        Ty::Adt { def_id, .. } => {\n-            match def_id.resolve(ctx.db)? {\n-                Def::Struct(s) => {\n-                    let variant_data = s.variant_data(ctx.db)?;\n-                    for field in variant_data.fields() {\n-                        CompletionItem::new(CompletionKind::Reference, field.name().to_string())\n+    for receiver in receiver.autoderef(ctx.db) {\n+        match receiver {\n+            Ty::Adt { def_id, .. } => {\n+                match def_id.resolve(ctx.db)? {\n+                    Def::Struct(s) => {\n+                        let variant_data = s.variant_data(ctx.db)?;\n+                        for field in variant_data.fields() {\n+                            CompletionItem::new(\n+                                CompletionKind::Reference,\n+                                field.name().to_string(),\n+                            )\n                             .kind(CompletionItemKind::Field)\n                             .add_to(acc);\n+                        }\n                     }\n+                    // TODO unions\n+                    _ => {}\n                 }\n-                // TODO unions\n-                _ => {}\n             }\n-        }\n-        Ty::Tuple(fields) => {\n-            for (i, _ty) in fields.iter().enumerate() {\n-                CompletionItem::new(CompletionKind::Reference, i.to_string())\n-                    .kind(CompletionItemKind::Field)\n-                    .add_to(acc);\n+            Ty::Tuple(fields) => {\n+                for (i, _ty) in fields.iter().enumerate() {\n+                    CompletionItem::new(CompletionKind::Reference, i.to_string())\n+                        .kind(CompletionItemKind::Field)\n+                        .add_to(acc);\n+                }\n             }\n-        }\n-        _ => {}\n-    };\n+            _ => {}\n+        };\n+    }\n     Ok(())\n }\n \n@@ -87,6 +91,21 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_field_completion_autoderef() {\n+        check_ref_completion(\n+            r\"\n+            struct A { the_field: u32 }\n+            impl A {\n+                fn foo(&self) {\n+                    self.<|>\n+                }\n+            }\n+            \",\n+            r#\"the_field\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_no_struct_field_completion_for_method_call() {\n         check_ref_completion("}, {"sha": "04249400b94e06cf836b8f72a2c4341e6a8b1a16", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=7bb279b365e54ee0051e09ead5aa157ff6be917b", "patch": "@@ -56,7 +56,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::ty::type_for_def;\n     }\n \n-    fn type_for_field(def_id: DefId, field: Name) -> Cancelable<Ty> {\n+    fn type_for_field(def_id: DefId, field: Name) -> Cancelable<Option<Ty>> {\n         type TypeForFieldQuery;\n         use fn crate::ty::type_for_field;\n     }"}, {"sha": "bba8527b7f765ba7d0c7c757f1039211cd821f69", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 50, "deletions": 22, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=7bb279b365e54ee0051e09ead5aa157ff6be917b", "patch": "@@ -13,6 +13,7 @@\n //! the union-find implementation from the `ena` crate, which is extracted from\n //! rustc.\n \n+mod autoderef;\n mod primitive;\n #[cfg(test)]\n mod tests;\n@@ -36,6 +37,14 @@ use crate::{\n     expr::{Body, Expr, ExprId, PatId, UnaryOp, BinaryOp, Statement},\n };\n \n+fn transpose<T>(x: Cancelable<Option<T>>) -> Option<Cancelable<T>> {\n+    match x {\n+        Ok(Some(t)) => Some(Ok(t)),\n+        Ok(None) => None,\n+        Err(e) => Some(Err(e)),\n+    }\n+}\n+\n /// The ID of a type variable.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TypeVarId(u32);\n@@ -357,6 +366,14 @@ impl Ty {\n         });\n         self\n     }\n+\n+    fn builtin_deref(&self) -> Option<Ty> {\n+        match self {\n+            Ty::Ref(t, _) => Some(Ty::clone(t)),\n+            Ty::RawPtr(t, _) => Some(Ty::clone(t)),\n+            _ => None,\n+        }\n+    }\n }\n \n impl fmt::Display for Ty {\n@@ -443,7 +460,11 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<T\n     }\n }\n \n-pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Cancelable<Ty> {\n+pub(super) fn type_for_field(\n+    db: &impl HirDatabase,\n+    def_id: DefId,\n+    field: Name,\n+) -> Cancelable<Option<Ty>> {\n     let def = def_id.resolve(db)?;\n     let variant_data = match def {\n         Def::Struct(s) => {\n@@ -459,12 +480,13 @@ pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name)\n     };\n     let module = def_id.module(db)?;\n     let impl_block = def_id.impl_block(db)?;\n-    let type_ref = if let Some(tr) = variant_data.get_field_type_ref(&field) {\n-        tr\n-    } else {\n-        return Ok(Ty::Unknown);\n-    };\n-    Ty::from_hir(db, &module, impl_block.as_ref(), &type_ref)\n+    let type_ref = ctry!(variant_data.get_field_type_ref(&field));\n+    Ok(Some(Ty::from_hir(\n+        db,\n+        &module,\n+        impl_block.as_ref(),\n+        &type_ref,\n+    )?))\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n@@ -802,7 +824,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref())?;\n                 for field in fields {\n                     let field_ty = if let Some(def_id) = def_id {\n-                        self.db.type_for_field(def_id, field.name.clone())?\n+                        self.db\n+                            .type_for_field(def_id, field.name.clone())?\n+                            .unwrap_or(Ty::Unknown)\n                     } else {\n                         Ty::Unknown\n                     };\n@@ -815,15 +839,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Field { expr, name } => {\n                 let receiver_ty = self.infer_expr(*expr, &Expectation::none())?;\n-                let ty = match receiver_ty {\n-                    Ty::Tuple(fields) => {\n-                        let i = name.to_string().parse::<usize>().ok();\n-                        i.and_then(|i| fields.get(i).cloned())\n-                            .unwrap_or(Ty::Unknown)\n-                    }\n-                    Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, name.clone())?,\n-                    _ => Ty::Unknown,\n-                };\n+                let ty = receiver_ty\n+                    .autoderef(self.db)\n+                    .find_map(|derefed_ty| match derefed_ty {\n+                        // this is more complicated than necessary because type_for_field is cancelable\n+                        Ty::Tuple(fields) => {\n+                            let i = name.to_string().parse::<usize>().ok();\n+                            i.and_then(|i| fields.get(i).cloned()).map(Ok)\n+                        }\n+                        Ty::Adt { def_id, .. } => {\n+                            transpose(self.db.type_for_field(def_id, name.clone()))\n+                        }\n+                        _ => None,\n+                    })\n+                    .unwrap_or(Ok(Ty::Unknown))?;\n                 self.insert_type_vars(ty)\n             }\n             Expr::Try { expr } => {\n@@ -848,12 +877,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n                 match op {\n                     Some(UnaryOp::Deref) => {\n-                        match inner_ty {\n-                            // builtin deref:\n-                            Ty::Ref(ref_inner, _) => (*ref_inner).clone(),\n-                            Ty::RawPtr(ptr_inner, _) => (*ptr_inner).clone(),\n+                        if let Some(derefed_ty) = inner_ty.builtin_deref() {\n+                            derefed_ty\n+                        } else {\n                             // TODO Deref::deref\n-                            _ => Ty::Unknown,\n+                            Ty::Unknown\n                         }\n                     }\n                     _ => Ty::Unknown,"}, {"sha": "24a38655837cce83f52737d91c158b98702a12c8", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=7bb279b365e54ee0051e09ead5aa157ff6be917b", "patch": "@@ -0,0 +1,21 @@\n+//! In certain situations, rust automatically inserts derefs as necessary: For\n+//! example, field accesses `foo.bar` still work when `foo` is actually a\n+//! reference to a type with the field `bar`. This is an approximation of the\n+//! logic in rustc (which lives in librustc_typeck/check/autoderef.rs).\n+\n+use ra_syntax::algo::generate;\n+\n+use crate::HirDatabase;\n+use super::Ty;\n+\n+impl Ty {\n+    /// Iterates over the possible derefs of `ty`.\n+    pub fn autoderef<'a>(self, db: &'a impl HirDatabase) -> impl Iterator<Item = Ty> + 'a {\n+        generate(Some(self), move |ty| ty.autoderef_step(db))\n+    }\n+\n+    fn autoderef_step(&self, _db: &impl HirDatabase) -> Option<Ty> {\n+        // TODO Deref::deref\n+        self.builtin_deref()\n+    }\n+}"}, {"sha": "e6c7e225b323084673225a801b2b7b7c163cb974", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=7bb279b365e54ee0051e09ead5aa157ff6be917b", "patch": "@@ -95,7 +95,7 @@ fn test() {\n }\n \n #[test]\n-fn infer_refs_and_ptrs() {\n+fn infer_refs() {\n     check_inference(\n         r#\"\n fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n@@ -180,6 +180,37 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_field_autoderef() {\n+    check_inference(\n+        r#\"\n+struct A {\n+    b: B,\n+}\n+struct B;\n+\n+fn test1(a: A) {\n+    let a1 = a;\n+    a1.b;\n+    let a2 = &a;\n+    a2.b;\n+    let a3 = &mut a;\n+    a3.b;\n+    let a4 = &&&&&&&a;\n+    a4.b;\n+    let a5 = &mut &&mut &&mut a;\n+    a5.b;\n+}\n+\n+fn test2(a1: *const A, a2: *mut A) {\n+    a1.b;\n+    a2.b;\n+}\n+\"#,\n+        \"field_autoderef.txt\",\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.source_file(file_id);"}, {"sha": "e1db1db40b8886e49201ff7779b07a0c26414e35", "filename": "crates/ra_hir/src/ty/tests/data/field_autoderef.txt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ffield_autoderef.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7bb279b365e54ee0051e09ead5aa157ff6be917b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ffield_autoderef.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ffield_autoderef.txt?ref=7bb279b365e54ee0051e09ead5aa157ff6be917b", "patch": "@@ -0,0 +1,43 @@\n+[44; 45) 'a': A\n+[50; 213) '{     ...5.b; }': ()\n+[60; 62) 'a1': A\n+[65; 66) 'a': A\n+[72; 74) 'a1': A\n+[72; 76) 'a1.b': B\n+[86; 88) 'a2': &A\n+[91; 93) '&a': &A\n+[92; 93) 'a': A\n+[99; 101) 'a2': &A\n+[99; 103) 'a2.b': B\n+[113; 115) 'a3': &mut A\n+[118; 124) '&mut a': &mut A\n+[123; 124) 'a': A\n+[130; 132) 'a3': &mut A\n+[130; 134) 'a3.b': B\n+[144; 146) 'a4': &&&&&&&A\n+[149; 157) '&&&&&&&a': &&&&&&&A\n+[150; 157) '&&&&&&a': &&&&&&A\n+[151; 157) '&&&&&a': &&&&&A\n+[152; 157) '&&&&a': &&&&A\n+[153; 157) '&&&a': &&&A\n+[154; 157) '&&a': &&A\n+[155; 157) '&a': &A\n+[156; 157) 'a': A\n+[163; 165) 'a4': &&&&&&&A\n+[163; 167) 'a4.b': B\n+[177; 179) 'a5': &mut &&mut &&mut A\n+[182; 200) '&mut &...&mut a': &mut &&mut &&mut A\n+[187; 200) '&&mut &&mut a': &&mut &&mut A\n+[188; 200) '&mut &&mut a': &mut &&mut A\n+[193; 200) '&&mut a': &&mut A\n+[194; 200) '&mut a': &mut A\n+[199; 200) 'a': A\n+[206; 208) 'a5': &mut &&mut &&mut A\n+[206; 210) 'a5.b': B\n+[224; 226) 'a1': *const A\n+[238; 240) 'a2': *mut A\n+[250; 273) '{     ...2.b; }': ()\n+[256; 258) 'a1': *const A\n+[256; 260) 'a1.b': B\n+[266; 268) 'a2': *mut A\n+[266; 270) 'a2.b': B"}]}