{"sha": "cf3b4f1e208247c9d171273dabff9c6b3c98a240", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmM2I0ZjFlMjA4MjQ3YzlkMTcxMjczZGFiZmY5YzZiM2M5OGEyNDA=", "commit": {"author": {"name": "cynecx", "email": "me@cynecx.net", "date": "2021-04-10T15:49:12Z"}, "committer": {"name": "cynecx", "email": "me@cynecx.net", "date": "2021-04-17T14:24:56Z"}, "message": "hir_ty: Expand macros at type position", "tree": {"sha": "0cae2703b98ba8640ce6693abe32fb51fe27fdda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cae2703b98ba8640ce6693abe32fb51fe27fdda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf3b4f1e208247c9d171273dabff9c6b3c98a240", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf3b4f1e208247c9d171273dabff9c6b3c98a240", "html_url": "https://github.com/rust-lang/rust/commit/cf3b4f1e208247c9d171273dabff9c6b3c98a240", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf3b4f1e208247c9d171273dabff9c6b3c98a240/comments", "author": {"login": "cynecx", "id": 5961244, "node_id": "MDQ6VXNlcjU5NjEyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5961244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cynecx", "html_url": "https://github.com/cynecx", "followers_url": "https://api.github.com/users/cynecx/followers", "following_url": "https://api.github.com/users/cynecx/following{/other_user}", "gists_url": "https://api.github.com/users/cynecx/gists{/gist_id}", "starred_url": "https://api.github.com/users/cynecx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cynecx/subscriptions", "organizations_url": "https://api.github.com/users/cynecx/orgs", "repos_url": "https://api.github.com/users/cynecx/repos", "events_url": "https://api.github.com/users/cynecx/events{/privacy}", "received_events_url": "https://api.github.com/users/cynecx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cynecx", "id": 5961244, "node_id": "MDQ6VXNlcjU5NjEyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5961244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cynecx", "html_url": "https://github.com/cynecx", "followers_url": "https://api.github.com/users/cynecx/followers", "following_url": "https://api.github.com/users/cynecx/following{/other_user}", "gists_url": "https://api.github.com/users/cynecx/gists{/gist_id}", "starred_url": "https://api.github.com/users/cynecx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cynecx/subscriptions", "organizations_url": "https://api.github.com/users/cynecx/orgs", "repos_url": "https://api.github.com/users/cynecx/repos", "events_url": "https://api.github.com/users/cynecx/events{/privacy}", "received_events_url": "https://api.github.com/users/cynecx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb2d284f28f70426e39e1b92d95bdbb217a48109", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb2d284f28f70426e39e1b92d95bdbb217a48109", "html_url": "https://github.com/rust-lang/rust/commit/fb2d284f28f70426e39e1b92d95bdbb217a48109"}], "stats": {"total": 515, "additions": 434, "deletions": 81}, "files": [{"sha": "29c0821cfed63701428e943f0215f706326c4c8a", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -6,6 +6,7 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use base_db::{FileId, FileRange};\n use hir_def::{\n+    body,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     AsMacroCall, FunctionId, TraitId, VariantId,\n };\n@@ -854,7 +855,8 @@ impl<'a> SemanticsScope<'a> {\n     /// necessary a heuristic, as it doesn't take hygiene into account.\n     pub fn speculative_resolve(&self, path: &ast::Path) -> Option<PathResolution> {\n         let hygiene = Hygiene::new(self.db.upcast(), self.file_id);\n-        let path = Path::from_src(path.clone(), &hygiene)?;\n+        let ctx = body::LowerCtx::with_hygiene(&hygiene);\n+        let path = Path::from_src(path.clone(), &ctx)?;\n         resolve_hir_path(self.db, &self.resolver, &path)\n     }\n }"}, {"sha": "0895bd6f1f1fc06ebfc2ecb7b8ed4df961473a5f", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -9,6 +9,7 @@ use std::{iter::once, sync::Arc};\n \n use hir_def::{\n     body::{\n+        self,\n         scope::{ExprScopes, ScopeId},\n         Body, BodySourceMap,\n     },\n@@ -202,8 +203,8 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<MacroDef> {\n-        let hygiene = Hygiene::new(db.upcast(), macro_call.file_id);\n-        let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &hygiene))?;\n+        let ctx = body::LowerCtx::new(db.upcast(), macro_call.file_id);\n+        let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &ctx))?;\n         self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()).map(|it| it.into())\n     }\n \n@@ -281,7 +282,9 @@ impl SourceAnalyzer {\n         }\n \n         // This must be a normal source file rather than macro file.\n-        let hir_path = Path::from_src(path.clone(), &Hygiene::new(db.upcast(), self.file_id))?;\n+        let hygiene = Hygiene::new(db.upcast(), self.file_id);\n+        let ctx = body::LowerCtx::with_hygiene(&hygiene);\n+        let hir_path = Path::from_src(path.clone(), &ctx)?;\n \n         // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we\n         // trying to resolve foo::bar."}, {"sha": "44ae136437fc3d86028be87e9a3e4ca99fe72f3b", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 60, "deletions": 14, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -19,9 +19,9 @@ use hir_expand::{\n use la_arena::{Arena, ArenaMap};\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use syntax::{ast, AstNode, AstPtr};\n+use syntax::{ast, AstNode, AstPtr, SyntaxNode};\n \n-pub(crate) use lower::LowerCtx;\n+pub use lower::LowerCtx;\n \n use crate::{\n     attr::{Attrs, RawAttrs},\n@@ -98,11 +98,14 @@ impl Expander {\n         }\n     }\n \n-    pub(crate) fn enter_expand<T: ast::AstNode>(\n+    fn enter_expand_intern(\n         &mut self,\n         db: &dyn DefDatabase,\n         macro_call: ast::MacroCall,\n-    ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n+    ) -> Result<\n+        ExpandResult<Option<(SyntaxNode, impl FnMut(&dyn DefDatabase) -> Mark + '_)>>,\n+        UnresolvedMacro,\n+    > {\n         if self.recursion_limit + 1 > EXPANSION_RECURSION_LIMIT {\n             cov_mark::hit!(your_stack_belongs_to_me);\n             return Ok(ExpandResult::str_err(\n@@ -147,6 +150,55 @@ impl Expander {\n             }\n         };\n \n+        let this = self;\n+\n+        let advance_state = move |db: &dyn DefDatabase| {\n+            this.recursion_limit += 1;\n+            let mark = Mark {\n+                file_id: this.current_file_id,\n+                ast_id_map: mem::take(&mut this.ast_id_map),\n+                bomb: DropBomb::new(\"expansion mark dropped\"),\n+            };\n+            this.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n+            this.current_file_id = file_id;\n+            this.ast_id_map = db.ast_id_map(file_id);\n+            mark\n+        };\n+\n+        Ok(ExpandResult { value: Some((raw_node, advance_state)), err })\n+    }\n+\n+    pub(crate) fn enter_expand_raw(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        macro_call: ast::MacroCall,\n+    ) -> Result<ExpandResult<Option<(Mark, SyntaxNode)>>, UnresolvedMacro> {\n+        let (raw_node, mut advance_state, err) = match self.enter_expand_intern(db, macro_call)? {\n+            ExpandResult { value: Some((raw_node, advance_state)), err } => {\n+                (raw_node, advance_state, err)\n+            }\n+            ExpandResult { value: None, err } => return Ok(ExpandResult { value: None, err }),\n+        };\n+\n+        log::debug!(\"macro expansion {:#?}\", raw_node);\n+\n+        let mark = advance_state(db);\n+\n+        Ok(ExpandResult { value: Some((mark, raw_node)), err })\n+    }\n+\n+    pub(crate) fn enter_expand<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        macro_call: ast::MacroCall,\n+    ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n+        let (raw_node, mut advance_state, err) = match self.enter_expand_intern(db, macro_call)? {\n+            ExpandResult { value: Some((raw_node, advance_state)), err } => {\n+                (raw_node, advance_state, err)\n+            }\n+            ExpandResult { value: None, err } => return Ok(ExpandResult { value: None, err }),\n+        };\n+\n         let node = match T::cast(raw_node) {\n             Some(it) => it,\n             None => {\n@@ -157,15 +209,7 @@ impl Expander {\n \n         log::debug!(\"macro expansion {:#?}\", node.syntax());\n \n-        self.recursion_limit += 1;\n-        let mark = Mark {\n-            file_id: self.current_file_id,\n-            ast_id_map: mem::take(&mut self.ast_id_map),\n-            bomb: DropBomb::new(\"expansion mark dropped\"),\n-        };\n-        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n-        self.current_file_id = file_id;\n-        self.ast_id_map = db.ast_id_map(file_id);\n+        let mark = advance_state(db);\n \n         Ok(ExpandResult { value: Some((mark, node)), err })\n     }\n@@ -191,7 +235,8 @@ impl Expander {\n     }\n \n     fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n-        Path::from_src(path, &self.cfg_expander.hygiene)\n+        let ctx = LowerCtx::with_hygiene(&self.cfg_expander.hygiene);\n+        Path::from_src(path, &ctx)\n     }\n \n     fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroDefId> {\n@@ -204,6 +249,7 @@ impl Expander {\n     }\n }\n \n+#[derive(Debug)]\n pub(crate) struct Mark {\n     file_id: HirFileId,\n     ast_id_map: Arc<AstIdMap>,"}, {"sha": "c11da30d2e046021bb214a7cccfd87ff2cb62ed7", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -1,10 +1,11 @@\n //! Transforms `ast::Expr` into an equivalent `hir_def::expr::Expr`\n //! representation.\n \n-use std::mem;\n+use std::{mem, sync::Arc};\n \n use either::Either;\n use hir_expand::{\n+    ast_id_map::{AstIdMap, FileAstId},\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n     ExpandError, HirFileId,\n@@ -39,20 +40,39 @@ use crate::{\n \n use super::{diagnostics::BodyDiagnostic, ExprSource, PatSource};\n \n-pub(crate) struct LowerCtx {\n+pub struct LowerCtx {\n     hygiene: Hygiene,\n+    file_id: Option<HirFileId>,\n+    source_ast_id_map: Option<Arc<AstIdMap>>,\n }\n \n impl LowerCtx {\n-    pub(crate) fn new(db: &dyn DefDatabase, file_id: HirFileId) -> Self {\n-        LowerCtx { hygiene: Hygiene::new(db.upcast(), file_id) }\n+    pub fn new(db: &dyn DefDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx {\n+            hygiene: Hygiene::new(db.upcast(), file_id),\n+            file_id: Some(file_id),\n+            source_ast_id_map: Some(db.ast_id_map(file_id)),\n+        }\n+    }\n+\n+    pub fn with_hygiene(hygiene: &Hygiene) -> Self {\n+        LowerCtx { hygiene: hygiene.clone(), file_id: None, source_ast_id_map: None }\n+    }\n+\n+    pub(crate) fn hygiene(&self) -> &Hygiene {\n+        &self.hygiene\n     }\n-    pub(crate) fn with_hygiene(hygiene: &Hygiene) -> Self {\n-        LowerCtx { hygiene: hygiene.clone() }\n+\n+    pub(crate) fn file_id(&self) -> HirFileId {\n+        self.file_id.unwrap()\n     }\n \n     pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n-        Path::from_src(ast, &self.hygiene)\n+        Path::from_src(ast, self)\n+    }\n+\n+    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> Option<FileAstId<N>> {\n+        self.source_ast_id_map.as_ref().map(|ast_id_map| ast_id_map.ast_id(item))\n     }\n }\n "}, {"sha": "8732b1e3ed6de4145988cbec70caf827f1a452aa", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -123,10 +123,11 @@ impl TypeAliasData {\n         let loc = typ.lookup(db);\n         let item_tree = loc.id.item_tree(db);\n         let typ = &item_tree[loc.id.value];\n+        let type_ref = typ.type_ref.clone();\n \n         Arc::new(TypeAliasData {\n             name: typ.name.clone(),\n-            type_ref: typ.type_ref.clone(),\n+            type_ref: type_ref,\n             visibility: item_tree[typ.visibility].clone(),\n             is_extern: typ.is_extern,\n             bounds: typ.bounds.to_vec(),\n@@ -202,12 +203,13 @@ impl ImplData {\n         let item_tree = impl_loc.id.item_tree(db);\n         let impl_def = &item_tree[impl_loc.id.value];\n         let target_trait = impl_def.target_trait.clone();\n-        let self_ty = impl_def.self_ty.clone();\n         let is_negative = impl_def.is_negative;\n         let module_id = impl_loc.container;\n         let container = AssocContainerId::ImplId(id);\n-        let mut expander = Expander::new(db, impl_loc.id.file_id(), module_id);\n+        let file_id = impl_loc.id.file_id();\n+        let self_ty = impl_def.self_ty.clone();\n \n+        let mut expander = Expander::new(db, file_id, module_id);\n         let items = collect_items(\n             db,\n             module_id,"}, {"sha": "2975786dd4c7973cf1b4662477229078e25f7812", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -189,12 +189,16 @@ impl Ctx {\n                                 block_stack.push(self.source_ast_id_map.ast_id(&block));\n                             },\n                             ast::Item(item) => {\n-                                // FIXME: This triggers for macro calls in expression/pattern/type position\n-                                let mod_items = self.lower_mod_item(&item, true);\n-                                let current_block = block_stack.last();\n-                                if let (Some(mod_items), Some(block)) = (mod_items, current_block) {\n-                                    if !mod_items.0.is_empty() {\n-                                        self.data().inner_items.entry(*block).or_default().extend(mod_items.0.iter().copied());\n+                                // FIXME: This triggers for macro calls in expression/pattern\n+                                if let Some(SyntaxKind::MACRO_TYPE) = node.parent().map(|p| p.kind()) {\n+                                    // Ignore macros at type position\n+                                } else {\n+                                    let mod_items = self.lower_mod_item(&item, true);\n+                                    let current_block = block_stack.last();\n+                                    if let (Some(mod_items), Some(block)) = (mod_items, current_block) {\n+                                        if !mod_items.0.is_empty() {\n+                                            self.data().inner_items.entry(*block).or_default().extend(mod_items.0.iter().copied());\n+                                        }\n                                     }\n                                 }\n                             },"}, {"sha": "059724daafaafc93458ae657e5f239c17c6b342e", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -676,6 +676,7 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n     }\n }\n \n+#[derive(Debug)]\n pub struct UnresolvedMacro {\n     pub path: ModPath,\n }"}, {"sha": "509f77850a304376d94b6f044ba843355548560d", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -48,7 +48,8 @@ pub enum ImportAlias {\n \n impl ModPath {\n     pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n-        lower::lower_path(path, hygiene).map(|it| (*it.mod_path).clone())\n+        let ctx = LowerCtx::with_hygiene(hygiene);\n+        lower::lower_path(path, &ctx).map(|it| (*it.mod_path).clone())\n     }\n \n     pub fn from_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> ModPath {\n@@ -167,8 +168,8 @@ pub enum GenericArg {\n impl Path {\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n-    pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n-        lower::lower_path(path, hygiene)\n+    pub fn from_src(path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n+        lower::lower_path(path, ctx)\n     }\n \n     /// Converts a known mod path to `Path`."}, {"sha": "1df6db5250e70880cdbba4bc5dbb150ba415679f", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -6,10 +6,7 @@ use crate::intern::Interned;\n use std::sync::Arc;\n \n use either::Either;\n-use hir_expand::{\n-    hygiene::Hygiene,\n-    name::{name, AsName},\n-};\n+use hir_expand::name::{name, AsName};\n use syntax::ast::{self, AstNode, TypeBoundsOwner};\n \n use super::AssociatedTypeBinding;\n@@ -23,12 +20,12 @@ pub(super) use lower_use::lower_use_tree;\n \n /// Converts an `ast::Path` to `Path`. Works with use trees.\n /// It correctly handles `$crate` based path from macro call.\n-pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n+pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx) -> Option<Path> {\n     let mut kind = PathKind::Plain;\n     let mut type_anchor = None;\n     let mut segments = Vec::new();\n     let mut generic_args = Vec::new();\n-    let ctx = LowerCtx::with_hygiene(hygiene);\n+    let hygiene = ctx.hygiene();\n     loop {\n         let segment = path.segment()?;\n \n@@ -43,10 +40,10 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n                     Either::Left(name) => {\n                         let args = segment\n                             .generic_arg_list()\n-                            .and_then(|it| lower_generic_args(&ctx, it))\n+                            .and_then(|it| lower_generic_args(ctx, it))\n                             .or_else(|| {\n                                 lower_generic_args_from_fn_path(\n-                                    &ctx,\n+                                    ctx,\n                                     segment.param_list(),\n                                     segment.ret_type(),\n                                 )\n@@ -64,7 +61,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n             ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                 assert!(path.qualifier().is_none()); // this can only occur at the first segment\n \n-                let self_type = TypeRef::from_ast(&ctx, type_ref?);\n+                let self_type = TypeRef::from_ast(ctx, type_ref?);\n \n                 match trait_ref {\n                     // <T>::foo\n@@ -74,7 +71,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n                     }\n                     // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                     Some(trait_ref) => {\n-                        let path = Path::from_src(trait_ref.path()?, hygiene)?;\n+                        let path = Path::from_src(trait_ref.path()?, ctx)?;\n                         let mod_path = (*path.mod_path).clone();\n                         let num_segments = path.mod_path.segments.len();\n                         kind = mod_path.kind;"}, {"sha": "0832371c0dcf17fa84744e709540222968e21933", "filename": "crates/hir_def/src/type_ref.rs", "status": "modified", "additions": 96, "deletions": 6, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -1,9 +1,16 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n-use hir_expand::name::Name;\n-use syntax::ast;\n+use std::borrow::Cow;\n \n-use crate::{body::LowerCtx, path::Path};\n+use hir_expand::{ast_id_map::FileAstId, name::Name, ExpandResult, InFile};\n+use syntax::{algo::SyntaxRewriter, ast, AstNode, SyntaxKind, SyntaxNode};\n+\n+use crate::{\n+    body::{Expander, LowerCtx},\n+    db::DefDatabase,\n+    path::Path,\n+    ModuleId,\n+};\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Mutability {\n@@ -68,6 +75,7 @@ impl TraitRef {\n         }\n     }\n }\n+\n /// Compare ty::Ty\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum TypeRef {\n@@ -84,6 +92,7 @@ pub enum TypeRef {\n     // For\n     ImplTrait(Vec<TypeBound>),\n     DynTrait(Vec<TypeBound>),\n+    Macro(InFile<FileAstId<ast::MacroCall>>),\n     Error,\n }\n \n@@ -176,8 +185,13 @@ impl TypeRef {\n             ast::Type::DynTraitType(inner) => {\n                 TypeRef::DynTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n-            // FIXME: Macros in type position are not yet supported.\n-            ast::Type::MacroType(_) => TypeRef::Error,\n+            ast::Type::MacroType(mt) => match mt.macro_call() {\n+                Some(mc) => ctx\n+                    .ast_id(&mc)\n+                    .map(|mc| TypeRef::Macro(InFile::new(ctx.file_id(), mc)))\n+                    .unwrap_or(TypeRef::Error),\n+                None => TypeRef::Error,\n+            },\n         }\n     }\n \n@@ -193,6 +207,16 @@ impl TypeRef {\n         TypeRef::Tuple(Vec::new())\n     }\n \n+    pub fn has_macro_calls(&self) -> bool {\n+        let mut has_macro_call = false;\n+        self.walk(&mut |ty_ref| {\n+            if let TypeRef::Macro(_) = ty_ref {\n+                has_macro_call |= true\n+            }\n+        });\n+        has_macro_call\n+    }\n+\n     pub fn walk(&self, f: &mut impl FnMut(&TypeRef)) {\n         go(self, f);\n \n@@ -215,7 +239,7 @@ impl TypeRef {\n                     }\n                 }\n                 TypeRef::Path(path) => go_path(path, f),\n-                TypeRef::Never | TypeRef::Placeholder | TypeRef::Error => {}\n+                TypeRef::Never | TypeRef::Placeholder | TypeRef::Macro(_) | TypeRef::Error => {}\n             };\n         }\n \n@@ -290,3 +314,69 @@ impl TypeBound {\n         }\n     }\n }\n+\n+pub fn expand_type_ref<'a>(\n+    db: &dyn DefDatabase,\n+    module_id: ModuleId,\n+    type_ref: &'a TypeRef,\n+) -> Option<Cow<'a, TypeRef>> {\n+    let macro_call = match type_ref {\n+        TypeRef::Macro(macro_call) => macro_call,\n+        _ => return Some(Cow::Borrowed(type_ref)),\n+    };\n+\n+    let file_id = macro_call.file_id;\n+    let macro_call = macro_call.to_node(db.upcast());\n+\n+    let mut expander = Expander::new(db, file_id, module_id);\n+    let expanded = expand(db, &mut expander, &macro_call, true)?;\n+\n+    let node = ast::Type::cast(expanded)?;\n+\n+    let ctx = LowerCtx::new(db, file_id);\n+    return Some(Cow::Owned(TypeRef::from_ast(&ctx, node)));\n+\n+    fn expand(\n+        db: &dyn DefDatabase,\n+        expander: &mut Expander,\n+        macro_call: &ast::MacroCall,\n+        expect_type: bool,\n+    ) -> Option<SyntaxNode> {\n+        let (mark, mut expanded) = match expander.enter_expand_raw(db, macro_call.clone()) {\n+            Ok(ExpandResult { value: Some((mark, expanded)), .. }) => (mark, expanded),\n+            _ => return None,\n+        };\n+\n+        if expect_type && !ast::Type::can_cast(expanded.kind()) {\n+            expander.exit(db, mark);\n+            return None;\n+        }\n+\n+        if ast::MacroType::can_cast(expanded.kind()) {\n+            expanded = expanded.first_child()?; // MACRO_CALL\n+        }\n+\n+        let mut rewriter = SyntaxRewriter::default();\n+\n+        let children = expanded.descendants().filter_map(ast::MacroCall::cast);\n+        for child in children {\n+            if let Some(new_node) = expand(db, expander, &child, false) {\n+                if expanded == *child.syntax() {\n+                    expanded = new_node;\n+                } else {\n+                    let parent = child.syntax().parent();\n+                    let old_node = match &parent {\n+                        Some(node) if node.kind() == SyntaxKind::MACRO_TYPE => node,\n+                        _ => child.syntax(),\n+                    };\n+                    rewriter.replace(old_node, &new_node)\n+                }\n+            }\n+        }\n+\n+        expander.exit(db, mark);\n+\n+        let res = rewriter.rewrite(&expanded);\n+        Some(res)\n+    }\n+}"}, {"sha": "1e4b0cc194b711c7c933292007251ed6936201d5", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -440,6 +440,7 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n         MACRO_ITEMS | SOURCE_FILE => FragmentKind::Items,\n         MACRO_STMTS => FragmentKind::Statements,\n         MACRO_PAT => FragmentKind::Pattern,\n+        MACRO_TYPE => FragmentKind::Type,\n         ITEM_LIST => FragmentKind::Items,\n         LET_STMT => {\n             // FIXME: Handle LHS Pattern"}, {"sha": "a5ac32d3cb014c5434f06d51574edb005eec410a", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -31,6 +31,7 @@ use parser::FragmentKind;\n use std::sync::Arc;\n use syntax::{algo::SyntaxRewriter, SyntaxNode};\n \n+#[derive(Debug)]\n pub struct ErrorEmitted {\n     _private: (),\n }"}, {"sha": "63bcb064069785e6531dd27173c3fd67cf95d6c7", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -997,7 +997,7 @@ impl HirDisplay for TypeRef {\n                 write!(f, \"dyn \")?;\n                 f.write_joined(bounds, \" + \")?;\n             }\n-            TypeRef::Error => write!(f, \"{{error}}\")?,\n+            TypeRef::Error | TypeRef::Macro(_) => write!(f, \"{{error}}\")?,\n         }\n         Ok(())\n     }"}, {"sha": "95ca5bdb0971d5a7427e9b14480dc08712cc576b", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -15,7 +15,7 @@ use hir_def::{\n     generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n-    type_ref::{TraitRef as HirTraitRef, TypeBound, TypeRef},\n+    type_ref::{expand_type_ref, TraitRef as HirTraitRef, TypeBound, TypeRef},\n     AdtId, AssocContainerId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId,\n     GenericDefId, HasModule, ImplId, LocalFieldId, Lookup, StaticId, StructId, TraitId,\n     TypeAliasId, TypeParamId, UnionId, VariantId,\n@@ -287,6 +287,16 @@ impl<'a> TyLoweringContext<'a> {\n                     }\n                 }\n             }\n+            mt @ TypeRef::Macro(_) => {\n+                if let Some(module_id) = self.resolver.module() {\n+                    match expand_type_ref(self.db.upcast(), module_id, mt) {\n+                        Some(type_ref) => self.lower_ty(type_ref.as_ref()),\n+                        None => TyKind::Error.intern(&Interner),\n+                    }\n+                } else {\n+                    TyKind::Error.intern(&Interner)\n+                }\n+            }\n             TypeRef::Error => TyKind::Error.intern(&Interner),\n         };\n         (ty, res)"}, {"sha": "cbe05a5c1664b8cd8443bc1fcae7328265aea486", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -1074,3 +1074,172 @@ fn macro_in_arm() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn macro_in_type_alias_position() {\n+    check_infer(\n+        r#\"\n+        macro_rules! U32 {\n+            () => { u32 };\n+        }\n+\n+        trait Foo {\n+            type Ty;\n+        }\n+\n+        impl<T> Foo for T {\n+            type Ty = U32!();\n+        }\n+\n+        type TayTo = U32!();\n+\n+        fn testy() {\n+            let a: <() as Foo>::Ty;\n+            let b: TayTo;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            147..196 '{     ...yTo; }': ()\n+            157..158 'a': u32\n+            185..186 'b': u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn nested_macro_in_type_alias_position() {\n+    check_infer(\n+        r#\"\n+        macro_rules! U32Inner2 {\n+            () => { u32 };\n+        }\n+\n+        macro_rules! U32Inner1 {\n+            () => { U32Inner2!() };\n+        }\n+\n+        macro_rules! U32 {\n+            () => { U32Inner1!() };\n+        }\n+\n+        trait Foo {\n+            type Ty;\n+        }\n+\n+        impl<T> Foo for T {\n+            type Ty = U32!();\n+        }\n+\n+        type TayTo = U32!();\n+\n+        fn testy() {\n+            let a: <() as Foo>::Ty;\n+            let b: TayTo;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            259..308 '{     ...yTo; }': ()\n+            269..270 'a': u32\n+            297..298 'b': u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macros_in_type_alias_position_generics() {\n+    check_infer(\n+        r#\"\n+        struct Foo<A, B>(A, B);\n+\n+        macro_rules! U32 {\n+            () => { u32 };\n+        }\n+\n+        macro_rules! Bar {\n+            () => { Foo<U32!(), U32!()> };\n+        }\n+\n+        trait Moo {\n+            type Ty;\n+        }\n+\n+        impl<T> Moo for T {\n+            type Ty = Bar!();\n+        }\n+\n+        type TayTo = Bar!();\n+\n+        fn main() {\n+            let a: <() as Moo>::Ty;\n+            let b: TayTo;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            228..277 '{     ...yTo; }': ()\n+            238..239 'a': Foo<u32, u32>\n+            266..267 'b': Foo<u32, u32>\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macros_in_type_position() {\n+    check_infer(\n+        r#\"\n+        struct Foo<A, B>(A, B);\n+\n+        macro_rules! U32 {\n+            () => { u32 };\n+        }\n+\n+        macro_rules! Bar {\n+            () => { Foo<U32!(), U32!()> };\n+        }\n+\n+        fn main() {\n+            let a: Bar!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            133..155 '{     ...!(); }': ()\n+            143..144 'a': Foo<u32, u32>\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macros_in_type_generics() {\n+    check_infer(\n+        r#\"\n+        struct Foo<A, B>(A, B);\n+\n+        macro_rules! U32 {\n+            () => { u32 };\n+        }\n+\n+        macro_rules! Bar {\n+            () => { Foo<U32!(), U32!()> };\n+        }\n+\n+        trait Moo {\n+            type Ty;\n+        }\n+\n+        impl<T> Moo for T {\n+            type Ty = Foo<Bar!(), Bar!()>;\n+        }\n+\n+        type TayTo = Foo<Bar!(), U32!()>;\n+\n+        fn main() {\n+            let a: <() as Moo>::Ty;\n+            let b: TayTo;\n+        }\n+        \"#,\n+        expect![[r#\"\n+            254..303 '{     ...yTo; }': ()\n+            264..265 'a': Foo<Foo<u32, u32>, Foo<u32, u32>>\n+            292..293 'b': Foo<Foo<u32, u32>, u32>\n+        \"#]],\n+    );\n+}"}, {"sha": "6ae3e734fe4218e331cfd532fd9210a149928597", "filename": "crates/parser/src/grammar/types.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -283,17 +283,21 @@ pub(super) fn path_type(p: &mut Parser) {\n // type B = crate::foo!();\n fn path_or_macro_type_(p: &mut Parser, allow_bounds: bool) {\n     assert!(paths::is_path_start(p));\n+    let r = p.start();\n     let m = p.start();\n+\n     paths::type_path(p);\n \n     let kind = if p.at(T![!]) && !p.at(T![!=]) {\n         items::macro_call_after_excl(p);\n-        MACRO_CALL\n+        m.complete(p, MACRO_CALL);\n+        MACRO_TYPE\n     } else {\n+        m.abandon(p);\n         PATH_TYPE\n     };\n \n-    let path = m.complete(p, kind);\n+    let path = r.complete(p, kind);\n \n     if allow_bounds {\n         opt_type_bounds_as_dyn_trait_type(p, path);\n@@ -319,7 +323,7 @@ pub(super) fn path_type_(p: &mut Parser, allow_bounds: bool) {\n fn opt_type_bounds_as_dyn_trait_type(p: &mut Parser, type_marker: CompletedMarker) {\n     assert!(matches!(\n         type_marker.kind(),\n-        SyntaxKind::PATH_TYPE | SyntaxKind::FOR_TYPE | SyntaxKind::MACRO_CALL\n+        SyntaxKind::PATH_TYPE | SyntaxKind::FOR_TYPE | SyntaxKind::MACRO_TYPE\n     ));\n     if !p.at(T![+]) {\n         return;"}, {"sha": "1ff3f7656a446b2a2471d4f04b1c875a06197f86", "filename": "crates/syntax/test_data/parser/inline/ok/0117_macro_call_type.rast", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0117_macro_call_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/cf3b4f1e208247c9d171273dabff9c6b3c98a240/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0117_macro_call_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0117_macro_call_type.rast?ref=cf3b4f1e208247c9d171273dabff9c6b3c98a240", "patch": "@@ -7,15 +7,16 @@ SOURCE_FILE@0..41\n     WHITESPACE@6..7 \" \"\n     EQ@7..8 \"=\"\n     WHITESPACE@8..9 \" \"\n-    MACRO_CALL@9..15\n-      PATH@9..12\n-        PATH_SEGMENT@9..12\n-          NAME_REF@9..12\n-            IDENT@9..12 \"foo\"\n-      BANG@12..13 \"!\"\n-      TOKEN_TREE@13..15\n-        L_PAREN@13..14 \"(\"\n-        R_PAREN@14..15 \")\"\n+    MACRO_TYPE@9..15\n+      MACRO_CALL@9..15\n+        PATH@9..12\n+          PATH_SEGMENT@9..12\n+            NAME_REF@9..12\n+              IDENT@9..12 \"foo\"\n+        BANG@12..13 \"!\"\n+        TOKEN_TREE@13..15\n+          L_PAREN@13..14 \"(\"\n+          R_PAREN@14..15 \")\"\n     SEMICOLON@15..16 \";\"\n   WHITESPACE@16..17 \"\\n\"\n   TYPE_ALIAS@17..40\n@@ -26,19 +27,20 @@ SOURCE_FILE@0..41\n     WHITESPACE@23..24 \" \"\n     EQ@24..25 \"=\"\n     WHITESPACE@25..26 \" \"\n-    MACRO_CALL@26..39\n-      PATH@26..36\n-        PATH@26..31\n-          PATH_SEGMENT@26..31\n-            NAME_REF@26..31\n-              CRATE_KW@26..31 \"crate\"\n-        COLON2@31..33 \"::\"\n-        PATH_SEGMENT@33..36\n-          NAME_REF@33..36\n-            IDENT@33..36 \"foo\"\n-      BANG@36..37 \"!\"\n-      TOKEN_TREE@37..39\n-        L_PAREN@37..38 \"(\"\n-        R_PAREN@38..39 \")\"\n+    MACRO_TYPE@26..39\n+      MACRO_CALL@26..39\n+        PATH@26..36\n+          PATH@26..31\n+            PATH_SEGMENT@26..31\n+              NAME_REF@26..31\n+                CRATE_KW@26..31 \"crate\"\n+          COLON2@31..33 \"::\"\n+          PATH_SEGMENT@33..36\n+            NAME_REF@33..36\n+              IDENT@33..36 \"foo\"\n+        BANG@36..37 \"!\"\n+        TOKEN_TREE@37..39\n+          L_PAREN@37..38 \"(\"\n+          R_PAREN@38..39 \")\"\n     SEMICOLON@39..40 \";\"\n   WHITESPACE@40..41 \"\\n\""}]}