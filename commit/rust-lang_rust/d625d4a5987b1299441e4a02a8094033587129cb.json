{"sha": "d625d4a5987b1299441e4a02a8094033587129cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MjVkNGE1OTg3YjEyOTk0NDFlNGEwMmE4MDk0MDMzNTg3MTI5Y2I=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-11T16:00:27Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-13T01:54:12Z"}, "message": "std: Add Option.{and,and_then,or,or_else}", "tree": {"sha": "814ae9707e9153e89471fd6f00de28162d689143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/814ae9707e9153e89471fd6f00de28162d689143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d625d4a5987b1299441e4a02a8094033587129cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d625d4a5987b1299441e4a02a8094033587129cb", "html_url": "https://github.com/rust-lang/rust/commit/d625d4a5987b1299441e4a02a8094033587129cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d625d4a5987b1299441e4a02a8094033587129cb/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7380b1ce7f7538ca6f6f61cc442f45e64622b902", "url": "https://api.github.com/repos/rust-lang/rust/commits/7380b1ce7f7538ca6f6f61cc442f45e64622b902", "html_url": "https://github.com/rust-lang/rust/commit/7380b1ce7f7538ca6f6f61cc442f45e64622b902"}], "stats": {"total": 93, "additions": 83, "deletions": 10}, "files": [{"sha": "24f44c8a2a8ec5ab7ca1b3e56ea727ffe1abb973", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d625d4a5987b1299441e4a02a8094033587129cb/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d625d4a5987b1299441e4a02a8094033587129cb/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=d625d4a5987b1299441e4a02a8094033587129cb", "patch": "@@ -635,7 +635,7 @@ impl BigUint {\n \n     // Converts this BigUint into an int, unless it would overflow.\n     pub fn to_int_opt(&self) -> Option<int> {\n-        self.to_uint_opt().chain(|n| {\n+        self.to_uint_opt().and_then(|n| {\n             // If top bit of uint is set, it's too large to convert to\n             // int.\n             if (n >> (2*BigDigit::bits - 1) != 0) {\n@@ -1221,7 +1221,7 @@ impl BigInt {\n         match self.sign {\n             Plus  => self.data.to_int_opt(),\n             Zero  => Some(0),\n-            Minus => self.data.to_uint_opt().chain(|n| {\n+            Minus => self.data.to_uint_opt().and_then(|n| {\n                 let m: uint = 1 << (2*BigDigit::bits-1);\n                 if (n > m) {\n                     None"}, {"sha": "761ad71a2699353b868d70593681b39a47eb35c2", "filename": "src/libstd/option.rs", "status": "modified", "additions": 81, "deletions": 8, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d625d4a5987b1299441e4a02a8094033587129cb/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d625d4a5987b1299441e4a02a8094033587129cb/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=d625d4a5987b1299441e4a02a8094033587129cb", "patch": "@@ -127,22 +127,51 @@ impl<T> Option<T> {\n     #[inline]\n     pub fn is_some(&self) -> bool { !self.is_none() }\n \n-    /// Update an optional value by optionally running its content through a\n-    /// function that returns an option.\n+    /// Returns `None` if the option is `None`, otherwise returns `optb`.\n     #[inline]\n-    pub fn chain<U>(self, f: &fn(t: T) -> Option<U>) -> Option<U> {\n+    pub fn and(self, optb: Option<T>) -> Option<T> {\n         match self {\n-            Some(t) => f(t),\n-            None => None\n+            Some(_) => optb,\n+            None => None,\n+        }\n+    }\n+\n+    /// Returns `None` if the option is `None`, otherwise calls and returns the\n+    /// value of `f`.\n+    #[inline]\n+    pub fn and_then(self, f: &fn() -> Option<T>) -> Option<T> {\n+        match self {\n+            Some(_) => f(),\n+            None => None,\n         }\n     }\n \n-    /// Returns the leftmost Some() value, or None if both are None.\n+    /// Returns the option if it contains a value, otherwise returns `optb`.\n     #[inline]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n-            Some(opta) => Some(opta),\n-            _ => optb\n+            Some(_) => self,\n+            None => optb\n+        }\n+    }\n+\n+    /// Returns the option if it contains a value, otherwise calls and returns the\n+    /// value of `f`.\n+    #[inline]\n+    pub fn or_else(self, f: &fn() -> Option<T>) -> Option<T> {\n+        match self {\n+            Some(_) => self,\n+            None => f(),\n+        }\n+    }\n+\n+    /// Update an optional value by optionally running its content through a\n+    /// function that returns an option.\n+    #[inline]\n+    pub fn chain<U>(self, f: &fn(T) -> Option<U>) -> Option<U> {\n+        match self {\n+            Some(t) => f(t),\n+            None => None\n         }\n     }\n \n@@ -509,6 +538,50 @@ mod tests {\n         let _y3 = y.take_unwrap();\n     }\n \n+    #[test]\n+    fn test_and() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.and(Some(2)), Some(2));\n+        assert_eq!(x.and(None), None);\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.and(Some(2)), None);\n+        assert_eq!(x.and(None), None);\n+    }\n+\n+    #[test]\n+    fn test_and_then() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.and_then(|| Some(2)), Some(2));\n+        assert_eq!(x.and_then(|| None), None);\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.and_then(|| Some(2)), None);\n+        assert_eq!(x.and_then(|| None), None);\n+    }\n+\n+    #[test]\n+    fn test_or() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.or(Some(2)), Some(1));\n+        assert_eq!(x.or(None), Some(1));\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.or(Some(2)), Some(2));\n+        assert_eq!(x.or(None), None);\n+    }\n+\n+    #[test]\n+    fn test_or_else() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.or_else(|| Some(2)), Some(1));\n+        assert_eq!(x.or_else(|| None), Some(1));\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.or_else(|| Some(2)), Some(2));\n+        assert_eq!(x.or_else(|| None), None);\n+    }\n+\n     #[test]\n     fn test_option_while_some() {\n         let mut i = 0;"}]}