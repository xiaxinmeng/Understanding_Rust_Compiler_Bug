{"sha": "24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "node_id": "C_kwDOAAsO6NoAKDI0YWM2YTI2YmNmNWJlMWFjODQxZTdmZTk2OWJkOTkyYjM0NjFmOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-05T14:48:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-05T14:48:17Z"}, "message": "Auto merge of #102704 - Dylan-DPC:rollup-66ff8sm, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #100986 (Stop suggesting adding generic args for turbofish)\n - #101061 (panic-on-uninit: adjust checks to 0x01-filling)\n - #102440 (Only export `__tls_*` on wasm32-unknown-unknown.)\n - #102496 (Suggest `.into()` when all other coercion suggestions fail)\n - #102699 (Fix hamburger button color)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e3445397f4accfe91104d99a1866c034943b75cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3445397f4accfe91104d99a1866c034943b75cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "html_url": "https://github.com/rust-lang/rust/commit/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c71b67159e1a3d0863caf28b7cefee0160cb927", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c71b67159e1a3d0863caf28b7cefee0160cb927", "html_url": "https://github.com/rust-lang/rust/commit/8c71b67159e1a3d0863caf28b7cefee0160cb927"}, {"sha": "4c644cdbf6b0ab4cd4c6861682212c1e53cb5b57", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c644cdbf6b0ab4cd4c6861682212c1e53cb5b57", "html_url": "https://github.com/rust-lang/rust/commit/4c644cdbf6b0ab4cd4c6861682212c1e53cb5b57"}], "stats": {"total": 1008, "additions": 666, "deletions": 342}, "files": [{"sha": "2cd746ccb6a6ee5d28ea3e23e718bc6a04f4a262", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -1180,16 +1180,19 @@ impl<'a> WasmLd<'a> {\n         //   sharing memory and instantiating the module multiple times. As a\n         //   result if it were exported then we'd just have no sharing.\n         //\n-        // * `--export=*tls*` - when `#[thread_local]` symbols are used these\n-        //   symbols are how the TLS segments are initialized and configured.\n+        // On wasm32-unknown-unknown, we also export symbols for glue code to use:\n+        //    * `--export=*tls*` - when `#[thread_local]` symbols are used these\n+        //      symbols are how the TLS segments are initialized and configured.\n         if sess.target_features.contains(&sym::atomics) {\n             cmd.arg(\"--shared-memory\");\n             cmd.arg(\"--max-memory=1073741824\");\n             cmd.arg(\"--import-memory\");\n-            cmd.arg(\"--export=__wasm_init_tls\");\n-            cmd.arg(\"--export=__tls_size\");\n-            cmd.arg(\"--export=__tls_align\");\n-            cmd.arg(\"--export=__tls_base\");\n+            if sess.target.os == \"unknown\" {\n+                cmd.arg(\"--export=__wasm_init_tls\");\n+                cmd.arg(\"--export=__tls_size\");\n+                cmd.arg(\"--export=__tls_align\");\n+                cmd.arg(\"--export=__tls_base\");\n+            }\n         }\n         WasmLd { cmd, sess }\n     }"}, {"sha": "230f841cf4d57df80d22ffaebfa298e4e004331a", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -32,7 +32,6 @@ extern crate rustc_middle;\n pub mod const_eval;\n mod errors;\n pub mod interpret;\n-mod might_permit_raw_init;\n pub mod transform;\n pub mod util;\n \n@@ -61,7 +60,6 @@ pub fn provide(providers: &mut Providers) {\n         const_eval::deref_mir_constant(tcx, param_env, value)\n     };\n     providers.permits_uninit_init =\n-        |tcx, ty| might_permit_raw_init::might_permit_raw_init(tcx, ty, InitKind::Uninit);\n-    providers.permits_zero_init =\n-        |tcx, ty| might_permit_raw_init::might_permit_raw_init(tcx, ty, InitKind::Zero);\n+        |tcx, ty| util::might_permit_raw_init(tcx, ty, InitKind::UninitMitigated0x01Fill);\n+    providers.permits_zero_init = |tcx, ty| util::might_permit_raw_init(tcx, ty, InitKind::Zero);\n }"}, {"sha": "37ffa19ccd6b9d7097c431545641129fdac547b6", "filename": "compiler/rustc_const_eval/src/might_permit_raw_init.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8c71b67159e1a3d0863caf28b7cefee0160cb927/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c71b67159e1a3d0863caf28b7cefee0160cb927/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs?ref=8c71b67159e1a3d0863caf28b7cefee0160cb927", "patch": "@@ -1,44 +0,0 @@\n-use crate::const_eval::CompileTimeInterpreter;\n-use crate::interpret::{InterpCx, MemoryKind, OpTy};\n-use rustc_middle::ty::layout::LayoutCx;\n-use rustc_middle::ty::{layout::TyAndLayout, ParamEnv, TyCtxt};\n-use rustc_session::Limit;\n-use rustc_target::abi::InitKind;\n-\n-pub fn might_permit_raw_init<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: TyAndLayout<'tcx>,\n-    kind: InitKind,\n-) -> bool {\n-    let strict = tcx.sess.opts.unstable_opts.strict_init_checks;\n-\n-    if strict {\n-        let machine = CompileTimeInterpreter::new(\n-            Limit::new(0),\n-            /*can_access_statics:*/ false,\n-            /*check_alignment:*/ true,\n-        );\n-\n-        let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);\n-\n-        let allocated = cx\n-            .allocate(ty, MemoryKind::Machine(crate::const_eval::MemoryKind::Heap))\n-            .expect(\"OOM: failed to allocate for uninit check\");\n-\n-        if kind == InitKind::Zero {\n-            cx.write_bytes_ptr(\n-                allocated.ptr,\n-                std::iter::repeat(0_u8).take(ty.layout.size().bytes_usize()),\n-            )\n-            .expect(\"failed to write bytes for zero valid check\");\n-        }\n-\n-        let ot: OpTy<'_, _> = allocated.into();\n-\n-        // Assume that if it failed, it's a validation failure.\n-        cx.validate_operand(&ot).is_ok()\n-    } else {\n-        let layout_cx = LayoutCx { tcx, param_env: ParamEnv::reveal_all() };\n-        ty.might_permit_raw_init(&layout_cx, kind)\n-    }\n-}"}, {"sha": "6ca71223391d2a5828b39b655cb113473cd0e46f", "filename": "compiler/rustc_const_eval/src/util/might_permit_raw_init.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -0,0 +1,151 @@\n+use rustc_middle::ty::layout::{LayoutCx, LayoutOf, TyAndLayout};\n+use rustc_middle::ty::{ParamEnv, TyCtxt};\n+use rustc_session::Limit;\n+use rustc_target::abi::{Abi, FieldsShape, InitKind, Scalar, Variants};\n+\n+use crate::const_eval::CompileTimeInterpreter;\n+use crate::interpret::{InterpCx, MemoryKind, OpTy};\n+\n+/// Determines if this type permits \"raw\" initialization by just transmuting some memory into an\n+/// instance of `T`.\n+///\n+/// `init_kind` indicates if the memory is zero-initialized or left uninitialized. We assume\n+/// uninitialized memory is mitigated by filling it with 0x01, which reduces the chance of causing\n+/// LLVM UB.\n+///\n+/// By default we check whether that operation would cause *LLVM UB*, i.e., whether the LLVM IR we\n+/// generate has UB or not. This is a mitigation strategy, which is why we are okay with accepting\n+/// Rust UB as long as there is no risk of miscompilations. The `strict_init_checks` can be set to\n+/// do a full check against Rust UB instead (in which case we will also ignore the 0x01-filling and\n+/// to the full uninit check).\n+pub fn might_permit_raw_init<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: TyAndLayout<'tcx>,\n+    kind: InitKind,\n+) -> bool {\n+    if tcx.sess.opts.unstable_opts.strict_init_checks {\n+        might_permit_raw_init_strict(ty, tcx, kind)\n+    } else {\n+        let layout_cx = LayoutCx { tcx, param_env: ParamEnv::reveal_all() };\n+        might_permit_raw_init_lax(ty, &layout_cx, kind)\n+    }\n+}\n+\n+/// Implements the 'strict' version of the `might_permit_raw_init` checks; see that function for\n+/// details.\n+fn might_permit_raw_init_strict<'tcx>(\n+    ty: TyAndLayout<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    kind: InitKind,\n+) -> bool {\n+    let machine = CompileTimeInterpreter::new(\n+        Limit::new(0),\n+        /*can_access_statics:*/ false,\n+        /*check_alignment:*/ true,\n+    );\n+\n+    let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);\n+\n+    let allocated = cx\n+        .allocate(ty, MemoryKind::Machine(crate::const_eval::MemoryKind::Heap))\n+        .expect(\"OOM: failed to allocate for uninit check\");\n+\n+    if kind == InitKind::Zero {\n+        cx.write_bytes_ptr(\n+            allocated.ptr,\n+            std::iter::repeat(0_u8).take(ty.layout.size().bytes_usize()),\n+        )\n+        .expect(\"failed to write bytes for zero valid check\");\n+    }\n+\n+    let ot: OpTy<'_, _> = allocated.into();\n+\n+    // Assume that if it failed, it's a validation failure.\n+    // This does *not* actually check that references are dereferenceable, but since all types that\n+    // require dereferenceability also require non-null, we don't actually get any false negatives\n+    // due to this.\n+    cx.validate_operand(&ot).is_ok()\n+}\n+\n+/// Implements the 'lax' (default) version of the `might_permit_raw_init` checks; see that function for\n+/// details.\n+fn might_permit_raw_init_lax<'tcx>(\n+    this: TyAndLayout<'tcx>,\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    init_kind: InitKind,\n+) -> bool {\n+    let scalar_allows_raw_init = move |s: Scalar| -> bool {\n+        match init_kind {\n+            InitKind::Zero => {\n+                // The range must contain 0.\n+                s.valid_range(cx).contains(0)\n+            }\n+            InitKind::UninitMitigated0x01Fill => {\n+                // The range must include an 0x01-filled buffer.\n+                let mut val: u128 = 0x01;\n+                for _ in 1..s.size(cx).bytes() {\n+                    // For sizes >1, repeat the 0x01.\n+                    val = (val << 8) | 0x01;\n+                }\n+                s.valid_range(cx).contains(val)\n+            }\n+        }\n+    };\n+\n+    // Check the ABI.\n+    let valid = match this.abi {\n+        Abi::Uninhabited => false, // definitely UB\n+        Abi::Scalar(s) => scalar_allows_raw_init(s),\n+        Abi::ScalarPair(s1, s2) => scalar_allows_raw_init(s1) && scalar_allows_raw_init(s2),\n+        Abi::Vector { element: s, count } => count == 0 || scalar_allows_raw_init(s),\n+        Abi::Aggregate { .. } => true, // Fields are checked below.\n+    };\n+    if !valid {\n+        // This is definitely not okay.\n+        return false;\n+    }\n+\n+    // Special magic check for references and boxes (i.e., special pointer types).\n+    if let Some(pointee) = this.ty.builtin_deref(false) {\n+        let pointee = cx.layout_of(pointee.ty).expect(\"need to be able to compute layouts\");\n+        // We need to ensure that the LLVM attributes `aligned` and `dereferenceable(size)` are satisfied.\n+        if pointee.align.abi.bytes() > 1 {\n+            // 0x01-filling is not aligned.\n+            return false;\n+        }\n+        if pointee.size.bytes() > 0 {\n+            // A 'fake' integer pointer is not sufficiently dereferenceable.\n+            return false;\n+        }\n+    }\n+\n+    // If we have not found an error yet, we need to recursively descend into fields.\n+    match &this.fields {\n+        FieldsShape::Primitive | FieldsShape::Union { .. } => {}\n+        FieldsShape::Array { .. } => {\n+            // Arrays never have scalar layout in LLVM, so if the array is not actually\n+            // accessed, there is no LLVM UB -- therefore we can skip this.\n+        }\n+        FieldsShape::Arbitrary { offsets, .. } => {\n+            for idx in 0..offsets.len() {\n+                if !might_permit_raw_init_lax(this.field(cx, idx), cx, init_kind) {\n+                    // We found a field that is unhappy with this kind of initialization.\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n+\n+    match &this.variants {\n+        Variants::Single { .. } => {\n+            // All fields of this single variant have already been checked above, there is nothing\n+            // else to do.\n+        }\n+        Variants::Multiple { .. } => {\n+            // We cannot tell LLVM anything about the details of this multi-variant layout, so\n+            // invalid values \"hidden\" inside the variant cannot cause LLVM trouble.\n+        }\n+    }\n+\n+    true\n+}"}, {"sha": "7a05cfd235faecd03dfce3339459ccd6f79c1ce8", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -3,8 +3,10 @@ mod alignment;\n mod call_kind;\n pub mod collect_writes;\n mod find_self_call;\n+mod might_permit_raw_init;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n pub use self::find_self_call::find_self_call;\n+pub use self::might_permit_raw_init::might_permit_raw_init;"}, {"sha": "d396c801c09ccda7c6659e9f89408f4f11a20c7e", "filename": "compiler/rustc_hir_analysis/src/check/demand.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -32,17 +32,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         error: Option<TypeError<'tcx>>,\n     ) {\n         self.annotate_expected_due_to_let_ty(err, expr, error);\n-        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr);\n-        self.suggest_compatible_variants(err, expr, expected, expr_ty);\n-        self.suggest_non_zero_new_unwrap(err, expr, expected, expr_ty);\n-        if self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty) {\n-            return;\n-        }\n-        self.suggest_no_capture_closure(err, expected, expr_ty);\n-        self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n-        self.suggest_missing_parentheses(err, expr);\n-        self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected);\n-        self.suggest_copied_or_cloned(err, expr, expr_ty, expected);\n+\n+        // Use `||` to give these suggestions a precedence\n+        let _ = self.suggest_missing_parentheses(err, expr)\n+            || self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr)\n+            || self.suggest_compatible_variants(err, expr, expected, expr_ty)\n+            || self.suggest_non_zero_new_unwrap(err, expr, expected, expr_ty)\n+            || self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty)\n+            || self.suggest_no_capture_closure(err, expected, expr_ty)\n+            || self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty)\n+            || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n+            || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n+            || self.suggest_into(err, expr, expr_ty, expected);\n+\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n@@ -286,7 +288,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         expr_ty: Ty<'tcx>,\n-    ) {\n+    ) -> bool {\n         if let ty::Adt(expected_adt, substs) = expected.kind() {\n             if let hir::ExprKind::Field(base, ident) = expr.kind {\n                 let base_ty = self.typeck_results.borrow().expr_ty(base);\n@@ -299,7 +301,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"\",\n                         Applicability::MaybeIncorrect,\n                     );\n-                    return\n+                    return true;\n                 }\n             }\n \n@@ -338,7 +340,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             } else if self.tcx.is_diagnostic_item(sym::Option, expected_adt.did()) {\n                                 vec![\"None\", \"Some(())\"]\n                             } else {\n-                                return;\n+                                return false;\n                             };\n                             if let Some(indent) =\n                                 self.tcx.sess.source_map().indentation_before(span.shrink_to_lo())\n@@ -358,7 +360,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n-                            return;\n+                            return true;\n                         }\n                     }\n                 }\n@@ -445,6 +447,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         suggestions_for(&**variant, *ctor_kind, *field_name),\n                         Applicability::MaybeIncorrect,\n                     );\n+                    return true;\n                 }\n                 _ => {\n                     // More than one matching variant.\n@@ -460,9 +463,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ),\n                         Applicability::MaybeIncorrect,\n                     );\n+                    return true;\n                 }\n             }\n         }\n+\n+        false\n     }\n \n     fn suggest_non_zero_new_unwrap(\n@@ -471,19 +477,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         expr_ty: Ty<'tcx>,\n-    ) {\n+    ) -> bool {\n         let tcx = self.tcx;\n         let (adt, unwrap) = match expected.kind() {\n             // In case Option<NonZero*> is wanted, but * is provided, suggest calling new\n             ty::Adt(adt, substs) if tcx.is_diagnostic_item(sym::Option, adt.did()) => {\n                 // Unwrap option\n-                let ty::Adt(adt, _) = substs.type_at(0).kind() else { return };\n+                let ty::Adt(adt, _) = substs.type_at(0).kind() else { return false; };\n \n                 (adt, \"\")\n             }\n             // In case NonZero* is wanted, but * is provided also add `.unwrap()` to satisfy types\n             ty::Adt(adt, _) => (adt, \".unwrap()\"),\n-            _ => return,\n+            _ => return false,\n         };\n \n         let map = [\n@@ -502,7 +508,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let Some((s, _)) = map\n             .iter()\n             .find(|&&(s, t)| self.tcx.is_diagnostic_item(s, adt.did()) && self.can_coerce(expr_ty, t))\n-            else { return };\n+            else { return false; };\n \n         let path = self.tcx.def_path_str(adt.non_enum_variant().def_id);\n \n@@ -514,6 +520,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ],\n             Applicability::MaybeIncorrect,\n         );\n+\n+        true\n     }\n \n     pub fn get_conversion_methods("}, {"sha": "09890c55cd36a1a7ecfd44f3d4407e090bf31026", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 92, "deletions": 17, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -3,7 +3,7 @@ use crate::astconv::AstConv;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n use hir::def_id::DefId;\n-use rustc_ast::util::parser::ExprPrecedence;\n+use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n-    ) {\n+    ) -> bool {\n         let expr = expr.peel_blocks();\n         if let Some((sp, msg, suggestion, applicability, verbose)) =\n             self.check_ref(expr, found, expected)\n@@ -337,14 +337,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 err.span_suggestion(sp, &msg, suggestion, applicability);\n             }\n+            return true;\n         } else if self.suggest_else_fn_with_closure(err, expr, found, expected)\n         {\n+            return true;\n         } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n             && let ty::FnDef(def_id, ..) = &found.kind()\n             && let Some(sp) = self.tcx.hir().span_if_local(*def_id)\n         {\n             err.span_label(sp, format!(\"{found} defined here\"));\n-        } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n+            return true;\n+        } else if self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n+            return true;\n+        } else {\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if !methods.is_empty() {\n                 let mut suggestions = methods.iter()\n@@ -395,6 +400,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         suggestions,\n                         Applicability::MaybeIncorrect,\n                     );\n+                    return true;\n                 }\n             } else if let ty::Adt(found_adt, found_substs) = found.kind()\n                 && self.tcx.is_diagnostic_item(sym::Option, found_adt.did())\n@@ -419,9 +425,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         format!(\".map(|x| &*{}x)\", \"*\".repeat(ref_cnt)),\n                         Applicability::MaybeIncorrect,\n                     );\n+                    return true;\n                 }\n             }\n         }\n+\n+        false\n     }\n \n     /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n@@ -432,13 +441,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n-    ) {\n+    ) -> bool {\n         if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n             // Do not suggest `Box::new` in const context.\n-            return;\n+            return false;\n         }\n         if !expected.is_box() || found.is_box() {\n-            return;\n+            return false;\n         }\n         let boxed_found = self.tcx.mk_box(found);\n         if self.can_coerce(boxed_found, expected) {\n@@ -456,6 +465,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                  https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n                  https://doc.rust-lang.org/std/boxed/index.html\",\n             );\n+            true\n+        } else {\n+            false\n         }\n     }\n \n@@ -466,7 +478,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n-    ) {\n+    ) -> bool {\n         if let (ty::FnPtr(_), ty::Closure(def_id, _)) = (expected.kind(), found.kind()) {\n             if let Some(upvars) = self.tcx.upvars_mentioned(*def_id) {\n                 // Report upto four upvars being captured to reduce the amount error messages\n@@ -490,8 +502,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     multi_span,\n                     \"closures can only be coerced to `fn` types if they do not capture any variables\"\n                 );\n+                return true;\n             }\n         }\n+        false\n     }\n \n     /// When encountering an `impl Future` where `BoxFuture` is expected, suggest `Box::pin`.\n@@ -893,11 +907,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-    ) {\n+    ) -> bool {\n         let sp = self.tcx.sess.source_map().start_point(expr.span);\n         if let Some(sp) = self.tcx.sess.parse_sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n             // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`\n             err.subdiagnostic(ExprParenthesesNeeded::surrounding(*sp));\n+            true\n+        } else {\n+            false\n         }\n     }\n \n@@ -910,7 +927,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         mut expr: &hir::Expr<'_>,\n         mut expr_ty: Ty<'tcx>,\n         mut expected_ty: Ty<'tcx>,\n-    ) {\n+    ) -> bool {\n         loop {\n             match (&expr.kind, expr_ty.kind(), expected_ty.kind()) {\n                 (\n@@ -924,9 +941,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 (hir::ExprKind::Block(blk, _), _, _) => {\n                     self.suggest_block_to_brackets(diag, *blk, expr_ty, expected_ty);\n-                    break;\n+                    break true;\n                 }\n-                _ => break,\n+                _ => break false,\n             }\n         }\n     }\n@@ -937,11 +954,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expr_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n-    ) {\n-        let ty::Adt(adt_def, substs) = expr_ty.kind() else { return; };\n-        let ty::Adt(expected_adt_def, expected_substs) = expected_ty.kind() else { return; };\n+    ) -> bool {\n+        let ty::Adt(adt_def, substs) = expr_ty.kind() else { return false; };\n+        let ty::Adt(expected_adt_def, expected_substs) = expected_ty.kind() else { return false; };\n         if adt_def != expected_adt_def {\n-            return;\n+            return false;\n         }\n \n         let mut suggest_copied_or_cloned = || {\n@@ -960,6 +977,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \".copied()\",\n                         Applicability::MachineApplicable,\n                     );\n+                    return true;\n                 } else if let Some(clone_did) = self.tcx.lang_items().clone_trait()\n                     && rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions(\n                         self,\n@@ -977,21 +995,78 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \".cloned()\",\n                         Applicability::MachineApplicable,\n                     );\n+                    return true;\n                 }\n             }\n+            false\n         };\n \n         if let Some(result_did) = self.tcx.get_diagnostic_item(sym::Result)\n             && adt_def.did() == result_did\n             // Check that the error types are equal\n             && self.can_eq(self.param_env, substs.type_at(1), expected_substs.type_at(1)).is_ok()\n         {\n-            suggest_copied_or_cloned();\n+            return suggest_copied_or_cloned();\n         } else if let Some(option_did) = self.tcx.get_diagnostic_item(sym::Option)\n             && adt_def.did() == option_did\n         {\n-            suggest_copied_or_cloned();\n+            return suggest_copied_or_cloned();\n+        }\n+\n+        false\n+    }\n+\n+    pub(crate) fn suggest_into(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expr_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        let expr = expr.peel_blocks();\n+\n+        // We have better suggestions for scalar interconversions...\n+        if expr_ty.is_scalar() && expected_ty.is_scalar() {\n+            return false;\n         }\n+\n+        // Don't suggest turning a block into another type (e.g. `{}.into()`)\n+        if matches!(expr.kind, hir::ExprKind::Block(..)) {\n+            return false;\n+        }\n+\n+        // We'll later suggest `.as_ref` when noting the type error,\n+        // so skip if we will suggest that instead.\n+        if self.should_suggest_as_ref(expected_ty, expr_ty).is_some() {\n+            return false;\n+        }\n+\n+        if let Some(into_def_id) = self.tcx.get_diagnostic_item(sym::Into)\n+            && self.predicate_must_hold_modulo_regions(&traits::Obligation::new(\n+                self.misc(expr.span),\n+                self.param_env,\n+                ty::Binder::dummy(ty::TraitRef {\n+                    def_id: into_def_id,\n+                    substs: self.tcx.mk_substs_trait(expr_ty, &[expected_ty.into()]),\n+                })\n+                .to_poly_trait_predicate()\n+                .to_predicate(self.tcx),\n+            ))\n+        {\n+            let sugg = if expr.precedence().order() >= PREC_POSTFIX {\n+                vec![(expr.span.shrink_to_hi(), \".into()\".to_owned())]\n+            } else {\n+                vec![(expr.span.shrink_to_lo(), \"(\".to_owned()), (expr.span.shrink_to_hi(), \").into()\".to_owned())]\n+            };\n+            diag.multipart_suggestion(\n+                format!(\"call `Into::into` on this expression to convert `{expr_ty}` into `{expected_ty}`\"),\n+                sugg,\n+                Applicability::MaybeIncorrect\n+            );\n+            return true;\n+        }\n+\n+        false\n     }\n \n     /// Suggest wrapping the block in square brackets instead of curly braces"}, {"sha": "9d56764d4897048ab97fbef070b7afe718d9627e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -2158,8 +2158,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n         diag: &mut Diagnostic,\n     ) {\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n+        {\n+            diag.span_suggestion(\n+                span,\n+                msg,\n+                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n+                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n+    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n         if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n-            (exp_found.expected.kind(), exp_found.found.kind())\n+            (expected.kind(), found.kind())\n         {\n             if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n                 if exp_def == &found_def {\n@@ -2197,21 +2211,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 _ => show_suggestion = false,\n                             }\n                         }\n-                        if let (Ok(snippet), true) =\n-                            (self.tcx.sess.source_map().span_to_snippet(span), show_suggestion)\n-                        {\n-                            diag.span_suggestion(\n-                                span,\n-                                *msg,\n-                                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n-                                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n-                                Applicability::MachineApplicable,\n-                            );\n+                        if show_suggestion {\n+                            return Some(*msg);\n                         }\n                     }\n                 }\n             }\n         }\n+        None\n     }\n \n     pub fn report_and_explain_type_error("}, {"sha": "2775d14a847808c7767b97cfefc52a0f24d006dd", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -435,6 +435,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 generics_def_id,\n                 def_id: _,\n                 generic_args,\n+                have_turbofish,\n             } => {\n                 let generics = self.tcx.generics_of(generics_def_id);\n                 let is_type = matches!(arg.unpack(), GenericArgKind::Type(_));\n@@ -482,11 +483,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     .unwrap()\n                     .into_buffer();\n \n-                infer_subdiags.push(SourceKindSubdiag::GenericSuggestion {\n-                    span: insert_span,\n-                    arg_count: generic_args.len(),\n-                    args,\n-                });\n+                if !have_turbofish {\n+                    infer_subdiags.push(SourceKindSubdiag::GenericSuggestion {\n+                        span: insert_span,\n+                        arg_count: generic_args.len(),\n+                        args,\n+                    });\n+                }\n             }\n             InferSourceKind::FullyQualifiedMethodCall { receiver, successor, substs, def_id } => {\n                 let printer = fmt_printer(self, Namespace::ValueNS);\n@@ -616,6 +619,7 @@ enum InferSourceKind<'tcx> {\n         generics_def_id: DefId,\n         def_id: DefId,\n         generic_args: &'tcx [GenericArg<'tcx>],\n+        have_turbofish: bool,\n     },\n     FullyQualifiedMethodCall {\n         receiver: &'tcx Expr<'tcx>,\n@@ -676,6 +680,7 @@ struct InsertableGenericArgs<'tcx> {\n     substs: SubstsRef<'tcx>,\n     generics_def_id: DefId,\n     def_id: DefId,\n+    have_turbofish: bool,\n }\n \n /// A visitor which searches for the \"best\" spot to use in the inference error.\n@@ -916,6 +921,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                             substs,\n                             generics_def_id: def_id,\n                             def_id,\n+                            have_turbofish: false,\n                         }\n                     };\n                     return Box::new(insertable.into_iter());\n@@ -933,6 +939,9 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> impl Iterator<Item = InsertableGenericArgs<'tcx>> + 'a {\n         let tcx = self.infcx.tcx;\n+        let have_turbofish = path.segments.iter().any(|segment| {\n+            segment.args.map_or(false, |args| args.args.iter().any(|arg| arg.is_ty_or_const()))\n+        });\n         // The last segment of a path often has `Res::Err` and the\n         // correct `Res` is the one of the whole path.\n         //\n@@ -942,7 +951,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n             let generics_def_id = tcx.res_generics_def_id(path.res)?;\n             let generics = tcx.generics_of(generics_def_id);\n             if generics.has_impl_trait() {\n-                None?\n+                None?;\n             }\n             let insert_span =\n                 path.segments.last().unwrap().ident.span.shrink_to_hi().with_hi(path.span.hi());\n@@ -951,6 +960,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                 substs,\n                 generics_def_id,\n                 def_id: path.res.def_id(),\n+                have_turbofish,\n             }\n         };\n \n@@ -970,6 +980,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                     substs,\n                     generics_def_id,\n                     def_id: res.def_id(),\n+                    have_turbofish,\n                 })\n             })\n             .chain(last_segment_using_path_data)\n@@ -998,7 +1009,13 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                     }\n                     let span = tcx.hir().span(segment.hir_id);\n                     let insert_span = segment.ident.span.shrink_to_hi().with_hi(span.hi());\n-                    InsertableGenericArgs { insert_span, substs, generics_def_id: def_id, def_id }\n+                    InsertableGenericArgs {\n+                        insert_span,\n+                        substs,\n+                        generics_def_id: def_id,\n+                        def_id,\n+                        have_turbofish: false,\n+                    }\n                 };\n \n                 let parent_def_id = generics.parent.unwrap();\n@@ -1121,7 +1138,13 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n \n         for args in self.expr_inferred_subst_iter(expr) {\n             debug!(?args);\n-            let InsertableGenericArgs { insert_span, substs, generics_def_id, def_id } = args;\n+            let InsertableGenericArgs {\n+                insert_span,\n+                substs,\n+                generics_def_id,\n+                def_id,\n+                have_turbofish,\n+            } = args;\n             let generics = tcx.generics_of(generics_def_id);\n             if let Some(argument_index) = generics\n                 .own_substs(substs)\n@@ -1144,6 +1167,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n                         generics_def_id,\n                         def_id,\n                         generic_args,\n+                        have_turbofish,\n                     },\n                 });\n             }"}, {"sha": "7171ca7bf89508cdfb65db31f743e70e01c97376", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -1392,7 +1392,7 @@ pub struct PointeeInfo {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum InitKind {\n     Zero,\n-    Uninit,\n+    UninitMitigated0x01Fill,\n }\n \n /// Trait that needs to be implemented by the higher-level type representation\n@@ -1498,72 +1498,4 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n             Abi::Aggregate { sized } => sized && self.size.bytes() == 0,\n         }\n     }\n-\n-    /// Determines if this type permits \"raw\" initialization by just transmuting some\n-    /// memory into an instance of `T`.\n-    ///\n-    /// `init_kind` indicates if the memory is zero-initialized or left uninitialized.\n-    ///\n-    /// This code is intentionally conservative, and will not detect\n-    /// * zero init of an enum whose 0 variant does not allow zero initialization\n-    /// * making uninitialized types who have a full valid range (ints, floats, raw pointers)\n-    /// * Any form of invalid value being made inside an array (unless the value is uninhabited)\n-    ///\n-    /// A strict form of these checks that uses const evaluation exists in\n-    /// `rustc_const_eval::might_permit_raw_init`, and a tracking issue for making these checks\n-    /// stricter is <https://github.com/rust-lang/rust/issues/66151>.\n-    ///\n-    /// FIXME: Once all the conservatism is removed from here, and the checks are ran by default,\n-    /// we can use the const evaluation checks always instead.\n-    pub fn might_permit_raw_init<C>(self, cx: &C, init_kind: InitKind) -> bool\n-    where\n-        Self: Copy,\n-        Ty: TyAbiInterface<'a, C>,\n-        C: HasDataLayout,\n-    {\n-        let scalar_allows_raw_init = move |s: Scalar| -> bool {\n-            match init_kind {\n-                InitKind::Zero => {\n-                    // The range must contain 0.\n-                    s.valid_range(cx).contains(0)\n-                }\n-                InitKind::Uninit => {\n-                    // The range must include all values.\n-                    s.is_always_valid(cx)\n-                }\n-            }\n-        };\n-\n-        // Check the ABI.\n-        let valid = match self.abi {\n-            Abi::Uninhabited => false, // definitely UB\n-            Abi::Scalar(s) => scalar_allows_raw_init(s),\n-            Abi::ScalarPair(s1, s2) => scalar_allows_raw_init(s1) && scalar_allows_raw_init(s2),\n-            Abi::Vector { element: s, count } => count == 0 || scalar_allows_raw_init(s),\n-            Abi::Aggregate { .. } => true, // Fields are checked below.\n-        };\n-        if !valid {\n-            // This is definitely not okay.\n-            return false;\n-        }\n-\n-        // If we have not found an error yet, we need to recursively descend into fields.\n-        match &self.fields {\n-            FieldsShape::Primitive | FieldsShape::Union { .. } => {}\n-            FieldsShape::Array { .. } => {\n-                // FIXME(#66151): For now, we are conservative and do not check arrays by default.\n-            }\n-            FieldsShape::Arbitrary { offsets, .. } => {\n-                for idx in 0..offsets.len() {\n-                    if !self.field(cx, idx).might_permit_raw_init(cx, init_kind) {\n-                        // We found a field that is unhappy with this kind of initialization.\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // FIXME(#66151): For now, we are conservative and do not check `self.variants`.\n-        true\n-    }\n }"}, {"sha": "140ce3ba9fc1eaac8a7f135be16daa7ae802b5cf", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -1826,6 +1826,7 @@ in storage.js plus the media query with (min-width: 701px)\n \t\t   as an icon, it's okay to specify its sizes in pixels. */\n \t\tfont-size: 32px;\n \t\tborder: none;\n+\t\tcolor: var(--main-color);\n \t}\n \n \t.sidebar-elems {"}, {"sha": "04dcb532504b52b38c50eebb81ffd16205a0e5f6", "filename": "src/test/rustdoc-gui/sidebar-mobile.goml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -42,23 +42,24 @@ scroll-to: \".block.keyword li:nth-child(1)\"\n compare-elements-position-near: (\".block.keyword li:nth-child(1)\", \".mobile-topbar\", {\"y\": 543})\n \n // Now checking the background color of the sidebar.\n+show-text: true\n local-storage: {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": \"dark\"}\n reload:\n \n // Open the sidebar menu.\n click: \".sidebar-menu-toggle\"\n-assert-css: (\".sidebar\", {\"background-color\": \"rgb(80, 80, 80)\"})\n+assert-css: (\".sidebar\", {\"background-color\": \"rgb(80, 80, 80)\", \"color\": \"rgb(221, 221, 221)\"})\n \n local-storage: {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": \"ayu\"}\n reload:\n \n // Open the sidebar menu.\n click: \".sidebar-menu-toggle\"\n-assert-css: (\".sidebar\", {\"background-color\": \"rgb(20, 25, 31)\"})\n+assert-css: (\".sidebar\", {\"background-color\": \"rgb(20, 25, 31)\", \"color\": \"rgb(197, 197, 197)\"})\n \n local-storage: {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": \"light\"}\n reload:\n \n // Open the sidebar menu.\n click: \".sidebar-menu-toggle\"\n-assert-css: (\".sidebar\", {\"background-color\": \"rgb(245, 245, 245)\"})\n+assert-css: (\".sidebar\", {\"background-color\": \"rgb(245, 245, 245)\", \"color\": \"rgb(0, 0, 0)\"})"}, {"sha": "6b5612dda90a7c371d67dd40a244849625bfe609", "filename": "src/test/ui/consts/assert-type-intrinsics.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -11,12 +11,15 @@ fn main() {\n     use std::mem::MaybeUninit;\n \n     const _BAD1: () = unsafe {\n-        MaybeUninit::<!>::uninit().assume_init();\n+        intrinsics::assert_inhabited::<!>(); //~ERROR: any use of this value will cause an error\n+        //~^WARN: previously accepted\n     };\n     const _BAD2: () = {\n-        intrinsics::assert_uninit_valid::<bool>();\n+        intrinsics::assert_uninit_valid::<!>(); //~ERROR: any use of this value will cause an error\n+        //~^WARN: previously accepted\n     };\n     const _BAD3: () = {\n-        intrinsics::assert_zero_valid::<&'static i32>();\n+        intrinsics::assert_zero_valid::<&'static i32>(); //~ERROR: any use of this value will cause an error\n+        //~^WARN: previously accepted\n     };\n }"}, {"sha": "9f97d8367056fd765c59f37bded695375e18d03c", "filename": "src/test/ui/consts/assert-type-intrinsics.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fassert-type-intrinsics.stderr?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -3,26 +3,26 @@ error: any use of this value will cause an error\n    |\n LL |     const _BAD1: () = unsafe {\n    |     ---------------\n-LL |         MaybeUninit::<!>::uninit().assume_init();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n+LL |         intrinsics::assert_inhabited::<!>();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n    = note: `#[deny(const_err)]` on by default\n \n error: any use of this value will cause an error\n-  --> $DIR/assert-type-intrinsics.rs:17:9\n+  --> $DIR/assert-type-intrinsics.rs:18:9\n    |\n LL |     const _BAD2: () = {\n    |     ---------------\n-LL |         intrinsics::assert_uninit_valid::<bool>();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to leave type `bool` uninitialized, which is invalid\n+LL |         intrinsics::assert_uninit_valid::<!>();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/assert-type-intrinsics.rs:20:9\n+  --> $DIR/assert-type-intrinsics.rs:22:9\n    |\n LL |     const _BAD3: () = {\n    |     ---------------\n@@ -40,29 +40,29 @@ error: any use of this value will cause an error\n    |\n LL |     const _BAD1: () = unsafe {\n    |     ---------------\n-LL |         MaybeUninit::<!>::uninit().assume_init();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n+LL |         intrinsics::assert_inhabited::<!>();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n    = note: `#[deny(const_err)]` on by default\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/assert-type-intrinsics.rs:17:9\n+  --> $DIR/assert-type-intrinsics.rs:18:9\n    |\n LL |     const _BAD2: () = {\n    |     ---------------\n-LL |         intrinsics::assert_uninit_valid::<bool>();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to leave type `bool` uninitialized, which is invalid\n+LL |         intrinsics::assert_uninit_valid::<!>();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ aborted execution: attempted to instantiate uninhabited type `!`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n    = note: `#[deny(const_err)]` on by default\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/assert-type-intrinsics.rs:20:9\n+  --> $DIR/assert-type-intrinsics.rs:22:9\n    |\n LL |     const _BAD3: () = {\n    |     ---------------"}, {"sha": "aa32969950d6bd677b5f308e14e844f740f2f4f1", "filename": "src/test/ui/inference/need_type_info/concrete-impl.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fconcrete-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fconcrete-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fconcrete-impl.stderr?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -3,11 +3,6 @@ error[E0282]: type annotations needed\n    |\n LL |     <Struct as Ambiguous<_>>::method();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `Self` declared on the trait `Ambiguous`\n-   |\n-help: consider specifying the generic argument\n-   |\n-LL |     <Struct as Ambiguous::<_>>::method();\n-   |                         ~~~~~\n \n error[E0283]: type annotations needed\n   --> $DIR/concrete-impl.rs:13:5\n@@ -22,10 +17,6 @@ LL | impl Ambiguous<One> for Struct {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL | impl Ambiguous<Two> for Struct {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: consider specifying the generic argument\n-   |\n-LL |     <Struct as Ambiguous::<_>>::method();\n-   |                         ~~~~~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3084f6eac67ab7e4e9858fcc220be646b86f4377", "filename": "src/test/ui/inference/need_type_info/do-not-suggest-generic-arguments-for-turbofish.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fdo-not-suggest-generic-arguments-for-turbofish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fdo-not-suggest-generic-arguments-for-turbofish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fdo-not-suggest-generic-arguments-for-turbofish.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -0,0 +1,11 @@\n+enum OhNo<T, U> {\n+    A(T),\n+    B(U),\n+    C,\n+}\n+\n+fn uwu() {\n+    OhNo::C::<u32, _>; //~ ERROR type annotations needed\n+}\n+\n+fn main() {}"}, {"sha": "2ad35ab039f4c8062b60d4eebaa09763a077615e", "filename": "src/test/ui/inference/need_type_info/do-not-suggest-generic-arguments-for-turbofish.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fdo-not-suggest-generic-arguments-for-turbofish.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fdo-not-suggest-generic-arguments-for-turbofish.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fdo-not-suggest-generic-arguments-for-turbofish.stderr?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/do-not-suggest-generic-arguments-for-turbofish.rs:8:5\n+   |\n+LL |     OhNo::C::<u32, _>;\n+   |     ^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `U` declared on the enum `OhNo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "ae44ffd29bd56ec4c05eb890a38709823b8d5751", "filename": "src/test/ui/intrinsics/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 168, "deletions": 82, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -34,6 +34,12 @@ enum OneVariant_NonZero {\n     DeadVariant(Bar),\n }\n \n+#[allow(dead_code, non_camel_case_types)]\n+enum OneVariant_Ref {\n+    Variant(&'static i32),\n+    DeadVariant(Bar),\n+}\n+\n // An `Aggregate` abi enum where 0 is not a valid discriminant.\n #[allow(dead_code)]\n #[repr(i32)]\n@@ -63,6 +69,7 @@ enum ZeroIsValid {\n     One(NonNull<()>) = 1,\n }\n \n+#[track_caller]\n fn test_panic_msg<T>(op: impl (FnOnce() -> T) + panic::UnwindSafe, msg: &str) {\n     let err = panic::catch_unwind(op).err();\n     assert_eq!(\n@@ -71,6 +78,15 @@ fn test_panic_msg<T>(op: impl (FnOnce() -> T) + panic::UnwindSafe, msg: &str) {\n     );\n }\n \n+#[track_caller]\n+fn test_panic_msg_only_if_strict<T>(op: impl (FnOnce() -> T) + panic::UnwindSafe, msg: &str) {\n+    let err = panic::catch_unwind(op).err();\n+    assert_eq!(\n+        err.as_ref().and_then(|a| a.downcast_ref::<&str>()),\n+        if cfg!(strict) { Some(&msg) } else { None },\n+    );\n+}\n+\n fn main() {\n     unsafe {\n         // Uninhabited types\n@@ -139,92 +155,216 @@ fn main() {\n             \"attempted to instantiate uninhabited type `[Bar; 2]`\"\n         );\n \n-        // Types that do not like zero-initialziation\n+        // Types that don't allow either.\n         test_panic_msg(\n-            || mem::uninitialized::<fn()>(),\n-            \"attempted to leave type `fn()` uninitialized, which is invalid\"\n+            || mem::zeroed::<&i32>(),\n+            \"attempted to zero-initialize type `&i32`, which is invalid\"\n         );\n         test_panic_msg(\n-            || mem::zeroed::<fn()>(),\n-            \"attempted to zero-initialize type `fn()`, which is invalid\"\n+            || mem::uninitialized::<&i32>(),\n+            \"attempted to leave type `&i32` uninitialized, which is invalid\"\n         );\n \n         test_panic_msg(\n-            || mem::uninitialized::<*const dyn Send>(),\n-            \"attempted to leave type `*const dyn core::marker::Send` uninitialized, which is invalid\"\n+            || mem::zeroed::<Box<[i32; 0]>>(),\n+            \"attempted to zero-initialize type `alloc::boxed::Box<[i32; 0]>`, which is invalid\"\n+        );\n+        test_panic_msg(\n+            || mem::uninitialized::<Box<[i32; 0]>>(),\n+            \"attempted to leave type `alloc::boxed::Box<[i32; 0]>` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<Box<u8>>(),\n+            \"attempted to zero-initialize type `alloc::boxed::Box<u8>`, which is invalid\"\n         );\n+        test_panic_msg(\n+            || mem::uninitialized::<Box<u8>>(),\n+            \"attempted to leave type `alloc::boxed::Box<u8>` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&[i32]>(),\n+            \"attempted to zero-initialize type `&[i32]`, which is invalid\"\n+        );\n+        test_panic_msg(\n+            || mem::uninitialized::<&[i32]>(),\n+            \"attempted to leave type `&[i32]` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&(u8, [u8])>(),\n+            \"attempted to zero-initialize type `&(u8, [u8])`, which is invalid\"\n+        );\n+        test_panic_msg(\n+            || mem::uninitialized::<&(u8, [u8])>(),\n+            \"attempted to leave type `&(u8, [u8])` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&dyn Send>(),\n+            \"attempted to zero-initialize type `&dyn core::marker::Send`, which is invalid\"\n+        );\n+        test_panic_msg(\n+            || mem::uninitialized::<&dyn Send>(),\n+            \"attempted to leave type `&dyn core::marker::Send` uninitialized, which is invalid\"\n+        );\n+\n         test_panic_msg(\n             || mem::zeroed::<*const dyn Send>(),\n             \"attempted to zero-initialize type `*const dyn core::marker::Send`, which is invalid\"\n         );\n+        test_panic_msg(\n+            || mem::uninitialized::<*const dyn Send>(),\n+            \"attempted to leave type `*const dyn core::marker::Send` uninitialized, which is invalid\"\n+        );\n \n         test_panic_msg(\n-            || mem::uninitialized::<(NonNull<u32>, u32, u32)>(),\n-            \"attempted to leave type `(core::ptr::non_null::NonNull<u32>, u32, u32)` uninitialized, \\\n+            || mem::uninitialized::<NoNullVariant>(),\n+            \"attempted to leave type `NoNullVariant` uninitialized, \\\n+                which is invalid\"\n+        );\n+        test_panic_msg(\n+            || mem::zeroed::<NoNullVariant>(),\n+            \"attempted to zero-initialize type `NoNullVariant`, \\\n                 which is invalid\"\n         );\n \n         test_panic_msg(\n-            || mem::zeroed::<(NonNull<u32>, u32, u32)>(),\n-            \"attempted to zero-initialize type `(core::ptr::non_null::NonNull<u32>, u32, u32)`, \\\n+            || mem::zeroed::<OneVariant_Ref>(),\n+            \"attempted to zero-initialize type `OneVariant_Ref`, \\\n                 which is invalid\"\n         );\n+        test_panic_msg(\n+            || mem::uninitialized::<OneVariant_Ref>(),\n+            \"attempted to leave type `OneVariant_Ref` uninitialized, which is invalid\"\n+        );\n \n+        // Types where both are invalid, but we allow uninit since the 0x01-filling is not LLVM UB.\n         test_panic_msg(\n-            || mem::uninitialized::<OneVariant_NonZero>(),\n-            \"attempted to leave type `OneVariant_NonZero` uninitialized, \\\n+            || mem::zeroed::<fn()>(),\n+            \"attempted to zero-initialize type `fn()`, which is invalid\"\n+        );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<fn()>(),\n+            \"attempted to leave type `fn()` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&()>(),\n+            \"attempted to zero-initialize type `&()`, which is invalid\"\n+        );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<&()>(),\n+            \"attempted to leave type `&()` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&[u8]>(),\n+            \"attempted to zero-initialize type `&[u8]`, which is invalid\"\n+        );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<&[u8]>(),\n+            \"attempted to leave type `&[u8]` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<&str>(),\n+            \"attempted to zero-initialize type `&str`, which is invalid\"\n+        );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<&str>(),\n+            \"attempted to leave type `&str` uninitialized, which is invalid\"\n+        );\n+\n+        test_panic_msg(\n+            || mem::zeroed::<(NonNull<u32>, u32, u32)>(),\n+            \"attempted to zero-initialize type `(core::ptr::non_null::NonNull<u32>, u32, u32)`, \\\n                 which is invalid\"\n         );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<(NonNull<u32>, u32, u32)>(),\n+            \"attempted to leave type `(core::ptr::non_null::NonNull<u32>, u32, u32)` uninitialized, which is invalid\"\n+        );\n+\n         test_panic_msg(\n             || mem::zeroed::<OneVariant_NonZero>(),\n             \"attempted to zero-initialize type `OneVariant_NonZero`, \\\n                 which is invalid\"\n         );\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<OneVariant_NonZero>(),\n+            \"attempted to leave type `OneVariant_NonZero` uninitialized, which is invalid\"\n+        );\n \n+        // Types where both are invalid but we allow the zeroed form since it is not LLVM UB.\n+        test_panic_msg_only_if_strict(\n+            || mem::zeroed::<LR_NonZero>(),\n+            \"attempted to zero-initialize type `LR_NonZero`, which is invalid\"\n+        );\n         test_panic_msg(\n             || mem::uninitialized::<LR_NonZero>(),\n             \"attempted to leave type `LR_NonZero` uninitialized, which is invalid\"\n         );\n \n+        test_panic_msg_only_if_strict(\n+            || mem::zeroed::<ManuallyDrop<LR_NonZero>>(),\n+            \"attempted to zero-initialize type `core::mem::manually_drop::ManuallyDrop<LR_NonZero>`, \\\n+             which is invalid\"\n+        );\n         test_panic_msg(\n             || mem::uninitialized::<ManuallyDrop<LR_NonZero>>(),\n             \"attempted to leave type `core::mem::manually_drop::ManuallyDrop<LR_NonZero>` uninitialized, \\\n              which is invalid\"\n         );\n \n-        test_panic_msg(\n-            || mem::uninitialized::<NoNullVariant>(),\n-            \"attempted to leave type `NoNullVariant` uninitialized, \\\n-                which is invalid\"\n+        // Some strict-only things\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<i32>(),\n+            \"attempted to leave type `i32` uninitialized, which is invalid\"\n         );\n \n-        test_panic_msg(\n-            || mem::zeroed::<NoNullVariant>(),\n-            \"attempted to zero-initialize type `NoNullVariant`, \\\n-                which is invalid\"\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<*const ()>(),\n+            \"attempted to leave type `*const ()` uninitialized, which is invalid\"\n         );\n \n-        // Types that can be zero, but not uninit.\n-        test_panic_msg(\n-            || mem::uninitialized::<bool>(),\n-            \"attempted to leave type `bool` uninitialized, which is invalid\"\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<[i32; 1]>(),\n+            \"attempted to leave type `[i32; 1]` uninitialized, which is invalid\"\n         );\n \n+        test_panic_msg_only_if_strict(\n+            || mem::zeroed::<[NonNull<()>; 1]>(),\n+            \"attempted to zero-initialize type `[core::ptr::non_null::NonNull<()>; 1]`, which is invalid\"\n+        );\n+\n+        // Types that can be zero, but not uninit (though some are mitigated).\n+        let _val = mem::zeroed::<LR>();\n         test_panic_msg(\n             || mem::uninitialized::<LR>(),\n             \"attempted to leave type `LR` uninitialized, which is invalid\"\n         );\n \n+        let _val = mem::zeroed::<ManuallyDrop<LR>>();\n         test_panic_msg(\n             || mem::uninitialized::<ManuallyDrop<LR>>(),\n             \"attempted to leave type `core::mem::manually_drop::ManuallyDrop<LR>` uninitialized, which is invalid\"\n         );\n \n-        // Some things that should work.\n         let _val = mem::zeroed::<bool>();\n-        let _val = mem::zeroed::<LR>();\n-        let _val = mem::zeroed::<ManuallyDrop<LR>>();\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<bool>(),\n+            \"attempted to leave type `bool` uninitialized, which is invalid\"\n+        );\n+\n         let _val = mem::zeroed::<OneVariant>();\n+        test_panic_msg_only_if_strict(\n+            || mem::uninitialized::<OneVariant>(),\n+            \"attempted to leave type `OneVariant` uninitialized, which is invalid\"\n+        );\n+\n+        // Some things that are actually allowed.\n         let _val = mem::zeroed::<Option<&'static i32>>();\n         let _val = mem::zeroed::<MaybeUninit<NonNull<u32>>>();\n         let _val = mem::zeroed::<[!; 0]>();\n@@ -233,59 +373,5 @@ fn main() {\n         let _val = mem::uninitialized::<[!; 0]>();\n         let _val = mem::uninitialized::<()>();\n         let _val = mem::uninitialized::<ZeroSized>();\n-\n-        if cfg!(strict) {\n-            test_panic_msg(\n-                || mem::uninitialized::<i32>(),\n-                \"attempted to leave type `i32` uninitialized, which is invalid\"\n-            );\n-\n-            test_panic_msg(\n-                || mem::uninitialized::<*const ()>(),\n-                \"attempted to leave type `*const ()` uninitialized, which is invalid\"\n-            );\n-\n-            test_panic_msg(\n-                || mem::uninitialized::<[i32; 1]>(),\n-                \"attempted to leave type `[i32; 1]` uninitialized, which is invalid\"\n-            );\n-\n-            test_panic_msg(\n-                || mem::zeroed::<NonNull<()>>(),\n-                \"attempted to zero-initialize type `core::ptr::non_null::NonNull<()>`, which is invalid\"\n-            );\n-\n-            test_panic_msg(\n-                || mem::zeroed::<[NonNull<()>; 1]>(),\n-                \"attempted to zero-initialize type `[core::ptr::non_null::NonNull<()>; 1]`, which is invalid\"\n-            );\n-\n-            // FIXME(#66151) we conservatively do not error here yet (by default).\n-            test_panic_msg(\n-                || mem::zeroed::<LR_NonZero>(),\n-                \"attempted to zero-initialize type `LR_NonZero`, which is invalid\"\n-            );\n-\n-            test_panic_msg(\n-                || mem::zeroed::<ManuallyDrop<LR_NonZero>>(),\n-                \"attempted to zero-initialize type `core::mem::manually_drop::ManuallyDrop<LR_NonZero>`, \\\n-                 which is invalid\"\n-            );\n-        } else {\n-            // These are UB because they have not been officially blessed, but we await the resolution\n-            // of <https://github.com/rust-lang/unsafe-code-guidelines/issues/71> before doing\n-            // anything about that.\n-            let _val = mem::uninitialized::<i32>();\n-            let _val = mem::uninitialized::<*const ()>();\n-\n-            // These are UB, but best to test them to ensure we don't become unintentionally\n-            // stricter.\n-\n-            // It's currently unchecked to create invalid enums and values inside arrays.\n-            let _val = mem::zeroed::<LR_NonZero>();\n-            let _val = mem::zeroed::<[LR_NonZero; 1]>();\n-            let _val = mem::zeroed::<[NonNull<()>; 1]>();\n-            let _val = mem::uninitialized::<[NonNull<()>; 1]>();\n-        }\n     }\n }"}, {"sha": "72102f460e0bd37cef0dddc144ce6368d19f2714", "filename": "src/test/ui/issues/issue-24013.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fissues%2Fissue-24013.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fissues%2Fissue-24013.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24013.stderr?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -3,11 +3,6 @@ error[E0282]: type annotations needed\n    |\n LL |     unsafe {swap::<&mut _>(transmute(&a), transmute(&b))};\n    |             ^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `swap`\n-   |\n-help: consider specifying the generic argument\n-   |\n-LL |     unsafe {swap::<&mut _>(transmute(&a), transmute(&b))};\n-   |                 ~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "2bd24f08c1e51d0efb6cb4c272b6dc12d1e19c50", "filename": "src/test/ui/issues/issue-47486.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -9,11 +9,6 @@ error[E0282]: type annotations needed\n    |\n LL |     [0u8; std::mem::size_of::<_>()];\n    |           ^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `size_of`\n-   |\n-help: consider specifying the generic argument\n-   |\n-LL |     [0u8; std::mem::size_of::<_>()];\n-   |                            ~~~~~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "946a0e3886139f992001204e0e960aad7444a9b8", "filename": "src/test/ui/lint/invalid_value.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -88,6 +88,9 @@ fn main() {\n         let _val: NonNull<i32> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: NonNull<i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: (NonZeroU32, i32) = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: (NonZeroU32, i32) = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         let _val: *const dyn Send = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: *const dyn Send = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n@@ -133,7 +136,7 @@ fn main() {\n         let _val: Result<i32, i32> = mem::zeroed();\n         let _val: Result<i32, i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n-        // Some things that happen to work due to rustc implementation details,\n+        // Some things that happen to be UB-free due to rustc implementation details,\n         // but are not guaranteed to keep working.\n         let _val: OneFruit = mem::zeroed();\n         let _val: OneFruit = mem::uninitialized();"}, {"sha": "3901692001abd7bfef6567d124bfa5607dcb41d5", "filename": "src/test/ui/lint/invalid_value.stderr", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -315,8 +315,30 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n+error: the type `(NonZeroU32, i32)` does not permit zero-initialization\n+  --> $DIR/invalid_value.rs:91:39\n+   |\n+LL |         let _val: (NonZeroU32, i32) = mem::zeroed();\n+   |                                       ^^^^^^^^^^^^^\n+   |                                       |\n+   |                                       this code causes undefined behavior when executed\n+   |                                       help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: `std::num::NonZeroU32` must be non-null\n+\n+error: the type `(NonZeroU32, i32)` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:92:39\n+   |\n+LL |         let _val: (NonZeroU32, i32) = mem::uninitialized();\n+   |                                       ^^^^^^^^^^^^^^^^^^^^\n+   |                                       |\n+   |                                       this code causes undefined behavior when executed\n+   |                                       help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: `std::num::NonZeroU32` must be non-null\n+\n error: the type `*const dyn Send` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:91:37\n+  --> $DIR/invalid_value.rs:94:37\n    |\n LL |         let _val: *const dyn Send = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -327,7 +349,7 @@ LL |         let _val: *const dyn Send = mem::zeroed();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `*const dyn Send` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:92:37\n+  --> $DIR/invalid_value.rs:95:37\n    |\n LL |         let _val: *const dyn Send = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -338,7 +360,7 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `[fn(); 2]` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:94:31\n+  --> $DIR/invalid_value.rs:97:31\n    |\n LL |         let _val: [fn(); 2] = mem::zeroed();\n    |                               ^^^^^^^^^^^^^\n@@ -349,7 +371,7 @@ LL |         let _val: [fn(); 2] = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `[fn(); 2]` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:95:31\n+  --> $DIR/invalid_value.rs:98:31\n    |\n LL |         let _val: [fn(); 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -360,7 +382,7 @@ LL |         let _val: [fn(); 2] = mem::uninitialized();\n    = note: function pointers must be non-null\n \n error: the type `TwoUninhabited` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:97:36\n+  --> $DIR/invalid_value.rs:100:36\n    |\n LL |         let _val: TwoUninhabited = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n@@ -375,7 +397,7 @@ LL | enum TwoUninhabited {\n    | ^^^^^^^^^^^^^^^^^^^\n \n error: the type `TwoUninhabited` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:98:36\n+  --> $DIR/invalid_value.rs:101:36\n    |\n LL |         let _val: TwoUninhabited = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n@@ -390,7 +412,7 @@ LL | enum TwoUninhabited {\n    | ^^^^^^^^^^^^^^^^^^^\n \n error: the type `OneFruitNonZero` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:100:37\n+  --> $DIR/invalid_value.rs:103:37\n    |\n LL |         let _val: OneFruitNonZero = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -405,7 +427,7 @@ LL |     Banana(NonZeroU32),\n    |            ^^^^^^^^^^\n \n error: the type `OneFruitNonZero` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:101:37\n+  --> $DIR/invalid_value.rs:104:37\n    |\n LL |         let _val: OneFruitNonZero = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -420,7 +442,7 @@ LL |     Banana(NonZeroU32),\n    |            ^^^^^^^^^^\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:105:26\n+  --> $DIR/invalid_value.rs:108:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -431,7 +453,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:108:32\n+  --> $DIR/invalid_value.rs:111:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -446,7 +468,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:111:28\n+  --> $DIR/invalid_value.rs:114:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -457,7 +479,7 @@ LL |         let _val: NonBig = mem::uninitialized();\n    = note: `NonBig` must be initialized inside its custom valid range\n \n error: the type `Fruit` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:114:27\n+  --> $DIR/invalid_value.rs:117:27\n    |\n LL |         let _val: Fruit = mem::uninitialized();\n    |                           ^^^^^^^^^^^^^^^^^^^^\n@@ -472,7 +494,7 @@ LL | enum Fruit {\n    | ^^^^^^^^^^\n \n error: the type `[bool; 2]` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:117:31\n+  --> $DIR/invalid_value.rs:120:31\n    |\n LL |         let _val: [bool; 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -483,7 +505,7 @@ LL |         let _val: [bool; 2] = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `i32` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:120:25\n+  --> $DIR/invalid_value.rs:123:25\n    |\n LL |         let _val: i32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -494,7 +516,7 @@ LL |         let _val: i32 = mem::uninitialized();\n    = note: integers must not be uninitialized\n \n error: the type `f32` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:123:25\n+  --> $DIR/invalid_value.rs:126:25\n    |\n LL |         let _val: f32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -505,7 +527,7 @@ LL |         let _val: f32 = mem::uninitialized();\n    = note: floats must not be uninitialized\n \n error: the type `*const ()` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:126:31\n+  --> $DIR/invalid_value.rs:129:31\n    |\n LL |         let _val: *const () = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -516,7 +538,7 @@ LL |         let _val: *const () = mem::uninitialized();\n    = note: raw pointers must not be uninitialized\n \n error: the type `*const [()]` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:129:33\n+  --> $DIR/invalid_value.rs:132:33\n    |\n LL |         let _val: *const [()] = mem::uninitialized();\n    |                                 ^^^^^^^^^^^^^^^^^^^^\n@@ -527,7 +549,7 @@ LL |         let _val: *const [()] = mem::uninitialized();\n    = note: raw pointers must not be uninitialized\n \n error: the type `Result<i32, i32>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:134:38\n+  --> $DIR/invalid_value.rs:137:38\n    |\n LL |         let _val: Result<i32, i32> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -542,7 +564,7 @@ LL | pub enum Result<T, E> {\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:142:34\n+  --> $DIR/invalid_value.rs:145:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -553,7 +575,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: references must be non-null\n \n error: the type `&[i32]` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:143:36\n+  --> $DIR/invalid_value.rs:146:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -564,7 +586,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: references must be non-null\n \n error: the type `NonZeroU32` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:144:32\n+  --> $DIR/invalid_value.rs:147:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -575,7 +597,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:147:34\n+  --> $DIR/invalid_value.rs:150:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -586,7 +608,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:148:34\n+  --> $DIR/invalid_value.rs:151:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -597,7 +619,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:149:26\n+  --> $DIR/invalid_value.rs:152:26\n    |\n LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -607,5 +629,5 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |\n    = note: booleans must be either `true` or `false`\n \n-error: aborting due to 48 previous errors\n+error: aborting due to 50 previous errors\n "}, {"sha": "2b6314c38ceb6db64784caf2ccccb336e726a09b", "filename": "src/test/ui/parser/expr-as-stmt-2.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt-2.stderr?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -36,11 +36,6 @@ LL | /     &&\n LL | |     if let Some(y) = a { true } else { false }\n    | |______________________________________________^ expected `bool`, found `&&bool`\n    |\n-help: consider removing the `&&`\n-   |\n-LL -     &&\n-LL +     if let Some(y) = a { true } else { false }\n-   |\n help: parentheses are required to parse this as an expression\n    |\n LL |     (if let Some(x) = a { true } else { false })"}, {"sha": "6da4ac34067e9bc8e74a4e888c1e82f29000a96c", "filename": "src/test/ui/parser/expr-as-stmt.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -170,11 +170,6 @@ LL | fn revenge_from_mars() -> bool {\n LL |     { true } && { true }\n    |              ^^^^^^^^^^^ expected `bool`, found `&&bool`\n    |\n-help: consider removing the `&&`\n-   |\n-LL -     { true } && { true }\n-LL +     { true } { true }\n-   |\n help: parentheses are required to parse this as an expression\n    |\n LL |     ({ true }) && { true }\n@@ -201,10 +196,6 @@ LL |     { true } || { true }\n    |\n    = note: expected type `bool`\n            found closure `[closure@$DIR/expr-as-stmt.rs:51:14: 51:16]`\n-help: use parentheses to call this closure\n-   |\n-LL |     { true } (|| { true })()\n-   |              +           +++\n help: parentheses are required to parse this as an expression\n    |\n LL |     ({ true }) || { true }"}, {"sha": "6050963c4ee80a4b46cd5efeb0ccdd02986480bb", "filename": "src/test/ui/suggestions/boxed-variant-field.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -9,7 +9,6 @@ fn foo(x: Ty) -> Ty {\n         Ty::List(elem) => foo(elem),\n         //~^ ERROR mismatched types\n         //~| HELP consider unboxing the value\n-        //~| HELP try wrapping\n     }\n }\n "}, {"sha": "9ae36a06a7155d4807961d49e36d028d803bfc46", "filename": "src/test/ui/suggestions/boxed-variant-field.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.stderr?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -17,10 +17,6 @@ help: consider unboxing the value\n    |\n LL |         Ty::List(elem) => foo(*elem),\n    |                               +\n-help: try wrapping the expression in `Ty::List`\n-   |\n-LL |         Ty::List(elem) => foo(Ty::List(elem)),\n-   |                               +++++++++    +\n \n error: aborting due to previous error\n "}, {"sha": "1c9a9e0aaf561e8596d83edc39adce4776cfe452", "filename": "src/test/ui/suggestions/into-convert.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.rs?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -0,0 +1,26 @@\n+use std::path::{Path, PathBuf};\n+use std::sync::atomic::AtomicU32;\n+use std::sync::Arc;\n+\n+fn main() {\n+    let x: A = B;\n+    //~^ ERROR mismatched types\n+    //~| HELP call `Into::into` on this expression to convert `B` into `A`\n+\n+    let y: Arc<Path> = PathBuf::new();\n+    //~^ ERROR mismatched types\n+    //~| HELP call `Into::into` on this expression to convert `PathBuf` into `Arc<Path>`\n+\n+    let z: AtomicU32 = 1;\n+    //~^ ERROR mismatched types\n+    //~| HELP call `Into::into` on this expression to convert `{integer}` into `AtomicU32`\n+}\n+\n+struct A;\n+struct B;\n+\n+impl From<B> for A {\n+    fn from(_: B) -> Self {\n+        A\n+    }\n+}"}, {"sha": "d43104a2172400350e4d01a8e8036864edf0e547", "filename": "src/test/ui/suggestions/into-convert.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24ac6a26bcf5be1ac841e7fe969bd992b3461f9d/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-convert.stderr?ref=24ac6a26bcf5be1ac841e7fe969bd992b3461f9d", "patch": "@@ -0,0 +1,44 @@\n+error[E0308]: mismatched types\n+  --> $DIR/into-convert.rs:6:16\n+   |\n+LL |     let x: A = B;\n+   |            -   ^ expected struct `A`, found struct `B`\n+   |            |\n+   |            expected due to this\n+   |\n+help: call `Into::into` on this expression to convert `B` into `A`\n+   |\n+LL |     let x: A = B.into();\n+   |                 +++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/into-convert.rs:10:24\n+   |\n+LL |     let y: Arc<Path> = PathBuf::new();\n+   |            ---------   ^^^^^^^^^^^^^^ expected struct `Arc`, found struct `PathBuf`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected struct `Arc<Path>`\n+              found struct `PathBuf`\n+help: call `Into::into` on this expression to convert `PathBuf` into `Arc<Path>`\n+   |\n+LL |     let y: Arc<Path> = PathBuf::new().into();\n+   |                                      +++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/into-convert.rs:14:24\n+   |\n+LL |     let z: AtomicU32 = 1;\n+   |            ---------   ^ expected struct `AtomicU32`, found integer\n+   |            |\n+   |            expected due to this\n+   |\n+help: call `Into::into` on this expression to convert `{integer}` into `AtomicU32`\n+   |\n+LL |     let z: AtomicU32 = 1.into();\n+   |                         +++++++\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}