{"sha": "6d989c729d03f5f9900d153417488b5eaf1e2f2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkOTg5YzcyOWQwM2Y1Zjk5MDBkMTUzNDE3NDg4YjVlYWYxZTJmMmY=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-08-23T15:54:35Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-08-23T15:54:35Z"}, "message": "add closure arg check, also catch non-consts", "tree": {"sha": "b85548ffa60c16df21b83f8fb5f66a420fd1e961", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b85548ffa60c16df21b83f8fb5f66a420fd1e961"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d989c729d03f5f9900d153417488b5eaf1e2f2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d989c729d03f5f9900d153417488b5eaf1e2f2f", "html_url": "https://github.com/rust-lang/rust/commit/6d989c729d03f5f9900d153417488b5eaf1e2f2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d989c729d03f5f9900d153417488b5eaf1e2f2f/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70e34077d590136fc1096ea03c887393a1246c93", "url": "https://api.github.com/repos/rust-lang/rust/commits/70e34077d590136fc1096ea03c887393a1246c93", "html_url": "https://github.com/rust-lang/rust/commit/70e34077d590136fc1096ea03c887393a1246c93"}], "stats": {"total": 144, "additions": 103, "deletions": 41}, "files": [{"sha": "cbd0c6d20d50ad880c149f3f05ae12181333a273", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6d989c729d03f5f9900d153417488b5eaf1e2f2f/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d989c729d03f5f9900d153417488b5eaf1e2f2f/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=6d989c729d03f5f9900d153417488b5eaf1e2f2f", "patch": "@@ -1,8 +1,8 @@\n-use consts::{constant, Constant};\n-use rustc_const_math::ConstInt;\n use rustc::hir::*;\n use rustc::lint::*;\n-use utils::{match_type, paths, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use rustc::ty;\n+use syntax::ast::{Name, UintTy};\n+use utils::{contains_name, match_type, paths, single_segment_path, snippet, span_lint_and_sugg, walk_ptrs_ty};\n \n /// **What it does:** Checks for naive byte counts\n ///\n@@ -47,14 +47,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n         ], {\n             let body = cx.tcx.hir.body(body_id);\n             if_let_chain!([\n+                body.arguments.len() == 1,\n+                let Some(argname) = get_pat_name(&body.arguments[0].pat),\n                 let ExprBinary(ref op, ref l, ref r) = body.value.node,\n                 op.node == BiEq,\n                 match_type(cx,\n                            walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n                            &paths::SLICE_ITER),\n-                let Some((Constant::Int(ConstInt::U8(needle)), _)) =\n-                        constant(cx, l).or_else(|| constant(cx, r))\n             ], {\n+                let needle = match get_path_name(l) {\n+                    Some(name) if check_arg(name, argname, r) => r,\n+                    _ => match get_path_name(r) {\n+                        Some(name) if check_arg(name, argname, l) => l,\n+                        _ => { return; }\n+                    }\n+                };\n+                if ty::TyUint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).sty {\n+                    return;\n+                }\n                 let haystack = if let ExprMethodCall(ref path, _, ref args) =\n                         filter_args[0].node {\n                     let p = path.name;\n@@ -73,8 +83,33 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                                    \"Consider using the bytecount crate\",\n                                    format!(\"bytecount::count({}, {})\",\n                                             snippet(cx, haystack.span, \"..\"),\n-                                            needle));\n+                                            snippet(cx, needle.span, \"..\")));\n             });\n         });\n     }\n }\n+\n+fn check_arg(name: Name, arg: Name, needle: &Expr) -> bool {\n+    name == arg && !contains_name(name, needle)\n+}\n+\n+fn get_pat_name(pat: &Pat) -> Option<Name> {\n+    match pat.node {\n+        PatKind::Binding(_, _, ref spname, _) => Some(spname.node),\n+        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n+        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n+        _ => None\n+    }\n+}\n+\n+fn get_path_name(expr: &Expr) -> Option<Name> {\n+    match expr.node {\n+        ExprBox(ref e) | ExprAddrOf(_, ref e) | ExprUnary(UnOp::UnDeref, ref e) => get_path_name(e),\n+        ExprBlock(ref b) => if b.stmts.is_empty() {\n+            b.expr.as_ref().and_then(|p| get_path_name(p))\n+        } else { None },\n+        ExprPath(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n+        _ => None\n+    }\n+}\n+"}, {"sha": "ccb339390b1e83e0ee3e27f1f06e77aa08b3e78d", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6d989c729d03f5f9900d153417488b5eaf1e2f2f/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d989c729d03f5f9900d153417488b5eaf1e2f2f/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=6d989c729d03f5f9900d153417488b5eaf1e2f2f", "patch": "@@ -1,10 +1,10 @@\n use reexport::*;\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, FnKind, NestedVisitorMap};\n+use rustc::hir::intravisit::FnKind;\n use rustc::ty;\n use syntax::codemap::Span;\n-use utils::{higher, in_external_macro, snippet, span_lint_and_then, iter_input_pats};\n+use utils::{contains_name, higher, in_external_macro, snippet, span_lint_and_then, iter_input_pats};\n \n /// **What it does:** Checks for bindings that shadow other bindings already in\n /// scope, while just changing reference level or mutability.\n@@ -261,7 +261,7 @@ fn lint_shadow<'a, 'tcx: 'a>(\n                 ),\n                 |db| { db.span_note(prev_span, \"previous binding is here\"); },\n             );\n-        } else if contains_self(name, expr) {\n+        } else if contains_name(name, expr) {\n             span_lint_and_then(\n                 cx,\n                 SHADOW_REUSE,\n@@ -391,27 +391,3 @@ fn path_eq_name(name: Name, path: &Path) -> bool {\n     !path.is_global() && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n }\n \n-struct ContainsSelf {\n-    name: Name,\n-    result: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ContainsSelf {\n-    fn visit_name(&mut self, _: Span, name: Name) {\n-        if self.name == name {\n-            self.result = true;\n-        }\n-    }\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-fn contains_self(name: Name, expr: &Expr) -> bool {\n-    let mut cs = ContainsSelf {\n-        name: name,\n-        result: false,\n-    };\n-    cs.visit_expr(expr);\n-    cs.result\n-}"}, {"sha": "c24ccd5d57342612796059583739212fee0b5287", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6d989c729d03f5f9900d153417488b5eaf1e2f2f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d989c729d03f5f9900d153417488b5eaf1e2f2f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=6d989c729d03f5f9900d153417488b5eaf1e2f2f", "patch": "@@ -3,6 +3,7 @@ use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::def::Def;\n+use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc::hir::map::Node;\n use rustc::lint::{LintContext, Level, LateContext, Lint};\n use rustc::session::Session;\n@@ -393,6 +394,33 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     }\n }\n \n+struct ContainsName {\n+    name: Name,\n+    result: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ContainsName {\n+    fn visit_name(&mut self, _: Span, name: Name) {\n+        if self.name == name {\n+            self.result = true;\n+        }\n+    }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// check if an `Expr` contains a certain name\n+pub fn contains_name(name: Name, expr: &Expr) -> bool {\n+    let mut cn = ContainsName {\n+        name: name,\n+        result: false,\n+    };\n+    cn.visit_expr(expr);\n+    cn.result\n+}\n+\n+\n /// Convert a span to a code snippet if available, otherwise use default.\n ///\n /// # Example"}, {"sha": "8fc27c49f34b4da2475345926bbd7b9a8d3cd8ba", "filename": "tests/ui/bytecount.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6d989c729d03f5f9900d153417488b5eaf1e2f2f/tests%2Fui%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d989c729d03f5f9900d153417488b5eaf1e2f2f/tests%2Fui%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbytecount.rs?ref=6d989c729d03f5f9900d153417488b5eaf1e2f2f", "patch": "@@ -1,6 +1,7 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n+#[deny(naive_bytecount)]\n fn main() {\n     let x = vec![0_u8; 16];\n \n@@ -11,4 +12,16 @@ fn main() {\n     let _ = x.iter().filter(|a| **a > 0).count(); // not an equality count, OK.\n \n     let _ = x.iter().map(|a| a + 1).filter(|&a| a < 15).count(); // not a slice\n+\n+    let b = 0;\n+\n+    let _ = x.iter().filter(|_| b > 0).count(); // woah there\n+\n+    let _ = x.iter().filter(|_a| b == b + 1).count(); // nothing to see here, move along\n+\n+    let _ = x.iter().filter(|a| b + 1 == **a).count(); // naive byte count\n+\n+    let y = vec![0_u16; 3];\n+\n+    let _ = y.iter().filter(|&&a| a == 0).count(); // naive count, but not bytes\n }"}, {"sha": "307edecfde1a097b5ed07b9536bc61f77b562213", "filename": "tests/ui/bytecount.stderr", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6d989c729d03f5f9900d153417488b5eaf1e2f2f/tests%2Fui%2Fbytecount.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d989c729d03f5f9900d153417488b5eaf1e2f2f/tests%2Fui%2Fbytecount.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbytecount.stderr?ref=6d989c729d03f5f9900d153417488b5eaf1e2f2f", "patch": "@@ -1,16 +1,26 @@\n error: You appear to be counting bytes the naive way\n- --> $DIR/bytecount.rs:7:13\n+ --> $DIR/bytecount.rs:8:13\n   |\n-7 |     let _ = x.iter().filter(|&&a| a == 0).count(); // naive byte count\n+8 |     let _ = x.iter().filter(|&&a| a == 0).count(); // naive byte count\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider using the bytecount crate: `bytecount::count(x, 0)`\n   |\n-  = note: `-D naive-bytecount` implied by `-D warnings`\n+note: lint level defined here\n+ --> $DIR/bytecount.rs:4:8\n+  |\n+4 | #[deny(naive_bytecount)]\n+  |        ^^^^^^^^^^^^^^^\n \n error: You appear to be counting bytes the naive way\n- --> $DIR/bytecount.rs:9:13\n-  |\n-9 |     let _ = (&x[..]).iter().filter(|&a| *a == 0).count(); // naive byte count\n-  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider using the bytecount crate: `bytecount::count((&x[..]), 0)`\n+  --> $DIR/bytecount.rs:10:13\n+   |\n+10 |     let _ = (&x[..]).iter().filter(|&a| *a == 0).count(); // naive byte count\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider using the bytecount crate: `bytecount::count((&x[..]), 0)`\n+\n+error: You appear to be counting bytes the naive way\n+  --> $DIR/bytecount.rs:22:13\n+   |\n+22 |     let _ = x.iter().filter(|a| b + 1 == **a).count(); // naive byte count\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider using the bytecount crate: `bytecount::count(x, b + 1)`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}]}