{"sha": "688094b868f4ebe344c06ea2ba5b445ebef6ae67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ODA5NGI4NjhmNGViZTM0NGMwNmVhMmJhNWI0NDVlYmVmNmFlNjc=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-08-12T06:32:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-12T06:32:53Z"}, "message": "Rollup merge of #85835 - Seppel3210:master, r=yaahc\n\nImplement Extend<(A, B)> for (Extend<A>, Extend<B>)\n\nI oriented myself at the implementation of `Iterator::unzip` and also rewrote the impl in terms of `(A, B)::extend` after that.\n\nSince (A, B) now also implements Extend we could also mention in the documentation of unzip that it can do \"nested unzipping\" (you could unzip `Iterator<Item=(A, (B, C))>` into `(Vec<A>, (Vec<B>, Vec<C>))` for example) but I'm not sure of that so I'm asking here \ud83d\ude42\n\n(P.S. I saw a couple of people asking if there is an unzip3 but there isn't. So this could be a way to get equivalent functionality)", "tree": {"sha": "8182bfdab64565050a0d1ab3bd2474ac56f64ed9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8182bfdab64565050a0d1ab3bd2474ac56f64ed9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/688094b868f4ebe344c06ea2ba5b445ebef6ae67", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhFMCVCRBK7hj4Ov3rIwAAUU4IAAfJUTWoTFIwfydqK/XLq4fb\nG+IYZVkJeqkwdMovkOBxDscAM4yJjKMi5sx9svFtf67U8eBxmGPqmaXrYIaePiMe\nIeOSuoyb14VAY0jTSfhBWImq9MIE6ls8DArE3A/S8K9JgO0VHQ/yZYBV803wMy+T\n1g8oBEI6O8MoKZOsfy9j2XNSOEMTNx2IXWdkVuOF981Tg2dsuys0OF71lrjYJPqE\n9ibqqd2PeqRv6+jdvr9tBgKF64e+APnOMA2m3lUWYBzHzHAd7sVOZS3jLVB2W8r3\nzKB3De1fGp4tryLz/ceC2DBaakhia7s13Uo7OHhWZRom3qNhEVZeuRiZqHa/v/s=\n=AMdh\n-----END PGP SIGNATURE-----\n", "payload": "tree 8182bfdab64565050a0d1ab3bd2474ac56f64ed9\nparent 25d3e14da77f755ef858b976a25c7e856b62b42a\nparent 3d0c5d09d33d74a508965799fcde6e8147cee721\nauthor Yuki Okushi <jtitor@2k36.org> 1628749973 +0900\ncommitter GitHub <noreply@github.com> 1628749973 +0900\n\nRollup merge of #85835 - Seppel3210:master, r=yaahc\n\nImplement Extend<(A, B)> for (Extend<A>, Extend<B>)\n\nI oriented myself at the implementation of `Iterator::unzip` and also rewrote the impl in terms of `(A, B)::extend` after that.\n\nSince (A, B) now also implements Extend we could also mention in the documentation of unzip that it can do \"nested unzipping\" (you could unzip `Iterator<Item=(A, (B, C))>` into `(Vec<A>, (Vec<B>, Vec<C>))` for example) but I'm not sure of that so I'm asking here \ud83d\ude42\n\n(P.S. I saw a couple of people asking if there is an unzip3 but there isn't. So this could be a way to get equivalent functionality)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/688094b868f4ebe344c06ea2ba5b445ebef6ae67", "html_url": "https://github.com/rust-lang/rust/commit/688094b868f4ebe344c06ea2ba5b445ebef6ae67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/688094b868f4ebe344c06ea2ba5b445ebef6ae67/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25d3e14da77f755ef858b976a25c7e856b62b42a", "url": "https://api.github.com/repos/rust-lang/rust/commits/25d3e14da77f755ef858b976a25c7e856b62b42a", "html_url": "https://github.com/rust-lang/rust/commit/25d3e14da77f755ef858b976a25c7e856b62b42a"}, {"sha": "3d0c5d09d33d74a508965799fcde6e8147cee721", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0c5d09d33d74a508965799fcde6e8147cee721", "html_url": "https://github.com/rust-lang/rust/commit/3d0c5d09d33d74a508965799fcde6e8147cee721"}], "stats": {"total": 91, "additions": 69, "deletions": 22}, "files": [{"sha": "aa91346851f9dc83aa003def0a3949ad412b215d", "filename": "library/core/src/iter/traits/collect.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/688094b868f4ebe344c06ea2ba5b445ebef6ae67/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688094b868f4ebe344c06ea2ba5b445ebef6ae67/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs?ref=688094b868f4ebe344c06ea2ba5b445ebef6ae67", "patch": "@@ -360,3 +360,61 @@ impl Extend<()> for () {\n     }\n     fn extend_one(&mut self, _item: ()) {}\n }\n+\n+#[stable(feature = \"extend_for_tuple\", since = \"1.56.0\")]\n+impl<A, B, ExtendA, ExtendB> Extend<(A, B)> for (ExtendA, ExtendB)\n+where\n+    ExtendA: Extend<A>,\n+    ExtendB: Extend<B>,\n+{\n+    /// Allows to `extend` a tuple of collections that also implement `Extend`.\n+    ///\n+    /// See also: [`Iterator::unzip`]\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// let mut tuple = (vec![0], vec![1]);\n+    /// tuple.extend(vec![(2, 3), (4, 5), (6, 7)]);\n+    /// assert_eq!(tuple.0, vec![0, 2, 4, 6]);\n+    /// assert_eq!(tuple.1, vec![1, 3, 5, 7]);\n+    ///\n+    /// // also allows for arbitrarily nested tuples\n+    /// let mut nested_tuple = (vec![(1, -1)], vec![(2, -2)]);\n+    /// nested_tuple.extend(vec![((3, -3), (4, -4)), ((5, -5), (6, -6))]);\n+    ///\n+    /// assert_eq!(nested_tuple.0, vec![(1, -1), (3, -3), (5, -5)]);\n+    /// assert_eq!(nested_tuple.1, vec![(2, -2), (4, -4), (6, -6)]);\n+    /// ```\n+    fn extend<T: IntoIterator<Item = (A, B)>>(&mut self, into_iter: T) {\n+        let (a, b) = self;\n+        let iter = into_iter.into_iter();\n+\n+        fn extend<'a, A, B>(\n+            a: &'a mut impl Extend<A>,\n+            b: &'a mut impl Extend<B>,\n+        ) -> impl FnMut((), (A, B)) + 'a {\n+            move |(), (t, u)| {\n+                a.extend_one(t);\n+                b.extend_one(u);\n+            }\n+        }\n+\n+        let (lower_bound, _) = iter.size_hint();\n+        if lower_bound > 0 {\n+            a.extend_reserve(lower_bound);\n+            b.extend_reserve(lower_bound);\n+        }\n+\n+        iter.fold((), extend(a, b));\n+    }\n+\n+    fn extend_one(&mut self, item: (A, B)) {\n+        self.0.extend_one(item.0);\n+        self.1.extend_one(item.1);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.0.extend_reserve(additional);\n+        self.1.extend_reserve(additional);\n+    }\n+}"}, {"sha": "524d8f857e2a5e26db1b757cb25abad31b4626b8", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/688094b868f4ebe344c06ea2ba5b445ebef6ae67/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688094b868f4ebe344c06ea2ba5b445ebef6ae67/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=688094b868f4ebe344c06ea2ba5b445ebef6ae67", "patch": "@@ -2841,6 +2841,14 @@ pub trait Iterator {\n     ///\n     /// assert_eq!(left, [1, 3]);\n     /// assert_eq!(right, [2, 4]);\n+    ///\n+    /// // you can also unzip multiple nested tuples at once\n+    /// let a = [(1, (2, 3)), (4, (5, 6))];\n+    ///\n+    /// let (x, (y, z)): (Vec<_>, (Vec<_>, Vec<_>)) = a.iter().cloned().unzip();\n+    /// assert_eq!(x, [1, 4]);\n+    /// assert_eq!(y, [2, 5]);\n+    /// assert_eq!(z, [3, 6]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB)\n@@ -2849,28 +2857,9 @@ pub trait Iterator {\n         FromB: Default + Extend<B>,\n         Self: Sized + Iterator<Item = (A, B)>,\n     {\n-        fn extend<'a, A, B>(\n-            ts: &'a mut impl Extend<A>,\n-            us: &'a mut impl Extend<B>,\n-        ) -> impl FnMut((), (A, B)) + 'a {\n-            move |(), (t, u)| {\n-                ts.extend_one(t);\n-                us.extend_one(u);\n-            }\n-        }\n-\n-        let mut ts: FromA = Default::default();\n-        let mut us: FromB = Default::default();\n-\n-        let (lower_bound, _) = self.size_hint();\n-        if lower_bound > 0 {\n-            ts.extend_reserve(lower_bound);\n-            us.extend_reserve(lower_bound);\n-        }\n-\n-        self.fold((), extend(&mut ts, &mut us));\n-\n-        (ts, us)\n+        let mut unzipped: (FromA, FromB) = Default::default();\n+        unzipped.extend(self);\n+        unzipped\n     }\n \n     /// Creates an iterator which copies all of its elements."}]}