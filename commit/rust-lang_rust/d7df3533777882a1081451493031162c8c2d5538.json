{"sha": "d7df3533777882a1081451493031162c8c2d5538", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZGYzNTMzNzc3ODgyYTEwODE0NTE0OTMwMzExNjJjOGMyZDU1Mzg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-24T01:47:20Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-24T06:38:35Z"}, "message": "Rollup merge of #22580 - pnkfelix:guard-pat-cfg2, r=pnkfelix\n\n aatch's cfg revisions, namely to match expressions\n\nRevise handling of match expressions so that arms branch to next arm.\n\nUpdate the graphviz tests accordingly.\n\nFixes #22073. (Includes regression test for the issue.)", "tree": {"sha": "379e5c328eeef4dcc3877248ce2477a21cc6bd8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/379e5c328eeef4dcc3877248ce2477a21cc6bd8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7df3533777882a1081451493031162c8c2d5538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7df3533777882a1081451493031162c8c2d5538", "html_url": "https://github.com/rust-lang/rust/commit/d7df3533777882a1081451493031162c8c2d5538", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7df3533777882a1081451493031162c8c2d5538/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfab9cc98b50546d2a1e6feaecbd27cc25bf6561", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfab9cc98b50546d2a1e6feaecbd27cc25bf6561", "html_url": "https://github.com/rust-lang/rust/commit/cfab9cc98b50546d2a1e6feaecbd27cc25bf6561"}, {"sha": "85defffea58139e3e5cc0811e499330fa24267ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/85defffea58139e3e5cc0811e499330fa24267ac", "html_url": "https://github.com/rust-lang/rust/commit/85defffea58139e3e5cc0811e499330fa24267ac"}], "stats": {"total": 519, "additions": 353, "deletions": 166}, "files": [{"sha": "8a00622486ddc294a9cdd9506f1375cf8e3f8148", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -1856,7 +1856,7 @@ impl LintPass for UnconditionalRecursion {\n                 continue\n             }\n             visited.insert(cfg_id);\n-            let node_id = cfg.graph.node_data(idx).id;\n+            let node_id = cfg.graph.node_data(idx).id();\n \n             // is this a recursive call?\n             if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {"}, {"sha": "52eedc460eb8749695fcb74cca6efab951c950cd", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 143, "deletions": 99, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -11,16 +11,15 @@\n use middle::cfg::*;\n use middle::def;\n use middle::graph;\n+use middle::pat_util;\n use middle::region::CodeExtent;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ptr::P;\n-use util::nodemap::NodeMap;\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n     loop_scopes: Vec<LoopScope>,\n@@ -36,35 +35,29 @@ struct LoopScope {\n pub fn construct(tcx: &ty::ctxt,\n                  blk: &ast::Block) -> CFG {\n     let mut graph = graph::Graph::new();\n-    let entry = add_initial_dummy_node(&mut graph);\n+    let entry = graph.add_node(CFGNodeData::Entry);\n \n     // `fn_exit` is target of return exprs, which lies somewhere\n     // outside input `blk`. (Distinguishing `fn_exit` and `block_exit`\n     // also resolves chicken-and-egg problem that arises if you try to\n     // have return exprs jump to `block_exit` during construction.)\n-    let fn_exit = add_initial_dummy_node(&mut graph);\n+    let fn_exit = graph.add_node(CFGNodeData::Exit);\n     let block_exit;\n \n     let mut cfg_builder = CFGBuilder {\n-        exit_map: NodeMap(),\n         graph: graph,\n         fn_exit: fn_exit,\n         tcx: tcx,\n         loop_scopes: Vec::new()\n     };\n     block_exit = cfg_builder.block(blk, entry);\n     cfg_builder.add_contained_edge(block_exit, fn_exit);\n-    let CFGBuilder {exit_map, graph, ..} = cfg_builder;\n-    CFG {exit_map: exit_map,\n-         graph: graph,\n+    let CFGBuilder {graph, ..} = cfg_builder;\n+    CFG {graph: graph,\n          entry: entry,\n          exit: fn_exit}\n }\n \n-fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {\n-    g.add_node(CFGNodeData { id: ast::DUMMY_NODE_ID })\n-}\n-\n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n@@ -74,19 +67,19 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n \n-        self.add_node(blk.id, &[expr_exit])\n+        self.add_ast_node(blk.id, &[expr_exit])\n     }\n \n     fn stmt(&mut self, stmt: &ast::Stmt, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n             ast::StmtDecl(ref decl, id) => {\n                 let exit = self.decl(&**decl, pred);\n-                self.add_node(id, &[exit])\n+                self.add_ast_node(id, &[exit])\n             }\n \n             ast::StmtExpr(ref expr, id) | ast::StmtSemi(ref expr, id) => {\n                 let exit = self.expr(&**expr, pred);\n-                self.add_node(id, &[exit])\n+                self.add_ast_node(id, &[exit])\n             }\n \n             ast::StmtMac(..) => {\n@@ -115,33 +108,33 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             ast::PatLit(..) |\n             ast::PatRange(..) |\n             ast::PatWild(_) => {\n-                self.add_node(pat.id, &[pred])\n+                self.add_ast_node(pat.id, &[pred])\n             }\n \n             ast::PatBox(ref subpat) |\n             ast::PatRegion(ref subpat, _) |\n             ast::PatIdent(_, _, Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&**subpat, pred);\n-                self.add_node(pat.id, &[subpat_exit])\n+                self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n             ast::PatEnum(_, Some(ref subpats)) |\n             ast::PatTup(ref subpats) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n-                self.add_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n             ast::PatStruct(_, ref subpats, _) => {\n                 let pats_exit =\n                     self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n-                self.add_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n             ast::PatVec(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);\n-                self.add_node(pat.id, &[post_exit])\n+                self.add_ast_node(pat.id, &[post_exit])\n             }\n \n             ast::PatMac(_) => {\n@@ -157,28 +150,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         pats.fold(pred, |pred, pat| self.pat(&**pat, pred))\n     }\n \n-    fn pats_any(&mut self,\n-                pats: &[P<ast::Pat>],\n-                pred: CFGIndex) -> CFGIndex {\n-        //! Handles case where just one of the patterns must match.\n-\n-        if pats.len() == 1 {\n-            self.pat(&*pats[0], pred)\n-        } else {\n-            let collect = self.add_dummy_node(&[]);\n-            for pat in pats {\n-                let pat_exit = self.pat(&**pat, pred);\n-                self.add_contained_edge(pat_exit, collect);\n-            }\n-            collect\n-        }\n-    }\n-\n     fn expr(&mut self, expr: &ast::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n             ast::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(&**blk, pred);\n-                self.add_node(expr.id, &[blk_exit])\n+                self.add_ast_node(expr.id, &[blk_exit])\n             }\n \n             ast::ExprIf(ref cond, ref then, None) => {\n@@ -198,7 +174,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n-                self.add_node(expr.id, &[cond_exit, then_exit])          // 3,4\n+                self.add_ast_node(expr.id, &[cond_exit, then_exit])      // 3,4\n             }\n \n             ast::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n@@ -219,7 +195,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n                 let else_exit = self.expr(&**otherwise, cond_exit);      // 3\n-                self.add_node(expr.id, &[then_exit, else_exit])          // 4, 5\n+                self.add_ast_node(expr.id, &[then_exit, else_exit])      // 4, 5\n             }\n \n             ast::ExprIfLet(..) => {\n@@ -247,7 +223,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n                 let cond_exit = self.expr(&**cond, loopback);             // 2\n-                let expr_exit = self.add_node(expr.id, &[cond_exit]);     // 3\n+                let expr_exit = self.add_ast_node(expr.id, &[cond_exit]); // 3\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n@@ -283,7 +259,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // may cause additional edges.\n \n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let expr_exit = self.add_node(expr.id, &[]);              // 2\n+                let expr_exit = self.add_ast_node(expr.id, &[]);          // 2\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n@@ -296,45 +272,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprMatch(ref discr, ref arms, _) => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //    [discr]\n-                //       |\n-                //       v 2\n-                //    [cond1]\n-                //      /  \\\n-                //     |    \\\n-                //     v 3   \\\n-                //  [pat1]    \\\n-                //     |       |\n-                //     v 4     |\n-                //  [guard1]   |\n-                //     |       |\n-                //     |       |\n-                //     v 5     v\n-                //  [body1]  [cond2]\n-                //     |      /  \\\n-                //     |    ...  ...\n-                //     |     |    |\n-                //     v 6   v    v\n-                //  [.....expr.....]\n-                //\n-                let discr_exit = self.expr(&**discr, pred);              // 1\n-\n-                let expr_exit = self.add_node(expr.id, &[]);\n-                let mut cond_exit = discr_exit;\n-                for arm in arms {\n-                    cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(&arm.pats,\n-                                                  cond_exit);            // 3\n-                    let guard_exit = self.opt_expr(&arm.guard,\n-                                                   pats_exit);           // 4\n-                    let body_exit = self.expr(&*arm.body, guard_exit);   // 5\n-                    self.add_contained_edge(body_exit, expr_exit);       // 6\n-                }\n-                expr_exit\n+                self.match_(expr.id, &discr, &arms, pred)\n             }\n \n             ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {\n@@ -354,30 +292,30 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let l_exit = self.expr(&**l, pred);                      // 1\n                 let r_exit = self.expr(&**r, l_exit);                    // 2\n-                self.add_node(expr.id, &[l_exit, r_exit])                 // 3,4\n+                self.add_ast_node(expr.id, &[l_exit, r_exit])            // 3,4\n             }\n \n             ast::ExprRet(ref v) => {\n                 let v_exit = self.opt_expr(v, pred);\n-                let b = self.add_node(expr.id, &[v_exit]);\n+                let b = self.add_ast_node(expr.id, &[v_exit]);\n                 self.add_returning_edge(expr, b);\n-                self.add_node(ast::DUMMY_NODE_ID, &[])\n+                self.add_unreachable_node()\n             }\n \n             ast::ExprBreak(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n-                let b = self.add_node(expr.id, &[pred]);\n+                let b = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n-                self.add_node(ast::DUMMY_NODE_ID, &[])\n+                self.add_unreachable_node()\n             }\n \n             ast::ExprAgain(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n-                let a = self.add_node(expr.id, &[pred]);\n+                let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n-                self.add_node(ast::DUMMY_NODE_ID, &[])\n+                self.add_unreachable_node()\n             }\n \n             ast::ExprVec(ref elems) => {\n@@ -454,7 +392,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     let &(_, ref expr, _) = a;\n                     &**expr\n                 }), post_inputs);\n-                self.add_node(expr.id, &[post_outputs])\n+                self.add_ast_node(expr.id, &[post_outputs])\n             }\n \n             ast::ExprMac(..) |\n@@ -481,7 +419,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n         if return_ty.diverges() {\n-            self.add_node(ast::DUMMY_NODE_ID, &[])\n+            self.add_unreachable_node()\n         } else {\n             ret\n         }\n@@ -508,20 +446,126 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n         let subexprs_exit = self.exprs(subexprs, pred);\n-        self.add_node(expr.id, &[subexprs_exit])\n+        self.add_ast_node(expr.id, &[subexprs_exit])\n+    }\n+\n+    fn match_(&mut self, id: ast::NodeId, discr: &ast::Expr,\n+              arms: &[ast::Arm], pred: CFGIndex) -> CFGIndex {\n+        // The CFG for match expression is quite complex, so no ASCII\n+        // art for it (yet).\n+        //\n+        // The CFG generated below matches roughly what trans puts\n+        // out. Each pattern and guard is visited in parallel, with\n+        // arms containing multiple patterns generating multiple nodes\n+        // for the same guard expression. The guard expressions chain\n+        // into each other from top to bottom, with a specific\n+        // exception to allow some additional valid programs\n+        // (explained below). Trans differs slightly in that the\n+        // pattern matching may continue after a guard but the visible\n+        // behaviour should be the same.\n+        //\n+        // What is going on is explained in further comments.\n+\n+        // Visit the discriminant expression\n+        let discr_exit = self.expr(discr, pred);\n+\n+        // Add a node for the exit of the match expression as a whole.\n+        let expr_exit = self.add_ast_node(id, &[]);\n+\n+        // Keep track of the previous guard expressions\n+        let mut prev_guards = Vec::new();\n+        // Track if the previous pattern contained bindings or wildcards\n+        let mut prev_has_bindings = false;\n+\n+        for arm in arms {\n+            // Add an exit node for when we've visited all the\n+            // patterns and the guard (if there is one) in the arm.\n+            let arm_exit = self.add_dummy_node(&[]);\n+\n+            for pat in &arm.pats {\n+                // Visit the pattern, coming from the discriminant exit\n+                let mut pat_exit = self.pat(&**pat, discr_exit);\n+\n+                // If there is a guard expression, handle it here\n+                if let Some(ref guard) = arm.guard {\n+                    // Add a dummy node for the previous guard\n+                    // expression to target\n+                    let guard_start = self.add_dummy_node(&[pat_exit]);\n+                    // Visit the guard expression\n+                    let guard_exit = self.expr(&**guard, guard_start);\n+\n+                    let this_has_bindings = pat_util::pat_contains_bindings_or_wild(\n+                        &self.tcx.def_map, &**pat);\n+\n+                    // If both this pattern and the previous pattern\n+                    // were free of bindings, they must consist only\n+                    // of \"constant\" patterns. Note we cannot match an\n+                    // all-constant pattern, fail the guard, and then\n+                    // match *another* all-constant pattern. This is\n+                    // because if the previous pattern matches, then\n+                    // we *cannot* match this one, unless all the\n+                    // constants are the same (which is rejected by\n+                    // `check_match`).\n+                    //\n+                    // We can use this to be smarter about the flow\n+                    // along guards. If the previous pattern matched,\n+                    // then we know we will not visit the guard in\n+                    // this one (whether or not the guard succeeded),\n+                    // if the previous pattern failed, then we know\n+                    // the guard for that pattern will not have been\n+                    // visited. Thus, it is not possible to visit both\n+                    // the previous guard and the current one when\n+                    // both patterns consist only of constant\n+                    // sub-patterns.\n+                    //\n+                    // However, if the above does not hold, then all\n+                    // previous guards need to be wired to visit the\n+                    // current guard pattern.\n+                    if prev_has_bindings || this_has_bindings {\n+                        while let Some(prev) = prev_guards.pop() {\n+                            self.add_contained_edge(prev, guard_start);\n+                        }\n+                    }\n+\n+                    prev_has_bindings = this_has_bindings;\n+\n+                    // Push the guard onto the list of previous guards\n+                    prev_guards.push(guard_exit);\n+\n+                    // Update the exit node for the pattern\n+                    pat_exit = guard_exit;\n+                }\n+\n+                // Add an edge from the exit of this pattern to the\n+                // exit of the arm\n+                self.add_contained_edge(pat_exit, arm_exit);\n+            }\n+\n+            // Visit the body of this arm\n+            let body_exit = self.expr(&arm.body, arm_exit);\n+\n+            // Link the body to the exit of the expression\n+            self.add_contained_edge(body_exit, expr_exit);\n+        }\n+\n+        expr_exit\n     }\n \n     fn add_dummy_node(&mut self, preds: &[CFGIndex]) -> CFGIndex {\n-        self.add_node(ast::DUMMY_NODE_ID, preds)\n+        self.add_node(CFGNodeData::Dummy, preds)\n     }\n \n-    fn add_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n-        assert!(!self.exit_map.contains_key(&id));\n-        let node = self.graph.add_node(CFGNodeData {id: id});\n-        if id != ast::DUMMY_NODE_ID {\n-            assert!(!self.exit_map.contains_key(&id));\n-            self.exit_map.insert(id, node);\n-        }\n+    fn add_ast_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n+        assert!(id != ast::DUMMY_NODE_ID);\n+        self.add_node(CFGNodeData::AST(id), preds)\n+    }\n+\n+    fn add_unreachable_node(&mut self) -> CFGIndex {\n+        self.add_node(CFGNodeData::Unreachable, &[])\n+    }\n+\n+    fn add_node(&mut self, data: CFGNodeData, preds: &[CFGIndex]) -> CFGIndex {\n+        let node = self.graph.add_node(data);\n         for &pred in preds {\n             self.add_contained_edge(pred, node);\n         }"}, {"sha": "0c5eca3c12968ee3b93d6b31371109271ef572c0", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -65,10 +65,10 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             dot::LabelText::LabelStr(\"entry\".into_cow())\n         } else if i == self.cfg.exit {\n             dot::LabelText::LabelStr(\"exit\".into_cow())\n-        } else if n.data.id == ast::DUMMY_NODE_ID {\n+        } else if n.data.id() == ast::DUMMY_NODE_ID {\n             dot::LabelText::LabelStr(\"(dummy_node)\".into_cow())\n         } else {\n-            let s = self.ast_map.node_to_string(n.data.id);\n+            let s = self.ast_map.node_to_string(n.data.id());\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n             dot::LabelText::EscStr(s.into_cow())"}, {"sha": "e8a99f59b1e95b365c9c0e4184757608978b8638", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -14,21 +14,33 @@\n use middle::graph;\n use middle::ty;\n use syntax::ast;\n-use util::nodemap::NodeMap;\n \n mod construct;\n pub mod graphviz;\n \n pub struct CFG {\n-    pub exit_map: NodeMap<CFGIndex>,\n     pub graph: CFGGraph,\n     pub entry: CFGIndex,\n     pub exit: CFGIndex,\n }\n \n-#[derive(Copy)]\n-pub struct CFGNodeData {\n-    pub id: ast::NodeId\n+#[derive(Copy, PartialEq)]\n+pub enum CFGNodeData {\n+    AST(ast::NodeId),\n+    Entry,\n+    Exit,\n+    Dummy,\n+    Unreachable,\n+}\n+\n+impl CFGNodeData {\n+    pub fn id(&self) -> ast::NodeId {\n+        if let CFGNodeData::AST(id) = *self {\n+            id\n+        } else {\n+            ast::DUMMY_NODE_ID\n+        }\n+    }\n }\n \n pub struct CFGEdgeData {\n@@ -50,6 +62,6 @@ impl CFG {\n     }\n \n     pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n-        self.graph.depth_traverse(self.entry).any(|node| node.id == id)\n+        self.graph.depth_traverse(self.entry).any(|node| node.id() == id)\n     }\n }"}, {"sha": "1718df702553f0f94886f0b365fd880ad55ad439", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 68, "deletions": 40, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -53,7 +53,7 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n \n     // mapping from node to cfg node index\n     // FIXME (#6298): Shouldn't this go with CFG?\n-    nodeid_to_index: NodeMap<CFGIndex>,\n+    nodeid_to_index: NodeMap<Vec<CFGIndex>>,\n \n     // Bit sets per cfg node.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n@@ -88,11 +88,9 @@ struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n     changed: bool\n }\n \n-fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n-    let opt_cfgindex = index.get(&id).cloned();\n-    opt_cfgindex.unwrap_or_else(|| {\n-        panic!(\"nodeid_to_index does not have entry for NodeId {}\", id);\n-    })\n+fn get_cfg_indices<'a>(id: ast::NodeId, index: &'a NodeMap<Vec<CFGIndex>>) -> &'a [CFGIndex] {\n+    let opt_indices = index.get(&id);\n+    opt_indices.map(|v| &v[..]).unwrap_or(&[])\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n@@ -114,9 +112,13 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             pprust::NodePat(pat) => pat.id\n         };\n \n-        if self.has_bitset_for_nodeid(id) {\n-            assert!(self.bits_per_id > 0);\n-            let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        if !self.has_bitset_for_nodeid(id) {\n+            return Ok(());\n+        }\n+\n+        assert!(self.bits_per_id > 0);\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let on_entry = &self.on_entry[start.. end];\n             let entry_str = bits_to_string(on_entry);\n@@ -144,7 +146,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n }\n \n fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n-                         cfg: &cfg::CFG) -> NodeMap<CFGIndex> {\n+                         cfg: &cfg::CFG) -> NodeMap<Vec<CFGIndex>> {\n     let mut index = NodeMap();\n \n     // FIXME (#6298): Would it be better to fold formals from decl\n@@ -157,28 +159,38 @@ fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n     }\n \n     cfg.graph.each_node(|node_idx, node| {\n-        if node.data.id != ast::DUMMY_NODE_ID {\n-            index.insert(node.data.id, node_idx);\n+        if let cfg::CFGNodeData::AST(id) = node.data {\n+            match index.entry(id).get() {\n+                Ok(v) => v.push(node_idx),\n+                Err(e) => {\n+                    e.insert(vec![node_idx]);\n+                }\n+            }\n         }\n         true\n     });\n \n     return index;\n \n-    fn add_entries_from_fn_decl(index: &mut NodeMap<CFGIndex>,\n+    fn add_entries_from_fn_decl(index: &mut NodeMap<Vec<CFGIndex>>,\n                                 decl: &ast::FnDecl,\n                                 entry: CFGIndex) {\n         //! add mappings from the ast nodes for the formal bindings to\n         //! the entry-node in the graph.\n         struct Formals<'a> {\n             entry: CFGIndex,\n-            index: &'a mut NodeMap<CFGIndex>,\n+            index: &'a mut NodeMap<Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n         visit::walk_fn_decl(&mut formals, decl);\n         impl<'a, 'v> visit::Visitor<'v> for Formals<'a> {\n             fn visit_pat(&mut self, p: &ast::Pat) {\n-                self.index.insert(p.id, self.entry);\n+                match self.index.entry(p.id).get() {\n+                    Ok(v) => v.push(self.entry),\n+                    Err(e) => {\n+                        e.insert(vec![self.entry]);\n+                    }\n+                }\n                 visit::walk_pat(self, p)\n             }\n         }\n@@ -230,10 +242,12 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = &mut self.gens[start.. end];\n-        set_bit(gens, bit);\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            let gens = &mut self.gens[start.. end];\n+            set_bit(gens, bit);\n+        }\n     }\n \n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n@@ -243,10 +257,12 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let kills = &mut self.kills[start.. end];\n-        set_bit(kills, bit);\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            let kills = &mut self.kills[start.. end];\n+            set_bit(kills, bit);\n+        }\n     }\n \n     fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n@@ -279,16 +295,21 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n \n-    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, f: F) -> bool where\n+    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n         F: FnMut(uint) -> bool,\n     {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n         if !self.has_bitset_for_nodeid(id) {\n             return true;\n         }\n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        self.each_bit_for_node(Entry, cfgidx, f)\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            if !self.each_bit_for_node(Entry, cfgidx, |i| f(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     pub fn each_bit_for_node<F>(&self, e: EntryOrExit, cfgidx: CFGIndex, f: F) -> bool where\n@@ -320,7 +341,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit(slice, f)\n     }\n \n-    pub fn each_gen_bit<F>(&self, id: ast::NodeId, f: F) -> bool where\n+    pub fn each_gen_bit<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n         F: FnMut(uint) -> bool,\n     {\n         //! Iterates through each bit in the gen set for `id`.\n@@ -334,12 +355,17 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             return true;\n         }\n \n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = &self.gens[start.. end];\n-        debug!(\"{} each_gen_bit(id={}, gens={})\",\n-               self.analysis_name, id, bits_to_string(gens));\n-        self.each_bit(gens, f)\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            let gens = &self.gens[start.. end];\n+            debug!(\"{} each_gen_bit(id={}, gens={})\",\n+                   self.analysis_name, id, bits_to_string(gens));\n+            if !self.each_bit(gens, |i| f(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     fn each_bit<F>(&self, words: &[uint], mut f: F) -> bool where\n@@ -400,13 +426,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n             let mut changed = false;\n             for &node_id in &edge.data.exiting_scopes {\n-                let opt_cfg_idx = self.nodeid_to_index.get(&node_id).cloned();\n+                let opt_cfg_idx = self.nodeid_to_index.get(&node_id);\n                 match opt_cfg_idx {\n-                    Some(cfg_idx) => {\n-                        let (start, end) = self.compute_id_range(cfg_idx);\n-                        let kills = &self.kills[start.. end];\n-                        if bitwise(&mut orig_kills, kills, &Union) {\n-                            changed = true;\n+                    Some(indices) => {\n+                        for &cfg_idx in indices {\n+                            let (start, end) = self.compute_id_range(cfg_idx);\n+                            let kills = &self.kills[start.. end];\n+                            if bitwise(&mut orig_kills, kills, &Union) {\n+                                changed = true;\n+                            }\n                         }\n                     }\n                     None => {\n@@ -482,7 +510,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n \n         cfg.graph.each_node(|node_index, node| {\n             debug!(\"DataFlowContext::walk_cfg idx={:?} id={} begin in_out={}\",\n-                   node_index, node.data.id, bits_to_string(in_out));\n+                   node_index, node.data.id(), bits_to_string(in_out));\n \n             let (start, end) = self.dfcx.compute_id_range(node_index);\n "}, {"sha": "a7df2f4a5dafb4dfe3e4b90e6a2a0b748ca05f2f", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -119,6 +119,21 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &ast::Pat) -> bool {\n     contains_bindings\n }\n \n+/// Checks if the pattern contains any patterns that bind something to\n+/// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n+pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &ast::Pat) -> bool {\n+    let mut contains_bindings = false;\n+    walk_pat(pat, |p| {\n+        if pat_is_binding_or_wild(dm, p) {\n+            contains_bindings = true;\n+            false // there's at least one binding/wildcard, can short circuit now.\n+        } else {\n+            true\n+        }\n+    });\n+    contains_bindings\n+}\n+\n pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n     match pat.node {\n         ast::PatIdent(ast::BindByValue(_), ref path1, None) => {"}, {"sha": "b0a03408b51e1fed5dc832b662dc0ca620f86769", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -612,13 +612,26 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n                 let (suggestion, _) =\n                     move_suggestion(param_env, expr_span, expr_ty, (\"moved by default\", \"\"));\n-                self.tcx.sess.span_note(\n-                    expr_span,\n-                    &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n-                            ol,\n-                            moved_lp_msg,\n-                            expr_ty.user_string(self.tcx),\n-                            suggestion));\n+                // If the two spans are the same, it's because the expression will be evaluated\n+                // multiple times. Avoid printing the same span and adjust the wording so it makes\n+                // more sense that it's from multiple evalutations.\n+                if expr_span == use_span {\n+                    self.tcx.sess.note(\n+                        &format!(\"`{}` was previously moved here{} because it has type `{}`, \\\n+                                  which is {}\",\n+                                 ol,\n+                                 moved_lp_msg,\n+                                 expr_ty.user_string(self.tcx),\n+                                 suggestion));\n+                } else {\n+                    self.tcx.sess.span_note(\n+                        expr_span,\n+                        &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n+                                 ol,\n+                                 moved_lp_msg,\n+                                 expr_ty.user_string(self.tcx),\n+                                 suggestion));\n+                }\n             }\n \n             move_data::MovePat => {"}, {"sha": "a2c9930c0ed2fdc36f4469af01af05eb292f4c28", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -52,7 +52,7 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n-        let id = n.1.data.id;\n+        let id = n.1.data.id();\n         debug!(\"dataflow_for({:?}, id={}) {:?}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;"}, {"sha": "7c989d9e0246c704090be75519dd302f2684b201", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -1353,7 +1353,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n // the clobbering of the existing value in the return slot.\n fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n     for n in cfg.graph.depth_traverse(cfg.entry) {\n-        match tcx.map.find(n.id) {\n+        match tcx.map.find(n.id()) {\n             Some(ast_map::NodeExpr(ex)) => {\n                 if let ast::ExprRet(Some(ref ret_expr)) = ex.node {\n                     let mut visitor = FindNestedReturn::new();"}, {"sha": "5d29d0e1fd083914964e45c8bb686ab5da2a082f", "filename": "src/test/compile-fail/move-in-guard-1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-1.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+pub fn main() {\n+    let x = box 1;\n+\n+    let v = (1, 2);\n+\n+    match v {\n+        (1, _) if take(x) => (),\n+        (_, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n+        _ => (),\n+    }\n+}\n+\n+fn take<T>(_: T) -> bool { false }"}, {"sha": "23af25797975f3720843c415adf2ef098ffbd48a", "filename": "src/test/compile-fail/move-in-guard-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-2.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+pub fn main() {\n+    let x = box 1;\n+\n+    let v = (1, 2);\n+\n+    match v {\n+        (1, _) |\n+        (_, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n+        _ => (),\n+    }\n+}\n+\n+fn take<T>(_: T) -> bool { false }"}, {"sha": "51c6b14e1deedb01fed39975d73f22ed15b113cf", "filename": "src/test/run-make/graphviz-flowgraph/f07.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -22,12 +22,12 @@ digraph block {\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n-    N6 -> N8;\n-    N8 -> N9;\n+    N6 -> N9;\n     N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N13;\n+    N12 -> N8;\n+    N8 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n     N15 -> N7;"}, {"sha": "fb7d2ad97bd5f553277f80ae09dfcba4cbd3f1bd", "filename": "src/test/run-make/graphviz-flowgraph/f13.dot-expected.dot", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -32,16 +32,16 @@ digraph block {\n     N6 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n-    N9 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n+    N9 -> N12;\n+    N12 -> N11;\n+    N11 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n     N15 -> N10;\n-    N11 -> N16;\n-    N16 -> N17;\n+    N9 -> N17;\n     N17 -> N18;\n-    N18 -> N19;\n+    N18 -> N16;\n+    N16 -> N19;\n     N19 -> N20;\n     N20 -> N21;\n     N21 -> N22;"}, {"sha": "64c4f1fdbaeabf6e2d9e06bdb80646e4063c4ede", "filename": "src/test/run-pass/move-guard-const.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d7df3533777882a1081451493031162c8c2d5538/src%2Ftest%2Frun-pass%2Fmove-guard-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7df3533777882a1081451493031162c8c2d5538/src%2Ftest%2Frun-pass%2Fmove-guard-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-guard-const.rs?ref=d7df3533777882a1081451493031162c8c2d5538", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let x = box 1;\n+\n+    let v = (1, 2);\n+\n+    match v {\n+        (2, 1) if take(x) => (),\n+        (1, 2) if take(x) => (),\n+        _ => (),\n+    }\n+}\n+\n+fn take<T>(_: T) -> bool { false }"}]}