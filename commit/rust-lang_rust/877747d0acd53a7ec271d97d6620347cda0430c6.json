{"sha": "877747d0acd53a7ec271d97d6620347cda0430c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3Nzc0N2QwYWNkNTNhN2VjMjcxZDk3ZDY2MjAzNDdjZGEwNDMwYzY=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-03-26T18:09:57Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:48Z"}, "message": "wired up uv_read_start and some helper funcs around uv_alloc_cb tasks", "tree": {"sha": "cc49a0f004a89ee266d0f1dbcbdb8dbf0cffa66f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc49a0f004a89ee266d0f1dbcbdb8dbf0cffa66f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/877747d0acd53a7ec271d97d6620347cda0430c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/877747d0acd53a7ec271d97d6620347cda0430c6", "html_url": "https://github.com/rust-lang/rust/commit/877747d0acd53a7ec271d97d6620347cda0430c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/877747d0acd53a7ec271d97d6620347cda0430c6/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0193dac6edae6c4c5dd1a8fffeb3d9f922769bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0193dac6edae6c4c5dd1a8fffeb3d9f922769bd", "html_url": "https://github.com/rust-lang/rust/commit/e0193dac6edae6c4c5dd1a8fffeb3d9f922769bd"}], "stats": {"total": 177, "additions": 150, "deletions": 27}, "files": [{"sha": "fe22df30ae1405c339aeef99fe4c05d65816c73d", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 120, "deletions": 26, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/877747d0acd53a7ec271d97d6620347cda0430c6/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/877747d0acd53a7ec271d97d6620347cda0430c6/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=877747d0acd53a7ec271d97d6620347cda0430c6", "patch": "@@ -285,6 +285,10 @@ native mod rustrt {\n     fn rust_uv_write(req: *libc::c_void, stream: *libc::c_void,\n              ++buf_in: *uv_buf_t, buf_cnt: libc::c_int,\n              cb: *u8) -> libc::c_int;\n+    fn rust_uv_read_start(stream: *libc::c_void, on_alloc: *u8,\n+                          on_read: *u8) -> libc::c_int;\n+    fn rust_uv_malloc_buf_base_of(sug_size: libc::size_t) -> *u8;\n+    fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n \n     // sizeof testing helpers\n     fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n@@ -295,7 +299,11 @@ native mod rustrt {\n     fn rust_uv_helper_sockaddr_in_size() -> libc::c_uint;\n \n     // data accessors for rust-mapped uv structs\n-    fn rust_uv_get_stream_handle_for_connect(connect: *uv_connect_t)\n+    fn rust_uv_get_stream_handle_from_connect_req(\n+        connect_req: *uv_connect_t)\n+        -> *uv_stream_t;\n+    fn rust_uv_get_stream_handle_from_write_req(\n+        write_req: *uv_write_t)\n         -> *uv_stream_t;\n     fn rust_uv_get_loop_for_uv_handle(handle: *libc::c_void)\n         -> *libc::c_void;\n@@ -347,6 +355,11 @@ mod direct {\n         let buf_cnt = vec::len(*buf_in) as i32;\n         ret rustrt::rust_uv_write(req, stream, buf_ptr, buf_cnt, cb);\n     }\n+    unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8,\n+                         on_read: *u8) -> libc::c_int {\n+        ret rustrt::rust_uv_read_start(stream as *libc::c_void,\n+                                       on_alloc, on_read);\n+    }\n \n     unsafe fn uv_last_error(loop_handle: *libc::c_void) -> uv_err_t {\n         ret rustrt::rust_uv_last_error(loop_handle);\n@@ -366,9 +379,16 @@ mod direct {\n         -> *libc::c_void {\n         ret rustrt::rust_uv_get_loop_for_uv_handle(handle);\n     }\n-    unsafe fn get_stream_handle_for_connect(connect: *uv_connect_t)\n+    unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t)\n+        -> *uv_stream_t {\n+        ret rustrt::rust_uv_get_stream_handle_from_connect_req(\n+            connect);\n+    }\n+    unsafe fn get_stream_handle_from_write_req(\n+        write_req: *uv_write_t)\n         -> *uv_stream_t {\n-        ret rustrt::rust_uv_get_stream_handle_for_connect(connect);\n+        ret rustrt::rust_uv_get_stream_handle_from_write_req(\n+            write_req);\n     }\n \n     unsafe fn get_data_for_req(req: *libc::c_void) -> *libc::c_void {\n@@ -392,10 +412,12 @@ mod direct {\n         ret rustrt::rust_uv_ip4_addr(addr_vec_ptr,\n                                      port as libc::c_int);\n     }\n-    // this is lame.\n-    // TODO: see github issue #1402\n-    unsafe fn free_1402(ptr: *libc::c_void) {\n-        rustrt::rust_uv_free(ptr);\n+    unsafe fn malloc_buf_base_of(suggested_size: libc::size_t)\n+        -> *u8 {\n+        ret rustrt::rust_uv_malloc_buf_base_of(suggested_size);\n+    }\n+    unsafe fn free_base_of_buf(buf: uv_buf_t) {\n+        rustrt::rust_uv_free_base_of_buf(buf);\n     }\n }\n \n@@ -948,42 +970,80 @@ fn test_uv_timer() {\n \n // BEGIN TCP REQUEST TEST SUITE\n \n+enum tcp_read_data {\n+    tcp_read_eof,\n+    tcp_read_more([u8]),\n+    tcp_read_error\n+}\n+\n type request_wrapper = {\n     write_req: *uv_write_t,\n-    req_buf: *[uv_buf_t]\n+    req_buf: *[uv_buf_t],\n+    read_chan: comm::chan<tcp_read_data>\n };\n \n-crust fn on_write_complete_cb(write_handle: *uv_write_t,\n+crust fn on_alloc_cb(handle: *libc::c_void,\n+                     suggested_size: libc::size_t) -> uv_buf_t\n+    unsafe {\n+    io::println(\"on_alloc_cb!\");\n+    let char_ptr = direct::malloc_buf_base_of(suggested_size);\n+    ret direct::buf_init(char_ptr, suggested_size);\n+}\n+\n+// do I need the explicit copy on the buf param?\n+crust fn on_read_cb(stream: *uv_stream_t, nread: libc::ssize_t,\n+                    ++buf: uv_buf_t) unsafe {\n+    if (nread > 0) {\n+        // we have data\n+        io::println(#fmt(\"read: data! nread: %d\", nread));\n+    }\n+    else if (nread == -1) {\n+        // err .. possibly EOF\n+        io::println(\"read: eof!\");\n+    }\n+    else {\n+        // nread == 0 .. do nothing, just free buf as below\n+        io::println(\"read: do nothing!\");\n+    }\n+    // when we're done\n+    direct::free_base_of_buf(buf);\n+    io::println(\"exiting on_read_cb\");\n+}\n+\n+crust fn on_write_complete_cb(write_req: *uv_write_t,\n                               status: libc::c_int) unsafe {\n     io::println(#fmt(\"beginning on_write_complete_cb status: %d\",\n                      status as int));\n-    io::println(\"ending on_write_complete_cb\");\n+    let stream = direct::get_stream_handle_from_write_req(write_req);\n+    io::println(#fmt(\"on_write_complete_cb: tcp stream: %d write_handle addr %d\",\n+        stream as int, write_req as int));\n+    let result = direct::read_start(stream, on_alloc_cb, on_read_cb);\n+    io::println(#fmt(\"ending on_write_complete_cb .. uv_read_start status: %d\", result as int));\n }\n \n-crust fn on_connect_cb(connect_handle_ptr: *uv_connect_t,\n+crust fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n                              status: libc::c_int) unsafe {\n     io::println(#fmt(\"beginning on_connect_cb .. status: %d\",\n                      status as int));\n-    let stream = direct::get_stream_handle_for_connect(connect_handle_ptr);\n+    let stream =\n+        direct::get_stream_handle_from_connect_req(connect_req_ptr);\n     if (status == 0i32) {\n         io::println(\"on_connect_cb: in status=0 if..\");\n-        let data = direct::get_data_for_req(\n-            connect_handle_ptr as *libc::c_void)\n+        let client_data = direct::get_data_for_req(\n+            connect_req_ptr as *libc::c_void)\n             as *request_wrapper;\n-        let write_handle = (*data).write_req as *libc::c_void;\n+        let write_handle = (*client_data).write_req as *libc::c_void;\n         io::println(#fmt(\"on_connect_cb: tcp stream: %d write_handle addr %d\",\n                         stream as int, write_handle as int));\n         let write_result = direct::write(write_handle,\n                           stream as *libc::c_void,\n-                          (*data).req_buf,\n+                          (*client_data).req_buf,\n                           on_write_complete_cb);\n         io::println(#fmt(\"on_connect_cb: direct::write() status: %d\",\n                          write_result as int));\n     }\n     else {\n-        let loop_handle = direct::get_loop_for_uv_handle(\n-            stream as *libc::c_void);\n-        let err = direct::uv_last_error(loop_handle);\n+        io::println(\"non-zero status for on_connect_cb..\");\n     }\n     io::println(\"finishing on_connect_cb\");\n }\n@@ -993,7 +1053,7 @@ fn impl_uv_tcp_request() unsafe {\n     let tcp_handle = direct::tcp_t();\n     let tcp_handle_ptr = ptr::addr_of(tcp_handle);\n     let connect_handle = direct::connect_t();\n-    let connect_handle_ptr = ptr::addr_of(connect_handle);\n+    let connect_req_ptr = ptr::addr_of(connect_handle);\n \n     // this is the persistent payload of data that we\n     // need to pass around to get this example to work.\n@@ -1013,8 +1073,11 @@ fn impl_uv_tcp_request() unsafe {\n     io::println(#fmt(\"tcp req: tcp stream: %d write_handle: %d\",\n                      tcp_handle_ptr as int,\n                      write_handle_ptr as int));\n-    let req = { writer_handle: write_handle_ptr,\n-                req_buf: ptr::addr_of(req_msg) };\n+    let read_port = comm::port::<tcp_read_data>();\n+    let read_chan = comm::chan::<tcp_read_data>(read_port);\n+    let client_data = { writer_handle: write_handle_ptr,\n+                req_buf: ptr::addr_of(req_msg),\n+                read_chan: read_chan };\n     \n     let tcp_init_result = direct::tcp_init(\n         test_loop as *libc::c_void, tcp_handle_ptr);\n@@ -1030,18 +1093,48 @@ fn impl_uv_tcp_request() unsafe {\n         \n         // this should set up the connection request..\n         let tcp_connect_result = direct::tcp_connect(\n-            connect_handle_ptr, tcp_handle_ptr,\n+            connect_req_ptr, tcp_handle_ptr,\n             addr, on_connect_cb);\n         if (tcp_connect_result == 0i32) {\n             // not set the data on the connect_req\n             // until its initialized\n             direct::set_data_for_req(\n-                connect_handle_ptr as *libc::c_void,\n-                ptr::addr_of(req) as *libc::c_void);\n+                connect_req_ptr as *libc::c_void,\n+                ptr::addr_of(client_data) as *libc::c_void);\n             io::println(\"before run tcp req loop\");\n             direct::run(test_loop);\n             io::println(\"after run tcp req loop\");\n-            // TODO: see github issue #1402\n+\n+            // now we read from the port to get data\n+            let mut read_bytes: [u8] = [0u8];\n+            let mut more_data = true;\n+            while(more_data) {\n+                alt comm::recv(read_port) {\n+                  tcp_read_eof {\n+                    more_data = false;\n+                  }\n+                  tcp_read_more(new_bytes) {\n+                    if (vec::len(read_bytes) == 1u &&\n+                        read_bytes[0] == 0u8) {\n+                        // the \"first\" read.. replace\n+                        // the stubbed out vec above\n+                        // with our initial set of read\n+                        // data\n+                    }\n+                    else {\n+                        // otherwise append\n+                        read_bytes = new_bytes;\n+                    }\n+                  }\n+                  _ {\n+                    assert false;\n+                  }\n+                }\n+            }\n+            io::println(\"finished reading data\");\n+            let read_str = str::from_bytes(read_bytes);\n+                \n+                \n         }\n         else {\n            io::println(\"direct::tcp_connect() failure\");\n@@ -1129,6 +1222,7 @@ fn impl_uv_byval_test() unsafe {\n                      addr.sin_port as uint));\n }\n #[test]\n+#[ignore(cfg(target_os = \"freebsd\"))]\n fn test_uv_ip4_byval_passing_test() {\n     impl_uv_byval_test();\n }"}, {"sha": "f753c55c69e1adc906d53043cc2754989a495d62", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/877747d0acd53a7ec271d97d6620347cda0430c6/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/877747d0acd53a7ec271d97d6620347cda0430c6/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=877747d0acd53a7ec271d97d6620347cda0430c6", "patch": "@@ -230,9 +230,13 @@ rust_uv_helper_sockaddr_in_size() {\n }\n \n extern \"C\" uv_stream_t*\n-rust_uv_get_stream_handle_for_connect(uv_connect_t* connect) {\n+rust_uv_get_stream_handle_from_connect_req(uv_connect_t* connect) {\n \treturn connect->handle;\n }\n+extern \"C\" uv_stream_t*\n+rust_uv_get_stream_handle_from_write_req(uv_write_t* write_req) {\n+\treturn write_req->handle;\n+}\n \n extern \"C\" uv_buf_t\n current_kernel_malloc_alloc_cb(uv_handle_t* handle,\n@@ -275,6 +279,16 @@ rust_uv_set_data_for_req(uv_req_t* req, void* data) {\n \treq->data = data;\n }\n \n+extern \"C\" char*\n+rust_uv_get_base_from_buf(uv_buf_t buf) {\n+\treturn buf.base;\n+}\n+\n+extern \"C\" size_t\n+rust_uv_get_len_from_buf(uv_buf_t buf) {\n+\treturn buf.len;\n+}\n+\n extern \"C\" uv_err_t\n rust_uv_last_error(uv_loop_t* loop) {\n \treturn uv_last_error(loop);\n@@ -302,6 +316,21 @@ rust_uv_write(uv_write_t* req, uv_stream_t* handle,\n \t\t\t  uv_write_cb cb) {\n \treturn uv_write(req, handle, bufs, buf_cnt, cb);\n }\n+extern \"C\" int\n+rust_uv_read_start(uv_stream_t* stream, uv_alloc_cb on_alloc,\n+\t\t\t\t   uv_read_cb on_read) {\n+    return uv_read_start(stream, on_alloc, on_read);\n+}\n+\n+extern \"C\" char*\n+rust_uv_malloc_buf_base_of(size_t suggested_size) {\n+\treturn (char*) current_kernel_malloc(sizeof(char)*suggested_size,\n+\t\t\t\t\t\t\t\t\t   \"uv_buf_t base\");\n+}\n+extern \"C\" void\n+rust_uv_free_base_of_buf(uv_buf_t buf) {\n+\tcurrent_kernel_free(buf.base);\n+}\n \n extern \"C\" struct sockaddr_in\n rust_uv_ip4_addr(const char* ip, int port) {"}]}