{"sha": "0975031117fc1de35220f0e16d2294acaab154f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NzUwMzExMTdmYzFkZTM1MjIwZjBlMTZkMjI5NGFjYWFiMTU0Zjg=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-09T03:37:46Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-09T07:05:21Z"}, "message": "Move cast_sign_loss to its own module", "tree": {"sha": "25546bd28b76466c4e3718864029250615399f1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25546bd28b76466c4e3718864029250615399f1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0975031117fc1de35220f0e16d2294acaab154f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0975031117fc1de35220f0e16d2294acaab154f8", "html_url": "https://github.com/rust-lang/rust/commit/0975031117fc1de35220f0e16d2294acaab154f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0975031117fc1de35220f0e16d2294acaab154f8/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0534bf4698acc7b302664bb80d9c85be2648fcd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0534bf4698acc7b302664bb80d9c85be2648fcd8", "html_url": "https://github.com/rust-lang/rust/commit/0534bf4698acc7b302664bb80d9c85be2648fcd8"}], "stats": {"total": 144, "additions": 78, "deletions": 66}, "files": [{"sha": "9656fbebd772089ab159054227c47e04c049939c", "filename": "clippy_lints/src/casts/cast_sign_loss.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0975031117fc1de35220f0e16d2294acaab154f8/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0975031117fc1de35220f0e16d2294acaab154f8/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=0975031117fc1de35220f0e16d2294acaab154f8", "patch": "@@ -0,0 +1,70 @@\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use if_chain::if_chain;\n+\n+use crate::consts::{constant, Constant};\n+use crate::utils::{method_chain_args, sext, span_lint};\n+\n+use super::CAST_SIGN_LOSS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    if should_lint(cx, cast_op, cast_from, cast_to) {\n+        span_lint(\n+            cx,\n+            CAST_SIGN_LOSS,\n+            expr.span,\n+            &format!(\n+                \"casting `{}` to `{}` may lose the sign of the value\",\n+                cast_from, cast_to\n+            ),\n+        );\n+    }\n+}\n+\n+fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) -> bool {\n+    match (cast_from.is_integral(), cast_to.is_integral()) {\n+        (true, true) => {\n+            if !cast_from.is_signed() || cast_to.is_signed() {\n+                return false;\n+            }\n+\n+            // Don't lint for positive constants.\n+            let const_val = constant(cx, &cx.typeck_results(), cast_op);\n+            if_chain! {\n+                if let Some((Constant::Int(n), _)) = const_val;\n+                if let ty::Int(ity) = *cast_from.kind();\n+                if sext(cx.tcx, n, ity) >= 0;\n+                then {\n+                    return false;\n+                }\n+            }\n+\n+            // Don't lint for the result of methods that always return non-negative values.\n+            if let ExprKind::MethodCall(ref path, _, _, _) = cast_op.kind {\n+                let mut method_name = path.ident.name.as_str();\n+                let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n+\n+                if_chain! {\n+                    if method_name == \"unwrap\";\n+                    if let Some(arglist) = method_chain_args(cast_op, &[\"unwrap\"]);\n+                    if let ExprKind::MethodCall(ref inner_path, _, _, _) = &arglist[0][0].kind;\n+                    then {\n+                        method_name = inner_path.ident.name.as_str();\n+                    }\n+                }\n+\n+                if allowed_methods.iter().any(|&name| method_name == name) {\n+                    return false;\n+                }\n+            }\n+\n+            true\n+        },\n+\n+        (false, true) => !cast_to.is_signed(),\n+\n+        (_, _) => false,\n+    }\n+}"}, {"sha": "f390dfdfab761df11666be33658625e01e1cc4f7", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 8, "deletions": 66, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0975031117fc1de35220f0e16d2294acaab154f8/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0975031117fc1de35220f0e16d2294acaab154f8/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=0975031117fc1de35220f0e16d2294acaab154f8", "patch": "@@ -1,6 +1,7 @@\n mod cast_lossless;\n mod cast_possible_truncation;\n mod cast_precision_loss;\n+mod cast_sign_loss;\n mod utils;\n \n use std::borrow::Cow;\n@@ -17,11 +18,10 @@ use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::sym;\n use rustc_target::abi::LayoutOf;\n \n-use crate::consts::{constant, Constant};\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    is_hir_ty_cfg_dependant, is_isize_or_usize, meets_msrv, method_chain_args, numeric_literal::NumericLiteral, sext,\n-    snippet_opt, snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then,\n+    is_hir_ty_cfg_dependant, is_isize_or_usize, meets_msrv, numeric_literal::NumericLiteral, snippet_opt,\n+    snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then,\n };\n \n use utils::int_ty_to_nbits;\n@@ -261,52 +261,6 @@ enum ArchSuffix {\n     None,\n }\n \n-fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    if !cast_from.is_signed() || cast_to.is_signed() {\n-        return;\n-    }\n-\n-    // don't lint for positive constants\n-    let const_val = constant(cx, &cx.typeck_results(), op);\n-    if_chain! {\n-        if let Some((Constant::Int(n), _)) = const_val;\n-        if let ty::Int(ity) = *cast_from.kind();\n-        if sext(cx.tcx, n, ity) >= 0;\n-        then {\n-            return\n-        }\n-    }\n-\n-    // don't lint for the result of methods that always return non-negative values\n-    if let ExprKind::MethodCall(ref path, _, _, _) = op.kind {\n-        let mut method_name = path.ident.name.as_str();\n-        let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n-\n-        if_chain! {\n-            if method_name == \"unwrap\";\n-            if let Some(arglist) = method_chain_args(op, &[\"unwrap\"]);\n-            if let ExprKind::MethodCall(ref inner_path, _, _, _) = &arglist[0][0].kind;\n-            then {\n-                method_name = inner_path.ident.name.as_str();\n-            }\n-        }\n-\n-        if allowed_methods.iter().any(|&name| method_name == name) {\n-            return;\n-        }\n-    }\n-\n-    span_lint(\n-        cx,\n-        CAST_SIGN_LOSS,\n-        expr.span,\n-        &format!(\n-            \"casting `{}` to `{}` may lose the sign of the value\",\n-            cast_from, cast_to\n-        ),\n-    );\n-}\n-\n fn check_truncation_and_wrapping(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n@@ -490,29 +444,17 @@ fn show_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &st\n fn lint_numeric_casts<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &Expr<'tcx>,\n-    cast_expr: &Expr<'_>,\n+    cast_op: &Expr<'_>,\n     cast_from: Ty<'tcx>,\n     cast_to: Ty<'tcx>,\n ) {\n-    cast_precision_loss::check(cx, expr, cast_from, cast_to);\n-    cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to);\n     cast_possible_truncation::check(cx, expr, cast_from, cast_to);\n+    cast_precision_loss::check(cx, expr, cast_from, cast_to);\n+    cast_lossless::check(cx, expr, cast_op, cast_from, cast_to);\n+    cast_sign_loss::check(cx, expr, cast_op, cast_from, cast_to);\n+\n     match (cast_from.is_integral(), cast_to.is_integral()) {\n-        (false, true) => {\n-            if !cast_to.is_signed() {\n-                span_lint(\n-                    cx,\n-                    CAST_SIGN_LOSS,\n-                    expr.span,\n-                    &format!(\n-                        \"casting `{}` to `{}` may lose the sign of the value\",\n-                        cast_from, cast_to\n-                    ),\n-                );\n-            }\n-        },\n         (true, true) => {\n-            check_loss_of_sign(cx, expr, cast_expr, cast_from, cast_to);\n             check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n         },\n         (_, _) => {},"}]}