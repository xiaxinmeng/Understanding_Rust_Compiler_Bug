{"sha": "5af5f2675382ec01418f3fa7269836d2d29f47d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZjVmMjY3NTM4MmVjMDE0MThmM2ZhNzI2OTgzNmQyZDI5ZjQ3ZDg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-05T20:56:11Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-08T21:38:38Z"}, "message": "handle string literals correctly in match checking\n\nThe root of the problem is that a string literal pattern is essentially of\nthe form `&LITERAL`, in a single block, while match checking wants to\nsplit that.\n\nTo fix that, I added a type field to the patterns in match checking,\nwhich allows us to distinguish between a full and split pattern.\n\nThat file is ugly and needs to be cleaned. However, `trans::_match` calls\nit, so I think we should delay the cleanup until we kill that.\n\nFixes #30240", "tree": {"sha": "d50d2c7ddba798e4c9cb0d412406ea15535f9eb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d50d2c7ddba798e4c9cb0d412406ea15535f9eb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5af5f2675382ec01418f3fa7269836d2d29f47d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5af5f2675382ec01418f3fa7269836d2d29f47d8", "html_url": "https://github.com/rust-lang/rust/commit/5af5f2675382ec01418f3fa7269836d2d29f47d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5af5f2675382ec01418f3fa7269836d2d29f47d8/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a614f856885eecff09f509268efa1e6ee7a6128", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a614f856885eecff09f509268efa1e6ee7a6128", "html_url": "https://github.com/rust-lang/rust/commit/1a614f856885eecff09f509268efa1e6ee7a6128"}], "stats": {"total": 241, "additions": 162, "deletions": 79}, "files": [{"sha": "25fc32fe81d441a06f729f14daf50eceee171c3f", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 112, "deletions": 75, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/5af5f2675382ec01418f3fa7269836d2d29f47d8/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af5f2675382ec01418f3fa7269836d2d29f47d8/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=5af5f2675382ec01418f3fa7269836d2d29f47d8", "patch": "@@ -49,7 +49,7 @@ pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     span: DUMMY_SP\n };\n \n-struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n+struct Matrix<'a, 'tcx>(Vec<Vec<(&'a Pat, Option<Ty<'tcx>>)>>);\n \n /// Pretty-printer for matrices of patterns, example:\n /// ++++++++++++++++++++++++++\n@@ -63,14 +63,14 @@ struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n /// ++++++++++++++++++++++++++\n /// + _     + [_, _, ..tail] +\n /// ++++++++++++++++++++++++++\n-impl<'a> fmt::Debug for Matrix<'a> {\n+impl<'a, 'tcx> fmt::Debug for Matrix<'a, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"\\n\")?;\n \n         let &Matrix(ref m) = self;\n         let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n             row.iter()\n-               .map(|&pat| pat_to_string(&pat))\n+               .map(|&(pat,ty)| format!(\"{}: {:?}\", pat_to_string(&pat), ty))\n                .collect::<Vec<String>>()\n         }).collect();\n \n@@ -97,8 +97,10 @@ impl<'a> fmt::Debug for Matrix<'a> {\n     }\n }\n \n-impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n-    fn from_iter<T: IntoIterator<Item=Vec<&'a Pat>>>(iter: T) -> Matrix<'a> {\n+impl<'a, 'tcx> FromIterator<Vec<(&'a Pat, Option<Ty<'tcx>>)>> for Matrix<'a, 'tcx> {\n+    fn from_iter<T: IntoIterator<Item=Vec<(&'a Pat, Option<Ty<'tcx>>)>>>(iter: T)\n+                                                                         -> Self\n+    {\n         Matrix(iter.into_iter().collect())\n     }\n }\n@@ -229,7 +231,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n                 .flat_map(|arm| &arm.0)\n-                .map(|pat| vec![&**pat])\n+                .map(|pat| vec![wrap_pat(cx, &pat)])\n                 .collect();\n             check_exhaustive(cx, ex.span, &matrix, source);\n         },\n@@ -301,7 +303,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n     let mut printed_if_let_err = false;\n     for &(ref pats, guard) in arms {\n         for pat in pats {\n-            let v = vec![&**pat];\n+            let v = vec![wrap_pat(cx, &pat)];\n \n             match is_useful(cx, &seen, &v[..], LeaveOutWitness) {\n                 NotUseful => {\n@@ -341,8 +343,9 @@ fn check_arms(cx: &MatchCheckCtxt,\n                                                            \"unreachable pattern\");\n                             // if we had a catchall pattern, hint at that\n                             for row in &seen.0 {\n-                                if pat_is_catchall(&cx.tcx.def_map.borrow(), row[0]) {\n-                                    span_note!(err, row[0].span, \"this pattern matches any value\");\n+                                if pat_is_catchall(&cx.tcx.def_map.borrow(), row[0].0) {\n+                                    span_note!(err, row[0].0.span,\n+                                               \"this pattern matches any value\");\n                                 }\n                             }\n                             err.emit();\n@@ -383,13 +386,16 @@ fn raw_pat(p: &Pat) -> &Pat {\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir::MatchSource) {\n-    match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n+fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+                              sp: Span,\n+                              matrix: &Matrix<'a, 'tcx>,\n+                              source: hir::MatchSource) {\n+    match is_useful(cx, matrix, &[(DUMMY_WILD_PAT, None)], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n                 vec![DUMMY_WILD_PAT]\n             } else {\n-                pats.iter().map(|w| &**w ).collect()\n+                pats.iter().map(|w| &**w).collect()\n             };\n             match source {\n                 hir::MatchSource::ForLoopDesugar => {\n@@ -631,7 +637,7 @@ impl Constructor {\n fn missing_constructors(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n                        left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n-        .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length))\n+        .flat_map(|row| pat_constructors(cx, row[0].0, left_ty, max_slice_length))\n         .collect();\n     all_constructors(cx, left_ty, max_slice_length)\n         .into_iter()\n@@ -668,13 +674,13 @@ fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: &MatchCheckCtxt,\n-             matrix: &Matrix,\n-             v: &[&Pat],\n-             witness: WitnessPreference)\n-             -> Usefulness {\n+fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+                       matrix: &Matrix<'a, 'tcx>,\n+                       v: &[(&Pat, Option<Ty<'tcx>>)],\n+                       witness: WitnessPreference)\n+                       -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n-    debug!(\"{:?}\", matrix);\n+    debug!(\"is_useful({:?}, {:?})\", matrix, v);\n     if rows.is_empty() {\n         return match witness {\n             ConstructWitness => UsefulWithWitness(vec!()),\n@@ -685,32 +691,25 @@ fn is_useful(cx: &MatchCheckCtxt,\n         return NotUseful;\n     }\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n-    let real_pat = match rows.iter().find(|r| (*r)[0].id != DUMMY_NODE_ID) {\n-        Some(r) => raw_pat(r[0]),\n-        None if v.is_empty() => return NotUseful,\n-        None => v[0]\n-    };\n-    let left_ty = if real_pat.id == DUMMY_NODE_ID {\n-        cx.tcx.mk_nil()\n-    } else {\n-        let left_ty = cx.tcx.pat_ty(&real_pat);\n-\n-        match real_pat.node {\n-            PatKind::Binding(hir::BindByRef(..), _, _) => {\n-                left_ty.builtin_deref(false, NoPreference).unwrap().ty\n-            }\n-            _ => left_ty,\n+    let left_ty = match rows.iter().filter_map(|r| r[0].1).next().or_else(|| v[0].1) {\n+        Some(ty) => ty,\n+        None => {\n+            // all patterns are wildcards - we can pick any type we want\n+            cx.tcx.types.bool\n         }\n     };\n \n-    let max_slice_length = rows.iter().filter_map(|row| match row[0].node {\n+    let max_slice_length = rows.iter().filter_map(|row| match row[0].0.node {\n         PatKind::Vec(ref before, _, ref after) => Some(before.len() + after.len()),\n         _ => None\n     }).max().map_or(0, |v| v + 1);\n \n-    let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n+    let constructors = pat_constructors(cx, v[0].0, left_ty, max_slice_length);\n+    debug!(\"is_useful - pat_constructors = {:?} left_ty = {:?}\", constructors,\n+           left_ty);\n     if constructors.is_empty() {\n         let constructors = missing_constructors(cx, matrix, left_ty, max_slice_length);\n+        debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n         if constructors.is_empty() {\n             all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n                 match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n@@ -731,7 +730,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n             }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n-                match raw_pat(r[0]).node {\n+                match raw_pat(r[0].0).node {\n                     PatKind::Binding(..) | PatKind::Wild => Some(r[1..].to_vec()),\n                     _ => None,\n                 }\n@@ -756,9 +755,14 @@ fn is_useful(cx: &MatchCheckCtxt,\n     }\n }\n \n-fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n-                         v: &[&Pat], ctor: Constructor, lty: Ty,\n-                         witness: WitnessPreference) -> Usefulness {\n+fn is_useful_specialized<'a, 'tcx>(\n+    cx: &MatchCheckCtxt<'a, 'tcx>,\n+    &Matrix(ref m): &Matrix<'a, 'tcx>,\n+    v: &[(&Pat, Option<Ty<'tcx>>)],\n+    ctor: Constructor,\n+    lty: Ty<'tcx>,\n+    witness: WitnessPreference) -> Usefulness\n+{\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n         specialize(cx, &r[..], &ctor, 0, arity)\n@@ -859,6 +863,19 @@ fn range_covered_by_constructor(ctor: &Constructor,\n     }\n }\n \n+fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n+                          pat: &'a Pat)\n+                          -> (&'a Pat, Option<Ty<'tcx>>)\n+{\n+    let pat_ty = cx.tcx.pat_ty(pat);\n+    (pat, Some(match pat.node {\n+        PatKind::Binding(hir::BindByRef(..), _, _) => {\n+            pat_ty.builtin_deref(false, NoPreference).unwrap().ty\n+        }\n+        _ => pat_ty\n+    }))\n+}\n+\n /// This is the main specialization step. It expands the first pattern in the given row\n /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n@@ -867,14 +884,22 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n-                      constructor: &Constructor, col: usize, arity: usize) -> Option<Vec<&'a Pat>> {\n+pub fn specialize<'a, 'b, 'tcx>(\n+    cx: &MatchCheckCtxt<'b, 'tcx>,\n+    r: &[(&'a Pat, Option<Ty<'tcx>>)],\n+    constructor: &Constructor, col: usize, arity: usize)\n+    -> Option<Vec<(&'a Pat, Option<Ty<'tcx>>)>>\n+{\n+    let pat = raw_pat(r[col].0);\n     let &Pat {\n         id: pat_id, ref node, span: pat_span\n-    } = raw_pat(r[col]);\n-    let head: Option<Vec<&Pat>> = match *node {\n+    } = pat;\n+    let wpat = |pat: &'a Pat| wrap_pat(cx, pat);\n+    let dummy_pat = (DUMMY_WILD_PAT, None);\n+\n+    let head: Option<Vec<(&Pat, Option<Ty>)>> = match *node {\n         PatKind::Binding(..) | PatKind::Wild =>\n-            Some(vec![DUMMY_WILD_PAT; arity]),\n+            Some(vec![dummy_pat; arity]),\n \n         PatKind::Path(..) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n@@ -899,12 +924,14 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Def::Variant(..) | Def::Struct(..) => {\n                     match ddpos {\n                         Some(ddpos) => {\n-                            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| &**p).collect();\n-                            pats.extend(repeat(DUMMY_WILD_PAT).take(arity - args.len()));\n-                            pats.extend(args[ddpos..].iter().map(|p| &**p));\n+                            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| {\n+                                wpat(p)\n+                            }).collect();\n+                            pats.extend(repeat((DUMMY_WILD_PAT, None)).take(arity - args.len()));\n+                            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n                             Some(pats)\n                         }\n-                        None => Some(args.iter().map(|p| &**p).collect())\n+                        None => Some(args.iter().map(|p| wpat(p)).collect())\n                     }\n                 }\n                 _ => None\n@@ -923,8 +950,8 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             if variant.did == def_variant.did {\n                 Some(variant.fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.node.name == sf.name) {\n-                        Some(ref f) => &*f.node.pat,\n-                        _ => DUMMY_WILD_PAT\n+                        Some(ref f) => wpat(&f.node.pat),\n+                        _ => dummy_pat\n                     }\n                 }).collect())\n             } else {\n@@ -933,25 +960,32 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         PatKind::Tuple(ref args, Some(ddpos)) => {\n-            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| &**p).collect();\n-            pats.extend(repeat(DUMMY_WILD_PAT).take(arity - args.len()));\n-            pats.extend(args[ddpos..].iter().map(|p| &**p));\n+            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| wpat(p)).collect();\n+            pats.extend(repeat(dummy_pat).take(arity - args.len()));\n+            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n             Some(pats)\n         }\n         PatKind::Tuple(ref args, None) =>\n-            Some(args.iter().map(|p| &**p).collect()),\n+            Some(args.iter().map(|p| wpat(&**p)).collect()),\n \n         PatKind::Box(ref inner) | PatKind::Ref(ref inner, _) =>\n-            Some(vec![&**inner]),\n+            Some(vec![wpat(&**inner)]),\n \n         PatKind::Lit(ref expr) => {\n-            let expr_value = eval_const_expr(cx.tcx, &expr);\n-            match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n-                Some(true) => Some(vec![]),\n-                Some(false) => None,\n-                None => {\n-                    span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n-                    None\n+            if let Some(&ty::TyS { sty: ty::TyRef(_, mt), .. }) = r[col].1 {\n+                // HACK: handle string literals. A string literal pattern\n+                // serves both as an unary reference pattern and as a\n+                // nullary value pattern, depending on the type.\n+                Some(vec![(pat, Some(mt.ty))])\n+            } else {\n+                let expr_value = eval_const_expr(cx.tcx, &expr);\n+                match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n+                    Some(true) => Some(vec![]),\n+                    Some(false) => None,\n+                    None => {\n+                        span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n+                        None\n+                    }\n                 }\n             }\n         }\n@@ -975,37 +1009,40 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Single => {\n                     // Fixed-length vectors.\n                     Some(\n-                        before.iter().map(|p| &**p).chain(\n-                        repeat(DUMMY_WILD_PAT).take(arity - pat_len).chain(\n-                        after.iter().map(|p| &**p)\n+                        before.iter().map(|p| wpat(p)).chain(\n+                        repeat(dummy_pat).take(arity - pat_len).chain(\n+                        after.iter().map(|p| wpat(p))\n                     )).collect())\n                 },\n                 Slice(length) if pat_len <= length && slice.is_some() => {\n                     Some(\n-                        before.iter().map(|p| &**p).chain(\n-                        repeat(DUMMY_WILD_PAT).take(arity - pat_len).chain(\n-                        after.iter().map(|p| &**p)\n+                        before.iter().map(|p| wpat(p)).chain(\n+                        repeat(dummy_pat).take(arity - pat_len).chain(\n+                        after.iter().map(|p| wpat(p))\n                     )).collect())\n                 }\n                 Slice(length) if pat_len == length => {\n                     Some(\n-                        before.iter().map(|p| &**p).chain(\n-                        after.iter().map(|p| &**p)\n+                        before.iter().map(|p| wpat(p)).chain(\n+                        after.iter().map(|p| wpat(p))\n                     ).collect())\n                 }\n                 SliceWithSubslice(prefix, suffix)\n                     if before.len() == prefix\n                         && after.len() == suffix\n                         && slice.is_some() => {\n                     // this is used by trans::_match only\n-                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.extend(after.iter().map(|p| &**p));\n+                    let mut pats: Vec<_> = before.iter()\n+                        .map(|p| (&**p, None)).collect();\n+                    pats.extend(after.iter().map(|p| (&**p, None)));\n                     Some(pats)\n                 }\n                 _ => None\n             }\n         }\n     };\n+    debug!(\"specialize({:?}, {:?}) = {:?}\", r[col], arity, head);\n+\n     head.map(|mut head| {\n         head.extend_from_slice(&r[..col]);\n         head.extend_from_slice(&r[col + 1..]);\n@@ -1063,8 +1100,8 @@ fn check_irrefutable(cx: &MatchCheckCtxt, pat: &Pat, is_fn_arg: bool) {\n fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A> where\n     F: FnOnce(&Pat) -> A,\n {\n-    let pats = Matrix(vec!(vec!(pat)));\n-    match is_useful(cx, &pats, &[DUMMY_WILD_PAT], ConstructWitness) {\n+    let pats = Matrix(vec!(vec!(wrap_pat(cx, pat))));\n+    match is_useful(cx, &pats, &[(DUMMY_WILD_PAT, None)], ConstructWitness) {\n         UsefulWithWitness(pats) => Some(refutable(&pats[0])),\n         NotUseful => None,\n         Useful => bug!()"}, {"sha": "913b0528b2e193f1a93a4e99af4940bf118b824b", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5af5f2675382ec01418f3fa7269836d2d29f47d8/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af5f2675382ec01418f3fa7269836d2d29f47d8/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=5af5f2675382ec01418f3fa7269836d2d29f47d8", "patch": "@@ -505,14 +505,16 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                           val: MatchInput,\n                                           mut e: F)\n                                           -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n-    F: FnMut(&[&'p hir::Pat]) -> Option<Vec<&'p hir::Pat>>,\n+    F: FnMut(&[(&'p hir::Pat, Option<Ty<'tcx>>)])\n+             -> Option<Vec<(&'p hir::Pat, Option<Ty<'tcx>>)>>,\n {\n     debug!(\"enter_match(bcx={}, m={:?}, col={}, val={:?})\",\n            bcx.to_str(), m, col, val);\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(&br.pats).map(|pats| {\n+        let pats : Vec<_> = br.pats.iter().map(|p| (*p, None)).collect();\n+        e(&pats).map(|pats| {\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -530,7 +532,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                 _ => {}\n             }\n             Match {\n-                pats: pats,\n+                pats: pats.into_iter().map(|p| p.0).collect(),\n                 data: br.data,\n                 bound_ptrs: bound_ptrs,\n                 pat_renaming_map: br.pat_renaming_map,\n@@ -550,7 +552,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, m, col, val, |pats| {\n-        match pats[col].node {\n+        match pats[col].0.node {\n             PatKind::Binding(..) | PatKind::Wild => {\n                 let mut r = pats[..col].to_vec();\n                 r.extend_from_slice(&pats[col + 1..]);"}, {"sha": "9b105e7ec159d193ff8997e4850398234c8563a0", "filename": "src/test/compile-fail/issue-30240.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5af5f2675382ec01418f3fa7269836d2d29f47d8/src%2Ftest%2Fcompile-fail%2Fissue-30240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af5f2675382ec01418f3fa7269836d2d29f47d8/src%2Ftest%2Fcompile-fail%2Fissue-30240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30240.rs?ref=5af5f2675382ec01418f3fa7269836d2d29f47d8", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n+        \"hello\" => {}\n+    }\n+\n+    match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n+        ref _x if false => {}\n+        \"hello\" => {}\n+        \"hello\" => {} //~ ERROR unreachable pattern\n+    }\n+}"}, {"sha": "3be661ce35e3866e5503cbc4a211a55e68bd6c43", "filename": "src/test/run-pass/issue-30240.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5af5f2675382ec01418f3fa7269836d2d29f47d8/src%2Ftest%2Frun-pass%2Fissue-30240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af5f2675382ec01418f3fa7269836d2d29f47d8/src%2Ftest%2Frun-pass%2Fissue-30240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30240.rs?ref=5af5f2675382ec01418f3fa7269836d2d29f47d8", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let &ref a = &[0i32] as &[_];\n+    assert_eq!(a, &[0i32] as &[_]);\n+\n+    let &ref a = \"hello\";\n+    assert_eq!(a, \"hello\");\n+\n+    match \"foo\" {\n+        \"fool\" => unreachable!(),\n+        \"foo\" => {},\n+        ref _x => unreachable!()\n+    }\n+}"}]}