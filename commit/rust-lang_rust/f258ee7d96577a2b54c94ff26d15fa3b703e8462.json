{"sha": "f258ee7d96577a2b54c94ff26d15fa3b703e8462", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNThlZTdkOTY1NzdhMmI1NGM5NGZmMjZkMTVmYTNiNzAzZTg0NjI=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-04T15:39:03Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-05T22:22:16Z"}, "message": "typeck: there are only unboxed closures now", "tree": {"sha": "37692c8f41758078472832fcf8a267bccb9fa427", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37692c8f41758078472832fcf8a267bccb9fa427"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f258ee7d96577a2b54c94ff26d15fa3b703e8462", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f258ee7d96577a2b54c94ff26d15fa3b703e8462", "html_url": "https://github.com/rust-lang/rust/commit/f258ee7d96577a2b54c94ff26d15fa3b703e8462", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f258ee7d96577a2b54c94ff26d15fa3b703e8462/comments", "author": null, "committer": null, "parents": [{"sha": "58b0d7479fb478d9c8293e78adaa86a8971442d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/58b0d7479fb478d9c8293e78adaa86a8971442d5", "html_url": "https://github.com/rust-lang/rust/commit/58b0d7479fb478d9c8293e78adaa86a8971442d5"}], "stats": {"total": 123, "additions": 11, "deletions": 112}, "files": [{"sha": "a1756dd6334dfdbaee999477277dc94b65e29d9a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 11, "deletions": 112, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f258ee7d96577a2b54c94ff26d15fa3b703e8462/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f258ee7d96577a2b54c94ff26d15fa3b703e8462/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=f258ee7d96577a2b54c94ff26d15fa3b703e8462", "patch": "@@ -46,30 +46,17 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             // evidence than an unboxed closure is desired, we'll use\n             // that, otherwise we'll fall back to boxed closures.\n             match expected_sig_and_kind {\n-                None => { // doesn't look like an unboxed closure\n-                    let region = astconv::opt_ast_region_to_region(fcx,\n-                                                                   fcx,\n-                                                                   expr.span,\n-                                                                   &None);\n-\n-                    check_boxed_closure(fcx,\n-                                        expr,\n-                                        ty::RegionTraitStore(region, ast::MutMutable),\n-                                        decl,\n-                                        body,\n-                                        expected);\n-\n-                    match capture {\n-                        CaptureByValue => {\n-                            fcx.ccx.tcx.sess.span_err(\n-                                expr.span,\n-                                \"boxed closures can't capture by value, \\\n-                                if you want to use an unboxed closure, \\\n-                                explicitly annotate its kind: e.g. `move |:|`\");\n-                        },\n-                        CaptureByRef => {}\n-                    }\n-                }\n+                None => { // don't have information about the kind, request explicit annotation\n+                    // HACK We still need to typeck the body, so assume `FnMut` kind just for that\n+                    let kind = ty::FnMutUnboxedClosureKind;\n+\n+                    check_unboxed_closure(fcx, expr, kind, decl, body, None);\n+\n+                    fcx.ccx.tcx.sess.span_err(\n+                        expr.span,\n+                        \"Can't infer the \\\"kind\\\" of the closure, explicitly annotate it. e.g. \\\n+                        `|&:| {}`\");\n+                },\n                 Some((sig, kind)) => {\n                     check_unboxed_closure(fcx, expr, kind, decl, body, Some(sig));\n                 }\n@@ -254,91 +241,3 @@ fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n \n     None\n }\n-\n-\n-fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                expr: &ast::Expr,\n-                                store: ty::TraitStore,\n-                                decl: &ast::FnDecl,\n-                                body: &ast::Block,\n-                                expected: Expectation<'tcx>) {\n-    let tcx = fcx.ccx.tcx;\n-\n-    // Find the expected input/output types (if any). Substitute\n-    // fresh bound regions for any bound regions we find in the\n-    // expected types so as to avoid capture.\n-    let expected_cenv = expected.map_to_option(fcx, |ty| match ty.sty {\n-        _ => None\n-    });\n-    let (expected_sig, expected_onceness, expected_bounds) = match expected_cenv {\n-        Some(cenv) => {\n-            let (sig, _) =\n-                ty::replace_late_bound_regions(\n-                    tcx,\n-                    &cenv.sig,\n-                    |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n-            let onceness = match (&store, &cenv.store) {\n-                // As the closure type and onceness go, only three\n-                // combinations are legit:\n-                //      once closure\n-                //      many closure\n-                //      once proc\n-                // If the actual and expected closure type disagree with\n-                // each other, set expected onceness to be always Once or\n-                // Many according to the actual type. Otherwise, it will\n-                // yield either an illegal \"many proc\" or a less known\n-                // \"once closure\" in the error message.\n-                (&ty::UniqTraitStore, &ty::UniqTraitStore) |\n-                (&ty::RegionTraitStore(..), &ty::RegionTraitStore(..)) =>\n-                    cenv.onceness,\n-                (&ty::UniqTraitStore, _) => ast::Once,\n-                (&ty::RegionTraitStore(..), _) => ast::Many,\n-            };\n-            (Some(sig), onceness, cenv.bounds.clone())\n-        }\n-        _ => {\n-            // Not an error! Means we're inferring the closure type\n-            let region = fcx.infcx().next_region_var(\n-                infer::AddrOfRegion(expr.span));\n-            let bounds = ty::region_existential_bound(region);\n-            let onceness = ast::Many;\n-            (None, onceness, bounds)\n-        }\n-    };\n-\n-    // construct the function type\n-    let fn_ty = astconv::ty_of_closure(fcx,\n-                                       ast::Unsafety::Normal,\n-                                       expected_onceness,\n-                                       expected_bounds,\n-                                       store,\n-                                       decl,\n-                                       abi::Rust,\n-                                       expected_sig);\n-    let fn_sig = fn_ty.sig.clone();\n-    let fty = panic!(\"stub\");\n-    debug!(\"check_expr_fn fty={}\", fcx.infcx().ty_to_string(fty));\n-\n-    fcx.write_ty(expr.id, fty);\n-\n-    // If the closure is a stack closure and hasn't had some non-standard\n-    // style inferred for it, then check it under its parent's style.\n-    // Otherwise, use its own\n-    let (inherited_style, inherited_style_id) = match store {\n-        ty::RegionTraitStore(..) => (fcx.ps.borrow().unsafety,\n-                                     fcx.ps.borrow().def),\n-        ty::UniqTraitStore => (ast::Unsafety::Normal, expr.id)\n-    };\n-\n-    let fn_sig =\n-        ty::liberate_late_bound_regions(tcx, CodeExtent::from_node_id(body.id), &fn_sig);\n-\n-    check_fn(fcx.ccx,\n-             inherited_style,\n-             inherited_style_id,\n-             &fn_sig,\n-             &*decl,\n-             expr.id,\n-             &*body,\n-             fcx.inh);\n-}"}]}