{"sha": "012dec5e5756bdc01e771f5152d71eafa9c8441e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMmRlYzVlNTc1NmJkYzAxZTc3MWY1MTUyZDcxZWFmYTljODQ0MWU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-02-26T00:39:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-29T02:00:50Z"}, "message": "std: rewrite json.rs to fix bugs and use readers/writers\n\nOur json implementation did not conform to the spec, and\nwas missing support for escpaed characters and exponental\nnumbers. This fixes it, and adds support for reading/writing\njson directly from/to a stream.\n\nThere are two things left unimplemented. We could use a\n\"to_json\" iface/impl, but that really needs traits to cut\ndown on code duplication. The other is it wouldn't be that\nnot that hard to turn this implementation into a event driven\nparser like YAJL, but I ran into some type-inference bugs,\nso I cut that out. It'd be nice to revisit this in the future\nthough.", "tree": {"sha": "13d04d8dfaefc360547e184296cea6e995f597f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13d04d8dfaefc360547e184296cea6e995f597f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/012dec5e5756bdc01e771f5152d71eafa9c8441e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/012dec5e5756bdc01e771f5152d71eafa9c8441e", "html_url": "https://github.com/rust-lang/rust/commit/012dec5e5756bdc01e771f5152d71eafa9c8441e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/012dec5e5756bdc01e771f5152d71eafa9c8441e/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cc23aab6d29ddf46afa0a605171fcf6533a61ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cc23aab6d29ddf46afa0a605171fcf6533a61ec", "html_url": "https://github.com/rust-lang/rust/commit/8cc23aab6d29ddf46afa0a605171fcf6533a61ec"}], "stats": {"total": 895, "additions": 669, "deletions": 226}, "files": [{"sha": "a4816fedf970e9eb08d740d07669c0140b5e757c", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/012dec5e5756bdc01e771f5152d71eafa9c8441e/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012dec5e5756bdc01e771f5152d71eafa9c8441e/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=012dec5e5756bdc01e771f5152d71eafa9c8441e", "patch": "@@ -9,6 +9,7 @@ import rustc::util::filesearch::{get_cargo_root, get_cargo_root_nearest,\n                                  get_cargo_sysroot, libdir};\n import rustc::driver::diagnostic;\n \n+import result::{ok, err};\n import std::fs;\n import std::io;\n import io::writer_util;\n@@ -225,15 +226,15 @@ fn parse_source(name: str, j: json::json) -> source {\n fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n     if !fs::path_exists(filename)  { ret; }\n     let c = io::read_whole_file_str(filename);\n-    let j = json::from_str(result::get(c));\n-    alt j {\n-        some(json::dict(_j)) {\n-            _j.items { |k, v|\n+    alt json::from_str(result::get(c)) {\n+        ok(json::dict(j)) {\n+            j.items { |k, v|\n                 sources.insert(k, parse_source(k, v));\n                 #debug(\"source: %s\", k);\n             }\n         }\n-        _ { fail \"malformed sources.json\"; }\n+        ok(_) { fail \"malformed sources.json\"; }\n+        err(e) { fail #fmt(\"%s:%u:%u: %s\", filename, e.line, e.col, e.msg); }\n     }\n }\n \n@@ -278,7 +279,7 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n     let tags = [];\n     alt p.find(\"tags\") {\n         some(json::list(js)) {\n-            for j in *js {\n+            for j in js {\n                 alt j {\n                     json::string(_j) { vec::grow(tags, 1u, _j); }\n                     _ { }\n@@ -316,10 +317,9 @@ fn load_source_packages(&c: cargo, &src: source) {\n     let pkgfile = fs::connect(dir, \"packages.json\");\n     if !fs::path_exists(pkgfile) { ret; }\n     let pkgstr = io::read_whole_file_str(pkgfile);\n-    let j = json::from_str(result::get(pkgstr));\n-    alt j {\n-        some(json::list(js)) {\n-            for _j: json::json in *js {\n+    alt json::from_str(result::get(pkgstr)) {\n+        ok(json::list(js)) {\n+            for _j: json::json in js {\n                 alt _j {\n                     json::dict(_p) {\n                         load_one_source_package(src, _p);\n@@ -331,8 +331,12 @@ fn load_source_packages(&c: cargo, &src: source) {\n                 }\n             }\n         }\n-        _ {\n-            warn(\"Malformed source json: \" + src.name);\n+        ok(_) {\n+            warn(\"Malformed source json: \" + src.name +\n+                 \"(packages is not a list)\");\n+        }\n+        err(e) {\n+            warn(#fmt(\"%s:%u:%u: %s\", src.name, e.line, e.col, e.msg));\n         }\n     };\n }"}, {"sha": "d2bbc7dc5e736426dc1daadac122b58a4e106334", "filename": "src/libstd/json.rs", "status": "modified", "additions": 653, "deletions": 214, "changes": 867, "blob_url": "https://github.com/rust-lang/rust/blob/012dec5e5756bdc01e771f5152d71eafa9c8441e/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012dec5e5756bdc01e771f5152d71eafa9c8441e/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=012dec5e5756bdc01e771f5152d71eafa9c8441e", "patch": "@@ -1,18 +1,24 @@\n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n \n-import float;\n+import result::{ok, err};\n+import io;\n+import io::{reader_util, writer_util};\n import map;\n \n export json;\n+export to_writer;\n export to_str;\n+export from_reader;\n export from_str;\n+export eq;\n \n export num;\n export string;\n export boolean;\n export list;\n export dict;\n+export null;\n \n /*\n Tag: json\n@@ -27,296 +33,729 @@ enum json {\n     /* Variant: boolean */\n     boolean(bool),\n     /* Variant: list */\n-    list(@[json]),\n+    list([json]),\n     /* Variant: dict */\n     dict(map::map<str,json>),\n     /* Variant: null */\n     null,\n }\n \n+type error = {\n+    line: uint,\n+    col: uint,\n+    msg: str,\n+};\n+\n /*\n-Function: to_str\n+Function: to_writer\n \n-Serializes a json value into a string.\n+Serializes a json value into a io::writer.\n */\n-fn to_str(j: json) -> str {\n+fn to_writer(wr: io::writer, j: json) {\n     alt j {\n-        num(f) { float::to_str(f, 6u) }\n-        string(s) { #fmt[\"\\\"%s\\\"\", s] } // XXX: escape\n-        boolean(true) { \"true\" }\n-        boolean(false) { \"false\" }\n-        list(@js) {\n-            str::concat([\"[\",\n-                    str::connect(\n-                        vec::map::<json,str>(js, { |e| to_str(e) }),\n-                        \", \"),\n-                    \"]\"])\n-        }\n-        dict(m) {\n-            let parts = [];\n-            m.items({ |k, v|\n-                        vec::grow(parts, 1u,\n-                                  str::concat([\"\\\"\", k, \"\\\": \", to_str(v)])\n-                        )\n-            });\n-            str::concat([\"{ \", str::connect(parts, \", \"), \" }\"])\n+      num(n) { wr.write_str(float::to_str(n, 6u)); }\n+      string(s) {\n+        wr.write_char('\"');\n+        let escaped = \"\";\n+        str::chars_iter(s) { |c|\n+            alt c {\n+              '\"' { escaped += \"\\\\\\\"\"; }\n+              '\\\\' { escaped += \"\\\\\\\\\"; }\n+              '\\x08' { escaped += \"\\\\b\"; }\n+              '\\x0c' { escaped += \"\\\\f\"; }\n+              '\\n' { escaped += \"\\\\n\"; }\n+              '\\r' { escaped += \"\\\\r\"; }\n+              '\\t' { escaped += \"\\\\t\"; }\n+              _ { escaped += str::from_char(c); }\n+            }\n+        };\n+        wr.write_str(escaped);\n+        wr.write_char('\"');\n+      }\n+      boolean(b) {\n+        wr.write_str(if b { \"true\" } else { \"false\" });\n+      }\n+      list(v) {\n+        wr.write_char('[');\n+        let first = true;\n+        vec::iter(v) { |item|\n+            if !first {\n+                wr.write_str(\", \");\n+            }\n+            first = false;\n+            to_writer(wr, item);\n+        };\n+        wr.write_char(']');\n+      }\n+      dict(d) {\n+        if d.size() == 0u {\n+            wr.write_str(\"{}\");\n+            ret;\n         }\n-        null { \"null\" }\n+\n+        wr.write_str(\"{ \");\n+        let first = true;\n+        d.items { |key, value|\n+            if !first {\n+                wr.write_str(\", \");\n+            }\n+            first = false;\n+            to_writer(wr, string(key));\n+            wr.write_str(\": \");\n+            to_writer(wr, value);\n+        };\n+        wr.write_str(\" }\");\n+      }\n+      null {\n+        wr.write_str(\"null\");\n+      }\n     }\n }\n \n-fn rest(s: str) -> str {\n-    assert(str::len(s) >= 1u);\n-    str::slice(s, 1u, str::len(s))\n+/*\n+Function: to_str\n+\n+Serializes a json value into a string.\n+*/\n+fn to_str(j: json) -> str {\n+    io::with_str_writer { |wr| to_writer(wr, j) }\n }\n \n-fn from_str_str(s: str) -> (option<json>, str) {\n-    let pos = 0u;\n-    let len = str::len(s);\n-    let escape = false;\n-    let res = \"\";\n+type parser = {\n+    rdr: io::reader,\n+    mutable ch: char,\n+    mutable line: uint,\n+    mutable col: uint,\n+};\n \n-    alt str::char_at(s, 0u) {\n-        '\"' { pos = 1u; }\n-        _ { ret (none, s); }\n-    }\n+impl parser for parser {\n+    fn eof() -> bool { self.ch == -1 as char }\n+\n+    fn bump() {\n+        self.ch = self.rdr.read_char();\n \n-    while (pos < len) {\n-        let chr = str::char_range_at(s, pos);\n-        let c = chr.ch;\n-        pos = chr.next;\n-        if (escape) {\n-            res = res + str::from_char(c);\n-            escape = false;\n-            cont;\n+        if self.ch == '\\n' {\n+            self.line += 1u;\n+            self.col = 1u;\n+        } else {\n+            self.col += 1u;\n         }\n-        if (c == '\\\\') {\n-            escape = true;\n-            cont;\n-        } else if (c == '\"') {\n-            ret (some(string(res)),\n-                 str::slice(s, pos, str::len(s)));\n+    }\n+\n+    fn next_char() -> char {\n+        self.bump();\n+        self.ch\n+    }\n+\n+    fn error<T>(msg: str) -> result::t<T, error> {\n+        err({ line: self.line, col: self.col, msg: msg })\n+    }\n+\n+    fn parse() -> result::t<json, error> {\n+        alt self.parse_value() {\n+          ok(value) {\n+            // Make sure there is no trailing characters.\n+            if self.eof() {\n+                ok(value)\n+            } else {\n+                self.error(\"trailing characters\")\n+            }\n+          }\n+          e { e }\n         }\n-        res = res + str::from_char(c);\n     }\n \n-    ret (none, s);\n-}\n+    fn parse_value() -> result::t<json, error> {\n+        self.parse_whitespace();\n+\n+        if self.eof() { ret self.error(\"EOF while parsing value\"); }\n \n-fn from_str_list(s: str) -> (option<json>, str) {\n-    if str::char_at(s, 0u) != '[' { ret (none, s); }\n-    let s0 = str::trim_left(rest(s));\n-    let vals = [];\n-    if str::is_empty(s0) { ret (none, s0); }\n-    if str::char_at(s0, 0u) == ']' { ret (some(list(@[])), rest(s0)); }\n-    while str::is_not_empty(s0) {\n-        s0 = str::trim_left(s0);\n-        let (next, s1) = from_str_helper(s0);\n-        s0 = s1;\n-        alt next {\n-            some(j) { vec::grow(vals, 1u, j); }\n-            none { ret (none, s0); }\n+        alt self.ch {\n+          'n' { self.parse_ident(\"ull\", null) }\n+          't' { self.parse_ident(\"rue\", boolean(true)) }\n+          'f' { self.parse_ident(\"alse\", boolean(false)) }\n+          '0' to '9' | '-' { self.parse_number() }\n+          '\"' {\n+              alt self.parse_str() {\n+                ok(s) { ok(string(s)) }\n+                err(e) { err(e) }\n+              }\n+          }\n+          '[' { self.parse_list() }\n+          '{' { self.parse_object() }\n+          _ { self.error(\"invalid syntax\") }\n         }\n-        s0 = str::trim_left(s0);\n-        if str::is_empty(s0) { ret (none, s0); }\n-        alt str::char_at(s0, 0u) {\n-            ',' { }\n-            ']' { ret (some(list(@vals)), rest(s0)); }\n-            _ { ret (none, s0); }\n+    }\n+\n+    fn parse_whitespace() {\n+        while char::is_whitespace(self.ch) { self.bump(); }\n+    }\n+\n+    fn parse_ident(ident: str, value: json) -> result::t<json, error> {\n+        if str::all(ident, { |c| c == self.next_char() }) {\n+            self.bump();\n+            ok(value)\n+        } else {\n+            self.error(\"invalid syntax\")\n         }\n-        s0 = rest(s0);\n     }\n-    ret (none, s0);\n-}\n \n-fn from_str_dict(s: str) -> (option<json>, str) {\n-    if str::char_at(s, 0u) != '{' { ret (none, s); }\n-    let s0 = str::trim_left(rest(s));\n-    let vals = map::new_str_hash::<json>();\n-    if str::is_empty(s0) { ret (none, s0); }\n-    if str::char_at(s0, 0u) == '}' { ret (some(dict(vals)), rest(s0)); }\n-    while str::is_not_empty(s0) {\n-        s0 = str::trim_left(s0);\n-        let (next, s1) = from_str_helper(s0);    // key\n-        let key = \"\";\n-        s0 = s1;\n-        alt next {\n-            some(string(k)) { key = k; }\n-            _ { ret (none, s0); }\n+    fn parse_number() -> result::t<json, error> {\n+        let neg = 1f;\n+\n+        if self.ch == '-' {\n+            self.bump();\n+            neg = -1f;\n         }\n-        s0 = str::trim_left(s0);\n-        if str::is_empty(s0) { ret (none, s0); }\n-        if str::char_at(s0, 0u) != ':' { ret (none, s0); }\n-        s0 = str::trim_left(rest(s0));\n-        let (next, s1) = from_str_helper(s0);    // value\n-        s0 = s1;\n-        alt next {\n-            some(j) { vals.insert(key, j); }\n-            _ { ret (none, s0); }\n+\n+        let res =  alt self.parse_integer() {\n+          ok(res) { res }\n+          err(e) { ret err(e); }\n+        };\n+\n+        if self.ch == '.' {\n+            alt self.parse_decimal(res) {\n+              ok(r) { res = r; }\n+              err(e) { ret err(e); }\n+            }\n         }\n-        s0 = str::trim_left(s0);\n-        if str::is_empty(s0) { ret (none, s0); }\n-        alt str::char_at(s0, 0u) {\n-            ',' { }\n-            '}' { ret (some(dict(vals)), rest(s0)); }\n-            _ { ret (none, s0); }\n+\n+        if self.ch == 'e' || self.ch == 'E' {\n+            alt self.parse_exponent(res) {\n+              ok(r) { res = r; }\n+              err(e) { ret err(e); }\n+            }\n         }\n-        s0 = str::trim_left(rest(s0));\n+\n+        ok(num(neg * res))\n     }\n-    (none, s)\n-}\n \n-fn from_str_float(s: str) -> (option<json>, str) {\n-    let pos = 0u;\n-    let len = str::len(s);\n-    let res = 0f;\n-    let neg = 1f;\n+    fn parse_integer() -> result::t<float, error> {\n+        let res = 0f;\n \n-    alt str::char_at(s, 0u) {\n-        '-' {\n-            neg = -1f;\n-            pos = 1u;\n-        }\n-        '+' {\n-            pos = 1u;\n+        alt self.ch {\n+          '0' {\n+            self.bump();\n+\n+            // There can be only one leading '0'.\n+            alt self.ch {\n+              '0' to '9' { ret self.error(\"invalid number\"); }\n+              _ {}\n+            }\n+          }\n+          '1' to '9' {\n+            while !self.eof() {\n+                alt self.ch {\n+                  '0' to '9' {\n+                    res *= 10f;\n+                    res += ((self.ch as int) - ('0' as int)) as float;\n+\n+                    self.bump();\n+                  }\n+                  _ { break; }\n+                }\n+            }\n+          }\n+          _ { ret self.error(\"invalid number\"); }\n         }\n-        '0' to '9' | '.' { }\n-        _ { ret (none, s); }\n+\n+        ok(res)\n     }\n \n-    while (pos < len) {\n-        let opos = pos;\n-        let chr = str::char_range_at(s, pos);\n-        let c = chr.ch;\n-        pos = chr.next;\n-        alt c {\n-            '0' to '9' {\n-                res = res * 10f;\n-                res += ((c as int) - ('0' as int)) as float;\n+    fn parse_decimal(res: float) -> result::t<float, error> {\n+        self.bump();\n+\n+        // Make sure a digit follows the decimal place.\n+        alt self.ch {\n+          '0' to '9' {}\n+          _ { ret self.error(\"invalid number\"); }\n+        }\n+\n+        let res = res;\n+        let dec = 1f;\n+        while !self.eof() {\n+            alt self.ch {\n+              '0' to '9' {\n+                dec /= 10f;\n+                res += (((self.ch as int) - ('0' as int)) as float) * dec;\n+\n+                self.bump();\n+              }\n+              _ { break; }\n             }\n-            '.' { break; }\n-            _ { ret (some(num(neg * res)),\n-                     str::slice(s, opos, str::len(s))); }\n         }\n+\n+        ok(res)\n     }\n \n-    if pos == len {\n-        ret (some(num(neg * res)),\n-             str::slice(s, pos, str::len(s)));\n+    fn parse_exponent(res: float) -> result::t<float, error> {\n+        self.bump();\n+\n+        let res = res;\n+        let exp = 0u;\n+        let neg_exp = false;\n+\n+        alt self.ch {\n+          '+' { self.bump(); }\n+          '-' { self.bump(); neg_exp = true; }\n+          _ {}\n+        }\n+\n+        // Make sure a digit follows the exponent place.\n+        alt self.ch {\n+          '0' to '9' {}\n+          _ { ret self.error(\"invalid number\"); }\n+        }\n+\n+        while !self.eof() {\n+            alt self.ch {\n+              '0' to '9' {\n+                exp *= 10u;\n+                exp += (self.ch as uint) - ('0' as uint);\n+\n+                self.bump();\n+              }\n+              _ { break; }\n+            }\n+        }\n+\n+        let exp = float::pow_with_uint(10u, exp);\n+        if neg_exp {\n+            res /= exp;\n+        } else {\n+            res *= exp;\n+        }\n+\n+        ok(res)\n     }\n \n-    let dec = 1f;\n-    while (pos < len) {\n-        let opos = pos;\n-        let chr = str::char_range_at(s, pos);\n-        let c = chr.ch;\n-        pos = chr.next;\n-        alt c {\n-            '0' to '9' {\n-                dec /= 10f;\n-                res += (((c as int) - ('0' as int)) as float) * dec;\n+    fn parse_str() -> result::t<str, error> {\n+        let escape = false;\n+        let res = \"\";\n+\n+        while !self.eof() {\n+            self.bump();\n+\n+            if (escape) {\n+                alt self.ch {\n+                  '\"' { str::push_char(res, '\"'); }\n+                  '\\\\' { str::push_char(res, '\\\\'); }\n+                  '/' { str::push_char(res, '/'); }\n+                  'b' { str::push_char(res, '\\x08'); }\n+                  'f' { str::push_char(res, '\\x0c'); }\n+                  'n' { str::push_char(res, '\\n'); }\n+                  'r' { str::push_char(res, '\\r'); }\n+                  't' { str::push_char(res, '\\t'); }\n+                  'u' {\n+                      // Parse \\u1234.\n+                      let i = 0u;\n+                      let n = 0u;\n+                      while i < 4u {\n+                          alt self.next_char() {\n+                            '0' to '9' {\n+                              n = n * 10u +\n+                                  (self.ch as uint) - ('0' as uint);\n+                            }\n+                            _ { ret self.error(\"invalid \\\\u escape\"); }\n+                          }\n+                      }\n+\n+                      // Error out if we didn't parse 4 digits.\n+                      if i != 4u {\n+                          ret self.error(\"invalid \\\\u escape\");\n+                      }\n+\n+                      str::push_char(res, n as char);\n+                  }\n+                  _ { ret self.error(\"invalid escape\"); }\n+                }\n+                escape = false;\n+            } else if self.ch == '\\\\' {\n+                escape = true;\n+            } else {\n+                if self.ch == '\"' {\n+                    self.bump();\n+                    ret ok(res);\n+                }\n+                str::push_char(res, self.ch);\n             }\n-            _ { ret (some(num(neg * res)),\n-                     str::slice(s, opos, str::len(s))); }\n         }\n+\n+        self.error(\"EOF while parsing string\")\n     }\n-    ret (some(num(neg * res)), str::slice(s, pos, str::len(s)));\n-}\n \n-fn from_str_bool(s: str) -> (option<json>, str) {\n-    if (str::starts_with(s, \"true\")) {\n-        (some(boolean(true)), str::slice(s, 4u, str::len(s)))\n-    } else if (str::starts_with(s, \"false\")) {\n-        (some(boolean(false)), str::slice(s, 5u, str::len(s)))\n-    } else {\n-        (none, s)\n+    fn parse_list() -> result::t<json, error> {\n+        self.bump();\n+        self.parse_whitespace();\n+\n+        let values = [];\n+\n+        if self.ch == ']' {\n+            self.bump();\n+            ret ok(list(values));\n+        }\n+\n+        while true {\n+            alt self.parse_value() {\n+              ok(v) { vec::push(values, v); }\n+              e { ret e; }\n+            }\n+\n+            self.parse_whitespace();\n+            if self.eof() { break; }\n+\n+            alt self.ch {\n+              ',' { self.bump(); }\n+              ']' { self.bump(); ret ok(list(values)); }\n+              _ { ret self.error(\"expecting ',' or ']'\"); }\n+            }\n+        }\n+\n+        ret self.error(\"EOF while parsing list\");\n     }\n-}\n \n-fn from_str_null(s: str) -> (option<json>, str) {\n-    if (str::starts_with(s, \"null\")) {\n-        (some(null), str::slice(s, 4u, str::len(s)))\n-    } else {\n-        (none, s)\n+    fn parse_object() -> result::t<json, error> {\n+        self.bump();\n+        self.parse_whitespace();\n+\n+        let values = map::new_str_hash();\n+\n+        if self.ch == '}' {\n+          self.bump();\n+          ret ok(dict(values));\n+        }\n+\n+        while !self.eof() {\n+            self.parse_whitespace();\n+\n+            if self.ch != '\"' {\n+                ret self.error(\"key must be a string\");\n+            }\n+\n+            let key = alt self.parse_str() {\n+              ok(key) { key }\n+              err(e) { ret err(e); }\n+            };\n+\n+            self.parse_whitespace();\n+\n+            if self.ch != ':' {\n+                if self.eof() { break; }\n+                ret self.error(\"expecting ':'\");\n+            }\n+            self.bump();\n+\n+            alt self.parse_value() {\n+              ok(value) { values.insert(key, value); }\n+              e { ret e; }\n+            }\n+            self.parse_whitespace();\n+\n+            alt self.ch {\n+              ',' { self.bump(); }\n+              '}' { self.bump(); ret ok(dict(values)); }\n+              _ {\n+                  if self.eof() { break; }\n+                  ret self.error(\"expecting ',' or '}'\");\n+              }\n+            }\n+        }\n+\n+        ret self.error(\"EOF while parsing object\");\n     }\n }\n \n-fn from_str_helper(s: str) -> (option<json>, str) {\n-    let s = str::trim_left(s);\n-    if str::is_empty(s) { ret (none, s); }\n-    let start = str::char_at(s, 0u);\n-    alt start {\n-        '\"' { from_str_str(s) }\n-        '[' { from_str_list(s) }\n-        '{' { from_str_dict(s) }\n-        '0' to '9' | '-' | '+' | '.' { from_str_float(s) }\n-        't' | 'f' { from_str_bool(s) }\n-        'n' { from_str_null(s) }\n-        _ { ret (none, s); }\n-    }\n+/*\n+Function: from_reader\n+\n+Deserializes a json value from an io::reader.\n+*/\n+\n+fn from_reader(rdr: io::reader) -> result::t<json, error> {\n+    let parser = {\n+        rdr: rdr,\n+        mutable ch: rdr.read_char(),\n+        mutable line: 1u,\n+        mutable col: 1u,\n+    };\n+\n+    parser.parse()\n }\n \n /*\n Function: from_str\n \n Deserializes a json value from a string.\n */\n-fn from_str(s: str) -> option<json> {\n-    let (j, _) = from_str_helper(s);\n-    j\n+fn from_str(s: str) -> result::t<json, error> {\n+    from_reader(io::string_reader(s))\n+}\n+\n+/*\n+Function: eq\n+\n+Test if two json values are equal.\n+*/\n+fn eq(value0: json, value1: json) -> bool {\n+    alt (value0, value1) {\n+      (num(f0), num(f1)) { f0 == f1 }\n+      (string(s0), string(s1)) { s0 == s1 }\n+      (boolean(b0), boolean(b1)) { b0 == b1 }\n+      (list(l0), list(l1)) { vec::all2(l0, l1, eq) }\n+      (dict(d0), dict(d1)) {\n+          if d0.size() == d1.size() {\n+              let equal = true;\n+              d0.items { |k, v0|\n+                  alt d1.find(k) {\n+                    some(v1) {\n+                        if !eq(v0, v1) { equal = false; } }\n+                    none { equal = false; }\n+                  }\n+              };\n+              equal\n+          } else {\n+              false\n+          }\n+      }\n+      (null, null) { true }\n+      _ { false }\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n+    fn mk_dict(items: [(str, json)]) -> json {\n+        let d = map::new_str_hash();\n+\n+        vec::iter(items) { |item|\n+            let (key, value) = item;\n+            d.insert(key, value);\n+        };\n+\n+        dict(d)\n+    }\n+\n+    #[test]\n+    fn test_write_null() {\n+        assert to_str(null) == \"null\";\n+    }\n+\n+    #[test]\n+    fn test_write_num() {\n+        assert to_str(num(3f)) == \"3\";\n+        assert to_str(num(3.1f)) == \"3.1\";\n+        assert to_str(num(-1.5f)) == \"-1.5\";\n+        assert to_str(num(0.5f)) == \"0.5\";\n+    }\n+\n+    #[test]\n+    fn test_write_str() {\n+        assert to_str(string(\"\")) == \"\\\"\\\"\";\n+        assert to_str(string(\"foo\")) == \"\\\"foo\\\"\";\n+    }\n+\n+    #[test]\n+    fn test_write_bool() {\n+        assert to_str(boolean(true)) == \"true\";\n+        assert to_str(boolean(false)) == \"false\";\n+    }\n+\n+    #[test]\n+    fn test_write_list() {\n+        assert to_str(list([])) == \"[]\";\n+        assert to_str(list([boolean(true)])) == \"[true]\";\n+        assert to_str(list([\n+            boolean(false),\n+            null,\n+            list([string(\"foo\\nbar\"), num(3.5f)])\n+        ])) == \"[false, null, [\\\"foo\\\\nbar\\\", 3.5]]\";\n+    }\n+\n+    #[test]\n+    fn test_write_dict() {\n+        assert to_str(mk_dict([])) == \"{}\";\n+        assert to_str(mk_dict([(\"a\", boolean(true))])) == \"{ \\\"a\\\": true }\";\n+        assert to_str(mk_dict([\n+            (\"a\", boolean(true)),\n+            (\"b\", list([\n+                mk_dict([(\"c\", string(\"\\x0c\\r\"))]),\n+                mk_dict([(\"d\", string(\"\"))])\n+            ]))\n+        ])) ==\n+            \"{ \" +\n+                \"\\\"a\\\": true, \" +\n+                \"\\\"b\\\": [\" +\n+                    \"{ \\\"c\\\": \\\"\\\\f\\\\r\\\" }, \" +\n+                    \"{ \\\"d\\\": \\\"\\\" }\" +\n+                \"]\" +\n+            \" }\";\n+    }\n+\n     #[test]\n-    fn test_from_str_null() {\n-        assert(from_str(\"null\") == some(null));\n+    fn test_trailing_characters() {\n+        assert from_str(\"nulla\") ==\n+            err({line: 1u, col: 5u, msg: \"trailing characters\"});\n+        assert from_str(\"truea\") ==\n+            err({line: 1u, col: 5u, msg: \"trailing characters\"});\n+        assert from_str(\"falsea\") ==\n+            err({line: 1u, col: 6u, msg: \"trailing characters\"});\n+        assert from_str(\"1a\") ==\n+            err({line: 1u, col: 2u, msg: \"trailing characters\"});\n+        assert from_str(\"[]a\") ==\n+            err({line: 1u, col: 3u, msg: \"trailing characters\"});\n+        assert from_str(\"{}a\") ==\n+            err({line: 1u, col: 3u, msg: \"trailing characters\"});\n+    }\n+\n+    #[test]\n+    fn test_read_identifiers() {\n+        assert from_str(\"n\") ==\n+            err({line: 1u, col: 2u, msg: \"invalid syntax\"});\n+        assert from_str(\"nul\") ==\n+            err({line: 1u, col: 4u, msg: \"invalid syntax\"});\n+\n+        assert from_str(\"t\") ==\n+            err({line: 1u, col: 2u, msg: \"invalid syntax\"});\n+        assert from_str(\"truz\") ==\n+            err({line: 1u, col: 4u, msg: \"invalid syntax\"});\n+\n+        assert from_str(\"f\") ==\n+            err({line: 1u, col: 2u, msg: \"invalid syntax\"});\n+        assert from_str(\"faz\") ==\n+            err({line: 1u, col: 3u, msg: \"invalid syntax\"});\n+\n+        assert from_str(\"null\") == ok(null);\n+        assert from_str(\"true\") == ok(boolean(true));\n+        assert from_str(\"false\") == ok(boolean(false));\n     }\n \n     #[test]\n-    fn test_from_str_num() {\n-        assert(from_str(\"3\") == some(num(3f)));\n-        assert(from_str(\"3.1\") == some(num(3.1f)));\n-        assert(from_str(\"-1.2\") == some(num(-1.2f)));\n-        assert(from_str(\".4\") == some(num(0.4f)));\n+    fn test_read_num() {\n+        assert from_str(\"+\") ==\n+            err({line: 1u, col: 1u, msg: \"invalid syntax\"});\n+        assert from_str(\".\") ==\n+            err({line: 1u, col: 1u, msg: \"invalid syntax\"});\n+\n+        assert from_str(\"-\") ==\n+            err({line: 1u, col: 2u, msg: \"invalid number\"});\n+        assert from_str(\"00\") ==\n+            err({line: 1u, col: 2u, msg: \"invalid number\"});\n+        assert from_str(\"1.\") ==\n+            err({line: 1u, col: 3u, msg: \"invalid number\"});\n+        assert from_str(\"1e\") ==\n+            err({line: 1u, col: 3u, msg: \"invalid number\"});\n+        assert from_str(\"1e+\") ==\n+            err({line: 1u, col: 4u, msg: \"invalid number\"});\n+\n+        assert from_str(\"3\") == ok(num(3f));\n+        assert from_str(\"3.1\") == ok(num(3.1f));\n+        assert from_str(\"-1.2\") == ok(num(-1.2f));\n+        assert from_str(\"0.4\") == ok(num(0.4f));\n+        assert from_str(\"0.4e5\") == ok(num(0.4e5f));\n+        assert from_str(\"0.4e+15\") == ok(num(0.4e15f));\n+        assert from_str(\"0.4e-01\") == ok(num(0.4e-01f));\n     }\n \n     #[test]\n-    fn test_from_str_str() {\n-        assert(from_str(\"\\\"foo\\\"\") == some(string(\"foo\")));\n-        assert(from_str(\"\\\"\\\\\\\"\\\"\") == some(string(\"\\\"\")));\n-        assert(from_str(\"\\\"lol\") == none);\n+    fn test_read_str() {\n+        assert from_str(\"\\\"\") ==\n+            err({line: 1u, col: 2u, msg: \"EOF while parsing string\"});\n+        assert from_str(\"\\\"lol\") ==\n+            err({line: 1u, col: 5u, msg: \"EOF while parsing string\"});\n+\n+        assert from_str(\"\\\"\\\"\") == ok(string(\"\"));\n+        assert from_str(\"\\\"foo\\\"\") == ok(string(\"foo\"));\n+        assert from_str(\"\\\"\\\\\\\"\\\"\") == ok(string(\"\\\"\"));\n+        assert from_str(\"\\\"\\\\b\\\"\") == ok(string(\"\\x08\"));\n+        assert from_str(\"\\\"\\\\n\\\"\") == ok(string(\"\\n\"));\n+        assert from_str(\"\\\"\\\\r\\\"\") == ok(string(\"\\r\"));\n+        assert from_str(\"\\\"\\\\t\\\"\") == ok(string(\"\\t\"));\n     }\n \n     #[test]\n-    fn test_from_str_bool() {\n-        assert(from_str(\"true\") == some(boolean(true)));\n-        assert(from_str(\"false\") == some(boolean(false)));\n-        assert(from_str(\"truz\") == none);\n+    fn test_read_list() {\n+        assert from_str(\"[\") ==\n+            err({line: 1u, col: 2u, msg: \"EOF while parsing value\"});\n+        assert from_str(\"[1\") ==\n+            err({line: 1u, col: 3u, msg: \"EOF while parsing list\"});\n+        assert from_str(\"[1,\") ==\n+            err({line: 1u, col: 4u, msg: \"EOF while parsing value\"});\n+        assert from_str(\"[1,]\") ==\n+            err({line: 1u, col: 4u, msg: \"invalid syntax\"});\n+        assert from_str(\"[6 7]\") ==\n+            err({line: 1u, col: 4u, msg: \"expecting ',' or ']'\"});\n+\n+        assert from_str(\"[]\") == ok(list([]));\n+        assert from_str(\"[ ]\") == ok(list([]));\n+        assert from_str(\"[true]\") == ok(list([boolean(true)]));\n+        assert from_str(\"[ false ]\") == ok(list([boolean(false)]));\n+        assert from_str(\"[null]\") == ok(list([null]));\n+        assert from_str(\"[3, 1]\") == ok(list([num(3f), num(1f)]));\n+        assert from_str(\"[2, [4, 1]]\") ==\n+               ok(list([num(2f), list([num(4f), num(1f)])]));\n     }\n \n     #[test]\n-    fn test_from_str_list() {\n-        assert(from_str(\"[]\") == some(list(@[])));\n-        assert(from_str(\"[true]\") == some(list(@[boolean(true)])));\n-        assert(from_str(\"[null]\") == some(list(@[null])));\n-        assert(from_str(\"[3, 1]\") == some(list(@[num(3f), num(1f)])));\n-        assert(from_str(\"[2, [4, 1]]\") ==\n-               some(list(@[num(2f), list(@[num(4f), num(1f)])])));\n-        assert(from_str(\"[2, ]\") == none);\n-        assert(from_str(\"[5, \") == none);\n-        assert(from_str(\"[6 7]\") == none);\n-        assert(from_str(\"[3\") == none);\n+    fn test_read_dict() {\n+        assert from_str(\"{\") ==\n+            err({line: 1u, col: 2u, msg: \"EOF while parsing object\"});\n+        assert from_str(\"{ \") ==\n+            err({line: 1u, col: 3u, msg: \"EOF while parsing object\"});\n+        assert from_str(\"{1\") ==\n+            err({line: 1u, col: 2u, msg: \"key must be a string\"});\n+        assert from_str(\"{ \\\"a\\\"\") ==\n+            err({line: 1u, col: 6u, msg: \"EOF while parsing object\"});\n+        assert from_str(\"{\\\"a\\\"\") ==\n+            err({line: 1u, col: 5u, msg: \"EOF while parsing object\"});\n+        assert from_str(\"{\\\"a\\\" \") ==\n+            err({line: 1u, col: 6u, msg: \"EOF while parsing object\"});\n+\n+        assert from_str(\"{\\\"a\\\" 1\") ==\n+            err({line: 1u, col: 6u, msg: \"expecting ':'\"});\n+        assert from_str(\"{\\\"a\\\":\") ==\n+            err({line: 1u, col: 6u, msg: \"EOF while parsing value\"});\n+        assert from_str(\"{\\\"a\\\":1\") ==\n+            err({line: 1u, col: 7u, msg: \"EOF while parsing object\"});\n+        assert from_str(\"{\\\"a\\\":1 1\") ==\n+            err({line: 1u, col: 8u, msg: \"expecting ',' or '}'\"});\n+        assert from_str(\"{\\\"a\\\":1,\") ==\n+            err({line: 1u, col: 8u, msg: \"EOF while parsing object\"});\n+\n+        assert eq(result::get(from_str(\"{}\")), mk_dict([]));\n+        assert eq(result::get(from_str(\"{\\\"a\\\": 3}\")),\n+                  mk_dict([(\"a\", num(3.0f))]));\n+\n+        assert eq(result::get(from_str(\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n+                  mk_dict([(\"a\", null), (\"b\", boolean(true))]));\n+        assert eq(result::get(from_str(\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n+                  mk_dict([\n+                      (\"a\", num(1.0)),\n+                      (\"b\", list([boolean(true)]))\n+                  ]));\n+        assert eq(result::get(from_str(\n+                      \"{\" +\n+                          \"\\\"a\\\": 1.0, \" +\n+                          \"\\\"b\\\": [\" +\n+                              \"true,\" +\n+                              \"\\\"foo\\\\nbar\\\", \" +\n+                              \"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n+                          \"]\" +\n+                      \"}\")),\n+                  mk_dict([\n+                      (\"a\", num(1.0f)),\n+                      (\"b\", list([\n+                          boolean(true),\n+                          string(\"foo\\nbar\"),\n+                          mk_dict([\n+                              (\"c\", mk_dict([(\"d\", null)]))\n+                          ])\n+                      ]))\n+                  ]));\n     }\n \n     #[test]\n-    fn test_from_str_dict() {\n-        assert(from_str(\"{}\") != none);\n-        assert(from_str(\"{\\\"a\\\": 3}\") != none);\n-        assert(from_str(\"{\\\"a\\\": null}\") != none);\n-        assert(from_str(\"{\\\"a\\\": }\") == none);\n-        assert(from_str(\"{\\\"a\\\" }\") == none);\n-        assert(from_str(\"{\\\"a\\\"\") == none);\n-        assert(from_str(\"{\") == none);\n+    fn test_multiline_errors() {\n+        assert from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n+            err({line: 3u, col: 8u, msg: \"EOF while parsing object\"});\n     }\n }"}]}