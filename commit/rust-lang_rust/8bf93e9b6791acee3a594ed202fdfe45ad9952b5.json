{"sha": "8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "node_id": "C_kwDOAAsO6NoAKDhiZjkzZTliNjc5MWFjZWUzYTU5NGVkMjAyZmRmZTQ1YWQ5OTUyYjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-09T20:13:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-09T20:13:28Z"}, "message": "Auto merge of #95855 - Dylan-DPC:rollup-h45xmpw, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #94794 (Clarify indexing into Strings)\n - #95361 (Make non-power-of-two alignments a validity error in `Layout`)\n - #95369 (Fix `x test src/librustdoc` with `download-rustc` enabled )\n - #95805 (Left overs of #95761)\n - #95808 (expand: Remove `ParseSess::missing_fragment_specifiers`)\n - #95817 (hide another #[allow] directive from a docs example)\n - #95831 (Use bitwise XOR in to_ascii_uppercase)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b7068e427d11a5cbc64f5da386e58e102f671235", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7068e427d11a5cbc64f5da386e58e102f671235"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "html_url": "https://github.com/rust-lang/rust/commit/8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c1fb2eb23964b56bd279b12aa925935d8559870", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c1fb2eb23964b56bd279b12aa925935d8559870", "html_url": "https://github.com/rust-lang/rust/commit/8c1fb2eb23964b56bd279b12aa925935d8559870"}, {"sha": "7726265ae0d3d2b37b4254980a72d5d5347fb92d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7726265ae0d3d2b37b4254980a72d5d5347fb92d", "html_url": "https://github.com/rust-lang/rust/commit/7726265ae0d3d2b37b4254980a72d5d5347fb92d"}], "stats": {"total": 664, "additions": 569, "deletions": 95}, "files": [{"sha": "dc181ecda5b05cc695f27b205255c08abaa68683", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -2,7 +2,6 @@\n #![feature(associated_type_bounds)]\n #![feature(associated_type_defaults)]\n #![feature(crate_visibility_modifier)]\n-#![feature(decl_macro)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "4298475767e6f7bd03deb95a948cea660fbf5a0c", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -110,7 +110,7 @@ use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::MultiSpan;\n-use rustc_session::lint::builtin::META_VARIABLE_MISUSE;\n+use rustc_session::lint::builtin::{META_VARIABLE_MISUSE, MISSING_FRAGMENT_SPECIFIER};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::kw;\n use rustc_span::{symbol::MacroRulesNormalizedIdent, Span};\n@@ -261,7 +261,18 @@ fn check_binders(\n             }\n         }\n         // Similarly, this can only happen when checking a toplevel macro.\n-        TokenTree::MetaVarDecl(span, name, _kind) => {\n+        TokenTree::MetaVarDecl(span, name, kind) => {\n+            if kind.is_none() && node_id != DUMMY_NODE_ID {\n+                // FIXME: Report this as a hard error eventually and remove equivalent errors from\n+                // `parse_tt_inner` and `nameize`. Until then the error may be reported twice, once\n+                // as a hard error and then once as a buffered lint.\n+                sess.buffer_lint(\n+                    MISSING_FRAGMENT_SPECIFIER,\n+                    span,\n+                    node_id,\n+                    &format!(\"missing fragment specifier\"),\n+                );\n+            }\n             if !macros.is_empty() {\n                 sess.span_diagnostic.span_bug(span, \"unexpected MetaVarDecl in nested lhs\");\n             }"}, {"sha": "ce243b4a672726f6b42b63e6e42f595649234c46", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -411,7 +411,6 @@ impl TtParser {\n     /// track of through the mps generated.\n     fn parse_tt_inner(\n         &mut self,\n-        sess: &ParseSess,\n         matcher: &[MatcherLoc],\n         token: &Token,\n     ) -> Option<NamedParseResult> {\n@@ -519,11 +518,9 @@ impl TtParser {\n                             self.bb_mps.push(mp);\n                         }\n                     } else {\n+                        // E.g. `$e` instead of `$e:expr`, reported as a hard error if actually used.\n                         // Both this check and the one in `nameize` are necessary, surprisingly.\n-                        if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n-                            // E.g. `$e` instead of `$e:expr`.\n-                            return Some(Error(span, \"missing fragment specifier\".to_string()));\n-                        }\n+                        return Some(Error(span, \"missing fragment specifier\".to_string()));\n                     }\n                 }\n                 MatcherLoc::Eof => {\n@@ -549,7 +546,7 @@ impl TtParser {\n                     // Need to take ownership of the matches from within the `Lrc`.\n                     Lrc::make_mut(&mut eof_mp.matches);\n                     let matches = Lrc::try_unwrap(eof_mp.matches).unwrap().into_iter();\n-                    self.nameize(sess, matcher, matches)\n+                    self.nameize(matcher, matches)\n                 }\n                 EofMatcherPositions::Multiple => {\n                     Error(token.span, \"ambiguity: multiple successful parses\".to_string())\n@@ -587,7 +584,7 @@ impl TtParser {\n \n             // Process `cur_mps` until either we have finished the input or we need to get some\n             // parsing from the black-box parser done.\n-            if let Some(res) = self.parse_tt_inner(&parser.sess, matcher, &parser.token) {\n+            if let Some(res) = self.parse_tt_inner(matcher, &parser.token) {\n                 return res;\n             }\n \n@@ -694,7 +691,6 @@ impl TtParser {\n \n     fn nameize<I: Iterator<Item = NamedMatch>>(\n         &self,\n-        sess: &ParseSess,\n         matcher: &[MatcherLoc],\n         mut res: I,\n     ) -> NamedParseResult {\n@@ -711,11 +707,9 @@ impl TtParser {\n                         }\n                     };\n                 } else {\n+                    // E.g. `$e` instead of `$e:expr`, reported as a hard error if actually used.\n                     // Both this check and the one in `parse_tt_inner` are necessary, surprisingly.\n-                    if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n-                        // E.g. `$e` instead of `$e:expr`.\n-                        return Error(span, \"missing fragment specifier\".to_string());\n-                    }\n+                    return Error(span, \"missing fragment specifier\".to_string());\n                 }\n             }\n         }"}, {"sha": "024299fbd9c01f353eca515ae8e6823518ac8fe6", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -2,8 +2,7 @@ use crate::mbe::macro_parser::count_metavar_decls;\n use crate::mbe::{Delimited, KleeneOp, KleeneToken, MetaVarExpr, SequenceRepetition, TokenTree};\n \n use rustc_ast::token::{self, Token};\n-use rustc_ast::tokenstream;\n-use rustc_ast::{NodeId, DUMMY_NODE_ID};\n+use rustc_ast::{tokenstream, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_feature::Features;\n use rustc_session::parse::{feature_err, ParseSess};\n@@ -104,10 +103,7 @@ pub(super) fn parse(\n                     }\n                     tree => tree.as_ref().map_or(start_sp, tokenstream::TokenTree::span),\n                 };\n-                if node_id != DUMMY_NODE_ID {\n-                    // Macros loaded from other crates have dummy node ids.\n-                    sess.missing_fragment_specifiers.borrow_mut().insert(span, node_id);\n-                }\n+\n                 result.push(TokenTree::MetaVarDecl(span, ident, None));\n             }\n "}, {"sha": "2a01b677e33bf7e47cd4ec5e4b1a4c387bbe0666", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -30,7 +30,6 @@ use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_serialize::json;\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n use rustc_session::cstore::{MetadataLoader, MetadataLoaderDyn};\n-use rustc_session::lint;\n use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n@@ -349,23 +348,8 @@ pub fn configure_and_expand(\n             ecx.check_unused_macros();\n         });\n \n-        let mut missing_fragment_specifiers: Vec<_> = ecx\n-            .sess\n-            .parse_sess\n-            .missing_fragment_specifiers\n-            .borrow()\n-            .iter()\n-            .map(|(span, node_id)| (*span, *node_id))\n-            .collect();\n-        missing_fragment_specifiers.sort_unstable_by_key(|(span, _)| *span);\n-\n         let recursion_limit_hit = ecx.reduced_recursion_limit.is_some();\n \n-        for (span, node_id) in missing_fragment_specifiers {\n-            let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n-            let msg = \"missing fragment specifier\";\n-            resolver.lint_buffer().buffer_lint(lint, node_id, span, msg);\n-        }\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }"}, {"sha": "1fa180b320cd8d11b3f11e0a8b740fe63116e39b", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -140,7 +140,6 @@ pub struct ParseSess {\n     pub config: CrateConfig,\n     pub check_config: CrateCheckConfig,\n     pub edition: Edition,\n-    pub missing_fragment_specifiers: Lock<FxHashMap<Span, NodeId>>,\n     /// Places where raw identifiers were used. This is used to avoid complaining about idents\n     /// clashing with keywords in new editions.\n     pub raw_identifier_spans: Lock<Vec<Span>>,\n@@ -195,7 +194,6 @@ impl ParseSess {\n             config: FxHashSet::default(),\n             check_config: CrateCheckConfig::default(),\n             edition: ExpnId::root().expn_data().edition,\n-            missing_fragment_specifiers: Default::default(),\n             raw_identifier_spans: Lock::new(Vec::new()),\n             bad_unicode_identifiers: Lock::new(Default::default()),\n             source_map,"}, {"sha": "d0d37c08d13068afe56809fb7c3338aebd52732c", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -393,7 +393,7 @@ impl<T> Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![allow(dead_code)]\n+    /// # #![allow(dead_code)]\n     /// use std::rc::{Rc, Weak};\n     ///\n     /// struct Gadget {"}, {"sha": "e97c1637fd5a26fea0b4674e7e7de6419d363ac5", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 82, "deletions": 10, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -117,27 +117,99 @@ use crate::vec::Vec;\n ///\n /// # UTF-8\n ///\n-/// `String`s are always valid UTF-8. This has a few implications, the first of\n-/// which is that if you need a non-UTF-8 string, consider [`OsString`]. It is\n-/// similar, but without the UTF-8 constraint. The second implication is that\n-/// you cannot index into a `String`:\n+/// `String`s are always valid UTF-8. If you need a non-UTF-8 string, consider\n+/// [`OsString`]. It is similar, but without the UTF-8 constraint. Because UTF-8\n+/// is a variable width encoding, `String`s are typically smaller than an array of\n+/// the same `chars`:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// // `s` is ASCII which represents each `char` as one byte\n+/// let s = \"hello\";\n+/// assert_eq!(s.len(), 5);\n+///\n+/// // A `char` array with the same contents would be longer because\n+/// // every `char` is four bytes\n+/// let s = ['h', 'e', 'l', 'l', 'o'];\n+/// let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();\n+/// assert_eq!(size, 20);\n+///\n+/// // However, for non-ASCII strings, the difference will be smaller\n+/// // and sometimes they are the same\n+/// let s = \"\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\";\n+/// assert_eq!(s.len(), 20);\n+///\n+/// let s = ['\ud83d\udc96', '\ud83d\udc96', '\ud83d\udc96', '\ud83d\udc96', '\ud83d\udc96'];\n+/// let size: usize = s.into_iter().map(|c| mem::size_of_val(&c)).sum();\n+/// assert_eq!(size, 20);\n+/// ```\n+///\n+/// This raises interesting questions as to how `s[i]` should work.\n+/// What should `i` be here? Several options include byte indices and\n+/// `char` indices but, because of UTF-8 encoding, only byte indices\n+/// would provide constant time indexing. Getting the `i`th `char`, for\n+/// example, is available using [`chars`]:\n+///\n+/// ```\n+/// let s = \"hello\";\n+/// let third_character = s.chars().nth(2);\n+/// assert_eq!(third_character, Some('l'));\n+///\n+/// let s = \"\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\";\n+/// let third_character = s.chars().nth(2);\n+/// assert_eq!(third_character, Some('\ud83d\udc96'));\n+/// ```\n+///\n+/// Next, what should `s[i]` return? Because indexing returns a reference\n+/// to underlying data it could be `&u8`, `&[u8]`, or something else similar.\n+/// Since we're only providing one index, `&u8` makes the most sense but that\n+/// might not be what the user expects and can be explicitly achieved with\n+/// [`as_bytes()`]:\n+///\n+/// ```\n+/// // The first byte is 104 - the byte value of `'h'`\n+/// let s = \"hello\";\n+/// assert_eq!(s.as_bytes()[0], 104);\n+/// // or\n+/// assert_eq!(s.as_bytes()[0], b'h');\n+///\n+/// // The first byte is 240 which isn't obviously useful\n+/// let s = \"\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\";\n+/// assert_eq!(s.as_bytes()[0], 240);\n+/// ```\n+///\n+/// Due to these ambiguities/restrictions, indexing with a `usize` is simply\n+/// forbidden:\n ///\n /// ```compile_fail,E0277\n /// let s = \"hello\";\n ///\n-/// println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n+/// // The following will not compile!\n+/// println!(\"The first letter of s is {}\", s[0]);\n /// ```\n ///\n+/// It is more clear, however, how `&s[i..j]` should work (that is,\n+/// indexing with a range). It should accept byte indices (to be constant-time)\n+/// and return a `&str` which is UTF-8 encoded. This is also called \"string slicing\".\n+/// Note this will panic if the byte indices provided are not character\n+/// boundaries - see [`is_char_boundary`] for more details. See the implementations\n+/// for [`SliceIndex<str>`] for more details on string slicing. For a non-panicking\n+/// version of string slicing, see [`get`].\n+///\n /// [`OsString`]: ../../std/ffi/struct.OsString.html \"ffi::OsString\"\n+/// [`SliceIndex<str>`]: core::slice::SliceIndex\n+/// [`as_bytes()`]: str::as_bytes\n+/// [`get`]: str::get\n+/// [`is_char_boundary`]: str::is_char_boundary\n ///\n-/// Indexing is intended to be a constant-time operation, but UTF-8 encoding\n-/// does not allow us to do this. Furthermore, it's not clear what sort of\n-/// thing the index should return: a byte, a codepoint, or a grapheme cluster.\n-/// The [`bytes`] and [`chars`] methods return iterators over the first\n-/// two, respectively.\n+/// The [`bytes`] and [`chars`] methods return iterators over the bytes and\n+/// codepoints of the string, respectively. To iterate over codepoints along\n+/// with byte indices, use [`char_indices`].\n ///\n /// [`bytes`]: str::bytes\n /// [`chars`]: str::chars\n+/// [`char_indices`]: str::char_indices\n ///\n /// # Deref\n ///"}, {"sha": "612e366cedf7876f1e490a3a5a93fcaeeab61e31", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -1,7 +1,6 @@\n use crate::cmp;\n use crate::fmt;\n-use crate::mem;\n-use crate::num::NonZeroUsize;\n+use crate::mem::{self, ValidAlign};\n use crate::ptr::NonNull;\n \n // While this function is used in one place and its implementation\n@@ -40,7 +39,7 @@ pub struct Layout {\n     //\n     // (However, we do not analogously require `align >= sizeof(void*)`,\n     //  even though that is *also* a requirement of `posix_memalign`.)\n-    align_: NonZeroUsize,\n+    align_: ValidAlign,\n }\n \n impl Layout {\n@@ -97,8 +96,8 @@ impl Layout {\n     #[must_use]\n     #[inline]\n     pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n-        // SAFETY: the caller must ensure that `align` is greater than zero.\n-        Layout { size_: size, align_: unsafe { NonZeroUsize::new_unchecked(align) } }\n+        // SAFETY: the caller must ensure that `align` is a power of two.\n+        Layout { size_: size, align_: unsafe { ValidAlign::new_unchecked(align) } }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout.\n@@ -117,7 +116,7 @@ impl Layout {\n                   without modifying the layout\"]\n     #[inline]\n     pub const fn align(&self) -> usize {\n-        self.align_.get()\n+        self.align_.as_nonzero().get()\n     }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`."}, {"sha": "712d06f217034967d47d8c2d532af643d6e87215", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -21,6 +21,12 @@ mod maybe_uninit;\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n pub use maybe_uninit::MaybeUninit;\n \n+mod valid_align;\n+// For now this type is left crate-local.  It could potentially make sense to expose\n+// it publicly, as it would be a nice parameter type for methods which need to take\n+// alignment as a parameter, such as `Layout::padding_needed_for`.\n+pub(crate) use valid_align::ValidAlign;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(inline)]\n pub use crate::intrinsics::transmute;"}, {"sha": "596a67f255a1bbcf3cbe003cbc8daab3903f57cf", "filename": "library/core/src/mem/valid_align.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -0,0 +1,240 @@\n+use crate::convert::TryFrom;\n+use crate::num::NonZeroUsize;\n+use crate::{cmp, fmt, mem, num};\n+\n+/// A type storing a `usize` which is a power of two, and thus\n+/// represents a possible alignment in the rust abstract machine.\n+///\n+/// Note that particularly large alignments, while representable in this type,\n+/// are likely not to be supported by actual allocators and linkers.\n+#[derive(Copy, Clone)]\n+#[repr(transparent)]\n+pub(crate) struct ValidAlign(ValidAlignEnum);\n+\n+// ValidAlign is `repr(usize)`, but via extra steps.\n+const _: () = assert!(mem::size_of::<ValidAlign>() == mem::size_of::<usize>());\n+const _: () = assert!(mem::align_of::<ValidAlign>() == mem::align_of::<usize>());\n+\n+impl ValidAlign {\n+    /// Creates a `ValidAlign` from a power-of-two `usize`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `align` must be a power of two.\n+    ///\n+    /// Equivalently, it must be `1 << exp` for some `exp` in `0..usize::BITS`.\n+    /// It must *not* be zero.\n+    #[inline]\n+    pub(crate) const unsafe fn new_unchecked(align: usize) -> Self {\n+        debug_assert!(align.is_power_of_two());\n+\n+        // SAFETY: By precondition, this must be a power of two, and\n+        // our variants encompass all possible powers of two.\n+        unsafe { mem::transmute::<usize, ValidAlign>(align) }\n+    }\n+\n+    #[inline]\n+    pub(crate) const fn as_nonzero(self) -> NonZeroUsize {\n+        // SAFETY: All the discriminants are non-zero.\n+        unsafe { NonZeroUsize::new_unchecked(self.0 as usize) }\n+    }\n+\n+    /// Returns the base 2 logarithm of the alignment.\n+    ///\n+    /// This is always exact, as `self` represents a power of two.\n+    #[inline]\n+    pub(crate) fn log2(self) -> u32 {\n+        self.as_nonzero().trailing_zeros()\n+    }\n+}\n+\n+impl fmt::Debug for ValidAlign {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?} (1 << {:?})\", self.as_nonzero(), self.log2())\n+    }\n+}\n+\n+impl TryFrom<NonZeroUsize> for ValidAlign {\n+    type Error = num::TryFromIntError;\n+\n+    #[inline]\n+    fn try_from(align: NonZeroUsize) -> Result<ValidAlign, Self::Error> {\n+        if align.is_power_of_two() {\n+            // SAFETY: Just checked for power-of-two\n+            unsafe { Ok(ValidAlign::new_unchecked(align.get())) }\n+        } else {\n+            Err(num::TryFromIntError(()))\n+        }\n+    }\n+}\n+\n+impl TryFrom<usize> for ValidAlign {\n+    type Error = num::TryFromIntError;\n+\n+    #[inline]\n+    fn try_from(align: usize) -> Result<ValidAlign, Self::Error> {\n+        if align.is_power_of_two() {\n+            // SAFETY: Just checked for power-of-two\n+            unsafe { Ok(ValidAlign::new_unchecked(align)) }\n+        } else {\n+            Err(num::TryFromIntError(()))\n+        }\n+    }\n+}\n+\n+impl cmp::Eq for ValidAlign {}\n+\n+impl cmp::PartialEq for ValidAlign {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.as_nonzero() == other.as_nonzero()\n+    }\n+}\n+\n+impl cmp::Ord for ValidAlign {\n+    #[inline]\n+    fn cmp(&self, other: &Self) -> cmp::Ordering {\n+        self.as_nonzero().cmp(&other.as_nonzero())\n+    }\n+}\n+\n+impl cmp::PartialOrd for ValidAlign {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[cfg(target_pointer_width = \"16\")]\n+type ValidAlignEnum = ValidAlignEnum16;\n+#[cfg(target_pointer_width = \"32\")]\n+type ValidAlignEnum = ValidAlignEnum32;\n+#[cfg(target_pointer_width = \"64\")]\n+type ValidAlignEnum = ValidAlignEnum64;\n+\n+#[derive(Copy, Clone)]\n+#[repr(u16)]\n+enum ValidAlignEnum16 {\n+    _Align1Shl0 = 1 << 0,\n+    _Align1Shl1 = 1 << 1,\n+    _Align1Shl2 = 1 << 2,\n+    _Align1Shl3 = 1 << 3,\n+    _Align1Shl4 = 1 << 4,\n+    _Align1Shl5 = 1 << 5,\n+    _Align1Shl6 = 1 << 6,\n+    _Align1Shl7 = 1 << 7,\n+    _Align1Shl8 = 1 << 8,\n+    _Align1Shl9 = 1 << 9,\n+    _Align1Shl10 = 1 << 10,\n+    _Align1Shl11 = 1 << 11,\n+    _Align1Shl12 = 1 << 12,\n+    _Align1Shl13 = 1 << 13,\n+    _Align1Shl14 = 1 << 14,\n+    _Align1Shl15 = 1 << 15,\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(u32)]\n+enum ValidAlignEnum32 {\n+    _Align1Shl0 = 1 << 0,\n+    _Align1Shl1 = 1 << 1,\n+    _Align1Shl2 = 1 << 2,\n+    _Align1Shl3 = 1 << 3,\n+    _Align1Shl4 = 1 << 4,\n+    _Align1Shl5 = 1 << 5,\n+    _Align1Shl6 = 1 << 6,\n+    _Align1Shl7 = 1 << 7,\n+    _Align1Shl8 = 1 << 8,\n+    _Align1Shl9 = 1 << 9,\n+    _Align1Shl10 = 1 << 10,\n+    _Align1Shl11 = 1 << 11,\n+    _Align1Shl12 = 1 << 12,\n+    _Align1Shl13 = 1 << 13,\n+    _Align1Shl14 = 1 << 14,\n+    _Align1Shl15 = 1 << 15,\n+    _Align1Shl16 = 1 << 16,\n+    _Align1Shl17 = 1 << 17,\n+    _Align1Shl18 = 1 << 18,\n+    _Align1Shl19 = 1 << 19,\n+    _Align1Shl20 = 1 << 20,\n+    _Align1Shl21 = 1 << 21,\n+    _Align1Shl22 = 1 << 22,\n+    _Align1Shl23 = 1 << 23,\n+    _Align1Shl24 = 1 << 24,\n+    _Align1Shl25 = 1 << 25,\n+    _Align1Shl26 = 1 << 26,\n+    _Align1Shl27 = 1 << 27,\n+    _Align1Shl28 = 1 << 28,\n+    _Align1Shl29 = 1 << 29,\n+    _Align1Shl30 = 1 << 30,\n+    _Align1Shl31 = 1 << 31,\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(u64)]\n+enum ValidAlignEnum64 {\n+    _Align1Shl0 = 1 << 0,\n+    _Align1Shl1 = 1 << 1,\n+    _Align1Shl2 = 1 << 2,\n+    _Align1Shl3 = 1 << 3,\n+    _Align1Shl4 = 1 << 4,\n+    _Align1Shl5 = 1 << 5,\n+    _Align1Shl6 = 1 << 6,\n+    _Align1Shl7 = 1 << 7,\n+    _Align1Shl8 = 1 << 8,\n+    _Align1Shl9 = 1 << 9,\n+    _Align1Shl10 = 1 << 10,\n+    _Align1Shl11 = 1 << 11,\n+    _Align1Shl12 = 1 << 12,\n+    _Align1Shl13 = 1 << 13,\n+    _Align1Shl14 = 1 << 14,\n+    _Align1Shl15 = 1 << 15,\n+    _Align1Shl16 = 1 << 16,\n+    _Align1Shl17 = 1 << 17,\n+    _Align1Shl18 = 1 << 18,\n+    _Align1Shl19 = 1 << 19,\n+    _Align1Shl20 = 1 << 20,\n+    _Align1Shl21 = 1 << 21,\n+    _Align1Shl22 = 1 << 22,\n+    _Align1Shl23 = 1 << 23,\n+    _Align1Shl24 = 1 << 24,\n+    _Align1Shl25 = 1 << 25,\n+    _Align1Shl26 = 1 << 26,\n+    _Align1Shl27 = 1 << 27,\n+    _Align1Shl28 = 1 << 28,\n+    _Align1Shl29 = 1 << 29,\n+    _Align1Shl30 = 1 << 30,\n+    _Align1Shl31 = 1 << 31,\n+    _Align1Shl32 = 1 << 32,\n+    _Align1Shl33 = 1 << 33,\n+    _Align1Shl34 = 1 << 34,\n+    _Align1Shl35 = 1 << 35,\n+    _Align1Shl36 = 1 << 36,\n+    _Align1Shl37 = 1 << 37,\n+    _Align1Shl38 = 1 << 38,\n+    _Align1Shl39 = 1 << 39,\n+    _Align1Shl40 = 1 << 40,\n+    _Align1Shl41 = 1 << 41,\n+    _Align1Shl42 = 1 << 42,\n+    _Align1Shl43 = 1 << 43,\n+    _Align1Shl44 = 1 << 44,\n+    _Align1Shl45 = 1 << 45,\n+    _Align1Shl46 = 1 << 46,\n+    _Align1Shl47 = 1 << 47,\n+    _Align1Shl48 = 1 << 48,\n+    _Align1Shl49 = 1 << 49,\n+    _Align1Shl50 = 1 << 50,\n+    _Align1Shl51 = 1 << 51,\n+    _Align1Shl52 = 1 << 52,\n+    _Align1Shl53 = 1 << 53,\n+    _Align1Shl54 = 1 << 54,\n+    _Align1Shl55 = 1 << 55,\n+    _Align1Shl56 = 1 << 56,\n+    _Align1Shl57 = 1 << 57,\n+    _Align1Shl58 = 1 << 58,\n+    _Align1Shl59 = 1 << 59,\n+    _Align1Shl60 = 1 << 60,\n+    _Align1Shl61 = 1 << 61,\n+    _Align1Shl62 = 1 << 62,\n+    _Align1Shl63 = 1 << 63,\n+}"}, {"sha": "98c9bf556bb07931d4147833f85ad53176c91552", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -299,8 +299,8 @@ impl u8 {\n     #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.52.0\")]\n     #[inline]\n     pub const fn to_ascii_uppercase(&self) -> u8 {\n-        // Unset the fifth bit if this is a lowercase letter\n-        *self & !((self.is_ascii_lowercase() as u8) * ASCII_CASE_MASK)\n+        // Toggle the fifth bit if this is a lowercase letter\n+        *self ^ ((self.is_ascii_lowercase() as u8) * ASCII_CASE_MASK)\n     }\n \n     /// Makes a copy of the value in its ASCII lower case equivalent."}, {"sha": "f9a317f663c0b7577294f47ca0261e6806d5b6ef", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -5,7 +5,7 @@ use crate::cmp::*;\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {\n-    ( $( $Tuple:ident( $( $T:ident )+ ) )+ ) => {\n+    ( $( ( $( $T:ident )+ ) )+ ) => {\n         $(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) where last_type!($($T,)+): ?Sized {\n@@ -106,16 +106,16 @@ macro_rules! last_type {\n }\n \n tuple_impls! {\n-    Tuple1(A)\n-    Tuple2(A B)\n-    Tuple3(A B C)\n-    Tuple4(A B C D)\n-    Tuple5(A B C D E)\n-    Tuple6(A B C D E F)\n-    Tuple7(A B C D E F G)\n-    Tuple8(A B C D E F G H)\n-    Tuple9(A B C D E F G H I)\n-    Tuple10(A B C D E F G H I J)\n-    Tuple11(A B C D E F G H I J K)\n-    Tuple12(A B C D E F G H I J K L)\n+    (A)\n+    (A B)\n+    (A B C)\n+    (A B C D)\n+    (A B C D E)\n+    (A B C D E F)\n+    (A B C D E F G)\n+    (A B C D E F G H)\n+    (A B C D E F G H I)\n+    (A B C D E F G H I J)\n+    (A B C D E F G H I J K)\n+    (A B C D E F G H I J K L)\n }"}, {"sha": "628ac3a45ff04d49f6c66e26fad1d77ed4012ea6", "filename": "library/core/tests/alloc.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Ftests%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/library%2Fcore%2Ftests%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Falloc.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -11,3 +11,21 @@ fn const_unchecked_layout() {\n     assert_eq!(LAYOUT.align(), ALIGN);\n     assert_eq!(Some(DANGLING), NonNull::new(ALIGN as *mut u8));\n }\n+\n+#[test]\n+fn layout_debug_shows_log2_of_alignment() {\n+    // `Debug` is not stable, but here's what it does right now\n+    let layout = Layout::from_size_align(24576, 8192).unwrap();\n+    let s = format!(\"{:?}\", layout);\n+    assert_eq!(s, \"Layout { size_: 24576, align_: 8192 (1 << 13) }\");\n+}\n+\n+// Running this normally doesn't do much, but it's also run in Miri, which\n+// will double-check that these are allowed by the validity invariants.\n+#[test]\n+fn layout_accepts_all_valid_alignments() {\n+    for align in 0..usize::BITS {\n+        let layout = Layout::from_size_align(0, 1_usize << align).unwrap();\n+        assert_eq!(layout.align(), 1_usize << align);\n+    }\n+}"}, {"sha": "81200ba60b026ceb3e94536f1451b436e4628d77", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -2065,6 +2065,7 @@ impl Step for Crate {\n     }\n }\n \n+/// Rustdoc is special in various ways, which is why this step is different from `Crate`.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateRustdoc {\n     host: TargetSelection,\n@@ -2092,11 +2093,15 @@ impl Step for CrateRustdoc {\n         let test_kind = self.test_kind;\n         let target = self.host;\n \n-        // Use the previous stage compiler to reuse the artifacts that are\n-        // created when running compiletest for src/test/rustdoc. If this used\n-        // `compiler`, then it would cause rustdoc to be built *again*, which\n-        // isn't really necessary.\n-        let compiler = builder.compiler_for(builder.top_stage, target, target);\n+        let compiler = if builder.config.download_rustc {\n+            builder.compiler(builder.top_stage, target)\n+        } else {\n+            // Use the previous stage compiler to reuse the artifacts that are\n+            // created when running compiletest for src/test/rustdoc. If this used\n+            // `compiler`, then it would cause rustdoc to be built *again*, which\n+            // isn't really necessary.\n+            builder.compiler_for(builder.top_stage, target, target)\n+        };\n         builder.ensure(compile::Rustc { compiler, target });\n \n         let mut cargo = tool::prepare_tool_cargo(\n@@ -2112,6 +2117,15 @@ impl Step for CrateRustdoc {\n         if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n+        match builder.doc_tests {\n+            DocTests::Only => {\n+                cargo.arg(\"--doc\");\n+            }\n+            DocTests::No => {\n+                cargo.args(&[\"--lib\", \"--bins\", \"--examples\", \"--tests\", \"--benches\"]);\n+            }\n+            DocTests::Yes => {}\n+        }\n \n         cargo.arg(\"-p\").arg(\"rustdoc:0.0.0\");\n \n@@ -2136,6 +2150,8 @@ impl Step for CrateRustdoc {\n         // sets up the dylib path for the *host* (stage1/lib), which is the\n         // wrong directory.\n         //\n+        // Recall that we special-cased `compiler_for(top_stage)` above, so we always use stage1.\n+        //\n         // It should be considered to just stop running doctests on\n         // librustdoc. There is only one test, and it doesn't look too\n         // important. There might be other ways to avoid this, but it seems\n@@ -2144,8 +2160,15 @@ impl Step for CrateRustdoc {\n         // See also https://github.com/rust-lang/rust/issues/13983 where the\n         // host vs target dylibs for rustdoc are consistently tricky to deal\n         // with.\n+        //\n+        // Note that this set the host libdir for `download_rustc`, which uses a normal rust distribution.\n+        let libdir = if builder.config.download_rustc {\n+            builder.rustc_libdir(compiler)\n+        } else {\n+            builder.sysroot_libdir(compiler, target).to_path_buf()\n+        };\n         let mut dylib_path = dylib_path();\n-        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n+        dylib_path.insert(0, PathBuf::from(&*libdir));\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n         if !builder.config.verbose_tests {"}, {"sha": "1490314a767884e02ddbca5584d871e42f9ac635", "filename": "src/test/ui/consts/std/alloc.32bit.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -1,14 +1,25 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:8:1\n+  --> $DIR/alloc.rs:9:1\n    |\n-LL | const LAYOUT_INVALID: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_: encountered 0, but expected something greater or equal to 1\n+LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_.0.<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                00 10 00 00 00 00 00 00                         \u2502 ........\n            }\n \n-error: aborting due to previous error\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/alloc.rs:13:1\n+   |\n+LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_.0.<enum-tag>: encountered 0x00000003, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               09 00 00 00 03 00 00 00                         \u2502 ........\n+           }\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "58349feec63d476917c2f8f17ce096b067d445df", "filename": "src/test/ui/consts/std/alloc.64bit.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -1,14 +1,25 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:8:1\n+  --> $DIR/alloc.rs:9:1\n    |\n-LL | const LAYOUT_INVALID: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_: encountered 0, but expected something greater or equal to 1\n+LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_.0.<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n            }\n \n-error: aborting due to previous error\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/alloc.rs:13:1\n+   |\n+LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_.0.<enum-tag>: encountered 0x0000000000000003, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               09 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 \u2502 ................\n+           }\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "708b954e84aeae95b429ef35dc545e2f17152bac", "filename": "src/test/ui/consts/std/alloc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -1,11 +1,16 @@\n // stderr-per-bitwidth\n+// ignore-debug (the debug assertions change the error)\n use std::alloc::Layout;\n \n // ok\n const LAYOUT_VALID: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x08) };\n \n // not ok, since alignment needs to be non-zero.\n-const LAYOUT_INVALID: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+// not ok, since alignment needs to be a power of two.\n+const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n //~^ ERROR it is undefined behavior to use this value\n \n fn main() {}"}, {"sha": "5d9eb55fee0366a96842811bffe0999338d7c129", "filename": "src/test/ui/macros/macro-match-nonterminal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -2,6 +2,8 @@ macro_rules! test {\n     ($a, $b) => {\n         //~^ ERROR missing fragment\n         //~| ERROR missing fragment\n+        //~| ERROR missing fragment\n+        //~| WARN this was previously accepted\n         //~| WARN this was previously accepted\n         ()\n     };"}, {"sha": "48b9bc6ff6ae08000c62785285369b9c9e880bed", "filename": "src/test/ui/macros/macro-match-nonterminal.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.stderr?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -4,15 +4,24 @@ error: missing fragment specifier\n LL |     ($a, $b) => {\n    |        ^\n \n+error: missing fragment specifier\n+  --> $DIR/macro-match-nonterminal.rs:2:8\n+   |\n+LL |     ($a, $b) => {\n+   |        ^\n+   |\n+   = note: `#[deny(missing_fragment_specifier)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #40107 <https://github.com/rust-lang/rust/issues/40107>\n+\n error: missing fragment specifier\n   --> $DIR/macro-match-nonterminal.rs:2:10\n    |\n LL |     ($a, $b) => {\n    |          ^^\n    |\n-   = note: `#[deny(missing_fragment_specifier)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #40107 <https://github.com/rust-lang/rust/issues/40107>\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "c1e6ba7464772144eb9e43aa61772619e4a5b429", "filename": "src/test/ui/macros/macro-missing-fragment-deduplication.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment-deduplication.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment-deduplication.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment-deduplication.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Zdeduplicate-diagnostics=yes\n+\n+macro_rules! m {\n+    ($name) => {}\n+    //~^ ERROR missing fragment\n+    //~| ERROR missing fragment\n+    //~| WARN this was previously accepted\n+}\n+\n+fn main() {\n+    m!();\n+    m!();\n+    m!();\n+    m!();\n+}"}, {"sha": "7622ca054c8ab5bfd12aebfbad97449adf28dfa8", "filename": "src/test/ui/macros/macro-missing-fragment-deduplication.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment-deduplication.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment-deduplication.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment-deduplication.stderr?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -0,0 +1,18 @@\n+error: missing fragment specifier\n+  --> $DIR/macro-missing-fragment-deduplication.rs:4:6\n+   |\n+LL |     ($name) => {}\n+   |      ^^^^^\n+\n+error: missing fragment specifier\n+  --> $DIR/macro-missing-fragment-deduplication.rs:4:6\n+   |\n+LL |     ($name) => {}\n+   |      ^^^^^\n+   |\n+   = note: `#[deny(missing_fragment_specifier)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #40107 <https://github.com/rust-lang/rust/issues/40107>\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "210c85ebbf2f336b53b75778fcb4be84817009d5", "filename": "src/test/ui/macros/macro-missing-fragment.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -1,7 +1,26 @@\n-macro_rules! m {\n-    ( $( any_token $field_rust_type )* ) => {}; //~ ERROR missing fragment\n+#![warn(missing_fragment_specifier)]\n+\n+macro_rules! used_arm {\n+    ( $( any_token $field_rust_type )* ) => {};\n+    //~^ ERROR missing fragment\n+    //~| WARN missing fragment\n+    //~| WARN this was previously accepted\n+}\n+\n+macro_rules! used_macro_unused_arm {\n+    () => {};\n+    ( $name ) => {};\n+    //~^ WARN missing fragment\n+    //~| WARN this was previously accepted\n+}\n+\n+macro_rules! unused_macro {\n+    ( $name ) => {};\n+    //~^ WARN missing fragment\n+    //~| WARN this was previously accepted\n }\n \n fn main() {\n-    m!();\n+    used_arm!();\n+    used_macro_unused_arm!();\n }"}, {"sha": "1bf6f04ec7f14843124c6c0d32c3cc247f64cf08", "filename": "src/test/ui/macros/macro-missing-fragment.stderr", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-missing-fragment.stderr?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -1,8 +1,40 @@\n error: missing fragment specifier\n-  --> $DIR/macro-missing-fragment.rs:2:20\n+  --> $DIR/macro-missing-fragment.rs:4:20\n    |\n LL |     ( $( any_token $field_rust_type )* ) => {};\n    |                    ^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+warning: missing fragment specifier\n+  --> $DIR/macro-missing-fragment.rs:4:20\n+   |\n+LL |     ( $( any_token $field_rust_type )* ) => {};\n+   |                    ^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/macro-missing-fragment.rs:1:9\n+   |\n+LL | #![warn(missing_fragment_specifier)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #40107 <https://github.com/rust-lang/rust/issues/40107>\n+\n+warning: missing fragment specifier\n+  --> $DIR/macro-missing-fragment.rs:12:7\n+   |\n+LL |     ( $name ) => {};\n+   |       ^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #40107 <https://github.com/rust-lang/rust/issues/40107>\n+\n+warning: missing fragment specifier\n+  --> $DIR/macro-missing-fragment.rs:18:7\n+   |\n+LL |     ( $name ) => {};\n+   |       ^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #40107 <https://github.com/rust-lang/rust/issues/40107>\n+\n+error: aborting due to previous error; 3 warnings emitted\n "}, {"sha": "069d181e96267a5ccd32c5e129d68bb3d930f76f", "filename": "src/test/ui/parser/macro/issue-33569.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.rs?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -1,6 +1,8 @@\n macro_rules! foo {\n     { $+ } => { //~ ERROR expected identifier, found `+`\n                 //~^ ERROR missing fragment specifier\n+                //~| ERROR missing fragment specifier\n+                //~| WARN this was previously accepted\n         $(x)(y) //~ ERROR expected one of: `*`, `+`, or `?`\n     }\n }"}, {"sha": "39d49fd03f1bf41b7a8836f0dbe0dff72b0373b7", "filename": "src/test/ui/parser/macro/issue-33569.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8bf93e9b6791acee3a594ed202fdfe45ad9952b5/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.stderr?ref=8bf93e9b6791acee3a594ed202fdfe45ad9952b5", "patch": "@@ -5,7 +5,7 @@ LL |     { $+ } => {\n    |        ^\n \n error: expected one of: `*`, `+`, or `?`\n-  --> $DIR/issue-33569.rs:4:13\n+  --> $DIR/issue-33569.rs:6:13\n    |\n LL |         $(x)(y)\n    |             ^^^\n@@ -16,5 +16,15 @@ error: missing fragment specifier\n LL |     { $+ } => {\n    |        ^\n \n-error: aborting due to 3 previous errors\n+error: missing fragment specifier\n+  --> $DIR/issue-33569.rs:2:8\n+   |\n+LL |     { $+ } => {\n+   |        ^\n+   |\n+   = note: `#[deny(missing_fragment_specifier)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #40107 <https://github.com/rust-lang/rust/issues/40107>\n+\n+error: aborting due to 4 previous errors\n "}]}