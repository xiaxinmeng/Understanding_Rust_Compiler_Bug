{"sha": "a3f0f5107e48d47936a604325a1af325033901d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZjBmNTEwN2U0OGQ0NzkzNmE2MDQzMjVhMWFmMzI1MDMzOTAxZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-03T17:30:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-03T17:30:37Z"}, "message": "Auto merge of #55101 - alexreg:trait-aliases, r=nikomatsakis\n\nImplement trait aliases (RFC 1733)\n\nExtends groundwork done in https://github.com/rust-lang/rust/pull/45047, and fully implements https://github.com/rust-lang/rfcs/pull/1733.\n\nCC @durka @nikomatsakis", "tree": {"sha": "53f0ad160be90667d55a84b30817060bd6a7678d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53f0ad160be90667d55a84b30817060bd6a7678d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3f0f5107e48d47936a604325a1af325033901d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f0f5107e48d47936a604325a1af325033901d0", "html_url": "https://github.com/rust-lang/rust/commit/a3f0f5107e48d47936a604325a1af325033901d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3f0f5107e48d47936a604325a1af325033901d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d28ee3e34d100534062d0bc690779ed9b6927fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d28ee3e34d100534062d0bc690779ed9b6927fe", "html_url": "https://github.com/rust-lang/rust/commit/3d28ee3e34d100534062d0bc690779ed9b6927fe"}, {"sha": "417168587beda80b97e9de83b61cbb8517a61dbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/417168587beda80b97e9de83b61cbb8517a61dbc", "html_url": "https://github.com/rust-lang/rust/commit/417168587beda80b97e9de83b61cbb8517a61dbc"}], "stats": {"total": 963, "additions": 631, "deletions": 332}, "files": [{"sha": "4f2db040160c33b969b0569e1e5bef2c2bcfd177", "filename": "src/doc/unstable-book/src/language-features/trait-alias.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrait-alias.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrait-alias.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrait-alias.md?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,34 @@\n+# `trait_alias`\n+\n+The tracking issue for this feature is: [#41517]\n+\n+[#41417]: https://github.com/rust-lang/rust/issues/41517\n+\n+------------------------\n+\n+The `trait_alias` feature adds support for trait aliases. These allow aliases\n+to be created for one or more traits (currently just a single regular trait plus\n+any number of auto-traits), and used wherever traits would normally be used as\n+either bounds or trait objects.\n+\n+```rust\n+#![feature(trait_alias)]\n+\n+trait Foo = std::fmt::Debug + Send;\n+trait Bar = Foo + Sync;\n+\n+// Use trait alias as bound on type parameter.\n+fn foo<T: Foo>(v: &T) {\n+    println!(\"{:?}\", v);\n+}\n+\n+pub fn main() {\n+    foo(&1);\n+\n+    // Use trait alias for trait objects.\n+    let a: &Bar = &123;\n+    println!(\"{:?}\", a);\n+    let b = Box::new(456) as Box<dyn Foo>;\n+    println!(\"{:?}\", b);\n+}\n+```"}, {"sha": "e558d945516713d2f690d4b698cbadc6a3c6a886", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -4875,23 +4875,24 @@ impl<'a> LoweringContext<'a> {\n         let node = match qpath {\n             hir::QPath::Resolved(None, path) => {\n                 // Turn trait object paths into `TyKind::TraitObject` instead.\n-                if let Def::Trait(_) = path.def {\n-                    let principal = hir::PolyTraitRef {\n-                        bound_generic_params: hir::HirVec::new(),\n-                        trait_ref: hir::TraitRef {\n-                            path: path.and_then(|path| path),\n-                            ref_id: id.node_id,\n-                            hir_ref_id: id.hir_id,\n-                        },\n-                        span,\n-                    };\n+                match path.def {\n+                    Def::Trait(_) | Def::TraitAlias(_) => {\n+                        let principal = hir::PolyTraitRef {\n+                            bound_generic_params: hir::HirVec::new(),\n+                            trait_ref: hir::TraitRef {\n+                                path: path.and_then(|path| path),\n+                                ref_id: id.node_id,\n+                                hir_ref_id: id.hir_id,\n+                            },\n+                            span,\n+                        };\n \n-                    // The original ID is taken by the `PolyTraitRef`,\n-                    // so the `Ty` itself needs a different one.\n-                    id = self.next_id();\n-                    hir::TyKind::TraitObject(hir_vec![principal], self.elided_dyn_bound(span))\n-                } else {\n-                    hir::TyKind::Path(hir::QPath::Resolved(None, path))\n+                        // The original ID is taken by the `PolyTraitRef`,\n+                        // so the `Ty` itself needs a different one.\n+                        id = self.next_id();\n+                        hir::TyKind::TraitObject(hir_vec![principal], self.elided_dyn_bound(span))\n+                    }\n+                    _ => hir::TyKind::Path(hir::QPath::Resolved(None, path)),\n                 }\n             }\n             _ => hir::TyKind::Path(qpath),"}, {"sha": "cf7a7abf95a6c55956d041461c18f04c615dc93d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -301,9 +301,7 @@ impl<'hir> Map<'hir> {\n                     ItemKind::Struct(..) => Some(Def::Struct(def_id())),\n                     ItemKind::Union(..) => Some(Def::Union(def_id())),\n                     ItemKind::Trait(..) => Some(Def::Trait(def_id())),\n-                    ItemKind::TraitAlias(..) => {\n-                        bug!(\"trait aliases are not yet implemented (see issue #41517)\")\n-                    },\n+                    ItemKind::TraitAlias(..) => Some(Def::TraitAlias(def_id())),\n                     ItemKind::ExternCrate(_) |\n                     ItemKind::Use(..) |\n                     ItemKind::ForeignMod(..) |"}, {"sha": "7d25ecedb4e046de7389bc32359f47dbd45dfc5f", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -1118,6 +1118,7 @@ for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n             &VtableClosure(ref table_closure) => table_closure.hash_stable(hcx, hasher),\n             &VtableFnPointer(ref table_fn_pointer) => table_fn_pointer.hash_stable(hcx, hasher),\n             &VtableGenerator(ref table_generator) => table_generator.hash_stable(hcx, hasher),\n+            &VtableTraitAlias(ref table_alias) => table_alias.hash_stable(hcx, hasher),\n         }\n     }\n }\n@@ -1226,6 +1227,22 @@ for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContex\n     }\n }\n \n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableTraitAliasData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableTraitAliasData {\n+            alias_def_id,\n+            substs,\n+            ref nested,\n+        } = *self;\n+        alias_def_id.hash_stable(hcx, hasher);\n+        substs.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl_stable_hash_for!(\n     impl<'tcx, V> for struct infer::canonical::Canonical<'tcx, V> {\n         max_universe, variables, value"}, {"sha": "a387765085a29c940362c952c719d12a8214f17f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -447,6 +447,17 @@ fn krate<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> NamedRegionMap {\n     map\n }\n \n+/// In traits, there is an implicit `Self` type parameter which comes before the generics.\n+/// We have to account for this when computing the index of the other generic parameters.\n+/// This function returns whether there is such an implicit parameter defined on the given item.\n+fn sub_items_have_self_param(node: &hir::ItemKind) -> bool {\n+    match *node {\n+        hir::ItemKind::Trait(..) |\n+        hir::ItemKind::TraitAlias(..) => true,\n+        _ => false,\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir)\n@@ -522,8 +533,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir::ItemKind::Impl(..) => true,\n                     _ => false,\n                 };\n-                // These kinds of items have only early bound lifetime parameters.\n-                let mut index = if let hir::ItemKind::Trait(..) = item.node {\n+                // These kinds of items have only early-bound lifetime parameters.\n+                let mut index = if sub_items_have_self_param(&item.node) {\n                     1 // Self comes before lifetimes\n                 } else {\n                     0\n@@ -1602,8 +1613,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n             let parent = self.tcx.hir.expect_item(parent_id);\n-            if let hir::ItemKind::Trait(..) = parent.node {\n-                index += 1; // Self comes first.\n+            if sub_items_have_self_param(&parent.node) {\n+                index += 1; // Self comes before lifetimes\n             }\n             match parent.node {\n                 hir::ItemKind::Trait(_, _, ref generics, ..)"}, {"sha": "b7512790bfb6913414c2e4d34c618b56c9012f19", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -534,8 +534,11 @@ pub enum Vtable<'tcx, N> {\n     /// Same as above, but for a fn pointer type with the given signature.\n     VtableFnPointer(VtableFnPointerData<'tcx, N>),\n \n-    /// Vtable automatically generated for a generator\n+    /// Vtable automatically generated for a generator.\n     VtableGenerator(VtableGeneratorData<'tcx, N>),\n+\n+    /// Vtable for a trait alias.\n+    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n }\n \n /// Identifies a particular impl in the source, along with a set of\n@@ -605,6 +608,13 @@ pub struct VtableFnPointerData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+pub struct VtableTraitAliasData<'tcx, N> {\n+    pub alias_def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n+    pub nested: Vec<N>,\n+}\n+\n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      param_env: ty::ParamEnv<'tcx>,\n@@ -1067,6 +1077,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableGenerator(c) => c.nested,\n             VtableObject(d) => d.nested,\n             VtableFnPointer(d) => d.nested,\n+            VtableTraitAlias(d) => d.nested,\n         }\n     }\n \n@@ -1090,20 +1101,25 @@ impl<'tcx, N> Vtable<'tcx, N> {\n                 trait_def_id: d.trait_def_id,\n                 nested: d.nested.into_iter().map(f).collect(),\n             }),\n-            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n-                fn_ty: p.fn_ty,\n-                nested: p.nested.into_iter().map(f).collect(),\n+            VtableClosure(c) => VtableClosure(VtableClosureData {\n+                closure_def_id: c.closure_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n             }),\n             VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n                 generator_def_id: c.generator_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n-            VtableClosure(c) => VtableClosure(VtableClosureData {\n-                closure_def_id: c.closure_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            })\n+            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n+                fn_ty: p.fn_ty,\n+                nested: p.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n+                alias_def_id: d.alias_def_id,\n+                substs: d.substs,\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n         }\n     }\n }"}, {"sha": "a388c7eeb7e49ede897bbe130ffc07ffd4071d93", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -19,10 +19,7 @@ use super::PredicateObligation;\n use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n-use super::VtableClosureData;\n-use super::VtableGeneratorData;\n-use super::VtableFnPointerData;\n-use super::VtableImplData;\n+use super::{VtableImplData, VtableClosureData, VtableGeneratorData, VtableFnPointerData};\n use super::util;\n \n use hir::def_id::DefId;\n@@ -1073,7 +1070,8 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n             super::VtableClosure(_) |\n             super::VtableGenerator(_) |\n             super::VtableFnPointer(_) |\n-            super::VtableObject(_) => {\n+            super::VtableObject(_) |\n+            super::VtableTraitAlias(_) => {\n                 debug!(\"assemble_candidates_from_impls: vtable={:?}\",\n                        vtable);\n                 true\n@@ -1235,7 +1233,8 @@ fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n             confirm_object_candidate(selcx, obligation, obligation_trait_ref),\n         super::VtableAutoImpl(..) |\n         super::VtableParam(..) |\n-        super::VtableBuiltin(..) =>\n+        super::VtableBuiltin(..) |\n+        super::VtableTraitAlias(..) =>\n             // we don't create Select candidates with this kind of resolution\n             span_bug!(\n                 obligation.cause.span,\n@@ -1486,7 +1485,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n     -> Progress<'tcx>\n {\n-    let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n+    let VtableImplData { impl_def_id, substs, nested } = impl_vtable;\n \n     let tcx = selcx.tcx();\n     let param_env = obligation.param_env;"}, {"sha": "312cd66dcc75c229b78b1d9d7a4d2b537b7eb55b", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 107, "deletions": 37, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -30,11 +30,11 @@ use super::{ObligationCause, PredicateObligation, TraitObligation};\n use super::{OutputTypeParameterMismatch, Overflow, SelectionError, Unimplemented};\n use super::{\n     VtableAutoImpl, VtableBuiltin, VtableClosure, VtableFnPointer, VtableGenerator, VtableImpl,\n-    VtableObject, VtableParam,\n+    VtableObject, VtableParam, VtableTraitAlias,\n };\n use super::{\n     VtableAutoImplData, VtableBuiltinData, VtableClosureData, VtableFnPointerData,\n-    VtableGeneratorData, VtableImplData, VtableObjectData,\n+    VtableGeneratorData, VtableImplData, VtableObjectData, VtableTraitAliasData,\n };\n \n use dep_graph::{DepKind, DepNodeIndex};\n@@ -271,6 +271,8 @@ enum SelectionCandidate<'tcx> {\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n     FnPointerCandidate,\n \n+    TraitAliasCandidate(DefId),\n+\n     ObjectCandidate,\n \n     BuiltinObjectCandidate,\n@@ -286,12 +288,13 @@ impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n             ImplCandidate(def_id) => ImplCandidate(def_id),\n             AutoImplCandidate(def_id) => AutoImplCandidate(def_id),\n             ProjectionCandidate => ProjectionCandidate,\n+            ClosureCandidate => ClosureCandidate,\n+            GeneratorCandidate => GeneratorCandidate,\n             FnPointerCandidate => FnPointerCandidate,\n+            TraitAliasCandidate(def_id) => TraitAliasCandidate(def_id),\n             ObjectCandidate => ObjectCandidate,\n             BuiltinObjectCandidate => BuiltinObjectCandidate,\n             BuiltinUnsizeCandidate => BuiltinUnsizeCandidate,\n-            ClosureCandidate => ClosureCandidate,\n-            GeneratorCandidate => GeneratorCandidate,\n \n             ParamCandidate(ref trait_ref) => {\n                 return tcx.lift(trait_ref).map(ParamCandidate);\n@@ -1452,7 +1455,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let predicate = self.infcx()\n             .resolve_type_vars_if_possible(&obligation.predicate);\n \n-        // ok to skip binder because of the nature of the\n+        // OK to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n         // bound regions\n         let trait_ref = predicate.skip_binder().trait_ref;\n@@ -1632,6 +1635,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ambiguous: false,\n         };\n \n+        self.assemble_candidates_for_trait_alias(obligation, &mut candidates)?;\n+\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n         let def_id = obligation.predicate.def_id();\n@@ -1879,7 +1884,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(());\n         }\n \n-        // ok to skip binder because the substs on generator types never\n+        // OK to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         let self_ty = *obligation.self_ty().skip_binder();\n@@ -1923,7 +1928,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n         };\n \n-        // ok to skip binder because the substs on closure types never\n+        // OK to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         match obligation.self_ty().skip_binder().sty {\n@@ -1973,7 +1978,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(());\n         }\n \n-        // ok to skip binder because what we are inspecting doesn't involve bound regions\n+        // OK to skip binder because what we are inspecting doesn't involve bound regions\n         let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n             ty::Infer(ty::TyVar(_)) => {\n@@ -2238,6 +2243,24 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn assemble_candidates_for_trait_alias(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) -> Result<(), SelectionError<'tcx>> {\n+        // OK to skip binder here because the tests we do below do not involve bound regions\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        debug!(\"assemble_candidates_for_trait_alias(self_ty={:?})\", self_ty);\n+\n+        let def_id = obligation.predicate.def_id();\n+\n+        if ty::is_trait_alias(self.tcx(), def_id) {\n+            candidates.vec.push(TraitAliasCandidate(def_id.clone()));\n+        }\n+\n+        Ok(())\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // WINNOW\n     //\n@@ -2288,7 +2311,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n-                | BuiltinCandidate { .. } => {\n+                | BuiltinCandidate { .. }\n+                | TraitAliasCandidate(..) => {\n                     // Global bounds from the where clause should be ignored\n                     // here (see issue #50825). Otherwise, we have a where\n                     // clause so don't go around looking for impls.\n@@ -2318,7 +2342,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n-                | BuiltinCandidate { .. } => true,\n+                | BuiltinCandidate { .. }\n+                | TraitAliasCandidate(..) => true,\n                 ObjectCandidate | ProjectionCandidate => {\n                     // Arbitrarily give param candidates priority\n                     // over projection and object candidates.\n@@ -2712,15 +2737,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ok(VtableParam(obligations))\n             }\n \n+            ImplCandidate(impl_def_id) => Ok(VtableImpl(self.confirm_impl_candidate(\n+                obligation,\n+                impl_def_id,\n+            ))),\n+\n             AutoImplCandidate(trait_def_id) => {\n                 let data = self.confirm_auto_impl_candidate(obligation, trait_def_id);\n                 Ok(VtableAutoImpl(data))\n             }\n \n-            ImplCandidate(impl_def_id) => Ok(VtableImpl(self.confirm_impl_candidate(\n-                obligation,\n-                impl_def_id,\n-            ))),\n+            ProjectionCandidate => {\n+                self.confirm_projection_candidate(obligation);\n+                Ok(VtableParam(Vec::new()))\n+            }\n \n             ClosureCandidate => {\n                 let vtable_closure = self.confirm_closure_candidate(obligation)?;\n@@ -2732,27 +2762,27 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ok(VtableGenerator(vtable_generator))\n             }\n \n-            BuiltinObjectCandidate => {\n-                // This indicates something like `(Trait+Send) :\n-                // Send`. In this case, we know that this holds\n-                // because that's what the object type is telling us,\n-                // and there's really no additional obligations to\n-                // prove and no types in particular to unify etc.\n-                Ok(VtableParam(Vec::new()))\n+            FnPointerCandidate => {\n+                let data = self.confirm_fn_pointer_candidate(obligation)?;\n+                Ok(VtableFnPointer(data))\n+            }\n+\n+            TraitAliasCandidate(alias_def_id) => {\n+                let data = self.confirm_trait_alias_candidate(obligation, alias_def_id);\n+                Ok(VtableTraitAlias(data))\n             }\n \n             ObjectCandidate => {\n                 let data = self.confirm_object_candidate(obligation);\n                 Ok(VtableObject(data))\n             }\n \n-            FnPointerCandidate => {\n-                let data = self.confirm_fn_pointer_candidate(obligation)?;\n-                Ok(VtableFnPointer(data))\n-            }\n-\n-            ProjectionCandidate => {\n-                self.confirm_projection_candidate(obligation);\n+            BuiltinObjectCandidate => {\n+                // This indicates something like `(Trait+Send) :\n+                // Send`. In this case, we know that this holds\n+                // because that's what the object type is telling us,\n+                // and there's really no additional obligations to\n+                // prove and no types in particular to unify etc.\n                 Ok(VtableParam(Vec::new()))\n             }\n \n@@ -2865,7 +2895,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.vtable_auto_impl(obligation, trait_def_id, types)\n     }\n \n-    /// See `confirm_auto_impl_candidate`\n+    /// See `confirm_auto_impl_candidate`.\n     fn vtable_auto_impl(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -2922,7 +2952,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // this time not in a probe.\n         self.in_snapshot(|this, snapshot| {\n             let (substs, placeholder_map) = this.rematch_impl(impl_def_id, obligation, snapshot);\n-            debug!(\"confirm_impl_candidate substs={:?}\", substs);\n+            debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.vtable_impl(\n                 impl_def_id,\n@@ -2986,10 +3016,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) -> VtableObjectData<'tcx, PredicateObligation<'tcx>> {\n         debug!(\"confirm_object_candidate({:?})\", obligation);\n \n-        // FIXME skipping binder here seems wrong -- we should\n-        // probably flatten the binder from the obligation and the\n-        // binder from the object. Have to try to make a broken test\n-        // case that results. -nmatsakis\n+        // FIXME(nmatsakis) skipping binder here seems wrong -- we should\n+        // probably flatten the binder from the obligation and the binder\n+        // from the object. Have to try to make a broken test case that\n+        // results.\n         let self_ty = self.infcx\n             .shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n@@ -3041,7 +3071,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) -> Result<VtableFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n \n-        // ok to skip binder; it is reintroduced below\n+        // OK to skip binder; it is reintroduced below\n         let self_ty = self.infcx\n             .shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig(self.tcx());\n@@ -3077,11 +3107,51 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         })\n     }\n \n+    fn confirm_trait_alias_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        alias_def_id: DefId,\n+    ) -> VtableTraitAliasData<'tcx, PredicateObligation<'tcx>> {\n+        debug!(\n+            \"confirm_trait_alias_candidate({:?}, {:?})\",\n+            obligation, alias_def_id\n+        );\n+\n+        self.in_snapshot(|this, snapshot| {\n+            let (predicate, placeholder_map) = this.infcx()\n+                .replace_late_bound_regions_with_placeholders(&obligation.predicate);\n+            let trait_ref = predicate.trait_ref;\n+            let trait_def_id = trait_ref.def_id;\n+            let substs = trait_ref.substs;\n+\n+            let trait_obligations = this.impl_or_trait_obligations(\n+                obligation.cause.clone(),\n+                obligation.recursion_depth,\n+                obligation.param_env,\n+                trait_def_id,\n+                &substs,\n+                placeholder_map,\n+                snapshot,\n+            );\n+\n+            debug!(\n+                \"confirm_trait_alias_candidate: trait_def_id={:?} trait_obligations={:?}\",\n+                trait_def_id, trait_obligations\n+            );\n+\n+            VtableTraitAliasData {\n+                alias_def_id,\n+                substs: substs,\n+                nested: trait_obligations,\n+            }\n+        })\n+    }\n+\n     fn confirm_generator_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        // ok to skip binder because the substs on generator types never\n+        // OK to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         let self_ty = self.infcx\n@@ -3139,7 +3209,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .fn_trait_kind(obligation.predicate.def_id())\n             .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n \n-        // ok to skip binder because the substs on closure types never\n+        // OK to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         let self_ty = self.infcx"}, {"sha": "e83d085971caa32ef52c6b2fbab491d53c5cc58d", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -62,6 +62,8 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n             super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n \n             super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableTraitAlias(ref d) => write!(f, \"{:?}\", d),\n         }\n     }\n }\n@@ -70,7 +72,7 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"VtableImplData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n             self.impl_def_id, self.substs, self.nested\n         )\n     }\n@@ -80,7 +82,7 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableGenerator(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"VtableGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n             self.generator_def_id, self.substs, self.nested\n         )\n     }\n@@ -90,15 +92,15 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"VtableClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n             self.closure_def_id, self.substs, self.nested\n         )\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableBuiltin(nested={:?})\", self.nested)\n+        write!(f, \"VtableBuiltinData(nested={:?})\", self.nested)\n     }\n }\n \n@@ -116,7 +118,7 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableObject(upcast={:?}, vtable_base={}, nested={:?})\",\n+            \"VtableObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n             self.upcast_trait_ref, self.vtable_base, self.nested\n         )\n     }\n@@ -126,12 +128,22 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"VtableFnPointer(fn_ty={:?}, nested={:?})\",\n+            \"VtableFnPointerData(fn_ty={:?}, nested={:?})\",\n             self.fn_ty, self.nested\n         )\n     }\n }\n \n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableTraitAliasData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.alias_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n impl<'tcx> fmt::Debug for traits::FulfillmentError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"FulfillmentError({:?},{:?})\", self.obligation, self.code)\n@@ -321,6 +333,17 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                     nested,\n                 })\n             ),\n+            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                alias_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs|\n+                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                    alias_def_id,\n+                    substs,\n+                    nested,\n+                })\n+            ),\n         }\n     }\n }\n@@ -386,6 +409,12 @@ BraceStructTypeFoldableImpl! {\n     } where N: TypeFoldable<'tcx>\n }\n \n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableTraitAliasData<'tcx, N> {\n+        alias_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n+}\n+\n EnumTypeFoldableImpl! {\n     impl<'tcx, N> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n         (traits::VtableImpl)(a),\n@@ -396,6 +425,7 @@ EnumTypeFoldableImpl! {\n         (traits::VtableParam)(a),\n         (traits::VtableBuiltin)(a),\n         (traits::VtableObject)(a),\n+        (traits::VtableTraitAlias)(a),\n     } where N: TypeFoldable<'tcx>\n }\n "}, {"sha": "74f8d67ce04846a97c309a0573037530a4b98225", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -333,7 +333,7 @@ impl<I> FilterToTraits<I> {\n     }\n }\n \n-impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n+impl<'tcx,I:Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {"}, {"sha": "b6691df39c120ccebeee7eef6692e609802447ab", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -400,7 +400,9 @@ fn resolve_associated_item<'a, 'tcx>(\n                 None\n             }\n         }\n-        traits::VtableAutoImpl(..) | traits::VtableParam(..) => None\n+        traits::VtableAutoImpl(..) |\n+        traits::VtableParam(..) |\n+        traits::VtableTraitAlias(..) => None\n     }\n }\n "}, {"sha": "c7c197d11c03beb112b95d85933d45b9d6acc1ef", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -1046,24 +1046,24 @@ pub enum Predicate<'tcx> {\n     /// would be the type parameters.\n     Trait(PolyTraitPredicate<'tcx>),\n \n-    /// where 'a : 'b\n+    /// where `'a : 'b`\n     RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n \n-    /// where T : 'a\n+    /// where `T : 'a`\n     TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n \n-    /// where <T as TraitRef>::Name == X, approximately.\n-    /// See `ProjectionPredicate` struct for details.\n+    /// where `<T as TraitRef>::Name == X`, approximately.\n+    /// See the `ProjectionPredicate` struct for details.\n     Projection(PolyProjectionPredicate<'tcx>),\n \n-    /// no syntax: T WF\n+    /// no syntax: `T` well-formed\n     WellFormed(Ty<'tcx>),\n \n     /// trait must be object-safe\n     ObjectSafe(DefId),\n \n     /// No direct syntax. May be thought of as `where T : FnFoo<...>`\n-    /// for some substitutions `...` and T being a closure type.\n+    /// for some substitutions `...` and `T` being a closure type.\n     /// Satisfied (or refuted) once we know the closure's kind.\n     ClosureKind(DefId, ClosureSubsts<'tcx>, ClosureKind),\n \n@@ -2797,7 +2797,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Determine whether an item is annotated with an attribute\n+    /// Determine whether an item is annotated with an attribute.\n     pub fn has_attr(self, did: DefId, attr: &str) -> bool {\n         attr::contains_name(&self.get_attrs(did), attr)\n     }\n@@ -2811,14 +2811,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.optimized_mir(def_id).generator_layout.as_ref().unwrap()\n     }\n \n-    /// Given the def_id of an impl, return the def_id of the trait it implements.\n+    /// Given the def-id of an impl, return the def_id of the trait it implements.\n     /// If it implements no trait, return `None`.\n     pub fn trait_id_of_impl(self, def_id: DefId) -> Option<DefId> {\n         self.impl_trait_ref(def_id).map(|tr| tr.def_id)\n     }\n \n-    /// If the given def ID describes a method belonging to an impl, return the\n-    /// ID of the impl that the method belongs to. Otherwise, return `None`.\n+    /// If the given defid describes a method belonging to an impl, return the\n+    /// def-id of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         let item = if def_id.krate != LOCAL_CRATE {\n             if let Some(Def::Method(_)) = self.describe_def(def_id) {\n@@ -2983,7 +2983,7 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n         })\n }\n \n-/// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition\n+/// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefId> {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         if let Node::Item(item) = tcx.hir.get(node_id) {\n@@ -2995,7 +2995,19 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefI\n     None\n }\n \n-/// See `ParamEnv` struct def'n for details.\n+/// Returns `true` if `def_id` is a trait alias.\n+pub fn is_trait_alias(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> bool {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+        if let Node::Item(item) = tcx.hir.get(node_id) {\n+            if let hir::ItemKind::TraitAlias(..) = item.node {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// See `ParamEnv` struct definition for details.\n fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        def_id: DefId)\n                        -> ParamEnv<'tcx>"}, {"sha": "28b58d62175bc21f270ef57a38d478c2df832c54", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -650,7 +650,7 @@ impl<'tcx> TraitRef<'tcx> {\n         TraitRef { def_id: def_id, substs: substs }\n     }\n \n-    /// Returns a TraitRef of the form `P0: Foo<P1..Pn>` where `Pi`\n+    /// Returns a `TraitRef` of the form `P0: Foo<P1..Pn>` where `Pi`\n     /// are the parameters defined on trait.\n     pub fn identity<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> TraitRef<'tcx> {\n         TraitRef {"}, {"sha": "9ba5bf9add110292760dd536f0b43b1157632aa5", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -527,7 +527,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n     }\n \n-    /// True if `def_id` refers to a trait (e.g., `trait Foo { ... }`).\n+    /// True if `def_id` refers to a trait (i.e., `trait Foo { ... }`).\n     pub fn is_trait(self, def_id: DefId) -> bool {\n         if let DefPathData::Trait(_) = self.def_key(def_id).disambiguated_data.data {\n             true"}, {"sha": "61861da62f759134b1c6858ab4167d169b70453c", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -403,25 +403,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     }\n                 }\n             }\n-            ItemKind::TraitAlias(Generics { ref params, .. }, ..) => {\n-                for param in params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {}\n-                        GenericParamKind::Type { ref default, .. } => {\n-                            if !param.bounds.is_empty() {\n-                                self.err_handler()\n-                                    .span_err(param.ident.span, \"type parameters on the left \\\n-                                        side of a trait alias cannot be bounded\");\n-                            }\n-                            if !default.is_none() {\n-                                self.err_handler()\n-                                    .span_err(param.ident.span, \"type parameters on the left \\\n-                                        side of a trait alias cannot have defaults\");\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n                 attr::first_attr_value_str_by_name(&item.attrs, \"path\");"}, {"sha": "17ca8c275c3cb39e48c20be846f1914f11e09f10", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -538,9 +538,9 @@ impl<'a> PathSource<'a> {\n         match self {\n             PathSource::Type => match def {\n                 Def::Struct(..) | Def::Union(..) | Def::Enum(..) |\n-                Def::Trait(..) | Def::TyAlias(..) | Def::AssociatedTy(..) |\n-                Def::PrimTy(..) | Def::TyParam(..) | Def::SelfTy(..) |\n-                Def::Existential(..) |\n+                Def::Trait(..) | Def::TraitAlias(..) | Def::TyAlias(..) |\n+                Def::AssociatedTy(..) | Def::PrimTy(..) | Def::TyParam(..) |\n+                Def::SelfTy(..) | Def::Existential(..) |\n                 Def::ForeignTy(..) => true,\n                 _ => false,\n             },\n@@ -3122,7 +3122,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                         return (err, candidates);\n                     }\n                     (Def::TyAlias(..), PathSource::Trait(_)) => {\n-                        err.span_label(span, \"type aliases cannot be used for traits\");\n+                        err.span_label(span, \"type aliases cannot be used as traits\");\n+                        if nightly_options::is_nightly_build() {\n+                            err.note(\"did you mean to use a trait alias?\");\n+                        }\n                         return (err, candidates);\n                     }\n                     (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n@@ -3888,15 +3891,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             // report an error.\n                             if record_used {\n                                 resolve_error(self, span,\n-                                        ResolutionError::CannotCaptureDynamicEnvironmentInFnItem);\n+                                    ResolutionError::CannotCaptureDynamicEnvironmentInFnItem);\n                             }\n                             return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n                             if record_used {\n                                 resolve_error(self, span,\n-                                        ResolutionError::AttemptToUseNonConstantValueInConstant);\n+                                    ResolutionError::AttemptToUseNonConstantValueInConstant);\n                             }\n                             return Def::Err;\n                         }"}, {"sha": "18f8473b5b56d7d88fb600878aaa16ff8fbbe0b3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Conversion from AST representation of types to the ty.rs\n+//! Conversion from AST representation of types to the `ty.rs`\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n //! is parameterized by an instance of `AstConv`.\n \n@@ -181,7 +181,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         item_segment: &hir::PathSegment)\n         -> &'tcx Substs<'tcx>\n     {\n-\n         let (substs, assoc_bindings) = item_segment.with_generic_args(|generic_args| {\n             self.create_substs_for_ast_path(\n                 span,\n@@ -545,7 +544,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     }\n \n     /// Given the type/region arguments provided to some path (along with\n-    /// an implicit Self, if this is a trait reference) returns the complete\n+    /// an implicit `Self`, if this is a trait reference) returns the complete\n     /// set of substitutions. This may involve applying defaulted type parameters.\n     ///\n     /// Note that the type listing given here is *exactly* what the user provided.\n@@ -722,7 +721,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     {\n         let trait_def_id = self.trait_def_id(trait_ref);\n \n-        debug!(\"ast_path_to_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n+        debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n@@ -739,11 +738,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             let predicate: Result<_, ErrorReported> =\n                 self.ast_type_binding_to_poly_projection_predicate(\n                     trait_ref.ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n-            // ok to ignore Err() because ErrorReported (see above)\n+            // ok to ignore Err because ErrorReported (see above)\n             Some((predicate.ok()?, binding.span))\n         }));\n \n-        debug!(\"ast_path_to_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n+        debug!(\"instantiate_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n                trait_ref, poly_projections, poly_trait_ref);\n         poly_trait_ref\n     }\n@@ -948,8 +947,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         )\n     }\n \n-    /// Transform a PolyTraitRef into a PolyExistentialTraitRef by\n-    /// removing the dummy Self type (TRAIT_OBJECT_DUMMY_SELF).\n+    /// Transform a `PolyTraitRef` into a `PolyExistentialTraitRef` by\n+    /// removing the dummy `Self` type (`TRAIT_OBJECT_DUMMY_SELF`).\n     fn trait_ref_to_existential(&self, trait_ref: ty::TraitRef<'tcx>)\n                                 -> ty::ExistentialTraitRef<'tcx> {\n         assert_eq!(trait_ref.self_ty().sty, TRAIT_OBJECT_DUMMY_SELF);\n@@ -975,9 +974,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let principal = self.instantiate_poly_trait_ref(&trait_bounds[0],\n                                                         dummy_self,\n                                                         &mut projection_bounds);\n+        debug!(\"principal: {:?}\", principal);\n \n         for trait_bound in trait_bounds[1..].iter() {\n-            // Sanity check for non-principal trait bounds\n+            // sanity check for non-principal trait bounds\n             self.instantiate_poly_trait_ref(trait_bound,\n                                             dummy_self,\n                                             &mut vec![]);\n@@ -1009,9 +1009,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             })\n         });\n \n-        // check that there are no gross object safety violations,\n+        // Check that there are no gross object safety violations;\n         // most importantly, that the supertraits don't contain Self,\n-        // to avoid ICE-s.\n+        // to avoid ICEs.\n         let object_safety_violations =\n             tcx.global_tcx().astconv_object_safety_violations(principal.def_id());\n         if !object_safety_violations.is_empty() {\n@@ -1021,7 +1021,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        // use a btreeset to keep output in a more consistent order\n+        // Use a BTreeSet to keep output in a more consistent order.\n         let mut associated_types = BTreeSet::default();\n \n         for tr in traits::supertraits(tcx, principal) {\n@@ -1060,7 +1060,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         v.sort_by(|a, b| a.stable_cmp(tcx, b));\n         let existential_predicates = ty::Binder::bind(tcx.mk_existential_predicates(v.into_iter()));\n \n-        // Explicitly specified region bound. Use that.\n+        // Use explicitly-specified region bound.\n         let region_bound = if !lifetime.is_elided() {\n             self.ast_region_to_region(lifetime, None)\n         } else {\n@@ -1347,7 +1347,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         err.span_label(span, \"associated type not allowed here\").emit();\n     }\n \n-    // Check a type Path and convert it to a Ty.\n+    // Check a type `Path` and convert it to a `Ty`.\n     pub fn def_to_ty(&self,\n                      opt_self_ty: Option<Ty<'tcx>>,\n                      path: &hir::Path,\n@@ -1442,8 +1442,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     /// Parses the programmer's textual representation of a type into our\n     /// internal notion of a type.\n     pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n-        debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?})\",\n-               ast_ty.id, ast_ty);\n+        debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?} ty_ty={:?})\",\n+               ast_ty.id, ast_ty, ast_ty.node);\n \n         let tcx = self.tcx();\n "}, {"sha": "527ba276de2732556ea7c4211facc15e06a6db0e", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -153,6 +153,9 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n         hir::ItemKind::Trait(..) => {\n             check_trait(tcx, item);\n         }\n+        hir::ItemKind::TraitAlias(..) => {\n+            check_trait(tcx, item);\n+        }\n         _ => {}\n     }\n }"}, {"sha": "74dea7fe411ad0e710a016afd5fabc6bb39089e3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -58,6 +58,8 @@ use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n use std::iter;\n \n+struct OnlySelfBounds(bool);\n+\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n@@ -245,8 +247,8 @@ fn type_param_predicates<'a, 'tcx>(\n     use rustc::hir::*;\n \n     // In the AST, bounds can derive from two places. Either\n-    // written inline like `<T:Foo>` or in a where clause like\n-    // `where T:Foo`.\n+    // written inline like `<T : Foo>` or in a where clause like\n+    // `where T : Foo`.\n \n     let param_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let param_owner = tcx.hir.ty_param_owner(param_id);\n@@ -317,12 +319,13 @@ fn type_param_predicates<'a, 'tcx>(\n     let icx = ItemCtxt::new(tcx, item_def_id);\n     result\n         .predicates\n-        .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty));\n+        .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty,\n+            OnlySelfBounds(true)));\n     result\n }\n \n impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n-    /// Find bounds from hir::Generics. This requires scanning through the\n+    /// Find bounds from `hir::Generics`. This requires scanning through the\n     /// AST. We do this to avoid having to convert *all* the bounds, which\n     /// would create artificial cycles. Instead we can only convert the\n     /// bounds for a type parameter `X` if `X::Foo` is used.\n@@ -331,6 +334,7 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n         ast_generics: &hir::Generics,\n         param_id: ast::NodeId,\n         ty: Ty<'tcx>,\n+        only_self_bounds: OnlySelfBounds,\n     ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n         let from_ty_params = ast_generics\n             .params\n@@ -350,9 +354,17 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n                 hir::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n                 _ => None,\n             })\n-            .filter(|bp| is_param(self.tcx, &bp.bounded_ty, param_id))\n-            .flat_map(|bp| bp.bounds.iter())\n-            .flat_map(|b| predicates_from_bound(self, ty, b));\n+            .flat_map(|bp| {\n+                let bt = if is_param(self.tcx, &bp.bounded_ty, param_id) {\n+                    Some(ty)\n+                } else if !only_self_bounds.0 {\n+                    Some(self.to_ty(&bp.bounded_ty))\n+                } else {\n+                    None\n+                };\n+                bp.bounds.iter().filter_map(move |b| bt.map(|bt| (bt, b)))\n+            })\n+            .flat_map(|(bt, b)| predicates_from_bound(self, bt, b));\n \n         from_ty_params.chain(from_where_clauses).collect()\n     }\n@@ -419,12 +431,9 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n             tcx.predicates_of(def_id);\n         }\n         hir::ItemKind::TraitAlias(..) => {\n-            span_err!(\n-                tcx.sess,\n-                it.span,\n-                E0645,\n-                \"trait aliases are not yet implemented (see issue #41517)\"\n-            );\n+            tcx.generics_of(def_id);\n+            tcx.at(it.span).super_predicates_of(def_id);\n+            tcx.predicates_of(def_id);\n         }\n         hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n             tcx.generics_of(def_id);\n@@ -693,22 +702,28 @@ fn super_predicates_of<'a, 'tcx>(\n \n     let icx = ItemCtxt::new(tcx, trait_def_id);\n \n-    // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n+    // Convert the bounds that follow the colon, e.g. `Bar + Zed` in `trait Foo : Bar + Zed`.\n     let self_param_ty = tcx.mk_self_type();\n     let superbounds1 = compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n \n     let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n \n     // Convert any explicit superbounds in the where clause,\n-    // e.g. `trait Foo where Self : Bar`:\n-    let superbounds2 = icx.type_parameter_bounds_in_generics(generics, item.id, self_param_ty);\n+    // e.g. `trait Foo where Self : Bar`.\n+    // In the case of trait aliases, however, we include all bounds in the where clause,\n+    // so e.g. `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n+    // as one of its \"superpredicates\".\n+    let is_trait_alias = ty::is_trait_alias(tcx, trait_def_id);\n+    let superbounds2 = icx.type_parameter_bounds_in_generics(\n+        generics, item.id, self_param_ty, OnlySelfBounds(!is_trait_alias));\n \n     // Combine the two lists to form the complete set of superbounds:\n     let superbounds: Vec<_> = superbounds1.into_iter().chain(superbounds2).collect();\n \n     // Now require that immediate supertraits are converted,\n     // which will, in turn, reach indirect supertraits.\n     for &(pred, span) in &superbounds {\n+        debug!(\"superbound: {:?}\", pred);\n         if let ty::Predicate::Trait(bound) = pred {\n             tcx.at(span).super_predicates_of(bound.def_id());\n         }\n@@ -1678,6 +1693,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n \n     let icx = ItemCtxt::new(tcx, def_id);\n     let no_generics = hir::Generics::empty();\n+    let empty_trait_items = HirVec::new();\n \n     let mut predicates = UniquePredicates::new();\n \n@@ -1722,6 +1738,10 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     is_trait = Some((ty::TraitRef::identity(tcx, def_id), items));\n                     generics\n                 }\n+                ItemKind::TraitAlias(ref generics, _) => {\n+                    is_trait = Some((ty::TraitRef::identity(tcx, def_id), &empty_trait_items));\n+                    generics\n+                }\n                 ItemKind::Existential(ExistTy {\n                     ref bounds,\n                     impl_trait_fn,\n@@ -2010,10 +2030,10 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n     }\n }\n \n-/// Converts a specific GenericBound from the AST into a set of\n+/// Converts a specific `GenericBound` from the AST into a set of\n /// predicates that apply to the self-type. A vector is returned\n-/// because this can be anywhere from 0 predicates (`T:?Sized` adds no\n-/// predicates) to 1 (`T:Foo`) to many (`T:Bar<X=i32>` adds `T:Bar`\n+/// because this can be anywhere from zero predicates (`T : ?Sized` adds no\n+/// predicates) to one (`T : Foo`) to many (`T : Bar<X=i32>` adds `T : Bar`\n /// and `<T as Bar>::X == i32`).\n fn predicates_from_bound<'tcx>(\n     astconv: &dyn AstConv<'tcx, 'tcx>,"}, {"sha": "cfedda18a7e22886e2e972cc30d82a36157976a5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -288,9 +288,9 @@ pub enum TraitBoundModifier {\n }\n \n /// The AST represents all type param bounds as types.\n-/// typeck::collect::compute_bounds matches these against\n-/// the \"special\" built-in traits (see middle::lang_items) and\n-/// detects Copy, Send and Sync.\n+/// `typeck::collect::compute_bounds` matches these against\n+/// the \"special\" built-in traits (see `middle::lang_items`) and\n+/// detects `Copy`, `Send` and `Sync`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),"}, {"sha": "a148a6496656a4a13047a03836ea14c14e48c742", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -252,7 +252,7 @@ impl Invocation {\n \n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n-    monotonic: bool, // c.f. `cx.monotonic_expander()`\n+    monotonic: bool, // cf. `cx.monotonic_expander()`\n }\n \n impl<'a, 'b> MacroExpander<'a, 'b> {"}, {"sha": "6abc506c07b736d08059d390626f7a78fcf86ae7", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -1635,19 +1635,13 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                             if name == \"packed\" {\n                                 gate_feature_post!(&self, repr_packed, attr.span,\n                                                    \"the `#[repr(packed(n))]` attribute \\\n-                                                   is experimental\");\n+                                                    is experimental\");\n                             }\n                         }\n                     }\n                 }\n             }\n \n-            ast::ItemKind::TraitAlias(..) => {\n-                gate_feature_post!(&self, trait_alias,\n-                                   i.span,\n-                                   \"trait aliases are not yet fully implemented\");\n-            }\n-\n             ast::ItemKind::Impl(_, polarity, defaultness, _, _, _, _) => {\n                 if polarity == ast::ImplPolarity::Negative {\n                     gate_feature_post!(&self, optin_builtin_traits,\n@@ -1669,6 +1663,15 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                    \"auto traits are experimental and possibly buggy\");\n             }\n \n+            ast::ItemKind::TraitAlias(..) => {\n+                gate_feature_post!(\n+                    &self,\n+                    trait_alias,\n+                    i.span,\n+                    \"trait aliases are experimental\"\n+                );\n+            }\n+\n             ast::ItemKind::MacroDef(ast::MacroDef { legacy: false, .. }) => {\n                 let msg = \"`macro` is experimental\";\n                 gate_feature_post!(&self, decl_macro, i.span, msg);"}, {"sha": "d3416d6923cb0bc0b1940bbe8f8140647caab0dc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -1295,7 +1295,7 @@ impl<'a> Parser<'a> {\n             self.check_keyword(keywords::Extern) && self.is_extern_non_path()\n     }\n \n-    /// parse a TyKind::BareFn type:\n+    /// parse a `TyKind::BareFn` type:\n     fn parse_ty_bare_fn(&mut self, generic_params: Vec<GenericParam>) -> PResult<'a, TyKind> {\n         /*\n \n@@ -1532,7 +1532,7 @@ impl<'a> Parser<'a> {\n                             if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n                         let path = match bounds[0] {\n                             GenericBound::Trait(ref pt, ..) => pt.trait_ref.path.clone(),\n-                            _ => self.bug(\"unexpected lifetime bound\"),\n+                            GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n                         };\n                         self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n                     }\n@@ -5779,7 +5779,7 @@ impl<'a> Parser<'a> {\n                              ast::ImplItemKind)> {\n         // code copied from parse_macro_use_or_failure... abstraction!\n         if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n-            // Method macro.\n+            // method macro\n             Ok((keywords::Invalid.ident(), vec![], ast::Generics::default(),\n                 ast::ImplItemKind::Macro(mac)))\n         } else {\n@@ -6792,11 +6792,11 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n     }\n \n-    /// Parse type Foo = Bar;\n+    /// Parse `type Foo = Bar;`\n     /// or\n-    /// existential type Foo: Bar;\n+    /// `existential type Foo: Bar;`\n     /// or\n-    /// return None without modifying the parser state\n+    /// `return None` without modifying the parser state\n     fn eat_type(&mut self) -> Option<PResult<'a, (Ident, AliasKind, ast::Generics)>> {\n         // This parses the grammar:\n         //     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\""}, {"sha": "d8ac1a8c63464025cfcf01e467b6096ec4bd490c", "filename": "src/test/run-pass/traits/trait-alias-bounds.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-bounds.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+use std::marker::PhantomData;\n+\n+trait Empty {}\n+trait EmptyAlias = Empty;\n+trait CloneDefault = Clone + Default;\n+trait SendSyncAlias = Send + Sync;\n+trait WhereSendAlias = where Self: Send;\n+trait SendEqAlias<T> = Send where T: PartialEq<Self>;\n+trait I32Iterator = Iterator<Item = i32>;\n+\n+#[allow(dead_code)]\n+struct Foo<T: SendSyncAlias>(PhantomData<T>);\n+#[allow(dead_code)]\n+struct Bar<T>(PhantomData<T>) where T: SendSyncAlias;\n+\n+impl EmptyAlias {}\n+\n+impl<T: SendSyncAlias> Empty for T {}\n+\n+fn a<T: CloneDefault>() -> (T, T) {\n+    let one = T::default();\n+    let two = one.clone();\n+    (one, two)\n+}\n+\n+fn b(x: &impl SendEqAlias<i32>) -> bool {\n+    22_i32 == *x\n+}\n+\n+fn c<T: I32Iterator>(x: &mut T) -> Option<i32> {\n+    x.next()\n+}\n+\n+fn d<T: SendSyncAlias>() {\n+    is_send_and_sync::<T>();\n+}\n+\n+fn is_send_and_sync<T: Send + Sync>() {}\n+\n+fn main() {\n+    let both = a::<i32>();\n+    assert_eq!(both.0, 0);\n+    assert_eq!(both.1, 0);\n+    let both: (i32, i32) = a();\n+    assert_eq!(both.0, 0);\n+    assert_eq!(both.1, 0);\n+\n+    assert!(b(&22));\n+\n+    assert_eq!(c(&mut vec![22].into_iter()), Some(22));\n+\n+    d::<i32>();\n+}"}, {"sha": "17e30922b2cb8068594a42b6f29305b20370b0f5", "filename": "src/test/run-pass/traits/trait-alias-object-type.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object-type.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait Foo = PartialEq<i32> + Send;\n+trait Bar = Foo + Sync;\n+\n+trait I32Iterator = Iterator<Item = i32>;\n+\n+pub fn main() {\n+    let a: &dyn Bar = &123;\n+    assert!(*a == 123);\n+    let b = Box::new(456) as Box<dyn Foo>;\n+    assert!(*b == 456);\n+\n+    // FIXME(alexreg): associated type should be gotten from trait alias definition\n+    // let c: &dyn I32Iterator = &vec![123].into_iter();\n+    // assert_eq!(c.next(), Some(123));\n+}"}, {"sha": "a9b7afb0ea343b3d6d114c726dc6dcf80dd13cea", "filename": "src/test/run-pass/traits/trait-alias-syntax.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-syntax.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait SimpleAlias = Default;\n+trait GenericAlias<T> = Iterator<Item = T>;\n+trait Partial<T> = IntoIterator<Item = T>;\n+trait SpecificAlias = GenericAlias<i32>;\n+trait PartialEqRef<'a, T: 'a> = PartialEq<&'a T>;\n+trait StaticAlias = 'static;\n+\n+trait Things<T> {}\n+trait Romeo {}\n+#[allow(dead_code)]\n+struct The<T>(T);\n+#[allow(dead_code)]\n+struct Fore<T>(T);\n+impl<T, U> Things<T> for The<U> {}\n+impl<T> Romeo for Fore<T> {}\n+\n+trait WithWhere<Art, Thou> = Romeo + Romeo where Fore<(Art, Thou)>: Romeo;\n+trait BareWhere<Wild, Are> = where The<Wild>: Things<Are>;\n+\n+fn main() {}"}, {"sha": "f60f1dfcf3772e0979c224d3a9e5e40fc2416472", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -2,7 +2,9 @@ error[E0404]: expected trait, found type alias `Bar`\n   --> $DIR/two_files.rs:15:6\n    |\n LL | impl Bar for Baz { } //~ ERROR expected trait, found type alias\n-   |      ^^^ type aliases cannot be used for traits\n+   |      ^^^ type aliases cannot be used as traits\n+   |\n+   = note: did you mean to use a trait alias?\n \n error: aborting due to previous error\n "}, {"sha": "a2a183f80f92e91fd0e8fa35a98859059baf5494", "filename": "src/test/ui/feature-gates/feature-gate-trait-alias.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo = Default;\n+\n+fn main() {}"}, {"sha": "e02dfe27805a4aef1ea32ff98b6e5c8936852cc5", "filename": "src/test/ui/feature-gates/feature-gate-trait-alias.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait-alias.stderr?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: trait aliases are experimental (see issue #41517)\n+  --> $DIR/feature-gate-trait-alias.rs:11:1\n+   |\n+LL | trait Foo = Default;\n+   | ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(trait_alias)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "3e330f9de6547a668b193379b029b9e8b0c47f4e", "filename": "src/test/ui/resolve/issue-3907.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -2,7 +2,9 @@ error[E0404]: expected trait, found type alias `Foo`\n   --> $DIR/issue-3907.rs:20:6\n    |\n LL | impl Foo for S { //~ ERROR expected trait, found type alias `Foo`\n-   |      ^^^ type aliases cannot be used for traits\n+   |      ^^^ type aliases cannot be used as traits\n+   |\n+   = note: did you mean to use a trait alias?\n help: possible better candidate is found in another module, you can import it into scope\n    |\n LL | use issue_3907::Foo;"}, {"sha": "0acc5c8a93ec689c1e2fc5ef56d9d06207ddb825", "filename": "src/test/ui/resolve/issue-5035.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -11,7 +11,9 @@ LL | impl K for isize {} //~ ERROR expected trait, found type alias `K`\n    |      ^\n    |      |\n    |      did you mean `I`?\n-   |      type aliases cannot be used for traits\n+   |      type aliases cannot be used as traits\n+   |\n+   = note: did you mean to use a trait alias?\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d293a77392e8997b80458653ce86b26259d5511f", "filename": "src/test/ui/resolve/unboxed-closure-sugar-nonexistent-trait.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -8,7 +8,9 @@ error[E0404]: expected trait, found type alias `Typedef`\n   --> $DIR/unboxed-closure-sugar-nonexistent-trait.rs:16:8\n    |\n LL | fn g<F:Typedef(isize) -> isize>(x: F) {}\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^ type aliases cannot be used for traits\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^ type aliases cannot be used as traits\n+   |\n+   = note: did you mean to use a trait alias?\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7aca227a76c484b3af95ef7659614b23b4576d84", "filename": "src/test/ui/trait-alias-fail.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d28ee3e34d100534062d0bc690779ed9b6927fe/src%2Ftest%2Fui%2Ftrait-alias-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28ee3e34d100534062d0bc690779ed9b6927fe/src%2Ftest%2Fui%2Ftrait-alias-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-alias-fail.rs?ref=3d28ee3e34d100534062d0bc690779ed9b6927fe", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// gate-test-trait_alias\n-\n-trait Alias1<T> = Default where T: Clone; // ok\n-    //~^ERROR trait aliases are not yet fully implemented\n-trait Alias2<T: Clone = ()> = Default;\n-    //~^ERROR type parameters on the left side of a trait alias cannot be bounded\n-    //~^^ERROR type parameters on the left side of a trait alias cannot have defaults\n-    //~^^^ERROR trait aliases are not yet fully implemented\n-\n-impl Alias1 { //~ERROR expected type, found trait alias\n-}\n-\n-impl Alias1 for () { //~ERROR expected trait, found trait alias\n-}\n-\n-fn main() {}\n-"}, {"sha": "f7b144c06f80ae309d6f446e2e4b5567eaeaff93", "filename": "src/test/ui/trait-alias-fail.stderr", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3d28ee3e34d100534062d0bc690779ed9b6927fe/src%2Ftest%2Fui%2Ftrait-alias-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d28ee3e34d100534062d0bc690779ed9b6927fe/src%2Ftest%2Fui%2Ftrait-alias-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-alias-fail.stderr?ref=3d28ee3e34d100534062d0bc690779ed9b6927fe", "patch": "@@ -1,44 +0,0 @@\n-error: type parameters on the left side of a trait alias cannot be bounded\n-  --> $DIR/trait-alias-fail.rs:15:14\n-   |\n-LL | trait Alias2<T: Clone = ()> = Default;\n-   |              ^\n-\n-error: type parameters on the left side of a trait alias cannot have defaults\n-  --> $DIR/trait-alias-fail.rs:15:14\n-   |\n-LL | trait Alias2<T: Clone = ()> = Default;\n-   |              ^\n-\n-error[E0573]: expected type, found trait alias `Alias1`\n-  --> $DIR/trait-alias-fail.rs:20:6\n-   |\n-LL | impl Alias1 { //~ERROR expected type, found trait alias\n-   |      ^^^^^^ not a type\n-\n-error[E0404]: expected trait, found trait alias `Alias1`\n-  --> $DIR/trait-alias-fail.rs:23:6\n-   |\n-LL | impl Alias1 for () { //~ERROR expected trait, found trait alias\n-   |      ^^^^^^ not a trait\n-\n-error[E0658]: trait aliases are not yet fully implemented (see issue #41517)\n-  --> $DIR/trait-alias-fail.rs:13:1\n-   |\n-LL | trait Alias1<T> = Default where T: Clone; // ok\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(trait_alias)] to the crate attributes to enable\n-\n-error[E0658]: trait aliases are not yet fully implemented (see issue #41517)\n-  --> $DIR/trait-alias-fail.rs:15:1\n-   |\n-LL | trait Alias2<T: Clone = ()> = Default;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(trait_alias)] to the crate attributes to enable\n-\n-error: aborting due to 6 previous errors\n-\n-Some errors occurred: E0404, E0573, E0658.\n-For more information about an error, try `rustc --explain E0404`."}, {"sha": "bf3483000e3bc5cd6385c09fea8e565566a9528c", "filename": "src/test/ui/traits/trait-alias-impl.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-impl.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait DefaultAlias = Default;\n+\n+impl DefaultAlias for () {}\n+\n+fn main() {}"}, {"sha": "9ad625176b148148d9f665acafd50df4a3cdcce0", "filename": "src/test/ui/traits/trait-alias-impl.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-impl.stderr?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,9 @@\n+error[E0404]: expected trait, found trait alias `DefaultAlias`\n+  --> $DIR/trait-alias-impl.rs:15:6\n+   |\n+LL | impl DefaultAlias for () {}\n+   |      ^^^^^^^^^^^^ not a trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0404`."}, {"sha": "3adcd8436d8a1c2c9075aaf5b7bbfe67552660da", "filename": "src/test/ui/traits/trait-alias-objects.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-objects.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait EqAlias = Eq;\n+trait IteratorAlias = Iterator;\n+\n+fn main() {\n+    let _: &dyn EqAlias = &123;\n+    let _: &dyn IteratorAlias = &vec![123].into_iter();\n+}"}, {"sha": "8f9681e898fe8a11e6e7cad3daac44f023a4c5b1", "filename": "src/test/ui/traits/trait-alias-objects.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-objects.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-objects.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-objects.stderr?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,18 @@\n+error[E0038]: the trait `EqAlias` cannot be made into an object\n+  --> $DIR/trait-alias-objects.rs:17:13\n+   |\n+LL |     let _: &dyn EqAlias = &123;\n+   |             ^^^^^^^^^^^ the trait `EqAlias` cannot be made into an object\n+   |\n+   = note: the trait cannot use `Self` as a type parameter in the supertraits or where-clauses\n+\n+error[E0191]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified\n+  --> $DIR/trait-alias-objects.rs:18:13\n+   |\n+LL |     let _: &dyn IteratorAlias = &vec![123].into_iter();\n+   |             ^^^^^^^^^^^^^^^^^ missing associated type `Item` value\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0038, E0191.\n+For more information about an error, try `rustc --explain E0038`."}, {"sha": "8c8ce1221ba3559fbc3bad9b8895ffdf414c613f", "filename": "src/test/ui/traits/trait-alias-wf.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-wf.rs?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait Foo {}\n+trait A<T: Foo> {}\n+trait B<T> = A<T>; // T cannot be unbounded\n+\n+fn main() {}"}, {"sha": "e8c81c87796f3cbbfc6202e53202a272c754dfec", "filename": "src/test/ui/traits/trait-alias-wf.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3f0f5107e48d47936a604325a1af325033901d0/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-wf.stderr?ref=a3f0f5107e48d47936a604325a1af325033901d0", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: the trait bound `T: Foo` is not satisfied\n+  --> $DIR/trait-alias-wf.rs:15:1\n+   |\n+LL | trait B<T> = A<T>; // T cannot be unbounded\n+   | ^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `T`\n+   |\n+   = help: consider adding a `where T: Foo` bound\n+note: required by `A`\n+  --> $DIR/trait-alias-wf.rs:14:1\n+   |\n+LL | trait A<T: Foo> {}\n+   | ^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9ea211b4d7d69a7f7c1cae1d8c71dc1c4e7d77c7", "filename": "src/test/ui/traits/trait-alias.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3d28ee3e34d100534062d0bc690779ed9b6927fe/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d28ee3e34d100534062d0bc690779ed9b6927fe/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias.rs?ref=3d28ee3e34d100534062d0bc690779ed9b6927fe", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(trait_alias)]\n-\n-trait SimpleAlias = Default; //~ERROR E0645\n-trait GenericAlias<T> = Iterator<Item=T>; //~ERROR E0645\n-trait Partial<T> = IntoIterator<Item=T>; //~ERROR E0645\n-\n-trait Things<T> {}\n-trait Romeo {}\n-struct The<T>(T);\n-struct Fore<T>(T);\n-impl<T, U> Things<T> for The<U> {}\n-impl<T> Romeo for Fore<T> {}\n-\n-trait WithWhere<Art, Thou> = Romeo + Romeo where Fore<(Art, Thou)>: Romeo; //~ERROR E0645\n-trait BareWhere<Wild, Are> = where The<Wild>: Things<Are>; //~ERROR E0645\n-\n-trait CD = Clone + Default; //~ERROR E0645\n-\n-fn foo<T: CD>() -> (T, T) {\n-    let one = T::default();\n-    let two = one.clone();\n-    (one, two)\n-}\n-\n-fn main() {\n-    let both = foo();\n-    assert_eq!(both.0, 0);\n-    assert_eq!(both.1, 0);\n-    let both: (i32, i32) = foo();\n-    assert_eq!(both.0, 0);\n-    assert_eq!(both.1, 0);\n-}\n-"}, {"sha": "5d290e5c7fba11189dc7e4612d3c8411ea047313", "filename": "src/test/ui/traits/trait-alias.stderr", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3d28ee3e34d100534062d0bc690779ed9b6927fe/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d28ee3e34d100534062d0bc690779ed9b6927fe/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias.stderr?ref=3d28ee3e34d100534062d0bc690779ed9b6927fe", "patch": "@@ -1,39 +0,0 @@\n-error[E0645]: trait aliases are not yet implemented (see issue #41517)\n-  --> $DIR/trait-alias.rs:13:1\n-   |\n-LL | trait SimpleAlias = Default; //~ERROR E0645\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0645]: trait aliases are not yet implemented (see issue #41517)\n-  --> $DIR/trait-alias.rs:14:1\n-   |\n-LL | trait GenericAlias<T> = Iterator<Item=T>; //~ERROR E0645\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0645]: trait aliases are not yet implemented (see issue #41517)\n-  --> $DIR/trait-alias.rs:15:1\n-   |\n-LL | trait Partial<T> = IntoIterator<Item=T>; //~ERROR E0645\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0645]: trait aliases are not yet implemented (see issue #41517)\n-  --> $DIR/trait-alias.rs:24:1\n-   |\n-LL | trait WithWhere<Art, Thou> = Romeo + Romeo where Fore<(Art, Thou)>: Romeo; //~ERROR E0645\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0645]: trait aliases are not yet implemented (see issue #41517)\n-  --> $DIR/trait-alias.rs:25:1\n-   |\n-LL | trait BareWhere<Wild, Are> = where The<Wild>: Things<Are>; //~ERROR E0645\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0645]: trait aliases are not yet implemented (see issue #41517)\n-  --> $DIR/trait-alias.rs:27:1\n-   |\n-LL | trait CD = Clone + Default; //~ERROR E0645\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 6 previous errors\n-\n-For more information about this error, try `rustc --explain E0645`."}]}