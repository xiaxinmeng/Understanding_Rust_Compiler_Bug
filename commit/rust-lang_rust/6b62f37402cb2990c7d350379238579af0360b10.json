{"sha": "6b62f37402cb2990c7d350379238579af0360b10", "node_id": "C_kwDOAAsO6NoAKDZiNjJmMzc0MDJjYjI5OTBjN2QzNTAzNzkyMzg1NzlhZjAzNjBiMTA", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-04-20T03:26:58Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-02T22:44:39Z"}, "message": "Restrict `From<S>` for `{D,Subd}iagnosticMessage`.\n\nCurrently a `{D,Subd}iagnosticMessage` can be created from any type that\nimpls `Into<String>`. That includes `&str`, `String`, and `Cow<'static,\nstr>`, which are reasonable. It also includes `&String`, which is pretty\nweird, and results in many places making unnecessary allocations for\npatterns like this:\n```\nself.fatal(&format!(...))\n```\nThis creates a string with `format!`, takes a reference, passes the\nreference to `fatal`, which does an `into()`, which clones the\nreference, doing a second allocation. Two allocations for a single\nstring, bleh.\n\nThis commit changes the `From` impls so that you can only create a\n`{D,Subd}iagnosticMessage` from `&str`, `String`, or `Cow<'static,\nstr>`. This requires changing all the places that currently create one\nfrom a `&String`. Most of these are of the `&format!(...)` form\ndescribed above; each one removes an unnecessary static `&`, plus an\nallocation when executed. There are also a few places where the existing\nuse of `&String` was more reasonable; these now just use `clone()` at\nthe call site.\n\nAs well as making the code nicer and more efficient, this is a step\ntowards possibly using `Cow<'static, str>` in\n`{D,Subd}iagnosticMessage::{Str,Eager}`. That would require changing\nthe `From<&'a str>` impls to `From<&'static str>`, which is doable, but\nI'm not yet sure if it's worthwhile.", "tree": {"sha": "64a4f63d5bdb61fd2d02c675d17ce9444ef0669b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64a4f63d5bdb61fd2d02c675d17ce9444ef0669b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b62f37402cb2990c7d350379238579af0360b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b62f37402cb2990c7d350379238579af0360b10", "html_url": "https://github.com/rust-lang/rust/commit/6b62f37402cb2990c7d350379238579af0360b10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b62f37402cb2990c7d350379238579af0360b10/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a368898de758e1b8def6c9060044a5b40eb79e84", "url": "https://api.github.com/repos/rust-lang/rust/commits/a368898de758e1b8def6c9060044a5b40eb79e84", "html_url": "https://github.com/rust-lang/rust/commit/a368898de758e1b8def6c9060044a5b40eb79e84"}], "stats": {"total": 1578, "additions": 791, "deletions": 787}, "files": [{"sha": "441282c05b42466848cc991a142f43e5378b3fe5", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         self.diagnostic().span_bug(\n             p.span,\n-            &format!(\n+            format!(\n                 \"lower_qpath: no final extension segment in {}..{}\",\n                 proj_start,\n                 p.segments.len()"}, {"sha": "ee3ded311c557cc2a067776eb4c3412d71772521", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -83,7 +83,7 @@ impl<'a> PostExpansionVisitor<'a> {\n                     &self,\n                     const_extern_fn,\n                     span,\n-                    &format!(\"`{}` as a `const fn` ABI is unstable\", abi)\n+                    format!(\"`{}` as a `const fn` ABI is unstable\", abi)\n                 ),\n             }\n         }\n@@ -104,7 +104,7 @@ impl<'a> PostExpansionVisitor<'a> {\n                 if self.sess.opts.pretty.map_or(true, |ppm| ppm.needs_hir()) {\n                     self.sess.parse_sess.span_diagnostic.delay_span_bug(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"unrecognized ABI not caught in lowering: {}\",\n                             symbol_unescaped.as_str()\n                         ),"}, {"sha": "d2d3792345f1cccd18ee18bc7ec7ec76a70de1d9", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -623,7 +623,7 @@ fn gate_cfg(gated_cfg: &GatedCfg, cfg_span: Span, sess: &ParseSess, features: &F\n     let (cfg, feature, has_feature) = gated_cfg;\n     if !has_feature(features) && !cfg_span.allows_unstable(*feature) {\n         let explain = format!(\"`cfg({cfg})` is experimental and subject to change\");\n-        feature_err(sess, *feature, cfg_span, &explain).emit();\n+        feature_err(sess, *feature, cfg_span, explain).emit();\n     }\n }\n "}, {"sha": "04b8174079acc5360d3157d82a1a0b699bbd2b40", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -158,7 +158,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } else if reinits > 1 {\n                 err.span_note(\n                     MultiSpan::from_spans(reinit_spans),\n-                    &if reinits <= 3 {\n+                    if reinits <= 3 {\n                         format!(\"these {reinits} reinitializations might get skipped\")\n                     } else {\n                         format!(\n@@ -253,7 +253,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // We have a `&mut` ref, we need to reborrow on each iteration (#62112).\n                     err.span_suggestion_verbose(\n                         span.shrink_to_lo(),\n-                        &format!(\n+                        format!(\n                             \"consider creating a fresh reborrow of {} here\",\n                             self.describe_place(moved_place)\n                                 .map(|n| format!(\"`{n}`\"))\n@@ -304,7 +304,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 ..\n             } = use_spans\n             {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"{} occurs due to deref coercion to `{deref_target_ty}`\",\n                     desired_action.as_noun(),\n                 ));\n@@ -586,7 +586,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 //     _ => {} // We don't want to point to this.\n                 // };\n                 // ```\n-                err.span_label(sp, &label);\n+                err.span_label(sp, label);\n                 shown = true;\n             }\n         }\n@@ -1139,7 +1139,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         if union_type_name != \"\" {\n-            err.note(&format!(\n+            err.note(format!(\n                 \"{} is a field of the union `{}`, so it overlaps the field {}\",\n                 msg_place, union_type_name, msg_borrow,\n             ));\n@@ -1238,14 +1238,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n         err.span_help(\n             inner_call_span,\n-            &format!(\n+            format!(\n                 \"try adding a local storing this{}...\",\n                 if use_span.is_some() { \"\" } else { \" argument\" }\n             ),\n         );\n         err.span_help(\n             outer_call_span,\n-            &format!(\n+            format!(\n                 \"...and then using that local {}\",\n                 if use_span.is_some() { \"here\" } else { \"as the argument to this call\" }\n             ),\n@@ -2281,7 +2281,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n         err.span_suggestion_verbose(\n             sugg_span,\n-            &format!(\n+            format!(\n                 \"to force the {} to take ownership of {} (and any \\\n                  other referenced variables), use the `move` keyword\",\n                 kind, captured_var\n@@ -2293,7 +2293,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match category {\n             ConstraintCategory::Return(_) | ConstraintCategory::OpaqueType => {\n                 let msg = format!(\"{} is returned here\", kind);\n-                err.span_note(constraint_span, &msg);\n+                err.span_note(constraint_span, msg);\n             }\n             ConstraintCategory::CallArgument(_) => {\n                 fr_name.highlight_region_name(&mut err);\n@@ -2304,7 +2304,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     );\n                 } else {\n                     let msg = format!(\"{scope} requires argument type to outlive `{fr_name}`\");\n-                    err.span_note(constraint_span, &msg);\n+                    err.span_note(constraint_span, msg);\n                 }\n             }\n             _ => bug!(\n@@ -2626,7 +2626,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     });\n                 if let Some(Ok(instance)) = deref_target {\n                     let deref_target_ty = instance.ty(tcx, self.param_env);\n-                    err.note(&format!(\n+                    err.note(format!(\n                         \"borrow occurs due to deref coercion to `{}`\",\n                         deref_target_ty\n                     ));\n@@ -3180,7 +3180,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n \n                 diag.span_label(*return_span, format!(\"also has lifetime `{}`\", region_name,));\n \n-                diag.help(&format!(\n+                diag.help(format!(\n                     \"use data from the highlighted arguments which match the `{}` lifetime of \\\n                      the return type\",\n                     region_name,"}, {"sha": "d0cb1126f38bbf2b92ff4ec1aa4214da1acfdb94", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     {\n                         err.span_label(\n                             pat.span,\n-                            &format!(\"binding `{ident}` declared here\"),\n+                            format!(\"binding `{ident}` declared here\"),\n                         );\n                     }\n                 }\n@@ -323,7 +323,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n \n             err.span_suggestion_verbose(\n                 span.shrink_to_hi(),\n-                &msg,\n+                msg,\n                 format!(\" + {suggestable_name}\"),\n                 Applicability::Unspecified,\n             );"}, {"sha": "a2334cc7249c94f650c4972fbfcb6a6cc9422d94", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1073,7 +1073,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             if !is_loop_move {\n                                 err.span_suggestion_verbose(\n                                     move_span.shrink_to_lo(),\n-                                    &format!(\n+                                    format!(\n                                         \"consider creating a fresh reborrow of {} here\",\n                                         self.describe_place(moved_place.as_ref())\n                                             .map(|n| format!(\"`{n}`\"))"}, {"sha": "8b77477a31a337bc0c6310531055ae5d0bbe8cd8", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -533,7 +533,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         suggestions.sort_unstable_by_key(|&(span, _, _)| span);\n         suggestions.dedup_by_key(|&mut (span, _, _)| span);\n         for (span, msg, suggestion) in suggestions {\n-            err.span_suggestion_verbose(span, &msg, suggestion, Applicability::MachineApplicable);\n+            err.span_suggestion_verbose(span, msg, suggestion, Applicability::MachineApplicable);\n         }\n     }\n "}, {"sha": "7558247948fe484dfdbe6bc544056c864bb9826f", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -573,7 +573,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 if !is_trait_sig {\n                                     err.span_suggestion_verbose(\n                                         err_help_span,\n-                                        &format!(\n+                                        format!(\n                                             \"consider changing this to be a mutable {pointer_desc}\"\n                                         ),\n                                         suggested_code,\n@@ -582,7 +582,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 } else if let Some(x) = local_trait {\n                                     err.span_suggestion_verbose(\n                                         x,\n-                                        &format!(\n+                                        format!(\n                                             \"consider changing that to be a mutable {pointer_desc}\"\n                                         ),\n                                         suggested_code,\n@@ -636,14 +636,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     };\n                                     err.span_suggestion_verbose(\n                                         span,\n-                                        &format!(\"consider {changing} this binding's type\"),\n+                                        format!(\"consider {changing} this binding's type\"),\n                                         sugg,\n                                         Applicability::HasPlaceholders,\n                                     );\n                                 } else {\n                                     err.span_label(\n                                         err_label_span,\n-                                        &format!(\n+                                        format!(\n                                             \"consider changing this binding's type to be: `{message}`\"\n                                         ),\n                                     );\n@@ -679,13 +679,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 match opt_source {\n                     Some(BorrowedContentSource::OverloadedDeref(ty)) => {\n-                        err.help(&format!(\n+                        err.help(format!(\n                             \"trait `DerefMut` is required to modify through a dereference, \\\n                              but it is not implemented for `{ty}`\",\n                         ));\n                     }\n                     Some(BorrowedContentSource::OverloadedIndex(ty)) => {\n-                        err.help(&format!(\n+                        err.help(format!(\n                             \"trait `IndexMut` is required to modify indexed content, \\\n                              but it is not implemented for `{ty}`\",\n                         ));\n@@ -736,7 +736,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // val[index] = rv;\n                         // ---------- place\n                         self.err.multipart_suggestions(\n-                            &format!(\n+                            format!(\n                                 \"to modify a `{}`, use `.get_mut()`, `.insert()` or the entry API\",\n                                 self.ty,\n                             ),\n@@ -788,7 +788,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     {\n                         // val[index].path(args..);\n                         self.err.multipart_suggestion(\n-                            &format!(\"to modify a `{}` use `.get_mut()`\", self.ty),\n+                            format!(\"to modify a `{}` use `.get_mut()`\", self.ty),\n                             vec![\n                                 (\n                                     val.span.shrink_to_hi().with_hi(index.span.lo()),\n@@ -822,7 +822,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let mut v = V { assign_span, err, ty, suggested: false };\n             v.visit_body(body);\n             if !v.suggested {\n-                err.help(&format!(\n+                err.help(format!(\n                     \"to modify a `{ty}`, use `.get_mut()`, `.insert()` or the entry API\",\n                 ));\n             }"}, {"sha": "ffba60581861d51c74601670975de77e93c48492", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -171,7 +171,7 @@ impl OutlivesSuggestionBuilder {\n         if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name)\n             && !matches!(outlived_fr_name.source, RegionNameSource::Static)\n         {\n-            diag.help(&format!(\n+            diag.help(format!(\n                 \"consider adding the following bound: `{fr_name}: {outlived_fr_name}`\",\n             ));\n         }\n@@ -207,7 +207,7 @@ impl OutlivesSuggestionBuilder {\n         // If there is exactly one suggestable constraints, then just suggest it. Otherwise, emit a\n         // list of diagnostics.\n         let mut diag = if suggested.len() == 1 {\n-            mbcx.infcx.tcx.sess.diagnostic().struct_help(&match suggested.last().unwrap() {\n+            mbcx.infcx.tcx.sess.diagnostic().struct_help(match suggested.last().unwrap() {\n                 SuggestedConstraint::Outlives(a, bs) => {\n                     let bs: SmallVec<[String; 2]> = bs.iter().map(|r| r.to_string()).collect();\n                     format!(\"add bound `{a}: {}`\", bs.join(\" + \"))\n@@ -232,15 +232,15 @@ impl OutlivesSuggestionBuilder {\n                 match constraint {\n                     SuggestedConstraint::Outlives(a, bs) => {\n                         let bs: SmallVec<[String; 2]> = bs.iter().map(|r| r.to_string()).collect();\n-                        diag.help(&format!(\"add bound `{a}: {}`\", bs.join(\" + \")));\n+                        diag.help(format!(\"add bound `{a}: {}`\", bs.join(\" + \")));\n                     }\n                     SuggestedConstraint::Equal(a, b) => {\n-                        diag.help(&format!(\n+                        diag.help(format!(\n                             \"`{a}` and `{b}` must be the same: replace one with the other\",\n                         ));\n                     }\n                     SuggestedConstraint::Static(a) => {\n-                        diag.help(&format!(\"replace `{a}` with `'static`\"));\n+                        diag.help(format!(\"replace `{a}` with `'static`\"));\n                     }\n                 }\n             }"}, {"sha": "37cf3f303126e9cca4ec5ae8944898226eecc234", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -533,8 +533,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                     _ => panic!(\"Unexpected type {ty:?}\"),\n                 };\n-                diag.note(&format!(\"requirement occurs because of {desc}\",));\n-                diag.note(&note);\n+                diag.note(format!(\"requirement occurs because of {desc}\",));\n+                diag.note(note);\n                 diag.help(\"see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\");\n             }\n         }\n@@ -863,7 +863,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n             spans_suggs.push((alias_span.shrink_to_hi(), \"<'a>\".to_string()));\n             diag.multipart_suggestion_verbose(\n-                &format!(\n+                format!(\n                     \"to declare that the trait object {captures}, you can add a lifetime parameter `'a` in the type alias\"\n                 ),\n                 spans_suggs,"}, {"sha": "f38e1605fa5caeff69bde95b388e9ece6bd0af1e", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -622,7 +622,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     // programs, so we need to use delay_span_bug here. See #82126.\n                     self.infcx.tcx.sess.delay_span_bug(\n                         hir_arg.span(),\n-                        &format!(\"unmatched subst and hir arg: found {kind:?} vs {hir_arg:?}\"),\n+                        format!(\"unmatched subst and hir arg: found {kind:?} vs {hir_arg:?}\"),\n                     );\n                 }\n             }"}, {"sha": "c4c54620e04e9f7b99f20395cea6a7f989197f97", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -2022,7 +2022,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // been emitted (#52262).\n                     self.infcx.tcx.sess.delay_span_bug(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"Accessing `{:?}` with the kind `{:?}` shouldn't be possible\",\n                             place, kind,\n                         ),\n@@ -2383,7 +2383,7 @@ mod error {\n             }\n             for (_, (mut diag, count)) in std::mem::take(&mut self.errors.buffered_mut_errors) {\n                 if count > 10 {\n-                    diag.note(&format!(\"...and {} other attempted mutable borrows\", count - 10));\n+                    diag.note(format!(\"...and {} other attempted mutable borrows\", count - 10));\n                 }\n                 diag.buffer(&mut self.errors.buffered);\n             }"}, {"sha": "a4394ddc01c5a6718ba0b160cee507d663d90f4a", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -399,7 +399,7 @@ pub(super) fn dump_annotation<'tcx>(\n \n         regioncx.annotate(tcx, &mut err);\n \n-        err.note(&format!(\n+        err.note(format!(\n             \"number of external vids: {}\",\n             closure_region_requirements.num_external_vids\n         ));\n@@ -421,7 +421,7 @@ pub(super) fn dump_annotation<'tcx>(\n     };\n \n     if !opaque_type_values.is_empty() {\n-        err.note(&format!(\"Inferred opaque type values:\\n{:#?}\", opaque_type_values));\n+        err.note(format!(\"Inferred opaque type values:\\n{:#?}\", opaque_type_values));\n     }\n \n     errors.buffer_non_error_diag(err);"}, {"sha": "4970ece5e7deb74e888df756ecc922a8ee1f1da0", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -399,7 +399,7 @@ fn check_opaque_type_parameter_valid(\n             return Err(tcx\n                 .sess\n                 .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(spans, &format!(\"{} used multiple times\", descr))\n+                .span_note(spans, format!(\"{} used multiple times\", descr))\n                 .emit());\n         }\n     }"}, {"sha": "bd01c0b504cb5d3fe9839f902201fdc5709b18d9", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -249,7 +249,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                         .infcx\n                         .tcx\n                         .sess\n-                        .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n+                        .delay_span_bug(span, format!(\"failed to normalize {:?}\", ty));\n                     TypeOpOutput {\n                         output: self.infcx.tcx.ty_error(guar),\n                         constraints: None,"}, {"sha": "a06d4bcc6c7aeb2c45b1a424300f7915972093ef", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if body.yield_ty().is_some() != universal_regions.yield_ty.is_some() {\n             self.tcx().sess.delay_span_bug(\n                 body.span,\n-                &format!(\n+                format!(\n                     \"Expected body to have yield_ty ({:?}) iff we have a UR yield_ty ({:?})\",\n                     body.yield_ty(),\n                     universal_regions.yield_ty,"}, {"sha": "438920e293db87201af3e0bcbb583fd0aaaff99e", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -236,7 +236,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             if hidden_type.has_non_region_infer() {\n                 let reported = infcx.tcx.sess.delay_span_bug(\n                     decl.hidden_type.span,\n-                    &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n+                    format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n                 );\n                 hidden_type.ty = infcx.tcx.ty_error(reported);\n             }"}, {"sha": "56f078f2da816fc9f266d8220ba41be06b343e11", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -335,7 +335,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     pub(crate) fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n         match self.defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"defining type: {} with closure substs {:#?}\",\n                     tcx.def_path_str_with_substs(def_id, substs),\n                     &substs[tcx.generics_of(def_id).parent_count..],\n@@ -347,11 +347,11 @@ impl<'tcx> UniversalRegions<'tcx> {\n                 // and other things that are not stable across tests!\n                 // So we just include the region-vid. Annoying.\n                 for_each_late_bound_region_in_recursive_scope(tcx, def_id.expect_local(), |r| {\n-                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r)));\n+                    err.note(format!(\"late-bound region is {:?}\", self.to_region_vid(r)));\n                 });\n             }\n             DefiningTy::Generator(def_id, substs, _) => {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"defining type: {} with generator substs {:#?}\",\n                     tcx.def_path_str_with_substs(def_id, substs),\n                     &substs[tcx.generics_of(def_id).parent_count..],\n@@ -361,23 +361,23 @@ impl<'tcx> UniversalRegions<'tcx> {\n                 // `r` but doing so is not stable across architectures\n                 // and so forth.\n                 for_each_late_bound_region_in_recursive_scope(tcx, def_id.expect_local(), |r| {\n-                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r)));\n+                    err.note(format!(\"late-bound region is {:?}\", self.to_region_vid(r)));\n                 });\n             }\n             DefiningTy::FnDef(def_id, substs) => {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"defining type: {}\",\n                     tcx.def_path_str_with_substs(def_id, substs),\n                 ));\n             }\n             DefiningTy::Const(def_id, substs) => {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"defining constant type: {}\",\n                     tcx.def_path_str_with_substs(def_id, substs),\n                 ));\n             }\n             DefiningTy::InlineConst(def_id, substs) => {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"defining inline constant type: {}\",\n                     tcx.def_path_str_with_substs(def_id, substs),\n                 ));"}, {"sha": "ac817d9a152ade1e81de6113b35af6c2c4c1f296", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -553,7 +553,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n             let mut e = ecx.struct_span_err(err_sp, msg);\n             e.span_label(err_sp, err.label + \" in asm template string\");\n             if let Some(note) = err.note {\n-                e.note(&note);\n+                e.note(note);\n             }\n             if let Some((label, span)) = err.secondary_label {\n                 let err_sp = template_span.from_inner(InnerSpan::new(span.start, span.end));\n@@ -600,7 +600,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                                     1 => format!(\"there is 1 {}argument\", positional),\n                                     x => format!(\"there are {} {}arguments\", x, positional),\n                                 };\n-                                err.note(&msg);\n+                                err.note(msg);\n \n                                 if named_pos.contains_key(&idx) {\n                                     err.span_label(args.operands[idx].1, \"named argument\");\n@@ -703,7 +703,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n             let (sp, msg) = unused_operands.into_iter().next().unwrap();\n             let mut err = ecx.struct_span_err(sp, msg);\n             err.span_label(sp, msg);\n-            err.help(&format!(\n+            err.help(format!(\n                 \"if this argument is intentionally unused, \\\n                  consider using it in an asm comment: `\\\"/*{} */\\\"`\",\n                 help_str\n@@ -718,7 +718,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n             for (sp, msg) in unused_operands {\n                 err.span_label(sp, msg);\n             }\n-            err.help(&format!(\n+            err.help(format!(\n                 \"if these arguments are intentionally unused, \\\n                  consider using them in an asm comment: `\\\"/*{} */\\\"`\",\n                 help_str"}, {"sha": "adc12ec84f514e11f97e810f2210da153102c51b", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -616,14 +616,14 @@ fn report_missing_placeholders(\n                         } else {\n                             diag.span_note(\n                                 sp,\n-                                &format!(\"format specifiers use curly braces, and {}\", trn),\n+                                format!(\"format specifiers use curly braces, and {}\", trn),\n                             );\n                         }\n                     } else {\n                         if success {\n-                            diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));\n+                            diag.help(format!(\"`{}` should be written as `{}`\", sub, trn));\n                         } else {\n-                            diag.note(&format!(\"`{}` should use curly braces, and {}\", sub, trn));\n+                            diag.note(format!(\"`{}` should use curly braces, and {}\", sub, trn));\n                         }\n                     }\n                 }\n@@ -777,7 +777,7 @@ fn report_invalid_references(\n                 has_precision_star = true;\n                 e.span_label(\n                     *span,\n-                    &format!(\n+                    format!(\n                         \"this precision flag adds an extra required argument at position {}, which is why there {} expected\",\n                         index,\n                         if num_placeholders == 1 {"}, {"sha": "52b5601bb11b8c8aee6178637d07a809ec336c2c", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -194,7 +194,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n                     };\n \n                     self.handler\n-                        .struct_span_err(attr.span, &msg)\n+                        .struct_span_err(attr.span, msg)\n                         .span_label(prev_attr.span, \"previous attribute here\")\n                         .emit();\n \n@@ -219,7 +219,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n                 pprust::path_to_string(&attr.get_normal_item().path),\n             );\n \n-            self.handler.span_err(attr.span, &msg);\n+            self.handler.span_err(attr.span, msg);\n             return;\n         }\n \n@@ -233,7 +233,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n                 pprust::path_to_string(&attr.get_normal_item().path),\n             );\n \n-            self.handler.span_err(attr.span, &msg);\n+            self.handler.span_err(attr.span, msg);\n             return;\n         }\n "}, {"sha": "b8a24f1102daf31537facae5a6d16f5f329a6e5d", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -150,7 +150,7 @@ pub fn expand_include<'cx>(\n                         if self.p.token != token::Eof {\n                             let token = pprust::token_to_string(&self.p.token);\n                             let msg = format!(\"expected item, found `{}`\", token);\n-                            self.p.struct_span_err(self.p.token.span, &msg).emit();\n+                            self.p.struct_span_err(self.p.token.span, msg).emit();\n                         }\n \n                         break;"}, {"sha": "73a3e3353f3a83ff3a337d78457cdd40b38914ec", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -88,10 +88,10 @@ pub(crate) fn import_function<'tcx>(\n     let sig = get_function_sig(tcx, module.target_config().default_call_conv, inst);\n     match module.declare_function(name, Linkage::Import, &sig) {\n         Ok(func_id) => func_id,\n-        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(format!(\n             \"attempt to declare `{name}` as function, but it was already declared as static\"\n         )),\n-        Err(ModuleError::IncompatibleSignature(_, prev_sig, new_sig)) => tcx.sess.fatal(&format!(\n+        Err(ModuleError::IncompatibleSignature(_, prev_sig, new_sig)) => tcx.sess.fatal(format!(\n             \"attempt to declare `{name}` with signature {new_sig:?}, \\\n              but it was already declared with signature {prev_sig:?}\"\n         )),\n@@ -548,7 +548,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             if !matches!(fn_sig.abi(), Abi::C { .. }) {\n                 fx.tcx.sess.span_fatal(\n                     source_info.span,\n-                    &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi()),\n+                    format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi()),\n                 );\n             }\n             let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n@@ -560,7 +560,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                         // FIXME set %al to upperbound on float args once floats are supported\n                         fx.tcx.sess.span_fatal(\n                             source_info.span,\n-                            &format!(\"Non int ty {:?} for variadic call\", ty),\n+                            format!(\"Non int ty {:?} for variadic call\", ty),\n                         );\n                     }\n                     AbiParam::new(ty)"}, {"sha": "e9dbea1be671d8696a19f0475cbc600277546192", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -220,13 +220,13 @@ pub(crate) fn verify_func(\n         match cranelift_codegen::verify_function(&func, &flags) {\n             Ok(_) => {}\n             Err(err) => {\n-                tcx.sess.err(&format!(\"{:?}\", err));\n+                tcx.sess.err(format!(\"{:?}\", err));\n                 let pretty_error = cranelift_codegen::print_errors::pretty_verifier_error(\n                     &func,\n                     Some(Box::new(writer)),\n                     err,\n                 );\n-                tcx.sess.fatal(&format!(\"cranelift verify error:\\n{}\", pretty_error));\n+                tcx.sess.fatal(format!(\"cranelift verify error:\\n{}\", pretty_error));\n             }\n         }\n     });"}, {"sha": "264b95e7abd7338d1572f35c1bd824673721353a", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -481,7 +481,7 @@ impl<'tcx> LayoutOfHelpers<'tcx> for RevealAllLayoutCx<'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let layout::LayoutError::SizeOverflow(_) = err {\n-            self.0.sess.span_fatal(span, &err.to_string())\n+            self.0.sess.span_fatal(span, err.to_string())\n         } else {\n             span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n         }\n@@ -499,7 +499,7 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for RevealAllLayoutCx<'tcx> {\n         fn_abi_request: FnAbiRequest<'tcx>,\n     ) -> ! {\n         if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n-            self.0.sess.span_fatal(span, &err.to_string())\n+            self.0.sess.span_fatal(span, err.to_string())\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {"}, {"sha": "d2b928db7d4df774ee35df3f8d07832abd520e9f", "filename": "compiler/rustc_codegen_cranelift/src/concurrency_limiter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -65,7 +65,7 @@ impl ConcurrencyLimiter {\n                     // Make sure to drop the mutex guard first to prevent poisoning the mutex.\n                     drop(state);\n                     if let Some(err) = err {\n-                        handler.fatal(&err).raise();\n+                        handler.fatal(err).raise();\n                     } else {\n                         // The error was already emitted, but compilation continued. Raise a silent\n                         // fatal error."}, {"sha": "77af561a58724c1fda56b2a1b1e1767412a453d1", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -308,7 +308,7 @@ fn data_id_for_static(\n             attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n         ) {\n             Ok(data_id) => data_id,\n-            Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+            Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(format!(\n                 \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n             )),\n             Err(err) => Err::<_, _>(err).unwrap(),\n@@ -356,7 +356,7 @@ fn data_id_for_static(\n         attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n     ) {\n         Ok(data_id) => data_id,\n-        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(format!(\n             \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n         )),\n         Err(err) => Err::<_, _>(err).unwrap(),\n@@ -404,7 +404,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 if let Some(names) = section_name.split_once(',') {\n                     names\n                 } else {\n-                    tcx.sess.fatal(&format!(\n+                    tcx.sess.fatal(format!(\n                         \"#[link_section = \\\"{}\\\"] is not valid for macos target: must be segment and section separated by comma\",\n                         section_name\n                     ));\n@@ -449,7 +449,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 GlobalAlloc::Static(def_id) => {\n                     if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n                     {\n-                        tcx.sess.fatal(&format!(\n+                        tcx.sess.fatal(format!(\n                             \"Allocation {:?} contains reference to TLS value {:?}\",\n                             alloc_id, def_id\n                         ));"}, {"sha": "aad9a9647f8c9b5c9f30b75a77638d0e678c9700", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -69,7 +69,7 @@ impl OngoingCodegen {\n \n             let module_codegen_result = match module_codegen_result {\n                 Ok(module_codegen_result) => module_codegen_result,\n-                Err(err) => sess.fatal(&err),\n+                Err(err) => sess.fatal(err),\n             };\n             let ModuleCodegenResult { module_regular, module_global_asm, existing_work_product } =\n                 module_codegen_result;\n@@ -468,7 +468,7 @@ pub(crate) fn run_aot(\n             let obj = create_compressed_metadata_file(tcx.sess, &metadata, &symbol_name);\n \n             if let Err(err) = std::fs::write(&tmp_file, obj) {\n-                tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));\n+                tcx.sess.fatal(format!(\"error writing metadata object file: {}\", err));\n             }\n \n             (metadata_cgu_name, tmp_file)"}, {"sha": "f67fdb592700f82b04a91c46ac5d43f533ffd26b", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -42,7 +42,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         _ => {\n             fx.tcx\n                 .sess\n-                .warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n+                .warn(format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n             crate::trap::trap_unimplemented(fx, intrinsic);\n             return;\n         }"}, {"sha": "33b2f4702a7a36042dabe64880cb8870ff93d90f", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm_aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_aarch64.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -207,7 +207,7 @@ pub(crate) fn codegen_aarch64_llvm_intrinsic_call<'tcx>(\n         }\n         */\n         _ => {\n-            fx.tcx.sess.warn(&format!(\n+            fx.tcx.sess.warn(format!(\n                 \"unsupported AArch64 llvm intrinsic {}; replacing with trap\",\n                 intrinsic\n             ));"}, {"sha": "56d8f13cec5e5068fb00141e616c5fb9fc6ad340", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm_x86.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -138,10 +138,9 @@ pub(crate) fn codegen_x86_llvm_intrinsic_call<'tcx>(\n             llvm_add_sub(fx, BinOp::Sub, ret, b_in, a, b);\n         }\n         _ => {\n-            fx.tcx.sess.warn(&format!(\n-                \"unsupported x86 llvm intrinsic {}; replacing with trap\",\n-                intrinsic\n-            ));\n+            fx.tcx\n+                .sess\n+                .warn(format!(\"unsupported x86 llvm intrinsic {}; replacing with trap\", intrinsic));\n             crate::trap::trap_unimplemented(fx, intrinsic);\n             return;\n         }"}, {"sha": "0a513b08b74f5df014fc9ae20913f70bc8d68b3a", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -42,7 +42,7 @@ fn report_atomic_type_validation_error<'tcx>(\n ) {\n     fx.tcx.sess.span_err(\n         span,\n-        &format!(\n+        format!(\n             \"`{}` intrinsic: expected basic integer or raw pointer type, found `{:?}`\",\n             intrinsic, ty\n         ),\n@@ -1202,7 +1202,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         _ => {\n             fx.tcx\n                 .sess\n-                .span_fatal(source_info.span, &format!(\"unsupported intrinsic {}\", intrinsic));\n+                .span_fatal(source_info.span, format!(\"unsupported intrinsic {}\", intrinsic));\n         }\n     }\n "}, {"sha": "5a038bfca5d2d7cb42d65012ec676c1c634ccdea", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -13,7 +13,7 @@ fn report_simd_type_validation_error(\n     span: Span,\n     ty: Ty<'_>,\n ) {\n-    fx.tcx.sess.span_err(span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", intrinsic, ty));\n+    fx.tcx.sess.span_err(span, format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", intrinsic, ty));\n     // Prevent verifier error\n     fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n@@ -150,7 +150,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                     _ => {\n                         fx.tcx.sess.span_err(\n                             span,\n-                            &format!(\n+                            format!(\n                                 \"simd_shuffle index must be an array of `u32`, got `{}`\",\n                                 idx_ty,\n                             ),\n@@ -248,7 +248,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(\n                     fx.mir.span,\n-                    &format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count),\n+                    format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count),\n                 );\n             }\n \n@@ -296,7 +296,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(\n                     fx.mir.span,\n-                    &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count),\n+                    format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count),\n                 );\n             }\n \n@@ -699,7 +699,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 _ => {\n                     fx.tcx.sess.span_fatal(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"invalid monomorphization of `simd_bitmask` intrinsic: \\\n                             vector argument `{}`'s element type `{}`, expected integer element \\\n                             type\",\n@@ -739,7 +739,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 _ => {\n                     fx.tcx.sess.span_fatal(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"invalid monomorphization of `simd_bitmask` intrinsic: \\\n                             cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n                             ret.layout().ty,\n@@ -875,7 +875,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         }\n \n         _ => {\n-            fx.tcx.sess.span_err(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n+            fx.tcx.sess.span_err(span, format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n             // Prevent verifier error\n             fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n         }"}, {"sha": "9966cc2ef3c12b2e0f0cebb9785a1e5935b44beb", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -185,7 +185,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         let mut config = self.config.borrow_mut();\n         if config.is_none() {\n             let new_config = BackendConfig::from_opts(&sess.opts.cg.llvm_args)\n-                .unwrap_or_else(|err| sess.fatal(&err));\n+                .unwrap_or_else(|err| sess.fatal(err));\n             *config = Some(new_config);\n         }\n     }\n@@ -245,7 +245,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n fn target_triple(sess: &Session) -> target_lexicon::Triple {\n     match sess.target.llvm_target.parse() {\n         Ok(triple) => triple,\n-        Err(err) => sess.fatal(&format!(\"target not recognized: {}\", err)),\n+        Err(err) => sess.fatal(format!(\"target not recognized: {}\", err)),\n     }\n }\n \n@@ -307,7 +307,7 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Arc<dyn isa::Tar\n         Some(value) => {\n             let mut builder =\n                 cranelift_codegen::isa::lookup(target_triple.clone()).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\"can't compile for {}: {}\", target_triple, err));\n+                    sess.fatal(format!(\"can't compile for {}: {}\", target_triple, err));\n                 });\n             if let Err(_) = builder.enable(value) {\n                 sess.fatal(\"the specified target cpu isn't currently supported by Cranelift.\");\n@@ -317,7 +317,7 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Arc<dyn isa::Tar\n         None => {\n             let mut builder =\n                 cranelift_codegen::isa::lookup(target_triple.clone()).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\"can't compile for {}: {}\", target_triple, err));\n+                    sess.fatal(format!(\"can't compile for {}: {}\", target_triple, err));\n                 });\n             if target_triple.architecture == target_lexicon::Architecture::X86_64 {\n                 // Don't use \"haswell\" as the default, as it implies `has_lzcnt`.\n@@ -330,7 +330,7 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Arc<dyn isa::Tar\n \n     match isa_builder.finish(flags) {\n         Ok(target_isa) => target_isa,\n-        Err(err) => sess.fatal(&format!(\"failed to build TargetIsa: {}\", err)),\n+        Err(err) => sess.fatal(format!(\"failed to build TargetIsa: {}\", err)),\n     }\n }\n "}, {"sha": "20ba73f38523a24502d50c464ad35ab1193dbe32", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -75,7 +75,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n             Ok(func_id) => func_id,\n             Err(err) => {\n                 tcx.sess\n-                    .fatal(&format!(\"entry symbol `{entry_name}` declared multiple times: {err}\"));\n+                    .fatal(format!(\"entry symbol `{entry_name}` declared multiple times: {err}\"));\n             }\n         };\n \n@@ -171,7 +171,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         }\n \n         if let Err(err) = m.define_function(cmain_func_id, &mut ctx) {\n-            tcx.sess.fatal(&format!(\"entry symbol `{entry_name}` defined multiple times: {err}\"));\n+            tcx.sess.fatal(format!(\"entry symbol `{entry_name}` defined multiple times: {err}\"));\n         }\n \n         unwind_context.add_function(cmain_func_id, &ctx, m.isa());"}, {"sha": "b1fda6ff2133797c234cfcdb556c4db32c30d26e", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -344,7 +344,7 @@ impl<'tcx> CPlace<'tcx> {\n         if layout.size.bytes() >= u64::from(u32::MAX - 16) {\n             fx.tcx\n                 .sess\n-                .fatal(&format!(\"values of type {} are too big to store on the stack\", layout.ty));\n+                .fatal(format!(\"values of type {} are too big to store on the stack\", layout.ty));\n         }\n \n         let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {"}, {"sha": "8a7809a14682ce480fa754f138fd20cc735179b0", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -53,7 +53,7 @@ use std::{env, fmt, fs, io, mem, str};\n pub fn ensure_removed(diag_handler: &Handler, path: &Path) {\n     if let Err(e) = fs::remove_file(path) {\n         if e.kind() != io::ErrorKind::NotFound {\n-            diag_handler.err(&format!(\"failed to remove {}: {}\", path.display(), e));\n+            diag_handler.err(format!(\"failed to remove {}: {}\", path.display(), e));\n         }\n     }\n }\n@@ -1405,7 +1405,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n         sess.emit_note(errors::StaticLibraryNativeArtifacts);\n         // Prefix for greppability\n         // Note: This must not be translated as tools are allowed to depend on this exact string.\n-        sess.note_without_error(&format!(\"native-static-libs: {}\", &lib_args.join(\" \")));\n+        sess.note_without_error(format!(\"native-static-libs: {}\", &lib_args.join(\" \")));\n     }\n }\n "}, {"sha": "1e57f4248d20f32b2c0be417c2fa69535bed1aca", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1631,7 +1631,7 @@ impl<'a> Linker for AixLinker<'a> {\n             }\n         };\n         if let Err(e) = res {\n-            self.sess.fatal(&format!(\"failed to write export file: {}\", e));\n+            self.sess.fatal(format!(\"failed to write export file: {}\", e));\n         }\n         self.cmd.arg(format!(\"-bE:{}\", path.to_str().unwrap()));\n     }"}, {"sha": "c42d59bd51c0a119f373a20246de4f1a039dccf0", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1833,7 +1833,7 @@ impl SharedEmitterMain {\n                     sess.abort_if_errors();\n                 }\n                 Ok(SharedEmitterMessage::Fatal(msg)) => {\n-                    sess.fatal(&msg);\n+                    sess.fatal(msg);\n                 }\n                 Err(_) => {\n                     break;"}, {"sha": "5cc87d1e56cca3d475a1a50436f7f2113870caae", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -301,7 +301,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n                 if let Some(val) = attr.value_str() {\n                     if val.as_str().bytes().any(|b| b == 0) {\n                         let msg = format!(\"illegal null byte in link_section value: `{}`\", &val);\n-                        tcx.sess.span_err(attr.span, &msg);\n+                        tcx.sess.span_err(attr.span, msg);\n                     } else {\n                         codegen_fn_attrs.link_section = Some(val);\n                     }\n@@ -631,7 +631,7 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n         } else {\n             let msg = format!(\"ordinal value in `link_ordinal` is too large: `{}`\", &ordinal);\n             tcx.sess\n-                .struct_span_err(attr.span, &msg)\n+                .struct_span_err(attr.span, msg)\n                 .note(\"the value may not exceed `u16::MAX`\")\n                 .emit();\n             None"}, {"sha": "6297f91341d44c35be63f4508132254cf98cd079", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -94,7 +94,7 @@ fn push_debuginfo_type_name<'tcx>(\n                         // Computing the layout can still fail here, e.g. if the target architecture\n                         // cannot represent the type. See https://github.com/rust-lang/rust/issues/94961.\n                         // FIXME: migrate once `rustc_middle::mir::interpret::InterpError` is translatable.\n-                        tcx.sess.fatal(&format!(\"{}\", e));\n+                        tcx.sess.fatal(format!(\"{}\", e));\n                     }\n                 }\n             } else {"}, {"sha": "1cfc4b933a8cb0d2390b8a7390f988774297a934", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -370,7 +370,7 @@ pub fn from_target_feature(\n             let Some(feature_gate) = supported_target_features.get(feature) else {\n                 let msg =\n                     format!(\"the feature named `{}` is not valid for this target\", feature);\n-                let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n+                let mut err = tcx.sess.struct_span_err(item.span(), msg);\n                 err.span_label(\n                     item.span(),\n                     format!(\"`{}` is not valid for this target\", feature),\n@@ -408,7 +408,7 @@ pub fn from_target_feature(\n                     &tcx.sess.parse_sess,\n                     feature_gate.unwrap(),\n                     item.span(),\n-                    &format!(\"the target feature `{}` is currently unstable\", feature),\n+                    format!(\"the target feature `{}` is currently unstable\", feature),\n                 )\n                 .emit();\n             }"}, {"sha": "cdef3fb23398b94fc8a86e0e803a2efac955ff3f", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -104,13 +104,13 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         // Add spans for the stacktrace. Don't print a single-line backtrace though.\n         if self.stacktrace.len() > 1 {\n             // Helper closure to print duplicated lines.\n-            let mut flush_last_line = |last_frame, times| {\n+            let mut flush_last_line = |last_frame: Option<(String, _)>, times| {\n                 if let Some((line, span)) = last_frame {\n-                    err.span_note(span, &line);\n+                    err.span_note(span, line.clone());\n                     // Don't print [... additional calls ...] if the number of lines is small\n                     if times < 3 {\n                         for _ in 0..times {\n-                            err.span_note(span, &line);\n+                            err.span_note(span, line.clone());\n                         }\n                     } else {\n                         err.span_note("}, {"sha": "046d2052968a3ad161bb31a7c38e20ce91ceebb1", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -368,7 +368,7 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                         if matches!(err.error, InterpError::UndefinedBehavior(_)) {\n                             diag.note(NOTE_ON_UNDEFINED_BEHAVIOR_ERROR);\n                         }\n-                        diag.note(&format!(\n+                        diag.note(format!(\n                             \"the raw bytes of the constant ({}\",\n                             display_allocation(\n                                 *ecx.tcx,"}, {"sha": "05be45fef139119bc2d468df4df85614b554229d", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -83,7 +83,7 @@ pub(crate) fn eval_to_valtree<'tcx>(\n                         Some(span) => {\n                             tcx.sess.create_err(MaxNumNodesInConstErr { span, global_const_id })\n                         }\n-                        None => tcx.sess.struct_err(&msg),\n+                        None => tcx.sess.struct_err(msg),\n                     };\n                     diag.emit();\n "}, {"sha": "c2b82ba9b0792c84c9e2de0d83376381870ad577", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -387,7 +387,7 @@ pub fn intern_const_alloc_recursive<\n             Err(error) => {\n                 ecx.tcx.sess.delay_span_bug(\n                     ecx.tcx.span,\n-                    &format!(\n+                    format!(\n                         \"error during interning should later cause validation failure: {}\",\n                         error\n                     ),"}, {"sha": "1e60a1e72ea07088f40bc687a50b99f206625ace", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -293,7 +293,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // FIXME: This should be a span_bug (#80742)\n                     self.tcx.sess.delay_span_bug(\n                         self.frame().current_span(),\n-                        &format!(\"{null_op:?} MIR operator called for unsized type {ty}\"),\n+                        format!(\"{null_op:?} MIR operator called for unsized type {ty}\"),\n                     );\n                     throw_inval!(SizeOfUnsizedType(ty));\n                 }"}, {"sha": "21f3c2c891713887de46d95ba39e3ef3efe12cfb", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> NonConstOp<'tcx> for FloatingPointOp {\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_floating_point_arithmetic,\n             span,\n-            &format!(\"floating point arithmetic is not allowed in {}s\", ccx.const_kind()),\n+            format!(\"floating point arithmetic is not allowed in {}s\", ccx.const_kind()),\n         )\n     }\n }\n@@ -211,13 +211,13 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                         err.span_note(span, \"function defined here, but it is not `const`\");\n                     }\n                     FnPtr(..) => {\n-                        err.note(&format!(\n+                        err.note(format!(\n                             \"function pointers need an RFC before allowed to be called in {}s\",\n                             ccx.const_kind()\n                         ));\n                     }\n                     Closure(..) => {\n-                        err.note(&format!(\n+                        err.note(format!(\n                             \"closures need an RFC before allowed to be called in {}s\",\n                             ccx.const_kind()\n                         ));\n@@ -289,7 +289,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                     ccx.const_kind()\n                 );\n \n-                err.note(&format!(\"attempting to deref into `{}`\", deref_target_ty));\n+                err.note(format!(\"attempting to deref into `{}`\", deref_target_ty));\n \n                 // Check first whether the source is accessible (issue #87060)\n                 if tcx.sess.source_map().is_span_accessible(deref_target) {\n@@ -310,14 +310,14 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n             }),\n         };\n \n-        err.note(&format!(\n+        err.note(format!(\n             \"calls in {}s are limited to constant functions, \\\n              tuple structs and tuple variants\",\n             ccx.const_kind(),\n         ));\n \n         if let Some(feature) = feature && ccx.tcx.sess.is_nightly_build() {\n-            err.help(&format!(\n+            err.help(format!(\n                 \"add `#![feature({})]` to the crate attributes to enable\",\n                 feature,\n             ));\n@@ -354,7 +354,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallUnstable {\n             err.help(\"const-stable functions can only call other const-stable functions\");\n         } else if ccx.tcx.sess.is_nightly_build() {\n             if let Some(feature) = feature {\n-                err.help(&format!(\n+                err.help(format!(\n                     \"add `#![feature({})]` to the crate attributes to enable\",\n                     feature\n                 ));\n@@ -637,7 +637,7 @@ impl<'tcx> NonConstOp<'tcx> for RawMutPtrDeref {\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n             span,\n-            &format!(\"dereferencing raw mutable pointers in {}s is unstable\", ccx.const_kind(),),\n+            format!(\"dereferencing raw mutable pointers in {}s is unstable\", ccx.const_kind(),),\n         )\n     }\n }\n@@ -724,7 +724,7 @@ pub mod ty {\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_mut_refs,\n                 span,\n-                &format!(\"mutable references are not allowed in {}s\", ccx.const_kind()),\n+                format!(\"mutable references are not allowed in {}s\", ccx.const_kind()),\n             )\n         }\n     }"}, {"sha": "f46c2d00fe4e0ad8ab427088c4d739e741046b71", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // occurred.\n         self.tcx.sess.diagnostic().delay_span_bug(\n             span,\n-            &format!(\n+            format!(\n                 \"broken MIR in {:?} ({}) at {:?}:\\n{}\",\n                 self.body.source.instance,\n                 self.when,\n@@ -1094,7 +1094,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         if self.body.source_scopes.get(scope).is_none() {\n             self.tcx.sess.diagnostic().delay_span_bug(\n                 self.body.span,\n-                &format!(\n+                format!(\n                     \"broken MIR in {:?} ({}):\\ninvalid source scope {:?}\",\n                     self.body.source.instance, self.when, scope,\n                 ),"}, {"sha": "6c3f677ab8e69f5e70ecabc79d8ba3abb8de722a", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -287,11 +287,19 @@ pub enum SubdiagnosticMessage {\n     FluentAttr(FluentId),\n }\n \n-/// `From` impl that enables existing diagnostic calls to functions which now take\n-/// `impl Into<SubdiagnosticMessage>` to continue to work as before.\n-impl<S: Into<String>> From<S> for SubdiagnosticMessage {\n-    fn from(s: S) -> Self {\n-        SubdiagnosticMessage::Str(s.into())\n+impl From<String> for SubdiagnosticMessage {\n+    fn from(s: String) -> Self {\n+        SubdiagnosticMessage::Str(s)\n+    }\n+}\n+impl<'a> From<&'a str> for SubdiagnosticMessage {\n+    fn from(s: &'a str) -> Self {\n+        SubdiagnosticMessage::Str(s.to_string())\n+    }\n+}\n+impl From<Cow<'static, str>> for SubdiagnosticMessage {\n+    fn from(s: Cow<'static, str>) -> Self {\n+        SubdiagnosticMessage::Str(s.to_string())\n     }\n }\n \n@@ -352,11 +360,19 @@ impl DiagnosticMessage {\n     }\n }\n \n-/// `From` impl that enables existing diagnostic calls to functions which now take\n-/// `impl Into<DiagnosticMessage>` to continue to work as before.\n-impl<S: Into<String>> From<S> for DiagnosticMessage {\n-    fn from(s: S) -> Self {\n-        DiagnosticMessage::Str(s.into())\n+impl From<String> for DiagnosticMessage {\n+    fn from(s: String) -> Self {\n+        DiagnosticMessage::Str(s)\n+    }\n+}\n+impl<'a> From<&'a str> for DiagnosticMessage {\n+    fn from(s: &'a str) -> Self {\n+        DiagnosticMessage::Str(s.to_string())\n+    }\n+}\n+impl From<Cow<'static, str>> for DiagnosticMessage {\n+    fn from(s: Cow<'static, str>) -> Self {\n+        DiagnosticMessage::Str(s.to_string())\n     }\n }\n "}, {"sha": "1f1398342b12207c60f87f6662f1c5b10e0ff5d1", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -791,7 +791,7 @@ macro_rules! struct_span_err {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n         $session.struct_span_err_with_code(\n             $span,\n-            &format!($($message)*),\n+            format!($($message)*),\n             $crate::error_code!($code),\n         )\n     })"}, {"sha": "68e57de5e0889e34ddedd0ad8b3a67b67a7d0c02", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -601,7 +601,7 @@ impl Emitter for SilentEmitter {\n         if d.level == Level::Fatal {\n             let mut d = d.clone();\n             if let Some(ref note) = self.fatal_note {\n-                d.note(note);\n+                d.note(note.clone());\n             }\n             self.fatal_handler.emit_diagnostic(&mut d);\n         }"}, {"sha": "f9c062d3a2176d7abfcb0c5af1a5b0202cbd01d8", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1462,10 +1462,10 @@ impl HandlerInner {\n                 DiagnosticMessage::Str(warnings),\n             )),\n             (_, 0) => {\n-                let _ = self.fatal(&errors);\n+                let _ = self.fatal(errors);\n             }\n             (_, _) => {\n-                let _ = self.fatal(&format!(\"{}; {}\", &errors, &warnings));\n+                let _ = self.fatal(format!(\"{}; {}\", &errors, &warnings));\n             }\n         }\n \n@@ -1486,18 +1486,18 @@ impl HandlerInner {\n                 error_codes.sort();\n                 if error_codes.len() > 1 {\n                     let limit = if error_codes.len() > 9 { 9 } else { error_codes.len() };\n-                    self.failure(&format!(\n+                    self.failure(format!(\n                         \"Some errors have detailed explanations: {}{}\",\n                         error_codes[..limit].join(\", \"),\n                         if error_codes.len() > 9 { \"...\" } else { \".\" }\n                     ));\n-                    self.failure(&format!(\n+                    self.failure(format!(\n                         \"For more information about an error, try \\\n                          `rustc --explain {}`.\",\n                         &error_codes[0]\n                     ));\n                 } else {\n-                    self.failure(&format!(\n+                    self.failure(format!(\n                         \"For more information about this error, try \\\n                          `rustc --explain {}`.\",\n                         &error_codes[0]\n@@ -1663,7 +1663,7 @@ impl HandlerInner {\n             if bug.level != Level::DelayedBug {\n                 // NOTE(eddyb) not panicking here because we're already producing\n                 // an ICE, and the more information the merrier.\n-                bug.note(&format!(\n+                bug.note(format!(\n                     \"`flushed_delayed` got diagnostic with level {:?}, \\\n                      instead of the expected `DelayedBug`\",\n                     bug.level,\n@@ -1732,7 +1732,7 @@ impl DelayedDiagnostic {\n     }\n \n     fn decorate(mut self) -> Diagnostic {\n-        self.inner.note(&format!(\"delayed at {}\", self.note));\n+        self.inner.note(format!(\"delayed at {}\", self.note));\n         self.inner\n     }\n }\n@@ -1831,7 +1831,7 @@ pub fn add_elided_lifetime_in_path_suggestion(\n         if incl_angl_brckt { format!(\"<{}>\", anon_lts) } else { format!(\"{}, \", anon_lts) };\n     diag.span_suggestion_verbose(\n         insertion_span.shrink_to_hi(),\n-        &format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n+        format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n         suggestion,\n         Applicability::MachineApplicable,\n     );"}, {"sha": "c1cca89df8ca5a3600affe5cf70f069b30118f9b", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1146,7 +1146,7 @@ impl<'a> ExtCtxt<'a> {\n         for (span, notes) in self.expansions.iter() {\n             let mut db = self.sess.parse_sess.create_note(errors::TraceMacro { span: *span });\n             for note in notes {\n-                db.note(note);\n+                db.note(note.clone());\n             }\n             db.emit();\n         }"}, {"sha": "7c78970345ad5e1db4af4fed3c0b23815b2d7bb0", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -797,7 +797,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             &self.cx.sess.parse_sess,\n             sym::proc_macro_hygiene,\n             span,\n-            &format!(\"custom attributes cannot be applied to {}\", kind),\n+            format!(\"custom attributes cannot be applied to {}\", kind),\n         )\n         .emit();\n     }"}, {"sha": "e4c65a2049bf6fc0dba5b8cbd5e336843951e4df", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -474,7 +474,7 @@ pub fn compile_declarative_macro(\n \n                 let s = parse_failure_msg(&token);\n                 let sp = token.span.substitute_dummy(def.span);\n-                let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);\n+                let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, s);\n                 err.span_label(sp, msg);\n                 annotate_doc_comment(&mut err, sess.source_map(), sp);\n                 err.emit();\n@@ -483,7 +483,7 @@ pub fn compile_declarative_macro(\n             Error(sp, msg) => {\n                 sess.parse_sess\n                     .span_diagnostic\n-                    .struct_span_err(sp.substitute_dummy(def.span), &msg)\n+                    .struct_span_err(sp.substitute_dummy(def.span), msg)\n                     .emit();\n                 return dummy_syn_ext();\n             }\n@@ -555,7 +555,7 @@ pub fn compile_declarative_macro(\n     let (transparency, transparency_error) = attr::find_transparency(&def.attrs, macro_rules);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) => {\n-            diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value));\n+            diag.span_err(span, format!(\"unknown macro transparency: `{}`\", value));\n         }\n         Some(TransparencyError::MultipleTransparencyAttrs(old_span, new_span)) => {\n             diag.span_err(vec![old_span, new_span], \"multiple macro transparency attributes\");\n@@ -1164,7 +1164,7 @@ fn check_matcher_core<'tt>(\n                             let sp = next_token.span();\n                             let mut err = sess.span_diagnostic.struct_span_err(\n                                 sp,\n-                                &format!(\n+                                format!(\n                                     \"`${name}:{frag}` {may_be} followed by `{next}`, which \\\n                                      is not allowed for `{frag}` fragments\",\n                                     name = name,\n@@ -1196,13 +1196,13 @@ fn check_matcher_core<'tt>(\n                             match possible {\n                                 &[] => {}\n                                 &[t] => {\n-                                    err.note(&format!(\n+                                    err.note(format!(\n                                         \"only {} is allowed after `{}` fragments\",\n                                         t, kind,\n                                     ));\n                                 }\n                                 ts => {\n-                                    err.note(&format!(\n+                                    err.note(format!(\n                                         \"{}{} or {}\",\n                                         msg,\n                                         ts[..ts.len() - 1].to_vec().join(\", \"),"}, {"sha": "6e919615019fb4edf306a27f8a8cd3b13ae05d41", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -78,7 +78,7 @@ fn check_trailing_token<'sess>(\n     if let Some(tt) = iter.next() {\n         let mut diag = sess\n             .span_diagnostic\n-            .struct_span_err(tt.span(), &format!(\"unexpected token: {}\", pprust::tt_to_string(tt)));\n+            .struct_span_err(tt.span(), format!(\"unexpected token: {}\", pprust::tt_to_string(tt)));\n         diag.span_note(tt.span(), \"meta-variable expression must not have trailing tokens\");\n         Err(diag)\n     } else {\n@@ -137,11 +137,11 @@ fn parse_ident<'sess>(\n         let token_str = pprust::token_to_string(token);\n         let mut err = sess.span_diagnostic.struct_span_err(\n             span,\n-            &format!(\"expected identifier, found `{}`\", &token_str)\n+            format!(\"expected identifier, found `{}`\", &token_str)\n         );\n         err.span_suggestion(\n             token.span,\n-            &format!(\"try removing `{}`\", &token_str),\n+            format!(\"try removing `{}`\", &token_str),\n             \"\",\n             Applicability::MaybeIncorrect,\n         );"}, {"sha": "b2bdf9c7e6db68e027586f87a1eb29a003f3666e", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -85,7 +85,7 @@ pub(super) fn parse(\n                                                     frag.name\n                                                 );\n                                                 sess.span_diagnostic\n-                                                    .struct_span_err(span, &msg)\n+                                                    .struct_span_err(span, msg)\n                                                     .help(VALID_FRAGMENT_NAMES_MSG)\n                                                     .emit();\n                                                 token::NonterminalKind::Ident\n@@ -195,7 +195,7 @@ fn parse_tree(\n                             _ => {\n                                 let tok = pprust::token_kind_to_string(&token::OpenDelim(delim));\n                                 let msg = format!(\"expected `(` or `{{`, found `{}`\", tok);\n-                                sess.span_diagnostic.span_err(delim_span.entire(), &msg);\n+                                sess.span_diagnostic.span_err(delim_span.entire(), msg);\n                             }\n                         }\n                     }\n@@ -246,7 +246,7 @@ fn parse_tree(\n                         \"expected identifier, found `{}`\",\n                         pprust::token_to_string(&token),\n                     );\n-                    sess.span_diagnostic.span_err(token.span, &msg);\n+                    sess.span_diagnostic.span_err(token.span, msg);\n                     TokenTree::MetaVar(token.span, Ident::empty())\n                 }\n \n@@ -358,7 +358,7 @@ fn parse_sep_and_kleene_op(\n // For example, `macro_rules! foo { ( ${length()} ) => {} }`\n fn span_dollar_dollar_or_metavar_in_the_lhs_err(sess: &ParseSess, token: &Token) {\n     sess.span_diagnostic\n-        .span_err(token.span, &format!(\"unexpected token: {}\", pprust::token_to_string(token)));\n+        .span_err(token.span, format!(\"unexpected token: {}\", pprust::token_to_string(token)));\n     sess.span_diagnostic.span_note_without_error(\n         token.span,\n         \"`$$` and meta-variable expressions are not allowed inside macro parameter definitions\","}, {"sha": "41b24407fa07c6603d17eab37bc28f53e74ae811", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -95,7 +95,7 @@ impl base::AttrProcMacro for AttrProcMacro {\n             |e| {\n                 let mut err = ecx.struct_span_err(span, \"custom attribute panicked\");\n                 if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n+                    err.help(format!(\"message: {}\", s));\n                 }\n                 err.emit()\n             },\n@@ -148,7 +148,7 @@ impl MultiItemModifier for DeriveProcMacro {\n                 Err(e) => {\n                     let mut err = ecx.struct_span_err(span, \"proc-macro derive panicked\");\n                     if let Some(s) = e.as_str() {\n-                        err.help(&format!(\"message: {}\", s));\n+                        err.help(format!(\"message: {}\", s));\n                     }\n                     err.emit();\n                     return ExpandResult::Ready(vec![]);"}, {"sha": "7b922f5d52599a1cd9a63a554c3fab2735662370", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -243,13 +243,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let note = format!(\"{title} is defined in an impl for the type `{impl_ty}`\");\n \n             if let Some(span) = note_span {\n-                err.span_note(span, &note);\n+                err.span_note(span, note);\n             } else {\n-                err.note(&note);\n+                err.note(note);\n             }\n         }\n         if candidates.len() > limit {\n-            err.note(&format!(\"and {} others\", candidates.len() - limit));\n+            err.note(format!(\"and {} others\", candidates.len() - limit));\n         }\n     }\n \n@@ -303,7 +303,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 \"associated type `{name}` not found for `{self_ty}` in the current scope\"\n             );\n             err.span_label(name.span, format!(\"associated item not found in `{self_ty}`\"));\n-            err.note(&format!(\n+            err.note(format!(\n                 \"the associated type was found for\\n{type_candidates}{additional_types}\",\n             ));\n             add_def_label(&mut err);\n@@ -390,10 +390,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let mut err = tcx.sess.struct_span_err(\n             name.span,\n-            &format!(\"the associated type `{name}` exists for `{self_ty}`, but its trait bounds were not satisfied\")\n+            format!(\"the associated type `{name}` exists for `{self_ty}`, but its trait bounds were not satisfied\")\n         );\n         if !bounds.is_empty() {\n-            err.note(&format!(\n+            err.note(format!(\n                 \"the following trait bounds were not satisfied:\\n{}\",\n                 bounds.join(\"\\n\")\n             ));\n@@ -409,7 +409,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             if !tcx.sess.source_map().is_span_accessible(span) {\n                 continue;\n             }\n-            err.span_label(span, &msg);\n+            err.span_label(span, msg);\n         }\n         add_def_label(&mut err);\n         err.emit()\n@@ -589,7 +589,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n         if !suggestions.is_empty() {\n             err.multipart_suggestion(\n-                &format!(\"specify the associated type{}\", pluralize!(types_count)),\n+                format!(\"specify the associated type{}\", pluralize!(types_count)),\n                 suggestions,\n                 Applicability::HasPlaceholders,\n             );"}, {"sha": "ed011b9086a19b63ed97eb0459cf60f79a2b77a1", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -112,7 +112,7 @@ fn generic_arg_mismatch_err(\n             if let rustc_hir::ExprKind::Path(rustc_hir::QPath::Resolved(_, path)) = body.value.kind\n             {\n                 if let Res::Def(DefKind::Fn { .. }, id) = path.res {\n-                    err.help(&format!(\"`{}` is a function item, not a type\", tcx.item_name(id)));\n+                    err.help(format!(\"`{}` is a function item, not a type\", tcx.item_name(id)));\n                     err.help(\"function item types cannot be named directly\");\n                 }\n             }\n@@ -130,7 +130,7 @@ fn generic_arg_mismatch_err(\n         } else {\n             (arg.descr(), param.kind.descr())\n         };\n-        err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n+        err.note(format!(\"{} arguments must be provided before {} arguments\", first, last));\n         if let Some(help) = help {\n             err.help(help);\n         }"}, {"sha": "def192f6e10427f8fecb1630c3b7c575bba1294e", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1168,9 +1168,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             tcx.sess\n                 .struct_span_err(\n                     binding.span,\n-                    &format!(\"{} `{}` is private\", assoc_item.kind, binding.item_name),\n+                    format!(\"{} `{}` is private\", assoc_item.kind, binding.item_name),\n                 )\n-                .span_label(binding.span, &format!(\"private {}\", assoc_item.kind))\n+                .span_label(binding.span, format!(\"private {}\", assoc_item.kind))\n                 .emit();\n         }\n         tcx.check_stability(assoc_item.def_id, Some(hir_ref_id), binding.span, None);\n@@ -1342,11 +1342,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         let expected = tcx.def_descr(assoc_item_def_id);\n                         let mut err = tcx.sess.struct_span_err(\n                             binding.span,\n-                            &format!(\"expected {expected} bound, found {got}\"),\n+                            format!(\"expected {expected} bound, found {got}\"),\n                         );\n                         err.span_note(\n                             tcx.def_span(assoc_item_def_id),\n-                            &format!(\"{expected} defined here\"),\n+                            format!(\"{expected} defined here\"),\n                         );\n \n                         if let hir::def::DefKind::AssocConst = def_kind\n@@ -1508,7 +1508,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 \"additional use\",\n             );\n             first_trait.label_with_exp_info(&mut err, \"first non-auto trait\", \"first use\");\n-            err.help(&format!(\n+            err.help(format!(\n                 \"consider creating a new trait with all of these as supertraits and using that \\\n                  trait here instead: `trait NewTrait: {} {{}}`\",\n                 regular_traits\n@@ -1818,7 +1818,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 ([], []) => {\n                     err.span_suggestion_verbose(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"if there were a type named `Type` that implements a trait named \\\n                              `Trait` with associated type `{name}`, you could use the \\\n                              fully-qualified path\",\n@@ -1830,7 +1830,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 ([], [trait_str]) => {\n                     err.span_suggestion_verbose(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"if there were a type named `Example` that implemented `{trait_str}`, \\\n                              you could use the fully-qualified path\",\n                         ),\n@@ -1841,7 +1841,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 ([], traits) => {\n                     err.span_suggestions(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"if there were a type named `Example` that implemented one of the \\\n                              traits with associated type `{name}`, you could use the \\\n                              fully-qualified path\",\n@@ -1856,7 +1856,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 ([type_str], []) => {\n                     err.span_suggestion_verbose(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"if there were a trait named `Example` with associated type `{name}` \\\n                              implemented for `{type_str}`, you could use the fully-qualified path\",\n                         ),\n@@ -1867,7 +1867,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 (types, []) => {\n                     err.span_suggestions(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"if there were a trait named `Example` with associated type `{name}` \\\n                              implemented for one of the types, you could use the fully-qualified \\\n                              path\",\n@@ -2033,15 +2033,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         );\n                     }\n                 } else {\n-                    err.note(&format!(\n+                    err.note(format!(\n                         \"associated type `{}` could derive from `{}`\",\n                         ty_param_name,\n                         bound.print_only_trait_path(),\n                     ));\n                 }\n             }\n             if !where_bounds.is_empty() {\n-                err.help(&format!(\n+                err.help(format!(\n                     \"consider introducing a new type parameter `T` and adding `where` constraints:\\\n                      \\n    where\\n        T: {},\\n{}\",\n                     ty_param_name,\n@@ -2109,14 +2109,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 // work for the `enum`, instead of just looking if it takes *any*.\n                                 err.span_suggestion_verbose(\n                                     args_span,\n-                                    &format!(\"{type_name} doesn't have generic parameters\"),\n+                                    format!(\"{type_name} doesn't have generic parameters\"),\n                                     \"\",\n                                     Applicability::MachineApplicable,\n                                 );\n                                 return;\n                             }\n                             let Ok(snippet) = tcx.sess.source_map().span_to_snippet(args_span) else {\n-                                err.note(&msg);\n+                                err.note(msg);\n                                 return;\n                             };\n                             let (qself_sugg_span, is_self) = if let hir::TyKind::Path(\n@@ -2150,12 +2150,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                         kw::SelfUpper == segment.ident.name,\n                                     ),\n                                     _ => {\n-                                        err.note(&msg);\n+                                        err.note(msg);\n                                         return;\n                                     }\n                                 }\n                             } else {\n-                                err.note(&msg);\n+                                err.note(msg);\n                                 return;\n                             };\n                             let suggestion = vec![\n@@ -2170,7 +2170,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 (args_span, String::new()),\n                             ];\n                             err.multipart_suggestion_verbose(\n-                                &msg,\n+                                msg,\n                                 suggestion,\n                                 Applicability::MaybeIncorrect,\n                             );\n@@ -2222,7 +2222,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let reported = if variant_resolution.is_some() {\n                     // Variant in type position\n                     let msg = format!(\"expected type, found variant `{}`\", assoc_ident);\n-                    tcx.sess.span_err(span, &msg)\n+                    tcx.sess.span_err(span, msg)\n                 } else if qself_ty.is_enum() {\n                     let mut err = struct_span_err!(\n                         tcx.sess,\n@@ -2293,7 +2293,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // Assume that if it's not matched, there must be a const defined with the same name\n             // but it was used in a type position.\n             let msg = format!(\"found associated const `{assoc_ident}` when type was expected\");\n-            let guar = tcx.sess.struct_span_err(span, &msg).emit();\n+            let guar = tcx.sess.struct_span_err(span, msg).emit();\n             return Err(guar);\n         };\n \n@@ -2313,7 +2313,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             also,\n                             tcx.def_kind_descr(kind, def_id)\n                         );\n-                        lint.span_note(tcx.def_span(def_id), &note_msg);\n+                        lint.span_note(tcx.def_span(def_id), note_msg);\n                     };\n \n                     could_refer_to(DefKind::Variant, variant_def_id, \"\");\n@@ -2510,9 +2510,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let msg = format!(\"{kind} `{name}` is private\");\n             let def_span = tcx.def_span(item);\n             tcx.sess\n-                .struct_span_err_with_code(span, &msg, rustc_errors::error_code!(E0624))\n-                .span_label(span, &format!(\"private {kind}\"))\n-                .span_label(def_span, &format!(\"{kind} defined here\"))\n+                .struct_span_err_with_code(span, msg, rustc_errors::error_code!(E0624))\n+                .span_label(span, format!(\"private {kind}\"))\n+                .span_label(def_span, format!(\"{kind} defined here\"))\n                 .emit();\n         }\n         tcx.check_stability(item, Some(block), span, None);\n@@ -2960,7 +2960,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 self.prohibit_generics(path.segments.iter(), |err| {\n                     if let Some(span) = tcx.def_ident_span(def_id) {\n                         let name = tcx.item_name(def_id);\n-                        err.span_note(span, &format!(\"type parameter `{name}` defined here\"));\n+                        err.span_note(span, format!(\"type parameter `{name}` defined here\"));\n                     }\n                 });\n \n@@ -3021,19 +3021,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         let mut span: MultiSpan = vec![t_sp].into();\n                         span.push_span_label(\n                             i_sp,\n-                            &format!(\"`Self` is on type `{type_name}` in this `impl`\"),\n+                            format!(\"`Self` is on type `{type_name}` in this `impl`\"),\n                         );\n                         let mut postfix = \"\";\n                         if generics == 0 {\n                             postfix = \", which doesn't have generic parameters\";\n                         }\n                         span.push_span_label(\n                             t_sp,\n-                            &format!(\"`Self` corresponds to this type{postfix}\"),\n+                            format!(\"`Self` corresponds to this type{postfix}\"),\n                         );\n-                        err.span_note(span, &msg);\n+                        err.span_note(span, msg);\n                     } else {\n-                        err.note(&msg);\n+                        err.note(msg);\n                     }\n                     for segment in path.segments {\n                         if let Some(args) = segment.args && segment.ident.name == kw::SelfUpper {\n@@ -3124,7 +3124,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         if let Some(args) = segment.args {\n                             err.span_suggestion_verbose(\n                                 segment.ident.span.shrink_to_hi().to(args.span_ext),\n-                                &format!(\"primitive type `{name}` doesn't have generic parameters\"),\n+                                format!(\"primitive type `{name}` doesn't have generic parameters\"),\n                                 \"\",\n                                 Applicability::MaybeIncorrect,\n                             );\n@@ -3415,7 +3415,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             if !infer_replacements.is_empty() {\n                 diag.multipart_suggestion(\n-                    &format!(\n+                    format!(\n                     \"try replacing `_` with the type{} in the corresponding trait method signature\",\n                     rustc_errors::pluralize!(infer_replacements.len()),\n                 ),"}, {"sha": "61b66ae2593be5226f9d24f6914d4d11f96467fa", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -175,7 +175,7 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         }\n         // Generic statics are rejected, but we still reach this case.\n         Err(e) => {\n-            tcx.sess.delay_span_bug(span, &e.to_string());\n+            tcx.sess.delay_span_bug(span, e.to_string());\n             return;\n         }\n     };\n@@ -334,7 +334,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n                 &tcx.sess.parse_sess,\n                 sym::impl_trait_projections,\n                 span,\n-                &format!(\n+                format!(\n                     \"`{}` return type cannot contain a projection or `Self` that references \\\n                     lifetimes from a parent scope\",\n                     if is_async { \"async fn\" } else { \"impl Trait\" },\n@@ -428,7 +428,7 @@ fn check_opaque_meets_bounds<'tcx>(\n             let ty_err = ty_err.to_string(tcx);\n             tcx.sess.delay_span_bug(\n                 span,\n-                &format!(\"could not unify `{hidden_ty}` with revealed type:\\n{ty_err}\"),\n+                format!(\"could not unify `{hidden_ty}` with revealed type:\\n{ty_err}\"),\n             );\n         }\n     }\n@@ -618,11 +618,11 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n                                 E0044,\n                                 \"foreign items may not have {kinds} parameters\",\n                             )\n-                            .span_label(item.span, &format!(\"can't have {kinds} parameters\"))\n+                            .span_label(item.span, format!(\"can't have {kinds} parameters\"))\n                             .help(\n                                 // FIXME: once we start storing spans for type arguments, turn this\n                                 // into a suggestion.\n-                                &format!(\n+                                format!(\n                                     \"replace the {} parameters with concrete {}{}\",\n                                     kinds,\n                                     kinds_pl,\n@@ -985,10 +985,7 @@ pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: ty::AdtDef<'_>) {\n \n                 err.span_note(\n                     tcx.def_span(def_spans[0].0),\n-                    &format!(\n-                        \"`{}` has a `#[repr(align)]` attribute\",\n-                        tcx.item_name(def_spans[0].0)\n-                    ),\n+                    format!(\"`{}` has a `#[repr(align)]` attribute\", tcx.item_name(def_spans[0].0)),\n                 );\n \n                 if def_spans.len() > 2 {\n@@ -997,7 +994,7 @@ pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: ty::AdtDef<'_>) {\n                         let ident = tcx.item_name(*adt_def);\n                         err.span_note(\n                             *span,\n-                            &if first {\n+                            if first {\n                                 format!(\n                                     \"`{}` contains a field of type `{}`\",\n                                     tcx.type_of(def.did()).subst_identity(),\n@@ -1466,10 +1463,10 @@ fn opaque_type_cycle_error(\n                     let ty_span = tcx.def_span(def_id);\n                     if !seen.contains(&ty_span) {\n                         let descr = if ty.is_impl_trait() { \"opaque \" } else { \"\" };\n-                        err.span_label(ty_span, &format!(\"returning this {descr}type `{ty}`\"));\n+                        err.span_label(ty_span, format!(\"returning this {descr}type `{ty}`\"));\n                         seen.insert(ty_span);\n                     }\n-                    err.span_label(sp, &format!(\"returning here with type `{ty}`\"));\n+                    err.span_label(sp, format!(\"returning here with type `{ty}`\"));\n                 }\n \n                 for closure_def_id in visitor.closures {"}, {"sha": "7384eb25f2ef7df51fda29c38d9aab87fb5f7b0d", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1273,7 +1273,7 @@ fn compare_number_of_generics<'tcx>(\n \n             let mut err = tcx.sess.struct_span_err_with_code(\n                 spans,\n-                &format!(\n+                format!(\n                     \"{} `{}` has {} {kind} parameter{} but its trait \\\n                      declaration has {} {kind} parameter{}\",\n                     item_kind,"}, {"sha": "64dff8e68b852fe75c393d844514d2fe111bc1d6", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -52,7 +52,7 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n             let span = tcx.def_span(drop_impl_did);\n             let reported = tcx.sess.delay_span_bug(\n                 span,\n-                &format!(\"should have been rejected by coherence check: {dtor_self_type}\"),\n+                format!(\"should have been rejected by coherence check: {dtor_self_type}\"),\n             );\n             Err(reported)\n         }\n@@ -76,15 +76,15 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         struct_span_err!(tcx.sess, drop_impl_span, E0366, \"`Drop` impls cannot be specialized\");\n     match arg {\n         ty::util::NotUniqueParam::DuplicateParam(arg) => {\n-            err.note(&format!(\"`{arg}` is mentioned multiple times\"))\n+            err.note(format!(\"`{arg}` is mentioned multiple times\"))\n         }\n         ty::util::NotUniqueParam::NotParam(arg) => {\n-            err.note(&format!(\"`{arg}` is not a generic parameter\"))\n+            err.note(format!(\"`{arg}` is not a generic parameter\"))\n         }\n     };\n     err.span_note(\n         item_span,\n-        &format!(\n+        format!(\n             \"use the same sequence of generic lifetime, type and const parameters \\\n                      as the {self_descr} definition\",\n         ),"}, {"sha": "e8785235c8318035b87b997b6c90ed776eab68bf", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -547,14 +547,14 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n                 Err(_) => {\n                     let msg =\n                         format!(\"unrecognized platform-specific intrinsic function: `{name}`\");\n-                    tcx.sess.struct_span_err(it.span, &msg).emit();\n+                    tcx.sess.struct_span_err(it.span, msg).emit();\n                     return;\n                 }\n             }\n         }\n         _ => {\n             let msg = format!(\"unrecognized platform-specific intrinsic function: `{name}`\");\n-            tcx.sess.struct_span_err(it.span, &msg).emit();\n+            tcx.sess.struct_span_err(it.span, msg).emit();\n             return;\n         }\n     };"}, {"sha": "0bb1467ef3170362f8a2829cd7a00d058a903c0b", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n             _ => None,\n         };\n         let Some(asm_ty) = asm_ty else {\n-            let msg = &format!(\"cannot use value of type `{ty}` for inline assembly\");\n+            let msg = format!(\"cannot use value of type `{ty}` for inline assembly\");\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             err.note(\n                 \"only integers, floats, SIMD vectors, pointers and function pointers \\\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n         if !ty.is_copy_modulo_regions(self.tcx, self.param_env) {\n             let msg = \"arguments for inline assembly must be copyable\";\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n-            err.note(&format!(\"`{ty}` does not implement the Copy trait\"));\n+            err.note(format!(\"`{ty}` does not implement the Copy trait\"));\n             err.emit();\n         }\n \n@@ -164,8 +164,8 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                 let mut err = self.tcx.sess.struct_span_err(vec![in_expr.span, expr.span], msg);\n \n                 let in_expr_ty = (self.get_operand_ty)(in_expr);\n-                err.span_label(in_expr.span, &format!(\"type `{in_expr_ty}`\"));\n-                err.span_label(expr.span, &format!(\"type `{ty}`\"));\n+                err.span_label(in_expr.span, format!(\"type `{in_expr_ty}`\"));\n+                err.span_label(expr.span, format!(\"type `{ty}`\"));\n                 err.note(\n                     \"asm inout arguments must have the same type, \\\n                     unless they are both pointers or integers of the same size\",\n@@ -184,17 +184,17 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n         let reg_class = reg.reg_class();\n         let supported_tys = reg_class.supported_types(asm_arch);\n         let Some((_, feature)) = supported_tys.iter().find(|&&(t, _)| t == asm_ty) else {\n-            let msg = &format!(\"type `{ty}` cannot be used with this register class\");\n+            let msg = format!(\"type `{ty}` cannot be used with this register class\");\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             let supported_tys: Vec<_> =\n                 supported_tys.iter().map(|(t, _)| t.to_string()).collect();\n-            err.note(&format!(\n+            err.note(format!(\n                 \"register class `{}` supports these types: {}\",\n                 reg_class.name(),\n                 supported_tys.join(\", \"),\n             ));\n             if let Some(suggest) = reg_class.suggest_class(asm_arch, asm_ty) {\n-                err.help(&format!(\n+                err.help(format!(\n                     \"consider using the `{}` register class instead\",\n                     suggest.name()\n                 ));\n@@ -215,9 +215,9 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n         // register class is usable at all.\n         if let Some(feature) = feature {\n             if !target_features.contains(feature) {\n-                let msg = &format!(\"`{}` target feature is not enabled\", feature);\n+                let msg = format!(\"`{}` target feature is not enabled\", feature);\n                 let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n-                err.note(&format!(\n+                err.note(format!(\n                     \"this is required to use type `{}` with register class `{}`\",\n                     ty,\n                     reg_class.name(),\n@@ -252,10 +252,10 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                     \"formatting may not be suitable for sub-register argument\",\n                     |lint| {\n                         lint.span_label(expr.span, \"for this argument\");\n-                        lint.help(&format!(\n+                        lint.help(format!(\n                             \"use `{{{idx}:{suggested_modifier}}}` to have the register formatted as `{suggested_result}`\",\n                         ));\n-                        lint.help(&format!(\n+                        lint.help(format!(\n                             \"or use `{{{idx}:{default_modifier}}}` to keep the default formatting of `{default_result}`\",\n                         ));\n                         lint\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                         op.is_clobber(),\n                     ) {\n                         let msg = format!(\"cannot use register `{}`: {}\", reg.name(), msg);\n-                        self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n+                        self.tcx.sess.struct_span_err(*op_sp, msg).emit();\n                         continue;\n                     }\n                 }\n@@ -340,7 +340,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                                 reg_class.name(),\n                                 feature\n                             );\n-                            self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n+                            self.tcx.sess.struct_span_err(*op_sp, msg).emit();\n                             // register isn't enabled, don't do more checks\n                             continue;\n                         }\n@@ -354,7 +354,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                                     .intersperse(\", \")\n                                     .collect::<String>(),\n                             );\n-                            self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n+                            self.tcx.sess.struct_span_err(*op_sp, msg).emit();\n                             // register isn't enabled, don't do more checks\n                             continue;\n                         }\n@@ -436,7 +436,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                                 self.tcx.sess.struct_span_err(*op_sp, \"invalid `sym` operand\");\n                             err.span_label(\n                                 self.tcx.def_span(anon_const.def_id),\n-                                &format!(\"is {} `{}`\", ty.kind().article(), ty),\n+                                format!(\"is {} `{}`\", ty.kind().article(), ty),\n                             );\n                             err.help(\"`sym` operands must refer to either a function or a static\");\n                             err.emit();"}, {"sha": "33c47da531e5e2a6f31f4246172ba693ea936feb", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -445,7 +445,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n             let plural = pluralize!(unsatisfied_bounds.len());\n             let mut err = tcx.sess.struct_span_err(\n                 gat_item_hir.span,\n-                &format!(\"missing required bound{} on `{}`\", plural, gat_item_hir.ident),\n+                format!(\"missing required bound{} on `{}`\", plural, gat_item_hir.ident),\n             );\n \n             let suggestion = format!(\n@@ -455,14 +455,14 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n             );\n             err.span_suggestion(\n                 gat_item_hir.generics.tail_span_for_predicate_suggestion(),\n-                &format!(\"add the required where clause{plural}\"),\n+                format!(\"add the required where clause{plural}\"),\n                 suggestion,\n                 Applicability::MachineApplicable,\n             );\n \n             let bound =\n                 if unsatisfied_bounds.len() > 1 { \"these bounds are\" } else { \"this bound is\" };\n-            err.note(&format!(\n+            err.note(format!(\n                 \"{} currently required to ensure that impls have maximum flexibility\",\n                 bound\n             ));\n@@ -916,14 +916,14 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                     if is_ptr {\n                         tcx.sess.span_err(\n                             hir_ty.span,\n-                            &format!(\n+                            format!(\n                                 \"using {unsupported_type} as const generic parameters is forbidden\",\n                             ),\n                         );\n                     } else {\n                         let mut err = tcx.sess.struct_span_err(\n                             hir_ty.span,\n-                            &format!(\n+                            format!(\n                                 \"{unsupported_type} is forbidden as the type of a const generic parameter\",\n                             ),\n                         );\n@@ -1029,7 +1029,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n                     let ty = tcx.erase_regions(ty);\n                     if ty.has_infer() {\n                         tcx.sess\n-                            .delay_span_bug(item.span, &format!(\"inference variables in {:?}\", ty));\n+                            .delay_span_bug(item.span, format!(\"inference variables in {:?}\", ty));\n                         // Just treat unresolved type expression as if it needs drop.\n                         true\n                     } else {\n@@ -1651,7 +1651,7 @@ fn check_method_receiver<'tcx>(\n                     &tcx.sess.parse_sess,\n                     sym::arbitrary_self_types,\n                     span,\n-                    &format!(\n+                    format!(\n                         \"`{receiver_ty}` cannot be used as the type of `self` without \\\n                          the `arbitrary_self_types` feature\",\n                     ),\n@@ -1874,10 +1874,10 @@ fn report_bivariance(\n     } else {\n         format!(\"consider removing `{param_name}` or referring to it in a field\")\n     };\n-    err.help(&msg);\n+    err.help(msg);\n \n     if matches!(param.kind, hir::GenericParamKind::Type { .. }) && !has_explicit_bounds {\n-        err.help(&format!(\n+        err.help(format!(\n             \"if you intended `{0}` to be a const parameter, use `const {0}: usize` instead\",\n             param_name\n         ));"}, {"sha": "3982b3531050a93550f2d1ed3312cd7999fd1e1f", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -213,7 +213,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                                  for structs containing the field being coerced, \\\n                                  ZST fields with 1 byte alignment, and nothing else\",\n                             )\n-                            .note(&format!(\n+                            .note(format!(\n                                 \"extra field `{}` of type `{}` is not allowed\",\n                                 field.name, ty_a,\n                             ))\n@@ -241,7 +241,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                             for a coercion between structures with a single field \\\n                             being coerced\",\n                     )\n-                    .note(&format!(\n+                    .note(format!(\n                         \"currently, {} fields need coercions: {}\",\n                         coerced_fields.len(),\n                         coerced_fields\n@@ -298,7 +298,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) -> Coe\n     let coerce_unsized_trait = tcx.require_lang_item(LangItem::CoerceUnsized, Some(span));\n \n     let unsize_trait = tcx.lang_items().require(LangItem::Unsize).unwrap_or_else(|err| {\n-        tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err.to_string()));\n+        tcx.sess.fatal(format!(\"`CoerceUnsized` implementation {}\", err.to_string()));\n     });\n \n     let source = tcx.type_of(impl_did).subst_identity();\n@@ -469,7 +469,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) -> Coe\n                     \"`CoerceUnsized` may only be implemented for \\\n                           a coercion between structures with one field being coerced\",\n                 )\n-                .note(&format!(\n+                .note(format!(\n                     \"currently, {} fields need coercions: {}\",\n                     diff_fields.len(),\n                     diff_fields"}, {"sha": "3355902069248c69a611c1fe47f29eb82974c557", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -146,7 +146,7 @@ impl<'tcx> InherentCollect<'tcx> {\n                 );\n                 err.help(\"consider using an extension trait instead\");\n                 if let ty::Ref(_, subty, _) = ty.kind() {\n-                    err.note(&format!(\n+                    err.note(format!(\n                         \"you could also try moving the reference to \\\n                             uses of `{}` (such as `self`) within the implementation\",\n                         subty"}, {"sha": "5ce8a83aad7f7250a83e3a224fb75d1dee8ccf94", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -372,10 +372,10 @@ fn emit_orphan_check_error<'tcx>(\n \n                 if is_target_ty {\n                     // Point at `D<A>` in `impl<A, B> for C<B> in D<A>`\n-                    err.span_label(self_ty_span, &msg);\n+                    err.span_label(self_ty_span, msg);\n                 } else {\n                     // Point at `C<B>` in `impl<A, B> for C<B> in D<A>`\n-                    err.span_label(trait_span, &msg);\n+                    err.span_label(trait_span, msg);\n                 }\n             }\n             err.note(\"define and implement a trait or new type instead\");\n@@ -531,15 +531,15 @@ fn lint_auto_trait_impl<'tcx>(\n             let self_descr = tcx.def_descr(self_type_did);\n             match arg {\n                 ty::util::NotUniqueParam::DuplicateParam(arg) => {\n-                    lint.note(&format!(\"`{}` is mentioned multiple times\", arg));\n+                    lint.note(format!(\"`{}` is mentioned multiple times\", arg));\n                 }\n                 ty::util::NotUniqueParam::NotParam(arg) => {\n-                    lint.note(&format!(\"`{}` is not a generic parameter\", arg));\n+                    lint.note(format!(\"`{}` is not a generic parameter\", arg));\n                 }\n             }\n             lint.span_note(\n                 item_span,\n-                &format!(\n+                format!(\n                     \"try using the same sequence of generic parameters as the {} definition\",\n                     self_descr,\n                 ),"}, {"sha": "2e5d058c6ed4db6f9dc2e7fb3d04cc294d0568fa", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -987,7 +987,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                                         lifetime.ident\n                                     ),\n                                     |lint| {\n-                                        let help = &format!(\n+                                        let help = format!(\n                                             \"you can use the `'static` lifetime directly, in place of `{}`\",\n                                             lifetime.ident,\n                                         );\n@@ -1365,7 +1365,7 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n \n         self.tcx.sess.delay_span_bug(\n             lifetime_ref.ident.span,\n-            &format!(\"Could not resolve {:?} in scope {:#?}\", lifetime_ref, self.scope,),\n+            format!(\"Could not resolve {:?} in scope {:#?}\", lifetime_ref, self.scope,),\n         );\n     }\n "}, {"sha": "c20fbfd1e40800e498ca7c88185fe6c3d5fc6389", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -828,14 +828,14 @@ fn infer_placeholder_type<'a>(\n                 if let Some(ty) = ty.make_suggestable(tcx, false) {\n                     err.span_suggestion(\n                         span,\n-                        &format!(\"provide a type for the {item}\", item = kind),\n+                        format!(\"provide a type for the {item}\", item = kind),\n                         format!(\"{colon} {ty}\"),\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n                     with_forced_trimmed_paths!(err.span_note(\n                         tcx.hir().body(body_id).value.span,\n-                        &format!(\"however, the inferred type `{ty}` cannot be named\"),\n+                        format!(\"however, the inferred type `{ty}` cannot be named\"),\n                     ));\n                 }\n             }\n@@ -856,7 +856,7 @@ fn infer_placeholder_type<'a>(\n                 } else {\n                     with_forced_trimmed_paths!(diag.span_note(\n                         tcx.hir().body(body_id).value.span,\n-                        &format!(\"however, the inferred type `{ty}` cannot be named\"),\n+                        format!(\"however, the inferred type `{ty}` cannot be named\"),\n                     ));\n                 }\n             }"}, {"sha": "f070b4f9bae736fb191ff713eaa60e188d590aad", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -76,7 +76,7 @@ fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n         // (#36836)\n         tcx.sess.delay_span_bug(\n             tcx.def_span(impl_def_id),\n-            &format!(\n+            format!(\n                 \"potentially unconstrained type parameters weren't evaluated: {:?}\",\n                 impl_self_ty,\n             ),"}, {"sha": "5cca2dacb5c7f730321b8b00daa53868d3b8f128", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -272,7 +272,7 @@ fn check_duplicate_params<'tcx>(\n     if let (_, [duplicate, ..]) = base_params.partition_dedup() {\n         let param = impl1_substs[duplicate.0 as usize];\n         tcx.sess\n-            .struct_span_err(span, &format!(\"specializing impl repeats parameter `{}`\", param))\n+            .struct_span_err(span, format!(\"specializing impl repeats parameter `{}`\", param))\n             .emit();\n     }\n }\n@@ -464,7 +464,7 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n                 tcx.sess\n                     .struct_span_err(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"cannot specialize on trait `{}`\",\n                             tcx.def_path_str(trait_ref.def_id),\n                         ),\n@@ -479,7 +479,7 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n             tcx.sess\n                 .struct_span_err(\n                     span,\n-                    &format!(\"cannot specialize on associated type `{projection_ty} == {term}`\",),\n+                    format!(\"cannot specialize on associated type `{projection_ty} == {term}`\",),\n                 )\n                 .emit();\n         }\n@@ -495,7 +495,7 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n         }\n         _ => {\n             tcx.sess\n-                .struct_span_err(span, &format!(\"cannot specialize on predicate `{}`\", predicate))\n+                .struct_span_err(span, format!(\"cannot specialize on predicate `{}`\", predicate))\n                 .emit();\n         }\n     }"}, {"sha": "42612eed7508b4bc506dc873aae02bb4dc1f4719", "filename": "compiler/rustc_hir_analysis/src/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -61,7 +61,7 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[(ty::Clau\n \n                     let span = tcx.def_span(item_def_id);\n                     let mut err = tcx.sess.struct_span_err(span, \"rustc_outlives\");\n-                    for p in &pred {\n+                    for p in pred {\n                         err.note(p);\n                     }\n                     err.emit();"}, {"sha": "c37dff61b727a606d6aae049e830500707805cf2", "filename": "compiler/rustc_hir_analysis/src/structured_errors/missing_cast_for_variadic_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> StructuredDiagnostic<'tcx> for MissingCastForVariadicArg<'tcx, '_> {\n         &self,\n         mut err: DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        err.note(&format!(\n+        err.note(format!(\n             \"certain types, like `{}`, must be casted before passing them to a \\\n                 variadic function, because of arcane ABI rules dictated by the C \\\n                 standard\","}, {"sha": "6d1a1634ab4e82f943d73c24ab85ecf2db01ae40", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -480,7 +480,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         let span = self.path_segment.ident.span;\n         let msg = self.create_error_message();\n \n-        self.tcx.sess.struct_span_err_with_code(span, &msg, self.code())\n+        self.tcx.sess.struct_span_err_with_code(span, msg, self.code())\n     }\n \n     /// Builds the `expected 1 type argument / supplied 2 type arguments` message.\n@@ -602,7 +602,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n                 err.span_suggestion_verbose(\n                     span.shrink_to_hi(),\n-                    &msg,\n+                    msg,\n                     sugg,\n                     Applicability::HasPlaceholders,\n                 );\n@@ -625,7 +625,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n                 let sugg = format!(\"{}{}{}\", sugg_prefix, suggested_args, sugg_suffix);\n                 debug!(\"sugg: {:?}\", sugg);\n \n-                err.span_suggestion_verbose(sugg_span, &msg, sugg, Applicability::HasPlaceholders);\n+                err.span_suggestion_verbose(sugg_span, msg, sugg, Applicability::HasPlaceholders);\n             }\n             AngleBrackets::Implied => {\n                 // We never encounter missing lifetimes in situations in which lifetimes are elided\n@@ -652,7 +652,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n                 err.span_suggestion_verbose(\n                     span.shrink_to_hi(),\n-                    &msg,\n+                    msg,\n                     sugg,\n                     Applicability::HasPlaceholders,\n                 );\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n                 let sugg = format!(\"{}{}{}\", sugg_prefix, suggested_args, sugg_suffix);\n                 debug!(\"sugg: {:?}\", sugg);\n \n-                err.span_suggestion_verbose(sugg_span, &msg, sugg, Applicability::HasPlaceholders);\n+                err.span_suggestion_verbose(sugg_span, msg, sugg, Applicability::HasPlaceholders);\n             }\n         }\n     }\n@@ -885,7 +885,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n             err.span_suggestion(\n                 span_redundant_lt_args,\n-                &msg_lifetimes,\n+                msg_lifetimes,\n                 \"\",\n                 Applicability::MaybeIncorrect,\n             );\n@@ -927,7 +927,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n             err.span_suggestion(\n                 span_redundant_type_or_const_args,\n-                &msg_types_or_consts,\n+                msg_types_or_consts,\n                 \"\",\n                 Applicability::MaybeIncorrect,\n             );\n@@ -943,7 +943,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n             if !suggestions.is_empty() {\n                 err.multipart_suggestion_verbose(\n-                    &format!(\n+                    format!(\n                         \"replace the generic bound{s} with the associated type{s}\",\n                         s = pluralize!(unbound_types.len())\n                     ),\n@@ -969,7 +969,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n                 },\n             );\n \n-            err.span_suggestion(span, &msg, \"\", Applicability::MaybeIncorrect);\n+            err.span_suggestion(span, msg, \"\", Applicability::MaybeIncorrect);\n         } else if redundant_lifetime_args && redundant_type_or_const_args {\n             remove_lifetime_args(err);\n             remove_type_or_const_args(err);\n@@ -1029,7 +1029,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n             )\n         };\n \n-        err.span_note(spans, &msg);\n+        err.span_note(spans, msg);\n     }\n \n     /// Add note if `impl Trait` is explicitly specified."}, {"sha": "7d2f7e876083a7d2e6ddbc09b30b07da9142ee31", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -271,7 +271,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             &cause,\n             &mut |err| {\n                 if let Some((span, msg)) = &ret_reason {\n-                    err.span_label(*span, msg);\n+                    err.span_label(*span, msg.clone());\n                 } else if let ExprKind::Block(block, _) = &then_expr.kind\n                     && let Some(expr) = &block.expr\n                 {"}, {"sha": "655ab94eb48d1336afedf2763690df32a11911b3", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .sess\n                             .struct_span_err(\n                                 callee_expr.span,\n-                                &format!(\"evaluate({:?}) = {:?}\", predicate, result),\n+                                format!(\"evaluate({:?}) = {:?}\", predicate, result),\n                             )\n                             .span_label(predicate_span, \"predicate\")\n                             .emit();\n@@ -630,7 +630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some((removal_span, kind, path)) = &unit_variant {\n             err.span_suggestion_verbose(\n                 *removal_span,\n-                &format!(\n+                format!(\n                     \"`{path}` is a unit {kind}, and does not take parentheses to be constructed\",\n                 ),\n                 \"\","}, {"sha": "a92f368e0830e2c5583a3a709e3ba20e5adf01af", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let reported = self\n                     .tcx\n                     .sess\n-                    .delay_span_bug(span, &format!(\"`{:?}` should be sized but is not?\", t));\n+                    .delay_span_bug(span, format!(\"`{:?}` should be sized but is not?\", t));\n                 return Err(reported);\n             }\n         })\n@@ -270,7 +270,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     fcx,\n                 );\n                 if self.cast_ty.is_integral() {\n-                    err.help(&format!(\n+                    err.help(format!(\n                         \"cast through {} first\",\n                         match e {\n                             CastError::NeedViaPtr => \"a raw pointer\",\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     self.cast_ty,\n                     fcx,\n                 )\n-                .help(&format!(\n+                .help(format!(\n                     \"cast through {} first\",\n                     match e {\n                         CastError::NeedViaInt => \"an integer\",\n@@ -651,13 +651,13 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                             );\n                         }\n                         Err(_) => {\n-                            let msg = &format!(\"did you mean `&{}{}`?\", mtstr, tstr);\n+                            let msg = format!(\"did you mean `&{}{}`?\", mtstr, tstr);\n                             err.span_help(self.cast_span, msg);\n                         }\n                     }\n                 } else {\n                     let msg =\n-                        &format!(\"consider using an implicit coercion to `&{mtstr}{tstr}` instead\");\n+                        format!(\"consider using an implicit coercion to `&{mtstr}{tstr}` instead\");\n                     err.span_help(self.span, msg);\n                 }\n             }\n@@ -674,7 +674,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     Err(_) => {\n                         err.span_help(\n                             self.cast_span,\n-                            &format!(\"you might have meant `Box<{tstr}>`\"),\n+                            format!(\"you might have meant `Box<{tstr}>`\"),\n                         );\n                     }\n                 }"}, {"sha": "1a3a14c92a5374591a18c2361e5c5e30b56bab4a", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -707,9 +707,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 &self.tcx.sess.parse_sess,\n                 sym::trait_upcasting,\n                 self.cause.span,\n-                &format!(\"cannot cast `{sub}` to `{sup}`, trait upcasting coercion is experimental\"),\n+                format!(\"cannot cast `{sub}` to `{sup}`, trait upcasting coercion is experimental\"),\n             );\n-            err.note(&format!(\"required when coercing `{source}` into `{target}`\"));\n+            err.note(format!(\"required when coercing `{source}` into `{target}`\"));\n             err.emit();\n         }\n \n@@ -1657,7 +1657,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             \"the function expects a value to always be returned, but loops might run zero times\",\n         );\n         if MAXITER < ret_exprs.len() {\n-            err.note(&format!(\n+            err.note(format!(\n                 \"if the loop doesn't execute, {} other values would never get returned\",\n                 ret_exprs.len() - MAXITER\n             ));\n@@ -1767,7 +1767,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         {\n             err.span_note(\n                 sp,\n-                &format!(\n+                format!(\n                     \"return type inferred to be `{}` here\",\n                     expected\n                 ),\n@@ -1864,7 +1864,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     Applicability::MaybeIncorrect,\n                 );\n             } else {\n-                err.help(&format!(\n+                err.help(format!(\n                     \"if the trait `{}` were object safe, you could return a boxed trait object\",\n                     &snippet[5..]\n                 ));"}, {"sha": "ee81ea345a64ebd5da505f6badc5801b337814a9", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -543,13 +543,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // We are pointing at the binding's type or initializer value, but it's pattern\n                     // is in a different line, so we point at both.\n                     err.span_label(secondary_span, \"expected due to the type of this binding\");\n-                    err.span_label(primary_span, &format!(\"expected due to this{post_message}\"));\n+                    err.span_label(primary_span, format!(\"expected due to this{post_message}\"));\n                 } else if post_message == \"\" {\n                     // We are pointing at either the assignment lhs or the binding def pattern.\n                     err.span_label(primary_span, \"expected due to the type of this binding\");\n                 } else {\n                     // We are pointing at the binding's type or initializer value.\n-                    err.span_label(primary_span, &format!(\"expected due to this{post_message}\"));\n+                    err.span_label(primary_span, format!(\"expected due to this{post_message}\"));\n                 }\n \n                 if !lhs.is_syntactic_place_expr() {\n@@ -566,7 +566,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) if rhs.hir_id == expr.hir_id\n                 && self.typeck_results.borrow().expr_ty_adjusted_opt(lhs) == Some(expected) =>\n             {\n-                err.span_label(lhs.span, &format!(\"expected because this is `{expected}`\"));\n+                err.span_label(lhs.span, format!(\"expected because this is `{expected}`\"));\n             }\n             _ => {}\n         }\n@@ -704,19 +704,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n         err.span_note(\n             path_span,\n-            &format!(\n+            format!(\n                 \"the `{}` call is resolved to the method in `{container}`, shadowing {tail}\",\n                 path.ident,\n             ),\n         );\n         if suggestions.len() > other_methods_in_scope.len() {\n-            err.note(&format!(\n+            err.note(format!(\n                 \"additionally, there are {} other available methods that aren't in scope\",\n                 suggestions.len() - other_methods_in_scope.len()\n             ));\n         }\n         err.multipart_suggestions(\n-            &format!(\n+            format!(\n                 \"you might have meant to call {}; you can use the fully-qualified path to call {} \\\n                  explicitly\",\n                 if suggestions.len() == 1 {\n@@ -941,7 +941,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 [(variant, ctor_kind, field_name, note)] => {\n                     // Just a single matching variant.\n                     err.multipart_suggestion_verbose(\n-                        &format!(\n+                        format!(\n                             \"try wrapping the expression in `{variant}`{note}\",\n                             note = note.as_deref().unwrap_or(\"\")\n                         ),\n@@ -953,7 +953,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => {\n                     // More than one matching variant.\n                     err.multipart_suggestions(\n-                        &format!(\n+                        format!(\n                             \"try wrapping the expression in a variant of `{}`\",\n                             self.tcx.def_path_str(expected_adt.did())\n                         ),\n@@ -1726,19 +1726,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ];\n                     (msg, suggestion)\n                 } else {\n-                    let msg = format!(\"{msg} and panic if the converted value doesn't fit\");\n+                    let msg =\n+                        format!(\"{} and panic if the converted value doesn't fit\", msg.clone());\n                     let mut suggestion = sugg.clone();\n                     suggestion.push((\n                         expr.span.shrink_to_hi(),\n                         format!(\"{close_paren}.try_into().unwrap()\"),\n                     ));\n                     (msg, suggestion)\n                 };\n-                err.multipart_suggestion_verbose(\n-                    &msg,\n-                    suggestion,\n-                    Applicability::MachineApplicable,\n-                );\n+                err.multipart_suggestion_verbose(msg, suggestion, Applicability::MachineApplicable);\n             };\n \n         let suggest_to_change_suffix_or_into =\n@@ -1755,21 +1752,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let always_fallible = found_to_exp_is_fallible\n                     && (exp_to_found_is_fallible || expected_ty_expr.is_none());\n                 let msg = if literal_is_ty_suffixed(expr) {\n-                    &lit_msg\n+                    lit_msg.clone()\n                 } else if always_fallible && (is_negative_int(expr) && is_uint(expected_ty)) {\n                     // We now know that converting either the lhs or rhs is fallible. Before we\n                     // suggest a fallible conversion, check if the value can never fit in the\n                     // expected type.\n                     let msg = format!(\"`{src}` cannot fit into type `{expected_ty}`\");\n-                    err.note(&msg);\n+                    err.note(msg);\n                     return;\n                 } else if in_const_context {\n                     // Do not recommend `into` or `try_into` in const contexts.\n                     return;\n                 } else if found_to_exp_is_fallible {\n                     return suggest_fallible_into_or_lhs_from(err, exp_to_found_is_fallible);\n                 } else {\n-                    &msg\n+                    msg.clone()\n                 };\n                 let suggestion = if literal_is_ty_suffixed(expr) {\n                     suffix_suggestion.clone()\n@@ -1831,14 +1828,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     suggest_to_change_suffix_or_into(err, false, true);\n                 } else if literal_is_ty_suffixed(expr) {\n                     err.multipart_suggestion_verbose(\n-                        &lit_msg,\n+                        lit_msg,\n                         suffix_suggestion,\n                         Applicability::MachineApplicable,\n                     );\n                 } else if can_cast {\n                     // Missing try_into implementation for `f64` to `f32`\n                     err.multipart_suggestion_verbose(\n-                        &format!(\"{cast_msg}, producing the closest possible value\"),\n+                        format!(\"{cast_msg}, producing the closest possible value\"),\n                         cast_suggestion,\n                         Applicability::MaybeIncorrect, // lossy conversion\n                     );\n@@ -1848,14 +1845,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (&ty::Uint(_) | &ty::Int(_), &ty::Float(_)) => {\n                 if literal_is_ty_suffixed(expr) {\n                     err.multipart_suggestion_verbose(\n-                        &lit_msg,\n+                        lit_msg,\n                         suffix_suggestion,\n                         Applicability::MachineApplicable,\n                     );\n                 } else if can_cast {\n                     // Missing try_into implementation for `{float}` to `{integer}`\n                     err.multipart_suggestion_verbose(\n-                        &format!(\"{msg}, rounding the float towards zero\"),\n+                        format!(\"{msg}, rounding the float towards zero\"),\n                         cast_suggestion,\n                         Applicability::MaybeIncorrect, // lossy conversion\n                     );\n@@ -1866,22 +1863,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n                 if exp.bit_width() > found.bit_width().unwrap_or(256) {\n                     err.multipart_suggestion_verbose(\n-                        &format!(\n+                        format!(\n                             \"{msg}, producing the floating point representation of the integer\",\n                         ),\n                         into_suggestion,\n                         Applicability::MachineApplicable,\n                     );\n                 } else if literal_is_ty_suffixed(expr) {\n                     err.multipart_suggestion_verbose(\n-                        &lit_msg,\n+                        lit_msg,\n                         suffix_suggestion,\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n                     // Missing try_into implementation for `{integer}` to `{float}`\n                     err.multipart_suggestion_verbose(\n-                        &format!(\n+                        format!(\n                             \"{cast_msg}, producing the floating point representation of the integer, \\\n                                  rounded if necessary\",\n                         ),\n@@ -1895,23 +1892,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n                 if exp.bit_width() > found.bit_width().unwrap_or(256) {\n                     err.multipart_suggestion_verbose(\n-                        &format!(\n+                        format!(\n                             \"{}, producing the floating point representation of the integer\",\n-                            &msg,\n+                            msg.clone(),\n                         ),\n                         into_suggestion,\n                         Applicability::MachineApplicable,\n                     );\n                 } else if literal_is_ty_suffixed(expr) {\n                     err.multipart_suggestion_verbose(\n-                        &lit_msg,\n+                        lit_msg,\n                         suffix_suggestion,\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n                     // Missing try_into implementation for `{integer}` to `{float}`\n                     err.multipart_suggestion_verbose(\n-                        &format!(\n+                        format!(\n                             \"{}, producing the floating point representation of the integer, \\\n                                 rounded if necessary\",\n                             &msg,\n@@ -1928,7 +1925,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &ty::Char,\n             ) => {\n                 err.multipart_suggestion_verbose(\n-                    &format!(\"{cast_msg}, since a `char` always occupies 4 bytes\"),\n+                    format!(\"{cast_msg}, since a `char` always occupies 4 bytes\"),\n                     cast_suggestion,\n                     Applicability::MachineApplicable,\n                 );"}, {"sha": "778ef06d57e20d61cdd1ebe3d499f40a5ae2392b", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1944,12 +1944,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         private_fields: Vec<&ty::FieldDef>,\n         used_fields: &'tcx [hir::ExprField<'tcx>],\n     ) {\n-        let mut err = self.tcx.sess.struct_span_err(\n-            span,\n-            &format!(\n-                \"cannot construct `{adt_ty}` with struct literal syntax due to private fields\",\n-            ),\n-        );\n+        let mut err =\n+            self.tcx.sess.struct_span_err(\n+                span,\n+                format!(\n+                    \"cannot construct `{adt_ty}` with struct literal syntax due to private fields\",\n+                ),\n+            );\n         let (used_private_fields, remaining_private_fields): (\n             Vec<(Symbol, Span, bool)>,\n             Vec<(Symbol, Span, bool)>,\n@@ -2045,7 +2046,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_label(field.ident.span, \"field does not exist\");\n                     err.span_suggestion_verbose(\n                         expr_span,\n-                        &format!(\n+                        format!(\n                             \"`{adt}::{variant}` is a tuple {kind_name}, use the appropriate syntax\",\n                             adt = ty,\n                             variant = variant.name,\n@@ -2063,7 +2064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_label(field.ident.span, \"field does not exist\");\n                     err.span_suggestion_verbose(\n                         expr_span,\n-                        &format!(\n+                        format!(\n                             \"`{adt}` is a tuple {kind_name}, use the appropriate syntax\",\n                             adt = ty,\n                             kind_name = kind_name,\n@@ -2105,7 +2106,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let available_field_names =\n                                 self.available_field_names(variant, expr_span);\n                             if !available_field_names.is_empty() {\n-                                err.note(&format!(\n+                                err.note(format!(\n                                     \"available fields are: {}\",\n                                     self.name_series_display(available_field_names)\n                                 ));\n@@ -2384,7 +2385,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n         if add_label {\n-            err.span_label(field_ident.span, &format!(\"field not found in `{ty}`\"));\n+            err.span_label(field_ident.span, format!(\"field not found in `{ty}`\"));\n         }\n     }\n \n@@ -2565,7 +2566,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let param_span = self.tcx.hir().span(param_hir_id);\n         let param_name = self.tcx.hir().ty_param_name(param_def_id.expect_local());\n \n-        err.span_label(param_span, &format!(\"type parameter '{param_name}' declared here\"));\n+        err.span_label(param_span, format!(\"type parameter '{param_name}' declared here\"));\n     }\n \n     fn suggest_fields_on_recordish(\n@@ -2589,7 +2590,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let struct_variant_def = def.non_enum_variant();\n             let field_names = self.available_field_names(struct_variant_def, access_span);\n             if !field_names.is_empty() {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"available fields are: {}\",\n                     self.name_series_display(field_names),\n                 ));\n@@ -2630,7 +2631,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n             let msg = format!(\"`{base}` is a raw pointer; try dereferencing it\");\n             let suggestion = format!(\"(*{base}).{field}\");\n-            err.span_suggestion(expr.span, &msg, suggestion, Applicability::MaybeIncorrect);\n+            err.span_suggestion(expr.span, msg, suggestion, Applicability::MaybeIncorrect);\n         }\n     }\n "}, {"sha": "cbedbad1f3864ce527e3006d1280a857fe9fb2c6", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -63,9 +63,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     lint::builtin::UNREACHABLE_CODE,\n                     id,\n                     span,\n-                    &msg,\n+                    msg.clone(),\n                     |lint| {\n-                        lint.span_label(span, &msg).span_label(\n+                        lint.span_label(span, msg).span_label(\n                             orig_span,\n                             custom_note\n                                 .unwrap_or(\"any code following this expression is unreachable\"),\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     _ => {\n                         self.tcx.sess.delay_span_bug(\n                             expr.span,\n-                            &format!(\n+                            format!(\n                                 \"while adjusting {:?}, can't compose {:?} and {:?}\",\n                                 expr,\n                                 entry.get(),\n@@ -1034,15 +1034,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 rcvr.span,\n                 \"you probably want to use this value after calling the method...\",\n             );\n-            err.span_note(sp, &modifies_rcvr_note);\n-            err.note(&format!(\"...instead of the `()` output of method `{}`\", path_segment.ident));\n+            err.span_note(sp, modifies_rcvr_note);\n+            err.note(format!(\"...instead of the `()` output of method `{}`\", path_segment.ident));\n         } else if let ExprKind::MethodCall(..) = rcvr.kind {\n             err.span_note(\n                 sp,\n                 modifies_rcvr_note.clone() + \", it is not meant to be used in method chains.\",\n             );\n         } else {\n-            err.span_note(sp, &modifies_rcvr_note);\n+            err.span_note(sp, modifies_rcvr_note);\n         }\n     }\n \n@@ -1374,7 +1374,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Err(_) => {\n                     self.tcx.sess.delay_span_bug(\n                         span,\n-                        &format!(\n+                        format!(\n                         \"instantiate_value_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n                         self_ty,\n                         impl_ty,"}, {"sha": "1e82161d9f7b265e5ed4897c98d4f30ae2f74931", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -685,7 +685,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     } else {\n                         err = tcx.sess.struct_span_err_with_code(\n                             full_call_span,\n-                            &format!(\n+                            format!(\n                                 \"{call_name} takes {}{} but {} {} supplied\",\n                                 if c_variadic { \"at least \" } else { \"\" },\n                                 potentially_plural_count(\n@@ -828,7 +828,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             tcx.sess.struct_span_err_with_code(\n                 full_call_span,\n-                &format!(\n+                format!(\n                     \"this {} takes {}{} but {} {} supplied\",\n                     call_name,\n                     if c_variadic { \"at least \" } else { \"\" },\n@@ -1203,7 +1203,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             SuggestionText::Remove(plural) => {\n                 err.multipart_suggestion(\n-                    &format!(\"remove the extra argument{}\", if plural { \"s\" } else { \"\" }),\n+                    format!(\"remove the extra argument{}\", if plural { \"s\" } else { \"\" }),\n                     suggestions,\n                     Applicability::HasPlaceholders,\n                 );\n@@ -1253,7 +1253,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             suggestion += \")\";\n             err.span_suggestion_verbose(\n                 suggestion_span,\n-                &suggestion_text,\n+                suggestion_text,\n                 suggestion,\n                 Applicability::HasPlaceholders,\n             );\n@@ -1947,7 +1947,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 spans.push_span_label(param.span, \"\");\n             }\n \n-            err.span_note(spans, &format!(\"{} defined here\", self.tcx.def_descr(def_id)));\n+            err.span_note(spans, format!(\"{} defined here\", self.tcx.def_descr(def_id)));\n         } else if let Some(hir::Node::Expr(e)) = self.tcx.hir().get_if_local(def_id)\n             && let hir::ExprKind::Closure(hir::Closure { body, .. }) = &e.kind\n         {\n@@ -1958,11 +1958,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 (\"closure\", self.tcx.def_span(def_id))\n             };\n-            err.span_note(span, &format!(\"{} defined here\", kind));\n+            err.span_note(span, format!(\"{} defined here\", kind));\n         } else {\n             err.span_note(\n                 self.tcx.def_span(def_id),\n-                &format!(\"{} defined here\", self.tcx.def_descr(def_id)),\n+                format!(\"{} defined here\", self.tcx.def_descr(def_id)),\n             );\n         }\n     }"}, {"sha": "7c75bf00c02f8c368fbba281fc759a6527a0b67c", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -278,9 +278,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.check_ref(expr, found, expected)\n         {\n             if verbose {\n-                err.span_suggestion_verbose(sp, &msg, suggestion, applicability);\n+                err.span_suggestion_verbose(sp, msg, suggestion, applicability);\n             } else {\n-                err.span_suggestion(sp, &msg, suggestion, applicability);\n+                err.span_suggestion(sp, msg, suggestion, applicability);\n             }\n             if annotation {\n                 let suggest_annotation = match expr.peel_drop_temps().kind {\n@@ -1449,7 +1449,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         {\n             diag.span_note(\n                 callee_expr.span,\n-                &format!(\n+                format!(\n                     \"`{expected_ty}` does not implement `Clone`, so `{found_ty}` was cloned instead\"\n                 ),\n             );"}, {"sha": "8ab0bd535d6fd21c1418b537a15a4bbf8fe28c96", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -205,7 +205,7 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         if ty.has_infer() {\n             self.tcx.sess.delay_span_bug(\n                 self.tcx.hir().span(assignee_place.hir_id),\n-                &format!(\"inference variables in {ty}\"),\n+                format!(\"inference variables in {ty}\"),\n             );\n         } else if ty.needs_drop(self.tcx, self.param_env) {\n             self.places"}, {"sha": "019fb86f55c4c89ce944cf45d09cf9528f589283", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                     self.fcx\n                         .tcx\n                         .sess\n-                        .delay_span_bug(span, &format!(\"Encountered var {:?}\", unresolved_term));\n+                        .delay_span_bug(span, format!(\"Encountered var {:?}\", unresolved_term));\n                 } else {\n                     let note = format!(\n                         \"the type is part of the {} because of this {}\",\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                     self.fcx\n                         .tcx\n                         .sess\n-                        .delay_span_bug(expr.span, &format!(\"inference variables in {ty}\"));\n+                        .delay_span_bug(expr.span, format!(\"inference variables in {ty}\"));\n                     true\n                 } else {\n                     ty.needs_drop(self.fcx.tcx, self.fcx.param_env)"}, {"sha": "3c5eafd9484889b006e1be686820912e0f03be62", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -72,8 +72,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let from = unpack_option_like(tcx, from);\n             if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer(dl.instruction_address_space).size(&tcx) {\n                 struct_span_err!(tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n-                    .note(&format!(\"source type: {from}\"))\n-                    .note(&format!(\"target type: {to}\"))\n+                    .note(format!(\"source type: {from}\"))\n+                    .note(format!(\"target type: {to}\"))\n                     .help(\"cast with `as` to a pointer instead\")\n                     .emit();\n                 return;\n@@ -109,10 +109,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         or dependently-sized types\"\n         );\n         if from == to {\n-            err.note(&format!(\"`{from}` does not have a fixed size\"));\n+            err.note(format!(\"`{from}` does not have a fixed size\"));\n         } else {\n-            err.note(&format!(\"source type: `{}` ({})\", from, skeleton_string(from, sk_from)))\n-                .note(&format!(\"target type: `{}` ({})\", to, skeleton_string(to, sk_to)));\n+            err.note(format!(\"source type: `{}` ({})\", from, skeleton_string(from, sk_from)))\n+                .note(format!(\"target type: `{}` ({})\", to, skeleton_string(to, sk_to)));\n             let mut should_delay_as_bug = false;\n             if let Err(LayoutError::Unknown(bad_from)) = sk_from && bad_from.references_error() {\n                 should_delay_as_bug = true;"}, {"sha": "a2a4362e2f5184e8c278451492ca520b4cc7f4f4", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -448,7 +448,7 @@ fn fatally_break_rust(sess: &Session) {\n         \"we would appreciate a joke overview: \\\n          https://github.com/rust-lang/rust/issues/43162#issuecomment-320764675\",\n     );\n-    handler.note_without_error(&format!(\n+    handler.note_without_error(format!(\n         \"rustc {} running on {}\",\n         option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n         config::host_triple(),"}, {"sha": "ec4e7f7f88af517051cb3dcd39c19a82a4514bda", "filename": "compiler/rustc_hir_typeck/src/method/prelude2021.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n                         lint.span_help(\n                             sp,\n-                            &format!(\"disambiguate the method call with `({})`\", self_adjusted,),\n+                            format!(\"disambiguate the method call with `({})`\", self_adjusted,),\n                         );\n                     }\n \n@@ -180,7 +180,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     } else {\n                         lint.span_help(\n                             sp,\n-                            &format!(\n+                            format!(\n                                 \"disambiguate the associated function with `{}::{}(...)`\",\n                                 trait_name, segment.ident,\n                             ),"}, {"sha": "a0e978b0c1074b530e0ddc2a3f19a1fbd4e567f9", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1396,7 +1396,7 @@ impl<'tcx> Pick<'tcx> {\n                         // However `self.span` only\n                         // highlights the method name, so we can't use it. Also consider reusing\n                         // the code from `report_method_error()`.\n-                        lint.help(&format!(\n+                        lint.help(format!(\n                             \"call with fully qualified syntax `{}(...)` to keep using the current \\\n                              method\",\n                             tcx.def_path_str(self.item.def_id),\n@@ -1420,7 +1420,7 @@ impl<'tcx> Pick<'tcx> {\n                 }\n                 if tcx.sess.is_nightly_build() {\n                     for (candidate, feature) in &self.unstable_candidates {\n-                        lint.help(&format!(\n+                        lint.help(format!(\n                             \"add `#![feature({})]` to the crate attributes to enable `{}`\",\n                             feature,\n                             tcx.def_path_str(candidate.item.def_id),"}, {"sha": "b786348f89ea04ebc09d0ea3eca7599713539463", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -169,13 +169,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     kind,\n                     item_name\n                 );\n-                err.span_label(item_name.span, &format!(\"private {}\", kind));\n+                err.span_label(item_name.span, format!(\"private {}\", kind));\n                 let sp = self\n                     .tcx\n                     .hir()\n                     .span_if_local(def_id)\n                     .unwrap_or_else(|| self.tcx.def_span(def_id));\n-                err.span_label(sp, &format!(\"private {} defined here\", kind));\n+                err.span_label(sp, format!(\"private {} defined here\", kind));\n                 self.suggest_valid_traits(&mut err, out_of_scope_traits);\n                 err.emit();\n             }\n@@ -188,7 +188,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else {\n                     format!(\"the `{item_name}` method cannot be invoked on a trait object\")\n                 };\n-                let mut err = self.sess().struct_span_err(span, &msg);\n+                let mut err = self.sess().struct_span_err(span, msg);\n                 if !needs_mut {\n                     err.span_label(bound_span, \"this has a `Sized` requirement\");\n                 }\n@@ -228,12 +228,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         {\n                             err.span_suggestion_verbose(\n                                 mut_ty.ty.span.shrink_to_lo(),\n-                                &msg,\n+                                msg,\n                                 \"mut \",\n                                 Applicability::MachineApplicable,\n                             );\n                         } else {\n-                            err.help(&msg);\n+                            err.help(msg);\n                         }\n                     }\n                 }\n@@ -374,14 +374,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty_str\n         };\n         if let Some(file) = ty_file {\n-            err.note(&format!(\"the full type name has been written to '{}'\", file.display(),));\n+            err.note(format!(\"the full type name has been written to '{}'\", file.display(),));\n         }\n         if rcvr_ty.references_error() {\n             err.downgrade_to_delayed_bug();\n         }\n \n         if tcx.ty_is_opaque_future(rcvr_ty) && item_name.name == sym::poll {\n-            err.help(&format!(\n+            err.help(format!(\n                 \"method `poll` found on `Pin<&mut {ty_str}>`, \\\n                 see documentation for `std::pin::Pin`\"\n             ));\n@@ -510,7 +510,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             if let Some(iterator_trait) = self.tcx.get_diagnostic_item(sym::Iterator) {\n                 let iterator_trait = self.tcx.def_path_str(iterator_trait);\n-                err.note(&format!(\n+                err.note(format!(\n                     \"`count` is defined on `{iterator_trait}`, which `{rcvr_ty}` does not implement\"\n                 ));\n             }\n@@ -810,7 +810,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 for (sp, label) in span_labels {\n                     span.push_span_label(sp, label);\n                 }\n-                err.span_note(span, &msg);\n+                err.span_note(span, msg);\n                 unsatisfied_bounds = true;\n             }\n \n@@ -867,7 +867,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 obligations.sort();\n                 err.span_suggestion_verbose(\n                     span,\n-                    &format!(\n+                    format!(\n                         \"consider restricting the type parameter{s} to satisfy the \\\n                          trait bound{s}\",\n                         s = pluralize!(obligations.len())\n@@ -912,13 +912,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                          but its trait bounds were not satisfied\"\n                     )\n                 });\n-                err.set_primary_message(&primary_message);\n+                err.set_primary_message(primary_message);\n                 if let Some(label) = label {\n                     custom_span_label = true;\n                     err.span_label(span, label);\n                 }\n                 if !bound_list.is_empty() {\n-                    err.note(&format!(\n+                    err.note(format!(\n                         \"the following trait bounds were not satisfied:\\n{bound_list}\"\n                     ));\n                 }\n@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             \"\".to_string()\n                         };\n-                        err.note(&format!(\n+                        err.note(format!(\n                             \"the {item_kind} was found for\\n{}{}\",\n                             type_candidates, additional_types\n                         ));\n@@ -1049,7 +1049,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         bound_spans.sort();\n         bound_spans.dedup();\n         for (span, msg) in bound_spans.into_iter() {\n-            err.span_label(span, &msg);\n+            err.span_label(span, msg);\n         }\n \n         if rcvr_ty.is_numeric() && rcvr_ty.is_fresh() || restrict_type_params {\n@@ -1119,7 +1119,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else {\n                     err.span_suggestion(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"there is {} {} with a similar name\",\n                             self.tcx.def_kind_descr_article(def_kind, similar_candidate.def_id),\n                             self.tcx.def_kind_descr(def_kind, similar_candidate.def_id)\n@@ -1203,9 +1203,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     };\n                     if let Some(note_span) = note_span {\n                         // We have a span pointing to the method. Show note with snippet.\n-                        err.span_note(note_span, &note_str);\n+                        err.span_note(note_span, note_str);\n                     } else {\n-                        err.note(&note_str);\n+                        err.note(note_str);\n                     }\n                     if let Some(sugg_span) = sugg_span\n                         && let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n@@ -1243,15 +1243,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n                     let item_span = self.tcx.def_span(item.def_id);\n                     let idx = if sources.len() > 1 {\n-                        let msg = &format!(\n+                        let msg = format!(\n                             \"candidate #{} is defined in the trait `{}`\",\n                             idx + 1,\n                             self.tcx.def_path_str(trait_did)\n                         );\n                         err.span_note(item_span, msg);\n                         Some(idx + 1)\n                     } else {\n-                        let msg = &format!(\n+                        let msg = format!(\n                             \"the candidate is defined in the trait `{}`\",\n                             self.tcx.def_path_str(trait_did)\n                         );\n@@ -1278,7 +1278,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n         if sources.len() > limit {\n-            err.note(&format!(\"and {} others\", sources.len() - limit));\n+            err.note(format!(\"and {} others\", sources.len() - limit));\n         }\n     }\n \n@@ -1402,7 +1402,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 applicability,\n             );\n         } else {\n-            err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n+            err.help(format!(\"try with `{}::{}`\", ty_str, item_name,));\n         }\n     }\n \n@@ -1436,7 +1436,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if self.is_fn_ty(field_ty, span) {\n                     let expr_span = expr.span.to(item_name.span);\n                     err.multipart_suggestion(\n-                        &format!(\n+                        format!(\n                             \"to call the function stored in `{}`, \\\n                                          surround the field access with parentheses\",\n                             item_name,\n@@ -1612,7 +1612,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let snippet = snippet.strip_suffix('.').unwrap_or(&snippet);\n                     err.span_suggestion(\n                         lit.span,\n-                        &format!(\n+                        format!(\n                             \"you must specify a concrete type for this numeric value, \\\n                                          like `{}`\",\n                             concrete_type\n@@ -1648,7 +1648,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // account for `let x: _ = 42;`\n                                     //                   ^^^\n                                     type_span,\n-                                    &msg,\n+                                    msg,\n                                     format!(\": {concrete_type}\"),\n                                     Applicability::MaybeIncorrect,\n                                 );\n@@ -1861,7 +1861,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let self_ty = field.ty(tcx, substs);\n                         err.span_note(\n                             tcx.def_span(pick.item.def_id),\n-                            &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n+                            format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n                         );\n                         let (article, kind, variant, question) =\n                             if tcx.is_diagnostic_item(sym::Result, kind.did()) {\n@@ -1975,7 +1975,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 err.span_note(\n                     tcx.def_span(pick.item.def_id),\n-                    &format!(\"the method `{item_name}` exists on the type `{ty}`\"),\n+                    format!(\"the method `{item_name}` exists on the type `{ty}`\"),\n                 );\n             }\n         }\n@@ -2046,7 +2046,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     pluralize!(preds.len()),\n                 )\n             };\n-            err.span_note(spans, &msg);\n+            err.span_note(spans, msg);\n         }\n \n         let preds: Vec<_> = errors\n@@ -2160,14 +2160,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             err.span_note(\n                 span,\n-                &format!(\"the trait{} {} must be implemented\", pluralize!(len), names),\n+                format!(\"the trait{} {} must be implemented\", pluralize!(len), names),\n             );\n         }\n \n         for (self_name, self_span, traits) in &derives_grouped {\n             err.span_suggestion_verbose(\n                 self_span.shrink_to_lo(),\n-                &format!(\"consider annotating `{}` with `#[derive({})]`\", self_name, traits),\n+                format!(\"consider annotating `{}` with `#[derive({})]`\", self_name, traits),\n                 format!(\"#[derive({})]\\n\", traits),\n                 Applicability::MaybeIncorrect,\n             );\n@@ -2313,7 +2313,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         err.span_suggestions(\n             span,\n-            &msg,\n+            msg,\n             path_strings.chain(glob_path_strings),\n             Applicability::MaybeIncorrect,\n         );\n@@ -2345,7 +2345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             self.suggest_use_candidates(err, msg, candidates);\n             if let Some(did) = edition_fix {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"'{}' is included in the prelude starting in Edition 2021\",\n                     with_crate_prefix!(self.tcx.def_path_str(did))\n                 ));\n@@ -2413,7 +2413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if pick.autoderefs == 0 && !skip {\n                             err.span_label(\n                                 pick.item.ident(self.tcx).span,\n-                                &format!(\"the method is available for `{}` here\", rcvr_ty),\n+                                format!(\"the method is available for `{}` here\", rcvr_ty),\n                             );\n                         }\n                         break;\n@@ -2459,7 +2459,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if pick.autoderefs == 0 && !skip {\n                             err.span_label(\n                                 pick.item.ident(self.tcx).span,\n-                                &format!(\"the method is available for `{}` here\", new_rcvr_t),\n+                                format!(\"the method is available for `{}` here\", new_rcvr_t),\n                             );\n                             err.multipart_suggestion(\n                                 \"consider wrapping the receiver expression with the \\\n@@ -2655,7 +2655,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             if !candidates.iter().any(|t| trait_def_ids.contains(&t.def_id)) {\n                                 err.span_suggestions(\n                                     sp,\n-                                    &message(format!(\n+                                    message(format!(\n                                         \"restrict type parameter `{}` with\",\n                                         param.name.ident(),\n                                     )),\n@@ -2687,7 +2687,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             };\n                             err.span_suggestions(\n                                 sp,\n-                                &message(format!(\"add {} supertrait for\", article)),\n+                                message(format!(\"add {} supertrait for\", article)),\n                                 candidates.iter().map(|t| {\n                                     format!(\"{} {}\", sep, self.tcx.def_path_str(t.def_id),)\n                                 }),\n@@ -2746,7 +2746,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 [trait_info] if trait_info.def_id.is_local() => {\n                     err.span_note(\n                         self.tcx.def_span(trait_info.def_id),\n-                        &format!(\n+                        format!(\n                             \"`{}` defines an item `{}`, perhaps you need to {} it\",\n                             self.tcx.def_path_str(trait_info.def_id),\n                             item_name,\n@@ -2763,7 +2763,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.tcx.def_path_str(trait_info.def_id),\n                         ));\n                     }\n-                    err.note(&msg);\n+                    err.note(msg);\n                 }\n             }\n             match &explicitly_negative[..] {\n@@ -2774,7 +2774,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.tcx.def_path_str(trait_info.def_id),\n                         item_name\n                     );\n-                    err.note(&msg);\n+                    err.note(msg);\n                 }\n                 trait_infos => {\n                     let mut msg = format!(\n@@ -2784,7 +2784,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     for trait_info in trait_infos {\n                         msg.push_str(&format!(\"\\n{}\", self.tcx.def_path_str(trait_info.def_id)));\n                     }\n-                    err.note(&msg);\n+                    err.note(msg);\n                 }\n             }\n         }\n@@ -2836,7 +2836,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 fn_args.len() == args.len() + 1 {\n                 err.span_suggestion_verbose(\n                     method_name.span.shrink_to_hi(),\n-                    &format!(\"try calling `{}` instead\", new_name.name.as_str()),\n+                    format!(\"try calling `{}` instead\", new_name.name.as_str()),\n                     \"_else\",\n                     Applicability::MaybeIncorrect,\n                 );\n@@ -2956,7 +2956,7 @@ fn print_disambiguation_help<'tcx>(\n     };\n     err.span_suggestion_verbose(\n         span,\n-        &format!(\n+        format!(\n             \"disambiguate the {} for {}\",\n             def_kind_descr,\n             if let Some(candidate) = candidate {"}, {"sha": "af351a3fa10e84cd5480e8ef3e55dcdb65fe5940", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -390,7 +390,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         )\n                         .is_ok()\n                     {\n-                        let msg = &format!(\n+                        let msg = format!(\n                             \"`{}{}` can be used on `{}` if you dereference the left-hand side\",\n                             op.node.as_str(),\n                             match is_assign {\n@@ -515,7 +515,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             // When we know that a missing bound is responsible, we don't show\n                             // this note as it is redundant.\n-                            err.note(&format!(\n+                            err.note(format!(\n                                 \"the trait `{missing_trait}` is not implemented for `{lhs_ty}`\"\n                             ));\n                         }\n@@ -690,7 +690,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 {\n                                     err.span_suggestion(\n                                         ex.span,\n-                                        &format!(\n+                                        format!(\n                                             \"you may have meant the maximum value of `{actual}`\",\n                                         ),\n                                         format!(\"{actual}::MAX\"),"}, {"sha": "5af955d313482e25b0889d458b1181cbeddf8234", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -517,7 +517,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn endpoint_has_type(&self, err: &mut Diagnostic, span: Span, ty: Ty<'_>) {\n         if !ty.references_error() {\n-            err.span_label(span, &format!(\"this is of type `{}`\", ty));\n+            err.span_label(span, format!(\"this is of type `{}`\", ty));\n         }\n     }\n \n@@ -544,16 +544,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             format!(\"this is of type `{}` but it should be `char` or numeric\", ty)\n         };\n         let mut one_side_err = |first_span, first_ty, second: Option<(bool, Ty<'tcx>, Span)>| {\n-            err.span_label(first_span, &msg(first_ty));\n+            err.span_label(first_span, msg(first_ty));\n             if let Some((_, ty, sp)) = second {\n                 let ty = self.resolve_vars_if_possible(ty);\n                 self.endpoint_has_type(&mut err, sp, ty);\n             }\n         };\n         match (lhs, rhs) {\n             (Some((true, lhs_ty, lhs_sp)), Some((true, rhs_ty, rhs_sp))) => {\n-                err.span_label(lhs_sp, &msg(lhs_ty));\n-                err.span_label(rhs_sp, &msg(rhs_ty));\n+                err.span_label(lhs_sp, msg(lhs_ty));\n+                err.span_label(rhs_sp, msg(rhs_ty));\n             }\n             (Some((true, lhs_ty, lhs_sp)), rhs) => one_side_err(lhs_sp, lhs_ty, rhs),\n             (lhs, Some((true, rhs_ty, rhs_sp))) => one_side_err(rhs_sp, rhs_ty, lhs),\n@@ -651,7 +651,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 )\n             });\n             let pre = if in_match { \"in the same arm, \" } else { \"\" };\n-            err.note(&format!(\"{}a binding must have the same type in all alternatives\", pre));\n+            err.note(format!(\"{}a binding must have the same type in all alternatives\", pre));\n             self.suggest_adding_missing_ref_or_removing_ref(\n                 &mut err,\n                 span,\n@@ -958,11 +958,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let pat_span = pat.span;\n         if let Some(span) = self.tcx.hir().res_span(pat_res) {\n-            e.span_label(span, &format!(\"{} defined here\", res.descr()));\n+            e.span_label(span, format!(\"{} defined here\", res.descr()));\n             if let [hir::PathSegment { ident, .. }] = &*segments {\n                 e.span_label(\n                     pat_span,\n-                    &format!(\n+                    format!(\n                         \"`{}` is interpreted as {} {}, not a new binding\",\n                         ident,\n                         res.article(),\n@@ -1158,7 +1158,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         err.span_label(\n             last_subpat_span,\n-            &format!(\"expected {} field{}, found {}\", fields.len(), fields_ending, subpats.len()),\n+            format!(\"expected {} field{}, found {}\", fields.len(), fields_ending, subpats.len()),\n         );\n         if self.tcx.sess.source_map().is_multiline(qpath.span().between(last_subpat_span)) {\n             err.span_label(qpath.span(), \"\");\n@@ -1171,7 +1171,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         err.span_label(\n             last_field_def_span,\n-            &format!(\"{} has {} field{}\", res.descr(), fields.len(), fields_ending),\n+            format!(\"{} has {} field{}\", res.descr(), fields.len(), fields_ending),\n         );\n \n         // Identify the case `Some(x, y)` where the expected type is e.g. `Option<(T, U)>`.\n@@ -1641,7 +1641,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let unmentioned_field = unmentioned_fields[0].1.name;\n                             err.span_suggestion_short(\n                                 pat_field.ident.span,\n-                                &format!(\n+                                format!(\n                                     \"`{}` has a field named `{}`\",\n                                     tcx.def_path_str(variant.def_id),\n                                     unmentioned_field\n@@ -1831,7 +1831,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lint.help(\n             \"ensure that all fields are mentioned explicitly by adding the suggested fields\",\n         );\n-        lint.note(&format!(\n+        lint.note(format!(\n             \"the pattern is of type `{}` and the `non_exhaustive_omitted_patterns` attribute was found\",\n             ty,\n         ));\n@@ -1895,7 +1895,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         err.span_suggestion(\n             sp,\n-            &format!(\n+            format!(\n                 \"include the missing field{} in the pattern{}\",\n                 pluralize!(len),\n                 if have_inaccessible_fields { \" and ignore the inaccessible fields\" } else { \"\" }\n@@ -1922,7 +1922,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         err.span_suggestion(\n             sp,\n-            &format!(\n+            format!(\n                 \"if you don't care about {these} missing field{s}, you can explicitly ignore {them}\",\n                 these = pluralize!(\"this\", len),\n                 s = pluralize!(len),"}, {"sha": "f217c5c1e1c98ee8aecb0286d8e7db8062e37d41", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -73,16 +73,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(ty);\n         let mut err = self.tcx.sess.struct_span_err(\n             span,\n-            &format!(\"negative integers cannot be used to index on a `{ty}`\"),\n+            format!(\"negative integers cannot be used to index on a `{ty}`\"),\n         );\n-        err.span_label(span, &format!(\"cannot use a negative integer for indexing on `{ty}`\"));\n+        err.span_label(span, format!(\"cannot use a negative integer for indexing on `{ty}`\"));\n         if let (hir::ExprKind::Path(..), Ok(snippet)) =\n             (&base_expr.kind, self.tcx.sess.source_map().span_to_snippet(base_expr.span))\n         {\n             // `foo[-1]` to `foo[foo.len() - 1]`\n             err.span_suggestion_verbose(\n                 span.shrink_to_lo(),\n-                &format!(\n+                format!(\n                     \"to access an element starting from the end of the `{ty}`, compute the index\",\n                 ),\n                 format!(\"{snippet}.len() \"),"}, {"sha": "543194ac9d67b895366a4d234ec3db034d0ef331", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -713,7 +713,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 self.tcx.sess.delay_span_bug(\n                     closure_span,\n-                    &format!(\n+                    format!(\n                         \"two identical projections: ({:?}, {:?})\",\n                         capture1.place.projections, capture2.place.projections\n                     ),\n@@ -863,7 +863,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let indent = line2.split_once(|c: char| !c.is_whitespace()).unwrap_or_default().0;\n                             lint.span_suggestion(\n                                 closure_body_span.with_lo(closure_body_span.lo() + BytePos::from_usize(line1.len())).shrink_to_lo(),\n-                                &diagnostic_msg,\n+                                diagnostic_msg,\n                                 format!(\"\\n{indent}{migration_string};\"),\n                                 Applicability::MachineApplicable,\n                             );\n@@ -874,15 +874,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // directly after the `{`.\n                             lint.span_suggestion(\n                                 closure_body_span.with_lo(closure_body_span.lo() + BytePos(1)).shrink_to_lo(),\n-                                &diagnostic_msg,\n+                                diagnostic_msg,\n                                 format!(\" {migration_string};\"),\n                                 Applicability::MachineApplicable,\n                             );\n                         } else {\n                             // This is a closure without braces around the body.\n                             // We add braces to add the `let` before the body.\n                             lint.multipart_suggestion(\n-                                &diagnostic_msg,\n+                                diagnostic_msg,\n                                 vec![\n                                     (closure_body_span.shrink_to_lo(), format!(\"{{ {migration_string}; \")),\n                                     (closure_body_span.shrink_to_hi(), \" }\".to_string()),\n@@ -893,7 +893,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     } else {\n                         lint.span_suggestion(\n                             closure_span,\n-                            &diagnostic_msg,\n+                            diagnostic_msg,\n                             migration_string,\n                             Applicability::HasPlaceholders\n                         );\n@@ -1519,7 +1519,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let span =\n                     capture_info.path_expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n-                diag.span_note(span, &output_str);\n+                diag.span_note(span, output_str);\n             }\n             diag.emit();\n         }\n@@ -1560,13 +1560,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             multi_span.push_span_label(path_span, path_label);\n                             multi_span.push_span_label(capture_kind_span, capture_kind_label);\n \n-                            diag.span_note(multi_span, &output_str);\n+                            diag.span_note(multi_span, output_str);\n                         } else {\n                             let span = capture_info\n                                 .path_expr_id\n                                 .map_or(closure_span, |e| self.tcx.hir().span(e));\n \n-                            diag.span_note(span, &output_str);\n+                            diag.span_note(span, output_str);\n                         };\n                     }\n                 }"}, {"sha": "cf95d4f04bb9229a341063713c9923910d7dcc28", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -227,7 +227,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 // When encountering `return [0][0]` outside of a `fn` body we can encounter a base\n                 // that isn't in the type table. We assume more relevant errors have already been\n                 // emitted, so we delay an ICE if none have. (#64638)\n-                self.tcx().sess.delay_span_bug(e.span, &format!(\"bad base: `{:?}`\", base));\n+                self.tcx().sess.delay_span_bug(e.span, format!(\"bad base: `{:?}`\", base));\n             }\n             if let Some(ty::Ref(_, base_ty, _)) = base_ty {\n                 let index_ty = typeck_results.expr_ty_adjusted_opt(index).unwrap_or_else(|| {\n@@ -491,7 +491,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     let err = self\n                         .tcx()\n                         .sess\n-                        .struct_span_err(span, &format!(\"user substs: {:?}\", user_substs));\n+                        .struct_span_err(span, format!(\"user substs: {:?}\", user_substs));\n                     err.buffer(&mut errors_buffer);\n                 }\n             }"}, {"sha": "d798202a644412fda94bbd866902fa2f9adfae96", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -205,7 +205,7 @@ impl CanonicalizeMode for CanonicalizeQueryResponse {\n                 // `delay_span_bug` to allow type error over an ICE.\n                 canonicalizer.tcx.sess.delay_span_bug(\n                     rustc_span::DUMMY_SP,\n-                    &format!(\"unexpected region in query response: `{:?}`\", r),\n+                    format!(\"unexpected region in query response: `{:?}`\", r),\n                 );\n                 r\n             }"}, {"sha": "c9e13be02ff9a69964b067de9ac8cd6b1d142ba2", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -192,7 +192,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             self.tcx.check_tys_might_be_eq(canonical).map_err(|_| {\n                 self.tcx.sess.delay_span_bug(\n                     DUMMY_SP,\n-                    &format!(\"cannot relate consts of different types (a={:?}, b={:?})\", a, b,),\n+                    format!(\"cannot relate consts of different types (a={:?}, b={:?})\", a, b,),\n                 )\n             })\n         });"}, {"sha": "98da5ba65b7b473de21fa04ab7f076551fdd55d1", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -282,9 +282,9 @@ fn emit_msg_span(\n     let message = format!(\"{}{}{}\", prefix, description, suffix);\n \n     if let Some(span) = span {\n-        err.span_note(span, &message);\n+        err.span_note(span, message);\n     } else {\n-        err.note(&message);\n+        err.note(message);\n     }\n }\n \n@@ -298,9 +298,9 @@ fn label_msg_span(\n     let message = format!(\"{}{}{}\", prefix, description, suffix);\n \n     if let Some(span) = span {\n-        err.span_label(span, &message);\n+        err.span_label(span, message);\n     } else {\n-        err.note(&message);\n+        err.note(message);\n     }\n }\n \n@@ -2395,7 +2395,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 );\n             } else {\n                 let consider = format!(\"{} `{}: {}`...\", msg, bound_kind, sub);\n-                err.help(&consider);\n+                err.help(consider);\n             }\n         }\n \n@@ -2625,7 +2625,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             );\n             err.span_note(\n                 sup_trace.cause.span,\n-                &format!(\"...so that the {}\", sup_trace.cause.as_requirement_str()),\n+                format!(\"...so that the {}\", sup_trace.cause.as_requirement_str()),\n             );\n \n             err.note_expected_found(&\"\", sup_expected, &\"\", sup_found);"}, {"sha": "aad9885827da56cbc64989ca5fc7dd54015a910f", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -299,7 +299,7 @@ pub fn suggest_new_region_bound(\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             span,\n-                            &format!(\"{consider} `{ty}`'s {explicit_static}\"),\n+                            format!(\"{consider} `{ty}`'s {explicit_static}\"),\n                             &lifetime_name,\n                             Applicability::MaybeIncorrect,\n                         );\n@@ -367,7 +367,7 @@ pub fn suggest_new_region_bound(\n                         spans_suggs\n                             .push((fn_return.span.shrink_to_hi(), format!(\" + {name} \")));\n                         err.multipart_suggestion_verbose(\n-                            &format!(\n+                            format!(\n                                 \"{declare} `{ty}` {captures}, {use_lt}\",\n                             ),\n                             spans_suggs,\n@@ -376,7 +376,7 @@ pub fn suggest_new_region_bound(\n                     } else {\n                         err.span_suggestion_verbose(\n                             fn_return.span.shrink_to_hi(),\n-                            &format!(\"{declare} `{ty}` {captures}, {explicit}\",),\n+                            format!(\"{declare} `{ty}` {captures}, {explicit}\",),\n                             &plus_lt,\n                             Applicability::MaybeIncorrect,\n                         );\n@@ -387,7 +387,7 @@ pub fn suggest_new_region_bound(\n                 if let LifetimeName::ImplicitObjectLifetimeDefault = lt.res {\n                     err.span_suggestion_verbose(\n                         fn_return.span.shrink_to_hi(),\n-                        &format!(\n+                        format!(\n                             \"{declare} the trait object {captures}, {explicit}\",\n                             declare = declare,\n                             captures = captures,\n@@ -404,7 +404,7 @@ pub fn suggest_new_region_bound(\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             lt.ident.span,\n-                            &format!(\"{} the trait object's {}\", consider, explicit_static),\n+                            format!(\"{} the trait object's {}\", consider, explicit_static),\n                             &lifetime_name,\n                             Applicability::MaybeIncorrect,\n                         );"}, {"sha": "a31163519404cca872ea1d500085b313bc2cc312", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -209,7 +209,7 @@ impl<T> Trait<T> for X {\n                         if !sp.contains(p_span) {\n                             diag.span_label(p_span, \"this type parameter\");\n                         }\n-                        diag.help(&format!(\n+                        diag.help(format!(\n                             \"every closure has a distinct type and so could not always match the \\\n                              caller-chosen type of parameter `{}`\",\n                             p\n@@ -248,7 +248,7 @@ impl<T> Trait<T> for X {\n                             proj_ty,\n                             values.expected,\n                         )) {\n-                            diag.help(&msg);\n+                            diag.help(msg);\n                             diag.note(\n                                 \"for more information, visit \\\n                                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n@@ -415,12 +415,12 @@ impl<T> Trait<T> for X {\n         if !impl_comparison {\n             // Generic suggestion when we can't be more specific.\n             if callable_scope {\n-                diag.help(&format!(\n+                diag.help(format!(\n                     \"{} or calling a method that returns `{}`\",\n                     msg, values.expected\n                 ));\n             } else {\n-                diag.help(&msg);\n+                diag.help(msg);\n             }\n             diag.note(\n                 \"for more information, visit \\\n@@ -536,7 +536,7 @@ fn foo(&self) -> Self::T { String::new() }\n             for (sp, label) in methods.into_iter() {\n                 span.push_span_label(sp, label);\n             }\n-            diag.span_help(span, &msg);\n+            diag.span_help(span, msg);\n             return true;\n         }\n         false"}, {"sha": "f1468cae455b5c7441239d1834ec2a3447273556", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -824,7 +824,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // resolution errors here; delay ICE in favor of those errors.\n         self.tcx().sess.delay_span_bug(\n             self.var_infos[node_idx].origin.span(),\n-            &format!(\n+            format!(\n                 \"collect_error_for_expanding_node() could not find \\\n                  error for var {:?} in universe {:?}, lower_bounds={:#?}, \\\n                  upper_bounds={:#?}\","}, {"sha": "a0f6d7ecab70fb3dad93b3d9be5e64271333380b", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> Drop for OpaqueTypeStorage<'tcx> {\n     fn drop(&mut self) {\n         if !self.opaque_types.is_empty() {\n             ty::tls::with(|tcx| {\n-                tcx.sess.delay_span_bug(DUMMY_SP, &format!(\"{:?}\", self.opaque_types))\n+                tcx.sess.delay_span_bug(DUMMY_SP, format!(\"{:?}\", self.opaque_types))\n             });\n         }\n     }"}, {"sha": "9c20c814b697f922fe00820f21bc279857c593ef", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -256,7 +256,7 @@ where\n                     // this point it never will be\n                     self.tcx.sess.delay_span_bug(\n                         origin.span(),\n-                        &format!(\"unresolved inference variable in outlives: {:?}\", v),\n+                        format!(\"unresolved inference variable in outlives: {:?}\", v),\n                     );\n                 }\n             }"}, {"sha": "c86da22526b02d933385902dbcfa608a63f01c91", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -179,7 +179,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                 // this point it never will be\n                 self.tcx.sess.delay_span_bug(\n                     rustc_span::DUMMY_SP,\n-                    &format!(\"unresolved inference variable in outlives: {:?}\", v),\n+                    format!(\"unresolved inference variable in outlives: {:?}\", v),\n                 );\n                 // add a bound that never holds\n                 VerifyBound::AnyBound(vec![])"}, {"sha": "b5a7d0326a88d7db659f569feaf9bd13a41fc2a8", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -73,7 +73,7 @@ pub fn report_object_safety_error<'tcx>(\n                 format!(\"...because {}\", violation.error_msg())\n             };\n             if spans.is_empty() {\n-                err.note(&msg);\n+                err.note(msg);\n             } else {\n                 for span in spans {\n                     multi_span.push(span);"}, {"sha": "d4898ffe883bc57a3354042a45f1d03177208240", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -616,7 +616,7 @@ pub trait LintContext: Sized {\n                         1 => (\"an \", \"\"),\n                         _ => (\"\", \"s\"),\n                     };\n-                    db.span_label(span, &format!(\n+                    db.span_label(span, format!(\n                         \"this comment contains {}invisible unicode text flow control codepoint{}\",\n                         an,\n                         s,\n@@ -680,12 +680,12 @@ pub trait LintContext: Sized {\n                     );\n                 }\n                 BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n-                    db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n+                    db.span_suggestion(span, note, sugg, Applicability::MaybeIncorrect);\n                 }\n                 BuiltinLintDiagnostics::UnusedImports(message, replaces, in_test_module) => {\n                     if !replaces.is_empty() {\n                         db.tool_only_multipart_suggestion(\n-                            &message,\n+                            message,\n                             replaces,\n                             Applicability::MachineApplicable,\n                         );\n@@ -720,13 +720,13 @@ pub trait LintContext: Sized {\n                 }\n                 BuiltinLintDiagnostics::MissingAbi(span, default_abi) => {\n                     db.span_label(span, \"ABI should be specified here\");\n-                    db.help(&format!(\"the default ABI is {}\", default_abi.name()));\n+                    db.help(format!(\"the default ABI is {}\", default_abi.name()));\n                 }\n                 BuiltinLintDiagnostics::LegacyDeriveHelpers(span) => {\n                     db.span_label(span, \"the attribute is introduced here\");\n                 }\n                 BuiltinLintDiagnostics::ProcMacroBackCompat(note) => {\n-                    db.note(&note);\n+                    db.note(note);\n                 }\n                 BuiltinLintDiagnostics::OrPatternsBackCompat(span,suggestion) => {\n                     db.span_suggestion(span, \"use pat_param to preserve semantics\", suggestion, Applicability::MachineApplicable);\n@@ -747,13 +747,13 @@ pub trait LintContext: Sized {\n                 } => {\n                     db.span_note(\n                         invoc_span,\n-                        &format!(\"the built-in attribute `{attr_name}` will be ignored, since it's applied to the macro invocation `{macro_name}`\")\n+                        format!(\"the built-in attribute `{attr_name}` will be ignored, since it's applied to the macro invocation `{macro_name}`\")\n                     );\n                 }\n                 BuiltinLintDiagnostics::TrailingMacro(is_trailing, name) => {\n                     if is_trailing {\n                         db.note(\"macro invocations at the end of a block are treated as expressions\");\n-                        db.note(&format!(\"to ignore the value produced by the macro, add a semicolon after the invocation of `{name}`\"));\n+                        db.note(format!(\"to ignore the value produced by the macro, add a semicolon after the invocation of `{name}`\"));\n                     }\n                 }\n                 BuiltinLintDiagnostics::BreakWithLabelAndLoop(span) => {\n@@ -765,7 +765,7 @@ pub trait LintContext: Sized {\n                     );\n                 }\n                 BuiltinLintDiagnostics::NamedAsmLabel(help) => {\n-                    db.help(&help);\n+                    db.help(help);\n                     db.note(\"see the asm section of Rust By Example <https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html#labels> for more information\");\n                 },\n                 BuiltinLintDiagnostics::UnexpectedCfg((name, name_span), None) => {\n@@ -793,15 +793,15 @@ pub trait LintContext: Sized {\n                             possibilities.sort();\n \n                             let possibilities = possibilities.join(\", \");\n-                            db.note(&format!(\"expected values for `{name}` are: {possibilities}\"));\n+                            db.note(format!(\"expected values for `{name}` are: {possibilities}\"));\n                         }\n \n                         // Suggest the most probable if we found one\n                         if let Some(best_match) = find_best_match_for_name(&possibilities, value, None) {\n                             db.span_suggestion(value_span, \"did you mean\", format!(\"\\\"{best_match}\\\"\"), Applicability::MaybeIncorrect);\n                         }\n                     } else {\n-                        db.note(&format!(\"no expected value for `{name}`\"));\n+                        db.note(format!(\"no expected value for `{name}`\"));\n                         if name != sym::feature {\n                             db.span_suggestion(name_span.shrink_to_hi().to(value_span), \"remove the value\", \"\", Applicability::MaybeIncorrect);\n                         }"}, {"sha": "9f1f5a26ee5336b3610ab484b1549084435cfc36", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -428,7 +428,7 @@ pub fn check_ast_node_inner<'a, T: EarlyLintPass>(\n         for early_lint in lints {\n             sess.delay_span_bug(\n                 early_lint.span,\n-                &format!(\n+                format!(\n                     \"failed to process buffered lint here (dummy = {})\",\n                     id == ast::DUMMY_NODE_ID\n                 ),"}, {"sha": "a44c1dd582ed3f1dd580c1be14481e4df4ca22ac", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -498,7 +498,7 @@ impl IntoDiagnostic<'_> for MultipleCandidates {\n         diag.code(error_code!(E0464));\n         diag.set_span(self.span);\n         for (i, candidate) in self.candidates.iter().enumerate() {\n-            diag.note(&format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n+            diag.note(format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n         }\n         diag\n     }"}, {"sha": "b43dcf3e5a183f4b36c302e4b5d91b6a93f54000", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -287,7 +287,7 @@ impl<'tcx> Collector<'tcx> {\n                                 &sess.parse_sess,\n                                 sym::$feature,\n                                 span,\n-                                &format!(\"linking modifier `{modifier}` is unstable\"),\n+                                format!(\"linking modifier `{modifier}` is unstable\"),\n                             )\n                             .emit();\n                         }"}, {"sha": "c266584ac280f5f44b7bd66110d3cb738cc53e13", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -231,19 +231,19 @@ pub fn explain_lint_level_source(\n     let name = lint.name_lower();\n     match src {\n         LintLevelSource::Default => {\n-            err.note_once(&format!(\"`#[{}({})]` on by default\", level.as_str(), name));\n+            err.note_once(format!(\"`#[{}({})]` on by default\", level.as_str(), name));\n         }\n         LintLevelSource::CommandLine(lint_flag_val, orig_level) => {\n             let flag = orig_level.to_cmd_flag();\n             let hyphen_case_lint_name = name.replace('_', \"-\");\n             if lint_flag_val.as_str() == name {\n-                err.note_once(&format!(\n+                err.note_once(format!(\n                     \"requested on the command line with `{} {}`\",\n                     flag, hyphen_case_lint_name\n                 ));\n             } else {\n                 let hyphen_case_flag_val = lint_flag_val.as_str().replace('_', \"-\");\n-                err.note_once(&format!(\n+                err.note_once(format!(\n                     \"`{} {}` implied by `{} {}`\",\n                     flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n                 ));\n@@ -256,7 +256,7 @@ pub fn explain_lint_level_source(\n             err.span_note_once(span, \"the lint level is defined here\");\n             if lint_attr_name.as_str() != name {\n                 let level_str = level.as_str();\n-                err.note_once(&format!(\n+                err.note_once(format!(\n                     \"`#[{}({})]` implied by `#[{}({})]`\",\n                     level_str, name, level_str, lint_attr_name\n                 ));\n@@ -444,12 +444,12 @@ pub fn struct_lint_level(\n             };\n \n             if future_incompatible.explain_reason {\n-                err.warn(&explanation);\n+                err.warn(explanation);\n             }\n             if !future_incompatible.reference.is_empty() {\n                 let citation =\n                     format!(\"for more information, see {}\", future_incompatible.reference);\n-                err.note(&citation);\n+                err.note(citation);\n             }\n         }\n "}, {"sha": "89fc864319df6ca34823cfc7b6d337a29b70153b", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -115,8 +115,8 @@ pub fn report_unstable(\n         soft_handler(SOFT_UNSTABLE, span, &msg)\n     } else {\n         let mut err =\n-            feature_err_issue(&sess.parse_sess, feature, span, GateIssue::Library(issue), &msg);\n-        if let Some((inner_types, ref msg, sugg, applicability)) = suggestion {\n+            feature_err_issue(&sess.parse_sess, feature, span, GateIssue::Library(issue), msg);\n+        if let Some((inner_types, msg, sugg, applicability)) = suggestion {\n             err.span_suggestion(inner_types, msg, sugg, applicability);\n         }\n         err.emit();\n@@ -170,7 +170,7 @@ pub fn deprecation_suggestion(\n     if let Some(suggestion) = suggestion {\n         diag.span_suggestion_verbose(\n             span,\n-            &format!(\"replace the use of the deprecated {}\", kind),\n+            format!(\"replace the use of the deprecated {}\", kind),\n             suggestion,\n             Applicability::MachineApplicable,\n         );\n@@ -599,7 +599,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             |span, def_id| {\n                 // The API could be uncallable for other reasons, for example when a private module\n                 // was referenced.\n-                self.sess.delay_span_bug(span, &format!(\"encountered unmarked API: {:?}\", def_id));\n+                self.sess.delay_span_bug(span, format!(\"encountered unmarked API: {:?}\", def_id));\n             },\n         )\n     }"}, {"sha": "c23755642084173afc675e5cc9bba0647352b871", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1010,18 +1010,15 @@ impl ObjectSafetyViolation {\n             ) => {\n                 err.span_suggestion(\n                     *span,\n-                    &format!(\n-                        \"consider changing method `{}`'s `self` parameter to be `&self`\",\n-                        name\n-                    ),\n+                    format!(\"consider changing method `{}`'s `self` parameter to be `&self`\", name),\n                     \"&Self\",\n                     Applicability::MachineApplicable,\n                 );\n             }\n             ObjectSafetyViolation::AssocConst(name, _)\n             | ObjectSafetyViolation::GAT(name, _)\n             | ObjectSafetyViolation::Method(name, ..) => {\n-                err.help(&format!(\"consider moving `{}` to another trait\", name));\n+                err.help(format!(\"consider moving `{}` to another trait\", name));\n             }\n         }\n     }"}, {"sha": "e7107c28bf407306e0f889be0ff2c999407fda3d", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -114,7 +114,7 @@ impl<'tcx> Const<'tcx> {\n                 Err(e) => {\n                     tcx.sess.delay_span_bug(\n                         expr.span,\n-                        &format!(\"Const::from_anon_const: couldn't lit_to_const {:?}\", e),\n+                        format!(\"Const::from_anon_const: couldn't lit_to_const {:?}\", e),\n                     );\n                 }\n             }"}, {"sha": "6a29063b80db39aadfd18d01dc26ce8e1905ca24", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -139,7 +139,7 @@ pub fn suggest_arbitrary_trait_bound<'tcx>(\n     // Suggest a where clause bound for a non-type parameter.\n     err.span_suggestion_verbose(\n         generics.tail_span_for_predicate_suggestion(),\n-        &format!(\n+        format!(\n             \"consider {} `where` clause, but there might be an alternative better way to express \\\n              this requirement\",\n             if generics.where_clause_span.is_empty() { \"introducing a\" } else { \"extending the\" },\n@@ -242,7 +242,7 @@ pub fn suggest_constraining_type_params<'a>(\n \n                 err.span_label(\n                     param.span,\n-                    &format!(\"this type parameter needs to be `{}`\", constraint),\n+                    format!(\"this type parameter needs to be `{}`\", constraint),\n                 );\n                 suggest_removing_unsized_bound(generics, &mut suggestions, param, def_id);\n             }"}, {"sha": "72710b78c93739d299642547cb8e30fbd9195195", "filename": "compiler/rustc_middle/src/ty/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -177,7 +177,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReverseMapper<'tcx> {\n                                 .sess\n                                 .struct_span_err(\n                                     self.span,\n-                                    &format!(\n+                                    format!(\n                                         \"type parameter `{}` is part of concrete type but not \\\n                                           used in parameter list for the `impl Trait` type alias\",\n                                         ty"}, {"sha": "3dfd0824f9872f029a95a678c3b634c98b4718e7", "filename": "compiler/rustc_middle/src/util/bug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -31,8 +31,8 @@ fn opt_span_bug_fmt<S: Into<MultiSpan>>(\n     tls::with_opt(move |tcx| {\n         let msg = format!(\"{}: {}\", location, args);\n         match (tcx, span) {\n-            (Some(tcx), Some(span)) => tcx.sess.diagnostic().span_bug(span, &msg),\n-            (Some(tcx), None) => tcx.sess.diagnostic().bug(&msg),\n+            (Some(tcx), Some(span)) => tcx.sess.diagnostic().span_bug(span, msg),\n+            (Some(tcx), None) => tcx.sess.diagnostic().bug(msg),\n             (None, _) => panic_any(msg),\n         }\n     })"}, {"sha": "8cb3b00c9ad7006ae6188d05f895b8bf804a6c27", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -672,7 +672,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n         ty::Adt(def, _) if def.is_variant_list_non_exhaustive() && !def.did().is_local());\n \n     adt_defined_here(cx, &mut err, scrut_ty, &witnesses);\n-    err.note(&format!(\n+    err.note(format!(\n         \"the matched value is of type `{}`{}\",\n         scrut_ty,\n         if is_variant_list_non_exhaustive { \", which is marked as non-exhaustive\" } else { \"\" }\n@@ -682,13 +682,13 @@ fn non_exhaustive_match<'p, 'tcx>(\n         && witnesses.len() == 1\n         && matches!(witnesses[0].ctor(), Constructor::NonExhaustive)\n     {\n-        err.note(&format!(\n+        err.note(format!(\n             \"`{}` does not have a fixed maximum value, so a wildcard `_` is necessary to match \\\n              exhaustively\",\n             scrut_ty,\n         ));\n         if cx.tcx.sess.is_nightly_build() {\n-            err.help(&format!(\n+            err.help(format!(\n                 \"add `#![feature(precise_pointer_size_matching)]` to the crate attributes to \\\n                  enable precise `{}` matching\",\n                 scrut_ty,\n@@ -793,9 +793,9 @@ fn non_exhaustive_match<'p, 'tcx>(\n         },\n     );\n     if let Some((span, sugg)) = suggestion {\n-        err.span_suggestion_verbose(span, &msg, sugg, Applicability::HasPlaceholders);\n+        err.span_suggestion_verbose(span, msg, sugg, Applicability::HasPlaceholders);\n     } else {\n-        err.help(&msg);\n+        err.help(msg);\n     }\n     err.emit();\n }\n@@ -857,7 +857,7 @@ fn adt_defined_here<'p, 'tcx>(\n         for pat in spans {\n             span.push_span_label(pat, \"not covered\");\n         }\n-        err.span_note(span, &format!(\"`{}` defined here\", ty));\n+        err.span_note(span, format!(\"`{}` defined here\", ty));\n     }\n }\n "}, {"sha": "1cf2f7ec0fff140a4d16225bee24b57a288f6d7e", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                         self.lower_pattern_range(ty, lc, hc, end, lo_span, lo_expr, hi_expr)\n                     }\n                     None => {\n-                        let msg = &format!(\n+                        let msg = format!(\n                             \"found bad range pattern `{:?}` outside of error recovery\",\n                             (&lo, &hi),\n                         );"}, {"sha": "98e7a519c201395ab85bb13994761ac3b5db1df5", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -366,7 +366,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     if maybe_dead {\n                         self.tcx.sess.delay_span_bug(\n                             terminator.source_info.span,\n-                            &format!(\n+                            format!(\n                                 \"drop of untracked, uninitialized value {:?}, place {:?} ({:?})\",\n                                 bb, place, path\n                             ),\n@@ -440,7 +440,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                             ) {\n                                 self.tcx.sess.delay_span_bug(\n                                     terminator.source_info.span,\n-                                    &format!(\"drop of untracked value {:?}\", bb),\n+                                    format!(\"drop of untracked value {:?}\", bb),\n                                 );\n                             }\n                             // A drop and replace behind a pointer/array/whatever."}, {"sha": "9e16c400f14798e038e55778091d9fa9d9dd4ea1", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -865,7 +865,7 @@ fn sanitize_witness<'tcx>(\n         _ => {\n             tcx.sess.delay_span_bug(\n                 body.span,\n-                &format!(\"unexpected generator witness type {:?}\", witness.kind()),\n+                format!(\"unexpected generator witness type {:?}\", witness.kind()),\n             );\n             return;\n         }\n@@ -1451,8 +1451,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n                 )\n             }\n             _ => {\n-                tcx.sess\n-                    .delay_span_bug(body.span, &format!(\"unexpected generator type {}\", gen_ty));\n+                tcx.sess.delay_span_bug(body.span, format!(\"unexpected generator type {}\", gen_ty));\n                 return;\n             }\n         };"}, {"sha": "b1c0dedd3c7dcade7a6b8de2abc537e76541fcd8", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -321,7 +321,7 @@ impl<'a> StringReader<'a> {\n     ) -> DiagnosticBuilder<'a, !> {\n         self.sess\n             .span_diagnostic\n-            .struct_span_fatal(self.mk_sp(from_pos, to_pos), &format!(\"{}: {}\", m, escaped_char(c)))\n+            .struct_span_fatal(self.mk_sp(from_pos, to_pos), format!(\"{}: {}\", m, escaped_char(c)))\n     }\n \n     /// Detect usages of Unicode codepoints changing the direction of the text on screen and loudly\n@@ -542,7 +542,7 @@ impl<'a> StringReader<'a> {\n         err.span_label(self.mk_sp(start, start), \"unterminated raw string\");\n \n         if n_hashes > 0 {\n-            err.note(&format!(\n+            err.note(format!(\n                 \"this raw string should be terminated with `\\\"{}`\",\n                 \"#\".repeat(n_hashes as usize)\n             ));"}, {"sha": "318a29985090237b06b752ec0ef463f071a3bbde", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -199,8 +199,7 @@ impl<'a> TokenTreesReader<'a> {\n         // matching opening delimiter).\n         let token_str = token_to_string(&self.token);\n         let msg = format!(\"unexpected closing delimiter: `{}`\", token_str);\n-        let mut err =\n-            self.string_reader.sess.span_diagnostic.struct_span_err(self.token.span, &msg);\n+        let mut err = self.string_reader.sess.span_diagnostic.struct_span_err(self.token.span, msg);\n \n         report_suspicious_mismatch_block(\n             &mut err,"}, {"sha": "d8bcf816fb26303f46599fb749e306d9967b019b", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -129,7 +129,7 @@ pub(crate) fn emit_unescape_error(\n             let label =\n                 if mode.is_byte() { \"unknown byte escape\" } else { \"unknown character escape\" };\n             let ec = escaped_char(c);\n-            let mut diag = handler.struct_span_err(span, &format!(\"{}: `{}`\", label, ec));\n+            let mut diag = handler.struct_span_err(span, format!(\"{}: `{}`\", label, ec));\n             diag.span_label(span, label);\n             if c == '{' || c == '}' && !mode.is_byte() {\n                 diag.help(\n@@ -180,13 +180,13 @@ pub(crate) fn emit_unescape_error(\n             } else {\n                 String::new()\n             };\n-            err.span_label(span, &format!(\"must be ASCII{}\", postfix));\n+            err.span_label(span, format!(\"must be ASCII{}\", postfix));\n             // Note: the \\\\xHH suggestions are not given for raw byte string\n             // literals, because they are araw and so cannot use any escapes.\n             if (c as u32) <= 0xFF && mode != Mode::RawByteStr {\n                 err.span_suggestion(\n                     span,\n-                    &format!(\n+                    format!(\n                         \"if you meant to use the unicode code point for {:?}, use a \\\\xHH escape\",\n                         c\n                     ),\n@@ -200,10 +200,7 @@ pub(crate) fn emit_unescape_error(\n                 utf8.push(c);\n                 err.span_suggestion(\n                     span,\n-                    &format!(\n-                        \"if you meant to use the UTF-8 encoding of {:?}, use \\\\xHH escapes\",\n-                        c\n-                    ),\n+                    format!(\"if you meant to use the UTF-8 encoding of {:?}, use \\\\xHH escapes\", c),\n                     utf8.as_bytes()\n                         .iter()\n                         .map(|b: &u8| format!(\"\\\\x{:X}\", *b))"}, {"sha": "829d9693e55a65615fc92d1c297d5626393fe564", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -350,7 +350,7 @@ pub(super) fn check_for_substitution(\n \n     let Some((_, ascii_name, token)) = ASCII_ARRAY.iter().find(|&&(s, _, _)| s == ascii_str) else {\n         let msg = format!(\"substitution character not found for '{}'\", ch);\n-        reader.sess.span_diagnostic.span_bug_no_panic(span, &msg);\n+        reader.sess.span_diagnostic.span_bug_no_panic(span, msg);\n         return (None, None);\n     };\n "}, {"sha": "25de780853291827770b780aa17516693ac6e95f", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -153,7 +153,7 @@ fn try_file_to_source_file(\n ) -> Result<Lrc<SourceFile>, Diagnostic> {\n     sess.source_map().load_file(path).map_err(|e| {\n         let msg = format!(\"couldn't read {}: {}\", path.display(), e);\n-        let mut diag = Diagnostic::new(Level::Fatal, &msg);\n+        let mut diag = Diagnostic::new(Level::Fatal, msg);\n         if let Some(sp) = spanopt {\n             diag.set_span(sp);\n         }\n@@ -190,7 +190,7 @@ pub fn maybe_file_to_stream(\n     override_span: Option<Span>,\n ) -> Result<TokenStream, Vec<Diagnostic>> {\n     let src = source_file.src.as_ref().unwrap_or_else(|| {\n-        sess.span_diagnostic.bug(&format!(\n+        sess.span_diagnostic.bug(format!(\n             \"cannot lex `source_file` without source: {}\",\n             sess.source_map().filename_for_diagnostics(&source_file.name)\n         ));\n@@ -247,7 +247,7 @@ pub fn parse_cfg_attr(\n             match parse_in(parse_sess, tokens.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n                 Ok(r) => return Some(r),\n                 Err(mut e) => {\n-                    e.help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n+                    e.help(format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n                         .note(CFG_ATTR_NOTE_REF)\n                         .emit();\n                 }"}, {"sha": "513f51a3b5cf18d7a23d1de11b9d464f39608e0f", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -207,11 +207,11 @@ struct MultiSugg {\n \n impl MultiSugg {\n     fn emit(self, err: &mut Diagnostic) {\n-        err.multipart_suggestion(&self.msg, self.patches, self.applicability);\n+        err.multipart_suggestion(self.msg, self.patches, self.applicability);\n     }\n \n     fn emit_verbose(self, err: &mut Diagnostic) {\n-        err.multipart_suggestion_verbose(&self.msg, self.patches, self.applicability);\n+        err.multipart_suggestion_verbose(self.msg, self.patches, self.applicability);\n     }\n }\n \n@@ -591,13 +591,13 @@ impl<'a> Parser<'a> {\n         };\n         self.last_unexpected_token_span = Some(self.token.span);\n         // FIXME: translation requires list formatting (for `expect`)\n-        let mut err = self.struct_span_err(self.token.span, &msg_exp);\n+        let mut err = self.struct_span_err(self.token.span, msg_exp);\n \n         if let TokenKind::Ident(symbol, _) = &self.prev_token.kind {\n             if [\"def\", \"fun\", \"func\", \"function\"].contains(&symbol.as_str()) {\n                 err.span_suggestion_short(\n                     self.prev_token.span,\n-                    &format!(\"write `fn` instead of `{symbol}` to declare a function\"),\n+                    format!(\"write `fn` instead of `{symbol}` to declare a function\"),\n                     \"fn\",\n                     Applicability::MachineApplicable,\n                 );\n@@ -695,13 +695,13 @@ impl<'a> Parser<'a> {\n                 err.set_span(span);\n                 err.span_suggestion(\n                     span,\n-                    &format!(\"remove the extra `#`{}\", pluralize!(count)),\n+                    format!(\"remove the extra `#`{}\", pluralize!(count)),\n                     \"\",\n                     Applicability::MachineApplicable,\n                 );\n                 err.span_label(\n                     str_span,\n-                    &format!(\"this raw string started with {n_hashes} `#`{}\", pluralize!(n_hashes)),\n+                    format!(\"this raw string started with {n_hashes} `#`{}\", pluralize!(n_hashes)),\n                 );\n                 true\n             }\n@@ -1360,12 +1360,12 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, P<Expr>> {\n         let mut err = self.struct_span_err(\n             op_span,\n-            &format!(\"Rust has no {} {} operator\", kind.fixity, kind.op.name()),\n+            format!(\"Rust has no {} {} operator\", kind.fixity, kind.op.name()),\n         );\n-        err.span_label(op_span, &format!(\"not a valid {} operator\", kind.fixity));\n+        err.span_label(op_span, format!(\"not a valid {} operator\", kind.fixity));\n \n         let help_base_case = |mut err: DiagnosticBuilder<'_, _>, base| {\n-            err.help(&format!(\"use `{}= 1` instead\", kind.op.chr()));\n+            err.help(format!(\"use `{}= 1` instead\", kind.op.chr()));\n             err.emit();\n             Ok(base)\n         };\n@@ -1554,7 +1554,7 @@ impl<'a> Parser<'a> {\n                 _ => this_token_str,\n             },\n         );\n-        let mut err = self.struct_span_err(sp, &msg);\n+        let mut err = self.struct_span_err(sp, msg);\n         let label_exp = format!(\"expected `{token_str}`\");\n         let sm = self.sess.source_map();\n         if !sm.is_multiline(prev_sp.until(sp)) {\n@@ -1705,7 +1705,7 @@ impl<'a> Parser<'a> {\n                     Applicability::MachineApplicable,\n                 );\n             }\n-            err.span_suggestion(lo.shrink_to_lo(), &format!(\"{prefix}you can still access the deprecated `try!()` macro using the \\\"raw identifier\\\" syntax\"), \"r#\", Applicability::MachineApplicable);\n+            err.span_suggestion(lo.shrink_to_lo(), format!(\"{prefix}you can still access the deprecated `try!()` macro using the \\\"raw identifier\\\" syntax\"), \"r#\", Applicability::MachineApplicable);\n             err.emit();\n             Ok(self.mk_expr_err(lo.to(hi)))\n         } else {\n@@ -2060,7 +2060,7 @@ impl<'a> Parser<'a> {\n                 format!(\"expected expression, found {}\", super::token_descr(&self.token),),\n             ),\n         };\n-        let mut err = self.struct_span_err(span, &msg);\n+        let mut err = self.struct_span_err(span, msg);\n         let sp = self.sess.source_map().start_point(self.token.span);\n         if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n             err.subdiagnostic(ExprParenthesesNeeded::surrounding(*sp));\n@@ -2131,7 +2131,7 @@ impl<'a> Parser<'a> {\n         // arguments after a comma.\n         let mut err = self.struct_span_err(\n             self.token.span,\n-            &format!(\"expected one of `,` or `>`, found {}\", super::token_descr(&self.token)),\n+            format!(\"expected one of `,` or `>`, found {}\", super::token_descr(&self.token)),\n         );\n         err.span_label(self.token.span, \"expected one of `,` or `>`\");\n         match self.recover_const_arg(arg.span(), err) {\n@@ -2558,7 +2558,7 @@ impl<'a> Parser<'a> {\n         let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n         if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n             err.multipart_suggestion(\n-                &format!(\n+                format!(\n                     \"try adding parentheses to match on a tuple{}\",\n                     if let CommaRecoveryMode::LikelyTuple = rt { \"\" } else { \"...\" },\n                 ),"}, {"sha": "f58f8919e5c9d4f135a74a57cda1edeade5e774a", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -855,7 +855,7 @@ impl<'a> Parser<'a> {\n                     _ => unreachable!(\"parse_dot_or_call_expr_with_ shouldn't produce this\"),\n                 }\n             );\n-            let mut err = self.struct_span_err(span, &msg);\n+            let mut err = self.struct_span_err(span, msg);\n \n             let suggest_parens = |err: &mut Diagnostic| {\n                 let suggestions = vec![\n@@ -1803,7 +1803,7 @@ impl<'a> Parser<'a> {\n         let token = self.token.clone();\n         let err = |self_: &Self| {\n             let msg = format!(\"unexpected token: {}\", super::token_descr(&token));\n-            self_.struct_span_err(token.span, &msg)\n+            self_.struct_span_err(token.span, msg)\n         };\n         // On an error path, eagerly consider a lifetime to be an unclosed character lit\n         if self.token.is_lifetime() {"}, {"sha": "d7bfc432d54d38aaceb5e7fbb4ee637b7e83107a", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -71,7 +71,7 @@ impl<'a> Parser<'a> {\n         if !self.eat(term) {\n             let token_str = super::token_descr(&self.token);\n             if !self.maybe_consume_incorrect_semicolon(&items) {\n-                let msg = &format!(\"expected item, found {token_str}\");\n+                let msg = format!(\"expected item, found {token_str}\");\n                 let mut err = self.struct_span_err(self.token.span, msg);\n                 let label = if self.is_kw_followed_by_ident(kw::Let) {\n                     \"consider using `const` or `static` instead of `let` for global variables\"\n@@ -1429,7 +1429,7 @@ impl<'a> Parser<'a> {\n             VariantData::Struct(fields, recovered)\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let msg = &format!(\"expected `where` or `{{` after union name, found {token_str}\");\n+            let msg = format!(\"expected `where` or `{{` after union name, found {token_str}\");\n             let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n             return Err(err);\n@@ -1465,7 +1465,7 @@ impl<'a> Parser<'a> {\n             self.eat(&token::CloseDelim(Delimiter::Brace));\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let msg = &format!(\n+            let msg = format!(\n                 \"expected {}`{{` after struct name, found {}\",\n                 if parsed_where { \"\" } else { \"`where`, or \" },\n                 token_str\n@@ -1602,7 +1602,7 @@ impl<'a> Parser<'a> {\n                 let sp = self.prev_token.span.shrink_to_hi();\n                 let mut err = self.struct_span_err(\n                     sp,\n-                    &format!(\"expected `,`, or `}}`, found {}\", super::token_descr(&self.token)),\n+                    format!(\"expected `,`, or `}}`, found {}\", super::token_descr(&self.token)),\n                 );\n \n                 // Try to recover extra trailing angle brackets\n@@ -1740,7 +1740,7 @@ impl<'a> Parser<'a> {\n                     Ok(_) => {\n                         let mut err = self.struct_span_err(\n                             lo.to(self.prev_token.span),\n-                            &format!(\"functions are not allowed in {adt_ty} definitions\"),\n+                            format!(\"functions are not allowed in {adt_ty} definitions\"),\n                         );\n                         err.help(\n                             \"unlike in C++, Java, and C#, functions are declared in `impl` blocks\",\n@@ -1759,7 +1759,7 @@ impl<'a> Parser<'a> {\n                     Ok((ident, _)) => {\n                         let mut err = self.struct_span_err(\n                             lo.with_hi(ident.span.hi()),\n-                            &format!(\"structs are not allowed in {adt_ty} definitions\"),\n+                            format!(\"structs are not allowed in {adt_ty} definitions\"),\n                         );\n                         err.help(\"consider creating a new `struct` definition instead of nesting\");\n                         err\n@@ -2228,11 +2228,11 @@ impl<'a> Parser<'a> {\n \n                         err.span_suggestion(\n                             self.token.uninterpolated_span(),\n-                            &format!(\"`{original_kw}` already used earlier, remove this one\"),\n+                            format!(\"`{original_kw}` already used earlier, remove this one\"),\n                             \"\",\n                             Applicability::MachineApplicable,\n                         )\n-                        .span_note(original_sp, &format!(\"`{original_kw}` first seen here\"));\n+                        .span_note(original_sp, format!(\"`{original_kw}` first seen here\"));\n                     }\n                     // The keyword has not been seen yet, suggest correct placement in the function front matter\n                     else if let Some(WrongKw::Misplaced(correct_pos_sp)) = wrong_kw {\n@@ -2243,7 +2243,7 @@ impl<'a> Parser<'a> {\n \n                             err.span_suggestion(\n                                     correct_pos_sp.to(misplaced_qual_sp),\n-                                    &format!(\"`{misplaced_qual}` must come before `{current_qual}`\"),\n+                                    format!(\"`{misplaced_qual}` must come before `{current_qual}`\"),\n                                     format!(\"{misplaced_qual} {current_qual}\"),\n                                     Applicability::MachineApplicable,\n                                 ).note(\"keyword order for functions declaration is `pub`, `default`, `const`, `async`, `unsafe`, `extern`\");\n@@ -2267,7 +2267,7 @@ impl<'a> Parser<'a> {\n                             if matches!(orig_vis.kind, VisibilityKind::Inherited) {\n                                 err.span_suggestion(\n                                     sp_start.to(self.prev_token.span),\n-                                    &format!(\"visibility `{vs}` must come before `{snippet}`\"),\n+                                    format!(\"visibility `{vs}` must come before `{snippet}`\"),\n                                     format!(\"{vs} {snippet}\"),\n                                     Applicability::MachineApplicable,\n                                 );"}, {"sha": "0c265d7af0e6ec32f17340de28287a1cf1d788ac", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -905,7 +905,7 @@ impl<'a> Parser<'a> {\n                                 expect_err\n                                     .span_suggestion_verbose(\n                                         self.prev_token.span.shrink_to_hi().until(self.token.span),\n-                                        &msg,\n+                                        msg,\n                                         \" @ \",\n                                         Applicability::MaybeIncorrect,\n                                     )\n@@ -921,7 +921,7 @@ impl<'a> Parser<'a> {\n                                     expect_err\n                                         .span_suggestion_short(\n                                             sp,\n-                                            &format!(\"missing `{}`\", token_str),\n+                                            format!(\"missing `{}`\", token_str),\n                                             token_str,\n                                             Applicability::MaybeIncorrect,\n                                         )"}, {"sha": "c317d96368ee6b7cf2f720320528348f44ea5e09", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -444,7 +444,7 @@ impl<'a> Parser<'a> {\n                         super::token_descr(&self_.token)\n                     );\n \n-                    let mut err = self_.struct_span_err(self_.token.span, &msg);\n+                    let mut err = self_.struct_span_err(self_.token.span, msg);\n                     err.span_label(self_.token.span, format!(\"expected {}\", expected));\n                     err\n                 });\n@@ -680,7 +680,7 @@ impl<'a> Parser<'a> {\n         let expected = Expected::to_string_or_fallback(expected);\n         let msg = format!(\"expected {}, found {}\", expected, super::token_descr(&self.token));\n \n-        let mut err = self.struct_span_err(self.token.span, &msg);\n+        let mut err = self.struct_span_err(self.token.span, msg);\n         err.span_label(self.token.span, format!(\"expected {}\", expected));\n \n         let sp = self.sess.source_map().start_point(self.token.span);\n@@ -978,7 +978,7 @@ impl<'a> Parser<'a> {\n                     break;\n                 }\n                 let token_str = super::token_descr(&self.token);\n-                let msg = &format!(\"expected `}}`, found {}\", token_str);\n+                let msg = format!(\"expected `}}`, found {}\", token_str);\n                 let mut err = self.struct_span_err(self.token.span, msg);\n \n                 err.span_label(self.token.span, \"expected `}`\");"}, {"sha": "47822a9ac7807bfc8dbdaecbc914fcf73654387c", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -679,14 +679,14 @@ impl<'a> Parser<'a> {\n                     );\n                     err.span_suggestion(\n                         eq.to(before_next),\n-                        &format!(\"remove the `=` if `{}` is a type\", ident),\n+                        format!(\"remove the `=` if `{}` is a type\", ident),\n                         \"\",\n                         Applicability::MaybeIncorrect,\n                     )\n                 } else {\n                     err.span_label(\n                         self.token.span,\n-                        &format!(\"expected type, found {}\", super::token_descr(&self.token)),\n+                        format!(\"expected type, found {}\", super::token_descr(&self.token)),\n                     )\n                 };\n                 return Err(err);"}, {"sha": "1c17de337e83300d5e759ea31907540546737490", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -634,7 +634,7 @@ impl<'a> Parser<'a> {\n \n                                 e.span_suggestion(\n                                     sp.with_hi(sp.lo() + BytePos(marker.len() as u32)),\n-                                    &format!(\n+                                    format!(\n                                         \"add a space before `{}` to use a regular comment\",\n                                         doc_comment_marker,\n                                     ),"}, {"sha": "f58f09d06bcdab8baa241b55faf6f140f65d6bb0", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -315,7 +315,7 @@ impl<'a> Parser<'a> {\n             }\n         } else {\n             let msg = format!(\"expected type, found {}\", super::token_descr(&self.token));\n-            let mut err = self.struct_span_err(self.token.span, &msg);\n+            let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected type\");\n             return Err(err);\n         };"}, {"sha": "982c4615affb639bad04439112ed4a3aae16ad7e", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -189,7 +189,7 @@ fn emit_malformed_attribute(\n         sess.buffer_lint(&ILL_FORMED_ATTRIBUTE_INPUT, span, ast::CRATE_NODE_ID, &msg);\n     } else {\n         sess.span_diagnostic\n-            .struct_span_err(span, &error_msg)\n+            .struct_span_err(span, error_msg)\n             .span_suggestions(\n                 span,\n                 if suggestions.len() == 1 {"}, {"sha": "6742722ce52c62ef43e21fef3fd65b9f8663809b", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n             [missing_primary, ref missing_secondary @ ..] => {\n                 let msg =\n                     format!(\"{} is not allowed in a `{}`\", expr.name(), const_kind.keyword_name());\n-                let mut err = feature_err(&tcx.sess.parse_sess, *missing_primary, span, &msg);\n+                let mut err = feature_err(&tcx.sess.parse_sess, *missing_primary, span, msg);\n \n                 // If multiple feature gates would be required to enable this expression, include\n                 // them as help messages. Don't emit a separate error for each missing feature gate.\n@@ -161,7 +161,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n                             \"add `#![feature({})]` to the crate attributes to enable\",\n                             gate,\n                         );\n-                        err.help(&note);\n+                        err.help(note);\n                     }\n                 }\n "}, {"sha": "363e1743677addb05621a1632ad9fadedb69214e", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -31,7 +31,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n \n         if !errors.is_empty() {\n             let message = errors.iter().fold(String::new(), |s1, s2| s1 + \"\\n\" + s2);\n-            tcx.sess.delay_span_bug(rustc_span::DUMMY_SP, &message);\n+            tcx.sess.delay_span_bug(rustc_span::DUMMY_SP, message);\n         }\n     }\n }"}, {"sha": "5f2ec656d1d1e35749092edb8fb8688c97d0f9c6", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -633,7 +633,7 @@ pub fn print_query_stack<Qcx: QueryContext>(\n         };\n         let mut diag = Diagnostic::new(\n             Level::FailureNote,\n-            &format!(\"#{} [{:?}] {}\", i, query_info.query.dep_kind, query_info.query.description),\n+            format!(\"#{} [{:?}] {}\", i, query_info.query.dep_kind, query_info.query.description),\n         );\n         diag.span = query_info.job.span.into();\n         handler.force_print_diagnostic(diag);"}, {"sha": "2438b3a38ed4d63ffa325325932ee65aee2fbcaf", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1002,7 +1002,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n-            self.r.tcx.sess.struct_span_err(span, &msg).note(note).emit();\n+            self.r.tcx.sess.struct_span_err(span, msg).note(note).emit();\n         }\n     }\n "}, {"sha": "17c4a6be049ed1a4b9242c1d1be4f23228d1dbed", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -418,7 +418,7 @@ impl Resolver<'_, '_> {\n                 UNUSED_IMPORTS,\n                 unused.use_tree_id,\n                 ms,\n-                &msg,\n+                msg,\n                 BuiltinLintDiagnostics::UnusedImports(fix_msg.into(), fixes, test_module_span),\n             );\n         }"}, {"sha": "fd263bab78fbd379801ed59aa6e730f610671ebc", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -238,7 +238,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             },\n         };\n \n-        err.note(&format!(\n+        err.note(format!(\n             \"`{}` must be defined only once in the {} namespace of this {}\",\n             name,\n             ns.descr(),\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                              making the path in the pattern qualified: `path::to::ModOrType::{}`\",\n                             name,\n                         );\n-                        err.span_help(span, &help_msg);\n+                        err.span_help(span, help_msg);\n                     }\n                     show_candidates(\n                         self.tcx,\n@@ -783,10 +783,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 if let Some((suggestions, msg, applicability)) = suggestion {\n                     if suggestions.is_empty() {\n-                        err.help(&msg);\n+                        err.help(msg);\n                         return err;\n                     }\n-                    err.multipart_suggestion(&msg, suggestions, applicability);\n+                    err.multipart_suggestion(msg, suggestions, applicability);\n                 }\n \n                 err\n@@ -930,7 +930,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } => {\n                 let mut err = self.tcx.sess.struct_span_err_with_code(\n                     span,\n-                    &format!(\n+                    format!(\n                         \"item `{}` is an associated {}, which doesn't match its trait `{}`\",\n                         name, kind, trait_path,\n                     ),\n@@ -1359,7 +1359,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         if macro_kind == MacroKind::Derive && (ident.name == sym::Send || ident.name == sym::Sync) {\n             let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", ident);\n-            err.span_note(ident.span, &msg);\n+            err.span_note(ident.span, msg);\n             return;\n         }\n         if self.macro_names.contains(&ident.normalize_to_macros_2_0()) {\n@@ -1419,15 +1419,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if !import.span.is_dummy() {\n                         err.span_note(\n                             import.span,\n-                            &format!(\"`{}` is imported here, but it is {}\", ident, desc),\n+                            format!(\"`{}` is imported here, but it is {}\", ident, desc),\n                         );\n                         // Silence the 'unused import' warning we might get,\n                         // since this diagnostic already covers that import.\n                         self.record_use(ident, binding, false);\n                         return;\n                     }\n                 }\n-                err.note(&format!(\"`{}` is in scope, but it is {}\", ident, desc));\n+                err.note(format!(\"`{}` is in scope, but it is {}\", ident, desc));\n                 return;\n             }\n         }\n@@ -1474,7 +1474,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             err.span_label(\n                 self.tcx.sess.source_map().guess_head_span(def_span),\n-                &format!(\n+                format!(\n                     \"{}{} `{}` defined here\",\n                     prefix,\n                     suggestion.res.descr(),\n@@ -1492,7 +1492,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 format!(\"maybe you meant this {}\", suggestion.res.descr())\n             }\n         };\n-        err.span_suggestion(span, &msg, suggestion.candidate, Applicability::MaybeIncorrect);\n+        err.span_suggestion(span, msg, suggestion.candidate, Applicability::MaybeIncorrect);\n         true\n     }\n \n@@ -1534,7 +1534,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let mut err = struct_span_err!(self.tcx.sess, ident.span, E0659, \"`{ident}` is ambiguous\");\n         err.span_label(ident.span, \"ambiguous name\");\n-        err.note(&format!(\"ambiguous because of {}\", kind.descr()));\n+        err.note(format!(\"ambiguous because of {}\", kind.descr()));\n \n         let mut could_refer_to = |b: &NameBinding<'_>, misc: AmbiguityErrorMisc, also: &str| {\n             let what = self.binding_description(b, ident, misc == AmbiguityErrorMisc::FromPrelude);\n@@ -1562,10 +1562,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 AmbiguityErrorMisc::FromPrelude | AmbiguityErrorMisc::None => {}\n             }\n \n-            err.span_note(b.span, &note_msg);\n+            err.span_note(b.span, note_msg);\n             for (i, help_msg) in help_msgs.iter().enumerate() {\n                 let or = if i == 0 { \"\" } else { \"or \" };\n-                err.help(&format!(\"{}{}\", or, help_msg));\n+                err.help(format!(\"{}{}\", or, help_msg));\n             }\n         };\n \n@@ -1608,7 +1608,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let descr = get_descr(binding);\n         let mut err =\n             struct_span_err!(self.tcx.sess, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n-        err.span_label(ident.span, &format!(\"private {}\", descr));\n+        err.span_label(ident.span, format!(\"private {}\", descr));\n \n         let mut non_exhaustive = None;\n         // If an ADT is foreign and marked as `non_exhaustive`, then that's\n@@ -1623,7 +1623,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             err.span_label(span, \"a constructor is private if any of the fields is private\");\n             if let Res::Def(_, d) = res && let Some(fields) = self.field_visibility_spans.get(&d) {\n                 err.multipart_suggestion_verbose(\n-                    &format!(\n+                    format!(\n                         \"consider making the field{} publicly accessible\",\n                         pluralize!(fields.len())\n                     ),\n@@ -1676,7 +1676,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     format!(\"cannot be constructed because it is `#[non_exhaustive]`\"),\n                 );\n             }\n-            err.span_note(note_span, &msg);\n+            err.span_note(note_span, msg);\n         }\n \n         err.emit();\n@@ -2444,15 +2444,15 @@ fn show_candidates(\n         };\n \n         for note in accessible_path_strings.iter().flat_map(|cand| cand.3.as_ref()) {\n-            err.note(note);\n+            err.note(note.clone());\n         }\n \n         if let Some(span) = use_placement_span {\n             let (add_use, trailing) = match mode {\n                 DiagnosticMode::Pattern => {\n                     err.span_suggestions(\n                         span,\n-                        &msg,\n+                        msg,\n                         accessible_path_strings.into_iter().map(|a| a.0),\n                         Applicability::MaybeIncorrect,\n                     );\n@@ -2471,7 +2471,7 @@ fn show_candidates(\n \n             err.span_suggestions_with_style(\n                 span,\n-                &msg,\n+                msg,\n                 accessible_path_strings.into_iter().map(|a| a.0),\n                 Applicability::MaybeIncorrect,\n                 SuggestionStyle::ShowAlways,\n@@ -2481,7 +2481,7 @@ fn show_candidates(\n                 if sp.can_be_used_for_suggestions() {\n                     err.span_suggestion_verbose(\n                         sp,\n-                        &format!(\"if you import `{}`, refer to it directly\", last.ident),\n+                        format!(\"if you import `{}`, refer to it directly\", last.ident),\n                         \"\",\n                         Applicability::Unspecified,\n                     );\n@@ -2495,7 +2495,7 @@ fn show_candidates(\n                 msg.push_str(&candidate.0);\n             }\n \n-            err.help(&msg);\n+            err.help(msg);\n         }\n     } else if !matches!(mode, DiagnosticMode::Import) {\n         assert!(!inaccessible_path_strings.is_empty());\n@@ -2520,9 +2520,9 @@ fn show_candidates(\n                 let span = tcx.sess.source_map().guess_head_span(span);\n                 let mut multi_span = MultiSpan::from_span(span);\n                 multi_span.push_span_label(span, \"not accessible\");\n-                err.span_note(multi_span, &msg);\n+                err.span_note(multi_span, msg);\n             } else {\n-                err.note(&msg);\n+                err.note(msg);\n             }\n             if let Some(note) = (*note).as_deref() {\n                 err.note(note);\n@@ -2566,10 +2566,10 @@ fn show_candidates(\n             }\n \n             for note in inaccessible_path_strings.iter().flat_map(|cand| cand.3.as_ref()) {\n-                err.note(note);\n+                err.note(note.clone());\n             }\n \n-            err.span_note(multi_span, &msg);\n+            err.span_note(multi_span, msg);\n         }\n     }\n }"}, {"sha": "530c188fe18034a4bb7df23a265808698686ff28", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -527,7 +527,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n                                         lint_id,\n                                         orig_ident.span,\n-                                        &format!(\n+                                        format!(\n                                             \"cannot find {} `{}` in this scope\",\n                                             ns.descr(),\n                                             ident"}, {"sha": "2044798f4d01d5cf5d5a243ca7e204553673eec5", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -578,7 +578,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut diag = struct_span_err!(self.tcx.sess, span, E0432, \"{}\", &msg);\n \n         if let Some((_, UnresolvedImportError { note: Some(note), .. })) = errors.iter().last() {\n-            diag.note(note);\n+            diag.note(note.clone());\n         }\n \n         for (import, err) in errors.into_iter().take(MAX_LABEL_COUNT) {\n@@ -588,10 +588,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             if let Some((suggestions, msg, applicability)) = err.suggestion {\n                 if suggestions.is_empty() {\n-                    diag.help(&msg);\n+                    diag.help(msg);\n                     continue;\n                 }\n-                diag.multipart_suggestion(&msg, suggestions, applicability);\n+                diag.multipart_suggestion(msg, suggestions, applicability);\n             }\n \n             if let Some(candidates) = &err.candidates {\n@@ -1063,7 +1063,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n                     import_id,\n                     import.span,\n-                    &msg,\n+                    msg,\n                 );\n             } else {\n                 let error_msg = if crate_private_reexport {\n@@ -1084,7 +1084,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     struct_span_err!(self.tcx.sess, import.span, E0365, \"{}\", error_msg)\n                         .span_label(import.span, label_msg)\n-                        .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n+                        .note(format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                         .emit();\n                 } else {\n                     let mut err =\n@@ -1102,7 +1102,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         _ => {\n                             err.span_note(\n                                 import.span,\n-                                &format!(\n+                                format!(\n                                     \"consider marking `{ident}` as `pub` in the imported module\"\n                                 ),\n                             );\n@@ -1200,7 +1200,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 UNUSED_IMPORTS,\n                 id,\n                 import.span,\n-                &format!(\"the item `{}` is imported redundantly\", ident),\n+                format!(\"the item `{}` is imported redundantly\", ident),\n                 BuiltinLintDiagnostics::RedundantImport(redundant_spans, ident),\n             );\n         }"}, {"sha": "11d2b975fec6d38c11e76bb2bb9a4034a7ef4143", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -2198,7 +2198,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     this.r\n                         .tcx\n                         .sess\n-                        .span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n+                        .span_err(ident.span, format!(\"imports cannot refer to {}\", what));\n                 }\n             };\n "}, {"sha": "e215b6b7090ae8414a1b620efa63112461ad463c", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -315,8 +315,11 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         debug!(?res, ?source);\n         let base_error = self.make_base_error(path, span, source, res);\n         let code = source.error_code(res.is_some());\n-        let mut err =\n-            self.r.tcx.sess.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n+        let mut err = self.r.tcx.sess.struct_span_err_with_code(\n+            base_error.span,\n+            base_error.msg.clone(),\n+            code,\n+        );\n \n         self.suggest_swapping_misplaced_self_ty_and_trait(&mut err, source, res, base_error.span);\n \n@@ -332,7 +335,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n         if self.suggest_pattern_match_with_let(&mut err, source, span) {\n             // Fallback label.\n-            err.span_label(base_error.span, &base_error.fallback_label);\n+            err.span_label(base_error.span, base_error.fallback_label);\n             return (err, Vec::new());\n         }\n \n@@ -358,7 +361,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n         if fallback {\n             // Fallback label.\n-            err.span_label(base_error.span, &base_error.fallback_label);\n+            err.span_label(base_error.span, base_error.fallback_label);\n         }\n         self.err_code_special_cases(&mut err, source, path, span);\n \n@@ -509,7 +512,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n                 err.span_suggestions(\n                     span,\n-                    &msg,\n+                    msg,\n                     enum_candidates.into_iter().map(|(_variant_path, enum_ty_path)| enum_ty_path),\n                     Applicability::MachineApplicable,\n                 );\n@@ -556,7 +559,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     | AssocSuggestion::AssocType => {\n                         err.span_suggestion(\n                             span,\n-                            &format!(\"you might have meant to {}\", candidate.action()),\n+                            format!(\"you might have meant to {}\", candidate.action()),\n                             format!(\"Self::{path_str}\"),\n                             Applicability::MachineApplicable,\n                         );\n@@ -577,7 +580,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n                 err.span_suggestion(\n                     call_span,\n-                    &format!(\"try calling `{ident}` as a method\"),\n+                    format!(\"try calling `{ident}` as a method\"),\n                     format!(\"self.{path_str}({args_snippet})\"),\n                     Applicability::MachineApplicable,\n                 );\n@@ -609,7 +612,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     ident.name == path[0].ident.name {\n                     err.span_help(\n                         ident.span,\n-                        &format!(\"the binding `{}` is available in a different scope in the same function\", path_str),\n+                        format!(\"the binding `{}` is available in a different scope in the same function\", path_str),\n                     );\n                     return (true, candidates);\n                 }\n@@ -890,7 +893,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 if let Some(ident) = fn_kind.ident() {\n                     err.span_label(\n                         ident.span,\n-                        &format!(\"this function {} have a `self` parameter\", doesnt),\n+                        format!(\"this function {} have a `self` parameter\", doesnt),\n                     );\n                 }\n             }\n@@ -1066,7 +1069,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     if ident.span == span {\n                         err.span_suggestion_verbose(\n                             *where_span,\n-                            &format!(\"constrain the associated type to `{}`\", ident),\n+                            format!(\"constrain the associated type to `{}`\", ident),\n                             format!(\n                                 \"{}: {}<{} = {}>\",\n                                 self.r\n@@ -1267,7 +1270,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 }\n                 PathSource::Expr(_) | PathSource::TupleStruct(..) | PathSource::Pat => {\n                     let span = find_span(&source, err);\n-                    err.span_label(self.r.def_span(def_id), &format!(\"`{path_str}` defined here\"));\n+                    err.span_label(self.r.def_span(def_id), format!(\"`{path_str}` defined here\"));\n \n                     let (tail, descr, applicability, old_fields) = match source {\n                         PathSource::Pat => (\"\", \"pattern\", Applicability::MachineApplicable, None),\n@@ -1311,7 +1314,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     };\n                     err.span_suggestion(\n                         span,\n-                        &format!(\"use struct {} syntax instead\", descr),\n+                        format!(\"use struct {} syntax instead\", descr),\n                         format!(\"{path_str} {{{pad}{fields}{pad}}}\"),\n                         applicability,\n                     );\n@@ -1453,7 +1456,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     if non_visible_spans.len() > 0 {\n                         if let Some(fields) = self.r.field_visibility_spans.get(&def_id) {\n                             err.multipart_suggestion_verbose(\n-                                &format!(\n+                                format!(\n                                     \"consider making the field{} publicly accessible\",\n                                     pluralize!(fields.len())\n                                 ),\n@@ -1483,7 +1486,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                         let span = find_span(&source, err);\n                         err.span_label(\n                             self.r.def_span(def_id),\n-                            &format!(\"`{path_str}` defined here\"),\n+                            format!(\"`{path_str}` defined here\"),\n                         );\n                         err.span_suggestion(\n                             span,\n@@ -1497,7 +1500,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n             (Res::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_def_id), _) if ns == ValueNS => {\n                 let def_id = self.r.tcx.parent(ctor_def_id);\n-                err.span_label(self.r.def_span(def_id), &format!(\"`{path_str}` defined here\"));\n+                err.span_label(self.r.def_span(def_id), format!(\"`{path_str}` defined here\"));\n                 let fields = self.r.field_def_ids(def_id).map_or_else(\n                     || \"/* fields */\".to_string(),\n                     |field_ids| vec![\"_\"; field_ids.len()].join(\", \"),\n@@ -1899,25 +1902,25 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n                 err.span_suggestions(\n                     span,\n-                    &msg,\n+                    msg,\n                     suggestable_variants,\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n \n             // If the enum has no tuple variants..\n             if non_suggestable_variant_count == variants.len() {\n-                err.help(&format!(\"the enum has no tuple variants {}\", source_msg));\n+                err.help(format!(\"the enum has no tuple variants {}\", source_msg));\n             }\n \n             // If there are also non-tuple variants..\n             if non_suggestable_variant_count == 1 {\n-                err.help(&format!(\n+                err.help(format!(\n                     \"you might have meant {} the enum's non-tuple variant\",\n                     source_msg\n                 ));\n             } else if non_suggestable_variant_count >= 1 {\n-                err.help(&format!(\n+                err.help(format!(\n                     \"you might have meant {} one of the enum's non-tuple variants\",\n                     source_msg\n                 ));\n@@ -2167,7 +2170,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                         lint::builtin::SINGLE_USE_LIFETIMES,\n                         param.id,\n                         param.ident.span,\n-                        &format!(\"lifetime parameter `{}` only used once\", param.ident),\n+                        format!(\"lifetime parameter `{}` only used once\", param.ident),\n                         lint::BuiltinLintDiagnostics::SingleUseLifetime {\n                             param_span: param.ident.span,\n                             use_span: Some((use_span, elidable)),\n@@ -2186,7 +2189,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             lint::builtin::UNUSED_LIFETIMES,\n                             param.id,\n                             param.ident.span,\n-                            &format!(\"lifetime parameter `{}` never used\", param.ident),\n+                            format!(\"lifetime parameter `{}` never used\", param.ident),\n                             lint::BuiltinLintDiagnostics::SingleUseLifetime {\n                                 param_span: param.ident.span,\n                                 use_span: None,\n@@ -2252,7 +2255,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                         suggest_note = false; // Avoid displaying the same help multiple times.\n                         err.span_label(\n                             span,\n-                            &format!(\n+                            format!(\n                                 \"lifetime `{}` is missing in item created through this procedural macro\",\n                                 name,\n                             ),\n@@ -2458,13 +2461,13 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     )];\n                 }\n             } else if num_params == 1 {\n-                err.help(&format!(\n+                err.help(format!(\n                     \"this function's return type contains a borrowed value, \\\n                  but the signature does not say which {} it is borrowed from\",\n                     m\n                 ));\n             } else {\n-                err.help(&format!(\n+                err.help(format!(\n                     \"this function's return type contains a borrowed value, \\\n                  but the signature does not say whether it is borrowed from {}\",\n                     m\n@@ -2533,7 +2536,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n             1 => {\n                 err.multipart_suggestion_verbose(\n-                    &format!(\"consider using the `{}` lifetime\", existing_name),\n+                    format!(\"consider using the `{}` lifetime\", existing_name),\n                     spans_suggs,\n                     Applicability::MaybeIncorrect,\n                 );\n@@ -2584,7 +2587,7 @@ pub(super) fn signal_label_shadowing(sess: &Session, orig: Span, shadower: Ident\n     let shadower = shadower.span;\n     let mut err = sess.struct_span_warn(\n         shadower,\n-        &format!(\"label name `{}` shadows a label name that is already in scope\", name),\n+        format!(\"label name `{}` shadows a label name that is already in scope\", name),\n     );\n     err.span_label(orig, \"first declared here\");\n     err.span_label(shadower, format!(\"label `{}` already in scope\", name));"}, {"sha": "4da43c6a9a2dbacc01ffdeac54b0a339b6a38c30", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -121,7 +121,7 @@ pub(crate) fn registered_tools(tcx: TyCtxt<'_>, (): ()) -> RegisteredTools {\n                     if let Some(old_ident) = registered_tools.replace(ident) {\n                         let msg = format!(\"{} `{}` was already registered\", \"tool\", ident);\n                         tcx.sess\n-                            .struct_span_err(ident.span, &msg)\n+                            .struct_span_err(ident.span, msg)\n                             .span_label(old_ident.span, \"already registered here\")\n                             .emit();\n                     }\n@@ -130,7 +130,7 @@ pub(crate) fn registered_tools(tcx: TyCtxt<'_>, (): ()) -> RegisteredTools {\n                     let msg = format!(\"`{}` only accepts identifiers\", sym::register_tool);\n                     let span = nested_meta.span();\n                     tcx.sess\n-                        .struct_span_err(span, &msg)\n+                        .struct_span_err(span, msg)\n                         .span_label(span, \"not an identifier\")\n                         .emit();\n                 }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n             self.tcx\n                 .sess\n                 .diagnostic()\n-                .bug(&format!(\"built-in macro `{}` was already registered\", name));\n+                .bug(format!(\"built-in macro `{}` was already registered\", name));\n         }\n     }\n \n@@ -315,7 +315,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n                 UNUSED_MACROS,\n                 node_id,\n                 ident.span,\n-                &format!(\"unused macro definition: `{}`\", ident.name),\n+                format!(\"unused macro definition: `{}`\", ident.name),\n             );\n         }\n         for (&(def_id, arm_i), &(ident, rule_span)) in self.unused_macro_rules.iter() {\n@@ -328,7 +328,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n                 UNUSED_MACRO_RULES,\n                 node_id,\n                 rule_span,\n-                &format!(\n+                format!(\n                     \"{} rule of macro `{}` is never used\",\n                     crate::diagnostics::ordinalize(arm_i + 1),\n                     ident.name\n@@ -698,7 +698,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         Segment::names_to_string(path)\n                     );\n                     let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n-                    this.tcx.sess.struct_span_err(span, &msg).note(msg_note).emit();\n+                    this.tcx.sess.struct_span_err(span, msg).note(msg_note).emit();\n                 }\n             }\n         };\n@@ -788,7 +788,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Err(..) => {\n                     let expected = kind.descr_expected();\n                     let msg = format!(\"cannot find {} `{}` in this scope\", expected, ident);\n-                    let mut err = self.tcx.sess.struct_span_err(ident.span, &msg);\n+                    let mut err = self.tcx.sess.struct_span_err(ident.span, msg);\n                     self.unresolved_macro_suggestions(&mut err, kind, &parent_scope, ident);\n                     err.emit();\n                 }\n@@ -866,9 +866,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if kind != NonMacroAttrKind::Tool && binding.map_or(true, |b| b.is_import()) {\n                 let msg =\n                     format!(\"cannot use {} {} through an import\", kind.article(), kind.descr());\n-                let mut err = self.tcx.sess.struct_span_err(span, &msg);\n+                let mut err = self.tcx.sess.struct_span_err(span, msg);\n                 if let Some(binding) = binding {\n-                    err.span_note(binding.span, &format!(\"the {} imported here\", kind.descr()));\n+                    err.span_note(binding.span, format!(\"the {} imported here\", kind.descr()));\n                 }\n                 err.emit();\n             }\n@@ -883,7 +883,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if macro_kind.is_some() && sub_namespace_match(macro_kind, Some(MacroKind::Attr)) {\n                 self.tcx.sess.span_err(\n                     ident.span,\n-                    &format!(\"name `{}` is reserved in attribute namespace\", ident),\n+                    format!(\"name `{}` is reserved in attribute namespace\", ident),\n                 );\n             }\n         }\n@@ -927,7 +927,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 let msg = format!(\"cannot find a built-in macro with name `{}`\", item.ident);\n-                self.tcx.sess.span_err(item.span, &msg);\n+                self.tcx.sess.span_err(item.span, msg);\n             }\n         }\n "}, {"sha": "69b3c1e7effbf45eb96c41a8adec6c7a371700f1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -271,7 +271,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                 let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n                 err.span_suggestion_verbose(\n                     closure_arg_span.unwrap_or(found_span),\n-                    &format!(\n+                    format!(\n                         \"consider changing the closure to take and ignore the expected argument{}\",\n                         pluralize!(expected_args.len())\n                     ),\n@@ -575,7 +575,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             Limit(0) => Limit(2),\n             limit => limit * 2,\n         };\n-        err.help(&format!(\n+        err.help(format!(\n             \"consider increasing the recursion limit by adding a \\\n              `#![recursion_limit = \\\"{}\\\"]` attribute to your crate (`{}`)\",\n             suggested_limit,\n@@ -737,7 +737,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         if is_try_conversion && let Some(ret_span) = self.return_type_span(&obligation) {\n                             err.span_label(\n                                 ret_span,\n-                                &format!(\n+                                format!(\n                                     \"expected `{}` because of this\",\n                                     trait_ref.skip_binder().self_ty()\n                                 ),\n@@ -780,15 +780,15 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             err.emit();\n                             return;\n                         }\n-                        if let Some(ref s) = label {\n+                        if let Some(s) = label {\n                             // If it has a custom `#[rustc_on_unimplemented]`\n                             // error message, let's display it as the label!\n                             err.span_label(span, s);\n                             if !matches!(trait_ref.skip_binder().self_ty().kind(), ty::Param(_)) {\n                                 // When the self type is a type param We don't need to \"the trait\n                                 // `std::marker::Sized` is not implemented for `T`\" as we will point\n                                 // at the type param with a label to suggest constraining it.\n-                                err.help(&explanation);\n+                                err.help(explanation);\n                             }\n                         } else if let Some(custom_explanation) = safe_transmute_explanation {\n                             err.span_label(span, custom_explanation);\n@@ -811,13 +811,13 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             );\n \n                         if let Some((msg, span)) = type_def {\n-                            err.span_label(span, &msg);\n+                            err.span_label(span, msg);\n                         }\n-                        if let Some(ref s) = note {\n+                        if let Some(s) = note {\n                             // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n-                            err.note(s.as_str());\n+                            err.note(s);\n                         }\n-                        if let Some(ref s) = parent_label {\n+                        if let Some(s) = parent_label {\n                             let body = obligation.cause.body_id;\n                             err.span_label(tcx.def_span(body), s);\n                         }\n@@ -1028,7 +1028,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 // which bounds actually failed to hold.\n                                 self.tcx.sess.struct_span_err(\n                                     span,\n-                                    &format!(\"the type `{}` is not well-formed\", ty),\n+                                    format!(\"the type `{}` is not well-formed\", ty),\n                                 )\n                             }\n                         }\n@@ -1071,7 +1071,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n                         let mut diag = self.tcx.sess.struct_span_err(\n                             span,\n-                            &format!(\"the constant `{}` is not of type `{}`\", ct, ty),\n+                            format!(\"the constant `{}` is not of type `{}`\", ct, ty),\n                         );\n                         self.note_type_err(\n                             &mut diag,\n@@ -1835,7 +1835,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             candidates.sort();\n             candidates.dedup();\n             let end = if candidates.len() <= 9 { candidates.len() } else { 8 };\n-            err.help(&format!(\n+            err.help(format!(\n                 \"the following {other}types implement trait `{}`:{}{}\",\n                 trait_ref.print_only_trait_path(),\n                 candidates[..end].join(\"\"),\n@@ -2026,7 +2026,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 \"perhaps two different versions of crate `{}` are being used?\",\n                 trait_crate\n             );\n-            err.note(&crate_msg);\n+            err.note(crate_msg);\n             suggested = true;\n         }\n         suggested\n@@ -2158,7 +2158,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 err.cancel();\n                                 return;\n                             }\n-                            err.note(&format!(\"cannot satisfy `{}`\", predicate));\n+                            err.note(format!(\"cannot satisfy `{}`\", predicate));\n                             let impl_candidates = self.find_similar_impl_candidates(\n                                 predicate.to_opt_poly_trait_pred().unwrap(),\n                             );\n@@ -2178,7 +2178,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             err.cancel();\n                             return;\n                         }\n-                        err.note(&format!(\"cannot satisfy `{}`\", predicate));\n+                        err.note(format!(\"cannot satisfy `{}`\", predicate));\n                     }\n                 }\n \n@@ -2223,9 +2223,9 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         err.cancel();\n                         err = self.tcx.sess.struct_span_err_with_code(\n                             span,\n-                            &format!(\n+                            format!(\n                                 \"cannot {verb} associated {noun} on trait without specifying the corresponding `impl` type\",\n-                             ),\n+                            ),\n                             rustc_errors::error_code!(E0790),\n                         );\n \n@@ -2332,7 +2332,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         ErrorCode::E0284,\n                         true,\n                     );\n-                    err.note(&format!(\"cannot satisfy `{}`\", predicate));\n+                    err.note(format!(\"cannot satisfy `{}`\", predicate));\n                     err\n                 } else {\n                     // If we can't find a substitution, just print a generic error\n@@ -2343,7 +2343,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         \"type annotations needed: cannot satisfy `{}`\",\n                         predicate,\n                     );\n-                    err.span_label(span, &format!(\"cannot satisfy `{}`\", predicate));\n+                    err.span_label(span, format!(\"cannot satisfy `{}`\", predicate));\n                     err\n                 }\n             }\n@@ -2371,7 +2371,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         \"type annotations needed: cannot satisfy `{}`\",\n                         predicate,\n                     );\n-                    err.span_label(span, &format!(\"cannot satisfy `{}`\", predicate));\n+                    err.span_label(span, format!(\"cannot satisfy `{}`\", predicate));\n                     err\n                 }\n             }\n@@ -2386,7 +2386,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     \"type annotations needed: cannot satisfy `{}`\",\n                     predicate,\n                 );\n-                err.span_label(span, &format!(\"cannot satisfy `{}`\", predicate));\n+                err.span_label(span, format!(\"cannot satisfy `{}`\", predicate));\n                 err\n             }\n         };\n@@ -2459,13 +2459,13 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         match (spans.len(), crates.len(), crate_names.len()) {\n             (0, 0, 0) => {\n-                err.note(&format!(\"cannot satisfy `{}`\", predicate));\n+                err.note(format!(\"cannot satisfy `{}`\", predicate));\n             }\n             (0, _, 1) => {\n-                err.note(&format!(\"{} in the `{}` crate{}\", msg, crates[0], post,));\n+                err.note(format!(\"{} in the `{}` crate{}\", msg, crates[0], post,));\n             }\n             (0, _, _) => {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"{} in the following crates: {}{}\",\n                     msg,\n                     crate_names.join(\", \"),\n@@ -2474,19 +2474,17 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n             (_, 0, 0) => {\n                 let span: MultiSpan = spans.into();\n-                err.span_note(span, &msg);\n+                err.span_note(span, msg);\n             }\n             (_, 1, 1) => {\n                 let span: MultiSpan = spans.into();\n-                err.span_note(span, &msg);\n-                err.note(\n-                    &format!(\"and another `impl` found in the `{}` crate{}\", crates[0], post,),\n-                );\n+                err.span_note(span, msg);\n+                err.note(format!(\"and another `impl` found in the `{}` crate{}\", crates[0], post,));\n             }\n             _ => {\n                 let span: MultiSpan = spans.into();\n-                err.span_note(span, &msg);\n-                err.note(&format!(\n+                err.span_note(span, msg);\n+                err.note(format!(\n                     \"and more `impl`s found in the following crates: {}{}\",\n                     crate_names.join(\", \"),\n                     post,\n@@ -2657,7 +2655,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n         err.span_help(\n             multispan,\n-            &format!(\n+            format!(\n                 \"you could relax the implicit `Sized` bound on `{T}` if it were \\\n                 used through indirection like `&{T}` or `Box<{T}>`\",\n                 T = param.name.ident(),\n@@ -2882,7 +2880,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             .fn_trait_kind_from_def_id(trait_ref.def_id())\n             .expect(\"expected to map DefId to ClosureKind\");\n         if !implemented_kind.extends(selected_kind) {\n-            err.note(&format!(\n+            err.note(format!(\n                 \"`{}` implements `{}`, but it must implement `{}`, which is more general\",\n                 trait_ref.skip_binder().self_ty(),\n                 implemented_kind,\n@@ -2899,7 +2897,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             if expected.len() != given.len() {\n                 // Note number of types that were expected and given\n                 err.note(\n-                    &format!(\n+                    format!(\n                         \"expected a closure taking {} argument{}, but one taking {} argument{} was given\",\n                         given.len(),\n                         pluralize!(given.len()),\n@@ -2942,7 +2940,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 unsatisfied_const = UnsatisfiedConst(true);\n                 err.span_note(\n                     span,\n-                    &format!(\n+                    format!(\n                         \"the trait `{}` is implemented for `{}`, \\\n                         but that implementation is not `const`\",\n                         non_const_predicate.print_modifiers_and_trait_path(),\n@@ -3171,7 +3169,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 let mut err = self.tcx.sess.struct_span_err(span, \"unconstrained generic constant\");\n                 let const_span = self.tcx.def_span(uv.def);\n                 match self.tcx.sess.source_map().span_to_snippet(const_span) {\n-                    Ok(snippet) => err.help(&format!(\n+                    Ok(snippet) => err.help(format!(\n                         \"try adding a `where` bound using this expression: `where [(); {}]:`\",\n                         snippet\n                     )),"}, {"sha": "08220c4fe9fece8bb8cbbf8d4c38b47a354c39d5", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -515,7 +515,7 @@ fn suggest_restriction<'tcx>(\n \n         err.span_suggestion_verbose(\n             sp,\n-            &format!(\"consider further restricting {}\", msg),\n+            format!(\"consider further restricting {}\", msg),\n             suggestion,\n             Applicability::MachineApplicable,\n         );\n@@ -964,7 +964,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // a more general note.\n             err.span_suggestion_verbose(\n                 obligation.cause.span.shrink_to_hi(),\n-                &msg,\n+                msg,\n                 format!(\"({args})\"),\n                 Applicability::HasPlaceholders,\n             );\n@@ -994,7 +994,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n                 _ => return false,\n             };\n-            err.help(&format!(\"{msg}: `{name}({args})`\"));\n+            err.help(format!(\"{msg}: `{name}({args})`\"));\n         }\n         true\n     }\n@@ -1334,7 +1334,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n                     let msg = format!(\"the trait bound `{}` is not satisfied\", old_pred);\n                     if has_custom_message {\n-                        err.note(&msg);\n+                        err.note(msg);\n                     } else {\n                         err.message =\n                             vec![(rustc_errors::DiagnosticMessage::Str(msg), Style::NoStyle)];\n@@ -1358,7 +1358,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     } else {\n                         let is_mut = mut_ref_self_ty_satisfies_pred || ref_inner_ty_mut;\n                         let sugg_prefix = format!(\"&{}\", if is_mut { \"mut \" } else { \"\" });\n-                        let sugg_msg = &format!(\n+                        let sugg_msg = format!(\n                             \"consider{} borrowing here\",\n                             if is_mut { \" mutably\" } else { \"\" }\n                         );\n@@ -1452,7 +1452,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         err.span_suggestion(\n             obligation.cause.span.shrink_to_lo(),\n-            &format!(\n+            format!(\n                 \"consider borrowing the value, since `&{self_ty}` can be coerced into `{object_ty}`\"\n             ),\n             \"&\",\n@@ -1505,7 +1505,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 };\n \n                 err.multipart_suggestion_verbose(\n-                    &msg,\n+                    msg,\n                     suggestions,\n                     Applicability::MachineApplicable,\n                 );\n@@ -1617,7 +1617,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) =\n                     obligation.predicate.kind().skip_binder()\n                 {\n-                    err.span_label(*span, &format!(\"this call returns `{}`\", pred.self_ty()));\n+                    err.span_label(*span, format!(\"this call returns `{}`\", pred.self_ty()));\n                 }\n                 if let Some(typeck_results) = &self.typeck_results\n                         && let ty = typeck_results.expr_ty_adjusted(base)\n@@ -1632,14 +1632,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         if vis_span.is_empty() {\n                             err.span_suggestion_verbose(\n                                 span.shrink_to_lo(),\n-                                &msg,\n+                                msg,\n                                 \"async \",\n                                 Applicability::MaybeIncorrect,\n                             );\n                         } else {\n                             err.span_suggestion_verbose(\n                                 vis_span.shrink_to_hi(),\n-                                &msg,\n+                                msg,\n                                 \" async\",\n                                 Applicability::MaybeIncorrect,\n                             );\n@@ -1717,7 +1717,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                     } else {\n-                        err.note(&format!(\n+                        err.note(format!(\n                             \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n                             trait_pred.print_modifiers_and_trait_path(),\n                             suggested_ty,\n@@ -1754,7 +1754,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         {\n             err.span_label(\n                 expr.span,\n-                &format!(\n+                format!(\n                     \"this expression has type `{}`, which implements `{}`\",\n                     ty,\n                     trait_pred.print_modifiers_and_trait_path()\n@@ -1946,7 +1946,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // Suggest `-> impl Trait`.\n             err.span_suggestion(\n                 ret_ty.span,\n-                &format!(\n+                format!(\n                     \"use `impl {1}` as the return type, as all return paths are of type `{}`, \\\n                      which implements `{1}`\",\n                     last_ty, trait_obj,\n@@ -1981,13 +1981,13 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             } else {\n                 // This is currently not possible to trigger because E0038 takes precedence, but\n                 // leave it in for completeness in case anything changes in an earlier stage.\n-                err.note(&format!(\n+                err.note(format!(\n                     \"if trait `{}` were object-safe, you could return a trait object\",\n                     trait_obj,\n                 ));\n             }\n             err.note(trait_obj_msg);\n-            err.note(&format!(\n+            err.note(format!(\n                 \"if all the returned values were of the same type you could use `impl {}` as the \\\n                  return type\",\n                 trait_obj,\n@@ -2027,7 +2027,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     } else {\n                         err.span_label(\n                             expr.span,\n-                            &format!(\"this returned value is of type `{}`\", ty),\n+                            format!(\"this returned value is of type `{}`\", ty),\n                         );\n                     }\n                 }\n@@ -2177,7 +2177,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     ) {\n         if let Some(assoc_item) = self.tcx.opt_associated_item(item_def_id) {\n             if let ty::AssocKind::Const | ty::AssocKind::Type = assoc_item.kind {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"{}s cannot be accessed directly on a `trait`, they can only be \\\n                         accessed through a specific `impl`\",\n                     self.tcx.def_kind_descr(assoc_item.kind.as_def_kind(), item_def_id)\n@@ -2607,7 +2607,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n                 err.span_note(\n                     span,\n-                    &format!(\n+                    format!(\n                         \"{} {} as this value is used across {}\",\n                         future_or_generator, trait_explanation, an_await_or_yield\n                     ),\n@@ -2628,7 +2628,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         );\n                         err.span_note(\n                             span,\n-                            &format!(\n+                            format!(\n                                 \"future {not_trait} as it awaits another future which {not_trait}\",\n                                 not_trait = trait_explanation\n                             ),\n@@ -2730,7 +2730,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n                 let mut span = MultiSpan::from_span(upvar_span);\n                 span.push_span_label(upvar_span, span_label);\n-                err.span_note(span, &span_note);\n+                err.span_note(span, span_note);\n             }\n         }\n \n@@ -2794,15 +2794,15 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 err.note(\"only the last element of a tuple may have a dynamically sized type\");\n             }\n             ObligationCauseCode::ProjectionWf(data) => {\n-                err.note(&format!(\"required so that the projection `{data}` is well-formed\"));\n+                err.note(format!(\"required so that the projection `{data}` is well-formed\"));\n             }\n             ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"required so that reference `{ref_ty}` does not outlive its referent\"\n                 ));\n             }\n             ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n-                err.note(&format!(\n+                err.note(format!(\n                     \"required so that the lifetime bound of `{}` for `{}` is satisfied\",\n                     region, object_ty,\n                 ));\n@@ -2838,34 +2838,34 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if span.is_visible(sm) {\n                     let msg = format!(\"required by this bound in `{short_item_name}`\");\n                     multispan.push_span_label(span, msg);\n-                    err.span_note(multispan, &descr);\n+                    err.span_note(multispan, descr);\n                 } else {\n-                    err.span_note(tcx.def_span(item_def_id), &descr);\n+                    err.span_note(tcx.def_span(item_def_id), descr);\n                 }\n             }\n             ObligationCauseCode::ObjectCastObligation(concrete_ty, object_ty) => {\n                 let (concrete_ty, concrete_file) =\n                     self.tcx.short_ty_string(self.resolve_vars_if_possible(concrete_ty));\n                 let (object_ty, object_file) =\n                     self.tcx.short_ty_string(self.resolve_vars_if_possible(object_ty));\n-                err.note(&with_forced_trimmed_paths!(format!(\n+                err.note(with_forced_trimmed_paths!(format!(\n                     \"required for the cast from `{concrete_ty}` to the object type `{object_ty}`\",\n                 )));\n                 if let Some(file) = concrete_file {\n-                    err.note(&format!(\n+                    err.note(format!(\n                         \"the full name for the casted type has been written to '{}'\",\n                         file.display(),\n                     ));\n                 }\n                 if let Some(file) = object_file {\n-                    err.note(&format!(\n+                    err.note(format!(\n                         \"the full name for the object type has been written to '{}'\",\n                         file.display(),\n                     ));\n                 }\n             }\n             ObligationCauseCode::Coercion { source: _, target } => {\n-                err.note(&format!(\"required by cast to type `{}`\", self.ty_to_string(target)));\n+                err.note(format!(\"required by cast to type `{}`\", self.ty_to_string(target)));\n             }\n             ObligationCauseCode::RepeatElementCopy { is_const_fn } => {\n                 err.note(\n@@ -3068,8 +3068,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         ));\n                         match ty.kind() {\n                             ty::Adt(def, _) => match self.tcx.opt_item_ident(def.did()) {\n-                                Some(ident) => err.span_note(ident.span, &msg),\n-                                None => err.note(&msg),\n+                                Some(ident) => err.span_note(ident.span, msg),\n+                                None => err.note(msg),\n                             },\n                             ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) => {\n                                 // If the previous type is async fn, this is the future generated by the body of an async function.\n@@ -3090,7 +3090,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 {\n                                     break 'print;\n                                 }\n-                                err.span_note(self.tcx.def_span(def_id), &msg)\n+                                err.span_note(self.tcx.def_span(def_id), msg)\n                             }\n                             ty::GeneratorWitness(bound_tys) => {\n                                 use std::fmt::Write;\n@@ -3126,7 +3126,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 let kind = tcx.generator_kind(def_id).unwrap().descr();\n                                 err.span_note(\n                                     sp,\n-                                    with_forced_trimmed_paths!(&format!(\n+                                    with_forced_trimmed_paths!(format!(\n                                         \"required because it's used within this {kind}\",\n                                     )),\n                                 )\n@@ -3136,7 +3136,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 \"required because it's used within this closure\",\n                             ),\n                             ty::Str => err.note(\"`str` is considered to contain a `[u8]` slice for auto trait purposes\"),\n-                            _ => err.note(&msg),\n+                            _ => err.note(msg),\n                         };\n                     }\n                 }\n@@ -3190,7 +3190,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         // FIXME: we should do something else so that it works even on crate foreign\n                         // auto traits.\n                         is_auto_trait = matches!(is_auto, hir::IsAuto::Yes);\n-                        err.span_note(ident.span, &msg);\n+                        err.span_note(ident.span, msg);\n                     }\n                     Some(Node::Item(hir::Item {\n                         kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n@@ -3219,15 +3219,15 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 \"unsatisfied trait bound introduced here\",\n                             );\n                         }\n-                        err.span_note(spans, &msg);\n+                        err.span_note(spans, msg);\n                     }\n                     _ => {\n-                        err.note(&msg);\n+                        err.note(msg);\n                     }\n                 };\n \n                 if let Some(file) = file {\n-                    err.note(&format!(\n+                    err.note(format!(\n                         \"the full type name has been written to '{}'\",\n                         file.display(),\n                     ));\n@@ -3267,19 +3267,19 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     parent_trait_pred = child_trait_pred;\n                 }\n                 if count > 0 {\n-                    err.note(&format!(\n+                    err.note(format!(\n                         \"{} redundant requirement{} hidden\",\n                         count,\n                         pluralize!(count)\n                     ));\n                     let (self_ty, file) =\n                         self.tcx.short_ty_string(parent_trait_pred.skip_binder().self_ty());\n-                    err.note(&format!(\n+                    err.note(format!(\n                         \"required for `{self_ty}` to implement `{}`\",\n                         parent_trait_pred.print_modifiers_and_trait_path()\n                     ));\n                     if let Some(file) = file {\n-                        err.note(&format!(\n+                        err.note(format!(\n                             \"the full type name has been written to '{}'\",\n                             file.display(),\n                         ));\n@@ -3360,7 +3360,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 {\n                     assoc_span.push_span_label(ident.span, \"in this trait\");\n                 }\n-                err.span_note(assoc_span, &msg);\n+                err.span_note(assoc_span, msg);\n             }\n             ObligationCauseCode::TrivialBound => {\n                 err.help(\"see issue #48214\");\n@@ -3516,7 +3516,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         if can_derive {\n             err.span_suggestion_verbose(\n                 self.tcx.def_span(adt.did()).shrink_to_lo(),\n-                &format!(\n+                format!(\n                     \"consider annotating `{}` with `#[derive({})]`\",\n                     trait_pred.skip_binder().self_ty(),\n                     diagnostic_name,\n@@ -3903,7 +3903,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             .map(|trait_ref| trait_ref.trait_ref.self_ty())\n             .find(|t| is_slice(*t))\n         {\n-            let msg = &format!(\"convert the array to a `{}` slice instead\", slice_ty);\n+            let msg = format!(\"convert the array to a `{}` slice instead\", slice_ty);\n \n             if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                 let mut suggestions = vec![];\n@@ -4124,7 +4124,7 @@ fn suggest_trait_object_return_type_alternatives(\n ) {\n     err.span_suggestion(\n         ret_ty,\n-        &format!(\n+        format!(\n             \"use `impl {}` as the return type if all return paths have the same type but you \\\n                 want to expose only the trait in the signature\",\n             trait_obj,\n@@ -4134,7 +4134,7 @@ fn suggest_trait_object_return_type_alternatives(\n     );\n     if is_object_safe {\n         err.multipart_suggestion(\n-            &format!(\n+            format!(\n                 \"use a boxed trait object if all return paths implement trait `{}`\",\n                 trait_obj,\n             ),"}, {"sha": "384b6ae93a12a6493d0a4948eae16e824a7b2f6a", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -525,7 +525,7 @@ fn virtual_call_violation_for_method<'tcx>(\n                         // #78372\n                         tcx.sess.delay_span_bug(\n                             tcx.def_span(method.def_id),\n-                            &format!(\"error: {}\\n while computing layout for type {:?}\", err, ty),\n+                            format!(\"error: {}\\n while computing layout for type {:?}\", err, ty),\n                         );\n                         None\n                     }\n@@ -541,7 +541,7 @@ fn virtual_call_violation_for_method<'tcx>(\n                 abi => {\n                     tcx.sess.delay_span_bug(\n                         tcx.def_span(method.def_id),\n-                        &format!(\n+                        format!(\n                             \"receiver when `Self = ()` should have a Scalar ABI; found {:?}\",\n                             abi\n                         ),\n@@ -560,7 +560,7 @@ fn virtual_call_violation_for_method<'tcx>(\n                 abi => {\n                     tcx.sess.delay_span_bug(\n                         tcx.def_span(method.def_id),\n-                        &format!(\n+                        format!(\n                             \"receiver when `Self = {}` should have a ScalarPair ABI; found {:?}\",\n                             trait_object_ty, abi\n                         ),"}, {"sha": "4369b257f5fe7c06238bcc05cc9be2d07f82d8c9", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1749,7 +1749,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // These traits have no associated types.\n                 selcx.tcx().sess.delay_span_bug(\n                     obligation.cause.span,\n-                    &format!(\"Cannot project an associated type from `{:?}`\", impl_source),\n+                    format!(\"Cannot project an associated type from `{:?}`\", impl_source),\n                 );\n                 return Err(());\n             }"}, {"sha": "1f8e756043d235c45e39a7f458e9b1610be67290", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -79,7 +79,7 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     if !errors.is_empty() {\n         infcx.tcx.sess.diagnostic().delay_span_bug(\n             DUMMY_SP,\n-            &format!(\"errors selecting obligation during MIR typeck: {:?}\", errors),\n+            format!(\"errors selecting obligation during MIR typeck: {:?}\", errors),\n         );\n     }\n "}, {"sha": "9890e990eebf0c9700a798ff81bb99d350792f8f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -67,7 +67,7 @@ impl IntercrateAmbiguityCause {\n     /// Emits notes when the overlap is caused by complex intercrate ambiguities.\n     /// See #23980 for details.\n     pub fn add_intercrate_ambiguity_hint(&self, err: &mut Diagnostic) {\n-        err.note(&self.intercrate_ambiguity_hint());\n+        err.note(self.intercrate_ambiguity_hint());\n     }\n \n     pub fn intercrate_ambiguity_hint(&self) -> String {\n@@ -2449,7 +2449,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                 // for a variable being generalized...\n                 let guar = self.infcx.tcx.sess.delay_span_bug(\n                     obligation.cause.span,\n-                    &format!(\n+                    format!(\n                         \"Impl {:?} was matchable against {:?} but now is not\",\n                         impl_def_id, obligation\n                     ),"}, {"sha": "233d35aed3820b777ea86cc5606e2b427cd4b040", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -373,7 +373,7 @@ fn report_conflicting_impls<'tcx>(\n                     }\n                     None => format!(\"conflicting implementation in crate `{}`\", cname),\n                 };\n-                err.note(&msg);\n+                err.note(msg);\n             }\n         }\n "}, {"sha": "fcdffc7468b82acefecf8953b6f5ae99a512aadf", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -190,7 +190,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n \n                 tcx.sess.delay_span_bug(\n                     span,\n-                    &format!(\"upvar_tys for closure not found. Expected capture information for closure {ty}\",),\n+                    format!(\"upvar_tys for closure not found. Expected capture information for closure {ty}\",),\n                 );\n                 return Err(NoSolution);\n             }\n@@ -232,7 +232,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n                 // be fully resolved.\n                 tcx.sess.delay_span_bug(\n                     span,\n-                    &format!(\"upvar_tys for generator not found. Expected capture information for generator {ty}\",),\n+                    format!(\"upvar_tys for generator not found. Expected capture information for generator {ty}\",),\n                 );\n                 return Err(NoSolution);\n             }"}, {"sha": "eedf459ce8fbc15b1b1599f261a69d8ebd26d87d", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -85,7 +85,7 @@ fn resolve_associated_item<'tcx>(\n         Err(CodegenObligationError::Ambiguity) => {\n             let reported = tcx.sess.delay_span_bug(\n                 tcx.def_span(trait_item_id),\n-                &format!(\n+                format!(\n                     \"encountered ambiguity selecting `{trait_ref:?}` during codegen, presuming due to \\\n                      overflow or prior type error\",\n                 ),"}, {"sha": "a04f85afb9ee2754e114bf3e8dafc22d2f6d88e9", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -132,7 +132,7 @@ where\n                             _ => {\n                                 tcx.sess.delay_span_bug(\n                                     tcx.hir().span_if_local(def_id).unwrap_or(DUMMY_SP),\n-                                    &format!(\"unexpected generator witness type {:?}\", witness),\n+                                    format!(\"unexpected generator witness type {:?}\", witness),\n                                 );\n                                 return Some(Err(AlwaysRequiresDrop));\n                             }"}, {"sha": "dfa4b091b0164ed30e2edf7707c3f4ebd2845c68", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -382,7 +382,7 @@ impl Options {\n                 match kind.parse() {\n                     Ok(kind) => emit.push(kind),\n                     Err(()) => {\n-                        diag.err(&format!(\"unrecognized emission type: {}\", kind));\n+                        diag.err(format!(\"unrecognized emission type: {}\", kind));\n                         return Err(1);\n                     }\n                 }\n@@ -559,28 +559,28 @@ impl Options {\n                 matches.opt_strs(\"theme\").iter().map(|s| (PathBuf::from(&s), s.to_owned()))\n             {\n                 if !theme_file.is_file() {\n-                    diag.struct_err(&format!(\"invalid argument: \\\"{}\\\"\", theme_s))\n+                    diag.struct_err(format!(\"invalid argument: \\\"{}\\\"\", theme_s))\n                         .help(\"arguments to --theme must be files\")\n                         .emit();\n                     return Err(1);\n                 }\n                 if theme_file.extension() != Some(OsStr::new(\"css\")) {\n-                    diag.struct_err(&format!(\"invalid argument: \\\"{}\\\"\", theme_s))\n+                    diag.struct_err(format!(\"invalid argument: \\\"{}\\\"\", theme_s))\n                         .help(\"arguments to --theme must have a .css extension\")\n                         .emit();\n                     return Err(1);\n                 }\n                 let (success, ret) = theme::test_theme_against(&theme_file, &paths, &diag);\n                 if !success {\n-                    diag.struct_err(&format!(\"error loading theme file: \\\"{}\\\"\", theme_s)).emit();\n+                    diag.struct_err(format!(\"error loading theme file: \\\"{}\\\"\", theme_s)).emit();\n                     return Err(1);\n                 } else if !ret.is_empty() {\n-                    diag.struct_warn(&format!(\n+                    diag.struct_warn(format!(\n                         \"theme file \\\"{}\\\" is missing CSS rules from the default theme\",\n                         theme_s\n                     ))\n                     .warn(\"the theme may appear incorrect when loaded\")\n-                    .help(&format!(\n+                    .help(format!(\n                         \"to see what rules are missing, call `rustdoc --check-theme \\\"{}\\\"`\",\n                         theme_s\n                     ))\n@@ -611,7 +611,7 @@ impl Options {\n         match matches.opt_str(\"r\").as_deref() {\n             Some(\"rust\") | None => {}\n             Some(s) => {\n-                diag.struct_err(&format!(\"unknown input format: {}\", s)).emit();\n+                diag.struct_err(format!(\"unknown input format: {}\", s)).emit();\n                 return Err(1);\n             }\n         }\n@@ -631,7 +631,7 @@ impl Options {\n         let crate_types = match parse_crate_types_from_list(matches.opt_strs(\"crate-type\")) {\n             Ok(types) => types,\n             Err(e) => {\n-                diag.struct_err(&format!(\"unknown crate type: {}\", e)).emit();\n+                diag.struct_err(format!(\"unknown crate type: {}\", e)).emit();\n                 return Err(1);\n             }\n         };\n@@ -649,7 +649,7 @@ impl Options {\n                     out_fmt\n                 }\n                 Err(e) => {\n-                    diag.struct_err(&e).emit();\n+                    diag.struct_err(e).emit();\n                     return Err(1);\n                 }\n             },\n@@ -790,7 +790,7 @@ fn check_deprecated_options(matches: &getopts::Matches, diag: &rustc_errors::Han\n \n     for &flag in deprecated_flags.iter() {\n         if matches.opt_present(flag) {\n-            diag.struct_warn(&format!(\"the `{}` flag is deprecated\", flag))\n+            diag.struct_warn(format!(\"the `{}` flag is deprecated\", flag))\n                 .note(\n                     \"see issue #44136 <https://github.com/rust-lang/rust/issues/44136> \\\n                     for more information\",\n@@ -803,7 +803,7 @@ fn check_deprecated_options(matches: &getopts::Matches, diag: &rustc_errors::Han\n \n     for &flag in removed_flags.iter() {\n         if matches.opt_present(flag) {\n-            let mut err = diag.struct_warn(&format!(\"the `{}` flag no longer functions\", flag));\n+            let mut err = diag.struct_warn(format!(\"the `{}` flag no longer functions\", flag));\n             err.note(\n                 \"see issue #44136 <https://github.com/rust-lang/rust/issues/44136> \\\n                 for more information\","}, {"sha": "a6be132337eb64c9264f31728d3c255fbcbee965", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -383,7 +383,7 @@ pub(crate) fn run_global_ctxt(\n \n     fn report_deprecated_attr(name: &str, diag: &rustc_errors::Handler, sp: Span) {\n         let mut msg =\n-            diag.struct_span_warn(sp, &format!(\"the `#![doc({})]` attribute is deprecated\", name));\n+            diag.struct_span_warn(sp, format!(\"the `#![doc({})]` attribute is deprecated\", name));\n         msg.note(\n             \"see issue #44136 <https://github.com/rust-lang/rust/issues/44136> \\\n             for more information\","}, {"sha": "88049c4ca00512227dcf256939996a367a604994", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -83,14 +83,14 @@ pub(crate) fn load_string<P: AsRef<Path>>(\n     let contents = match fs::read(file_path) {\n         Ok(bytes) => bytes,\n         Err(e) => {\n-            diag.struct_err(&format!(\"error reading `{}`: {}\", file_path.display(), e)).emit();\n+            diag.struct_err(format!(\"error reading `{}`: {}\", file_path.display(), e)).emit();\n             return Err(LoadStringError::ReadFail);\n         }\n     };\n     match str::from_utf8(&contents) {\n         Ok(s) => Ok(s.to_string()),\n         Err(_) => {\n-            diag.struct_err(&format!(\"error reading `{}`: not UTF-8\", file_path.display())).emit();\n+            diag.struct_err(format!(\"error reading `{}`: not UTF-8\", file_path.display())).emit();\n             Err(LoadStringError::BadUtf8)\n         }\n     }"}, {"sha": "01a92f6df6a0c1624fa61ed8307eedb9462b924d", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -746,7 +746,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         // Flush pending errors.\n         Rc::get_mut(&mut self.shared).unwrap().fs.close();\n         let nb_errors =\n-            self.shared.errors.iter().map(|err| self.tcx().sess.struct_err(&err).emit()).count();\n+            self.shared.errors.iter().map(|err| self.tcx().sess.struct_err(err).emit()).count();\n         if nb_errors > 0 {\n             Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n         } else {"}, {"sha": "e09c6480060d054aa5dd4cbe696e660d58a4353f", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -2256,8 +2256,7 @@ fn render_call_locations<W: fmt::Write>(mut w: W, cx: &mut Context<'_>, item: &c\n             Ok(contents) => contents,\n             Err(err) => {\n                 let span = item.span(tcx).map_or(rustc_span::DUMMY_SP, |span| span.inner());\n-                tcx.sess\n-                    .span_err(span, &format!(\"failed to read file {}: {}\", path.display(), err));\n+                tcx.sess.span_err(span, format!(\"failed to read file {}: {}\", path.display(), err));\n                 return false;\n             }\n         };"}, {"sha": "a26fa3749129625aa9b5dca7d7b6c5ef67720cf5", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -145,7 +145,7 @@ impl DocVisitor for SourceCollector<'_, '_> {\n                 Err(e) => {\n                     self.cx.shared.tcx.sess.span_err(\n                         span,\n-                        &format!(\n+                        format!(\n                             \"failed to render source code for `{}`: {}\",\n                             filename.prefer_local(),\n                             e,"}, {"sha": "263ce3d93b9fd1fca6a5d4cea13917bb5589512f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -677,7 +677,7 @@ fn wrap_return(diag: &rustc_errors::Handler, res: Result<(), String>) -> MainRes\n     match res {\n         Ok(()) => diag.has_errors().map_or(Ok(()), Err),\n         Err(err) => {\n-            let reported = diag.struct_err(&err).emit();\n+            let reported = diag.struct_err(err).emit();\n             Err(reported)\n         }\n     }\n@@ -693,10 +693,10 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n         Ok(_) => tcx.sess.has_errors().map_or(Ok(()), Err),\n         Err(e) => {\n             let mut msg =\n-                tcx.sess.struct_err(&format!(\"couldn't generate documentation: {}\", e.error));\n+                tcx.sess.struct_err(format!(\"couldn't generate documentation: {}\", e.error));\n             let file = e.file.display().to_string();\n             if !file.is_empty() {\n-                msg.note(&format!(\"failed to create or modify \\\"{}\\\"\", file));\n+                msg.note(format!(\"failed to create or modify \\\"{}\\\"\", file));\n             }\n             Err(msg.emit())\n         }"}, {"sha": "a885ff0ca5e580d060ebf6bda784194403f3ff41", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -1179,9 +1179,9 @@ impl LinkCollector<'_, '_> {\n                 specified.descr(),\n             );\n             if let Some(sp) = sp {\n-                diag.span_label(sp, &note);\n+                diag.span_label(sp, note);\n             } else {\n-                diag.note(&note);\n+                diag.note(note);\n             }\n             suggest_disambiguator(resolved, diag, path_str, &ori_link.link, sp);\n         };\n@@ -1617,7 +1617,7 @@ fn report_diagnostic(\n             let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n \n             // Print the line containing the `link_range` and manually mark it with '^'s.\n-            lint.note(&format!(\n+            lint.note(format!(\n                 \"the link appears in this line:\\n\\n{line}\\n\\\n                      {indicator: <before$}{indicator:^<found$}\",\n                 line = line,\n@@ -1730,9 +1730,9 @@ fn resolution_failure(\n                             format!(\"no item named `{}` in scope\", unresolved)\n                         };\n                         if let Some(span) = sp {\n-                            diag.span_label(span, &note);\n+                            diag.span_label(span, note);\n                         } else {\n-                            diag.note(&note);\n+                            diag.note(note);\n                         }\n \n                         if !path_str.contains(\"::\") {\n@@ -1787,9 +1787,9 @@ fn resolution_failure(\n                                 let variant = res.name(tcx);\n                                 let note = format!(\"variant `{variant}` has no such field\");\n                                 if let Some(span) = sp {\n-                                    diag.span_label(span, &note);\n+                                    diag.span_label(span, note);\n                                 } else {\n-                                    diag.note(&note);\n+                                    diag.note(note);\n                                 }\n                                 return;\n                             }\n@@ -1812,9 +1812,9 @@ fn resolution_failure(\n                             | InlineConst => {\n                                 let note = assoc_item_not_allowed(res);\n                                 if let Some(span) = sp {\n-                                    diag.span_label(span, &note);\n+                                    diag.span_label(span, note);\n                                 } else {\n-                                    diag.note(&note);\n+                                    diag.note(note);\n                                 }\n                                 return;\n                             }\n@@ -1834,9 +1834,9 @@ fn resolution_failure(\n                         unresolved,\n                     );\n                     if let Some(span) = sp {\n-                        diag.span_label(span, &note);\n+                        diag.span_label(span, note);\n                     } else {\n-                        diag.note(&note);\n+                        diag.note(note);\n                     }\n \n                     continue;\n@@ -1854,9 +1854,9 @@ fn resolution_failure(\n                     }\n                 };\n                 if let Some(span) = sp {\n-                    diag.span_label(span, &note);\n+                    diag.span_label(span, note);\n                 } else {\n-                    diag.note(&note);\n+                    diag.note(note);\n                 }\n             }\n         },\n@@ -1906,7 +1906,7 @@ fn disambiguator_error(\n             \"see {}/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\",\n             crate::DOC_RUST_LANG_ORG_CHANNEL\n         );\n-        diag.note(&msg);\n+        diag.note(msg);\n     });\n }\n \n@@ -2023,13 +2023,13 @@ fn suggest_disambiguator(\n     if let Some(sp) = sp {\n         let mut spans = suggestion.as_help_span(path_str, ori_link, sp);\n         if spans.len() > 1 {\n-            diag.multipart_suggestion(&help, spans, Applicability::MaybeIncorrect);\n+            diag.multipart_suggestion(help, spans, Applicability::MaybeIncorrect);\n         } else {\n             let (sp, suggestion_text) = spans.pop().unwrap();\n-            diag.span_suggestion_verbose(sp, &help, suggestion_text, Applicability::MaybeIncorrect);\n+            diag.span_suggestion_verbose(sp, help, suggestion_text, Applicability::MaybeIncorrect);\n         }\n     } else {\n-        diag.help(&format!(\"{}: {}\", help, suggestion.as_help(path_str)));\n+        diag.help(format!(\"{}: {}\", help, suggestion.as_help(path_str)));\n     }\n }\n "}, {"sha": "8f873dbe501311d04bf74bb0943190d822988437", "filename": "src/librustdoc/passes/lint/check_code_block_syntax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -108,7 +108,7 @@ fn check_rust_syntax(\n                 // just give a `help` instead.\n                 lint.span_help(\n                     sp.from_inner(InnerSpan::new(0, 3)),\n-                    &format!(\"{}: ```text\", explanation),\n+                    format!(\"{}: ```text\", explanation),\n                 );\n             } else if empty_block {\n                 lint.span_suggestion(\n@@ -119,12 +119,12 @@ fn check_rust_syntax(\n                 );\n             }\n         } else if empty_block || is_ignore {\n-            lint.help(&format!(\"{}: ```text\", explanation));\n+            lint.help(format!(\"{}: ```text\", explanation));\n         }\n \n         // FIXME(#67563): Provide more context for these errors by displaying the spans inline.\n         for message in buffer.messages.iter() {\n-            lint.note(message);\n+            lint.note(message.clone());\n         }\n \n         lint"}, {"sha": "d2fa7769bbd2f2a1b450b0d4edd57a0041612688", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -331,7 +331,7 @@ pub(crate) fn run(\n     };\n \n     if let Err(e) = inner() {\n-        tcx.sess.fatal(&e);\n+        tcx.sess.fatal(e);\n     }\n \n     Ok(())\n@@ -358,7 +358,7 @@ pub(crate) fn load_call_locations(\n     };\n \n     inner().map_err(|e: String| {\n-        diag.err(&format!(\"failed to load examples: {}\", e));\n+        diag.err(format!(\"failed to load examples: {}\", e));\n         1\n     })\n }"}, {"sha": "722e01cd1fc72869e10819df7d735204b96394d4", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -241,7 +241,7 @@ pub(crate) fn test_theme_against<P: AsRef<Path>>(\n     {\n         Ok(c) => c,\n         Err(e) => {\n-            diag.struct_err(&e).emit();\n+            diag.struct_err(e).emit();\n             return (false, vec![]);\n         }\n     };"}, {"sha": "d1314795f580344f096db7750b7a9d5b43f938bc", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                                 if let PredicateKind::Clause(Clause::Trait(trait_pred)) =\n                                     obligation.predicate.kind().skip_binder()\n                                 {\n-                                    db.note(&format!(\n+                                    db.note(format!(\n                                         \"`{}` doesn't implement `{}`\",\n                                         trait_pred.self_ty(),\n                                         trait_pred.trait_ref.print_only_trait_path(),"}, {"sha": "9e65f9ecd1664b85770ff6719f5b22db30c6acf8", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -353,7 +353,7 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Se\n pub fn read_conf(sess: &Session, path: &io::Result<(Option<PathBuf>, Vec<String>)>) -> Conf {\n     if let Ok((_, warnings)) = path {\n         for warning in warnings {\n-            sess.warn(warning);\n+            sess.warn(warning.clone());\n         }\n     }\n     let file_name = match path {"}, {"sha": "91f7ce1dbe58e438c7944854d7ac50ea61371586", "filename": "src/tools/clippy/clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -175,13 +175,13 @@ fn check_manual_split_once_indirect(\n             let remove_msg = format!(\"remove the `{iter_ident}` usages\");\n             diag.span_suggestion(\n                 first.span,\n-                &remove_msg,\n+                remove_msg.clone(),\n                 \"\",\n                 app,\n             );\n             diag.span_suggestion(\n                 second.span,\n-                &remove_msg,\n+                remove_msg,\n                 \"\",\n                 app,\n             );"}, {"sha": "7eaa7db78a4706753f84ba60330710ab58117e1c", "filename": "src/tools/clippy/clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -131,13 +131,13 @@ impl<'tcx> LateLintPass<'tcx> for NonSendFieldInSendTy {\n                             for field in non_send_fields {\n                                 diag.span_note(\n                                     field.def.span,\n-                                    &format!(\"it is not safe to send field `{}` to another thread\", field.def.ident.name),\n+                                    format!(\"it is not safe to send field `{}` to another thread\", field.def.ident.name),\n                                 );\n \n                                 match field.generic_params.len() {\n                                     0 => diag.help(\"use a thread-safe type that implements `Send`\"),\n-                                    1 if is_ty_param(field.ty) => diag.help(&format!(\"add `{}: Send` bound in `Send` impl\", field.ty)),\n-                                    _ => diag.help(&format!(\n+                                    1 if is_ty_param(field.ty) => diag.help(format!(\"add `{}: Send` bound in `Send` impl\", field.ty)),\n+                                    _ => diag.help(format!(\n                                         \"add bounds on type parameter{} `{}` that satisfy `{}: Send`\",\n                                         if field.generic_params.len() > 1 { \"s\" } else { \"\" },\n                                         field.generic_params_string(),"}, {"sha": "49cb9718ef66e201414a13c6f59da771d17111cd", "filename": "src/tools/clippy/clippy_utils/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -133,7 +133,7 @@ pub fn get_unique_attr<'a>(\n     let mut unique_attr: Option<&ast::Attribute> = None;\n     for attr in get_attr(sess, attrs, name) {\n         if let Some(duplicate) = unique_attr {\n-            sess.struct_span_err(attr.span, &format!(\"`{name}` is defined multiple times\"))\n+            sess.struct_span_err(attr.span, format!(\"`{name}` is defined multiple times\"))\n                 .span_note(duplicate.span, \"first definition found here\")\n                 .emit();\n         } else {"}, {"sha": "a93f3eb84f2c143c4eae76e57295be6d2f318e4f", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -409,30 +409,32 @@ pub fn report_msg<'tcx>(\n     } else {\n         // Make sure we show the message even when it is a dummy span.\n         for line in span_msg {\n-            err.note(&line);\n+            err.note(line);\n         }\n         err.note(\"(no span available)\");\n     }\n \n     // Show note and help messages.\n     let mut extra_span = false;\n-    for (span_data, note) in &notes {\n+    let notes_len = notes.len();\n+    for (span_data, note) in notes {\n         if let Some(span_data) = span_data {\n             err.span_note(span_data.span(), note);\n             extra_span = true;\n         } else {\n             err.note(note);\n         }\n     }\n-    for (span_data, help) in &helps {\n+    let helps_len = helps.len();\n+    for (span_data, help) in helps {\n         if let Some(span_data) = span_data {\n             err.span_help(span_data.span(), help);\n             extra_span = true;\n         } else {\n             err.help(help);\n         }\n     }\n-    if notes.len() + helps.len() > 0 {\n+    if notes_len + helps_len > 0 {\n         // Add visual separator before backtrace.\n         err.note(if extra_span { \"BACKTRACE (of the first span):\" } else { \"BACKTRACE:\" });\n     }\n@@ -441,7 +443,7 @@ pub fn report_msg<'tcx>(\n         let is_local = machine.is_local(frame_info);\n         // No span for non-local frames and the first frame (which is the error site).\n         if is_local && idx > 0 {\n-            err.span_note(frame_info.span, &frame_info.to_string());\n+            err.span_note(frame_info.span, frame_info.to_string());\n         } else {\n             let sm = sess.source_map();\n             let span = sm.span_to_embeddable_string(frame_info.span);"}, {"sha": "7db100a08a10689822872a0d7981eca6b1535a11", "filename": "tests/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b62f37402cb2990c7d350379238579af0360b10/tests%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b62f37402cb2990c7d350379238579af0360b10/tests%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=6b62f37402cb2990c7d350379238579af0360b10", "patch": "@@ -67,7 +67,7 @@ impl CodegenBackend for TheBackend {\n         let crate_name = codegen_results.crate_info.local_crate_name;\n         for &crate_type in sess.opts.crate_types.iter() {\n             if crate_type != CrateType::Rlib {\n-                sess.fatal(&format!(\"Crate type is {:?}\", crate_type));\n+                sess.fatal(format!(\"Crate type is {:?}\", crate_type));\n             }\n             let output_name = out_filename(sess, crate_type, &outputs, crate_name);\n             let mut out_file = ::std::fs::File::create(output_name).unwrap();"}]}