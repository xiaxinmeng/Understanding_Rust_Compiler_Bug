{"sha": "ca98712ff92c56506442cd5a500547f2f0cba0c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhOTg3MTJmZjkyYzU2NTA2NDQyY2Q1YTUwMDU0N2YyZjBjYmEwYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-10T00:25:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-10T00:25:11Z"}, "message": "Auto merge of #81411 - Skgland:deprecate_expr_method_call, r=varkor\n\nRemove usages of `expr_method_call` in derive(Ord,PartialOrd,RustcEncode,RustcDecode)\n\nPreparing for deprecation of `expr_method_call`  (#81295), by removing the remaining usages not covered by (#81294).\n\nI am not sure about the changes to `derive(RustcEncode,RustcDecode)`", "tree": {"sha": "bf96b43c80e1f53c5601f9a945481de47e78306d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf96b43c80e1f53c5601f9a945481de47e78306d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca98712ff92c56506442cd5a500547f2f0cba0c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca98712ff92c56506442cd5a500547f2f0cba0c3", "html_url": "https://github.com/rust-lang/rust/commit/ca98712ff92c56506442cd5a500547f2f0cba0c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca98712ff92c56506442cd5a500547f2f0cba0c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87bacf22ec93a9479dbd829de5d1917c16b17255", "url": "https://api.github.com/repos/rust-lang/rust/commits/87bacf22ec93a9479dbd829de5d1917c16b17255", "html_url": "https://github.com/rust-lang/rust/commit/87bacf22ec93a9479dbd829de5d1917c16b17255"}, {"sha": "0375022c73c05925871e440e086ed4e266e61ee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0375022c73c05925871e440e086ed4e266e61ee7", "html_url": "https://github.com/rust-lang/rust/commit/0375022c73c05925871e440e086ed4e266e61ee7"}], "stats": {"total": 119, "additions": 76, "deletions": 43}, "files": [{"sha": "f84e6e076201220b3fe3848823e81238f1c4ef02", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ca98712ff92c56506442cd5a500547f2f0cba0c3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca98712ff92c56506442cd5a500547f2f0cba0c3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=ca98712ff92c56506442cd5a500547f2f0cba0c3", "patch": "@@ -47,9 +47,10 @@ pub fn ordering_collapsed(\n     span: Span,\n     self_arg_tags: &[Ident],\n ) -> P<ast::Expr> {\n-    let lft = cx.expr_ident(span, self_arg_tags[0]);\n+    let lft = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[0]));\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    cx.expr_method_call(span, lft, Ident::new(sym::cmp, span), vec![rgt])\n+    let fn_cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n+    cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {"}, {"sha": "151a919e0293b3e178f1a11345375f30f6da23a5", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca98712ff92c56506442cd5a500547f2f0cba0c3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca98712ff92c56506442cd5a500547f2f0cba0c3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=ca98712ff92c56506442cd5a500547f2f0cba0c3", "patch": "@@ -107,9 +107,11 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n             if self_args.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n             } else {\n-                let lft = cx.expr_ident(span, tag_tuple[0]);\n+                let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n                 let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n-                cx.expr_method_call(span, lft, Ident::new(sym::partial_cmp, span), vec![rgt])\n+                let fn_partial_cmp_path =\n+                    cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n+                cx.expr_call_global(span, fn_partial_cmp_path, vec![lft, rgt])\n             }\n         }),\n         cx,"}, {"sha": "1d892b20729d5d830d6730c26c3cf5b66f926616", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ca98712ff92c56506442cd5a500547f2f0cba0c3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca98712ff92c56506442cd5a500547f2f0cba0c3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=ca98712ff92c56506442cd5a500547f2f0cba0c3", "patch": "@@ -91,18 +91,19 @@ fn decodable_substructure(\n                 Unnamed(ref fields, _) => fields.len(),\n                 Named(ref fields) => fields.len(),\n             };\n-            let read_struct_field = Ident::new(sym::read_struct_field, trait_span);\n+            let fn_read_struct_field_path: Vec<_> =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_struct_field]);\n \n             let path = cx.path_ident(trait_span, substr.type_ident);\n             let result =\n                 decode_static_fields(cx, trait_span, path, summary, |cx, span, name, field| {\n                     cx.expr_try(\n                         span,\n-                        cx.expr_method_call(\n+                        cx.expr_call_global(\n                             span,\n-                            blkdecoder.clone(),\n-                            read_struct_field,\n+                            fn_read_struct_field_path.clone(),\n                             vec![\n+                                blkdecoder.clone(),\n                                 cx.expr_str(span, name),\n                                 cx.expr_usize(span, field),\n                                 exprdecode.clone(),\n@@ -111,11 +112,14 @@ fn decodable_substructure(\n                     )\n                 });\n             let result = cx.expr_ok(trait_span, result);\n-            cx.expr_method_call(\n+            let fn_read_struct_path: Vec<_> =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_struct]);\n+\n+            cx.expr_call_global(\n                 trait_span,\n-                decoder,\n-                Ident::new(sym::read_struct, trait_span),\n+                fn_read_struct_path,\n                 vec![\n+                    decoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, nfields),\n                     cx.lambda1(trait_span, result, blkarg),\n@@ -127,7 +131,9 @@ fn decodable_substructure(\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n             let mut variants = Vec::with_capacity(fields.len());\n-            let rvariant_arg = Ident::new(sym::read_enum_variant_arg, trait_span);\n+\n+            let fn_read_enum_variant_arg_path: Vec<_> =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum_variant_arg]);\n \n             for (i, &(ident, v_span, ref parts)) in fields.iter().enumerate() {\n                 variants.push(cx.expr_str(v_span, ident.name));\n@@ -138,11 +144,10 @@ fn decodable_substructure(\n                         let idx = cx.expr_usize(span, field);\n                         cx.expr_try(\n                             span,\n-                            cx.expr_method_call(\n+                            cx.expr_call_global(\n                                 span,\n-                                blkdecoder.clone(),\n-                                rvariant_arg,\n-                                vec![idx, exprdecode.clone()],\n+                                fn_read_enum_variant_arg_path.clone(),\n+                                vec![blkdecoder.clone(), idx, exprdecode.clone()],\n                             ),\n                         )\n                     });\n@@ -159,17 +164,21 @@ fn decodable_substructure(\n             let lambda = cx.lambda(trait_span, vec![blkarg, variant], result);\n             let variant_vec = cx.expr_vec(trait_span, variants);\n             let variant_vec = cx.expr_addr_of(trait_span, variant_vec);\n-            let result = cx.expr_method_call(\n+            let fn_read_enum_variant_path: Vec<_> =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum_variant]);\n+            let result = cx.expr_call_global(\n                 trait_span,\n-                blkdecoder,\n-                Ident::new(sym::read_enum_variant, trait_span),\n-                vec![variant_vec, lambda],\n+                fn_read_enum_variant_path,\n+                vec![blkdecoder, variant_vec, lambda],\n             );\n-            cx.expr_method_call(\n+            let fn_read_enum_path: Vec<_> =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum]);\n+\n+            cx.expr_call_global(\n                 trait_span,\n-                decoder,\n-                Ident::new(sym::read_enum, trait_span),\n+                fn_read_enum_path,\n                 vec![\n+                    decoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.lambda1(trait_span, result, blkarg),\n                 ],"}, {"sha": "01a57bea14e3b0ae4d5af5c3f9cac6cba0cbd7cb", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ca98712ff92c56506442cd5a500547f2f0cba0c3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca98712ff92c56506442cd5a500547f2f0cba0c3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=ca98712ff92c56506442cd5a500547f2f0cba0c3", "patch": "@@ -179,7 +179,8 @@ fn encodable_substructure(\n \n     match *substr.fields {\n         Struct(_, ref fields) => {\n-            let emit_struct_field = Ident::new(sym::emit_struct_field, trait_span);\n+            let fn_emit_struct_field_path =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct_field]);\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n@@ -189,11 +190,15 @@ fn encodable_substructure(\n                 let self_ref = cx.expr_addr_of(span, self_.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                 let lambda = cx.lambda1(span, enc, blkarg);\n-                let call = cx.expr_method_call(\n+                let call = cx.expr_call_global(\n                     span,\n-                    blkencoder.clone(),\n-                    emit_struct_field,\n-                    vec![cx.expr_str(span, name), cx.expr_usize(span, i), lambda],\n+                    fn_emit_struct_field_path.clone(),\n+                    vec![\n+                        blkencoder.clone(),\n+                        cx.expr_str(span, name),\n+                        cx.expr_usize(span, i),\n+                        lambda,\n+                    ],\n                 );\n \n                 // last call doesn't need a try!\n@@ -216,11 +221,14 @@ fn encodable_substructure(\n                 cx.lambda_stmts_1(trait_span, stmts, blkarg)\n             };\n \n-            cx.expr_method_call(\n+            let fn_emit_struct_path =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct]);\n+\n+            cx.expr_call_global(\n                 trait_span,\n-                encoder,\n-                Ident::new(sym::emit_struct, trait_span),\n+                fn_emit_struct_path,\n                 vec![\n+                    encoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, fields.len()),\n                     blk,\n@@ -235,7 +243,10 @@ fn encodable_substructure(\n             // actually exist.\n             let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n             let encoder = cx.expr_ident(trait_span, blkarg);\n-            let emit_variant_arg = Ident::new(sym::emit_enum_variant_arg, trait_span);\n+\n+            let fn_emit_enum_variant_arg_path: Vec<_> =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_enum_variant_arg]);\n+\n             let mut stmts = Vec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n@@ -244,11 +255,11 @@ fn encodable_substructure(\n                     let enc =\n                         cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                     let lambda = cx.lambda1(span, enc, blkarg);\n-                    let call = cx.expr_method_call(\n+\n+                    let call = cx.expr_call_global(\n                         span,\n-                        blkencoder.clone(),\n-                        emit_variant_arg,\n-                        vec![cx.expr_usize(span, i), lambda],\n+                        fn_emit_enum_variant_arg_path.clone(),\n+                        vec![blkencoder.clone(), cx.expr_usize(span, i), lambda],\n                     );\n                     let call = if i != last {\n                         cx.expr_try(span, call)\n@@ -265,23 +276,29 @@ fn encodable_substructure(\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n             let name = cx.expr_str(trait_span, variant.ident.name);\n-            let call = cx.expr_method_call(\n+\n+            let fn_emit_enum_variant_path: Vec<_> =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_enum_variant]);\n+\n+            let call = cx.expr_call_global(\n                 trait_span,\n-                blkencoder,\n-                Ident::new(sym::emit_enum_variant, trait_span),\n+                fn_emit_enum_variant_path,\n                 vec![\n+                    blkencoder,\n                     name,\n                     cx.expr_usize(trait_span, idx),\n                     cx.expr_usize(trait_span, fields.len()),\n                     blk,\n                 ],\n             );\n+\n             let blk = cx.lambda1(trait_span, call, blkarg);\n-            let ret = cx.expr_method_call(\n+            let fn_emit_enum_path: Vec<_> =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_enum]);\n+            let ret = cx.expr_call_global(\n                 trait_span,\n-                encoder,\n-                Ident::new(sym::emit_enum, trait_span),\n-                vec![cx.expr_str(trait_span, substr.type_ident.name), blk],\n+                fn_emit_enum_path,\n+                vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n         }"}, {"sha": "e3dc793a7fac456f0946503160dc6110b60d89ad", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca98712ff92c56506442cd5a500547f2f0cba0c3/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca98712ff92c56506442cd5a500547f2f0cba0c3/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=ca98712ff92c56506442cd5a500547f2f0cba0c3", "patch": "@@ -1043,6 +1043,10 @@ impl<'a> ExtCtxt<'a> {\n             .chain(components.iter().map(|&s| Ident::with_dummy_span(s)))\n             .collect()\n     }\n+    pub fn def_site_path(&self, components: &[Symbol]) -> Vec<Ident> {\n+        let def_site = self.with_def_site_ctxt(DUMMY_SP);\n+        components.iter().map(|&s| Ident::new(s, def_site)).collect()\n+    }\n \n     pub fn check_unused_macros(&mut self) {\n         self.resolver.check_unused_macros();"}]}