{"sha": "b48833d6db16c7d94f20ee6083dbb880979acfd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ODgzM2Q2ZGIxNmM3ZDk0ZjIwZWU2MDgzZGJiODgwOTc5YWNmZDQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-24T01:29:45Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-24T01:35:57Z"}, "message": "Update rustc/syntax docs now that rustdoc lexes all non-`notrust` code blocks.\n\nThis includes blocks made by indentation, so they need to be changed to\nexplicitly have ```notrust ... ``` fences..", "tree": {"sha": "07df714d210e94cd7e0e96200699bc8c149683b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07df714d210e94cd7e0e96200699bc8c149683b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b48833d6db16c7d94f20ee6083dbb880979acfd4", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b48833d6db16c7d94f20ee6083dbb880979acfd4", "html_url": "https://github.com/rust-lang/rust/commit/b48833d6db16c7d94f20ee6083dbb880979acfd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b48833d6db16c7d94f20ee6083dbb880979acfd4/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbed3321f5bbe4375819dd82193bd4299fabafb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbed3321f5bbe4375819dd82193bd4299fabafb9", "html_url": "https://github.com/rust-lang/rust/commit/cbed3321f5bbe4375819dd82193bd4299fabafb9"}], "stats": {"total": 556, "additions": 328, "deletions": 228}, "files": [{"sha": "e8753a9726d8a13aa51114187668b7a6fa342d8d", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 271, "deletions": 179, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/b48833d6db16c7d94f20ee6083dbb880979acfd4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48833d6db16c7d94f20ee6083dbb880979acfd4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=b48833d6db16c7d94f20ee6083dbb880979acfd4", "patch": "@@ -56,26 +56,34 @@ it is safe with respect to the in-scope loans.\n Throughout the docs we'll consider a simple subset of Rust in which\n you can only borrow from lvalues, defined like so:\n \n-    LV = x | LV.f | *LV\n+```notrust\n+LV = x | LV.f | *LV\n+```\n \n Here `x` represents some variable, `LV.f` is a field reference,\n and `*LV` is a pointer dereference. There is no auto-deref or other\n niceties. This means that if you have a type like:\n \n-    struct S { f: uint }\n+```notrust\n+struct S { f: uint }\n+```\n \n and a variable `a: ~S`, then the rust expression `a.f` would correspond\n to an `LV` of `(*a).f`.\n \n Here is the formal grammar for the types we'll consider:\n \n-    TY = () | S<'LT...> | ~TY | & 'LT MQ TY | @ MQ TY\n-    MQ = mut | imm | const\n+```notrust\n+TY = () | S<'LT...> | ~TY | & 'LT MQ TY | @ MQ TY\n+MQ = mut | imm | const\n+```\n \n Most of these types should be pretty self explanatory. Here `S` is a\n struct name and we assume structs are declared like so:\n \n-    SD = struct S<'LT...> { (f: TY)... }\n+```notrust\n+SD = struct S<'LT...> { (f: TY)... }\n+```\n \n # Borrowing and loans\n \n@@ -85,13 +93,15 @@ struct name and we assume structs are declared like so:\n \n Now, imagine we had a program like this:\n \n-    struct Foo { f: uint, g: uint }\n-    ...\n-    'a: {\n-      let mut x: ~Foo = ...;\n-      let y = &mut (*x).f;\n-      x = ...;\n-    }\n+```notrust\n+struct Foo { f: uint, g: uint }\n+...\n+'a: {\n+  let mut x: ~Foo = ...;\n+  let y = &mut (*x).f;\n+  x = ...;\n+}\n+```\n \n This is of course dangerous because mutating `x` will free the old\n value and hence invalidate `y`. The borrow checker aims to prevent\n@@ -108,9 +118,11 @@ the borrow, and (3) a set of restrictions. In the code, `Loan` is a\n struct defined in `middle::borrowck`. Formally, we define `LOAN` as\n follows:\n \n-    LOAN = (LV, LT, MQ, RESTRICTION*)\n-    RESTRICTION = (LV, ACTION*)\n-    ACTION = MUTATE | CLAIM | FREEZE\n+```notrust\n+LOAN = (LV, LT, MQ, RESTRICTION*)\n+RESTRICTION = (LV, ACTION*)\n+ACTION = MUTATE | CLAIM | FREEZE\n+```\n \n Here the `LOAN` tuple defines the lvalue `LV` being borrowed; the\n lifetime `LT` of that borrow; the mutability `MQ` of the borrow; and a\n@@ -139,10 +151,12 @@ To give you a better feeling for what kind of restrictions derived\n from a loan, let's look at the loan `L` that would be issued as a\n result of the borrow `&mut (*x).f` in the example above:\n \n-    L = ((*x).f, 'a, mut, RS) where\n-        RS = [((*x).f, [MUTATE, CLAIM, FREEZE]),\n-              (*x, [MUTATE, CLAIM, FREEZE]),\n-              (x, [MUTATE, CLAIM, FREEZE])]\n+```notrust\n+L = ((*x).f, 'a, mut, RS) where\n+    RS = [((*x).f, [MUTATE, CLAIM, FREEZE]),\n+          (*x, [MUTATE, CLAIM, FREEZE]),\n+          (x, [MUTATE, CLAIM, FREEZE])]\n+```\n \n The loan states that the expression `(*x).f` has been loaned as\n mutable for the lifetime `'a`. Because the loan is mutable, that means\n@@ -200,10 +214,12 @@ conditions that it uses. For simplicity I will ignore const loans.\n I will present the rules in a modified form of standard inference\n rules, which looks as as follows:\n \n-    PREDICATE(X, Y, Z)                  // Rule-Name\n-      Condition 1\n-      Condition 2\n-      Condition 3\n+```notrust\n+PREDICATE(X, Y, Z)                  // Rule-Name\n+  Condition 1\n+  Condition 2\n+  Condition 3\n+```\n \n The initial line states the predicate that is to be satisfied.  The\n indented lines indicate the conditions that must be met for the\n@@ -274,45 +290,53 @@ Let's begin with the rules for variables, which state that if a\n variable is declared as mutable, it may be borrowed any which way, but\n otherwise the variable must be borrowed as immutable or const:\n \n-    MUTABILITY(X, MQ)                   // M-Var-Mut\n-      DECL(X) = mut\n+```notrust\n+MUTABILITY(X, MQ)                   // M-Var-Mut\n+  DECL(X) = mut\n \n-    MUTABILITY(X, MQ)                   // M-Var-Imm\n-      DECL(X) = imm\n-      MQ = imm | const\n+MUTABILITY(X, MQ)                   // M-Var-Imm\n+  DECL(X) = imm\n+  MQ = imm | const\n+```\n \n ### Checking mutability of owned content\n \n Fields and owned pointers inherit their mutability from\n their base expressions, so both of their rules basically\n delegate the check to the base expression `LV`:\n \n-    MUTABILITY(LV.f, MQ)                // M-Field\n-      MUTABILITY(LV, MQ)\n+```notrust\n+MUTABILITY(LV.f, MQ)                // M-Field\n+  MUTABILITY(LV, MQ)\n \n-    MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n-      TYPE(LV) = ~Ty\n-      MUTABILITY(LV, MQ)\n+MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n+  TYPE(LV) = ~Ty\n+  MUTABILITY(LV, MQ)\n+```\n \n ### Checking mutability of immutable pointer types\n \n Immutable pointer types like `&T` and `@T` can only\n be borrowed if MQ is immutable or const:\n \n-    MUTABILITY(*LV, MQ)                // M-Deref-Borrowed-Imm\n-      TYPE(LV) = &Ty\n-      MQ == imm | const\n+```notrust\n+MUTABILITY(*LV, MQ)                // M-Deref-Borrowed-Imm\n+  TYPE(LV) = &Ty\n+  MQ == imm | const\n \n-    MUTABILITY(*LV, MQ)                // M-Deref-Managed-Imm\n-      TYPE(LV) = @Ty\n-      MQ == imm | const\n+MUTABILITY(*LV, MQ)                // M-Deref-Managed-Imm\n+  TYPE(LV) = @Ty\n+  MQ == imm | const\n+```\n \n ### Checking mutability of mutable pointer types\n \n `&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n \n-    MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n-      TYPE(LV) = &mut Ty\n+```notrust\n+MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n+  TYPE(LV) = &mut Ty\n+```\n \n ## Checking aliasability\n \n@@ -328,32 +352,40 @@ Rust code corresponding to this predicate is the function\n Local variables are never aliasable as they are accessible only within\n the stack frame.\n \n+```notrust\n     ALIASABLE(X, MQ)                   // M-Var-Mut\n+```\n \n ### Checking aliasable of owned content\n \n Owned content is aliasable if it is found in an aliasable location:\n \n-    ALIASABLE(LV.f, MQ)                // M-Field\n-      ALIASABLE(LV, MQ)\n+```notrust\n+ALIASABLE(LV.f, MQ)                // M-Field\n+  ALIASABLE(LV, MQ)\n \n-    ALIASABLE(*LV, MQ)                 // M-Deref-Unique\n-      ALIASABLE(LV, MQ)\n+ALIASABLE(*LV, MQ)                 // M-Deref-Unique\n+  ALIASABLE(LV, MQ)\n+```\n \n ### Checking mutability of immutable pointer types\n \n Immutable pointer types like `&T` are aliasable, and hence can only be\n borrowed immutably:\n \n-    ALIASABLE(*LV, imm)                // M-Deref-Borrowed-Imm\n-      TYPE(LV) = &Ty\n+```notrust\n+ALIASABLE(*LV, imm)                // M-Deref-Borrowed-Imm\n+  TYPE(LV) = &Ty\n+```\n \n ### Checking mutability of mutable pointer types\n \n `&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n \n-    ALIASABLE(*LV, MQ)                 // M-Deref-Borrowed-Mut\n-      TYPE(LV) = &mut Ty\n+```notrust\n+ALIASABLE(*LV, MQ)                 // M-Deref-Borrowed-Mut\n+  TYPE(LV) = &mut Ty\n+```\n \n ## Checking lifetime\n \n@@ -373,49 +405,63 @@ guaranteed to exist, presuming that no mutations occur.\n \n The scope of a local variable is the block where it is declared:\n \n-      SCOPE(X) = block where X is declared\n+```notrust\n+  SCOPE(X) = block where X is declared\n+```\n \n The scope of a field is the scope of the struct:\n \n-      SCOPE(LV.f) = SCOPE(LV)\n+```notrust\n+  SCOPE(LV.f) = SCOPE(LV)\n+```\n \n The scope of a unique referent is the scope of the pointer, since\n (barring mutation or moves) the pointer will not be freed until\n the pointer itself `LV` goes out of scope:\n \n-      SCOPE(*LV) = SCOPE(LV) if LV has type ~T\n+```notrust\n+  SCOPE(*LV) = SCOPE(LV) if LV has type ~T\n+```\n \n The scope of a managed referent is also the scope of the pointer.  This\n is a conservative approximation, since there may be other aliases fo\n that same managed box that would cause it to live longer:\n \n-      SCOPE(*LV) = SCOPE(LV) if LV has type @T\n+```notrust\n+  SCOPE(*LV) = SCOPE(LV) if LV has type @T\n+```\n \n The scope of a borrowed referent is the scope associated with the\n pointer.  This is a conservative approximation, since the data that\n the pointer points at may actually live longer:\n \n-      SCOPE(*LV) = LT if LV has type &'LT T or &'LT mut T\n+```notrust\n+  SCOPE(*LV) = LT if LV has type &'LT T or &'LT mut T\n+```\n \n ### Checking lifetime of variables\n \n The rule for variables states that a variable can only be borrowed a\n lifetime `LT` that is a subregion of the variable's scope:\n \n-    LIFETIME(X, LT, MQ)                 // L-Local\n-      LT <= SCOPE(X)\n+```notrust\n+LIFETIME(X, LT, MQ)                 // L-Local\n+  LT <= SCOPE(X)\n+```\n \n ### Checking lifetime for owned content\n \n The lifetime of a field or owned pointer is the same as the lifetime\n of its owner:\n \n-    LIFETIME(LV.f, LT, MQ)              // L-Field\n-      LIFETIME(LV, LT, MQ)\n+```notrust\n+LIFETIME(LV.f, LT, MQ)              // L-Field\n+  LIFETIME(LV, LT, MQ)\n \n-    LIFETIME(*LV, LT, MQ)               // L-Deref-Send\n-      TYPE(LV) = ~Ty\n-      LIFETIME(LV, LT, MQ)\n+LIFETIME(*LV, LT, MQ)               // L-Deref-Send\n+  TYPE(LV) = ~Ty\n+  LIFETIME(LV, LT, MQ)\n+```\n \n ### Checking lifetime for derefs of references\n \n@@ -425,9 +471,11 @@ lifetime. Therefore, the borrow is valid so long as the lifetime `LT`\n of the borrow is shorter than the lifetime `LT'` of the pointer\n itself:\n \n-    LIFETIME(*LV, LT, MQ)               // L-Deref-Borrowed\n-      TYPE(LV) = &LT' Ty OR &LT' mut Ty\n-      LT <= LT'\n+```notrust\n+LIFETIME(*LV, LT, MQ)               // L-Deref-Borrowed\n+  TYPE(LV) = &LT' Ty OR &LT' mut Ty\n+  LT <= LT'\n+```\n \n ### Checking lifetime for derefs of managed, immutable pointers\n \n@@ -436,11 +484,13 @@ Managed pointers are valid so long as the data within them is\n when the user guarantees such a root will exist. For this to be true,\n three conditions must be met:\n \n-    LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-User-Root\n-      TYPE(LV) = @Ty\n-      LT <= SCOPE(LV)                   // (1)\n-      LV is immutable                   // (2)\n-      LV is not moved or not movable    // (3)\n+```notrust\n+LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-User-Root\n+  TYPE(LV) = @Ty\n+  LT <= SCOPE(LV)                   // (1)\n+  LV is immutable                   // (2)\n+  LV is not moved or not movable    // (3)\n+```\n \n Condition (1) guarantees that the managed box will be rooted for at\n least the lifetime `LT` of the borrow, presuming that no mutation or\n@@ -468,10 +518,12 @@ borrow without crossing the exit from the scope `LT`.\n \n The rule for compiler rooting is as follows:\n \n-    LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-Compiler-Root\n-      TYPE(LV) = @Ty\n-      LT <= innermost enclosing loop/func\n-      ROOT LV at *LV for LT\n+```notrust\n+LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-Compiler-Root\n+  TYPE(LV) = @Ty\n+  LT <= innermost enclosing loop/func\n+  ROOT LV at *LV for LT\n+```\n \n Here I have written `ROOT LV at *LV FOR LT` to indicate that the code\n makes a note in a side-table that the box `LV` must be rooted into the\n@@ -490,9 +542,11 @@ for the lifetime of the loan\".\n Note that there is an initial set of restrictions: these restrictions\n are computed based on the kind of borrow:\n \n-    &mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n-    &LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n-    &const LV => RESTRICTIONS(LV, LT, [])\n+```notrust\n+&mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n+&LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n+&const LV => RESTRICTIONS(LV, LT, [])\n+```\n \n The reasoning here is that a mutable borrow must be the only writer,\n therefore it prevents other writes (`MUTATE`), mutable borrows\n@@ -505,7 +559,9 @@ moved out from under it, so no actions are forbidden.\n \n The simplest case is a borrow of a local variable `X`:\n \n-    RESTRICTIONS(X, LT, ACTIONS) = (X, ACTIONS)            // R-Variable\n+```notrust\n+RESTRICTIONS(X, LT, ACTIONS) = (X, ACTIONS)            // R-Variable\n+```\n \n In such cases we just record the actions that are not permitted.\n \n@@ -514,8 +570,10 @@ In such cases we just record the actions that are not permitted.\n Restricting a field is the same as restricting the owner of that\n field:\n \n-    RESTRICTIONS(LV.f, LT, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n-      RESTRICTIONS(LV, LT, ACTIONS) = RS\n+```notrust\n+RESTRICTIONS(LV.f, LT, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n+  RESTRICTIONS(LV, LT, ACTIONS) = RS\n+```\n \n The reasoning here is as follows. If the field must not be mutated,\n then you must not mutate the owner of the field either, since that\n@@ -535,9 +593,11 @@ must prevent the owned pointer `LV` from being mutated, which means\n that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n on `LV`:\n \n-    RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n-      TYPE(LV) = ~Ty\n-      RESTRICTIONS(LV, LT, ACTIONS|MUTATE|CLAIM) = RS\n+```notrust\n+RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n+  TYPE(LV) = ~Ty\n+  RESTRICTIONS(LV, LT, ACTIONS|MUTATE|CLAIM) = RS\n+```\n \n ### Restrictions for loans of immutable managed/borrowed referents\n \n@@ -550,14 +610,16 @@ restricting that path. Therefore, the rule for `&Ty` and `@Ty`\n pointers always returns an empty set of restrictions, and it only\n permits restricting `MUTATE` and `CLAIM` actions:\n \n-    RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Managed\n-      TYPE(LV) = @Ty\n-      ACTIONS subset of [MUTATE, CLAIM]\n+```notrust\n+RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Managed\n+  TYPE(LV) = @Ty\n+  ACTIONS subset of [MUTATE, CLAIM]\n \n-    RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n-      TYPE(LV) = &LT' Ty\n-      LT <= LT'                                            // (1)\n-      ACTIONS subset of [MUTATE, CLAIM]\n+RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n+  TYPE(LV) = &LT' Ty\n+  LT <= LT'                                            // (1)\n+  ACTIONS subset of [MUTATE, CLAIM]\n+```\n \n The reason that we can restrict `MUTATE` and `CLAIM` actions even\n without a restrictions list is that it is never legal to mutate nor to\n@@ -569,17 +631,21 @@ specify that the lifetime of the loan must be less than the lifetime\n of the `&Ty` pointer. In simple cases, this clause is redundant, since\n the `LIFETIME()` function will already enforce the required rule:\n \n-    fn foo(point: &'a Point) -> &'static f32 {\n-        &point.x // Error\n-    }\n+```\n+fn foo(point: &'a Point) -> &'static f32 {\n+    &point.x // Error\n+}\n+```\n \n The above example fails to compile both because of clause (1) above\n but also by the basic `LIFETIME()` check. However, in more advanced\n examples involving multiple nested pointers, clause (1) is needed:\n \n-    fn foo(point: &'a &'b mut Point) -> &'b f32 {\n-        &point.x // Error\n-    }\n+```\n+fn foo(point: &'a &'b mut Point) -> &'b f32 {\n+    &point.x // Error\n+}\n+```\n \n The `LIFETIME` rule here would accept `'b` because, in fact, the\n *memory is* guaranteed to remain valid (i.e., not be freed) for the\n@@ -594,9 +660,11 @@ which is only `'a`, not `'b`. Hence this example yields an error.\n As a final twist, consider the case of two nested *immutable*\n pointers, rather than a mutable pointer within an immutable one:\n \n-    fn foo(point: &'a &'b Point) -> &'b f32 {\n-        &point.x // OK\n-    }\n+```\n+fn foo(point: &'a &'b Point) -> &'b f32 {\n+    &point.x // OK\n+}\n+```\n \n This function is legal. The reason for this is that the inner pointer\n (`*point : &'b Point`) is enough to guarantee the memory is immutable\n@@ -614,10 +682,12 @@ The rules pertaining to `LIFETIME` exist to ensure that we don't\n create a borrowed pointer that outlives the memory it points at. So\n `LIFETIME` prevents a function like this:\n \n-    fn get_1<'a>() -> &'a int {\n-        let x = 1;\n-        &x\n-    }\n+```\n+fn get_1<'a>() -> &'a int {\n+    let x = 1;\n+    &x\n+}\n+```\n \n Here we would be returning a pointer into the stack. Clearly bad.\n \n@@ -632,10 +702,12 @@ after we return and hence the remaining code in `'a` cannot possibly\n mutate it. This distinction is important for type checking functions\n like this one:\n \n-    fn inc_and_get<'a>(p: &'a mut Point) -> &'a int {\n-        p.x += 1;\n-        &p.x\n-    }\n+```\n+fn inc_and_get<'a>(p: &'a mut Point) -> &'a int {\n+    p.x += 1;\n+    &p.x\n+}\n+```\n \n In this case, we take in a `&mut` and return a frozen borrowed pointer\n with the same lifetime. So long as the lifetime of the returned value\n@@ -661,8 +733,10 @@ Because moves from a `&const` or `@const` lvalue are never legal, it\n is not necessary to add any restrictions at all to the final\n result.\n \n+```notrust\n     RESTRICTIONS(*LV, LT, []) = []                         // R-Deref-Freeze-Borrowed\n       TYPE(LV) = &const Ty or @const Ty\n+```\n \n ### Restrictions for loans of mutable borrowed referents\n \n@@ -675,10 +749,12 @@ while the new claimant is live.\n \n The rule for mutable borrowed pointers is as follows:\n \n-    RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed\n-      TYPE(LV) = &LT' mut Ty\n-      LT <= LT'                                            // (1)\n-      RESTRICTIONS(LV, LT, ACTIONS) = RS                   // (2)\n+```notrust\n+RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed\n+  TYPE(LV) = &LT' mut Ty\n+  LT <= LT'                                            // (1)\n+  RESTRICTIONS(LV, LT, ACTIONS) = RS                   // (2)\n+```\n \n Let's examine the two numbered clauses:\n \n@@ -693,19 +769,21 @@ maximum of `LT'`.\n \n Here is a concrete example of a bug this rule prevents:\n \n-     // Test region-reborrow-from-shorter-mut-ref.rs:\n-     fn copy_pointer<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n-         &mut **p // ERROR due to clause (1)\n-     }\n-     fn main() {\n-         let mut x = 1;\n-         let mut y = &mut x; // <-'b-----------------------------+\n-         //      +-'a--------------------+                       |\n-         //      v                       v                       |\n-         let z = copy_borrowed_ptr(&mut y); // y is lent         |\n-         *y += 1; // Here y==z, so both should not be usable...  |\n-         *z += 1; // ...and yet they would be, but for clause 1. |\n-     } <---------------------------------------------------------+\n+```\n+// Test region-reborrow-from-shorter-mut-ref.rs:\n+fn copy_pointer<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n+    &mut **p // ERROR due to clause (1)\n+}\n+fn main() {\n+    let mut x = 1;\n+    let mut y = &mut x; // <-'b-----------------------------+\n+    //      +-'a--------------------+                       |\n+    //      v                       v                       |\n+    let z = copy_borrowed_ptr(&mut y); // y is lent         |\n+    *y += 1; // Here y==z, so both should not be usable...  |\n+    *z += 1; // ...and yet they would be, but for clause 1. |\n+} // <------------------------------------------------------+\n+```\n \n Clause (2) propagates the restrictions on the referent to the pointer\n itself. This is the same as with an owned pointer, though the\n@@ -719,12 +797,14 @@ ways to violate the rules is to move the base pointer to a new name\n and access it via that new name, thus bypassing the restrictions on\n the old name. Here is an example:\n \n-       // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n-       fn foo(t0: &mut int) {\n-           let p: &int = &*t0; // Freezes `*t0`\n-           let t1 = t0;        //~ ERROR cannot move out of `t0`\n-           *t1 = 22;           // OK, not a write through `*t0`\n-       }\n+```\n+// src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n+fn foo(t0: &mut int) {\n+    let p: &int = &*t0; // Freezes `*t0`\n+    let t1 = t0;        //~ ERROR cannot move out of `t0`\n+    *t1 = 22;           // OK, not a write through `*t0`\n+}\n+```\n \n Remember that `&mut` pointers are linear, and hence `let t1 = t0` is a\n move of `t0` -- or would be, if it were legal. Instead, we get an\n@@ -737,13 +817,15 @@ danger is to mutably borrow the base path. This can lead to two bad\n scenarios. The most obvious is that the mutable borrow itself becomes\n another path to access the same data, as shown here:\n \n-       // src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs\n-       fn foo<'a>(mut t0: &'a mut int,\n-                  mut t1: &'a mut int) {\n-           let p: &int = &*t0;     // Freezes `*t0`\n-           let mut t2 = &mut t0;   //~ ERROR cannot borrow `t0`\n-           **t2 += 1;              // Mutates `*t0`\n-       }\n+```\n+// src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs\n+fn foo<'a>(mut t0: &'a mut int,\n+           mut t1: &'a mut int) {\n+    let p: &int = &*t0;     // Freezes `*t0`\n+    let mut t2 = &mut t0;   //~ ERROR cannot borrow `t0`\n+    **t2 += 1;              // Mutates `*t0`\n+}\n+```\n \n In this example, `**t2` is the same memory as `*t0`. Because `t2` is\n an `&mut` pointer, `**t2` is a unique path and hence it would be\n@@ -756,13 +838,15 @@ of `t0`. Hence the claim `&mut t0` is illegal.\n Another danger with an `&mut` pointer is that we could swap the `t0`\n value away to create a new path:\n \n-       // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n-       fn foo<'a>(mut t0: &'a mut int,\n-                  mut t1: &'a mut int) {\n-           let p: &int = &*t0;     // Freezes `*t0`\n-           swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n-           *t1 = 22;\n-       }\n+```\n+// src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n+fn foo<'a>(mut t0: &'a mut int,\n+           mut t1: &'a mut int) {\n+    let p: &int = &*t0;     // Freezes `*t0`\n+    swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n+    *t1 = 22;\n+}\n+```\n \n This is illegal for the same reason as above. Note that if we added\n back a swap operator -- as we used to have -- we would want to be very\n@@ -772,14 +856,16 @@ careful to ensure this example is still illegal.\n referent is claimed, even freezing the base pointer can be dangerous,\n as shown in the following example:\n \n-       // src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs\n-       fn foo<'a>(mut t0: &'a mut int,\n-                  mut t1: &'a mut int) {\n-           let p: &mut int = &mut *t0; // Claims `*t0`\n-           let mut t2 = &t0;           //~ ERROR cannot borrow `t0`\n-           let q: &int = &*t2;         // Freezes `*t0` but not through `*p`\n-           *p += 1;                    // violates type of `*q`\n-       }\n+```\n+// src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs\n+fn foo<'a>(mut t0: &'a mut int,\n+           mut t1: &'a mut int) {\n+    let p: &mut int = &mut *t0; // Claims `*t0`\n+    let mut t2 = &t0;           //~ ERROR cannot borrow `t0`\n+    let q: &int = &*t2;         // Freezes `*t0` but not through `*p`\n+    *p += 1;                    // violates type of `*q`\n+}\n+```\n \n Here the problem is that `*t0` is claimed by `p`, and hence `p` wants\n to be the controlling pointer through which mutation or freezes occur.\n@@ -793,26 +879,30 @@ which is clearly unsound.\n However, it is not always unsafe to freeze the base pointer. In\n particular, if the referent is frozen, there is no harm in it:\n \n-       // src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs\n-       fn foo<'a>(mut t0: &'a mut int,\n-                  mut t1: &'a mut int) {\n-           let p: &int = &*t0; // Freezes `*t0`\n-           let mut t2 = &t0;\n-           let q: &int = &*t2; // Freezes `*t0`, but that's ok...\n-           let r: &int = &*t0; // ...after all, could do same thing directly.\n-       }\n+```\n+// src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs\n+fn foo<'a>(mut t0: &'a mut int,\n+           mut t1: &'a mut int) {\n+    let p: &int = &*t0; // Freezes `*t0`\n+    let mut t2 = &t0;\n+    let q: &int = &*t2; // Freezes `*t0`, but that's ok...\n+    let r: &int = &*t0; // ...after all, could do same thing directly.\n+}\n+```\n \n In this case, creating the alias `t2` of `t0` is safe because the only\n thing `t2` can be used for is to further freeze `*t0`, which is\n already frozen. In particular, we cannot assign to `*t0` through the\n new alias `t2`, as demonstrated in this test case:\n \n-       // src/test/run-pass/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs\n-       fn foo(t0: & &mut int) {\n-           let t1 = t0;\n-           let p: &int = &**t0;\n-           **t1 = 22; //~ ERROR cannot assign\n-       }\n+```\n+// src/test/run-pass/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs\n+fn foo(t0: & &mut int) {\n+    let t1 = t0;\n+    let p: &int = &**t0;\n+    **t1 = 22; //~ ERROR cannot assign\n+}\n+```\n \n This distinction is reflected in the rules. When doing an `&mut`\n borrow -- as in the first example -- the set `ACTIONS` will be\n@@ -876,22 +966,24 @@ moves/uninitializations of the variable that is being used.\n \n Let's look at a simple example:\n \n-    fn foo(a: ~int) {\n-        let b: ~int;       // Gen bit 0.\n-\n-        if cond {          // Bits: 0\n-            use(&*a);\n-            b = a;         // Gen bit 1, kill bit 0.\n-            use(&*b);\n-        } else {\n-                           // Bits: 0\n-        }\n-                           // Bits: 0,1\n-        use(&*a);          // Error.\n-        use(&*b);          // Error.\n+```\n+fn foo(a: ~int) {\n+    let b: ~int;       // Gen bit 0.\n+\n+    if cond {          // Bits: 0\n+        use(&*a);\n+        b = a;         // Gen bit 1, kill bit 0.\n+        use(&*b);\n+    } else {\n+                       // Bits: 0\n     }\n+                       // Bits: 0,1\n+    use(&*a);          // Error.\n+    use(&*b);          // Error.\n+}\n \n-    fn use(a: &int) { }\n+fn use(a: &int) { }\n+```\n \n In this example, the variable `b` is created uninitialized. In one\n branch of an `if`, we then move the variable `a` into `b`. Once we"}, {"sha": "5fa611a1fe287c06f86b9aa7daa38ff6d978b5be", "filename": "src/librustc/middle/typeck/infer/doc.rs", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b48833d6db16c7d94f20ee6083dbb880979acfd4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48833d6db16c7d94f20ee6083dbb880979acfd4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs?ref=b48833d6db16c7d94f20ee6083dbb880979acfd4", "patch": "@@ -45,11 +45,13 @@ There are several critical invariants which we maintain:\n > types lie in between.  The bottom type is then the Null type.\n > So the tree looks like:\n >\n->             Object\n->             /    \\\n->         String   Other\n->             \\    /\n->             (null)\n+> ```notrust\n+>         Object\n+>         /    \\\n+>     String   Other\n+>         \\    /\n+>         (null)\n+> ```\n >\n > So the upper bound type is the \"supertype\" and the lower bound is the\n > \"subtype\" (also, super and sub mean upper and lower in Latin, or something\n@@ -104,18 +106,20 @@ Pictorally, what this does is to take two distinct variables with\n (hopefully not completely) distinct type ranges and produce one with\n the intersection.\n \n-                      B.ub                  B.ub\n-                       /\\                    /\n-               A.ub   /  \\           A.ub   /\n-               /   \\ /    \\              \\ /\n-              /     X      \\              UB\n-             /     / \\      \\            / \\\n-            /     /   /      \\          /   /\n-            \\     \\  /       /          \\  /\n-             \\      X       /             LB\n-              \\    / \\     /             / \\\n-               \\  /   \\   /             /   \\\n-               A.lb    B.lb          A.lb    B.lb\n+```notrust\n+                  B.ub                  B.ub\n+                   /\\                    /\n+           A.ub   /  \\           A.ub   /\n+           /   \\ /    \\              \\ /\n+          /     X      \\              UB\n+         /     / \\      \\            / \\\n+        /     /   /      \\          /   /\n+        \\     \\  /       /          \\  /\n+         \\      X       /             LB\n+          \\    / \\     /             / \\\n+           \\  /   \\   /             /   \\\n+           A.lb    B.lb          A.lb    B.lb\n+```\n \n \n ### Option 2: Relate UB/LB\n@@ -125,20 +129,22 @@ bounds in such a way that, whatever happens, we know that A <: B will hold.\n This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n are two ways to do that, depicted pictorally here:\n \n-        Before                Option #1            Option #2\n-\n-                 B.ub                B.ub                B.ub\n-                  /\\                 /  \\                /  \\\n-          A.ub   /  \\        A.ub   /(B')\\       A.ub   /(B')\\\n-          /   \\ /    \\           \\ /     /           \\ /     /\n-         /     X      \\         __UB____/             UB    /\n-        /     / \\      \\       /  |                   |    /\n-       /     /   /      \\     /   |                   |   /\n-       \\     \\  /       /    /(A')|                   |  /\n-        \\      X       /    /     LB            ______LB/\n-         \\    / \\     /    /     / \\           / (A')/ \\\n-          \\  /   \\   /     \\    /   \\          \\    /   \\\n-          A.lb    B.lb       A.lb    B.lb        A.lb    B.lb\n+```notrust\n+    Before                Option #1            Option #2\n+\n+             B.ub                B.ub                B.ub\n+              /\\                 /  \\                /  \\\n+      A.ub   /  \\        A.ub   /(B')\\       A.ub   /(B')\\\n+      /   \\ /    \\           \\ /     /           \\ /     /\n+     /     X      \\         __UB____/             UB    /\n+    /     / \\      \\       /  |                   |    /\n+   /     /   /      \\     /   |                   |   /\n+   \\     \\  /       /    /(A')|                   |  /\n+    \\      X       /    /     LB            ______LB/\n+     \\    / \\     /    /     / \\           / (A')/ \\\n+      \\  /   \\   /     \\    /   \\          \\    /   \\\n+      A.lb    B.lb       A.lb    B.lb        A.lb    B.lb\n+```\n \n In these diagrams, UB and LB are defined as before.  As you can see,\n the new ranges `A'` and `B'` are quite different from the range that\n@@ -158,13 +164,15 @@ course, it depends on the program.\n \n The main case which fails today that I would like to support is:\n \n-    fn foo<T>(x: T, y: T) { ... }\n+```notrust\n+fn foo<T>(x: T, y: T) { ... }\n \n-    fn bar() {\n-        let x: @mut int = @mut 3;\n-        let y: @int = @3;\n-        foo(x, y);\n-    }\n+fn bar() {\n+    let x: @mut int = @mut 3;\n+    let y: @int = @3;\n+    foo(x, y);\n+}\n+```\n \n In principle, the inferencer ought to find that the parameter `T` to\n `foo(x, y)` is `@const int`.  Today, however, it does not; this is"}, {"sha": "ded80295320f02bd65298a32aaa23adf65ff6a8f", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b48833d6db16c7d94f20ee6083dbb880979acfd4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b48833d6db16c7d94f20ee6083dbb880979acfd4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=b48833d6db16c7d94f20ee6083dbb880979acfd4", "patch": "@@ -59,7 +59,7 @@ associated with. It is only not `None` when the associated field has\n an identifier in the source code. For example, the `x`s in the\n following snippet\n \n-~~~ignore\n+~~~notrust\n struct A { x : int }\n \n struct B(int);\n@@ -83,7 +83,7 @@ variants, it is represented as a count of 0.\n \n The following simplified `Eq` is used for in-code examples:\n \n-~~~ignore\n+~~~notrust\n trait Eq {\n     fn eq(&self, other: &Self);\n }\n@@ -101,7 +101,7 @@ above `Eq`, `A`, `B` and `C`.\n \n When generating the `expr` for the `A` impl, the `SubstructureFields` is\n \n-~~~ignore\n+~~~notrust\n Struct(~[FieldInfo {\n            span: <span of x>\n            name: Some(<ident of x>),\n@@ -112,7 +112,7 @@ Struct(~[FieldInfo {\n \n For the `B` impl, called with `B(a)` and `B(b)`,\n \n-~~~ignore\n+~~~notrust\n Struct(~[FieldInfo {\n           span: <span of `int`>,\n           name: None,\n@@ -126,7 +126,7 @@ Struct(~[FieldInfo {\n When generating the `expr` for a call with `self == C0(a)` and `other\n == C0(b)`, the SubstructureFields is\n \n-~~~ignore\n+~~~notrust\n EnumMatching(0, <ast::Variant for C0>,\n              ~[FieldInfo {\n                 span: <span of int>\n@@ -138,7 +138,7 @@ EnumMatching(0, <ast::Variant for C0>,\n \n For `C1 {x}` and `C1 {x}`,\n \n-~~~ignore\n+~~~notrust\n EnumMatching(1, <ast::Variant for C1>,\n              ~[FieldInfo {\n                 span: <span of x>\n@@ -150,7 +150,7 @@ EnumMatching(1, <ast::Variant for C1>,\n \n For `C0(a)` and `C1 {x}` ,\n \n-~~~ignore\n+~~~notrust\n EnumNonMatching(~[(0, <ast::Variant for B0>,\n                    ~[(<span of int>, None, <expr for &a>)]),\n                   (1, <ast::Variant for B1>,\n@@ -164,7 +164,7 @@ EnumNonMatching(~[(0, <ast::Variant for B0>,\n \n A static method on the above would result in,\n \n-~~~~ignore\n+~~~~notrust\n StaticStruct(<ast::StructDef of A>, Named(~[(<ident of x>, <span of x>)]))\n \n StaticStruct(<ast::StructDef of B>, Unnamed(~[<span of x>]))\n@@ -625,7 +625,7 @@ impl<'a> MethodDef<'a> {\n     }\n \n     /**\n-   ~~~ignore\n+   ~~~\n     #[deriving(Eq)]\n     struct A { x: int, y: int }\n \n@@ -725,7 +725,7 @@ impl<'a> MethodDef<'a> {\n     }\n \n     /**\n-   ~~~ignore\n+   ~~~\n     #[deriving(Eq)]\n     enum A {\n         A1\n@@ -768,7 +768,7 @@ impl<'a> MethodDef<'a> {\n     /**\n     Creates the nested matches for an enum definition recursively, i.e.\n \n-   ~~~ignore\n+   ~~~notrust\n     match self {\n        Variant1 => match other { Variant1 => matching, Variant2 => nonmatching, ... },\n        Variant2 => match other { Variant1 => nonmatching, Variant2 => matching, ... },\n@@ -1172,7 +1172,7 @@ pub fn cs_fold(use_foldl: bool,\n Call the method that is being derived on all the fields, and then\n process the collected results. i.e.\n \n-~~~ignore\n+~~~\n f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n               self_2.method(__arg_1_2, __arg_2_2)])\n ~~~"}]}