{"sha": "e4761c85b52ac9953a7ac1f89d9e09a79389b4fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NzYxYzg1YjUyYWM5OTUzYTdhYzFmODlkOWUwOWE3OTM4OWI0ZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-15T09:57:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-15T09:57:18Z"}, "message": "auto merge of #17962 : jkleint/rust/guide-vectors, r=steveklabnik\n\nThe array is the fundamental concept; vectors are growable arrays, and\r\nslices are views into either.  Show common array ops up front: length\r\nand iteration.  Mention arrays are immutable by default.  Highlight\r\ndefinite initialization and bounds-checking as safety features.  Show\r\nthat you only need a type suffix on one element of initializers.\r\nExplain that vectors are a value-add library type over arrays, not a\r\nfundamental type; show they have the same \"interface.\" Motivate slices\r\nas efficient views into arrays; explain you can slice vectors, Strings,\r\n&str because they're backed by arrays.  Show off new, easy-to-read\r\n[a..b] slice syntax.", "tree": {"sha": "8c1ab4e012d3921797cd46ff7f93f64858d8d7ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c1ab4e012d3921797cd46ff7f93f64858d8d7ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4761c85b52ac9953a7ac1f89d9e09a79389b4fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4761c85b52ac9953a7ac1f89d9e09a79389b4fd", "html_url": "https://github.com/rust-lang/rust/commit/e4761c85b52ac9953a7ac1f89d9e09a79389b4fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4761c85b52ac9953a7ac1f89d9e09a79389b4fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71dfa5befe2ddf3d16fb5e23f6922125cf1cf5e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/71dfa5befe2ddf3d16fb5e23f6922125cf1cf5e6", "html_url": "https://github.com/rust-lang/rust/commit/71dfa5befe2ddf3d16fb5e23f6922125cf1cf5e6"}, {"sha": "1ce5a5626e39326835b33946b102d2a0d8baee93", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce5a5626e39326835b33946b102d2a0d8baee93", "html_url": "https://github.com/rust-lang/rust/commit/1ce5a5626e39326835b33946b102d2a0d8baee93"}], "stats": {"total": 115, "additions": 65, "deletions": 50}, "files": [{"sha": "db97fc0644416c125c4e074801e7a181deb37c70", "filename": "src/doc/guide.md", "status": "modified", "additions": 65, "deletions": 50, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e4761c85b52ac9953a7ac1f89d9e09a79389b4fd/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/e4761c85b52ac9953a7ac1f89d9e09a79389b4fd/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=e4761c85b52ac9953a7ac1f89d9e09a79389b4fd", "patch": "@@ -1496,87 +1496,102 @@ low-level details matter, they really matter. Just remember that `String`s\n allocate memory and control their data, while `&str`s are a reference to\n another string, and you'll be all set.\n \n-# Vectors\n+# Arrays, Vectors, and Slices\n \n-Like many programming languages, Rust has a list type for when you want a list\n-of things. But similar to strings, Rust has different types to represent this\n-idea: `Vec<T>` (a 'vector'), `[T, .. N]` (an 'array'), and `&[T]` (a 'slice').\n-Whew!\n+Like many programming languages, Rust has list types to represent a sequence of\n+things. The most basic is the **array**, a fixed-size list of elements of the\n+same type. By default, arrays are immutable.\n \n-Vectors are similar to `String`s: they have a dynamic length, and they\n-allocate enough memory to fit. You can create a vector with the `vec!` macro:\n+```{rust}\n+let a = [1i, 2i, 3i];\n+let mut m = [1i, 2i, 3i];\n+```\n+\n+You can create an array with a given number of elements, all initialized to the\n+same value, with `[val, ..N]` syntax. The compiler ensures that arrays are\n+always initialized.\n \n ```{rust}\n-let nums = vec![1i, 2i, 3i];\n+let a = [0i, ..20];  // Shorthand for array of 20 elements all initialized to 0\n ```\n \n-Notice that unlike the `println!` macro we've used in the past, we use square\n-brackets (`[]`) with `vec!`. Rust allows you to use either in either situation,\n-this is just convention.\n+Arrays have type `[T,..N]`. We'll talk about this `T` notation later, when we\n+cover generics.\n \n-You can create an array with just square brackets:\n+You can get the number of elements in an array `a` with `a.len()`, and use\n+`a.iter()` to iterate over them with a for loop. This code will print each\n+number in order:\n \n ```{rust}\n-let nums = [1i, 2i, 3i];\n-let nums = [1i, ..20]; // Shorthand for an array of 20 elements all initialized to 1\n+let a = [1i, 2, 3];     // Only the first item needs a type suffix\n+\n+println!(\"a has {} elements\", a.len());\n+for e in a.iter() {\n+    println!(\"{}\", e);\n+}\n ```\n \n-So what's the difference? An array has a fixed size, so you can't add or\n-subtract elements:\n+You can access a particular element of an array with **subscript notation**:\n \n-```{rust,ignore}\n-let mut nums = vec![1i, 2i, 3i];\n-nums.push(4i); // works\n+```{rust}\n+let names = [\"Graydon\", \"Brian\", \"Niko\"];\n \n-let mut nums = [1i, 2i, 3i];\n-nums.push(4i); //  error: type `[int, .. 3]` does not implement any method\n-               // in scope named `push`\n+println!(\"The second name is: {}\", names[1]);\n ```\n \n-The `push()` method lets you append a value to the end of the vector. But\n-since arrays have fixed sizes, adding an element doesn't make any sense.\n-You can see how it has the exact type in the error message: `[int, .. 3]`.\n-An array of `int`s, with length 3.\n+Subscripts start at zero, like in most programming languages, so the first name\n+is `names[0]` and the second name is `names[1]`. The above example prints\n+`The second name is: Brian`. If you try to use a subscript that is not in the\n+array, you will get an error: array access is bounds-checked at run-time. Such\n+errant access is the source of many bugs in other systems programming\n+languages.\n \n-Similar to `&str`, a slice is a reference to another array. We can get a\n-slice from a vector by using the `as_slice()` method:\n+A **vector** is a dynamic or \"growable\" array, implemented as the standard\n+library type [`Vec<T>`](std/vec/) (we'll talk about what the `<T>` means\n+later). Vectors are to arrays what `String` is to `&str`. You can create them\n+with the `vec!` macro:\n \n ```{rust}\n-let vec = vec![1i, 2i, 3i];\n-let slice = vec.as_slice();\n+let v = vec![1i, 2, 3];\n ```\n \n-All three types implement an `iter()` method, which returns an iterator. We'll\n-talk more about the details of iterators later, but for now, the `iter()` method\n-allows you to write a `for` loop that prints out the contents of a vector, array,\n-or slice:\n+(Notice that unlike the `println!` macro we've used in the past, we use square\n+brackets `[]` with `vec!`. Rust allows you to use either in either situation,\n+this is just convention.)\n \n-```{rust}\n-let vec = vec![1i, 2i, 3i];\n+You can get the length of, iterate over, and subscript vectors just like\n+arrays. In addition, (mutable) vectors can grow automatically:\n \n-for i in vec.iter() {\n-    println!(\"{}\", i);\n-}\n+```{rust}\n+let mut nums = vec![1i, 2, 3];\n+nums.push(4);\n+println!(\"The length of nums is now {}\", nums.len());   // Prints 4\n ```\n \n-This code will print each number in order, on its own line.\n+Vectors have many more useful methods.\n \n-You can access a particular element of a vector, array, or slice by using\n-**subscript notation**:\n+A **slice** is a reference to (or \"view\" into) an array. They are useful for\n+allowing safe, efficient access to a portion of an array without copying. For\n+example, you might want to reference just one line of a file read into memory.\n+By nature, a slice is not created directly, but from an existing variable.\n+Slices have a length, can be mutable or not, and in many ways behave like\n+arrays:\n \n ```{rust}\n-let names = [\"Graydon\", \"Brian\", \"Niko\"];\n+let a = [0i, 1, 2, 3, 4];\n+let middle = a.slice(1, 4);     // A slice of a: just the elements [1,2,3]\n \n-println!(\"The second name is: {}\", names[1]);\n+for e in middle.iter() {\n+    println!(\"{}\", e);          // Prints 1, 2, 3\n+}\n ```\n \n-These subscripts start at zero, like in most programming languages, so the\n-first name is `names[0]` and the second name is `names[1]`. The above example\n-prints `The second name is: Brian`.\n+You can also take a slice of a vector, `String`, or `&str`, because they are\n+backed by arrays. Slices have type `&[T]`, which we'll talk about when we cover\n+generics.\n \n-There's a whole lot more to vectors, but that's enough to get started. We have\n-now learned all of the most basic Rust concepts. We're ready to start building\n-our guessing game, but we need to know how to do one last thing first: get\n+We have now learned all of the most basic Rust concepts. We're ready to start\n+building our guessing game, we just need to know one last thing: how to get\n input from the keyboard. You can't have a guessing game without the ability to\n guess!\n "}]}