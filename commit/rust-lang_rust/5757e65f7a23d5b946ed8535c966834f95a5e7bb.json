{"sha": "5757e65f7a23d5b946ed8535c966834f95a5e7bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NTdlNjVmN2EyM2Q1Yjk0NmVkODUzNWM5NjY4MzRmOTVhNWU3YmI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-01-25T13:34:34Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-21T17:36:22Z"}, "message": "scaffolding for borrowck on MIR.\n\nemit (via debug!) scary message from `fn borrowck_mir` until basic\nprototype is in place.\n\nGather children of move paths and set their kill bits in\ndataflow. (Each node has a link to the child that is first among its\nsiblings.)\n\nHooked in libgraphviz based rendering, including of borrowck dataflow\nstate.\n\ndoing this well required some refactoring of the code, so I cleaned it\nup more generally (adding comments to explain what its trying to do\nand how it is doing it).\n\nUpdate: this newer version addresses most review comments (at least\nthe ones that were largely mechanical changes), but I left the more\ninteresting revisions to separate followup commits (in this same PR).", "tree": {"sha": "7a02a86ccaa90757d9a8dc86b8dccac09ca98399", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a02a86ccaa90757d9a8dc86b8dccac09ca98399"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5757e65f7a23d5b946ed8535c966834f95a5e7bb", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5757e65f7a23d5b946ed8535c966834f95a5e7bb", "html_url": "https://github.com/rust-lang/rust/commit/5757e65f7a23d5b946ed8535c966834f95a5e7bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5757e65f7a23d5b946ed8535c966834f95a5e7bb/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "213d57983d1640d22bd69e7351731fd1adcbf9b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/213d57983d1640d22bd69e7351731fd1adcbf9b2", "html_url": "https://github.com/rust-lang/rust/commit/213d57983d1640d22bd69e7351731fd1adcbf9b2"}], "stats": {"total": 1808, "additions": 1777, "deletions": 31}, "files": [{"sha": "54733083aaeb04510cb1f12c95c847fe292fb231", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -97,7 +97,7 @@ DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml rustc_front\\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\\\n \t\t  \t  rustc_const_eval\n DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n-DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n+DEPS_rustc_borrowck := rustc rustc_front rustc_mir log graphviz syntax\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\"}, {"sha": "de3f7f1b0863b36114eb286669569f17a93fd35c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -653,7 +653,7 @@ fn set_bit(words: &mut [usize], bit: usize) -> bool {\n     let word = bit / usize_bits;\n     let bit_in_word = bit % usize_bits;\n     let bit_mask = 1 << bit_in_word;\n-    debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n+    debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n     let oldv = words[word];\n     let newv = oldv | bit_mask;\n     words[word] = newv;"}, {"sha": "1476c3513dcf78eab1c2e9d1a6f366c4a62cb070", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -499,13 +499,13 @@ pub enum Lvalue<'tcx> {\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Lvalue`. See the aliases\n /// `LvalueProjection` etc below.\n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Projection<'tcx, B, V> {\n     pub base: B,\n     pub elem: ProjectionElem<'tcx, V>,\n }\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum ProjectionElem<'tcx, V> {\n     Deref,\n     Field(Field, Ty<'tcx>),\n@@ -857,7 +857,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// this does not necessarily mean that they are \"==\" in Rust -- in\n /// particular one must be wary of `NaN`!\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n@@ -877,7 +877,7 @@ impl<'tcx> Debug for TypedConstVal<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n         def_id: DefId,"}, {"sha": "9355c072ad7534bf2b4bb98d2f266d4f33b023c7", "filename": "src/librustc_borrowck/bitslice.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fbitslice.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+/// `BitSlice` provides helper methods for treating a `[usize]`\n+/// as a bitvector.\n+pub trait BitSlice {\n+    fn set_bit(&mut self, idx: usize) -> bool;\n+    fn get_bit(&self, idx: usize) -> bool;\n+}\n+\n+impl BitSlice for [usize] {\n+    fn set_bit(&mut self, idx: usize) -> bool {\n+        let words = self;\n+        debug!(\"set_bit: words={} idx={}\",\n+               bits_to_string(words, words.len() * mem::size_of::<usize>()), bit_str(idx));\n+        let BitLookup { word, bit_in_word, bit_mask } = bit_lookup(idx);\n+        debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n+        let oldv = words[word];\n+        let newv = oldv | bit_mask;\n+        words[word] = newv;\n+        oldv != newv\n+    }\n+\n+    fn get_bit(&self, idx: usize) -> bool {\n+        let words = self;\n+        let BitLookup { word, bit_mask, .. } = bit_lookup(idx);\n+        (words[word] & bit_mask) != 0\n+    }\n+}\n+\n+struct BitLookup { word: usize, bit_in_word: usize, bit_mask: usize }\n+\n+#[inline]\n+fn bit_lookup(bit: usize) -> BitLookup {\n+    let usize_bits = mem::size_of::<usize>() * 8;\n+    let word = bit / usize_bits;\n+    let bit_in_word = bit % usize_bits;\n+    let bit_mask = 1 << bit_in_word;\n+    BitLookup { word: word, bit_in_word: bit_in_word, bit_mask: bit_mask }\n+}\n+\n+\n+fn bit_str(bit: usize) -> String {\n+    let byte = bit >> 8;\n+    let lobits = 1 << (bit & 0xFF);\n+    format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n+}\n+\n+pub fn bits_to_string(words: &[usize], bytes: usize) -> String {\n+    let mut result = String::new();\n+    let mut sep = '[';\n+\n+    // Note: this is a little endian printout of bytes.\n+\n+    let mut i = 0;\n+    for &word in words.iter() {\n+        let mut v = word;\n+        for _ in 0..mem::size_of::<usize>() {\n+            let byte = v & 0xFF;\n+            if i >= bytes {\n+                assert!(byte == 0);\n+            } else {\n+                result.push(sep);\n+                result.push_str(&format!(\"{:02x}\", byte));\n+            }\n+            v >>= 8;\n+            i += 1;\n+            sep = '-';\n+        }\n+    }\n+    result.push(']');\n+    return result\n+}"}, {"sha": "aa885eb47424d8ade55971fa0bbe562ae3a77c15", "filename": "src/librustc_borrowck/borrowck/mir/abs_domain.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The move-analysis portion of borrowck needs to work in an abstract\n+//! domain of lifted Lvalues.  Most of the Lvalue variants fall into a\n+//! one-to-one mapping between the concrete and abstract (e.g. a\n+//! field-deref on a local-variable, `x.field`, has the same meaning\n+//! in both domains). Indexed-Projections are the exception: `a[x]`\n+//! needs to be treated as mapping to the same move path as `a[y]` as\n+//! well as `a[13]`, et cetera.\n+//!\n+//! (In theory the analysis could be extended to work with sets of\n+//! paths, so that `a[0]` and `a[13]` could be kept distinct, while\n+//! `a[x]` would still overlap them both. But that is not this\n+//! representation does today.)\n+\n+use rustc::mir::repr::{Lvalue, LvalueElem};\n+use rustc::mir::repr::{Operand, Projection, ProjectionElem};\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct AbstractOperand;\n+pub type AbstractProjection<'tcx> =\n+    Projection<'tcx, Lvalue<'tcx>, AbstractOperand>;\n+pub type AbstractElem<'tcx> =\n+    ProjectionElem<'tcx, AbstractOperand>;\n+\n+pub trait Lift {\n+    type Abstract;\n+    fn lift(&self) -> Self::Abstract;\n+}\n+impl<'tcx> Lift for Operand<'tcx> {\n+    type Abstract = AbstractOperand;\n+    fn lift(&self) -> Self::Abstract { AbstractOperand }\n+}\n+impl<'tcx> Lift for LvalueElem<'tcx> {\n+    type Abstract = AbstractElem<'tcx>;\n+    fn lift(&self) -> Self::Abstract {\n+        match *self {\n+            ProjectionElem::Deref =>\n+                ProjectionElem::Deref,\n+            ProjectionElem::Field(ref f, ty) =>\n+                ProjectionElem::Field(f.clone(), ty.clone()),\n+            ProjectionElem::Index(ref i) =>\n+                ProjectionElem::Index(i.lift()),\n+            ProjectionElem::ConstantIndex {offset,min_length,from_end} =>\n+                ProjectionElem::ConstantIndex {\n+                    offset: offset,\n+                    min_length: min_length,\n+                    from_end: from_end\n+                },\n+            ProjectionElem::Downcast(a, u) =>\n+                ProjectionElem::Downcast(a.clone(), u.clone()),\n+        }\n+    }\n+}"}, {"sha": "3ab91c6ae23a826a2536e858d9ce7c4904fd01e3", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -0,0 +1,501 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::attr::AttrMetaMethods;\n+\n+use rustc::middle::ty;\n+use rustc::mir::repr::{self, Mir};\n+\n+use std::io;\n+use std::mem;\n+use std::usize;\n+\n+use super::MirBorrowckCtxt;\n+use super::gather_moves::{Location, MoveData, MovePathData, MovePathIndex, PathMap};\n+use super::graphviz;\n+use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n+\n+pub trait Dataflow {\n+    fn dataflow(&mut self);\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a> Dataflow for MirBorrowckCtxt<'b, 'a, 'tcx> {\n+    fn dataflow(&mut self) {\n+        self.build_gen_and_kill_sets();\n+        self.pre_dataflow_instrumentation().unwrap();\n+        self.propagate();\n+        self.post_dataflow_instrumentation().unwrap();\n+    }\n+}\n+\n+struct PropagationContext<'c, 'b: 'c, 'a: 'b, 'tcx: 'a> {\n+    mbcx: &'c mut MirBorrowckCtxt<'b, 'a, 'tcx>,\n+    changed: bool,\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n+    fn propagate(&mut self) {\n+        let mut temp = vec![0; self.flow_state.sets.words_per_block];\n+        let mut propcx = PropagationContext { mbcx: &mut *self, changed: true, };\n+        while propcx.changed {\n+            propcx.changed = false;\n+            propcx.reset(&mut temp);\n+            propcx.walk_cfg(&mut temp);\n+        }\n+    }\n+\n+    fn build_gen_and_kill_sets(&mut self) {\n+        // First we need to build the gen- and kill-sets. The\n+        // gather_moves information provides a high-level mapping from\n+        // mir-locations to the MoveOuts (and those correspond\n+        // directly to gen-sets here). But we still need to figure out\n+        // the kill-sets.\n+\n+        let move_data = &self.flow_state.operator;\n+        let move_paths = &move_data.move_paths;\n+        let loc_map = &move_data.loc_map;\n+        let path_map = &move_data.path_map;\n+        let rev_lookup = &move_data.rev_lookup;\n+\n+        for bb in self.mir.all_basic_blocks() {\n+            let &repr::BasicBlockData { ref statements,\n+                                        ref terminator,\n+                                        is_cleanup: _ } =\n+                self.mir.basic_block_data(bb);\n+\n+            let mut sets = self.flow_state.sets.for_block(bb.index());\n+            for (j, stmt) in statements.iter().enumerate() {\n+                let loc = Location { block: bb, index: j };\n+                debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n+                       stmt, loc, &loc_map[loc]);\n+                for move_index in &loc_map[loc] {\n+                    // Every path deinitialized by a *particular move*\n+                    // has corresponding bit, \"gen'ed\" (i.e. set)\n+                    // here, in dataflow vector\n+                    let retval = sets.gen_set.set_bit(move_index.idx().unwrap());\n+                    assert!(retval);\n+                }\n+                match stmt.kind {\n+                    repr::StatementKind::Assign(ref lvalue, _) => {\n+                        // assigning into this `lvalue` kills all\n+                        // MoveOuts from it, and *also* all MoveOuts\n+                        // for children and associated fragment sets.\n+                        let move_path_index = rev_lookup.find(lvalue);\n+                        set_children_kill_bits(sets.kill_set,\n+                                               move_path_index,\n+                                               path_map,\n+                                               move_paths);\n+                    }\n+                }\n+            }\n+\n+            let loc = Location { block: bb, index: statements.len() };\n+            debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n+                   terminator, loc, &loc_map[loc]);\n+            for move_index in &loc_map[loc] {\n+                let retval = sets.gen_set.set_bit(move_index.idx().unwrap());\n+                assert!(retval);\n+            }\n+\n+            // Note: while below as originally authored could be\n+            // written as an `if let`, it is more future-proof (to MIR\n+            // changes) to use an explicit `match` here.\n+            match *terminator {\n+                None => {}\n+                Some(repr::Terminator::Goto { target: _ }) => {}\n+                Some(repr::Terminator::If { cond: _, targets: _ }) => {}\n+                Some(repr::Terminator::Switch { discr: _, adt_def: _, targets: _ }) => {}\n+                Some(repr::Terminator::SwitchInt { discr: _, switch_ty: _, values: _, targets: _ }) => {}\n+                Some(repr::Terminator::Resume) => {}\n+                Some(repr::Terminator::Return) => {}\n+                Some(repr::Terminator::Drop { value: _, target: _, unwind: _ }) => {\n+                    // either kind of Drop completely invalidates the\n+                    // state of the referenced memory, effectively\n+                    // acting like a MoveOut. Such gen-set additions\n+                    // were added by the loop above over the loc_map.\n+                }\n+                Some(repr::Terminator::Call { func: _, args: _, cleanup: _,\n+                                              ref destination }) => {\n+                    // Note: a followup commit refines this to reflect\n+                    // that the destination will be initialized if the\n+                    // call succeeds (thus killling any MoveOuts for\n+                    // that destination).\n+                    //\n+                    // That is, this code just does the kills\n+                    // unconditionally (which I believe this matches\n+                    // the behavior of the old borrowck dataflow\n+                    // analysis), but this code also is also removed\n+                    // and replaced with something flow-dependent in a\n+                    // followup commit.\n+\n+                    if let Some((ref destination, _)) = *destination {\n+                        let move_path_index = rev_lookup.find(destination);\n+                        set_children_kill_bits(sets.kill_set,\n+                                               move_path_index,\n+                                               path_map,\n+                                               move_paths);\n+                    }\n+                }\n+            }\n+        }\n+\n+        fn set_children_kill_bits(kill_set: &mut [usize],\n+                                  move_path_index: MovePathIndex,\n+                                  path_map: &PathMap,\n+                                  move_paths: &MovePathData) {\n+            assert!(move_path_index.idx().is_some());\n+\n+            // 1. set kill bits for all moves that directly\n+            // influence path for `move_path_index`\n+            for move_index in &path_map[move_path_index] {\n+                kill_set.set_bit(move_index.idx().unwrap());\n+            }\n+\n+            // 2. for each child of the path (that is named in this\n+            //    function), recur.\n+            //\n+            // (Unnamed children are irrelevant to dataflow; by\n+            // definition they have no associated moves.)\n+            let mut child_index = move_paths[move_path_index].first_child;\n+            while let Some(_) = child_index.idx() {\n+                set_children_kill_bits(kill_set, child_index, path_map, move_paths);\n+                child_index = move_paths[child_index].next_sibling;\n+            }\n+        }\n+    }\n+}\n+\n+impl<'c, 'b: 'c, 'a: 'b, 'tcx: 'a> PropagationContext<'c, 'b, 'a, 'tcx> {\n+    fn reset(&mut self, bits: &mut [usize]) {\n+        let e = if self.mbcx.flow_state.operator.initial_value() {usize::MAX} else {0};\n+        for b in bits {\n+            *b = e;\n+        }\n+    }\n+\n+    fn walk_cfg(&mut self, in_out: &mut [usize]) {\n+        let &mut MirBorrowckCtxt { ref mir, ref mut flow_state, .. } = self.mbcx;\n+        for (idx, bb) in mir.basic_blocks.iter().enumerate() {\n+            {\n+                let sets = flow_state.sets.for_block(idx);\n+                debug_assert!(in_out.len() == sets.on_entry.len());\n+                in_out.clone_from_slice(sets.on_entry);\n+                bitwise(in_out, sets.gen_set, &Union);\n+                bitwise(in_out, sets.kill_set, &Subtract);\n+            }\n+            flow_state.propagate_bits_into_graph_successors_of(in_out, &mut self.changed, bb);\n+        }\n+    }\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n+    fn pre_dataflow_instrumentation(&self) -> io::Result<()> {\n+        self.if_attr_meta_name_found(\n+            \"borrowck_graphviz_preflow\",\n+            |this, path: &str| {\n+                graphviz::print_borrowck_graph_to(this, \"preflow\", path)\n+            })\n+    }\n+\n+    fn post_dataflow_instrumentation(&self) -> io::Result<()> {\n+        self.if_attr_meta_name_found(\n+            \"borrowck_graphviz_postflow\",\n+            |this, path: &str| {\n+                graphviz::print_borrowck_graph_to(this, \"postflow\", path)\n+            })\n+    }\n+\n+    fn if_attr_meta_name_found<F>(&self,\n+                                  name: &str,\n+                                  callback: F) -> io::Result<()>\n+        where F: for <'aa, 'bb> FnOnce(&'aa Self, &'bb str) -> io::Result<()>\n+    {\n+        for attr in self.attributes {\n+            if attr.check_name(\"rustc_mir\") {\n+                let items = attr.meta_item_list();\n+                for item in items.iter().flat_map(|l| l.iter()) {\n+                    if item.check_name(name) {\n+                        if let Some(s) = item.value_str() {\n+                            return callback(self, &s);\n+                        } else {\n+                            self.bcx.tcx.sess.span_err(\n+                                item.span,\n+                                &format!(\"{} attribute requires a path\", item.name()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+/// Maps each block to a set of bits\n+#[derive(Clone, Debug)]\n+struct Bits {\n+    bits: Vec<usize>,\n+}\n+\n+impl Bits {\n+    fn new(init_word: usize, num_words: usize) -> Self {\n+        Bits { bits: vec![init_word; num_words] }\n+    }\n+}\n+\n+pub struct DataflowState<O: BitDenotation>\n+{\n+    /// All the sets for the analysis. (Factored into its\n+    /// own structure so that we can borrow it mutably\n+    /// on its own separate from other fields.)\n+    pub sets: AllSets,\n+\n+    /// operator used to initialize, combine, and interpret bits.\n+    operator: O,\n+}\n+\n+pub struct AllSets {\n+    /// Analysis bitwidth for each block.\n+    bits_per_block: usize,\n+\n+    /// Number of words associated with each block entry\n+    /// equal to bits_per_block / usize::BITS, rounded up.\n+    words_per_block: usize,\n+\n+    /// For each block, bits generated by executing the statements in\n+    /// the block. (For comparison, the Terminator for each block is\n+    /// handled in a flow-specific manner during propagation.)\n+    gen_sets: Bits,\n+\n+    /// For each block, bits killed by executing the statements in the\n+    /// block. (For comparison, the Terminator for each block is\n+    /// handled in a flow-specific manner during propagation.)\n+    kill_sets: Bits,\n+\n+    /// For each block, bits valid on entry to the block.\n+    on_entry_sets: Bits,\n+}\n+\n+pub struct BlockSets<'a> {\n+    on_entry: &'a mut [usize],\n+    gen_set: &'a mut [usize],\n+    kill_set: &'a mut [usize],\n+}\n+\n+impl AllSets {\n+    pub fn bits_per_block(&self) -> usize { self.bits_per_block }\n+    pub fn bytes_per_block(&self) -> usize { (self.bits_per_block + 7) / 8 }\n+    pub fn for_block(&mut self, block_idx: usize) -> BlockSets {\n+        let offset = self.words_per_block * block_idx;\n+        let range = offset..(offset + self.words_per_block);\n+        BlockSets {\n+            on_entry: &mut self.on_entry_sets.bits[range.clone()],\n+            gen_set: &mut self.gen_sets.bits[range.clone()],\n+            kill_set: &mut self.kill_sets.bits[range],\n+        }\n+    }\n+\n+    fn lookup_set_for<'a>(&self, sets: &'a Bits, block_idx: usize) -> &'a [usize] {\n+        let offset = self.words_per_block * block_idx;\n+        &sets.bits[offset..(offset + self.words_per_block)]\n+    }\n+    pub fn gen_set_for(&self, block_idx: usize) -> &[usize] {\n+        self.lookup_set_for(&self.gen_sets, block_idx)\n+    }\n+    pub fn kill_set_for(&self, block_idx: usize) -> &[usize] {\n+        self.lookup_set_for(&self.kill_sets, block_idx)\n+    }\n+    pub fn on_entry_set_for(&self, block_idx: usize) -> &[usize] {\n+        self.lookup_set_for(&self.on_entry_sets, block_idx)\n+    }\n+}\n+\n+impl<O: BitDenotation> DataflowState<O> {\n+    fn each_bit<F>(&self, words: &[usize], mut f: F)\n+        where F: FnMut(usize) {\n+        //! Helper for iterating over the bits in a bitvector.\n+\n+        for (word_index, &word) in words.iter().enumerate() {\n+            if word != 0 {\n+                let usize_bits: usize = mem::size_of::<usize>();\n+                let base_index = word_index * usize_bits;\n+                for offset in 0..usize_bits {\n+                    let bit = 1 << offset;\n+                    if (word & bit) != 0 {\n+                        // NB: we round up the total number of bits\n+                        // that we store in any given bit set so that\n+                        // it is an even multiple of usize::BITS. This\n+                        // means that there may be some stray bits at\n+                        // the end that do not correspond to any\n+                        // actual value; that's why we first check\n+                        // that we are in range of bits_per_block.\n+                        let bit_index = base_index + offset as usize;\n+                        if bit_index >= self.sets.bits_per_block() {\n+                            return;\n+                        } else {\n+                            f(bit_index);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn interpret_set(&self, words: &[usize]) -> Vec<&O::Bit> {\n+        let mut v = Vec::new();\n+        self.each_bit(words, |i| {\n+            v.push(self.operator.interpret(i));\n+        });\n+        v\n+    }\n+}\n+\n+pub trait BitwiseOperator {\n+    /// Joins two predecessor bits together, typically either `|` or `&`\n+    fn join(&self, pred1: usize, pred2: usize) -> usize;\n+}\n+\n+/// Parameterization for the precise form of data flow that is used.\n+pub trait DataflowOperator : BitwiseOperator {\n+    /// Specifies the initial value for each bit in the `on_entry` set\n+    fn initial_value(&self) -> bool;\n+}\n+\n+pub trait BitDenotation: DataflowOperator {\n+    /// Specifies what is represented by each bit in the dataflow bitvector.\n+    type Bit;\n+    /// Size of each bivector allocated for each block in the analysis.\n+    fn bits_per_block(&self) -> usize;\n+    /// Provides the meaning of each entry in the dataflow bitvector.\n+    /// (Mostly intended for use for better debug instrumentation.)\n+    fn interpret(&self, idx: usize) -> &Self::Bit;\n+}\n+\n+impl<D: BitDenotation> DataflowState<D> {\n+    pub fn new(mir: &Mir, denotation: D) -> Self {\n+        let bits_per_block = denotation.bits_per_block();\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n+        let num_blocks = mir.basic_blocks.len();\n+        let num_words = num_blocks * words_per_block;\n+\n+        let entry = if denotation.initial_value() { usize::MAX } else {0};\n+\n+        let zeroes = Bits::new(0, num_words);\n+        let on_entry = Bits::new(entry, num_words);\n+\n+        DataflowState {\n+            sets: AllSets {\n+                bits_per_block: bits_per_block,\n+                words_per_block: words_per_block,\n+                gen_sets: zeroes.clone(),\n+                kill_sets: zeroes,\n+                on_entry_sets: on_entry,\n+            },\n+            operator: denotation,\n+        }\n+    }\n+}\n+\n+impl<D: BitDenotation> DataflowState<D> {\n+    fn propagate_bits_into_graph_successors_of(&mut self,\n+                                               in_out: &mut [usize],\n+                                               changed: &mut bool,\n+                                               bb: &repr::BasicBlockData) {\n+        let term = if let Some(ref term) = bb.terminator { term } else { return };\n+        match *term {\n+            repr::Terminator::Return |\n+            repr::Terminator::Resume => {}\n+            repr::Terminator::Goto { ref target } |\n+            repr::Terminator::Drop { ref target, value: _, unwind: None } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+            }\n+            repr::Terminator::Drop { ref target, value: _, unwind: Some(ref unwind) } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+            }\n+            repr::Terminator::If { ref targets, .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.0);\n+                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.1);\n+            }\n+            repr::Terminator::Switch { ref targets, .. } |\n+            repr::Terminator::SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                }\n+            }\n+            repr::Terminator::Call { ref cleanup, ref destination, func: _, args: _ } => {\n+                if let Some(ref unwind) = *cleanup {\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+                }\n+                if let Some((_, ref destination)) = *destination {\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, destination);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate_bits_into_entry_set_for(&mut self,\n+                                         in_out: &mut [usize],\n+                                         changed: &mut bool,\n+                                         bb: &repr::BasicBlock) {\n+        let entry_set = self.sets.for_block(bb.index()).on_entry;\n+        let set_changed = bitwise(entry_set, in_out, &self.operator);\n+        if set_changed {\n+            *changed = true;\n+        }\n+    }\n+}\n+\n+\n+impl<'tcx> DataflowState<MoveData<'tcx>> {\n+    pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> Self {\n+        let move_data = MoveData::gather_moves(mir, tcx);\n+        DataflowState::new(mir, move_data)\n+    }\n+}\n+\n+impl<'tcx> BitwiseOperator for MoveData<'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // moves from both preds are in scope\n+    }\n+}\n+\n+impl<'tcx> DataflowOperator for MoveData<'tcx> {\n+    #[inline]\n+    fn initial_value(&self) -> bool {\n+        false // no loans in scope by default\n+    }\n+}\n+\n+#[inline]\n+fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n+                               in_vec: &[usize],\n+                               op: &Op) -> bool {\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    let mut changed = false;\n+    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n+        let old_val = *out_elt;\n+        let new_val = op.join(old_val, *in_elt);\n+        *out_elt = new_val;\n+        changed |= old_val != new_val;\n+    }\n+    changed\n+}\n+\n+struct Union;\n+impl BitwiseOperator for Union {\n+    fn join(&self, a: usize, b: usize) -> usize { a | b }\n+}\n+struct Subtract;\n+impl BitwiseOperator for Subtract {\n+    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n+}"}, {"sha": "135fdb838d087180a3fc06bce1cbae97440c0c40", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "added", "additions": 715, "deletions": 0, "changes": 715, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -0,0 +1,715 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use rustc::middle::ty;\n+use rustc::middle::def_id::DefId;\n+use rustc::mir::repr::{self, Mir, BasicBlock, Lvalue, Rvalue};\n+use rustc::mir::repr::{StatementKind, Terminator};\n+use rustc::util::nodemap::FnvHashMap;\n+\n+use std::cell::{Cell, RefCell};\n+use std::collections::hash_map::Entry;\n+use std::fmt;\n+use std::iter;\n+use std::ops::Index;\n+use std::usize;\n+\n+use super::dataflow::BitDenotation;\n+use super::abs_domain::{AbstractElem, Lift};\n+\n+/// Index into MovePathData.move_paths\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct MovePathIndex(usize);\n+\n+const INVALID_MOVE_PATH_INDEX: MovePathIndex = MovePathIndex(usize::MAX);\n+\n+impl MovePathIndex {\n+    pub fn idx(&self) -> Option<usize> {\n+        if *self == INVALID_MOVE_PATH_INDEX {\n+            None\n+        } else {\n+            Some(self.0)\n+        }\n+    }\n+}\n+\n+/// `MovePath` is a canonicalized representation of a path that is\n+/// moved or assigned to.\n+///\n+/// It follows a tree structure.\n+///\n+/// Given `struct X { m: M, n: N }` and `x: X`, moves like `drop x.m;`\n+/// move *out* of the l-value `x.m`.\n+///\n+/// The MovePaths representing `x.m` and `x.n` are siblings (that is,\n+/// one of them will link to the other via the `next_sibling` field,\n+/// and the other will have no entry in its `next_sibling` field), and\n+/// they both have the MovePath representing `x` as their parent.\n+#[derive(Clone)]\n+pub struct MovePath<'tcx> {\n+    pub next_sibling: MovePathIndex,\n+    pub first_child: MovePathIndex,\n+    pub parent: MovePathIndex,\n+    pub lvalue: Lvalue<'tcx>,\n+}\n+\n+/// During construction of the MovePath's, we use PreMovePath to\n+/// represent accumulated state while we are gathering up all the\n+/// children of each path.\n+#[derive(Clone)]\n+struct PreMovePath<'tcx> {\n+    pub next_sibling: MovePathIndex,\n+    pub first_child: Cell<MovePathIndex>,\n+    pub parent: MovePathIndex,\n+    pub lvalue: Lvalue<'tcx>,\n+}\n+\n+impl<'tcx> PreMovePath<'tcx> {\n+    fn into_move_path(self) -> MovePath<'tcx> {\n+        MovePath {\n+            next_sibling: self.next_sibling,\n+            parent: self.parent,\n+            lvalue: self.lvalue,\n+            first_child: self.first_child.get(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for MovePath<'tcx> {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(w, \"MovePath {{\"));\n+        if self.parent != INVALID_MOVE_PATH_INDEX {\n+            try!(write!(w, \" parent: {:?},\", self.parent));\n+        }\n+        if self.first_child != INVALID_MOVE_PATH_INDEX {\n+            try!(write!(w, \" first_child: {:?},\", self.first_child));\n+        }\n+        if self.next_sibling != INVALID_MOVE_PATH_INDEX {\n+            try!(write!(w, \" next_sibling: {:?}\", self.next_sibling));\n+        }\n+        write!(w, \" lvalue: {:?} }}\", self.lvalue)\n+    }\n+}\n+\n+/// Index into MoveData.moves.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct MoveOutIndex(usize);\n+\n+impl MoveOutIndex {\n+    pub fn idx(&self) -> Option<usize> {\n+        if *self == INVALID_MOVE_OUT_INDEX {\n+            None\n+        } else {\n+            Some(self.0)\n+        }\n+    }\n+}\n+\n+const INVALID_MOVE_OUT_INDEX: MoveOutIndex = MoveOutIndex(usize::MAX);\n+\n+pub struct MoveData<'tcx> {\n+    pub move_paths: MovePathData<'tcx>,\n+    pub moves: Vec<MoveOut>,\n+    pub loc_map: LocMap,\n+    pub path_map: PathMap,\n+    pub rev_lookup: MovePathLookup<'tcx>,\n+}\n+\n+pub struct LocMap {\n+    /// Location-indexed (BasicBlock for outer index, index within BB\n+    /// for inner index) map to list of MoveOutIndex's.\n+    ///\n+    /// Each Location `l` is mapped to the MoveOut's that are effects\n+    /// of executing the code at `l`. (There can be multiple MoveOut's\n+    /// for a given `l` because each MoveOut is associated with one\n+    /// particular path being moved.)\n+    map: Vec<Vec<Vec<MoveOutIndex>>>,\n+}\n+\n+impl Index<Location> for LocMap {\n+    type Output = [MoveOutIndex];\n+    fn index(&self, index: Location) -> &Self::Output {\n+        assert!(index.block.index() < self.map.len());\n+        assert!(index.index < self.map[index.block.index()].len());\n+        &self.map[index.block.index()][index.index]\n+    }\n+}\n+\n+pub struct PathMap {\n+    /// Path-indexed map to list of MoveOutIndex's.\n+    ///\n+    /// Each Path `p` is mapped to the MoveOut's that move out of `p`.\n+    map: Vec<Vec<MoveOutIndex>>,\n+}\n+\n+impl Index<MovePathIndex> for PathMap {\n+    type Output = [MoveOutIndex];\n+    fn index(&self, index: MovePathIndex) -> &Self::Output {\n+        assert!(index != INVALID_MOVE_PATH_INDEX);\n+        &self.map[index.0]\n+    }\n+}\n+\n+/// `MoveOut` represents a point in a program that moves out of some\n+/// L-value; i.e., \"creates\" uninitialized memory.\n+///\n+/// With respect to dataflow analysis:\n+/// - Generated by moves and declaration of uninitialized variables.\n+/// - Killed by assignments to the memory.\n+#[derive(Copy, Clone)]\n+pub struct MoveOut {\n+    /// path being moved\n+    pub path: MovePathIndex,\n+    /// location of move\n+    pub source: Location,\n+}\n+\n+impl fmt::Debug for MoveOut {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"p{}@{:?}\", self.path.0, self.source)\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Location {\n+    /// block where action is located\n+    pub block: BasicBlock,\n+    /// index within above block; statement when < statments.len) or\n+    /// the terminator (when = statements.len).\n+    pub index: usize,\n+}\n+\n+impl fmt::Debug for Location {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}[{}]\", self.block, self.index)\n+    }\n+}\n+\n+pub struct MovePathData<'tcx> {\n+    move_paths: Vec<MovePath<'tcx>>,\n+}\n+\n+impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n+    type Output = MovePath<'tcx>;\n+    fn index(&self, i: MovePathIndex) -> &MovePath<'tcx> {\n+        &self.move_paths[i.idx().unwrap()]\n+    }\n+}\n+\n+/// MovePathRevIndex maps from a uint in an lvalue-category to the\n+/// MovePathIndex for the MovePath for that lvalue.\n+type MovePathRevIndex = Vec<MovePathIndex>;\n+\n+struct MovePathDataBuilder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    pre_move_paths: RefCell<Vec<PreMovePath<'tcx>>>,\n+    rev_lookup: RefCell<MovePathLookup<'tcx>>,\n+}\n+\n+/// Tables mapping from an l-value to its MovePathIndex.\n+pub struct MovePathLookup<'tcx> {\n+    vars: MovePathRevIndex,\n+    temps: MovePathRevIndex,\n+    args: MovePathRevIndex,\n+    statics: FnvHashMap<DefId, MovePathIndex>,\n+    return_ptr: Option<MovePathIndex>,\n+\n+    /// This is the only non-trivial lookup to explain: projections\n+    /// are made from a base-lvalue and a projection elem. The\n+    /// base-lvalue will have a unique MovePathIndex; we use the\n+    /// latter as the index into the outer vector (narrowing\n+    /// subsequent search so that it is solely relative to that\n+    /// base-lvalue). For the remaining lookup, we map the projection\n+    /// elem to the associated MovePathIndex.\n+    projections: Vec<FnvHashMap<AbstractElem<'tcx>, MovePathIndex>>,\n+\n+    /// Tracks the next index to allocate during construction of the\n+    /// MovePathData. Unused after MovePathData is fully constructed.\n+    next_index: MovePathIndex,\n+}\n+\n+trait FillTo {\n+    type T;\n+    fn fill_to_with(&mut self, idx: usize, x: Self::T);\n+    fn fill_to(&mut self, idx: usize) where Self::T: Default {\n+        self.fill_to_with(idx, Default::default())\n+    }\n+}\n+impl<T:Clone> FillTo for Vec<T> {\n+    type T = T;\n+    fn fill_to_with(&mut self, idx: usize, x: T) {\n+        if idx >= self.len() {\n+            let delta = idx + 1 - self.len();\n+            assert_eq!(idx + 1, self.len() + delta);\n+            self.extend(iter::repeat(x).take(delta))\n+        }\n+        debug_assert!(idx < self.len());\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+enum LookupKind { Generate, Reuse }\n+struct Lookup<T>(LookupKind, T);\n+\n+impl Lookup<MovePathIndex> {\n+    fn idx(&self) -> usize { (self.1).0 }\n+}\n+\n+impl<'tcx> MovePathLookup<'tcx> {\n+    fn new() -> Self {\n+        MovePathLookup {\n+            vars: vec![],\n+            temps: vec![],\n+            args: vec![],\n+            statics: Default::default(),\n+            return_ptr: None,\n+            projections: vec![],\n+            next_index: MovePathIndex(0),\n+        }\n+    }\n+\n+    fn next_index(next: &mut MovePathIndex) -> MovePathIndex {\n+        let i = *next;\n+        *next = MovePathIndex(i.0 + 1);\n+        i\n+    }\n+\n+    fn lookup_or_generate(vec: &mut Vec<MovePathIndex>,\n+                          idx: u32,\n+                          next_index: &mut MovePathIndex) -> Lookup<MovePathIndex> {\n+        let idx = idx as usize;\n+        vec.fill_to_with(idx, INVALID_MOVE_PATH_INDEX);\n+        let entry = &mut vec[idx];\n+        if *entry == INVALID_MOVE_PATH_INDEX {\n+            let i = Self::next_index(next_index);\n+            *entry = i;\n+            Lookup(LookupKind::Generate, i)\n+        } else {\n+            Lookup(LookupKind::Reuse, *entry)\n+        }\n+    }\n+\n+    fn lookup_var(&mut self, var_idx: u32) -> Lookup<MovePathIndex> {\n+        Self::lookup_or_generate(&mut self.vars,\n+                                 var_idx,\n+                                 &mut self.next_index)\n+    }\n+\n+    fn lookup_temp(&mut self, temp_idx: u32) -> Lookup<MovePathIndex> {\n+        Self::lookup_or_generate(&mut self.temps,\n+                                 temp_idx,\n+                                 &mut self.next_index)\n+    }\n+\n+    fn lookup_arg(&mut self, arg_idx: u32) -> Lookup<MovePathIndex> {\n+        Self::lookup_or_generate(&mut self.args,\n+                                 arg_idx,\n+                                 &mut self.next_index)\n+    }\n+\n+    fn lookup_static(&mut self, static_id: DefId) -> Lookup<MovePathIndex> {\n+        let &mut MovePathLookup { ref mut statics,\n+                                  ref mut next_index, .. } = self;\n+        match statics.entry(static_id.clone()) {\n+            Entry::Occupied(ent) => {\n+                Lookup(LookupKind::Reuse, *ent.get())\n+            }\n+            Entry::Vacant(ent) => {\n+                let mpi = Self::next_index(next_index);\n+                ent.insert(mpi);\n+                Lookup(LookupKind::Generate, mpi)\n+            }\n+        }\n+    }\n+\n+    fn lookup_return_pointer(&mut self) -> Lookup<MovePathIndex> {\n+        match self.return_ptr {\n+            Some(mpi) => {\n+                Lookup(LookupKind::Reuse, mpi)\n+            }\n+            ref mut ret @ None => {\n+                let mpi = Self::next_index(&mut self.next_index);\n+                *ret = Some(mpi);\n+                Lookup(LookupKind::Generate, mpi)\n+            }\n+        }\n+    }\n+\n+    fn lookup_proj(&mut self,\n+                   proj: &repr::LvalueProjection<'tcx>,\n+                   base: MovePathIndex) -> Lookup<MovePathIndex> {\n+        let MovePathLookup { ref mut projections,\n+                             ref mut next_index, .. } = *self;\n+        projections.fill_to(base.0);\n+        match projections[base.0].entry(proj.elem.lift()) {\n+            Entry::Occupied(ent) => {\n+                Lookup(LookupKind::Reuse, *ent.get())\n+            }\n+            Entry::Vacant(ent) => {\n+                let mpi = Self::next_index(next_index);\n+                ent.insert(mpi);\n+                Lookup(LookupKind::Generate, mpi)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> MovePathLookup<'tcx> {\n+    // Unlike the builder `fn move_path_for` below, this lookup\n+    // alternative will *not* create a MovePath on the fly for an\n+    // unknown l-value; it will simply panic.\n+    pub fn find(&self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n+        match *lval {\n+            Lvalue::Var(var_idx) => self.vars[var_idx as usize],\n+            Lvalue::Temp(temp_idx) => self.temps[temp_idx as usize],\n+            Lvalue::Arg(arg_idx) => self.args[arg_idx as usize],\n+            Lvalue::Static(ref def_id) => self.statics[def_id],\n+            Lvalue::ReturnPointer => self.return_ptr.unwrap(),\n+            Lvalue::Projection(ref proj) => {\n+                let base_index = self.find(&proj.base);\n+                self.projections[base_index.0 as usize][&proj.elem.lift()]\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n+    // (use of `&self` here is going to necessitate use of e.g. RefCell\n+    //  or some other &-safe data accumulator)\n+    //\n+    // Caller must ensure self's RefCells (i.e. `self.pre_move_paths`\n+    // and `self.rev_lookup`) are not mutably borrowed.\n+    fn move_path_for(&self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n+        let lookup = {\n+            let mut rev_lookup = self.rev_lookup.borrow_mut();\n+            match *lval {\n+                Lvalue::Var(var_idx) => rev_lookup.lookup_var(var_idx),\n+                Lvalue::Temp(temp_idx) => rev_lookup.lookup_temp(temp_idx),\n+                Lvalue::Arg(arg_idx) => rev_lookup.lookup_arg(arg_idx),\n+                Lvalue::Static(def_id) => rev_lookup.lookup_static(def_id),\n+                Lvalue::ReturnPointer => rev_lookup.lookup_return_pointer(),\n+                Lvalue::Projection(ref proj) => {\n+                    // Manually drop the rev_lookup ...\n+                    drop(rev_lookup);\n+\n+                    // ... so that we can reborrow it here (which may\n+                    //     well be building new move path) ...\n+                    let base_index = self.move_path_for(&proj.base);\n+\n+                    // ... and restablish exclusive access here.\n+                    let mut rev_lookup = self.rev_lookup.borrow_mut();\n+                    rev_lookup.lookup_proj(proj, base_index)\n+                }\n+            }\n+        };\n+\n+        let mut pre_move_paths = self.pre_move_paths.borrow_mut();\n+\n+        // At this point, `lookup` is either the previously assigned\n+        // index or a newly-allocated one.\n+        debug_assert!(lookup.idx() <= pre_move_paths.len());\n+\n+        if let Lookup(LookupKind::Generate, mpi) = lookup {\n+            let parent;\n+            let sibling;\n+\n+            match *lval {\n+                Lvalue::Var(_) | Lvalue::Temp(_) | Lvalue::Arg(_) |\n+                Lvalue::Static(_) | Lvalue::ReturnPointer => {\n+                    sibling = INVALID_MOVE_PATH_INDEX;\n+                    parent = INVALID_MOVE_PATH_INDEX;\n+                }\n+                Lvalue::Projection(ref proj) => {\n+                    // Here, install new MovePath as new first_child.\n+\n+                    drop(pre_move_paths);\n+\n+                    // Note: `parent` previously allocated (Projection\n+                    // case of match above established this).\n+                    parent = self.move_path_for(&proj.base);\n+\n+                    pre_move_paths = self.pre_move_paths.borrow_mut();\n+                    let parent_move_path = &mut pre_move_paths[parent.0];\n+\n+                    // At last: Swap in the new first_child.\n+                    sibling = parent_move_path.first_child.get();\n+                    parent_move_path.first_child.set(mpi);\n+                }\n+            };\n+\n+            let move_path = PreMovePath {\n+                next_sibling: sibling,\n+                parent: parent,\n+                lvalue: lval.clone(),\n+                first_child: Cell::new(INVALID_MOVE_PATH_INDEX),\n+            };\n+\n+            pre_move_paths.push(move_path);\n+        }\n+\n+        return lookup.1;\n+    }\n+}\n+\n+impl<'tcx> MoveData<'tcx> {\n+    pub fn gather_moves(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> Self {\n+        gather_moves(mir, tcx)\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum StmtKind {\n+    Use, Repeat, Cast, BinaryOp, UnaryOp, Box,\n+    Aggregate, Drop, CallFn, CallArg, Return,\n+}\n+\n+fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx> {\n+    use self::StmtKind as SK;\n+\n+    let bbs = mir.all_basic_blocks();\n+    let mut moves = Vec::with_capacity(bbs.len());\n+    let mut loc_map: Vec<_> = iter::repeat(Vec::new()).take(bbs.len()).collect();\n+    let mut path_map = Vec::new();\n+\n+    let builder = MovePathDataBuilder {\n+        mir: mir,\n+        pre_move_paths: RefCell::new(Vec::new()),\n+        rev_lookup: RefCell::new(MovePathLookup::new()),\n+    };\n+\n+    for bb in bbs {\n+        let loc_map_bb = &mut loc_map[bb.index()];\n+        let bb_data = mir.basic_block_data(bb);\n+\n+        debug_assert!(loc_map_bb.len() == 0);\n+        let len = bb_data.statements.len();\n+        loc_map_bb.fill_to(len);\n+        debug_assert!(loc_map_bb.len() == len + 1);\n+\n+        let mut bb_ctxt = BlockContext {\n+            tcx: tcx,\n+            moves: &mut moves,\n+            builder: &builder,\n+            path_map: &mut path_map,\n+            loc_map_bb: loc_map_bb,\n+        };\n+\n+        for (i, stmt) in bb_data.statements.iter().enumerate() {\n+            let source = Location { block: bb, index: i };\n+            match stmt.kind {\n+                StatementKind::Assign(ref lval, ref rval) => {\n+                    // ensure MovePath created for `lval`.\n+                    builder.move_path_for(lval);\n+\n+                    match *rval {\n+                        Rvalue::Use(ref operand) => {\n+                            bb_ctxt.on_operand(SK::Use, operand, source)\n+                        }\n+                        Rvalue::Repeat(ref operand, ref _const) =>\n+                            bb_ctxt.on_operand(SK::Repeat, operand, source),\n+                        Rvalue::Cast(ref _kind, ref operand, ref _ty) =>\n+                            bb_ctxt.on_operand(SK::Cast, operand, source),\n+                        Rvalue::BinaryOp(ref _binop, ref operand1, ref operand2) => {\n+                            bb_ctxt.on_operand(SK::BinaryOp, operand1, source);\n+                            bb_ctxt.on_operand(SK::BinaryOp, operand2, source);\n+                        }\n+                        Rvalue::UnaryOp(ref _unop, ref operand) => {\n+                            bb_ctxt.on_operand(SK::UnaryOp, operand, source);\n+                        }\n+                        Rvalue::Box(ref _ty) => {\n+                            // this is creating uninitialized\n+                            // memory that needs to be initialized.\n+                            bb_ctxt.on_move_out_lval(SK::Box, lval, source);\n+                        }\n+                        Rvalue::Aggregate(ref _kind, ref operands) => {\n+                            for operand in operands {\n+                                bb_ctxt.on_operand(SK::Aggregate, operand, source);\n+                            }\n+                        }\n+                        Rvalue::Ref(..) |\n+                        Rvalue::Len(..) |\n+                        Rvalue::InlineAsm { .. } => {}\n+\n+                        Rvalue::Slice {..} => {\n+                            bb_ctxt.tcx.sess.bug(\"cannot move out of slice\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if let Some(ref term) = bb_data.terminator {\n+            match *term {\n+                Terminator::Goto { target: _ } | Terminator::Resume => { }\n+\n+                Terminator::Return => {\n+                    let source = Location { block: bb,\n+                                            index: bb_data.statements.len() };\n+                    let lval = &Lvalue::ReturnPointer.deref();\n+                    bb_ctxt.on_move_out_lval(SK::Return, lval, source);\n+                }\n+\n+                Terminator::If { ref cond, targets: _ } => {\n+                    // The `cond` is always of (copyable) type `bool`,\n+                    // so there will never be anything to move.\n+                    let _ = cond;\n+                }\n+\n+                Terminator::SwitchInt { switch_ty: _, values: _, targets: _, ref discr } |\n+                Terminator::Switch { adt_def: _, targets: _, ref discr } => {\n+                    // The `discr` is not consumed; that is instead\n+                    // encoded on specific match arms (and for\n+                    // SwitchInt`, it is always a copyable integer\n+                    // type anyway).\n+                    let _ = discr;\n+                }\n+\n+                Terminator::Drop { value: ref lval, target: _, unwind: _ } => {\n+                    let source = Location { block: bb,\n+                                            index: bb_data.statements.len() };\n+                    bb_ctxt.on_move_out_lval(SK::Drop, lval, source);\n+                }\n+\n+                Terminator::Call { ref func, ref args, ref destination, cleanup: _ } => {\n+                    let source = Location { block: bb,\n+                                            index: bb_data.statements.len() };\n+                    bb_ctxt.on_operand(SK::CallFn, func, source);\n+                    for arg in args {\n+                        bb_ctxt.on_operand(SK::CallArg, arg, source);\n+                    }\n+                    if let Some((ref destination, _bb)) = *destination {\n+                        // Create MovePath for `destination`, then\n+                        // discard returned index.\n+                        builder.move_path_for(destination);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // At this point, we may have created some MovePaths that do not\n+    // have corresponding entries in the path map.\n+    //\n+    // (For example, creating the path `a.b.c` may, as a side-effect,\n+    // create a path for the parent path `a.b`.)\n+    //\n+    // All such paths were not referenced ...\n+    //\n+    // well you know, lets actually try just asserting that the path map *is* complete.\n+    assert_eq!(path_map.len(), builder.pre_move_paths.borrow().len());\n+    path_map.fill_to(builder.pre_move_paths.borrow().len() - 1);\n+\n+    let pre_move_paths = builder.pre_move_paths.into_inner();\n+    let move_paths: Vec<_> = pre_move_paths.into_iter()\n+        .map(|p| p.into_move_path())\n+        .collect();\n+\n+    debug!(\"{}\", {\n+        let mut seen: Vec<_> = move_paths.iter().map(|_| false).collect();\n+        for (j, &MoveOut { ref path, ref source }) in moves.iter().enumerate() {\n+            debug!(\"MovePathData moves[{}]: MoveOut {{ path: {:?} = {:?}, source: {:?} }}\",\n+                   j, path, move_paths[path.0], source);\n+            seen[path.0] = true;\n+        }\n+        for (j, path) in move_paths.iter().enumerate() {\n+            if !seen[j] {\n+                debug!(\"MovePathData move_paths[{}]: {:?}\", j, path);\n+            }\n+        }\n+        \"done dumping MovePathData\"\n+    });\n+\n+    MoveData {\n+        move_paths: MovePathData { move_paths: move_paths, },\n+        moves: moves,\n+        loc_map: LocMap { map: loc_map },\n+        path_map: PathMap { map: path_map },\n+        rev_lookup: builder.rev_lookup.into_inner(),\n+    }\n+}\n+\n+struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n+    tcx: &'b ty::TyCtxt<'tcx>,\n+    moves: &'b mut Vec<MoveOut>,\n+    builder: &'b MovePathDataBuilder<'a, 'tcx>,\n+    path_map: &'b mut Vec<Vec<MoveOutIndex>>,\n+    loc_map_bb: &'b mut Vec<Vec<MoveOutIndex>>,\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n+    fn on_move_out_lval(&mut self,\n+                        stmt_kind: StmtKind,\n+                        lval: &repr::Lvalue<'tcx>,\n+                        source: Location) {\n+        let builder = self.builder;\n+        let tcx = self.tcx;\n+        let lval_ty = builder.mir.lvalue_ty(tcx, lval);\n+\n+        // FIXME: does lvalue_ty ever return TyError, or is it\n+        // guaranteed to always return non-Infer/non-Error values?\n+\n+        // This code is just trying to avoid creating a MoveOut\n+        // entry for values that do not need move semantics.\n+        //\n+        // type_contents is imprecise (may claim needs drop for\n+        // types that in fact have no destructor). But that is\n+        // still usable for our purposes here.\n+        let consumed = lval_ty.to_ty(tcx).type_contents(tcx).needs_drop(tcx);\n+\n+        if !consumed {\n+            debug!(\"ctxt: {:?} no consume of lval: {:?} of type {:?}\",\n+                   stmt_kind, lval, lval_ty);\n+            return;\n+        }\n+        let i = source.index;\n+        let index = MoveOutIndex(self.moves.len());\n+\n+        let path = builder.move_path_for(lval);\n+        self.moves.push(MoveOut { path: path, source: source.clone() });\n+        self.path_map.fill_to(path.0);\n+\n+        debug!(\"ctxt: {:?} add consume of lval: {:?} \\\n+                at index: {:?} \\\n+                to path_map for path: {:?} and \\\n+                to loc_map for loc: {:?}\",\n+               stmt_kind, lval, index, path, source);\n+\n+        debug_assert!(path.0 < self.path_map.len());\n+        // this is actually a questionable assert; at the very\n+        // least, incorrect input code can probably cause it to\n+        // fire.\n+        assert!(self.path_map[path.0].iter().find(|idx| **idx == index).is_none());\n+        self.path_map[path.0].push(index);\n+\n+        debug_assert!(i < self.loc_map_bb.len());\n+        debug_assert!(self.loc_map_bb[i].iter().find(|idx| **idx == index).is_none());\n+        self.loc_map_bb[i].push(index);\n+    }\n+\n+    fn on_operand(&mut self, stmt_kind: StmtKind, operand: &repr::Operand<'tcx>, source: Location) {\n+        match *operand {\n+            repr::Operand::Constant(..) => {} // not-a-move\n+            repr::Operand::Consume(ref lval) => { // a move\n+                self.on_move_out_lval(stmt_kind, lval, source);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> BitDenotation for MoveData<'tcx>{\n+    type Bit = MoveOut;\n+    fn bits_per_block(&self) -> usize {\n+        self.moves.len()\n+    }\n+    fn interpret(&self, idx: usize) -> &Self::Bit {\n+        &self.moves[idx]\n+    }\n+}"}, {"sha": "b81ef186a4f9dd3735ed5a0a78c2aece30a2bdc7", "filename": "src/librustc_borrowck/borrowck/mir/graphviz.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -0,0 +1,232 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Hook into libgraphviz for rendering dataflow graphs for MIR.\n+\n+use rustc::mir::repr::{BasicBlock, Mir};\n+\n+use dot;\n+use dot::IntoCow;\n+\n+use std::fs::File;\n+use std::io;\n+use std::io::prelude::*;\n+\n+use super::MirBorrowckCtxt;\n+use bitslice::bits_to_string;\n+use super::gather_moves::MoveOut;\n+\n+struct Graph<'c, 'b:'c, 'a:'b, 'tcx:'a> { mbcx: &'c MirBorrowckCtxt<'b, 'a, 'tcx>,\n+                                          context: &'b str }\n+\n+pub fn print_borrowck_graph_to(mbcx: &MirBorrowckCtxt,\n+                               context: &str,\n+                               path: &str) -> io::Result<()> {\n+    let g = Graph { mbcx: mbcx, context: context };\n+    let mut v = Vec::new();\n+    try!(dot::render(&g, &mut v));\n+    println!(\"print_borrowck_graph_to path: {} context: {} node_id: {}\",\n+             path, context, mbcx.node_id);\n+    File::create(path).and_then(|mut f| f.write_all(&v))\n+}\n+\n+pub type Node = BasicBlock;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct Edge { source: BasicBlock, index: usize }\n+\n+fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n+    let succ_len = mir.basic_block_data(bb).terminator().successors().len();\n+    (0..succ_len).map(|index| Edge { source: bb, index: index}).collect()\n+}\n+\n+impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n+    type Node = Node;\n+    type Edge = Edge;\n+    fn graph_id(&self) -> dot::Id {\n+        dot::Id::new(format!(\"graph_for_node_{}_{}\",\n+                             self.mbcx.node_id,\n+                             self.context))\n+            .unwrap()\n+    }\n+\n+    fn node_id(&self, n: &Node) -> dot::Id {\n+        dot::Id::new(format!(\"bb_{}\", n.index()))\n+            .unwrap()\n+    }\n+\n+    fn node_label(&self, n: &Node) -> dot::LabelText {\n+        // A standard MIR label, as generated by write_node_label, is\n+        // presented in a single column in a table.\n+        //\n+        // The code below does a bunch of formatting work to format a\n+        // node (i.e. MIR basic-block) label with extra\n+        // dataflow-enriched information.  In particular, the goal is\n+        // to add extra columns that present the three dataflow\n+        // bitvectors, and the data those bitvectors represent.\n+        //\n+        // It presents it in the following format (where I am\n+        // presenting the table rendering via ASCII art, one line per\n+        // row of the table, and a chunk size of 3 rather than 5):\n+        //\n+        // ------  -----------------------  ------------  --------------------\n+        //                    [e1, e3, e4]\n+        //             [e8, e9] \"= ENTRY:\"  <ENTRY-BITS>\n+        // ------  -----------------------  ------------  --------------------\n+        // Left\n+        // Most\n+        // Column\n+        // Is\n+        // Just\n+        // Normal\n+        // Series\n+        // Of\n+        // MIR\n+        // Stmts\n+        // ------  -----------------------  ------------  --------------------\n+        //           [g1, g4, g5] \"= GEN:\"  <GEN-BITS>\n+        // ------  -----------------------  ------------  --------------------\n+        //                         \"KILL:\"  <KILL-BITS>   \"=\" [k1, k3, k8]\n+        //                                                [k9]\n+        // ------  -----------------------  ------------  --------------------\n+        //\n+        // (In addition, the added dataflow is rendered with a colored\n+        // background just so it will stand out compared to the\n+        // statements.)\n+        let mut v = Vec::new();\n+        let i = n.index();\n+        let chunk_size = 5;\n+        const BG_FLOWCONTENT: &'static str = r#\"bgcolor=\"pink\"\"#;\n+        const ALIGN_RIGHT: &'static str = r#\"align=\"right\"\"#;\n+        const FACE_MONOSPACE: &'static str = r#\"FACE=\"Courier\"\"#;\n+        fn chunked_present_left<W:io::Write>(w: &mut W,\n+                                             interpreted: &[&MoveOut],\n+                                             chunk_size: usize)\n+                                             -> io::Result<()>\n+        {\n+            // This function may emit a sequence of <tr>'s, but it\n+            // always finishes with an (unfinished)\n+            // <tr><td></td><td>\n+            //\n+            // Thus, after being called, one should finish both the\n+            // pending <td> as well as the <tr> itself.\n+            let mut seen_one = false;\n+            for c in interpreted.chunks(chunk_size) {\n+                if seen_one {\n+                    // if not the first row, finish off the previous row\n+                    try!(write!(w, \"</td><td></td><td></td></tr>\"));\n+                }\n+                try!(write!(w, \"<tr><td></td><td {bg} {align}>{objs:?}\",\n+                            bg = BG_FLOWCONTENT,\n+                            align = ALIGN_RIGHT,\n+                            objs = c));\n+                seen_one = true;\n+            }\n+            if !seen_one {\n+                try!(write!(w, \"<tr><td></td><td {bg} {align}>[]\",\n+                            bg = BG_FLOWCONTENT,\n+                            align = ALIGN_RIGHT));\n+            }\n+            Ok(())\n+        }\n+        ::rustc_mir::graphviz::write_node_label(\n+            *n, self.mbcx.mir, &mut v, 4,\n+            |w| {\n+                let flow = &self.mbcx.flow_state;\n+                let entry = flow.interpret_set(flow.sets.on_entry_set_for(i));\n+                try!(chunked_present_left(w, &entry[..], chunk_size));\n+                write!(w, \"= ENTRY:</td><td {bg}><FONT {face}>{entrybits:?}</FONT></td>\\\n+                                        <td></td></tr>\",\n+                       bg = BG_FLOWCONTENT,\n+                       face = FACE_MONOSPACE,\n+                       entrybits=bits_to_string(flow.sets.on_entry_set_for(i),\n+                                                flow.sets.bytes_per_block()))\n+            },\n+            |w| {\n+                let flow = &self.mbcx.flow_state;\n+                let gen = flow.interpret_set( flow.sets.gen_set_for(i));\n+                let kill = flow.interpret_set(flow.sets.kill_set_for(i));\n+                try!(chunked_present_left(w, &gen[..], chunk_size));\n+                try!(write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n+                                            <td></td></tr>\",\n+                            bg = BG_FLOWCONTENT,\n+                            face = FACE_MONOSPACE,\n+                            genbits=bits_to_string( flow.sets.gen_set_for(i),\n+                                                    flow.sets.bytes_per_block())));\n+                try!(write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n+                                             <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n+                            bg = BG_FLOWCONTENT,\n+                            align = ALIGN_RIGHT,\n+                            face = FACE_MONOSPACE,\n+                            killbits=bits_to_string(flow.sets.kill_set_for(i),\n+                                                    flow.sets.bytes_per_block())));\n+\n+                // (chunked_present_right)\n+                let mut seen_one = false;\n+                for k in kill.chunks(chunk_size) {\n+                    if !seen_one {\n+                        // continuation of row; this is fourth <td>\n+                        try!(write!(w, \"<td {bg}>= {kill:?}</td></tr>\",\n+                                    bg = BG_FLOWCONTENT,\n+                                    kill=k));\n+                    } else {\n+                        // new row, with indent of three <td>'s\n+                        try!(write!(w, \"<tr><td></td><td></td><td></td><td {bg}>{kill:?}</td></tr>\",\n+                                    bg = BG_FLOWCONTENT,\n+                                    kill=k));\n+                    }\n+                    seen_one = true;\n+                }\n+                if !seen_one {\n+                    try!(write!(w, \"<td {bg}>= []</td></tr>\",\n+                                bg = BG_FLOWCONTENT));\n+                }\n+\n+                Ok(())\n+            })\n+            .unwrap();\n+        dot::LabelText::html(String::from_utf8(v).unwrap())\n+    }\n+\n+    fn node_shape(&self, _n: &Node) -> Option<dot::LabelText> {\n+        Some(dot::LabelText::label(\"none\"))\n+    }\n+}\n+\n+impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::GraphWalk<'c> for Graph<'c,'b,'a,'tcx> {\n+    type Node = Node;\n+    type Edge = Edge;\n+    fn nodes(&self) -> dot::Nodes<Node> {\n+        self.mbcx.mir.all_basic_blocks().into_cow()\n+    }\n+\n+    fn edges(&self) -> dot::Edges<Edge> {\n+        let mir = self.mbcx.mir;\n+        let blocks = self.mbcx.mir.all_basic_blocks();\n+        // base initial capacity on assumption every block has at\n+        // least one outgoing edge (Which should be true for all\n+        // blocks but one, the exit-block).\n+        let mut edges = Vec::with_capacity(blocks.len());\n+        for bb in blocks {\n+            let outgoing = outgoing(mir, bb);\n+            edges.extend(outgoing.into_iter());\n+        }\n+        edges.into_cow()\n+    }\n+\n+    fn source(&self, edge: &Edge) -> Node {\n+        edge.source\n+    }\n+\n+    fn target(&self, edge: &Edge) -> Node {\n+        let mir = self.mbcx.mir;\n+        mir.basic_block_data(edge.source).terminator().successors()[edge.index]\n+    }\n+}"}, {"sha": "d1335811858b8aa926fbaa99de800f1bb58ccc04", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrowck::BorrowckCtxt;\n+\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+use rustc_front::hir;\n+use rustc_front::intravisit::{FnKind};\n+\n+use rustc::mir::repr::{BasicBlock, BasicBlockData, Mir, Statement, Terminator};\n+\n+mod abs_domain;\n+mod dataflow;\n+mod gather_moves;\n+mod graphviz;\n+\n+use self::dataflow::{Dataflow, DataflowState};\n+use self::gather_moves::{MoveData};\n+\n+pub fn borrowck_mir<'b, 'a: 'b, 'tcx: 'a>(\n+    bcx: &'b mut BorrowckCtxt<'a, 'tcx>,\n+    fk: FnKind,\n+    _decl: &hir::FnDecl,\n+    mir: &'a Mir<'tcx>,\n+    body: &hir::Block,\n+    _sp: Span,\n+    id: ast::NodeId,\n+    attributes: &[ast::Attribute]) {\n+    match fk {\n+        FnKind::ItemFn(name, _, _, _, _, _, _) |\n+        FnKind::Method(name, _, _, _) => {\n+            debug!(\"borrowck_mir({}) UNIMPLEMENTED\", name);\n+        }\n+        FnKind::Closure(_) => {\n+            debug!(\"borrowck_mir closure (body.id={}) UNIMPLEMENTED\", body.id);\n+        }\n+    }\n+\n+    let mut mbcx = MirBorrowckCtxt {\n+        bcx: bcx,\n+        mir: mir,\n+        node_id: id,\n+        attributes: attributes,\n+        flow_state: DataflowState::new_move_analysis(mir, bcx.tcx),\n+    };\n+\n+    for bb in mir.all_basic_blocks() {\n+        mbcx.process_basic_block(bb);\n+    }\n+\n+    mbcx.dataflow();\n+\n+    debug!(\"borrowck_mir done\");\n+}\n+\n+pub struct MirBorrowckCtxt<'b, 'a: 'b, 'tcx: 'a> {\n+    bcx: &'b mut BorrowckCtxt<'a, 'tcx>,\n+    mir: &'b Mir<'tcx>,\n+    node_id: ast::NodeId,\n+    attributes: &'b [ast::Attribute],\n+    flow_state: DataflowState<MoveData<'tcx>>,\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n+    fn process_basic_block(&mut self, bb: BasicBlock) {\n+        let &BasicBlockData { ref statements, ref terminator, is_cleanup: _ } =\n+            self.mir.basic_block_data(bb);\n+        for stmt in statements {\n+            self.process_statement(bb, stmt);\n+        }\n+\n+        self.process_terminator(bb, terminator);\n+    }\n+\n+    fn process_statement(&mut self, bb: BasicBlock, stmt: &Statement<'tcx>) {\n+        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}\", bb, stmt);\n+    }\n+\n+    fn process_terminator(&mut self, bb: BasicBlock, term: &Option<Terminator<'tcx>>) {\n+        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?})\", bb, term);\n+    }\n+}"}, {"sha": "bb2fe7acb9536e4b9287ef9afcac76c75b244f7a", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -40,6 +40,7 @@ use std::fmt;\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n use syntax::errors::DiagnosticBuilder;\n \n@@ -49,12 +50,16 @@ use rustc_front::intravisit;\n use rustc_front::intravisit::{Visitor, FnKind};\n use rustc_front::util as hir_util;\n \n+use rustc::mir::mir_map::MirMap;\n+\n pub mod check_loans;\n \n pub mod gather_loans;\n \n pub mod move_data;\n \n+mod mir;\n+\n #[derive(Clone, Copy)]\n pub struct LoanDataFlowOperator;\n \n@@ -66,15 +71,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n         match fk {\n             FnKind::ItemFn(..) |\n             FnKind::Method(..) => {\n-                let new_free_region_map = self.tcx.free_region_map(id);\n-                let old_free_region_map =\n-                    mem::replace(&mut self.free_region_map, new_free_region_map);\n-                borrowck_fn(self, fk, fd, b, s, id);\n-                self.free_region_map = old_free_region_map;\n+                self.with_temp_region_map(id, |this| {\n+                    borrowck_fn(this, fk, fd, b, s, id, fk.attrs())\n+                });\n             }\n \n             FnKind::Closure(..) => {\n-                borrowck_fn(self, fk, fd, b, s, id);\n+                borrowck_fn(self, fk, fd, b, s, id, fk.attrs());\n             }\n         }\n     }\n@@ -98,9 +101,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n+        mir_map: Some(mir_map),\n         free_region_map: FreeRegionMap::new(),\n         stats: BorrowStats {\n             loaned_paths_same: 0,\n@@ -159,8 +163,17 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                decl: &hir::FnDecl,\n                body: &hir::Block,\n                sp: Span,\n-               id: ast::NodeId) {\n+               id: ast::NodeId,\n+               attributes: &[ast::Attribute]) {\n     debug!(\"borrowck_fn(id={})\", id);\n+\n+    if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n+        let mir = this.mir_map.unwrap().map.get(&id).unwrap();\n+        this.with_temp_region_map(id, |this| {\n+            mir::borrowck_mir(this, fk, decl, mir, body, sp, id, attributes)\n+        });\n+    }\n+\n     let cfg = cfg::CFG::new(this.tcx, body);\n     let AnalysisData { all_loans,\n                        loans: loan_dfcx,\n@@ -233,13 +246,15 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: &'a TyCtxt<'tcx>,\n+    mir_map: Option<&'a MirMap<'tcx>>,\n     fn_parts: FnParts<'a>,\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n+        mir_map: mir_map,\n         free_region_map: FreeRegionMap::new(),\n         stats: BorrowStats {\n             loaned_paths_same: 0,\n@@ -279,9 +294,13 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     free_region_map: FreeRegionMap,\n \n     // Statistics:\n-    stats: BorrowStats\n+    stats: BorrowStats,\n+\n+    // NodeId to MIR mapping (for methods that carry the #[rustc_mir] attribute).\n+    mir_map: Option<&'a MirMap<'tcx>>,\n }\n \n+#[derive(Clone)]\n struct BorrowStats {\n     loaned_paths_same: usize,\n     loaned_paths_imm: usize,\n@@ -574,6 +593,15 @@ pub enum MovedValueUseKind {\n // Misc\n \n impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n+    fn with_temp_region_map<F>(&mut self, id: ast::NodeId, f: F)\n+        where F: for <'b> FnOnce(&'b mut BorrowckCtxt<'a, 'tcx>)\n+    {\n+        let new_free_region_map = self.tcx.free_region_map(id);\n+        let old_free_region_map = mem::replace(&mut self.free_region_map, new_free_region_map);\n+        f(self);\n+        self.free_region_map = old_free_region_map;\n+    }\n+\n     pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n                            -> bool\n     {"}, {"sha": "83c63de218ddcd1d3dcc765a7ca424518da53836", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -23,7 +23,7 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-\n+#![feature(associated_consts)]\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n \n@@ -32,6 +32,7 @@\n extern crate graphviz as dot;\n extern crate rustc;\n extern crate rustc_front;\n+extern crate rustc_mir;\n \n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n@@ -42,6 +43,7 @@ pub use borrowck::{AnalysisData, BorrowckCtxt};\n pub mod diagnostics;\n \n mod borrowck;\n+mod bitslice;\n \n pub mod graphviz;\n "}, {"sha": "c39d0d7587f439f7fbca4c512100f3cd392249b2", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -880,7 +880,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         time(time_passes,\n              \"borrow checking\",\n-             || borrowck::check_crate(tcx));\n+             || borrowck::check_crate(tcx, &mir_map));\n \n         // Avoid overwhelming user with errors if type checking failed.\n         // I'm not sure how helpful this is, to be honest, but it avoids"}, {"sha": "5134278de2183db2ae4ede34d02c4a991bc0dbc6", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -56,6 +56,8 @@ use rustc_front::hir;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_front::print::pprust as pprust_hir;\n \n+use rustc::mir::mir_map::MirMap;\n+\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n     PpmNormal,\n@@ -875,9 +877,10 @@ pub fn pretty_print_input(sess: Session,\n                                                                      &arenas,\n                                                                      &id,\n                                                                      resolve::MakeGlobMap::No,\n-                                                                     |tcx, _, _, _| {\n+                                                                     |tcx, mir_map, _, _| {\n                         print_flowgraph(variants,\n                                         tcx,\n+                                        mir_map.as_ref(),\n                                         code,\n                                         mode,\n                                         out)\n@@ -911,12 +914,13 @@ pub fn pretty_print_input(sess: Session,\n     }\n }\n \n-fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                             tcx: &TyCtxt,\n-                             code: blocks::Code,\n-                             mode: PpFlowGraphMode,\n-                             mut out: W)\n-                             -> io::Result<()> {\n+fn print_flowgraph<'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n+                                   tcx: &TyCtxt<'tcx>,\n+                                   mir_map: Option<&MirMap<'tcx>>,\n+                                   code: blocks::Code,\n+                                   mode: PpFlowGraphMode,\n+                                   mut out: W)\n+                                   -> io::Result<()> {\n     let cfg = match code {\n         blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n         blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),\n@@ -942,6 +946,7 @@ fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n         blocks::FnLikeCode(fn_like) => {\n             let (bccx, analysis_data) =\n                 borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n+                                                              mir_map,\n                                                               fn_like.to_fn_parts(),\n                                                               &cfg);\n "}, {"sha": "bed83708ff8b50d117633ab26bfa2fa71e314f07", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5757e65f7a23d5b946ed8535c966834f95a5e7bb/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=5757e65f7a23d5b946ed8535c966834f95a5e7bb", "patch": "@@ -43,16 +43,33 @@ where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n     Ok(())\n }\n \n-/// Write a graphviz DOT node for the given basic block.\n-fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n+/// Write a graphviz HTML-styled label for the given basic block, with\n+/// all necessary escaping already performed. (This is suitable for\n+/// emitting directly, as is done in this module, or for use with the\n+/// LabelText::HtmlStr from libgraphviz.)\n+///\n+/// `init` and `fini` are callbacks for emitting additional rows of\n+/// data (using HTML enclosed with `<tr>` in the emitted text).\n+pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n+                                              mir: &Mir,\n+                                              w: &mut W,\n+                                              num_cols: u32,\n+                                              init: INIT,\n+                                              fini: FINI) -> io::Result<()>\n+    where INIT: Fn(&mut W) -> io::Result<()>,\n+          FINI: Fn(&mut W) -> io::Result<()>\n+{\n     let data = mir.basic_block_data(block);\n \n-    // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n-    try!(write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(block)));\n     try!(write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#));\n \n     // Basic block number at the top.\n-    try!(write!(w, r#\"<tr><td bgcolor=\"gray\" align=\"center\">{}</td></tr>\"#, block.index()));\n+    try!(write!(w, r#\"<tr><td {attrs} colspan=\"{colspan}\">{blk}</td></tr>\"#,\n+                attrs=r#\"bgcolor=\"gray\" align=\"center\"\"#,\n+                colspan=num_cols,\n+                blk=block.index()));\n+\n+    try!(init(w));\n \n     // List of statements in the middle.\n     if !data.statements.is_empty() {\n@@ -69,8 +86,19 @@ fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<(\n     data.terminator().fmt_head(&mut terminator_head).unwrap();\n     try!(write!(w, r#\"<tr><td align=\"left\">{}</td></tr>\"#, dot::escape_html(&terminator_head)));\n \n-    // Close the table, node label, and the node itself.\n-    writeln!(w, \"</table>>];\")\n+    try!(fini(w));\n+\n+    // Close the table\n+    writeln!(w, \"</table>\")\n+}\n+\n+/// Write a graphviz DOT node for the given basic block.\n+fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n+    // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n+    try!(write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(block)));\n+    try!(write_node_label(block, mir, w, 1, |_| Ok(()), |_| Ok(())));\n+    // Close the node label and the node itself.\n+    writeln!(w, \">];\")\n }\n \n /// Write graphviz DOT edges with labels between the given basic block and all of its successors."}]}