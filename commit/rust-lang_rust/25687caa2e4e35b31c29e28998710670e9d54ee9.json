{"sha": "25687caa2e4e35b31c29e28998710670e9d54ee9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1Njg3Y2FhMmU0ZTM1YjMxYzI5ZTI4OTk4NzEwNjcwZTlkNTRlZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-28T08:26:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-28T08:26:22Z"}, "message": "Auto merge of #73830 - Manishearth:rollup-8k68ysm, r=Manishearth\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #72796 (MIR sanity check: validate types on assignment)\n - #73243 (Add documentation to point to `File::open` or `OpenOptions::open` instead of `is_file` to check read/write possibility)\n - #73525 (Prepare for LLVM 11)\n - #73672 (Adds a clearer message for when the async keyword is missing from a f\u2026)\n - #73708 (Explain move errors that occur due to method calls involving `self` (take two))\n - #73758 (improper_ctypes: fix remaining `Reveal:All`)\n - #73763 (errors: use `-Z terminal-width` in JSON emitter)\n - #73796 (replace more `DefId`s with `LocalDefId`)\n - #73797 (fix typo in self-profile.md)\n - #73809 (Add links to fs::DirEntry::metadata)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "65b2f12402411f111f87e2fd39ec73aae44d6325", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65b2f12402411f111f87e2fd39ec73aae44d6325"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25687caa2e4e35b31c29e28998710670e9d54ee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25687caa2e4e35b31c29e28998710670e9d54ee9", "html_url": "https://github.com/rust-lang/rust/commit/25687caa2e4e35b31c29e28998710670e9d54ee9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25687caa2e4e35b31c29e28998710670e9d54ee9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b4a3d68b5d3026bab9d41fcc004439207ecff90", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4a3d68b5d3026bab9d41fcc004439207ecff90", "html_url": "https://github.com/rust-lang/rust/commit/3b4a3d68b5d3026bab9d41fcc004439207ecff90"}, {"sha": "cdb59d90417b60bc373ab4ea44c768447a7c7994", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb59d90417b60bc373ab4ea44c768447a7c7994", "html_url": "https://github.com/rust-lang/rust/commit/cdb59d90417b60bc373ab4ea44c768447a7c7994"}], "stats": {"total": 2268, "additions": 1645, "deletions": 623}, "files": [{"sha": "7305141a427146ada0c2361245e863ac60fda507", "filename": "src/doc/unstable-book/src/compiler-flags/self-profile.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile.md", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile.md?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -13,7 +13,7 @@ For example:\n First, run a compilation session and provide the `-Zself-profile` flag:\n \n ```console\n-$ rustc --crate-name foo -Zself-profile`\n+$ rustc --crate-name foo -Zself-profile\n ```\n \n This will generate three files in the working directory such as:"}, {"sha": "abf461338d80a95137e6c1e8f2715ccfdd8e27a4", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -27,6 +27,7 @@ use crate::task::{Context, Poll};\n #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n #[lang = \"future_trait\"]\n+#[rustc_on_unimplemented(label = \"`{Self}` is not a future\", message = \"`{Self}` is not a future\")]\n pub trait Future {\n     /// The type of value produced on completion.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]"}, {"sha": "bb7d59e113c08a29fc9c61e26383c668adb577e7", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -24,6 +24,12 @@ fn main() {\n         \"InstrProfilingUtil.c\",\n         \"InstrProfilingValue.c\",\n         \"InstrProfilingWriter.c\",\n+        // This file was renamed in LLVM 10.\n+        \"InstrProfilingRuntime.cc\",\n+        \"InstrProfilingRuntime.cpp\",\n+        // These files were added in LLVM 11.\n+        \"InstrProfilingInternal.c\",\n+        \"InstrProfilingBiasVar.c\",\n     ];\n \n     if target.contains(\"msvc\") {\n@@ -69,14 +75,12 @@ fn main() {\n \n     let src_root = root.join(\"lib\").join(\"profile\");\n     for src in profile_sources {\n-        cfg.file(src_root.join(src));\n+        let path = src_root.join(src);\n+        if path.exists() {\n+            cfg.file(path);\n+        }\n     }\n \n-    // The file was renamed in LLVM 10.\n-    let old_runtime_path = src_root.join(\"InstrProfilingRuntime.cc\");\n-    let new_runtime_path = src_root.join(\"InstrProfilingRuntime.cpp\");\n-    cfg.file(if old_runtime_path.exists() { old_runtime_path } else { new_runtime_path });\n-\n     cfg.include(root.join(\"include\"));\n     cfg.warnings(false);\n     cfg.compile(\"profiler-rt\");"}, {"sha": "90a3a5ec64e0e56ba973720bc30932a8e9ffd267", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n+use rustc_span::source_map::{respan, DesugaringKind, ForLoopLoc, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n@@ -1361,9 +1361,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::Expr<'hir> {\n+        let orig_head_span = head.span;\n         // expand <head>\n         let mut head = self.lower_expr_mut(head);\n-        let desugared_span = self.mark_span_with_reason(DesugaringKind::ForLoop, head.span, None);\n+        let desugared_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::Head),\n+            orig_head_span,\n+            None,\n+        );\n         head.span = desugared_span;\n \n         let iter = Ident::with_dummy_span(sym::iter);\n@@ -1458,10 +1463,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `mut iter => { ... }`\n         let iter_arm = self.arm(iter_pat, loop_expr);\n \n+        let into_iter_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::IntoIter),\n+            orig_head_span,\n+            None,\n+        );\n+\n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n             let into_iter_path = &[sym::iter, sym::IntoIterator, sym::into_iter];\n-            self.expr_call_std_path(desugared_span, into_iter_path, arena_vec![self; head])\n+            self.expr_call_std_path(into_iter_span, into_iter_path, arena_vec![self; head])\n         };\n \n         let match_expr = self.arena.alloc(self.expr_match("}, {"sha": "9764c9a102e8a43fd7541678b9cf4f5b5c1235dd", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -797,6 +797,7 @@ pub unsafe fn optimize_thin_module(\n         kind: ModuleKind::Regular,\n     };\n     {\n+        let target = &*module.module_llvm.tm;\n         let llmod = module.module_llvm.llmod();\n         save_temp_bitcode(&cgcx, &module, \"thin-lto-input\");\n \n@@ -833,7 +834,7 @@ pub unsafe fn optimize_thin_module(\n         {\n             let _timer =\n                 cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_rename\", thin_module.name());\n-            if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod) {\n+            if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod, target) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n             }\n@@ -865,7 +866,7 @@ pub unsafe fn optimize_thin_module(\n         {\n             let _timer =\n                 cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_import\", thin_module.name());\n-            if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod) {\n+            if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod, target) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n             }"}, {"sha": "7beb4fc897472a6a79db7a12127a458abf7ff32a", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -233,6 +233,8 @@ pub enum TypeKind {\n     Metadata = 14,\n     X86_MMX = 15,\n     Token = 16,\n+    ScalableVector = 17,\n+    BFloat = 18,\n }\n \n impl TypeKind {\n@@ -255,6 +257,8 @@ impl TypeKind {\n             TypeKind::Metadata => rustc_codegen_ssa::common::TypeKind::Metadata,\n             TypeKind::X86_MMX => rustc_codegen_ssa::common::TypeKind::X86_MMX,\n             TypeKind::Token => rustc_codegen_ssa::common::TypeKind::Token,\n+            TypeKind::ScalableVector => rustc_codegen_ssa::common::TypeKind::ScalableVector,\n+            TypeKind::BFloat => rustc_codegen_ssa::common::TypeKind::BFloat,\n         }\n     }\n }\n@@ -2141,10 +2145,18 @@ extern \"C\" {\n         PreservedSymbols: *const *const c_char,\n         PreservedSymbolsLen: c_uint,\n     ) -> Option<&'static mut ThinLTOData>;\n-    pub fn LLVMRustPrepareThinLTORename(Data: &ThinLTOData, Module: &Module) -> bool;\n+    pub fn LLVMRustPrepareThinLTORename(\n+        Data: &ThinLTOData,\n+        Module: &Module,\n+        Target: &TargetMachine,\n+    ) -> bool;\n     pub fn LLVMRustPrepareThinLTOResolveWeak(Data: &ThinLTOData, Module: &Module) -> bool;\n     pub fn LLVMRustPrepareThinLTOInternalize(Data: &ThinLTOData, Module: &Module) -> bool;\n-    pub fn LLVMRustPrepareThinLTOImport(Data: &ThinLTOData, Module: &Module) -> bool;\n+    pub fn LLVMRustPrepareThinLTOImport(\n+        Data: &ThinLTOData,\n+        Module: &Module,\n+        Target: &TargetMachine,\n+    ) -> bool;\n     pub fn LLVMRustGetThinLTOModuleImports(\n         Data: *const ThinLTOData,\n         ModuleNameCallback: ThinLTOModuleNameCallback,"}, {"sha": "432b2f3bdc3c174987221d051dde6c616d2f8be3", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -98,6 +98,8 @@ pub enum TypeKind {\n     Metadata,\n     X86_MMX,\n     Token,\n+    ScalableVector,\n+    BFloat,\n }\n \n // FIXME(mw): Anything that is produced via DepGraph::with_task() must implement"}, {"sha": "24186198fd2b15b11c1d8ccd7e9b04b8347a6ebb", "filename": "src/librustc_errors/json.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_errors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_errors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fjson.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -36,6 +36,7 @@ pub struct JsonEmitter {\n     pretty: bool,\n     ui_testing: bool,\n     json_rendered: HumanReadableErrorType,\n+    terminal_width: Option<usize>,\n     macro_backtrace: bool,\n }\n \n@@ -45,6 +46,7 @@ impl JsonEmitter {\n         source_map: Lrc<SourceMap>,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n+        terminal_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n@@ -54,13 +56,15 @@ impl JsonEmitter {\n             pretty,\n             ui_testing: false,\n             json_rendered,\n+            terminal_width,\n             macro_backtrace,\n         }\n     }\n \n     pub fn basic(\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n+        terminal_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n@@ -69,6 +73,7 @@ impl JsonEmitter {\n             Lrc::new(SourceMap::new(file_path_mapping)),\n             pretty,\n             json_rendered,\n+            terminal_width,\n             macro_backtrace,\n         )\n     }\n@@ -79,6 +84,7 @@ impl JsonEmitter {\n         source_map: Lrc<SourceMap>,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n+        terminal_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n@@ -88,6 +94,7 @@ impl JsonEmitter {\n             pretty,\n             ui_testing: false,\n             json_rendered,\n+            terminal_width,\n             macro_backtrace,\n         }\n     }\n@@ -247,7 +254,13 @@ impl Diagnostic {\n         let buf = BufWriter::default();\n         let output = buf.clone();\n         je.json_rendered\n-            .new_emitter(Box::new(buf), Some(je.sm.clone()), false, None, je.macro_backtrace)\n+            .new_emitter(\n+                Box::new(buf),\n+                Some(je.sm.clone()),\n+                false,\n+                je.terminal_width,\n+                je.macro_backtrace,\n+            )\n             .ui_testing(je.ui_testing)\n             .emit_diagnostic(diag);\n         let output = Arc::try_unwrap(output.0).unwrap().into_inner().unwrap();"}, {"sha": "5aaf219b315bdc22b69dca21de23531cc104c681", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 55, "deletions": 25, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -21,11 +21,26 @@ use rustc_span::Span;\n \n use lazy_static::lazy_static;\n \n+pub enum LangItemGroup {\n+    Op,\n+}\n+\n+const NUM_GROUPS: usize = 1;\n+\n+macro_rules! expand_group {\n+    () => {\n+        None\n+    };\n+    ($group:expr) => {\n+        Some($group)\n+    };\n+}\n+\n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end.\n macro_rules! language_item_table {\n     (\n-        $( $variant:ident, $name:expr, $method:ident, $target:expr; )*\n+        $( $variant:ident $($group:expr)?, $name:expr, $method:ident, $target:expr; )*\n     ) => {\n \n         enum_from_u32! {\n@@ -45,6 +60,13 @@ macro_rules! language_item_table {\n                     $( $variant => $name, )*\n                 }\n             }\n+\n+            pub fn group(self) -> Option<LangItemGroup> {\n+                use LangItemGroup::*;\n+                match self {\n+                    $( $variant => expand_group!($($group)*), )*\n+                }\n+            }\n         }\n \n         #[derive(HashStable_Generic)]\n@@ -54,6 +76,9 @@ macro_rules! language_item_table {\n             pub items: Vec<Option<DefId>>,\n             /// Lang items that were not found during collection.\n             pub missing: Vec<LangItem>,\n+            /// Mapping from `LangItemGroup` discriminants to all\n+            /// `DefId`s of lang items in that group.\n+            pub groups: [Vec<DefId>; NUM_GROUPS],\n         }\n \n         impl LanguageItems {\n@@ -64,6 +89,7 @@ macro_rules! language_item_table {\n                 Self {\n                     items: vec![$(init_none($variant)),*],\n                     missing: Vec::new(),\n+                    groups: [vec![]; NUM_GROUPS],\n                 }\n             }\n \n@@ -79,6 +105,10 @@ macro_rules! language_item_table {\n                 self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n             }\n \n+            pub fn group(&self, group: LangItemGroup) -> &[DefId] {\n+                self.groups[group as usize].as_ref()\n+            }\n+\n             $(\n                 /// Returns the corresponding `DefId` for the lang item\n                 #[doc = $name]\n@@ -171,30 +201,30 @@ language_item_table! {\n     CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n     DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n \n-    AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n-    SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;\n-    MulTraitLangItem,            \"mul\",                mul_trait,               Target::Trait;\n-    DivTraitLangItem,            \"div\",                div_trait,               Target::Trait;\n-    RemTraitLangItem,            \"rem\",                rem_trait,               Target::Trait;\n-    NegTraitLangItem,            \"neg\",                neg_trait,               Target::Trait;\n-    NotTraitLangItem,            \"not\",                not_trait,               Target::Trait;\n-    BitXorTraitLangItem,         \"bitxor\",             bitxor_trait,            Target::Trait;\n-    BitAndTraitLangItem,         \"bitand\",             bitand_trait,            Target::Trait;\n-    BitOrTraitLangItem,          \"bitor\",              bitor_trait,             Target::Trait;\n-    ShlTraitLangItem,            \"shl\",                shl_trait,               Target::Trait;\n-    ShrTraitLangItem,            \"shr\",                shr_trait,               Target::Trait;\n-    AddAssignTraitLangItem,      \"add_assign\",         add_assign_trait,        Target::Trait;\n-    SubAssignTraitLangItem,      \"sub_assign\",         sub_assign_trait,        Target::Trait;\n-    MulAssignTraitLangItem,      \"mul_assign\",         mul_assign_trait,        Target::Trait;\n-    DivAssignTraitLangItem,      \"div_assign\",         div_assign_trait,        Target::Trait;\n-    RemAssignTraitLangItem,      \"rem_assign\",         rem_assign_trait,        Target::Trait;\n-    BitXorAssignTraitLangItem,   \"bitxor_assign\",      bitxor_assign_trait,     Target::Trait;\n-    BitAndAssignTraitLangItem,   \"bitand_assign\",      bitand_assign_trait,     Target::Trait;\n-    BitOrAssignTraitLangItem,    \"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n-    ShlAssignTraitLangItem,      \"shl_assign\",         shl_assign_trait,        Target::Trait;\n-    ShrAssignTraitLangItem,      \"shr_assign\",         shr_assign_trait,        Target::Trait;\n-    IndexTraitLangItem,          \"index\",              index_trait,             Target::Trait;\n-    IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n+    AddTraitLangItem(Op),        \"add\",                add_trait,               Target::Trait;\n+    SubTraitLangItem(Op),        \"sub\",                sub_trait,               Target::Trait;\n+    MulTraitLangItem(Op),        \"mul\",                mul_trait,               Target::Trait;\n+    DivTraitLangItem(Op),        \"div\",                div_trait,               Target::Trait;\n+    RemTraitLangItem(Op),        \"rem\",                rem_trait,               Target::Trait;\n+    NegTraitLangItem(Op),        \"neg\",                neg_trait,               Target::Trait;\n+    NotTraitLangItem(Op),        \"not\",                not_trait,               Target::Trait;\n+    BitXorTraitLangItem(Op),     \"bitxor\",             bitxor_trait,            Target::Trait;\n+    BitAndTraitLangItem(Op),     \"bitand\",             bitand_trait,            Target::Trait;\n+    BitOrTraitLangItem(Op),      \"bitor\",              bitor_trait,             Target::Trait;\n+    ShlTraitLangItem(Op),        \"shl\",                shl_trait,               Target::Trait;\n+    ShrTraitLangItem(Op),        \"shr\",                shr_trait,               Target::Trait;\n+    AddAssignTraitLangItem(Op),  \"add_assign\",         add_assign_trait,        Target::Trait;\n+    SubAssignTraitLangItem(Op),  \"sub_assign\",         sub_assign_trait,        Target::Trait;\n+    MulAssignTraitLangItem(Op),  \"mul_assign\",         mul_assign_trait,        Target::Trait;\n+    DivAssignTraitLangItem(Op),  \"div_assign\",         div_assign_trait,        Target::Trait;\n+    RemAssignTraitLangItem(Op),  \"rem_assign\",         rem_assign_trait,        Target::Trait;\n+    BitXorAssignTraitLangItem(Op),\"bitxor_assign\",     bitxor_assign_trait,     Target::Trait;\n+    BitAndAssignTraitLangItem(Op),\"bitand_assign\",     bitand_assign_trait,     Target::Trait;\n+    BitOrAssignTraitLangItem(Op),\"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n+    ShlAssignTraitLangItem(Op),  \"shl_assign\",         shl_assign_trait,        Target::Trait;\n+    ShrAssignTraitLangItem(Op),  \"shr_assign\",         shr_assign_trait,        Target::Trait;\n+    IndexTraitLangItem(Op),      \"index\",              index_trait,             Target::Trait;\n+    IndexMutTraitLangItem(Op),   \"index_mut\",          index_mut_trait,         Target::Trait;\n \n     UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n     VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;"}, {"sha": "1687bcc1556367900976f3ce64074720feceabba", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -468,7 +468,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n                     None => format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    Some(DesugaringKind::ForLoop) => {\n+                    Some(DesugaringKind::ForLoop(_)) => {\n                         \"the element type for this iterator is not specified\".to_string()\n                     }\n                     _ => format!(\"this needs {}\", suffix),"}, {"sha": "20617bb8bd8fc2aa84cfffef9be05b2960e0c3d3", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -28,30 +28,27 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         br: &ty::BoundRegion,\n     ) -> Option<(&hir::Ty<'tcx>, &hir::FnDecl<'tcx>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n-            let def_id = anon_reg.def_id;\n-            if let Some(def_id) = def_id.as_local() {\n-                let hir_id = self.tcx().hir().as_local_hir_id(def_id);\n-                let fndecl = match self.tcx().hir().get(hir_id) {\n-                    Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n-                    | Node::TraitItem(&hir::TraitItem {\n-                        kind: hir::TraitItemKind::Fn(ref m, ..),\n-                        ..\n-                    })\n-                    | Node::ImplItem(&hir::ImplItem {\n-                        kind: hir::ImplItemKind::Fn(ref m, ..),\n-                        ..\n-                    }) => &m.decl,\n-                    _ => return None,\n-                };\n+            let hir_id = self.tcx().hir().as_local_hir_id(anon_reg.def_id);\n+            let fndecl = match self.tcx().hir().get(hir_id) {\n+                Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n+                | Node::TraitItem(&hir::TraitItem {\n+                    kind: hir::TraitItemKind::Fn(ref m, ..),\n+                    ..\n+                })\n+                | Node::ImplItem(&hir::ImplItem {\n+                    kind: hir::ImplItemKind::Fn(ref m, ..), ..\n+                }) => &m.decl,\n+                _ => return None,\n+            };\n \n-                return fndecl\n-                    .inputs\n-                    .iter()\n-                    .find_map(|arg| self.find_component_for_bound_region(arg, br))\n-                    .map(|ty| (ty, &**fndecl));\n-            }\n+            fndecl\n+                .inputs\n+                .iter()\n+                .find_map(|arg| self.find_component_for_bound_region(arg, br))\n+                .map(|ty| (ty, &**fndecl))\n+        } else {\n+            None\n         }\n-        None\n     }\n \n     // This method creates a FindNestedTypeVisitor which returns the type corresponding"}, {"sha": "72deba990b0b5e5dc5dc6a629cfcede63cce94ab", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -75,8 +75,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n \n         if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n-            let is_self_anon = self.is_self_anon(is_first, scope_def_id);\n-            if is_self_anon {\n+            if self.is_self_anon(is_first, scope_def_id) {\n                 return None;\n             }\n "}, {"sha": "b6e971feb0e5fdc4043f45411baa2264ea13cc19", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 196, "deletions": 198, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -10,219 +10,217 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         debug!(\"try_report_static_impl_trait(error={:?})\", self.error);\n-        if let Some(ref error) = self.error {\n-            if let RegionResolutionError::SubSupConflict(\n-                _,\n-                var_origin,\n-                sub_origin,\n-                sub_r,\n-                sup_origin,\n-                sup_r,\n-            ) = error\n-            {\n-                debug!(\n-                    \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n-                    var_origin, sub_origin, sub_r, sup_origin, sup_r\n+        if let Some(RegionResolutionError::SubSupConflict(\n+            _,\n+            var_origin,\n+            ref sub_origin,\n+            sub_r,\n+            ref sup_origin,\n+            sup_r,\n+        )) = self.error\n+        {\n+            debug!(\n+                \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n+                var_origin, sub_origin, sub_r, sup_origin, sup_r\n+            );\n+            let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n+            debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n+            let fn_returns = self.tcx().return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n+            if fn_returns.is_empty() {\n+                return None;\n+            }\n+            debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n+            if *sub_r == RegionKind::ReStatic {\n+                let sp = var_origin.span();\n+                let return_sp = sub_origin.span();\n+                let param_info = self.find_param_with_region(sup_r, sub_r)?;\n+                let (lifetime_name, lifetime) = if sup_r.has_name() {\n+                    (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n+                } else {\n+                    (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n+                };\n+                let mut err = struct_span_err!(\n+                    self.tcx().sess,\n+                    sp,\n+                    E0759,\n+                    \"cannot infer an appropriate lifetime\"\n                 );\n-                let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-                debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n-                let fn_returns = self.tcx().return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n-                if fn_returns.is_empty() {\n-                    return None;\n-                }\n-                debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n-                if **sub_r == RegionKind::ReStatic {\n-                    let sp = var_origin.span();\n-                    let return_sp = sub_origin.span();\n-                    let param_info = self.find_param_with_region(sup_r, sub_r)?;\n-                    let (lifetime_name, lifetime) = if sup_r.has_name() {\n-                        (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n+                err.span_label(\n+                    param_info.param_ty_span,\n+                    &format!(\"this data with {}...\", lifetime),\n+                );\n+                debug!(\"try_report_static_impl_trait: param_info={:?}\", param_info);\n+\n+                // We try to make the output have fewer overlapping spans if possible.\n+                if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n+                    && sup_origin.span() != return_sp\n+                {\n+                    // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+\n+                    // Customize the spans and labels depending on their relative order so\n+                    // that split sentences flow correctly.\n+                    if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n+                        // Avoid the following:\n+                        //\n+                        // error: cannot infer an appropriate lifetime\n+                        //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                        //    |\n+                        // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                        //    |           ----                      ---------^-\n+                        //\n+                        // and instead show:\n+                        //\n+                        // error: cannot infer an appropriate lifetime\n+                        //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                        //    |\n+                        // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                        //    |           ----                               ^\n+                        err.span_label(\n+                            sup_origin.span(),\n+                            \"...is captured here, requiring it to live as long as `'static`\",\n+                        );\n                     } else {\n-                        (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n-                    };\n-                    let mut err = struct_span_err!(\n-                        self.tcx().sess,\n-                        sp,\n-                        E0759,\n-                        \"cannot infer an appropriate lifetime\"\n-                    );\n+                        err.span_label(sup_origin.span(), \"...is captured here...\");\n+                        if return_sp < sup_origin.span() {\n+                            err.span_note(\n+                                return_sp,\n+                                \"...and is required to live as long as `'static` here\",\n+                            );\n+                        } else {\n+                            err.span_label(\n+                                return_sp,\n+                                \"...and is required to live as long as `'static` here\",\n+                            );\n+                        }\n+                    }\n+                } else {\n                     err.span_label(\n-                        param_info.param_ty_span,\n-                        &format!(\"this data with {}...\", lifetime),\n+                        return_sp,\n+                        \"...is captured and required to live as long as `'static` here\",\n                     );\n-                    debug!(\"try_report_static_impl_trait: param_info={:?}\", param_info);\n+                }\n \n-                    // We try to make the output have fewer overlapping spans if possible.\n-                    if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n-                        && sup_origin.span() != return_sp\n-                    {\n-                        // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+                // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+                let consider = \"consider changing the\";\n+                let declare = \"to declare that the\";\n+                let arg = match param_info.param.pat.simple_ident() {\n+                    Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                    None => \"the argument\".to_string(),\n+                };\n+                let explicit =\n+                    format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n+                let explicit_static =\n+                    format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n+                let captures = format!(\"captures data from {}\", arg);\n+                let add_static_bound =\n+                    \"alternatively, add an explicit `'static` bound to this reference\";\n+                let plus_lt = format!(\" + {}\", lifetime_name);\n+                for fn_return in fn_returns {\n+                    if fn_return.span.desugaring_kind().is_some() {\n+                        // Skip `async` desugaring `impl Future`.\n+                        continue;\n+                    }\n+                    match fn_return.kind {\n+                        TyKind::OpaqueDef(item_id, _) => {\n+                            let item = self.tcx().hir().item(item_id.id);\n+                            let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n+                                opaque\n+                            } else {\n+                                err.emit();\n+                                return Some(ErrorReported);\n+                            };\n \n-                        // Customize the spans and labels depending on their relative order so\n-                        // that split sentences flow correctly.\n-                        if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n-                            // Avoid the following:\n-                            //\n-                            // error: cannot infer an appropriate lifetime\n-                            //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n-                            //    |\n-                            // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-                            //    |           ----                      ---------^-\n-                            //\n-                            // and instead show:\n-                            //\n-                            // error: cannot infer an appropriate lifetime\n-                            //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n-                            //    |\n-                            // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-                            //    |           ----                               ^\n-                            err.span_label(\n-                                sup_origin.span(),\n-                                \"...is captured here, requiring it to live as long as `'static`\",\n-                            );\n-                        } else {\n-                            err.span_label(sup_origin.span(), \"...is captured here...\");\n-                            if return_sp < sup_origin.span() {\n-                                err.span_note(\n-                                    return_sp,\n-                                    \"...and is required to live as long as `'static` here\",\n+                            if let Some(span) = opaque\n+                                .bounds\n+                                .iter()\n+                                .filter_map(|arg| match arg {\n+                                    GenericBound::Outlives(Lifetime {\n+                                        name: LifetimeName::Static,\n+                                        span,\n+                                        ..\n+                                    }) => Some(*span),\n+                                    _ => None,\n+                                })\n+                                .next()\n+                            {\n+                                err.span_suggestion_verbose(\n+                                    span,\n+                                    &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n+                                    lifetime_name.clone(),\n+                                    Applicability::MaybeIncorrect,\n                                 );\n+                                err.span_suggestion_verbose(\n+                                    param_info.param_ty_span,\n+                                    add_static_bound,\n+                                    param_info.param_ty.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else if let Some(_) = opaque\n+                                .bounds\n+                                .iter()\n+                                .filter_map(|arg| match arg {\n+                                    GenericBound::Outlives(Lifetime { name, span, .. })\n+                                        if name.ident().to_string() == lifetime_name =>\n+                                    {\n+                                        Some(*span)\n+                                    }\n+                                    _ => None,\n+                                })\n+                                .next()\n+                            {\n                             } else {\n-                                err.span_label(\n-                                    return_sp,\n-                                    \"...and is required to live as long as `'static` here\",\n+                                err.span_suggestion_verbose(\n+                                    fn_return.span.shrink_to_hi(),\n+                                    &format!(\n+                                        \"{declare} `impl Trait` {captures}, {explicit}\",\n+                                        declare = declare,\n+                                        captures = captures,\n+                                        explicit = explicit,\n+                                    ),\n+                                    plus_lt.clone(),\n+                                    Applicability::MaybeIncorrect,\n                                 );\n                             }\n                         }\n-                    } else {\n-                        err.span_label(\n-                            return_sp,\n-                            \"...is captured and required to live as long as `'static` here\",\n-                        );\n-                    }\n-\n-                    // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-                    let consider = \"consider changing the\";\n-                    let declare = \"to declare that the\";\n-                    let arg = match param_info.param.pat.simple_ident() {\n-                        Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n-                        None => \"the argument\".to_string(),\n-                    };\n-                    let explicit =\n-                        format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n-                    let explicit_static =\n-                        format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n-                    let captures = format!(\"captures data from {}\", arg);\n-                    let add_static_bound =\n-                        \"alternatively, add an explicit `'static` bound to this reference\";\n-                    let plus_lt = format!(\" + {}\", lifetime_name);\n-                    for fn_return in fn_returns {\n-                        if fn_return.span.desugaring_kind().is_some() {\n-                            // Skip `async` desugaring `impl Future`.\n-                            continue;\n-                        }\n-                        match fn_return.kind {\n-                            TyKind::OpaqueDef(item_id, _) => {\n-                                let item = self.tcx().hir().item(item_id.id);\n-                                let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n-                                    opaque\n-                                } else {\n-                                    err.emit();\n-                                    return Some(ErrorReported);\n-                                };\n-\n-                                if let Some(span) = opaque\n-                                    .bounds\n-                                    .iter()\n-                                    .filter_map(|arg| match arg {\n-                                        GenericBound::Outlives(Lifetime {\n-                                            name: LifetimeName::Static,\n-                                            span,\n-                                            ..\n-                                        }) => Some(*span),\n-                                        _ => None,\n-                                    })\n-                                    .next()\n-                                {\n-                                    err.span_suggestion_verbose(\n-                                        span,\n-                                        &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n-                                        lifetime_name.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                    err.span_suggestion_verbose(\n-                                        param_info.param_ty_span,\n-                                        add_static_bound,\n-                                        param_info.param_ty.to_string(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                } else if let Some(_) = opaque\n-                                    .bounds\n-                                    .iter()\n-                                    .filter_map(|arg| match arg {\n-                                        GenericBound::Outlives(Lifetime { name, span, .. })\n-                                            if name.ident().to_string() == lifetime_name =>\n-                                        {\n-                                            Some(*span)\n-                                        }\n-                                        _ => None,\n-                                    })\n-                                    .next()\n-                                {\n-                                } else {\n-                                    err.span_suggestion_verbose(\n-                                        fn_return.span.shrink_to_hi(),\n-                                        &format!(\n-                                            \"{declare} `impl Trait` {captures}, {explicit}\",\n-                                            declare = declare,\n-                                            captures = captures,\n-                                            explicit = explicit,\n-                                        ),\n-                                        plus_lt.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n+                        TyKind::TraitObject(_, lt) => match lt.name {\n+                            LifetimeName::ImplicitObjectLifetimeDefault => {\n+                                err.span_suggestion_verbose(\n+                                    fn_return.span.shrink_to_hi(),\n+                                    &format!(\n+                                        \"{declare} trait object {captures}, {explicit}\",\n+                                        declare = declare,\n+                                        captures = captures,\n+                                        explicit = explicit,\n+                                    ),\n+                                    plus_lt.clone(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            name if name.ident().to_string() != lifetime_name => {\n+                                // With this check we avoid suggesting redundant bounds. This\n+                                // would happen if there are nested impl/dyn traits and only\n+                                // one of them has the bound we'd suggest already there, like\n+                                // in `impl Foo<X = dyn Bar> + '_`.\n+                                err.span_suggestion_verbose(\n+                                    lt.span,\n+                                    &format!(\"{} trait object's {}\", consider, explicit_static),\n+                                    lifetime_name.clone(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                err.span_suggestion_verbose(\n+                                    param_info.param_ty_span,\n+                                    add_static_bound,\n+                                    param_info.param_ty.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n                             }\n-                            TyKind::TraitObject(_, lt) => match lt.name {\n-                                LifetimeName::ImplicitObjectLifetimeDefault => {\n-                                    err.span_suggestion_verbose(\n-                                        fn_return.span.shrink_to_hi(),\n-                                        &format!(\n-                                            \"{declare} trait object {captures}, {explicit}\",\n-                                            declare = declare,\n-                                            captures = captures,\n-                                            explicit = explicit,\n-                                        ),\n-                                        plus_lt.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                                name if name.ident().to_string() != lifetime_name => {\n-                                    // With this check we avoid suggesting redundant bounds. This\n-                                    // would happen if there are nested impl/dyn traits and only\n-                                    // one of them has the bound we'd suggest already there, like\n-                                    // in `impl Foo<X = dyn Bar> + '_`.\n-                                    err.span_suggestion_verbose(\n-                                        lt.span,\n-                                        &format!(\"{} trait object's {}\", consider, explicit_static),\n-                                        lifetime_name.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                    err.span_suggestion_verbose(\n-                                        param_info.param_ty_span,\n-                                        add_static_bound,\n-                                        param_info.param_ty.to_string(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                                _ => {}\n-                            },\n                             _ => {}\n-                        }\n+                        },\n+                        _ => {}\n                     }\n-                    err.emit();\n-                    return Some(ErrorReported);\n                 }\n+                err.emit();\n+                return Some(ErrorReported);\n             }\n         }\n         None"}, {"sha": "fa999abb1a86c46b672c88b81b49d1efc36f5fea", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -3,7 +3,7 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::{self, DefIdTree, Region, Ty};\n use rustc_span::Span;\n \n@@ -92,7 +92,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     // FIXME(#42703) - Need to handle certain cases here.\n     pub(super) fn is_return_type_anon(\n         &self,\n-        scope_def_id: DefId,\n+        scope_def_id: LocalDefId,\n         br: ty::BoundRegion,\n         decl: &hir::FnDecl<'_>,\n     ) -> Option<Span> {\n@@ -112,9 +112,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     // corresponds to self and if yes, we display E0312.\n     // FIXME(#42700) - Need to format self properly to\n     // enable E0621 for it.\n-    pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n+    pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: LocalDefId) -> bool {\n         is_first\n-            && self.tcx().opt_associated_item(scope_def_id).map(|i| i.fn_has_self_parameter)\n+            && self\n+                .tcx()\n+                .opt_associated_item(scope_def_id.to_def_id())\n+                .map(|i| i.fn_has_self_parameter)\n                 == Some(true)\n     }\n }"}, {"sha": "d0275a0dd0dcbf72d451822f4e6f2d09bf3ea117", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 66, "deletions": 62, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -11,7 +11,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{sign_extend, truncate};\n use rustc_middle::ty::layout::{IntegerExt, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, AdtKind, Ty, TypeFoldable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n@@ -525,78 +525,82 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n-fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind {\n-        ty::FnPtr(_) => true,\n-        ty::Ref(..) => true,\n-        ty::Adt(field_def, substs) if field_def.repr.transparent() && !field_def.is_union() => {\n-            for field in field_def.all_fields() {\n-                let field_ty =\n-                    tcx.normalize_erasing_regions(ParamEnv::reveal_all(), field.ty(tcx, substs));\n-                if field_ty.is_zst(tcx, field.did) {\n-                    continue;\n-                }\n+impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n+    /// Is type known to be non-null?\n+    fn ty_is_known_nonnull(&self, ty: Ty<'tcx>) -> bool {\n+        match ty.kind {\n+            ty::FnPtr(_) => true,\n+            ty::Ref(..) => true,\n+            ty::Adt(field_def, substs) if field_def.repr.transparent() && !field_def.is_union() => {\n+                for field in field_def.all_fields() {\n+                    let field_ty = self.cx.tcx.normalize_erasing_regions(\n+                        self.cx.param_env,\n+                        field.ty(self.cx.tcx, substs),\n+                    );\n+                    if field_ty.is_zst(self.cx.tcx, field.did) {\n+                        continue;\n+                    }\n \n-                let attrs = tcx.get_attrs(field_def.did);\n-                if attrs.iter().any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed))\n-                    || ty_is_known_nonnull(tcx, field_ty)\n-                {\n-                    return true;\n+                    let attrs = self.cx.tcx.get_attrs(field_def.did);\n+                    if attrs\n+                        .iter()\n+                        .any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed))\n+                        || self.ty_is_known_nonnull(field_ty)\n+                    {\n+                        return true;\n+                    }\n                 }\n-            }\n \n-            false\n+                false\n+            }\n+            _ => false,\n         }\n-        _ => false,\n     }\n-}\n \n-/// Check if this enum can be safely exported based on the\n-/// \"nullable pointer optimization\". Currently restricted\n-/// to function pointers, references, core::num::NonZero*,\n-/// core::ptr::NonNull, and #[repr(transparent)] newtypes.\n-/// FIXME: This duplicates code in codegen.\n-fn is_repr_nullable_ptr<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-    ty_def: &'tcx ty::AdtDef,\n-    substs: SubstsRef<'tcx>,\n-) -> bool {\n-    if ty_def.variants.len() != 2 {\n-        return false;\n-    }\n+    /// Check if this enum can be safely exported based on the \"nullable pointer optimization\".\n+    /// Currently restricted to function pointers, references, `core::num::NonZero*`,\n+    /// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n+    fn is_repr_nullable_ptr(\n+        &self,\n+        ty: Ty<'tcx>,\n+        ty_def: &'tcx ty::AdtDef,\n+        substs: SubstsRef<'tcx>,\n+    ) -> bool {\n+        if ty_def.variants.len() != 2 {\n+            return false;\n+        }\n \n-    let get_variant_fields = |index| &ty_def.variants[VariantIdx::new(index)].fields;\n-    let variant_fields = [get_variant_fields(0), get_variant_fields(1)];\n-    let fields = if variant_fields[0].is_empty() {\n-        &variant_fields[1]\n-    } else if variant_fields[1].is_empty() {\n-        &variant_fields[0]\n-    } else {\n-        return false;\n-    };\n+        let get_variant_fields = |index| &ty_def.variants[VariantIdx::new(index)].fields;\n+        let variant_fields = [get_variant_fields(0), get_variant_fields(1)];\n+        let fields = if variant_fields[0].is_empty() {\n+            &variant_fields[1]\n+        } else if variant_fields[1].is_empty() {\n+            &variant_fields[0]\n+        } else {\n+            return false;\n+        };\n \n-    if fields.len() != 1 {\n-        return false;\n-    }\n+        if fields.len() != 1 {\n+            return false;\n+        }\n \n-    let field_ty = fields[0].ty(tcx, substs);\n-    if !ty_is_known_nonnull(tcx, field_ty) {\n-        return false;\n-    }\n+        let field_ty = fields[0].ty(self.cx.tcx, substs);\n+        if !self.ty_is_known_nonnull(field_ty) {\n+            return false;\n+        }\n \n-    // At this point, the field's type is known to be nonnull and the parent enum is Option-like.\n-    // If the computed size for the field and the enum are different, the nonnull optimization isn't\n-    // being applied (and we've got a problem somewhere).\n-    let compute_size_skeleton = |t| SizeSkeleton::compute(t, tcx, ParamEnv::reveal_all()).unwrap();\n-    if !compute_size_skeleton(ty).same_size(compute_size_skeleton(field_ty)) {\n-        bug!(\"improper_ctypes: Option nonnull optimization not applied?\");\n-    }\n+        // At this point, the field's type is known to be nonnull and the parent enum is\n+        // Option-like. If the computed size for the field and the enum are different, the non-null\n+        // optimization isn't being applied (and we've got a problem somewhere).\n+        let compute_size_skeleton =\n+            |t| SizeSkeleton::compute(t, self.cx.tcx, self.cx.param_env).unwrap();\n+        if !compute_size_skeleton(ty).same_size(compute_size_skeleton(field_ty)) {\n+            bug!(\"improper_ctypes: Option nonnull optimization not applied?\");\n+        }\n \n-    true\n-}\n+        true\n+    }\n \n-impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the type is array and emit an unsafe type lint.\n     fn check_for_array_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n         if let ty::Array(..) = ty.kind {\n@@ -738,7 +742,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // discriminant.\n                         if !def.repr.c() && !def.repr.transparent() && def.repr.int.is_none() {\n                             // Special-case types like `Option<extern fn()>`.\n-                            if !is_repr_nullable_ptr(cx, ty, def, substs) {\n+                            if !self.is_repr_nullable_ptr(ty, def, substs) {\n                                 return FfiUnsafe {\n                                     ty,\n                                     reason: \"enum has no representation hint\".into(),"}, {"sha": "2254d553337d5fed65d94daa7b19b3d40311af0f", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -1339,13 +1339,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_fn_param_names(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Symbol] {\n+    fn get_fn_param_names(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Ident] {\n         let param_names = match self.kind(id) {\n             EntryKind::Fn(data) | EntryKind::ForeignFn(data) => data.decode(self).param_names,\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.param_names,\n             _ => Lazy::empty(),\n         };\n-        tcx.arena.alloc_from_iter(param_names.decode(self))\n+        tcx.arena.alloc_from_iter(param_names.decode((self, tcx)))\n     }\n \n     fn exported_symbols("}, {"sha": "d01c767e2bc044219b9c74695c9370e69c90e33c", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder, UseSpecializedEncodable};\n use rustc_session::config::CrateType;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n use rustc_target::abi::VariantIdx;\n use std::hash::Hash;\n@@ -1004,18 +1004,12 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId) -> Lazy<[Symbol]> {\n-        self.tcx.dep_graph.with_ignore(|| {\n-            let body = self.tcx.hir().body(body_id);\n-            self.lazy(body.params.iter().map(|arg| match arg.pat.kind {\n-                hir::PatKind::Binding(_, _, ident, _) => ident.name,\n-                _ => kw::Invalid,\n-            }))\n-        })\n+    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId) -> Lazy<[Ident]> {\n+        self.tcx.dep_graph.with_ignore(|| self.lazy(self.tcx.hir().body_param_names(body_id)))\n     }\n \n-    fn encode_fn_param_names(&mut self, param_names: &[Ident]) -> Lazy<[Symbol]> {\n-        self.lazy(param_names.iter().map(|ident| ident.name))\n+    fn encode_fn_param_names(&mut self, param_names: &[Ident]) -> Lazy<[Ident]> {\n+        self.lazy(param_names.iter())\n     }\n \n     fn encode_optimized_mir(&mut self, def_id: LocalDefId) {"}, {"sha": "381e7ee115e173ceac4a535c6b8bf621513b663f", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -19,7 +19,7 @@ use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::CrateDisambiguator;\n use rustc_span::edition::Edition;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, Span};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n \n@@ -327,7 +327,7 @@ struct ModData {\n struct FnData {\n     asyncness: hir::IsAsync,\n     constness: hir::Constness,\n-    param_names: Lazy<[Symbol]>,\n+    param_names: Lazy<[Ident]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "75c10de9bbe5ef29e38e4f707464ad3075c6f332", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n@@ -374,6 +374,13 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    pub fn body_param_names(&self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n+        self.body(id).params.iter().map(|arg| match arg.pat.kind {\n+            PatKind::Binding(_, _, ident, _) => ident,\n+            _ => Ident::new(kw::Invalid, rustc_span::DUMMY_SP),\n+        })\n+    }\n+\n     /// Returns the `BodyOwnerKind` of this `LocalDefId`.\n     ///\n     /// Panics if `LocalDefId` does not have an associated body.\n@@ -451,11 +458,11 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn visit_item_likes_in_module<V>(&self, module: DefId, visitor: &mut V)\n+    pub fn visit_item_likes_in_module<V>(&self, module: LocalDefId, visitor: &mut V)\n     where\n         V: ItemLikeVisitor<'hir>,\n     {\n-        let module = self.tcx.hir_module_items(module.expect_local());\n+        let module = self.tcx.hir_module_items(module);\n \n         for id in &module.items {\n             visitor.visit_item(self.expect_item(*id));"}, {"sha": "e152d11c081a12bb430fe39ca9432bc5f7680a39", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -12,10 +12,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n-use rustc_hir::Body;\n-use rustc_hir::HirId;\n-use rustc_hir::ItemLocalId;\n-use rustc_hir::Node;\n+use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n \n pub struct Owner<'tcx> {\n@@ -79,5 +76,20 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_deref();\n+    providers.fn_arg_names = |tcx, id| {\n+        let hir = tcx.hir();\n+        let hir_id = hir.as_local_hir_id(id.expect_local());\n+        if let Some(body_id) = hir.maybe_body_owned_by(hir_id) {\n+            tcx.arena.alloc_from_iter(hir.body_param_names(body_id))\n+        } else if let Node::TraitItem(&TraitItem {\n+            kind: TraitItemKind::Fn(_, TraitFn::Required(idents)),\n+            ..\n+        }) = hir.get(hir_id)\n+        {\n+            tcx.arena.alloc_slice(idents)\n+        } else {\n+            span_bug!(hir.span(hir_id), \"fn_arg_names: unexpected item {:?}\", id);\n+        }\n+    };\n     map::provide(providers);\n }"}, {"sha": "bb62c1bb82428d2bd19dcce8419e393d1d4433f5", "filename": "src/librustc_middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_middle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_middle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flint.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -339,7 +339,7 @@ pub fn struct_lint_level<'s, 'd>(\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n-        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n+        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop(_)) => false,\n         ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             // Dummy span for the `def_site` means it's an external macro."}, {"sha": "ba5a8c3ec2052a22dc2fdaa2a68ef7e0d66acbe4", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -15,11 +15,11 @@ use rustc_query_system::query::QueryDescription;\n use rustc_span::symbol::Symbol;\n use std::borrow::Cow;\n \n-fn describe_as_module(def_id: DefId, tcx: TyCtxt<'_>) -> String {\n+fn describe_as_module(def_id: LocalDefId, tcx: TyCtxt<'_>) -> String {\n     if def_id.is_top_level_module() {\n         \"top-level module\".to_string()\n     } else {\n-        format!(\"module `{}`\", tcx.def_path_str(def_id))\n+        format!(\"module `{}`\", tcx.def_path_str(def_id.to_def_id()))\n     }\n }\n \n@@ -473,49 +473,49 @@ rustc_queries! {\n \n     Other {\n         query lint_mod(key: LocalDefId) -> () {\n-            desc { |tcx| \"linting {}\", describe_as_module(key.to_def_id(), tcx) }\n+            desc { |tcx| \"linting {}\", describe_as_module(key, tcx) }\n         }\n \n         /// Checks the attributes in the module.\n-        query check_mod_attrs(key: DefId) -> () {\n+        query check_mod_attrs(key: LocalDefId) -> () {\n             desc { |tcx| \"checking attributes in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_unstable_api_usage(key: DefId) -> () {\n+        query check_mod_unstable_api_usage(key: LocalDefId) -> () {\n             desc { |tcx| \"checking for unstable API usage in {}\", describe_as_module(key, tcx) }\n         }\n \n         /// Checks the const bodies in the module for illegal operations (e.g. `if` or `loop`).\n-        query check_mod_const_bodies(key: DefId) -> () {\n+        query check_mod_const_bodies(key: LocalDefId) -> () {\n             desc { |tcx| \"checking consts in {}\", describe_as_module(key, tcx) }\n         }\n \n         /// Checks the loops in the module.\n-        query check_mod_loops(key: DefId) -> () {\n+        query check_mod_loops(key: LocalDefId) -> () {\n             desc { |tcx| \"checking loops in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_item_types(key: DefId) -> () {\n+        query check_mod_item_types(key: LocalDefId) -> () {\n             desc { |tcx| \"checking item types in {}\", describe_as_module(key, tcx) }\n         }\n \n         query check_mod_privacy(key: LocalDefId) -> () {\n-            desc { |tcx| \"checking privacy in {}\", describe_as_module(key.to_def_id(), tcx) }\n+            desc { |tcx| \"checking privacy in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_intrinsics(key: DefId) -> () {\n+        query check_mod_intrinsics(key: LocalDefId) -> () {\n             desc { |tcx| \"checking intrinsics in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_liveness(key: DefId) -> () {\n+        query check_mod_liveness(key: LocalDefId) -> () {\n             desc { |tcx| \"checking liveness of variables in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_impl_wf(key: DefId) -> () {\n+        query check_mod_impl_wf(key: LocalDefId) -> () {\n             desc { |tcx| \"checking that impls are well-formed in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query collect_mod_item_types(key: DefId) -> () {\n+        query collect_mod_item_types(key: LocalDefId) -> () {\n             desc { |tcx| \"collecting item types in {}\", describe_as_module(key, tcx) }\n         }\n \n@@ -729,7 +729,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query fn_arg_names(def_id: DefId) -> &'tcx [Symbol] {\n+        query fn_arg_names(def_id: DefId) -> &'tcx [rustc_span::symbol::Ident] {\n             desc { |tcx| \"looking up function parameter names for `{}`\", tcx.def_path_str(def_id) }\n         }\n         /// Gets the rendered value of the specified constant or associated constant."}, {"sha": "44c8c1f6fdba44ecaf1cf9af4197d86ebb2ae242", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -873,8 +873,8 @@ impl<'tcx> CommonConsts<'tcx> {\n // conflict.\n #[derive(Debug)]\n pub struct FreeRegionInfo {\n-    // def id corresponding to FreeRegion\n-    pub def_id: DefId,\n+    // `LocalDefId` corresponding to FreeRegion\n+    pub def_id: LocalDefId,\n     // the bound region corresponding to FreeRegion\n     pub boundregion: ty::BoundRegion,\n     // checks if bound region is in Impl Item\n@@ -1412,14 +1412,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     // Returns the `DefId` and the `BoundRegion` corresponding to the given region.\n     pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n-            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ref ebr) => {\n-                (self.parent(ebr.def_id).unwrap(), ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n+            ty::ReFree(ref free_region) => {\n+                (free_region.scope.expect_local(), free_region.bound_region)\n             }\n+            ty::ReEarlyBound(ref ebr) => (\n+                self.parent(ebr.def_id).unwrap().expect_local(),\n+                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n+            ),\n             _ => return None, // not a free region\n         };\n \n-        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope.expect_local());\n+        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope);\n         let is_impl_item = match self.hir().find(hir_id) {\n             Some(Node::Item(..) | Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n@@ -1436,8 +1439,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Given a `DefId` for an `fn`, return all the `dyn` and `impl` traits in its return type.\n-    pub fn return_type_impl_or_dyn_traits(&self, scope_def_id: DefId) -> Vec<&'tcx hir::Ty<'tcx>> {\n-        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n+    pub fn return_type_impl_or_dyn_traits(\n+        &self,\n+        scope_def_id: LocalDefId,\n+    ) -> Vec<&'tcx hir::Ty<'tcx>> {\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id);\n         let hir_output = match self.hir().get(hir_id) {\n             Node::Item(hir::Item {\n                 kind:\n@@ -1480,9 +1486,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         v.0\n     }\n \n-    pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {\n+    pub fn return_type_impl_trait(&self, scope_def_id: LocalDefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n-        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id);\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n                 match item.kind {\n@@ -1512,8 +1518,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     // Checks if the bound region is in Impl Item.\n-    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: DefId) -> bool {\n-        let container_id = self.associated_item(suitable_region_binding_scope).container.id();\n+    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: LocalDefId) -> bool {\n+        let container_id =\n+            self.associated_item(suitable_region_binding_scope.to_def_id()).container.id();\n         if self.impl_trait_ref(container_id).is_some() {\n             // For now, we do not try to target impls of traits. This is\n             // because this message is going to suggest that the user"}, {"sha": "e85f69554d0c831cf3ba0bf18180ff8c3bb7af89", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -24,7 +24,8 @@ use crate::borrow_check::{\n };\n \n use super::{\n-    explain_borrow::BorrowExplanation, IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n+    explain_borrow::BorrowExplanation, FnSelfUseKind, IncludingDowncast, RegionName,\n+    RegionNameSource, UseSpans,\n };\n \n #[derive(Debug)]\n@@ -150,11 +151,68 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         format!(\"value moved{} here, in previous iteration of loop\", move_msg),\n                     );\n                 } else {\n-                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n-                    move_spans.var_span_label(\n-                        &mut err,\n-                        format!(\"variable moved due to use{}\", move_spans.describe()),\n-                    );\n+                    if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } =\n+                        move_spans\n+                    {\n+                        let place_name = self\n+                            .describe_place(moved_place.as_ref())\n+                            .map(|n| format!(\"`{}`\", n))\n+                            .unwrap_or_else(|| \"value\".to_owned());\n+                        match kind {\n+                            FnSelfUseKind::FnOnceCall => {\n+                                err.span_label(\n+                                    fn_call_span,\n+                                    &format!(\"{} moved due to this call\", place_name),\n+                                );\n+                                err.span_note(\n+                                    var_span,\n+                                    \"this value implements `FnOnce`, which causes it to be moved when called\",\n+                                );\n+                            }\n+                            FnSelfUseKind::Operator { self_arg } => {\n+                                err.span_label(\n+                                    fn_call_span,\n+                                    &format!(\"{} moved due to usage in operator\", place_name),\n+                                );\n+                                if self.fn_self_span_reported.insert(fn_span) {\n+                                    err.span_note(\n+                                        self_arg.span,\n+                                        \"calling this operator moves the left-hand side\",\n+                                    );\n+                                }\n+                            }\n+                            FnSelfUseKind::Normal { self_arg, implicit_into_iter } => {\n+                                if implicit_into_iter {\n+                                    err.span_label(\n+                                        fn_call_span,\n+                                        &format!(\n+                                            \"{} moved due to this implicit call to `.into_iter()`\",\n+                                            place_name\n+                                        ),\n+                                    );\n+                                } else {\n+                                    err.span_label(\n+                                        fn_call_span,\n+                                        &format!(\"{} moved due to this method call\", place_name),\n+                                    );\n+                                }\n+                                // Avoid pointing to the same function in multiple different\n+                                // error messages\n+                                if self.fn_self_span_reported.insert(self_arg.span) {\n+                                    err.span_note(\n+                                        self_arg.span,\n+                                        &format!(\"this function consumes the receiver `self` by taking ownership of it, which moves {}\", place_name)\n+                                    );\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                        move_spans.var_span_label(\n+                            &mut err,\n+                            format!(\"variable moved due to use{}\", move_spans.describe()),\n+                        );\n+                    }\n                 }\n                 if let UseSpans::PatUse(span) = move_spans {\n                     err.span_suggestion_verbose(\n@@ -170,7 +228,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     );\n                 }\n \n-                if Some(DesugaringKind::ForLoop) == move_span.desugaring_kind() {\n+                if let Some(DesugaringKind::ForLoop(_)) = move_span.desugaring_kind() {\n                     let sess = self.infcx.tcx.sess;\n                     if let Ok(snippet) = sess.source_map().span_to_snippet(move_span) {\n                         err.span_suggestion("}, {"sha": "b591b938b5ac32efb41f8f391decc77879cff34d", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -509,7 +509,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // Used in a closure.\n                 (LaterUseKind::ClosureCapture, var_span)\n             }\n-            UseSpans::PatUse(span) | UseSpans::OtherUse(span) => {\n+            UseSpans::PatUse(span)\n+            | UseSpans::OtherUse(span)\n+            | UseSpans::FnSelfUse { var_span: span, .. } => {\n                 let block = &self.body.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {"}, {"sha": "e94952e1c543cd6ee92ee7b7cdfb189bbdc3aa06", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 137, "deletions": 20, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -4,14 +4,19 @@ use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItemGroup;\n use rustc_hir::GeneratorKind;\n use rustc_middle::mir::{\n     AggregateKind, Constant, Field, Local, LocalInfo, LocalKind, Location, Operand, Place,\n     PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n-use rustc_span::{symbol::sym, Span};\n+use rustc_span::{\n+    hygiene::{DesugaringKind, ForLoopLoc},\n+    symbol::sym,\n+    Span,\n+};\n use rustc_target::abi::VariantIdx;\n \n use super::borrow_set::BorrowData;\n@@ -33,6 +38,7 @@ crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionName, RegionNameSource};\n+use rustc_span::symbol::Ident;\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -529,30 +535,52 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n }\n \n-// The span(s) associated to a use of a place.\n+/// The span(s) associated to a use of a place.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub(super) enum UseSpans {\n-    // The access is caused by capturing a variable for a closure.\n+    /// The access is caused by capturing a variable for a closure.\n     ClosureUse {\n-        // This is true if the captured variable was from a generator.\n+        /// This is true if the captured variable was from a generator.\n         generator_kind: Option<GeneratorKind>,\n-        // The span of the args of the closure, including the `move` keyword if\n-        // it's present.\n+        /// The span of the args of the closure, including the `move` keyword if\n+        /// it's present.\n         args_span: Span,\n-        // The span of the first use of the captured variable inside the closure.\n+        /// The span of the first use of the captured variable inside the closure.\n+        var_span: Span,\n+    },\n+    /// The access is caused by using a variable as the receiver of a method\n+    /// that takes 'self'\n+    FnSelfUse {\n+        /// The span of the variable being moved\n         var_span: Span,\n+        /// The span of the method call on the variable\n+        fn_call_span: Span,\n+        /// The definition span of the method being called\n+        fn_span: Span,\n+        kind: FnSelfUseKind,\n     },\n     /// This access is caused by a `match` or `if let` pattern.\n     PatUse(Span),\n     /// This access has a single span associated to it: common case.\n     OtherUse(Span),\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub(super) enum FnSelfUseKind {\n+    /// A normal method call of the form `receiver.foo(a, b, c)`\n+    Normal { self_arg: Ident, implicit_into_iter: bool },\n+    /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n+    FnOnceCall,\n+    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n+    Operator { self_arg: Ident },\n+}\n+\n impl UseSpans {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { args_span: span, .. }\n             | UseSpans::PatUse(span)\n+            | UseSpans::FnSelfUse { var_span: span, .. }\n             | UseSpans::OtherUse(span) => span,\n         }\n     }\n@@ -561,6 +589,7 @@ impl UseSpans {\n         match self {\n             UseSpans::ClosureUse { var_span: span, .. }\n             | UseSpans::PatUse(span)\n+            | UseSpans::FnSelfUse { var_span: span, .. }\n             | UseSpans::OtherUse(span) => span,\n         }\n     }\n@@ -631,6 +660,7 @@ impl UseSpans {\n         match self {\n             closure @ UseSpans::ClosureUse { .. } => closure,\n             UseSpans::PatUse(_) | UseSpans::OtherUse(_) => if_other(),\n+            fn_self @ UseSpans::FnSelfUse { .. } => fn_self,\n         }\n     }\n }\n@@ -733,25 +763,112 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n         if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) = stmt.kind {\n-            let def_id = match kind {\n+            match kind {\n                 box AggregateKind::Closure(def_id, _)\n-                | box AggregateKind::Generator(def_id, _, _) => def_id,\n-                _ => return OtherUse(stmt.source_info.span),\n+                | box AggregateKind::Generator(def_id, _, _) => {\n+                    debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n+                    if let Some((args_span, generator_kind, var_span)) =\n+                        self.closure_span(*def_id, moved_place, places)\n+                    {\n+                        return ClosureUse { generator_kind, args_span, var_span };\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        let normal_ret =\n+            if moved_place.projection.iter().any(|p| matches!(p, ProjectionElem::Downcast(..))) {\n+                PatUse(stmt.source_info.span)\n+            } else {\n+                OtherUse(stmt.source_info.span)\n             };\n \n-            debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n-            if let Some((args_span, generator_kind, var_span)) =\n-                self.closure_span(*def_id, moved_place, places)\n-            {\n-                return ClosureUse { generator_kind, args_span, var_span };\n+        // We are trying to find MIR of the form:\n+        // ```\n+        // _temp = _moved_val;\n+        // ...\n+        // FnSelfCall(_temp, ...)\n+        // ```\n+        //\n+        // where `_moved_val` is the place we generated the move error for,\n+        // `_temp` is some other local, and `FnSelfCall` is a function\n+        // that has a `self` parameter.\n+\n+        let target_temp = match stmt.kind {\n+            StatementKind::Assign(box (temp, _)) if temp.as_local().is_some() => {\n+                temp.as_local().unwrap()\n             }\n-        }\n+            _ => return normal_ret,\n+        };\n \n-        if moved_place.projection.iter().any(|p| matches!(p, ProjectionElem::Downcast(..))) {\n-            PatUse(stmt.source_info.span)\n-        } else {\n-            OtherUse(stmt.source_info.span)\n+        debug!(\"move_spans: target_temp = {:?}\", target_temp);\n+\n+        if let Some(Terminator {\n+            kind: TerminatorKind::Call { func, args, fn_span, from_hir_call, .. },\n+            ..\n+        }) = &self.body[location.block].terminator\n+        {\n+            let mut method_did = None;\n+            if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n+                if let ty::FnDef(def_id, _) = ty.kind {\n+                    debug!(\"move_spans: fn = {:?}\", def_id);\n+                    if let Some(ty::AssocItem { fn_has_self_parameter, .. }) =\n+                        self.infcx.tcx.opt_associated_item(def_id)\n+                    {\n+                        if *fn_has_self_parameter {\n+                            method_did = Some(def_id);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            let tcx = self.infcx.tcx;\n+            let method_did = if let Some(did) = method_did { did } else { return normal_ret };\n+\n+            if let [Operand::Move(self_place), ..] = **args {\n+                if self_place.as_local() == Some(target_temp) {\n+                    let parent = tcx.parent(method_did);\n+                    let is_fn_once = parent == tcx.lang_items().fn_once_trait();\n+                    let is_operator = !from_hir_call\n+                        && parent.map_or(false, |p| {\n+                            tcx.lang_items().group(LangItemGroup::Op).contains(&p)\n+                        });\n+                    let fn_call_span = *fn_span;\n+\n+                    let self_arg = tcx.fn_arg_names(method_did)[0];\n+\n+                    let kind = if is_fn_once {\n+                        FnSelfUseKind::FnOnceCall\n+                    } else if is_operator {\n+                        FnSelfUseKind::Operator { self_arg }\n+                    } else {\n+                        debug!(\n+                            \"move_spans: method_did={:?}, fn_call_span={:?}\",\n+                            method_did, fn_call_span\n+                        );\n+                        let implicit_into_iter = matches!(\n+                            fn_call_span.desugaring_kind(),\n+                            Some(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n+                        );\n+                        FnSelfUseKind::Normal { self_arg, implicit_into_iter }\n+                    };\n+\n+                    return FnSelfUse {\n+                        var_span: stmt.source_info.span,\n+                        fn_call_span,\n+                        fn_span: self\n+                            .infcx\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .guess_head_span(self.infcx.tcx.def_span(method_did)),\n+                        kind,\n+                    };\n+                }\n+            }\n         }\n+        return normal_ret;\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`)"}, {"sha": "4883b08e424423a71265093c884a7d3e069d3476", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     format!(\"{}.as_ref()\", snippet),\n                     Applicability::MaybeIncorrect,\n                 );\n-            } else if span.is_desugaring(DesugaringKind::ForLoop)\n+            } else if matches!(span.desugaring_kind(), Some(DesugaringKind::ForLoop(_)))\n                 && self.infcx.tcx.is_diagnostic_item(Symbol::intern(\"vec_type\"), def_id)\n             {\n                 // FIXME: suggest for anything that implements `IntoIterator`."}, {"sha": "b4bc89e827daa7010b7608ab5b68ee73abb8a98b", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     opt_assignment_rhs_span.and_then(|span| span.desugaring_kind());\n                                 match opt_desugaring_kind {\n                                     // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop) => Some((\n+                                    Some(DesugaringKind::ForLoop(_)) => Some((\n                                         false,\n                                         opt_assignment_rhs_span.unwrap(),\n                                         format!("}, {"sha": "99b9788c20b053b549c6b5eb918e2fc60ab27076", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -579,7 +579,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let (Some(f), Some(ty::RegionKind::ReStatic)) =\n             (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n-            if let Some((ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = self\n+            if let Some((&ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = self\n                 .infcx\n                 .tcx\n                 .is_suitable_region(f)\n@@ -592,7 +592,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 //\n                 // eg. check for `impl Trait + 'static` instead of `impl Trait`.\n                 let has_static_predicate = {\n-                    let predicates_of = self.infcx.tcx.predicates_of(*did);\n+                    let predicates_of = self.infcx.tcx.predicates_of(did);\n                     let bounds = predicates_of.instantiate(self.infcx.tcx, substs);\n \n                     let mut found = false;\n@@ -625,7 +625,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     diag.help(&format!(\"consider replacing `{}` with `{}`\", fr_name, static_str));\n                 } else {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n-                    let span = self.infcx.tcx.def_span(*did);\n+                    let span = self.infcx.tcx.def_span(did);\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         let suggestable_fr_name = if fr_name.was_named() {\n                             fr_name.to_string()"}, {"sha": "83691d439eb81c983dc1af5da94f01eb310ce4c2", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -278,6 +278,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n                 move_data: &move_data,\n                 location_table: &LocationTable::new(promoted_body),\n                 movable_generator,\n+                fn_self_span_reported: Default::default(),\n                 locals_are_invalidated_at_exit,\n                 access_place_error_reported: Default::default(),\n                 reservation_error_reported: Default::default(),\n@@ -311,6 +312,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         location_table,\n         movable_generator,\n         locals_are_invalidated_at_exit,\n+        fn_self_span_reported: Default::default(),\n         access_place_error_reported: Default::default(),\n         reservation_error_reported: Default::default(),\n         reservation_warnings: Default::default(),\n@@ -487,6 +489,10 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     // but it is currently inconvenient to track down the `BorrowIndex`\n     // at the time we detect and report a reservation error.\n     reservation_error_reported: FxHashSet<Place<'tcx>>,\n+    /// This fields keeps track of the `Span`s that we have\n+    /// used to report extra information for `FnSelfUse`, to avoid\n+    /// unnecessarily verbose errors.\n+    fn_self_span_reported: FxHashSet<Span>,\n     /// Migration warnings to be reported for #56254. We delay reporting these\n     /// so that we can suppress the warning if there's a corresponding error\n     /// for the activation of the borrow."}, {"sha": "7b292ee71f99d22f49dbef2ad6e5f4256b0473e2", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -232,8 +232,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     ) -> Self {\n         let tcx = infcx.tcx;\n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id);\n-        UniversalRegionsBuilder { infcx, mir_def_id: mir_def_id.to_def_id(), mir_hir_id, param_env }\n-            .build()\n+        UniversalRegionsBuilder { infcx, mir_def_id, mir_hir_id, param_env }.build()\n     }\n \n     /// Given a reference to a closure type, extracts all the values\n@@ -389,7 +388,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    mir_def_id: DefId,\n+    mir_def_id: LocalDefId,\n     mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n@@ -418,15 +417,15 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let mut indices = self.compute_indices(fr_static, defining_ty);\n         debug!(\"build: indices={:?}\", indices);\n \n-        let closure_base_def_id = self.infcx.tcx.closure_base_def_id(self.mir_def_id);\n+        let closure_base_def_id = self.infcx.tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n \n         // If this is a closure or generator, then the late-bound regions from the enclosing\n         // function are actually external regions to us. For example, here, 'a is not local\n         // to the closure c (although it is local to the fn foo):\n         // fn foo<'a>() {\n         //     let c = || { let x: &'a u32 = ...; }\n         // }\n-        if self.mir_def_id != closure_base_def_id {\n+        if self.mir_def_id.to_def_id() != closure_base_def_id {\n             self.infcx.replace_late_bound_regions_with_nll_infer_vars(self.mir_def_id, &mut indices)\n         }\n \n@@ -443,7 +442,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         );\n         // Converse of above, if this is a function then the late-bound regions declared on its\n         // signature are local to the fn.\n-        if self.mir_def_id == closure_base_def_id {\n+        if self.mir_def_id.to_def_id() == closure_base_def_id {\n             self.infcx\n                 .replace_late_bound_regions_with_nll_infer_vars(self.mir_def_id, &mut indices);\n         }\n@@ -508,14 +507,14 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n     /// see `DefiningTy` for details.\n     fn defining_ty(&self) -> DefiningTy<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n \n         match tcx.hir().body_owner_kind(self.mir_hir_id) {\n             BodyOwnerKind::Closure | BodyOwnerKind::Fn => {\n-                let defining_ty = if self.mir_def_id == closure_base_def_id {\n+                let defining_ty = if self.mir_def_id.to_def_id() == closure_base_def_id {\n                     tcx.type_of(closure_base_def_id)\n                 } else {\n-                    let tables = tcx.typeck_tables_of(self.mir_def_id.expect_local());\n+                    let tables = tcx.typeck_tables_of(self.mir_def_id);\n                     tables.node_type(self.mir_hir_id)\n                 };\n \n@@ -540,11 +539,11 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n \n             BodyOwnerKind::Const | BodyOwnerKind::Static(..) => {\n-                assert_eq!(closure_base_def_id, self.mir_def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), closure_base_def_id);\n                 let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n                 let substs =\n                     self.infcx.replace_free_regions_with_nll_infer_vars(FR, &identity_substs);\n-                DefiningTy::Const(self.mir_def_id, substs)\n+                DefiningTy::Const(self.mir_def_id.to_def_id(), substs)\n             }\n         }\n     }\n@@ -559,7 +558,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         defining_ty: DefiningTy<'tcx>,\n     ) -> UniversalRegionIndices<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n         let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n         let fr_substs = match defining_ty {\n             DefiningTy::Closure(_, ref substs) | DefiningTy::Generator(_, ref substs, _) => {\n@@ -593,7 +592,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n-                assert_eq!(self.mir_def_id, def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n                 let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n@@ -617,7 +616,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n-                assert_eq!(self.mir_def_id, def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n                 let resume_ty = substs.as_generator().resume_ty();\n                 let output = substs.as_generator().return_ty();\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n@@ -635,7 +634,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             DefiningTy::Const(def_id, _) => {\n                 // For a constant body, there are no inputs, and one\n                 // \"output\" (the type of the constant).\n-                assert_eq!(self.mir_def_id, def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n                 let ty = tcx.type_of(def_id);\n                 let ty = indices.fold_to_region_vids(tcx, &ty);\n                 ty::Binder::dummy(tcx.intern_type_list(&[ty]))\n@@ -656,7 +655,7 @@ trait InferCtxtExt<'tcx> {\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n-        all_outlive_scope: DefId,\n+        all_outlive_scope: LocalDefId,\n         value: &ty::Binder<T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n@@ -665,7 +664,7 @@ trait InferCtxtExt<'tcx> {\n \n     fn replace_late_bound_regions_with_nll_infer_vars(\n         &self,\n-        mir_def_id: DefId,\n+        mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     );\n }\n@@ -685,7 +684,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n-        all_outlive_scope: DefId,\n+        all_outlive_scope: LocalDefId,\n         value: &ty::Binder<T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n@@ -699,7 +698,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n             debug!(\"replace_bound_regions_with_nll_infer_vars: br={:?}\", br);\n             let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: all_outlive_scope,\n+                scope: all_outlive_scope.to_def_id(),\n                 bound_region: br,\n             }));\n             let region_vid = self.next_nll_region_var(origin);\n@@ -724,11 +723,11 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// inputs vector.\n     fn replace_late_bound_regions_with_nll_infer_vars(\n         &self,\n-        mir_def_id: DefId,\n+        mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) {\n         debug!(\"replace_late_bound_regions_with_nll_infer_vars(mir_def_id={:?})\", mir_def_id);\n-        let closure_base_def_id = self.tcx.closure_base_def_id(mir_def_id);\n+        let closure_base_def_id = self.tcx.closure_base_def_id(mir_def_id.to_def_id());\n         for_each_late_bound_region_defined_on(self.tcx, closure_base_def_id, |r| {\n             debug!(\"replace_late_bound_regions_with_nll_infer_vars: r={:?}\", r);\n             if !indices.indices.contains_key(&r) {"}, {"sha": "9c72a18c6d469ae3356035b613d018b26eda85cd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::mir::interpret::{\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n-    self, fold::BottomUpFolder, query::TyCtxtAt, subst::SubstsRef, Ty, TyCtxt, TypeFoldable,\n+    self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::{source_map::DUMMY_SP, Span};\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n@@ -24,6 +24,7 @@ use super::{\n     Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n     ScalarMaybeUninit, StackPopJump,\n };\n+use crate::transform::validate::equal_up_to_regions;\n use crate::util::storage::AlwaysLiveLocals;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -220,49 +221,35 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx,\n /// This test should be symmetric, as it is primarily about layout compatibility.\n pub(super) fn mir_assign_valid_types<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     src: TyAndLayout<'tcx>,\n     dest: TyAndLayout<'tcx>,\n ) -> bool {\n-    if src.ty == dest.ty {\n-        // Equal types, all is good.\n-        return true;\n-    }\n-    if src.layout != dest.layout {\n-        // Layout differs, definitely not equal.\n-        // We do this here because Miri would *do the wrong thing* if we allowed layout-changing\n-        // assignments.\n-        return false;\n-    }\n-\n-    // Type-changing assignments can happen for (at least) two reasons:\n-    // 1. `&mut T` -> `&T` gets optimized from a reborrow to a mere assignment.\n-    // 2. Subtyping is used. While all normal lifetimes are erased, higher-ranked types\n-    //    with their late-bound lifetimes are still around and can lead to type differences.\n-    // Normalize both of them away.\n-    let normalize = |ty: Ty<'tcx>| {\n-        ty.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            // Normalize all references to immutable.\n-            ty_op: |ty| match ty.kind {\n-                ty::Ref(_, pointee, _) => tcx.mk_imm_ref(tcx.lifetimes.re_erased, pointee),\n-                _ => ty,\n-            },\n-            // We just erase all late-bound lifetimes, but this is not fully correct (FIXME):\n-            // lifetimes in invariant positions could matter (e.g. through associated types).\n-            // We rely on the fact that layout was confirmed to be equal above.\n-            lt_op: |_| tcx.lifetimes.re_erased,\n-            // Leave consts unchanged.\n-            ct_op: |ct| ct,\n-        })\n-    };\n-    normalize(src.ty) == normalize(dest.ty)\n+    // Type-changing assignments can happen when subtyping is used. While\n+    // all normal lifetimes are erased, higher-ranked types with their\n+    // late-bound lifetimes are still around and can lead to type\n+    // differences. So we compare ignoring lifetimes.\n+    if equal_up_to_regions(tcx, param_env, src.ty, dest.ty) {\n+        // Make sure the layout is equal, too -- just to be safe. Miri really\n+        // needs layout equality. For performance reason we skip this check when\n+        // the types are equal. Equal types *can* have different layouts when\n+        // enum downcast is involved (as enum variants carry the type of the\n+        // enum), but those should never occur in assignments.\n+        if cfg!(debug_assertions) || src.ty != dest.ty {\n+            assert_eq!(src.layout, dest.layout);\n+        }\n+        true\n+    } else {\n+        false\n+    }\n }\n \n /// Use the already known layout if given (but sanity check in debug mode),\n /// or compute the layout.\n #[cfg_attr(not(debug_assertions), inline(always))]\n pub(super) fn from_known_layout<'tcx>(\n     tcx: TyCtxtAt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     known_layout: Option<TyAndLayout<'tcx>>,\n     compute: impl FnOnce() -> InterpResult<'tcx, TyAndLayout<'tcx>>,\n ) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n@@ -271,7 +258,7 @@ pub(super) fn from_known_layout<'tcx>(\n         Some(known_layout) => {\n             if cfg!(debug_assertions) {\n                 let check_layout = compute()?;\n-                if !mir_assign_valid_types(tcx.tcx, check_layout, known_layout) {\n+                if !mir_assign_valid_types(tcx.tcx, param_env, check_layout, known_layout) {\n                     span_bug!(\n                         tcx.span,\n                         \"expected type differs from actual type.\\nexpected: {:?}\\nactual: {:?}\",\n@@ -475,7 +462,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // have to support that case (mostly by skipping all caching).\n         match frame.locals.get(local).and_then(|state| state.layout.get()) {\n             None => {\n-                let layout = from_known_layout(self.tcx, layout, || {\n+                let layout = from_known_layout(self.tcx, self.param_env, layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty =\n                         self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty);"}, {"sha": "fd55deaf83bbabb2fa9d7050ad4486550fd8dd7a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -488,6 +488,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n             *self.tcx,\n+            self.param_env,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n                 place.ty(&self.frame().body.local_decls, *self.tcx).ty\n             ))?,\n@@ -570,7 +571,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // documentation).\n         let val_val = M::adjust_global_const(self, val_val)?;\n         // Other cases need layout.\n-        let layout = from_known_layout(self.tcx, layout, || self.layout_of(val.ty))?;\n+        let layout =\n+            from_known_layout(self.tcx, self.param_env, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.create_memory_alloc(alloc);"}, {"sha": "98a1cea97e2208c25e7ff0af91aae14dba470ff4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -652,6 +652,7 @@ where\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n             *self.tcx,\n+            self.param_env,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n                 place.ty(&self.frame().body.local_decls, *self.tcx).ty\n             ))?,\n@@ -855,7 +856,7 @@ where\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        if !mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n+        if !mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n             span_bug!(\n                 self.cur_span(),\n                 \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n@@ -912,7 +913,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n+        if mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }"}, {"sha": "a891f12c8e15f9a1c015bc985a021cd0645570a5", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -512,6 +512,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // This is basically `force_bits`.\n             let r_bits = r_bits.and_then(|r| r.to_bits_or_ptr(right_size, &self.tcx).ok());\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n+                debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n                     source_info,"}, {"sha": "d3f486c815e6c438869442042f71d109d4b31de7", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 147, "deletions": 12, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -7,7 +7,11 @@ use rustc_middle::{\n         BasicBlock, Body, Location, Operand, Rvalue, Statement, StatementKind, Terminator,\n         TerminatorKind,\n     },\n-    ty::{self, ParamEnv, TyCtxt},\n+    ty::{\n+        self,\n+        relate::{Relate, RelateResult, TypeRelation},\n+        ParamEnv, Ty, TyCtxt,\n+    },\n };\n \n #[derive(Copy, Clone, Debug)]\n@@ -28,6 +32,98 @@ impl<'tcx> MirPass<'tcx> for Validator {\n     }\n }\n \n+/// Returns whether the two types are equal up to lifetimes.\n+/// All lifetimes, including higher-ranked ones, get ignored for this comparison.\n+/// (This is unlike the `erasing_regions` methods, which keep higher-ranked lifetimes for soundness reasons.)\n+///\n+/// The point of this function is to approximate \"equal up to subtyping\".  However,\n+/// the approximation is incorrect as variance is ignored.\n+pub fn equal_up_to_regions(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    src: Ty<'tcx>,\n+    dest: Ty<'tcx>,\n+) -> bool {\n+    // Fast path.\n+    if src == dest {\n+        return true;\n+    }\n+\n+    struct LifetimeIgnoreRelation<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    }\n+\n+    impl TypeRelation<'tcx> for LifetimeIgnoreRelation<'tcx> {\n+        fn tcx(&self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+            self.param_env\n+        }\n+\n+        fn tag(&self) -> &'static str {\n+            \"librustc_mir::transform::validate\"\n+        }\n+\n+        fn a_is_expected(&self) -> bool {\n+            true\n+        }\n+\n+        fn relate_with_variance<T: Relate<'tcx>>(\n+            &mut self,\n+            _: ty::Variance,\n+            a: &T,\n+            b: &T,\n+        ) -> RelateResult<'tcx, T> {\n+            // Ignore variance, require types to be exactly the same.\n+            self.relate(a, b)\n+        }\n+\n+        fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+            if a == b {\n+                // Short-circuit.\n+                return Ok(a);\n+            }\n+            ty::relate::super_relate_tys(self, a, b)\n+        }\n+\n+        fn regions(\n+            &mut self,\n+            a: ty::Region<'tcx>,\n+            _b: ty::Region<'tcx>,\n+        ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+            // Ignore regions.\n+            Ok(a)\n+        }\n+\n+        fn consts(\n+            &mut self,\n+            a: &'tcx ty::Const<'tcx>,\n+            b: &'tcx ty::Const<'tcx>,\n+        ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+            ty::relate::super_relate_consts(self, a, b)\n+        }\n+\n+        fn binders<T>(\n+            &mut self,\n+            a: &ty::Binder<T>,\n+            b: &ty::Binder<T>,\n+        ) -> RelateResult<'tcx, ty::Binder<T>>\n+        where\n+            T: Relate<'tcx>,\n+        {\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+            Ok(a.clone())\n+        }\n+    }\n+\n+    // Instantiate and run relation.\n+    let mut relator: LifetimeIgnoreRelation<'tcx> = LifetimeIgnoreRelation { tcx: tcx, param_env };\n+    relator.relate(&src, &dest).is_ok()\n+}\n+\n struct TypeChecker<'a, 'tcx> {\n     when: &'a str,\n     source: MirSource<'tcx>,\n@@ -81,6 +177,28 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             self.fail(location, format!(\"encountered jump to invalid basic block {:?}\", bb))\n         }\n     }\n+\n+    /// Check if src can be assigned into dest.\n+    /// This is not precise, it will accept some incorrect assignments.\n+    fn mir_assign_valid_types(&self, src: Ty<'tcx>, dest: Ty<'tcx>) -> bool {\n+        // Fast path before we normalize.\n+        if src == dest {\n+            // Equal types, all is good.\n+            return true;\n+        }\n+        // Normalize projections and things like that.\n+        // FIXME: We need to reveal_all, as some optimizations change types in ways\n+        // that require unfolding opaque types.\n+        let param_env = self.param_env.with_reveal_all();\n+        let src = self.tcx.normalize_erasing_regions(param_env, src);\n+        let dest = self.tcx.normalize_erasing_regions(param_env, dest);\n+\n+        // Type-changing assignments can happen when subtyping is used. While\n+        // all normal lifetimes are erased, higher-ranked types with their\n+        // late-bound lifetimes are still around and can lead to type\n+        // differences. So we compare ignoring lifetimes.\n+        equal_up_to_regions(self.tcx, param_env, src, dest)\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n@@ -99,20 +217,37 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n     }\n \n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-        // The sides of an assignment must not alias. Currently this just checks whether the places\n-        // are identical.\n-        if let StatementKind::Assign(box (dest, rvalue)) = &statement.kind {\n-            match rvalue {\n-                Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) => {\n-                    if dest == src {\n-                        self.fail(\n-                            location,\n-                            \"encountered `Assign` statement with overlapping memory\",\n-                        );\n+        match &statement.kind {\n+            StatementKind::Assign(box (dest, rvalue)) => {\n+                // LHS and RHS of the assignment must have the same type.\n+                let left_ty = dest.ty(&self.body.local_decls, self.tcx).ty;\n+                let right_ty = rvalue.ty(&self.body.local_decls, self.tcx);\n+                if !self.mir_assign_valid_types(right_ty, left_ty) {\n+                    self.fail(\n+                        location,\n+                        format!(\n+                            \"encountered `Assign` statement with incompatible types:\\n\\\n+                            left-hand side has type: {}\\n\\\n+                            right-hand side has type: {}\",\n+                            left_ty, right_ty,\n+                        ),\n+                    );\n+                }\n+                // The sides of an assignment must not alias. Currently this just checks whether the places\n+                // are identical.\n+                match rvalue {\n+                    Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) => {\n+                        if dest == src {\n+                            self.fail(\n+                                location,\n+                                \"encountered `Assign` statement with overlapping memory\",\n+                            );\n+                        }\n                     }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n+            _ => {}\n         }\n     }\n "}, {"sha": "ef84f251390e6045efcf82bfa15ec9935feca066", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::ast::{Attribute, NestedMetaItem};\n use rustc_ast::attr;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{self, HirId, Item, ItemKind, TraitItem};\n use rustc_hir::{MethodKind, Target};\n@@ -464,7 +464,7 @@ fn is_c_like_enum(item: &Item<'_>) -> bool {\n     }\n }\n \n-fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir()\n         .visit_item_likes_in_module(module_def_id, &mut CheckAttrVisitor { tcx }.as_deep_visitor());\n }"}, {"sha": "90a076eeded7ed520be0afa2a4a410262c88169b", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -9,7 +9,7 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n@@ -62,7 +62,7 @@ impl NonConstExpr {\n     }\n }\n \n-fn check_mod_const_bodies(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_const_bodies(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let mut vis = CheckConstVisitor::new(tcx);\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut vis.as_deep_visitor());\n }"}, {"sha": "2edbc29b7efb6fcb92936d694547a39ece519ca0", "filename": "src/librustc_passes/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_id_validator.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -17,7 +17,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n     par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n         let local_def_id = hir_map.local_def_id(*module_id);\n         hir_map.visit_item_likes_in_module(\n-            local_def_id.to_def_id(),\n+            local_def_id,\n             &mut OuterVisitor { hir_map, errors: &errors },\n         );\n     });"}, {"sha": "683039df15ac6d0de0f47898f577befc37df68ea", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -2,7 +2,7 @@ use rustc_ast::ast::{FloatTy, InlineAsmTemplatePiece, IntTy, UintTy};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n@@ -14,7 +14,7 @@ use rustc_target::abi::{Pointer, VariantIdx};\n use rustc_target::asm::{InlineAsmRegOrRegClass, InlineAsmType};\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n-fn check_mod_intrinsics(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_intrinsics(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut ItemVisitor { tcx }.as_deep_visitor());\n }\n "}, {"sha": "0be37cb096038a7ddb6a6db6cc9c3b8c72fec94c", "filename": "src/librustc_passes/lang_items.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -102,7 +102,8 @@ impl LanguageItemCollector<'tcx> {\n         // Check for duplicates.\n         if let Some(original_def_id) = self.items.items[item_index] {\n             if original_def_id != item_def_id {\n-                let name = LangItem::from_u32(item_index as u32).unwrap().name();\n+                let lang_item = LangItem::from_u32(item_index as u32).unwrap();\n+                let name = lang_item.name();\n                 let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n                     Some(span) => struct_span_err!(\n                         self.tcx.sess,\n@@ -152,6 +153,9 @@ impl LanguageItemCollector<'tcx> {\n \n         // Matched.\n         self.items.items[item_index] = Some(item_def_id);\n+        if let Some(group) = LangItem::from_u32(item_index as u32).unwrap().group() {\n+            self.items.groups[group as usize].push(item_def_id);\n+        }\n     }\n }\n "}, {"sha": "798c6b8925bbf6d03c992507d955c3633a8d9a06", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -89,7 +89,7 @@ use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::*;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{Expr, HirId, HirIdMap, HirIdSet, Node};\n use rustc_middle::hir::map::Map;\n@@ -172,7 +172,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     }\n }\n \n-fn check_mod_liveness(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_liveness(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut IrMaps::new(tcx, module_def_id).as_deep_visitor(),\n@@ -248,7 +248,7 @@ enum VarKind {\n \n struct IrMaps<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    body_owner: DefId,\n+    body_owner: LocalDefId,\n     num_live_nodes: usize,\n     num_vars: usize,\n     live_node_map: HirIdMap<LiveNode>,\n@@ -259,7 +259,7 @@ struct IrMaps<'tcx> {\n }\n \n impl IrMaps<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, body_owner: DefId) -> IrMaps<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, body_owner: LocalDefId) -> IrMaps<'tcx> {\n         IrMaps {\n             tcx,\n             body_owner,\n@@ -349,7 +349,7 @@ fn visit_fn<'tcx>(\n \n     // swap in a new set of IR maps for this function body:\n     let def_id = ir.tcx.hir().local_def_id(id);\n-    let mut fn_maps = IrMaps::new(ir.tcx, def_id.to_def_id());\n+    let mut fn_maps = IrMaps::new(ir.tcx, def_id);\n \n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n@@ -484,7 +484,7 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n             ir.set_captures(expr.hir_id, call_caps);\n             let old_body_owner = ir.body_owner;\n-            ir.body_owner = closure_def_id.to_def_id();\n+            ir.body_owner = closure_def_id;\n             intravisit::walk_expr(ir, expr);\n             ir.body_owner = old_body_owner;\n         }\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             for (&var_hir_id, upvar) in upvars.iter().rev() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                    closure_expr_id: self.ir.body_owner.expect_local(),\n+                    closure_expr_id: self.ir.body_owner,\n                 };\n                 match self.tables.upvar_capture(upvar_id) {\n                     ty::UpvarCapture::ByRef(_) => {\n@@ -1614,7 +1614,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n             let var = self.variable(var_hir_id, upvar.span);\n             let upvar_id = ty::UpvarId {\n                 var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                closure_expr_id: self.ir.body_owner.expect_local(),\n+                closure_expr_id: self.ir.body_owner,\n             };\n             match self.tables.upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => {}"}, {"sha": "d7012d4d711df89de5d8e08cd4fc7a96ddd78636", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -2,7 +2,7 @@ use Context::*;\n \n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Destination, Movability, Node};\n use rustc_middle::hir::map::Map;\n@@ -29,7 +29,7 @@ struct CheckLoopVisitor<'a, 'hir> {\n     cx: Context,\n }\n \n-fn check_mod_loops(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_loops(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CheckLoopVisitor { sess: &tcx.sess, hir_map: tcx.hir(), cx: Normal }.as_deep_visitor(),"}, {"sha": "ad512c63352f1a062c8bf0daeee2cb5a216754f2", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Generics, HirId, Item, StructField, Variant};\n use rustc_middle::hir::map::Map;\n@@ -472,7 +472,7 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n \n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors.\n-fn check_mod_unstable_api_usage(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_unstable_api_usage(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut Checker { tcx }.as_deep_visitor());\n }\n "}, {"sha": "fcd5dab94a6c25efe39d6c0f0a2ea23dabe3665a", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -1061,8 +1061,15 @@ fn default_emitter(\n             }\n         }\n         (config::ErrorOutputType::Json { pretty, json_rendered }, None) => Box::new(\n-            JsonEmitter::stderr(Some(registry), source_map, pretty, json_rendered, macro_backtrace)\n-                .ui_testing(sopts.debugging_opts.ui_testing),\n+            JsonEmitter::stderr(\n+                Some(registry),\n+                source_map,\n+                pretty,\n+                json_rendered,\n+                sopts.debugging_opts.terminal_width,\n+                macro_backtrace,\n+            )\n+            .ui_testing(sopts.debugging_opts.ui_testing),\n         ),\n         (config::ErrorOutputType::Json { pretty, json_rendered }, Some(dst)) => Box::new(\n             JsonEmitter::new(\n@@ -1071,6 +1078,7 @@ fn default_emitter(\n                 source_map,\n                 pretty,\n                 json_rendered,\n+                sopts.debugging_opts.terminal_width,\n                 macro_backtrace,\n             )\n             .ui_testing(sopts.debugging_opts.ui_testing),\n@@ -1416,7 +1424,7 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n             Box::new(EmitterWriter::stderr(color_config, None, short, false, None, false))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } => {\n-            Box::new(JsonEmitter::basic(pretty, json_rendered, false))\n+            Box::new(JsonEmitter::basic(pretty, json_rendered, None, false))\n         }\n     };\n     let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n@@ -1431,7 +1439,7 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n             Box::new(EmitterWriter::stderr(color_config, None, short, false, None, false))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } => {\n-            Box::new(JsonEmitter::basic(pretty, json_rendered, false))\n+            Box::new(JsonEmitter::basic(pretty, json_rendered, None, false))\n         }\n     };\n     let handler = rustc_errors::Handler::with_emitter(true, None, emitter);"}, {"sha": "60bbdd0495cc4f9d0af6cbd745c38051ca5f9f06", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -822,7 +822,14 @@ pub enum DesugaringKind {\n     OpaqueTy,\n     Async,\n     Await,\n-    ForLoop,\n+    ForLoop(ForLoopLoc),\n+}\n+\n+/// A location in the desugaring of a `for` loop\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+pub enum ForLoopLoc {\n+    Head,\n+    IntoIter,\n }\n \n impl DesugaringKind {\n@@ -835,7 +842,7 @@ impl DesugaringKind {\n             DesugaringKind::QuestionMark => \"operator `?`\",\n             DesugaringKind::TryBlock => \"`try` block\",\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n-            DesugaringKind::ForLoop => \"`for` loop\",\n+            DesugaringKind::ForLoop(_) => \"`for` loop\",\n         }\n     }\n }"}, {"sha": "dcd2e83b747133f85db9ae6c7593024851c08fd0", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -30,8 +30,9 @@ use source_map::SourceMap;\n pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n+pub use hygiene::SyntaxContext;\n use hygiene::Transparency;\n-pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, MacroKind, SyntaxContext};\n+pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind};\n pub mod def_id;\n use def_id::{CrateNum, DefId, LOCAL_CRATE};\n mod span_encoding;"}, {"sha": "7c4048ab223023f3b56bd3671a3043a1bca01131", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -737,7 +737,7 @@ pub fn check_wf_new(tcx: TyCtxt<'_>) {\n     tcx.hir().krate().par_visit_all_item_likes(&visit);\n }\n \n-fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckItemTypesVisitor { tcx });\n }\n "}, {"sha": "b486e3d3536c99f4e0f1e69d62be93f56deb8fff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -55,7 +55,7 @@ struct OnlySelfBounds(bool);\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CollectItemTypesVisitor { tcx }.as_deep_visitor(),"}, {"sha": "77cd1b3de0106723004e428c9aab4773e1efd4be", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -14,7 +14,7 @@ use min_specialization::check_min_specialization;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n@@ -59,11 +59,11 @@ pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n     for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module).to_def_id());\n+        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module));\n     }\n }\n \n-fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let min_specialization = tcx.features().min_specialization;\n     tcx.hir()\n         .visit_item_likes_in_module(module_def_id, &mut ImplWfCheck { tcx, min_specialization });"}, {"sha": "38f202e84accba9b69a3fc303205a9041ff12351", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -193,8 +193,15 @@ pub fn new_handler(\n                 Lrc::new(source_map::SourceMap::new(source_map::FilePathMapping::empty()))\n             });\n             Box::new(\n-                JsonEmitter::stderr(None, source_map, pretty, json_rendered, false)\n-                    .ui_testing(debugging_opts.ui_testing),\n+                JsonEmitter::stderr(\n+                    None,\n+                    source_map,\n+                    pretty,\n+                    json_rendered,\n+                    debugging_opts.terminal_width,\n+                    false,\n+                )\n+                .ui_testing(debugging_opts.ui_testing),\n             )\n         }\n     };"}, {"sha": "17f890375f843bb8ce212e894be57b91f0199ee2", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -1033,8 +1033,16 @@ impl Metadata {\n     /// [`is_dir`], and will be false for symlink metadata\n     /// obtained from [`symlink_metadata`].\n     ///\n+    /// When the goal is simply to read from (or write to) the source, the most\n+    /// reliable way to test the source can be read (or written to) is to open\n+    /// it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n+    /// a Unix-like system for example. See [`File::open`] or\n+    /// [`OpenOptions::open`] for more information.\n+    ///\n     /// [`is_dir`]: struct.Metadata.html#method.is_dir\n     /// [`symlink_metadata`]: fn.symlink_metadata.html\n+    /// [`File::open`]: struct.File.html#method.open\n+    /// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n     ///\n     /// # Examples\n     ///\n@@ -1307,8 +1315,16 @@ impl FileType {\n     /// [`is_dir`] and [`is_symlink`]; only zero or one of these\n     /// tests may pass.\n     ///\n+    /// When the goal is simply to read from (or write to) the source, the most\n+    /// reliable way to test the source can be read (or written to) is to open\n+    /// it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n+    /// a Unix-like system for example. See [`File::open`] or\n+    /// [`OpenOptions::open`] for more information.\n+    ///\n     /// [`is_dir`]: struct.FileType.html#method.is_dir\n     /// [`is_symlink`]: struct.FileType.html#method.is_symlink\n+    /// [`File::open`]: struct.File.html#method.open\n+    /// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n     ///\n     /// # Examples\n     ///\n@@ -1429,7 +1445,10 @@ impl DirEntry {\n     /// Returns the metadata for the file that this entry points at.\n     ///\n     /// This function will not traverse symlinks if this entry points at a\n-    /// symlink.\n+    /// symlink. To traverse symlinks use [`fs::metadata`] or [`fs::File::metadata`].\n+    ///\n+    /// [`fs::metadata`]: fn.metadata.html\n+    /// [`fs::File::metadata`]: struct.File.html#method.metadata\n     ///\n     /// # Platform-specific behavior\n     ///"}, {"sha": "f14a9ff72f62f473ef8437ed5c63650cbab30785", "filename": "src/libstd/path.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -2503,11 +2503,20 @@ impl Path {\n     /// # See Also\n     ///\n     /// This is a convenience function that coerces errors to false. If you want to\n-    /// check errors, call [fs::metadata] and handle its Result. Then call\n-    /// [fs::Metadata::is_file] if it was Ok.\n-    ///\n-    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n-    /// [fs::Metadata::is_file]: ../../std/fs/struct.Metadata.html#method.is_file\n+    /// check errors, call [`fs::metadata`] and handle its Result. Then call\n+    /// [`fs::Metadata::is_file`] if it was Ok.\n+    ///\n+    /// When the goal is simply to read from (or write to) the source, the most\n+    /// reliable way to test the source can be read (or written to) is to open\n+    /// it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n+    /// a Unix-like system for example. See [`File::open`] or\n+    /// [`OpenOptions::open`] for more information.\n+    ///\n+    /// [`fs::metadata`]: ../../std/fs/fn.metadata.html\n+    /// [`fs::Metadata`]: ../../std/fs/struct.Metadata.html\n+    /// [`fs::Metadata::is_file`]: ../../std/fs/struct.Metadata.html#method.is_file\n+    /// [`File::open`]: ../../std/fs/struct.File.html#method.open\n+    /// [`OpenOptions::open`]: ../../std/fs/struct.OpenOptions.html#method.open\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn is_file(&self) -> bool {\n         fs::metadata(self).map(|m| m.is_file()).unwrap_or(false)"}, {"sha": "41b14714842fd0f9d588621f1057005e49e0d037", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 93, "deletions": 26, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -49,8 +49,10 @@ typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef;\n \n DEFINE_STDCXX_CONVERSION_FUNCTIONS(Pass, LLVMPassRef)\n DEFINE_STDCXX_CONVERSION_FUNCTIONS(TargetMachine, LLVMTargetMachineRef)\n+#if LLVM_VERSION_LT(11, 0)\n DEFINE_STDCXX_CONVERSION_FUNCTIONS(PassManagerBuilder,\n                                    LLVMPassManagerBuilderRef)\n+#endif\n \n extern \"C\" void LLVMInitializePasses() {\n   PassRegistry &Registry = *PassRegistry::getPassRegistry();\n@@ -343,17 +345,17 @@ enum class LLVMRustPassBuilderOptLevel {\n static PassBuilder::OptimizationLevel fromRust(LLVMRustPassBuilderOptLevel Level) {\n   switch (Level) {\n   case LLVMRustPassBuilderOptLevel::O0:\n-    return PassBuilder::O0;\n+    return PassBuilder::OptimizationLevel::O0;\n   case LLVMRustPassBuilderOptLevel::O1:\n-    return PassBuilder::O1;\n+    return PassBuilder::OptimizationLevel::O1;\n   case LLVMRustPassBuilderOptLevel::O2:\n-    return PassBuilder::O2;\n+    return PassBuilder::OptimizationLevel::O2;\n   case LLVMRustPassBuilderOptLevel::O3:\n-    return PassBuilder::O3;\n+    return PassBuilder::OptimizationLevel::O3;\n   case LLVMRustPassBuilderOptLevel::Os:\n-    return PassBuilder::Os;\n+    return PassBuilder::OptimizationLevel::Os;\n   case LLVMRustPassBuilderOptLevel::Oz:\n-    return PassBuilder::Oz;\n+    return PassBuilder::OptimizationLevel::Oz;\n   default:\n     report_fatal_error(\"Bad PassBuilderOptLevel.\");\n   }\n@@ -796,8 +798,13 @@ LLVMRustOptimizeWithNewPassManager(\n   // We manually collect pipeline callbacks so we can apply them at O0, where the\n   // PassBuilder does not create a pipeline.\n   std::vector<std::function<void(ModulePassManager &)>> PipelineStartEPCallbacks;\n+#if LLVM_VERSION_GE(11, 0)\n+  std::vector<std::function<void(ModulePassManager &, PassBuilder::OptimizationLevel)>>\n+      OptimizerLastEPCallbacks;\n+#else\n   std::vector<std::function<void(FunctionPassManager &, PassBuilder::OptimizationLevel)>>\n       OptimizerLastEPCallbacks;\n+#endif\n \n   if (VerifyIR) {\n     PipelineStartEPCallbacks.push_back([VerifyIR](ModulePassManager &MPM) {\n@@ -811,6 +818,14 @@ LLVMRustOptimizeWithNewPassManager(\n           SanitizerOptions->SanitizeMemoryTrackOrigins,\n           SanitizerOptions->SanitizeMemoryRecover,\n           /*CompileKernel=*/false);\n+#if LLVM_VERSION_GE(11, 0)\n+      OptimizerLastEPCallbacks.push_back(\n+        [Options](ModulePassManager &MPM, PassBuilder::OptimizationLevel Level) {\n+          MPM.addPass(MemorySanitizerPass(Options));\n+          MPM.addPass(createModuleToFunctionPassAdaptor(MemorySanitizerPass(Options)));\n+        }\n+      );\n+#else\n #if LLVM_VERSION_GE(10, 0)\n       PipelineStartEPCallbacks.push_back([Options](ModulePassManager &MPM) {\n         MPM.addPass(MemorySanitizerPass(Options));\n@@ -821,9 +836,18 @@ LLVMRustOptimizeWithNewPassManager(\n           FPM.addPass(MemorySanitizerPass(Options));\n         }\n       );\n+#endif\n     }\n \n     if (SanitizerOptions->SanitizeThread) {\n+#if LLVM_VERSION_GE(11, 0)\n+      OptimizerLastEPCallbacks.push_back(\n+        [](ModulePassManager &MPM, PassBuilder::OptimizationLevel Level) {\n+          MPM.addPass(ThreadSanitizerPass());\n+          MPM.addPass(createModuleToFunctionPassAdaptor(ThreadSanitizerPass()));\n+        }\n+      );\n+#else\n #if LLVM_VERSION_GE(10, 0)\n       PipelineStartEPCallbacks.push_back([](ModulePassManager &MPM) {\n         MPM.addPass(ThreadSanitizerPass());\n@@ -834,9 +858,22 @@ LLVMRustOptimizeWithNewPassManager(\n           FPM.addPass(ThreadSanitizerPass());\n         }\n       );\n+#endif\n     }\n \n     if (SanitizerOptions->SanitizeAddress) {\n+#if LLVM_VERSION_GE(11, 0)\n+      OptimizerLastEPCallbacks.push_back(\n+        [SanitizerOptions](ModulePassManager &MPM, PassBuilder::OptimizationLevel Level) {\n+          MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n+          MPM.addPass(ModuleAddressSanitizerPass(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeAddressRecover));\n+          MPM.addPass(createModuleToFunctionPassAdaptor(AddressSanitizerPass(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeAddressRecover,\n+              /*UseAfterScope=*/true)));\n+        }\n+      );\n+#else\n       PipelineStartEPCallbacks.push_back([&](ModulePassManager &MPM) {\n         MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n       });\n@@ -853,21 +890,27 @@ LLVMRustOptimizeWithNewPassManager(\n               /*CompileKernel=*/false, SanitizerOptions->SanitizeAddressRecover));\n         }\n       );\n+#endif\n     }\n   }\n \n   ModulePassManager MPM(DebugPassManager);\n   if (!NoPrepopulatePasses) {\n-    if (OptLevel == PassBuilder::O0) {\n+    if (OptLevel == PassBuilder::OptimizationLevel::O0) {\n       for (const auto &C : PipelineStartEPCallbacks)\n         C(MPM);\n \n+#if LLVM_VERSION_GE(11, 0)\n+      for (const auto &C : OptimizerLastEPCallbacks)\n+        C(MPM, OptLevel);\n+#else\n       if (!OptimizerLastEPCallbacks.empty()) {\n         FunctionPassManager FPM(DebugPassManager);\n         for (const auto &C : OptimizerLastEPCallbacks)\n           C(FPM, OptLevel);\n         MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n       }\n+#endif\n \n       MPM.addPass(AlwaysInlinerPass(EmitLifetimeMarkers));\n \n@@ -892,12 +935,17 @@ LLVMRustOptimizeWithNewPassManager(\n         break;\n       case LLVMRustOptStage::PreLinkThinLTO:\n         MPM = PB.buildThinLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);\n+#if LLVM_VERSION_GE(11, 0)\n+        for (const auto &C : OptimizerLastEPCallbacks)\n+          C(MPM, OptLevel);\n+#else\n         if (!OptimizerLastEPCallbacks.empty()) {\n           FunctionPassManager FPM(DebugPassManager);\n           for (const auto &C : OptimizerLastEPCallbacks)\n             C(FPM, OptLevel);\n           MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n         }\n+#endif\n         break;\n       case LLVMRustOptStage::PreLinkFatLTO:\n         MPM = PB.buildLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);\n@@ -994,10 +1042,10 @@ class RustAssemblyAnnotationWriter : public AssemblyAnnotationWriter {\n     const Value *Value;\n     if (const CallInst *CI = dyn_cast<CallInst>(I)) {\n       Name = \"call\";\n-      Value = CI->getCalledValue();\n+      Value = CI->getCalledOperand();\n     } else if (const InvokeInst* II = dyn_cast<InvokeInst>(I)) {\n       Name = \"invoke\";\n-      Value = II->getCalledValue();\n+      Value = II->getCalledOperand();\n     } else {\n       // Could demangle more operations, e. g.\n       // `store %place, @function`.\n@@ -1335,10 +1383,33 @@ LLVMRustFreeThinLTOData(LLVMRustThinLTOData *Data) {\n // `ProcessThinLTOModule` function. Here they're split up into separate steps\n // so rustc can save off the intermediate bytecode between each step.\n \n+#if LLVM_VERSION_GE(11, 0)\n+static bool\n+clearDSOLocalOnDeclarations(Module &Mod, TargetMachine &TM) {\n+  // When linking an ELF shared object, dso_local should be dropped. We\n+  // conservatively do this for -fpic.\n+  bool ClearDSOLocalOnDeclarations =\n+      TM.getTargetTriple().isOSBinFormatELF() &&\n+      TM.getRelocationModel() != Reloc::Static &&\n+      Mod.getPIELevel() == PIELevel::Default;\n+  return ClearDSOLocalOnDeclarations;\n+}\n+#endif\n+\n extern \"C\" bool\n-LLVMRustPrepareThinLTORename(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+LLVMRustPrepareThinLTORename(const LLVMRustThinLTOData *Data, LLVMModuleRef M,\n+                             LLVMTargetMachineRef TM) {\n   Module &Mod = *unwrap(M);\n-  if (renameModuleForThinLTO(Mod, Data->Index)) {\n+  TargetMachine &Target = *unwrap(TM);\n+\n+#if LLVM_VERSION_GE(11, 0)\n+  bool ClearDSOLocal = clearDSOLocalOnDeclarations(Mod, Target);\n+  bool error = renameModuleForThinLTO(Mod, Data->Index, ClearDSOLocal);\n+#else\n+  bool error = renameModuleForThinLTO(Mod, Data->Index);\n+#endif\n+\n+  if (error) {\n     LLVMRustSetLastError(\"renameModuleForThinLTO failed\");\n     return false;\n   }\n@@ -1362,8 +1433,10 @@ LLVMRustPrepareThinLTOInternalize(const LLVMRustThinLTOData *Data, LLVMModuleRef\n }\n \n extern \"C\" bool\n-LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n+LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M,\n+                             LLVMTargetMachineRef TM) {\n   Module &Mod = *unwrap(M);\n+  TargetMachine &Target = *unwrap(TM);\n \n   const auto &ImportList = Data->ImportLists.lookup(Mod.getModuleIdentifier());\n   auto Loader = [&](StringRef Identifier) {\n@@ -1399,7 +1472,12 @@ LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n \n     return MOrErr;\n   };\n+#if LLVM_VERSION_GE(11, 0)\n+  bool ClearDSOLocal = clearDSOLocalOnDeclarations(Mod, Target);\n+  FunctionImporter Importer(Data->Index, Loader, ClearDSOLocal);\n+#else\n   FunctionImporter Importer(Data->Index, Loader);\n+#endif\n   Expected<bool> Result = Importer.importFunctions(Mod, ImportList);\n   if (!Result) {\n     LLVMRustSetLastError(toString(Result.takeError()).c_str());\n@@ -1558,22 +1636,11 @@ LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod, DICompileUnit *Unit) {\n   }\n \n   // Use LLVM's built-in `DebugInfoFinder` to find a bunch of debuginfo and\n-  // process it recursively. Note that we specifically iterate over instructions\n-  // to ensure we feed everything into it.\n+  // process it recursively. Note that we used to specifically iterate over\n+  // instructions to ensure we feed everything into it, but `processModule`\n+  // started doing this the same way in LLVM 7 (commit d769eb36ab2b8).\n   DebugInfoFinder Finder;\n   Finder.processModule(*M);\n-  for (Function &F : M->functions()) {\n-    for (auto &FI : F) {\n-      for (Instruction &BI : FI) {\n-        if (auto Loc = BI.getDebugLoc())\n-          Finder.processLocation(*M, Loc);\n-        if (auto DVI = dyn_cast<DbgValueInst>(&BI))\n-          Finder.processValue(*M, DVI);\n-        if (auto DDI = dyn_cast<DbgDeclareInst>(&BI))\n-          Finder.processDeclare(*M, DDI);\n-      }\n-    }\n-  }\n \n   // After we've found all our debuginfo, rewrite all subprograms to point to\n   // the same `DICompileUnit`."}, {"sha": "063b6acc604ea543bf828ef7ca428157e9892aeb", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -1,5 +1,4 @@\n #include \"rustllvm.h\"\n-#include \"llvm/IR/CallSite.h\"\n #include \"llvm/IR/DebugInfoMetadata.h\"\n #include \"llvm/IR/DiagnosticInfo.h\"\n #include \"llvm/IR/DiagnosticPrinter.h\"\n@@ -214,50 +213,50 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n \n extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned Index,\n                                              LLVMRustAttribute RustAttr) {\n-  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  CallBase *Call = unwrap<CallBase>(Instr);\n   Attribute Attr = Attribute::get(Call->getContext(), fromRust(RustAttr));\n-  Call.addAttribute(Index, Attr);\n+  Call->addAttribute(Index, Attr);\n }\n \n extern \"C\" void LLVMRustAddAlignmentCallSiteAttr(LLVMValueRef Instr,\n                                                  unsigned Index,\n                                                  uint32_t Bytes) {\n-  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  CallBase *Call = unwrap<CallBase>(Instr);\n   AttrBuilder B;\n   B.addAlignmentAttr(Bytes);\n-  Call.setAttributes(Call.getAttributes().addAttributes(\n+  Call->setAttributes(Call->getAttributes().addAttributes(\n       Call->getContext(), Index, B));\n }\n \n extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n                                                        unsigned Index,\n                                                        uint64_t Bytes) {\n-  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  CallBase *Call = unwrap<CallBase>(Instr);\n   AttrBuilder B;\n   B.addDereferenceableAttr(Bytes);\n-  Call.setAttributes(Call.getAttributes().addAttributes(\n+  Call->setAttributes(Call->getAttributes().addAttributes(\n       Call->getContext(), Index, B));\n }\n \n extern \"C\" void LLVMRustAddDereferenceableOrNullCallSiteAttr(LLVMValueRef Instr,\n                                                              unsigned Index,\n                                                              uint64_t Bytes) {\n-  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  CallBase *Call = unwrap<CallBase>(Instr);\n   AttrBuilder B;\n   B.addDereferenceableOrNullAttr(Bytes);\n-  Call.setAttributes(Call.getAttributes().addAttributes(\n+  Call->setAttributes(Call->getAttributes().addAttributes(\n       Call->getContext(), Index, B));\n }\n \n extern \"C\" void LLVMRustAddByValCallSiteAttr(LLVMValueRef Instr, unsigned Index,\n                                              LLVMTypeRef Ty) {\n-  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  CallBase *Call = unwrap<CallBase>(Instr);\n #if LLVM_VERSION_GE(9, 0)\n   Attribute Attr = Attribute::getWithByValType(Call->getContext(), unwrap(Ty));\n #else\n   Attribute Attr = Attribute::get(Call->getContext(), Attribute::ByVal);\n #endif\n-  Call.addAttribute(Index, Attr);\n+  Call->addAttribute(Index, Attr);\n }\n \n extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,\n@@ -336,20 +335,24 @@ extern \"C\" void LLVMRustSetHasUnsafeAlgebra(LLVMValueRef V) {\n extern \"C\" LLVMValueRef\n LLVMRustBuildAtomicLoad(LLVMBuilderRef B, LLVMValueRef Source, const char *Name,\n                         LLVMAtomicOrdering Order) {\n-  LoadInst *LI = new LoadInst(unwrap(Source));\n+  Value *Ptr = unwrap(Source);\n+  Type *Ty = Ptr->getType()->getPointerElementType();\n+  LoadInst *LI = unwrap(B)->CreateLoad(Ty, Ptr, Name);\n   LI->setAtomic(fromRust(Order));\n-  return wrap(unwrap(B)->Insert(LI, Name));\n+  return wrap(LI);\n }\n \n extern \"C\" LLVMValueRef LLVMRustBuildAtomicStore(LLVMBuilderRef B,\n                                                  LLVMValueRef V,\n                                                  LLVMValueRef Target,\n                                                  LLVMAtomicOrdering Order) {\n-  StoreInst *SI = new StoreInst(unwrap(V), unwrap(Target));\n+  StoreInst *SI = unwrap(B)->CreateStore(unwrap(V), unwrap(Target));\n   SI->setAtomic(fromRust(Order));\n-  return wrap(unwrap(B)->Insert(SI));\n+  return wrap(SI);\n }\n \n+// FIXME: Use the C-API LLVMBuildAtomicCmpXchg and LLVMSetWeak\n+// once we raise our minimum support to LLVM 10.\n extern \"C\" LLVMValueRef\n LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Target,\n                            LLVMValueRef Old, LLVMValueRef Source,\n@@ -965,8 +968,14 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateUnionType(\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateTemplateTypeParameter(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n     const char *Name, size_t NameLen, LLVMMetadataRef Ty) {\n+#if LLVM_VERSION_GE(11, 0)\n+  bool IsDefault = false; // FIXME: should we ever set this true?\n+  return wrap(Builder->createTemplateTypeParameter(\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), unwrapDI<DIType>(Ty), IsDefault));\n+#else\n   return wrap(Builder->createTemplateTypeParameter(\n       unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), unwrapDI<DIType>(Ty)));\n+#endif\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateNameSpace(\n@@ -1227,12 +1236,23 @@ extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n     return LLVMArrayTypeKind;\n   case Type::PointerTyID:\n     return LLVMPointerTypeKind;\n+#if LLVM_VERSION_GE(11, 0)\n+  case Type::FixedVectorTyID:\n+    return LLVMVectorTypeKind;\n+#else\n   case Type::VectorTyID:\n     return LLVMVectorTypeKind;\n+#endif\n   case Type::X86_MMXTyID:\n     return LLVMX86_MMXTypeKind;\n   case Type::TokenTyID:\n     return LLVMTokenTypeKind;\n+#if LLVM_VERSION_GE(11, 0)\n+  case Type::ScalableVectorTyID:\n+    return LLVMScalableVectorTypeKind;\n+  case Type::BFloatTyID:\n+    return LLVMBFloatTypeKind;\n+#endif\n   }\n   report_fatal_error(\"Unhandled TypeID.\");\n }\n@@ -1359,10 +1379,12 @@ extern \"C\" void LLVMRustFreeOperandBundleDef(OperandBundleDef *Bundle) {\n extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n                                           LLVMValueRef *Args, unsigned NumArgs,\n                                           OperandBundleDef *Bundle) {\n+  Value *Callee = unwrap(Fn);\n+  FunctionType *FTy = cast<FunctionType>(Callee->getType()->getPointerElementType());\n   unsigned Len = Bundle ? 1 : 0;\n   ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateCall(\n-      unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles));\n+      FTy, Callee, makeArrayRef(unwrap(Args), NumArgs), Bundles));\n }\n \n extern \"C\" LLVMValueRef LLVMRustGetInstrprofIncrementIntrinsic(LLVMModuleRef M) {\n@@ -1422,9 +1444,11 @@ LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n                     unsigned NumArgs, LLVMBasicBlockRef Then,\n                     LLVMBasicBlockRef Catch, OperandBundleDef *Bundle,\n                     const char *Name) {\n+  Value *Callee = unwrap(Fn);\n+  FunctionType *FTy = cast<FunctionType>(Callee->getType()->getPointerElementType());\n   unsigned Len = Bundle ? 1 : 0;\n   ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n-  return wrap(unwrap(B)->CreateInvoke(unwrap(Fn), unwrap(Then), unwrap(Catch),\n+  return wrap(unwrap(B)->CreateInvoke(FTy, Callee, unwrap(Then), unwrap(Catch),\n                                       makeArrayRef(unwrap(Args), NumArgs),\n                                       Bundles, Name));\n }"}, {"sha": "433d32abd37c65b01de9d76180cce9209b564e1a", "filename": "src/test/codegen/sanitizer-recover.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-recover.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -27,17 +27,17 @@\n // ASAN:               }\n //\n // MSAN-LABEL: define i32 @penguin(\n-// MSAN:         call void @__msan_warning_noreturn()\n+// MSAN:         call void @__msan_warning{{(_with_origin_noreturn\\(i32 0\\)|_noreturn\\(\\))}}\n // MSAN:         unreachable\n // MSAN:       }\n //\n // MSAN-RECOVER-LABEL: define i32 @penguin(\n-// MSAN-RECOVER:         call void @__msan_warning()\n+// MSAN-RECOVER:         call void @__msan_warning{{(_with_origin\\(i32 0\\)|\\(\\))}}\n // MSAN-RECOVER-NOT:     unreachable\n // MSAN-RECOVER:       }\n //\n // MSAN-RECOVER-LTO-LABEL: define i32 @penguin(\n-// MSAN-RECOVER-LTO:          call void @__msan_warning()\n+// MSAN-RECOVER-LTO:          call void @__msan_warning{{(_with_origin\\(i32 0\\)|\\(\\))}}\n // MSAN-RECOVER-LTO-NOT:      unreachable\n // MSAN-RECOVER-LTO:       }\n //"}, {"sha": "86d459bf084b1f6827c92525f8dc317f518ac7b9", "filename": "src/test/ui/async-await/async-error-span.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -5,7 +5,7 @@\n use std::future::Future;\n \n fn get_future() -> impl Future<Output = ()> {\n-//~^ ERROR the trait bound `(): std::future::Future` is not satisfied\n+//~^ ERROR `()` is not a future\n     panic!()\n }\n "}, {"sha": "9523f040aa8cd91c3526600b6d207913be08228a", "filename": "src/test/ui/async-await/async-error-span.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -1,12 +1,13 @@\n-error[E0277]: the trait bound `(): std::future::Future` is not satisfied\n+error[E0277]: `()` is not a future\n   --> $DIR/async-error-span.rs:7:20\n    |\n LL | fn get_future() -> impl Future<Output = ()> {\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `()`\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not a future\n LL |\n LL |     panic!()\n    |     -------- this returned value is of type `!`\n    |\n+   = help: the trait `std::future::Future` is not implemented for `()`\n    = note: the return type of a function must have a statically known size\n \n error[E0698]: type inside `async fn` body must be known in this context"}, {"sha": "34d12db8806dc0845e77096f283c0804e73d9579", "filename": "src/test/ui/async-await/issue-70594.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -6,7 +6,7 @@ async fn fun() {\n     //~| error: `.await` is not allowed in a `const`\n     //~| error: `loop` is not allowed in a `const`\n     //~| error: `.await` is not allowed in a `const`\n-    //~| error: the trait bound `(): std::future::Future` is not satisfied\n+    //~| error: `()` is not a future\n }\n \n fn main() {}"}, {"sha": "1b7abe317222d982c6eb8d276d03769af2394746", "filename": "src/test/ui/async-await/issue-70594.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -27,12 +27,13 @@ error[E0744]: `.await` is not allowed in a `const`\n LL |     [1; ().await];\n    |         ^^^^^^^^\n \n-error[E0277]: the trait bound `(): std::future::Future` is not satisfied\n+error[E0277]: `()` is not a future\n   --> $DIR/issue-70594.rs:4:9\n    |\n LL |     [1; ().await];\n-   |         ^^^^^^^^ the trait `std::future::Future` is not implemented for `()`\n+   |         ^^^^^^^^ `()` is not a future\n    |\n+   = help: the trait `std::future::Future` is not implemented for `()`\n    = note: required by `std::future::Future::poll`\n \n error: aborting due to 5 previous errors"}, {"sha": "e3ba74a03c898c933470709ef1097adb569faad0", "filename": "src/test/ui/async-await/issues/issue-62009-1.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -27,12 +27,13 @@ LL | fn main() {\n LL |     (|_| 2333).await;\n    |     ^^^^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n-error[E0277]: the trait bound `[closure@$DIR/issue-62009-1.rs:12:5: 12:15]: std::future::Future` is not satisfied\n+error[E0277]: `[closure@$DIR/issue-62009-1.rs:12:5: 12:15]` is not a future\n   --> $DIR/issue-62009-1.rs:12:5\n    |\n LL |     (|_| 2333).await;\n-   |     ^^^^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `[closure@$DIR/issue-62009-1.rs:12:5: 12:15]`\n+   |     ^^^^^^^^^^^^^^^^ `[closure@$DIR/issue-62009-1.rs:12:5: 12:15]` is not a future\n    |\n+   = help: the trait `std::future::Future` is not implemented for `[closure@$DIR/issue-62009-1.rs:12:5: 12:15]`\n    = note: required by `std::future::Future::poll`\n \n error: aborting due to 4 previous errors"}, {"sha": "addc8a0efe1aa51c0cc1b9521507b2571a2a25ee", "filename": "src/test/ui/binop/binop-consume-args.stderr", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -4,10 +4,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs + rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn add<A: Add<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -35,10 +40,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs - rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn sub(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn sub<A: Sub<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -66,10 +76,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs * rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn mul(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn mul<A: Mul<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -97,10 +112,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs / rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn div(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn div<A: Div<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -128,10 +148,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs % rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn rem(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn rem<A: Rem<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -159,10 +184,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs & rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitand(self, rhs: Rhs) -> Self::Output;\n+   |               ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitand<A: BitAnd<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -190,10 +220,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                     --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs | rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitor(self, rhs: Rhs) -> Self::Output;\n+   |              ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitor<A: BitOr<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -221,10 +256,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs ^ rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitxor(self, rhs: Rhs) -> Self::Output;\n+   |               ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitxor<A: BitXor<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -252,10 +292,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs << rhs;\n-   |     --- value moved here\n+   |     ---------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn shl(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn shl<A: Shl<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -283,10 +328,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs >> rhs;\n-   |     --- value moved here\n+   |     ---------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn shr(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn shr<A: Shr<B, Output=()> + Copy, B>(lhs: A, rhs: B) {"}, {"sha": "97b70efe20e79d25d468c52c36e2f011b92e92cc", "filename": "src/test/ui/binop/binop-move-semantics.stderr", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -1,14 +1,21 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/binop-move-semantics.rs:8:5\n    |\n-LL | fn double_move<T: Add<Output=()>>(x: T) {\n-   |                                   - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n-LL |     x\n-   |     - value moved here\n-LL |     +\n-LL |     x;\n-   |     ^ value used here after move\n+LL |   fn double_move<T: Add<Output=()>>(x: T) {\n+   |                                     - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+LL | /     x\n+LL | |     +\n+LL | |     x;\n+   | |     ^\n+   | |     |\n+   | |_____value used here after move\n+   |       `x` moved due to usage in operator\n+   |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n    |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn double_move<T: Add<Output=()> + Copy>(x: T) {"}, {"sha": "bc1721944fbbb6de8b7b1da9112928d3782de7fe", "filename": "src/test/ui/borrowck/borrowck-unboxed-closures.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -22,10 +22,15 @@ error[E0382]: use of moved value: `f`\n LL | fn c<F:FnOnce(isize, isize) -> isize>(f: F) {\n    |                                       - move occurs because `f` has type `F`, which does not implement the `Copy` trait\n LL |     f(1, 2);\n-   |     - value moved here\n+   |     ------- `f` moved due to this call\n LL |     f(1, 2);\n    |     ^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/borrowck-unboxed-closures.rs:11:5\n+   |\n+LL |     f(1, 2);\n+   |     ^\n help: consider further restricting this bound\n    |\n LL | fn c<F:FnOnce(isize, isize) -> isize + Copy>(f: F) {"}, {"sha": "896bb6dc6bee8a8cfca5c73ef4d84479b85f5bc6", "filename": "src/test/ui/closure_context/issue-42065.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `debug_dump_dict`\n   --> $DIR/issue-42065.rs:11:5\n    |\n LL |     debug_dump_dict();\n-   |     --------------- value moved here\n+   |     ----------------- `debug_dump_dict` moved due to this call\n LL |     debug_dump_dict();\n    |     ^^^^^^^^^^^^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `di\n    |\n LL |         for (key, value) in dict {\n    |                             ^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/issue-42065.rs:10:5\n+   |\n+LL |     debug_dump_dict();\n+   |     ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "614e69e89f6ec539a91349c44ddefc6371fd082e", "filename": "src/test/ui/codemap_tests/tab_3.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -4,10 +4,16 @@ error[E0382]: borrow of moved value: `some_vec`\n LL |     let some_vec = vec![\"hi\"];\n    |         -------- move occurs because `some_vec` has type `std::vec::Vec<&str>`, which does not implement the `Copy` trait\n LL |     some_vec.into_iter();\n-   |     -------- value moved here\n+   |              ----------- `some_vec` moved due to this method call\n LL |     {\n LL |         println!(\"{:?}\", some_vec);\n    |                          ^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `some_vec`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "fecba721ac9fdeb101053fd43ce0b7e2789ee00e", "filename": "src/test/ui/issues-71798.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues-71798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues-71798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -1,5 +1,5 @@\n fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n-    *x //~^ ERROR the trait bound `u32: std::future::Future` is not satisfied\n+    *x //~^ ERROR `u32` is not a future\n }\n \n fn main() {"}, {"sha": "b3b29a726413156e284f85931100cdb5e688fba3", "filename": "src/test/ui/issues-71798.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues-71798.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues-71798.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -4,14 +4,15 @@ error[E0425]: cannot find value `u` in this scope\n LL |     let _ = test_ref & u;\n    |                        ^ not found in this scope\n \n-error[E0277]: the trait bound `u32: std::future::Future` is not satisfied\n+error[E0277]: `u32` is not a future\n   --> $DIR/issues-71798.rs:1:25\n    |\n LL | fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `u32`\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `u32` is not a future\n LL |     *x\n    |     -- this returned value is of type `u32`\n    |\n+   = help: the trait `std::future::Future` is not implemented for `u32`\n    = note: the return type of a function must have a statically known size\n \n error: aborting due to 2 previous errors"}, {"sha": "b759aa45e3eb707d2a8074447cb22038cf2980bf", "filename": "src/test/ui/issues/issue-12127.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -2,10 +2,15 @@ error[E0382]: use of moved value: `f`\n   --> $DIR/issue-12127.rs:11:9\n    |\n LL |         f();\n-   |         - value moved here\n+   |         --- `f` moved due to this call\n LL |         f();\n    |         ^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/issue-12127.rs:10:9\n+   |\n+LL |         f();\n+   |         ^\n    = note: move occurs because `f` has type `[closure@$DIR/issue-12127.rs:8:24: 8:41 x:std::boxed::Box<isize>]`, which does not implement the `Copy` trait\n \n error: aborting due to previous error"}, {"sha": "4fb805b37e03f02330f2bc77637b0a231b539b80", "filename": "src/test/ui/issues/issue-33941.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -3,4 +3,5 @@ use std::collections::HashMap;\n fn main() {\n     for _ in HashMap::new().iter().cloned() {} //~ ERROR type mismatch\n     //~^ ERROR type mismatch\n+    //~| ERROR type mismatch\n }"}, {"sha": "20335d2cdd684c6b6d681ce29790b4106a22c2fc", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -17,6 +17,16 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n            found reference `&_`\n    = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::iter::Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n \n-error: aborting due to 2 previous errors\n+error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as std::iter::Iterator>::Item == &_`\n+  --> $DIR/issue-33941.rs:4:14\n+   |\n+LL |     for _ in HashMap::new().iter().cloned() {}\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found reference\n+   |\n+   = note:  expected tuple `(&_, &_)`\n+           found reference `&_`\n+   = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::iter::Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0271`."}, {"sha": "b4cc1a0aa7eb2bf5dd8fbdbc2c02d74094b714ce", "filename": "src/test/ui/issues/issue-34721.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -5,14 +5,19 @@ LL |     pub fn baz<T: Foo>(x: T) -> T {\n    |                        - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n LL |         if 0 == 1 {\n LL |             bar::bar(x.zero())\n-   |                      - value moved here\n+   |                        ------ `x` moved due to this method call\n LL |         } else {\n LL |             x.zero()\n-   |             - value moved here\n+   |               ------ `x` moved due to this method call\n LL |         };\n LL |         x.zero()\n    |         ^ value used here after move\n    |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $DIR/issue-34721.rs:4:13\n+   |\n+LL |     fn zero(self) -> Self;\n+   |             ^^^^\n help: consider further restricting this bound\n    |\n LL |     pub fn baz<T: Foo + Copy>(x: T) -> T {"}, {"sha": "ba43f2d33ee4463058c536652a9dab4aed06fa2e", "filename": "src/test/ui/issues/issue-61108.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -6,11 +6,17 @@ LL |     let mut bad_letters = vec!['e', 't', 'o', 'i'];\n LL |     for l in bad_letters {\n    |              -----------\n    |              |\n-   |              value moved here\n+   |              `bad_letters` moved due to this implicit call to `.into_iter()`\n    |              help: consider borrowing to avoid moving into the for loop: `&bad_letters`\n ...\n LL |     bad_letters.push('s');\n    |     ^^^^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `bad_letters`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2c337bae130171454088824186eee57106c70202", "filename": "src/test/ui/issues/issue-64559.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -6,12 +6,18 @@ LL |     let orig = vec![true];\n LL |     for _val in orig {}\n    |                 ----\n    |                 |\n-   |                 value moved here\n+   |                 `orig` moved due to this implicit call to `.into_iter()`\n    |                 help: consider borrowing to avoid moving into the for loop: `&orig`\n LL |     let _closure = || orig;\n    |                    ^^ ---- use occurs due to use in closure\n    |                    |\n    |                    value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `orig`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "6107f53fa19606b20fcfa967a3401fb4cf2310f1", "filename": "src/test/ui/moves/move-fn-self-receiver.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -0,0 +1,74 @@\n+use std::pin::Pin;\n+use std::rc::Rc;\n+use std::ops::Add;\n+\n+struct Foo;\n+\n+impl Add for Foo {\n+    type Output = ();\n+    fn add(self, _rhs: Self) -> () {}\n+}\n+\n+impl Foo {\n+    fn use_self(self) {}\n+    fn use_box_self(self: Box<Self>) {}\n+    fn use_pin_box_self(self: Pin<Box<Self>>) {}\n+    fn use_rc_self(self: Rc<Self>) {}\n+    fn use_mut_self(&mut self) -> &mut Self { self }\n+}\n+\n+struct Container(Vec<bool>);\n+\n+impl Container {\n+    fn custom_into_iter(self) -> impl Iterator<Item = bool> {\n+        self.0.into_iter()\n+    }\n+}\n+\n+fn move_out(val: Container) {\n+    val.0.into_iter().next();\n+    val.0; //~ ERROR use of moved\n+\n+    let foo = Foo;\n+    foo.use_self();\n+    foo; //~ ERROR use of moved\n+\n+    let second_foo = Foo;\n+    second_foo.use_self();\n+    second_foo; //~ ERROR use of moved\n+\n+    let boxed_foo = Box::new(Foo);\n+    boxed_foo.use_box_self();\n+    boxed_foo; //~ ERROR use of moved\n+\n+    let pin_box_foo = Box::pin(Foo);\n+    pin_box_foo.use_pin_box_self();\n+    pin_box_foo; //~ ERROR use of moved\n+\n+    let mut mut_foo = Foo;\n+    let ret = mut_foo.use_mut_self();\n+    mut_foo; //~ ERROR cannot move out\n+    ret;\n+\n+    let rc_foo = Rc::new(Foo);\n+    rc_foo.use_rc_self();\n+    rc_foo; //~ ERROR use of moved\n+\n+    let foo_add = Foo;\n+    foo_add + Foo;\n+    foo_add; //~ ERROR use of moved\n+\n+    let implicit_into_iter = vec![true];\n+    for _val in implicit_into_iter {}\n+    implicit_into_iter; //~ ERROR use of moved\n+\n+    let explicit_into_iter = vec![true];\n+    for _val in explicit_into_iter.into_iter() {}\n+    explicit_into_iter; //~ ERROR use of moved\n+\n+    let container = Container(vec![]);\n+    for _val in container.custom_into_iter() {}\n+    container; //~ ERROR use of moved\n+}\n+\n+fn main() {}"}, {"sha": "4333e8a23e866f408cbcbfab35992f4dd7bea440", "filename": "src/test/ui/moves/move-fn-self-receiver.stderr", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -0,0 +1,158 @@\n+error[E0382]: use of moved value: `val.0`\n+  --> $DIR/move-fn-self-receiver.rs:30:5\n+   |\n+LL |     val.0.into_iter().next();\n+   |           ----------- `val.0` moved due to this method call\n+LL |     val.0;\n+   |     ^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `val.0`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n+   = note: move occurs because `val.0` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `foo`\n+  --> $DIR/move-fn-self-receiver.rs:34:5\n+   |\n+LL |     let foo = Foo;\n+   |         --- move occurs because `foo` has type `Foo`, which does not implement the `Copy` trait\n+LL |     foo.use_self();\n+   |         ---------- `foo` moved due to this method call\n+LL |     foo;\n+   |     ^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `foo`\n+  --> $DIR/move-fn-self-receiver.rs:13:17\n+   |\n+LL |     fn use_self(self) {}\n+   |                 ^^^^\n+\n+error[E0382]: use of moved value: `second_foo`\n+  --> $DIR/move-fn-self-receiver.rs:38:5\n+   |\n+LL |     let second_foo = Foo;\n+   |         ---------- move occurs because `second_foo` has type `Foo`, which does not implement the `Copy` trait\n+LL |     second_foo.use_self();\n+   |                ---------- `second_foo` moved due to this method call\n+LL |     second_foo;\n+   |     ^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `boxed_foo`\n+  --> $DIR/move-fn-self-receiver.rs:42:5\n+   |\n+LL |     let boxed_foo = Box::new(Foo);\n+   |         --------- move occurs because `boxed_foo` has type `std::boxed::Box<Foo>`, which does not implement the `Copy` trait\n+LL |     boxed_foo.use_box_self();\n+   |               -------------- `boxed_foo` moved due to this method call\n+LL |     boxed_foo;\n+   |     ^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `boxed_foo`\n+  --> $DIR/move-fn-self-receiver.rs:14:21\n+   |\n+LL |     fn use_box_self(self: Box<Self>) {}\n+   |                     ^^^^\n+\n+error[E0382]: use of moved value: `pin_box_foo`\n+  --> $DIR/move-fn-self-receiver.rs:46:5\n+   |\n+LL |     let pin_box_foo = Box::pin(Foo);\n+   |         ----------- move occurs because `pin_box_foo` has type `std::pin::Pin<std::boxed::Box<Foo>>`, which does not implement the `Copy` trait\n+LL |     pin_box_foo.use_pin_box_self();\n+   |                 ------------------ `pin_box_foo` moved due to this method call\n+LL |     pin_box_foo;\n+   |     ^^^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `pin_box_foo`\n+  --> $DIR/move-fn-self-receiver.rs:15:25\n+   |\n+LL |     fn use_pin_box_self(self: Pin<Box<Self>>) {}\n+   |                         ^^^^\n+\n+error[E0505]: cannot move out of `mut_foo` because it is borrowed\n+  --> $DIR/move-fn-self-receiver.rs:50:5\n+   |\n+LL |     let ret = mut_foo.use_mut_self();\n+   |               ------- borrow of `mut_foo` occurs here\n+LL |     mut_foo;\n+   |     ^^^^^^^ move out of `mut_foo` occurs here\n+LL |     ret;\n+   |     --- borrow later used here\n+\n+error[E0382]: use of moved value: `rc_foo`\n+  --> $DIR/move-fn-self-receiver.rs:55:5\n+   |\n+LL |     let rc_foo = Rc::new(Foo);\n+   |         ------ move occurs because `rc_foo` has type `std::rc::Rc<Foo>`, which does not implement the `Copy` trait\n+LL |     rc_foo.use_rc_self();\n+   |            ------------- `rc_foo` moved due to this method call\n+LL |     rc_foo;\n+   |     ^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `rc_foo`\n+  --> $DIR/move-fn-self-receiver.rs:16:20\n+   |\n+LL |     fn use_rc_self(self: Rc<Self>) {}\n+   |                    ^^^^\n+\n+error[E0382]: use of moved value: `foo_add`\n+  --> $DIR/move-fn-self-receiver.rs:59:5\n+   |\n+LL |     let foo_add = Foo;\n+   |         ------- move occurs because `foo_add` has type `Foo`, which does not implement the `Copy` trait\n+LL |     foo_add + Foo;\n+   |     ------------- `foo_add` moved due to usage in operator\n+LL |     foo_add;\n+   |     ^^^^^^^ value used here after move\n+   |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n+\n+error[E0382]: use of moved value: `implicit_into_iter`\n+  --> $DIR/move-fn-self-receiver.rs:63:5\n+   |\n+LL |     let implicit_into_iter = vec![true];\n+   |         ------------------ move occurs because `implicit_into_iter` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+LL |     for _val in implicit_into_iter {}\n+   |                 ------------------\n+   |                 |\n+   |                 `implicit_into_iter` moved due to this implicit call to `.into_iter()`\n+   |                 help: consider borrowing to avoid moving into the for loop: `&implicit_into_iter`\n+LL |     implicit_into_iter;\n+   |     ^^^^^^^^^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `explicit_into_iter`\n+  --> $DIR/move-fn-self-receiver.rs:67:5\n+   |\n+LL |     let explicit_into_iter = vec![true];\n+   |         ------------------ move occurs because `explicit_into_iter` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+LL |     for _val in explicit_into_iter.into_iter() {}\n+   |                                    ----------- `explicit_into_iter` moved due to this method call\n+LL |     explicit_into_iter;\n+   |     ^^^^^^^^^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `container`\n+  --> $DIR/move-fn-self-receiver.rs:71:5\n+   |\n+LL |     let container = Container(vec![]);\n+   |         --------- move occurs because `container` has type `Container`, which does not implement the `Copy` trait\n+LL |     for _val in container.custom_into_iter() {}\n+   |                           ------------------ `container` moved due to this method call\n+LL |     container;\n+   |     ^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `container`\n+  --> $DIR/move-fn-self-receiver.rs:23:25\n+   |\n+LL |     fn custom_into_iter(self) -> impl Iterator<Item = bool> {\n+   |                         ^^^^\n+\n+error: aborting due to 11 previous errors\n+\n+Some errors have detailed explanations: E0382, E0505.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "142feb280d153be2b8a94061d803d5e3cd5805e5", "filename": "src/test/ui/moves/moves-based-on-type-access-to-field.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -4,9 +4,15 @@ error[E0382]: borrow of moved value: `x`\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     consume(x.into_iter().next().unwrap());\n-   |             - value moved here\n+   |               ----------- `x` moved due to this method call\n LL |     touch(&x[0]);\n    |            ^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ff98aab50c9f82ec0bebf89288f1eeb8a2425973", "filename": "src/test/ui/moves/moves-based-on-type-exprs.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -104,19 +104,31 @@ error[E0382]: borrow of moved value: `x`\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     let _y = x.into_iter().next().unwrap();\n-   |              - value moved here\n+   |                ----------- `x` moved due to this method call\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:83:11\n    |\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     let _y = [x.into_iter().next().unwrap(); 1];\n-   |               - value moved here\n+   |                 ----------- `x` moved due to this method call\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to 11 previous errors\n "}, {"sha": "8761b5261d51bab1ebf7b6a2fd2cedcd6680df98", "filename": "src/test/ui/once-cant-call-twice-on-heap.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -4,10 +4,15 @@ error[E0382]: use of moved value: `blk`\n LL | fn foo<F:FnOnce()>(blk: F) {\n    |                    --- move occurs because `blk` has type `F`, which does not implement the `Copy` trait\n LL |     blk();\n-   |     --- value moved here\n+   |     ----- `blk` moved due to this call\n LL |     blk();\n    |     ^^^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/once-cant-call-twice-on-heap.rs:8:5\n+   |\n+LL |     blk();\n+   |     ^^^\n help: consider further restricting this bound\n    |\n LL | fn foo<F:FnOnce() + Copy>(blk: F) {"}, {"sha": "11372494772d0962c55e4d66faf252c6330ec8f5", "filename": "src/test/ui/suggestions/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -1,4 +1,4 @@\n-error[E0277]: the trait bound `fn() -> impl std::future::Future {foo}: std::future::Future` is not satisfied\n+error[E0277]: `fn() -> impl std::future::Future {foo}` is not a future\n   --> $DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:10:9\n    |\n LL | async fn foo() {}\n@@ -8,14 +8,15 @@ LL | fn bar(f: impl Future<Output=()>) {}\n    |                ----------------- required by this bound in `bar`\n ...\n LL |     bar(foo);\n-   |         ^^^ the trait `std::future::Future` is not implemented for `fn() -> impl std::future::Future {foo}`\n+   |         ^^^ `fn() -> impl std::future::Future {foo}` is not a future\n    |\n+   = help: the trait `std::future::Future` is not implemented for `fn() -> impl std::future::Future {foo}`\n help: use parentheses to call the function\n    |\n LL |     bar(foo());\n    |            ^^\n \n-error[E0277]: the trait bound `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:36]: std::future::Future` is not satisfied\n+error[E0277]: `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:36]` is not a future\n   --> $DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:12:9\n    |\n LL | fn bar(f: impl Future<Output=()>) {}\n@@ -24,8 +25,9 @@ LL | fn bar(f: impl Future<Output=()>) {}\n LL |     let async_closure = async || ();\n    |                         -------- consider calling this closure\n LL |     bar(async_closure);\n-   |         ^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:36]`\n+   |         ^^^^^^^^^^^^^ `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:36]` is not a future\n    |\n+   = help: the trait `std::future::Future` is not implemented for `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:36]`\n help: use parentheses to call the closure\n    |\n LL |     bar(async_closure());"}, {"sha": "e445a84fd012e7b2089b3d848bcbaed194dd986e", "filename": "src/test/ui/terminal-width/flag-human.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fterminal-width%2Fflag-human.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fterminal-width%2Fflag-human.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fflag-human.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: -Z terminal-width=20\n+\n+// This test checks that `-Z terminal-width` effects the human error output by restricting it to an\n+// arbitrarily low value so that the effect is visible.\n+\n+fn main() {\n+    let _: () = 42;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "393dcf2b82845b1da2a4d6d0352d44c7cdc978a1", "filename": "src/test/ui/terminal-width/flag-human.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fterminal-width%2Fflag-human.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fterminal-width%2Fflag-human.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fflag-human.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/flag-human.rs:7:17\n+   |\n+LL | ..._: () = 42;\n+   |       --   ^^ expected `()`, found integer\n+   |       |\n+   |       expected due to this\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "eabdc59ddedd548ccdcb96982a43266fe1cc6abf", "filename": "src/test/ui/terminal-width/flag-json.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fterminal-width%2Fflag-json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fterminal-width%2Fflag-json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fflag-json.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: -Z terminal-width=20 --error-format=json\n+\n+// This test checks that `-Z terminal-width` effects the JSON error output by restricting it to an\n+// arbitrarily low value so that the effect is visible.\n+\n+fn main() {\n+    let _: () = 42;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "29730ccdd4ed7014c2f5bcab6dc89939b72ccf08", "filename": "src/test/ui/terminal-width/flag-json.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fterminal-width%2Fflag-json.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fterminal-width%2Fflag-json.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fflag-json.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -0,0 +1,32 @@\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\n+This error occurs when the compiler is unable to infer the concrete type of a\n+variable. It can occur in several cases, the most common being a mismatch\n+between two types: the type the author explicitly assigned, and the type the\n+compiler inferred.\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/flag-json.rs\",\"byte_start\":244,\"byte_end\":246,\"line_start\":7,\"line_end\":7,\"column_start\":17,\"column_end\":19,\"is_primary\":true,\"text\":[{\"text\":\"    let _: () = 42;\",\"highlight_start\":17,\"highlight_end\":19}],\"label\":\"expected `()`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/flag-json.rs\",\"byte_start\":239,\"byte_end\":241,\"line_start\":7,\"line_end\":7,\"column_start\":12,\"column_end\":14,\"is_primary\":false,\"text\":[{\"text\":\"    let _: () = 42;\",\"highlight_start\":12,\"highlight_end\":14}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"error[E0308]: mismatched types\n+  --> $DIR/flag-json.rs:7:17\n+   |\n+LL | ..._: () = 42;\n+   |       --   ^^ expected `()`, found integer\n+   |       |\n+   |       expected due to this\n+\n+\"}\n+{\"message\":\"aborting due to previous error\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to previous error\n+\n+\"}\n+{\"message\":\"For more information about this error, try `rustc --explain E0308`.\",\"code\":null,\"level\":\"failure-note\",\"spans\":[],\"children\":[],\"rendered\":\"For more information about this error, try `rustc --explain E0308`.\n+\"}"}, {"sha": "ab6f06518467c9bacaa471e69fb0562f96a987b9", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnonce-call-twice.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `tick`\n   --> $DIR/unboxed-closures-infer-fnonce-call-twice.rs:10:5\n    |\n LL |     tick();\n-   |     ---- value moved here\n+   |     ------ `tick` moved due to this call\n LL |     tick();\n    |     ^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `co\n    |\n LL |     let tick = || mem::drop(counter);\n    |                             ^^^^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/unboxed-closures-infer-fnonce-call-twice.rs:9:5\n+   |\n+LL |     tick();\n+   |     ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "8d70a2b17602b1508e8018239048f850a07bf7a2", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnonce-move-call-twice.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `tick`\n   --> $DIR/unboxed-closures-infer-fnonce-move-call-twice.rs:10:5\n    |\n LL |     tick();\n-   |     ---- value moved here\n+   |     ------ `tick` moved due to this call\n LL |     tick();\n    |     ^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `co\n    |\n LL |     let tick = move || mem::drop(counter);\n    |                                  ^^^^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/unboxed-closures-infer-fnonce-move-call-twice.rs:9:5\n+   |\n+LL |     tick();\n+   |     ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "dd54c222f64bbb0a548f93473e83f2f46e3d61ef", "filename": "src/test/ui/unop-move-semantics.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funop-move-semantics.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -4,11 +4,16 @@ error[E0382]: borrow of moved value: `x`\n LL | fn move_then_borrow<T: Not<Output=T> + Clone>(x: T) {\n    |                                               - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n LL |     !x;\n-   |      - value moved here\n+   |     -- `x` moved due to usage in operator\n LL | \n LL |     x.clone();\n    |     ^ value borrowed here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn not(self) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn move_then_borrow<T: Not<Output=T> + Clone + Copy>(x: T) {"}, {"sha": "906b543e421229e20a3f67af6201b2dd4118193f", "filename": "src/test/ui/unsized-locals/borrow-after-move.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -37,10 +37,16 @@ error[E0382]: borrow of moved value: `y`\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         y.foo();\n-   |         - value moved here\n+   |           ----- `y` moved due to this method call\n ...\n LL |         println!(\"{}\", &y);\n    |                        ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `y`\n+  --> $DIR/borrow-after-move.rs:4:12\n+   |\n+LL |     fn foo(self) -> String;\n+   |            ^^^^\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/borrow-after-move.rs:39:24"}, {"sha": "49b2031c6b9d969a12b82b603d77b3629920697c", "filename": "src/test/ui/unsized-locals/double-move.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -34,9 +34,15 @@ error[E0382]: use of moved value: `y`\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         y.foo();\n-   |         - value moved here\n+   |           ----- `y` moved due to this method call\n LL |         y.foo();\n    |         ^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `y`\n+  --> $DIR/double-move.rs:4:12\n+   |\n+LL |     fn foo(self) -> String;\n+   |            ^^^^\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/double-move.rs:45:9"}, {"sha": "b9440f4de07a9e9a38075d6f93a7769de37c4a6d", "filename": "src/test/ui/use/use-after-move-self-based-on-type.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -4,9 +4,15 @@ error[E0382]: use of moved value: `self`\n LL |     pub fn foo(self) -> isize {\n    |                ---- move occurs because `self` has type `S`, which does not implement the `Copy` trait\n LL |         self.bar();\n-   |         ---- value moved here\n+   |              ----- `self` moved due to this method call\n LL |         return self.x;\n    |                ^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `self`\n+  --> $DIR/use-after-move-self-based-on-type.rs:15:16\n+   |\n+LL |     pub fn bar(self) {}\n+   |                ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3da53b024db440506d518511fb2c20f4f870da71", "filename": "src/test/ui/use/use-after-move-self.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -4,9 +4,15 @@ error[E0382]: use of moved value: `self`\n LL |     pub fn foo(self) -> isize {\n    |                ---- move occurs because `self` has type `S`, which does not implement the `Copy` trait\n LL |         self.bar();\n-   |         ---- value moved here\n+   |              ----- `self` moved due to this method call\n LL |         return *self.x;\n    |                ^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `self`\n+  --> $DIR/use-after-move-self.rs:13:16\n+   |\n+LL |     pub fn bar(self) {}\n+   |                ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ece63a2b8194745d2be6b0b7b9f66aeef1a986c3", "filename": "src/test/ui/walk-struct-literal-with.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -4,9 +4,15 @@ error[E0382]: borrow of moved value: `start`\n LL |     let start = Mine{test:\"Foo\".to_string(), other_val:0};\n    |         ----- move occurs because `start` has type `Mine`, which does not implement the `Copy` trait\n LL |     let end = Mine{other_val:1, ..start.make_string_bar()};\n-   |                                   ----- value moved here\n+   |                                         ----------------- `start` moved due to this method call\n LL |     println!(\"{}\", start.test);\n    |                    ^^^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `start`\n+  --> $DIR/walk-struct-literal-with.rs:7:28\n+   |\n+LL |     fn make_string_bar(mut self) -> Mine{\n+   |                            ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "571e7a59113ada60bbe3af9097f4f36c99acbc2b", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25687caa2e4e35b31c29e28998710670e9d54ee9/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=25687caa2e4e35b31c29e28998710670e9d54ee9", "patch": "@@ -263,7 +263,7 @@ impl EarlyProps {\n         }\n \n         fn version_to_int(version: &str) -> u32 {\n-            let version_without_suffix = version.split('-').next().unwrap();\n+            let version_without_suffix = version.trim_end_matches(\"git\").split('-').next().unwrap();\n             let components: Vec<u32> = version_without_suffix\n                 .split('.')\n                 .map(|s| s.parse().expect(\"Malformed version component\"))"}]}