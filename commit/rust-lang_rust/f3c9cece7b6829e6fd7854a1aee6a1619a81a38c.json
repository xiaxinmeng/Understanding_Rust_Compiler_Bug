{"sha": "f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYzljZWNlN2I2ODI5ZTZmZDc4NTRhMWFlZTZhMTYxOWE4MWEzOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-07T17:47:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-07T17:47:10Z"}, "message": "Auto merge of #61430 - matthewjasper:drop-on-into-panic, r=oli-obk\n\nMake `into` schedule drop for the destination\n\ncloses #47949", "tree": {"sha": "e6f22af501794750fc1166471d8128374d434e10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6f22af501794750fc1166471d8128374d434e10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "html_url": "https://github.com/rust-lang/rust/commit/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59a31c8c676bdc9f50490d5798b1b4e884b7d7ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/59a31c8c676bdc9f50490d5798b1b4e884b7d7ae", "html_url": "https://github.com/rust-lang/rust/commit/59a31c8c676bdc9f50490d5798b1b4e884b7d7ae"}, {"sha": "37026837a3f23486d3cf1009d9136927168ddb33", "url": "https://api.github.com/repos/rust-lang/rust/commits/37026837a3f23486d3cf1009d9136927168ddb33", "html_url": "https://github.com/rust-lang/rust/commit/37026837a3f23486d3cf1009d9136927168ddb33"}], "stats": {"total": 907, "additions": 621, "deletions": 286}, "files": [{"sha": "f9440866e4925eedd785f0eb6e7d6d793cd96add", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -1,18 +1,22 @@\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::matches::ArmHasGuard;\n+use crate::build::scope::DropKind;\n use crate::hair::*;\n+use rustc::middle::region;\n use rustc::mir::*;\n use rustc::hir;\n use syntax_pos::Span;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn ast_block(&mut self,\n-                     destination: &Place<'tcx>,\n-                     block: BasicBlock,\n-                     ast_block: &'tcx hir::Block,\n-                     source_info: SourceInfo)\n-                     -> BlockAnd<()> {\n+    pub fn ast_block(\n+        &mut self,\n+        destination: &Place<'tcx>,\n+        scope: Option<region::Scope>,\n+        block: BasicBlock,\n+        ast_block: &'tcx hir::Block,\n+        source_info: SourceInfo,\n+    ) -> BlockAnd<()> {\n         let Block {\n             region_scope,\n             opt_destruction_scope,\n@@ -21,37 +25,61 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             expr,\n             targeted_by_break,\n             safety_mode\n-        } =\n-            self.hir.mirror(ast_block);\n+        } = self.hir.mirror(ast_block);\n         self.in_opt_scope(opt_destruction_scope.map(|de|(de, source_info)), move |this| {\n             this.in_scope((region_scope, source_info), LintLevel::Inherited, move |this| {\n                 if targeted_by_break {\n                     // This is a `break`-able block\n                     let exit_block = this.cfg.start_new_block();\n+                    if let Some(scope) = scope {\n+                        // Breakable blocks assign to their destination on each\n+                        // `break`, as well as when they exit normally. So we\n+                        // can't schedule the drop in the last expression like\n+                        // normal blocks do.\n+                        let local = destination.as_local()\n+                            .expect(\"cannot schedule drop of non-Local place\");\n+                        this.schedule_drop(span, scope, local, DropKind::Value);\n+                    }\n                     let block_exit = this.in_breakable_scope(\n                         None, exit_block, destination.clone(), |this| {\n-                            this.ast_block_stmts(destination, block, span, stmts, expr,\n-                                                 safety_mode)\n+                            this.ast_block_stmts(\n+                                destination,\n+                                None,\n+                                block,\n+                                span,\n+                                stmts,\n+                                expr,\n+                                safety_mode,\n+                            )\n                         });\n                     this.cfg.terminate(unpack!(block_exit), source_info,\n                                        TerminatorKind::Goto { target: exit_block });\n                     exit_block.unit()\n                 } else {\n-                    this.ast_block_stmts(destination, block, span, stmts, expr,\n-                                         safety_mode)\n+                    this.ast_block_stmts(\n+                        destination,\n+                        scope,\n+                        block,\n+                        span,\n+                        stmts,\n+                        expr,\n+                        safety_mode,\n+                    )\n                 }\n             })\n         })\n     }\n \n-    fn ast_block_stmts(&mut self,\n-                       destination: &Place<'tcx>,\n-                       mut block: BasicBlock,\n-                       span: Span,\n-                       stmts: Vec<StmtRef<'tcx>>,\n-                       expr: Option<ExprRef<'tcx>>,\n-                       safety_mode: BlockSafety)\n-                       -> BlockAnd<()> {\n+    fn ast_block_stmts(\n+        &mut self,\n+        destination: &Place<'tcx>,\n+        scope: Option<region::Scope>,\n+        mut block: BasicBlock,\n+        span: Span,\n+        stmts: Vec<StmtRef<'tcx>>,\n+        expr: Option<ExprRef<'tcx>>,\n+        safety_mode: BlockSafety,\n+    ) -> BlockAnd<()> {\n         let this = self;\n \n         // This convoluted structure is to avoid using recursion as we walk down a list\n@@ -177,7 +205,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.block_context.currently_ignores_tail_results();\n             this.block_context.push(BlockFrame::TailExpr { tail_result_is_ignored });\n \n-            unpack!(block = this.into(destination, block, expr));\n+            unpack!(block = this.into(destination, scope, block, expr));\n             let popped = this.block_context.pop();\n \n             assert!(popped.map_or(false, |bf|bf.is_tail_expr()));"}, {"sha": "bd9edc56872b9f3c52229bff295b2bd5bce2f09f", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -128,7 +128,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         expr_span,\n                         scope,\n                         result,\n-                        expr.ty,\n                     );\n                 }\n \n@@ -137,11 +136,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.cfg\n                     .push_assign(block, source_info, &Place::from(result), box_);\n \n-                // initialize the box contents:\n+                // Initialize the box contents. No scope is needed since the\n+                // `Box` is already scheduled to be dropped.\n                 unpack!(\n                     block = this.into(\n                         &Place::from(result).deref(),\n-                        block, value\n+                        None,\n+                        block,\n+                        value\n                     )\n                 );\n                 block.and(Rvalue::Use(Operand::Move(Place::from(result))))\n@@ -569,7 +571,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 upvar_span,\n                 temp_lifetime,\n                 temp,\n-                upvar_ty,\n             );\n         }\n "}, {"sha": "bd20f27c945c1d3a923626f41b784d0e35883b3d", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -103,24 +103,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         expr_span,\n                         temp_lifetime,\n                         temp,\n-                        expr_ty,\n                         DropKind::Storage,\n                     );\n                 }\n             }\n         }\n \n-        unpack!(block = this.into(temp_place, block, expr));\n-\n-        if let Some(temp_lifetime) = temp_lifetime {\n-            this.schedule_drop(\n-                expr_span,\n-                temp_lifetime,\n-                temp,\n-                expr_ty,\n-                DropKind::Value,\n-            );\n-        }\n+        unpack!(block = this.into(temp_place, temp_lifetime, block, expr));\n \n         block.and(temp)\n     }"}, {"sha": "c262215ab9be4439265768a523628e2f72ff8069", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -2,7 +2,9 @@\n \n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n+use crate::build::scope::DropKind;\n use crate::hair::*;\n+use rustc::middle::region;\n use rustc::mir::*;\n use rustc::ty;\n \n@@ -11,15 +13,18 @@ use rustc_target::spec::abi::Abi;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n+    /// If a `drop_scope` is provided, `destination` is scheduled to be dropped\n+    /// in `scope` once it has been initialized.\n     pub fn into_expr(\n         &mut self,\n         destination: &Place<'tcx>,\n+        scope: Option<region::Scope>,\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         debug!(\n-            \"into_expr(destination={:?}, block={:?}, expr={:?})\",\n-            destination, block, expr\n+            \"into_expr(destination={:?}, scope={:?}, block={:?}, expr={:?})\",\n+            destination, scope, block, expr\n         );\n \n         // since we frequently have to reference `self` from within a\n@@ -35,6 +40,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             _ => false,\n         };\n \n+        let schedule_drop = move |this: &mut Self| {\n+            if let Some(drop_scope) = scope {\n+                let local = destination.as_local()\n+                    .expect(\"cannot schedule drop of non-Local place\");\n+                this.schedule_drop(expr_span, drop_scope, local, DropKind::Value);\n+            }\n+        };\n+\n         if !expr_is_block_or_scope {\n             this.block_context.push(BlockFrame::SubExpr);\n         }\n@@ -47,14 +60,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             } => {\n                 let region_scope = (region_scope, source_info);\n                 this.in_scope(region_scope, lint_level, |this| {\n-                    this.into(destination, block, value)\n+                    this.into(destination, scope, block, value)\n                 })\n             }\n             ExprKind::Block { body: ast_block } => {\n-                this.ast_block(destination, block, ast_block, source_info)\n+                this.ast_block(destination, scope, block, ast_block, source_info)\n             }\n             ExprKind::Match { scrutinee, arms } => {\n-                this.match_expr(destination, expr_span, block, scrutinee, arms)\n+                this.match_expr(destination, scope, expr_span, block, scrutinee, arms)\n             }\n             ExprKind::NeverToAny { source } => {\n                 let source = this.hir.mirror(source);\n@@ -67,6 +80,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // This is an optimization. If the expression was a call then we already have an\n                 // unreachable block. Don't bother to terminate it and create a new one.\n+                schedule_drop(this);\n                 if is_call {\n                     block.unit()\n                 } else {\n@@ -164,6 +178,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     TerminatorKind::Goto { target: loop_block },\n                 );\n \n+                // Loops assign to their destination on each `break`. Since we\n+                // can't easily unschedule drops, we schedule the drop now.\n+                schedule_drop(this);\n                 this.in_breakable_scope(\n                     Some(loop_block),\n                     exit_block,\n@@ -185,7 +202,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         // introduce a unit temporary as the destination for the loop body.\n                         let tmp = this.get_unit_temp();\n                         // Execute the body, branching back to the test.\n-                        let body_block_end = unpack!(this.into(&tmp, body_block, body));\n+                        // No scope is provided, since we've scheduled the drop above.\n+                        let body_block_end = unpack!(this.into(&tmp, None, body_block, body));\n                         this.cfg.terminate(\n                             body_block_end,\n                             source_info,\n@@ -234,8 +252,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         is_block_tail: None,\n                     });\n                     let ptr_temp = Place::from(ptr_temp);\n-                    let block = unpack!(this.into(&ptr_temp, block, ptr));\n-                    this.into(&ptr_temp.deref(), block, val)\n+                    // No need for a scope, ptr_temp doesn't need drop\n+                    let block = unpack!(this.into(&ptr_temp, None, block, ptr));\n+                    // Maybe we should provide a scope here so that\n+                    // `move_val_init` wouldn't leak on panic even with an\n+                    // arbitrary `val` expression, but `schedule_drop`,\n+                    // borrowck and drop elaboration all prevent us from\n+                    // dropping `ptr_temp.deref()`.\n+                    this.into(&ptr_temp.deref(), None, block, val)\n                 } else {\n                     let args: Vec<_> = args\n                         .into_iter()\n@@ -265,11 +289,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             from_hir_call,\n                         },\n                     );\n+                    schedule_drop(this);\n                     success.unit()\n                 }\n             }\n             ExprKind::Use { source } => {\n-                this.into(destination, block, source)\n+                this.into(destination, scope, block, source)\n             }\n \n             // These cases don't actually need a destination\n@@ -296,6 +321,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg\n                     .push_assign(block, source_info, destination, rvalue);\n+                schedule_drop(this);\n                 block.unit()\n             }\n             ExprKind::Index { .. } | ExprKind::Deref { .. } | ExprKind::Field { .. } => {\n@@ -315,6 +341,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg\n                     .push_assign(block, source_info, destination, rvalue);\n+                schedule_drop(this);\n                 block.unit()\n             }\n \n@@ -346,6 +373,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 let rvalue = unpack!(block = this.as_local_rvalue(block, expr));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n+                schedule_drop(this);\n                 block.unit()\n             }\n         };"}, {"sha": "e57f10f0b14e91907949c48ccf089318b529cd56", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -6,26 +6,31 @@\n \n use crate::build::{BlockAnd, Builder};\n use crate::hair::*;\n+use rustc::middle::region;\n use rustc::mir::*;\n \n pub(in crate::build) trait EvalInto<'tcx> {\n     fn eval_into(\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: &Place<'tcx>,\n+        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()>;\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn into<E>(&mut self,\n-                   destination: &Place<'tcx>,\n-                   block: BasicBlock,\n-                   expr: E)\n-                   -> BlockAnd<()>\n-        where E: EvalInto<'tcx>\n+    pub fn into<E>(\n+        &mut self,\n+        destination: &Place<'tcx>,\n+        scope: Option<region::Scope>,\n+        block: BasicBlock,\n+        expr: E,\n+    ) -> BlockAnd<()>\n+    where\n+        E: EvalInto<'tcx>,\n     {\n-        expr.eval_into(self, destination, block)\n+        expr.eval_into(self, destination, scope, block)\n     }\n }\n \n@@ -34,10 +39,11 @@ impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: &Place<'tcx>,\n+        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()> {\n         let expr = builder.hir.mirror(self);\n-        builder.into_expr(destination, block, expr)\n+        builder.into_expr(destination, scope, block, expr)\n     }\n }\n \n@@ -46,8 +52,9 @@ impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: &Place<'tcx>,\n+        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()> {\n-        builder.into_expr(destination, block, self)\n+        builder.into_expr(destination, scope, block, self)\n     }\n }"}, {"sha": "e8cf827aa900b497bc8e51c5cb5fded91958e2d3", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -102,6 +102,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn match_expr(\n         &mut self,\n         destination: &Place<'tcx>,\n+        destination_scope: Option<region::Scope>,\n         span: Span,\n         mut block: BasicBlock,\n         scrutinee: ExprRef<'tcx>,\n@@ -228,6 +229,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         };\n \n         // Step 5. Create everything else: the guards and the arms.\n+        if let Some(scope) = destination_scope {\n+            // `match` assigns to its destination in each arm. Since we can't\n+            // easily unschedule drops, we schedule the drop now.\n+            let local = destination.as_local()\n+                .expect(\"cannot schedule drop of non-Local place\");\n+            self.schedule_drop(span, scope, local, DropKind::Value);\n+        }\n+\n         let match_scope = self.scopes.topmost();\n \n         let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, mut candidates)| {\n@@ -275,7 +284,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.source_scope = source_scope;\n                 }\n \n-                this.into(destination, arm_block, body)\n+                // No scope is provided, since we've scheduled the drop above.\n+                this.into(destination, None, arm_block, body)\n             })\n         }).collect();\n \n@@ -311,8 +321,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n-                unpack!(block = self.into(&place, block, initializer));\n+                let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n \n+                unpack!(block = self.into(&place, Some(region_scope), block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let source_info = self.source_info(irrefutable_pat.span);\n@@ -324,7 +335,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     },\n                 );\n \n-                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n \n@@ -352,9 +362,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     user_ty_span,\n                 },\n             } => {\n+                let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n-                unpack!(block = self.into(&place, block, initializer));\n+                unpack!(block = self.into(&place, Some(region_scope), block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n@@ -400,7 +411,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     },\n                 );\n \n-                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n \n@@ -535,21 +545,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 kind: StatementKind::StorageLive(local_id),\n             },\n         );\n-        let var_ty = self.local_decls[local_id].ty;\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n-        self.schedule_drop(span, region_scope, local_id, var_ty, DropKind::Storage);\n+        self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n         Place::from(local_id)\n     }\n \n     pub fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n-        let var_ty = self.local_decls[local_id].ty;\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n         self.schedule_drop(\n             span,\n             region_scope,\n             local_id,\n-            var_ty,\n             DropKind::Value,\n         );\n     }"}, {"sha": "9a98cf1cb88c1645ef3ec1d97aba31c71da58c7b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -616,6 +616,7 @@ where\n     let source_info = builder.source_info(span);\n     let call_site_s = (call_site_scope, source_info);\n     unpack!(block = builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n+        builder.schedule_drop(span, call_site_scope, RETURN_PLACE, DropKind::Value);\n         if should_abort_on_panic(tcx, fn_def_id, abi) {\n             builder.schedule_abort();\n         }\n@@ -646,6 +647,7 @@ where\n             builder.cfg.terminate(unreachable_block, source_info,\n                                   TerminatorKind::Unreachable);\n         }\n+        builder.unschedule_return_place_drop();\n         return_block.unit()\n     }));\n     assert_eq!(block, builder.return_block());\n@@ -687,7 +689,9 @@ fn construct_const<'a, 'tcx>(\n     let mut block = START_BLOCK;\n     let ast_expr = &tcx.hir().body(body_id).value;\n     let expr = builder.hir.mirror(ast_expr);\n-    unpack!(block = builder.into_expr(&Place::return_place(), block, expr));\n+    // We don't provide a scope because we can't unwind in constants, so won't\n+    // need to drop the return place.\n+    unpack!(block = builder.into_expr(&Place::return_place(), None, block, expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -829,12 +833,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Function arguments always get the first Local indices after the return place\n             let local = Local::new(index + 1);\n             let place = Place::from(local);\n-            let &ArgInfo(ty, opt_ty_info, arg_opt, ref self_binding) = arg_info;\n+            let &ArgInfo(_, opt_ty_info, arg_opt, ref self_binding) = arg_info;\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(\n                 arg_opt.as_ref().map_or(ast_body.span, |arg| arg.pat.span),\n-                argument_scope, local, ty, DropKind::Value,\n+                argument_scope, local, DropKind::Value,\n             );\n \n             if let Some(arg) = arg_opt {\n@@ -888,7 +892,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        self.into(&Place::return_place(), block, body)\n+        // No scope is provided, since we've scheduled the drop of the return\n+        // place.\n+        self.into(&Place::return_place(), None, block, body)\n     }\n \n     fn set_correct_source_scope_for_arg("}, {"sha": "6206bfd9f3eac193a7af825bdf81926e2df999de", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -85,7 +85,6 @@ should go to.\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n use crate::hair::{Expr, ExprRef, LintLevel};\n use rustc::middle::region;\n-use rustc::ty::Ty;\n use rustc::hir;\n use rustc::mir::*;\n use syntax_pos::{DUMMY_SP, Span};\n@@ -173,11 +172,11 @@ struct BreakableScope<'tcx> {\n     region_scope: region::Scope,\n     /// Where the body of the loop begins. `None` if block\n     continue_block: Option<BasicBlock>,\n-    /// Block to branch into when the loop or block terminates (either by being `break`-en out\n-    /// from, or by having its condition to become false)\n+    /// Block to branch into when the loop or block terminates (either by being\n+    /// `break`-en out from, or by having its condition to become false)\n     break_block: BasicBlock,\n-    /// The destination of the loop/block expression itself (i.e., where to put the result of a\n-    /// `break` expression)\n+    /// The destination of the loop/block expression itself (i.e., where to put\n+    /// the result of a `break` expression)\n     break_destination: Place<'tcx>,\n }\n \n@@ -514,7 +513,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let Some(value) = value {\n                 debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n                 self.block_context.push(BlockFrame::SubExpr);\n-                unpack!(block = self.into(&destination, block, value));\n+                unpack!(block = self.into(&destination, None, block, value));\n                 self.block_context.pop();\n             } else {\n                 self.cfg.push_assign_unit(block, source_info, &destination)\n@@ -728,10 +727,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span: Span,\n         region_scope: region::Scope,\n         local: Local,\n-        place_ty: Ty<'tcx>,\n     ) {\n-        self.schedule_drop(span, region_scope, local, place_ty, DropKind::Storage);\n-        self.schedule_drop(span, region_scope, local, place_ty, DropKind::Value);\n+        self.schedule_drop(span, region_scope, local, DropKind::Storage);\n+        self.schedule_drop(span, region_scope, local, DropKind::Value);\n     }\n \n     /// Indicates that `place` should be dropped on exit from\n@@ -744,12 +742,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span: Span,\n         region_scope: region::Scope,\n         local: Local,\n-        place_ty: Ty<'tcx>,\n         drop_kind: DropKind,\n     ) {\n-        let needs_drop = self.hir.needs_drop(place_ty);\n-        match drop_kind {\n-            DropKind::Value => if !needs_drop { return },\n+        let needs_drop = match drop_kind {\n+            DropKind::Value => {\n+                if !self.hir.needs_drop(self.local_decls[local].ty) { return }\n+                true\n+            },\n             DropKind::Storage => {\n                 if local.index() <= self.arg_count {\n                     span_bug!(\n@@ -758,8 +757,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         self.arg_count,\n                     )\n                 }\n+                false\n             }\n-        }\n+        };\n \n         for scope in self.scopes.iter_mut() {\n             let this_scope = scope.region_scope == region_scope;\n@@ -1070,6 +1070,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         success_block\n     }\n \n+    /// Unschedules the drop of the return place.\n+    ///\n+    /// If the return type of a function requires drop, then we schedule it\n+    /// in the outermost scope so that it's dropped if there's a panic while\n+    /// we drop any local variables. But we don't want to drop it if we\n+    /// return normally.\n+    crate fn unschedule_return_place_drop(&mut self) {\n+        assert_eq!(self.scopes.len(), 1);\n+        assert!(self.scopes.scopes[0].drops.len() <= 1);\n+        self.scopes.scopes[0].drops.clear();\n+    }\n+\n     // `match` arm scopes\n     // ==================\n     /// Unschedules any drops in the top scope."}, {"sha": "c1695ba66d0d536e54142f907043c66ddbe975e3", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -109,15 +109,13 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         assert_eq!(1, self.body.arg_count);\n     }\n \n-    fn statement_effect(&self,\n-                        sets: &mut GenKillSet<Local>,\n-                        loc: Location) {\n-        self.check_for_move(sets, loc);\n+    fn before_statement_effect(&self, sets: &mut GenKillSet<Self::Idx>, loc: Location) {\n+        // If we borrow or assign to a place then it needs storage for that\n+        // statement.\n         self.check_for_borrow(sets, loc);\n \n         let stmt = &self.body[loc.block].statements[loc.statement_index];\n         match stmt.kind {\n-            StatementKind::StorageLive(l) => sets.gen(l),\n             StatementKind::StorageDead(l) => sets.kill(l),\n             StatementKind::Assign(box(ref place, _))\n             | StatementKind::SetDiscriminant { box ref place, .. } => {\n@@ -136,11 +134,35 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         }\n     }\n \n-    fn terminator_effect(&self,\n-                         sets: &mut GenKillSet<Local>,\n-                         loc: Location) {\n+    fn statement_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        // If we move from a place then only stops needing storage *after*\n+        // that statement.\n         self.check_for_move(sets, loc);\n+    }\n+\n+    fn before_terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n         self.check_for_borrow(sets, loc);\n+\n+        if let TerminatorKind::Call {\n+            destination: Some((Place { base: PlaceBase::Local(local), .. }, _)),\n+            ..\n+        } = self.body[loc.block].terminator().kind {\n+            sets.gen(local);\n+        }\n+    }\n+\n+    fn terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        // For call terminators the destination requires storage for the call\n+        // and after the call returns successfully, but not after a panic.\n+        // Since `propagate_call_unwind` doesn't exist, we have to kill the\n+        // destination here, and then gen it again in `propagate_call_return`.\n+        if let TerminatorKind::Call {\n+            destination: Some((Place { base: PlaceBase::Local(local), projection: box [] }, _)),\n+            ..\n+        } = self.body[loc.block].terminator().kind {\n+            sets.kill(local);\n+        }\n+        self.check_for_move(sets, loc);\n     }\n \n     fn propagate_call_return("}, {"sha": "865fa012c2995e3a07b904272b3725b0d6caa854", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -508,10 +508,7 @@ fn locals_live_across_suspend_points(\n             storage_liveness_map.insert(block, storage_liveness.clone());\n \n             requires_storage_cursor.seek(loc);\n-            let mut storage_required = requires_storage_cursor.get().clone();\n-\n-            // Mark locals without storage statements as always requiring storage\n-            storage_required.union(&ignored.0);\n+            let storage_required = requires_storage_cursor.get().clone();\n \n             // Locals live are live at this point only if they are used across\n             // suspension points (the `liveness` variable)"}, {"sha": "76098731947fea1fa5aef0d29abfc371cd6188c7", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -41,33 +41,36 @@ impl Drop for S {\n //\n //     bb2: {\n //         _1 = move _2;\n-//         drop(_2) -> bb4;\n+//         drop(_2) -> [return: bb5, unwind: bb4];\n //     }\n //\n //     bb3 (cleanup): {\n //         drop(_2) -> bb1;\n //     }\n //\n-//     bb4: {\n+//     bb4 (cleanup): {\n+//         drop(_1) -> bb1;\n+//     }\n+//\n+//     bb5: {\n //         StorageDead(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         _4 = move _1;\n-//         _3 = const std::mem::drop::<std::boxed::Box<S>>(move _4) -> [return: bb5, unwind: bb7];\n+//         _3 = const std::mem::drop::<std::boxed::Box<S>>(move _4) -> [return: bb6, unwind: bb7];\n //     }\n //\n-//     bb5: {\n+//     bb6: {\n //         StorageDead(_4);\n //         StorageDead(_3);\n //         _0 = ();\n //         drop(_1) -> bb8;\n //     }\n-//     bb6 (cleanup): {\n-//         drop(_1) -> bb1;\n-//     }\n+//\n //     bb7 (cleanup): {\n-//         drop(_4) -> bb6;\n+//         drop(_4) -> bb4;\n //     }\n+//\n //     bb8: {\n //         StorageDead(_1);\n //         return;"}, {"sha": "e8dd56cbbae22da87d5efed6e95f2a58bfd5c816", "filename": "src/test/mir-opt/issue-62289.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fmir-opt%2Fissue-62289.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fmir-opt%2Fissue-62289.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-62289.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -24,68 +24,71 @@ fn main() {\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         _4 = std::option::Option::<u32>::None;\n-//         _3 = const <std::option::Option<u32> as std::ops::Try>::into_result(move _4) -> [return: bb2, unwind: bb3];\n+//         _3 = const <std::option::Option<u32> as std::ops::Try>::into_result(move _4) -> [return: bb2, unwind: bb4];\n //     }\n //     bb1 (cleanup): {\n //         resume;\n //     }\n //     bb2: {\n //         StorageDead(_4);\n //         _5 = discriminant(_3);\n-//         switchInt(move _5) -> [0isize: bb10, 1isize: bb5, otherwise: bb4];\n+//         switchInt(move _5) -> [0isize: bb11, 1isize: bb6, otherwise: bb5];\n //     }\n //     bb3 (cleanup): {\n-//         drop(_2) -> bb1;\n+//         drop(_0) -> bb1;\n //     }\n-//     bb4: {\n-//         unreachable;\n+//     bb4 (cleanup): {\n+//         drop(_2) -> bb3;\n //     }\n //     bb5: {\n+//         unreachable;\n+//     }\n+//     bb6: {\n //         StorageLive(_6);\n //         _6 = ((_3 as Err).0: std::option::NoneError);\n //         StorageLive(_8);\n //         StorageLive(_9);\n //         _9 = _6;\n-//         _8 = const <std::option::NoneError as std::convert::From<std::option::NoneError>>::from(move _9) -> [return: bb7, unwind: bb3];\n+//         _8 = const <std::option::NoneError as std::convert::From<std::option::NoneError>>::from(move _9) -> [return: bb8, unwind: bb4];\n //     }\n-//     bb6: {\n+//     bb7: {\n //         return;\n //     }\n-//     bb7: {\n+//     bb8: {\n //         StorageDead(_9);\n-//         _0 = const <std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::from_error(move _8) -> [return: bb8, unwind: bb3];\n+//         _0 = const <std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::from_error(move _8) -> [return: bb9, unwind: bb4];\n //     }\n-//     bb8: {\n+//     bb9: {\n //         StorageDead(_8);\n //         StorageDead(_6);\n-//         drop(_2) -> bb9;\n+//         drop(_2) -> [return: bb10, unwind: bb3];\n //     }\n-//     bb9: {\n+//     bb10: {\n //         StorageDead(_2);\n //         StorageDead(_1);\n //         StorageDead(_3);\n-//         goto -> bb6;\n+//         goto -> bb7;\n //     }\n-//     bb10: {\n+//     bb11: {\n //         StorageLive(_10);\n //         _10 = ((_3 as Ok).0: u32);\n //         (*_2) = _10;\n //         StorageDead(_10);\n //         _1 = move _2;\n-//         drop(_2) -> [return: bb12, unwind: bb11];\n+//         drop(_2) -> [return: bb13, unwind: bb12];\n //     }\n-//     bb11 (cleanup): {\n-//         drop(_1) -> bb1;\n+//     bb12 (cleanup): {\n+//         drop(_1) -> bb3;\n //     }\n-//     bb12: {\n+//     bb13: {\n //         StorageDead(_2);\n //         _0 = std::option::Option::<std::boxed::Box<u32>>::Some(move _1,);\n-//         drop(_1) -> bb13;\n+//         drop(_1) -> [return: bb14, unwind: bb3];\n //     }\n-//     bb13: {\n+//     bb14: {\n //         StorageDead(_1);\n //         StorageDead(_3);\n-//         goto -> bb6;\n+//         goto -> bb7;\n //     }\n // }\n // END rustc.test.ElaborateDrops.before.mir"}, {"sha": "c266644fd702c87ab6f2e2820ca881c443307150", "filename": "src/test/ui/async-await/async-fn-size-moved-locals.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -22,7 +22,8 @@ struct BigFut([u8; BIG_FUT_SIZE]);\n impl BigFut {\n     fn new() -> Self {\n         BigFut([0; BIG_FUT_SIZE])\n-    } }\n+    }\n+}\n \n impl Drop for BigFut {\n     fn drop(&mut self) {}"}, {"sha": "a489fb11630cd3e04306bae743251bbb47ccfdcb", "filename": "src/test/ui/async-await/async-fn-size-uninit-locals.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-uninit-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-uninit-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-uninit-locals.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -0,0 +1,103 @@\n+// Test that we don't store uninitialized locals in futures from `async fn`.\n+//\n+// The exact sizes can change by a few bytes (we'd like to know when they do).\n+// What we don't want to see is the wrong multiple of 1024 (the size of `Big`)\n+// being reflected in the size.\n+\n+// ignore-wasm32-bare (sizes don't match)\n+// run-pass\n+\n+// edition:2018\n+\n+#![allow(unused_variables, unused_assignments)]\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+use std::task::{Context, Poll};\n+\n+const BIG_FUT_SIZE: usize = 1024;\n+struct Big([u8; BIG_FUT_SIZE]);\n+\n+impl Big {\n+    fn new() -> Self {\n+        Big([0; BIG_FUT_SIZE])\n+    }\n+}\n+\n+impl Drop for Big {\n+    fn drop(&mut self) {}\n+}\n+\n+#[allow(dead_code)]\n+struct Joiner {\n+    a: Option<Big>,\n+    b: Option<Big>,\n+    c: Option<Big>,\n+}\n+\n+impl Future for Joiner {\n+    type Output = ();\n+\n+    fn poll(self: Pin<&mut Self>, _ctx: &mut Context<'_>) -> Poll<Self::Output> {\n+        Poll::Ready(())\n+    }\n+}\n+\n+fn noop() {}\n+async fn fut() {}\n+\n+async fn single() {\n+    let x;\n+    fut().await;\n+    x = Big::new();\n+}\n+\n+async fn single_with_noop() {\n+    let x;\n+    fut().await;\n+    noop();\n+    x = Big::new();\n+    noop();\n+}\n+\n+async fn joined() {\n+    let joiner;\n+    let a = Big::new();\n+    let b = Big::new();\n+    let c = Big::new();\n+\n+    fut().await;\n+    noop();\n+    joiner = Joiner { a: Some(a), b: Some(b), c: Some(c) };\n+    noop();\n+}\n+\n+async fn joined_with_noop() {\n+    let joiner;\n+    let a = Big::new();\n+    let b = Big::new();\n+    let c = Big::new();\n+\n+    fut().await;\n+    noop();\n+    joiner = Joiner { a: Some(a), b: Some(b), c: Some(c) };\n+    noop();\n+}\n+\n+async fn join_retval() -> Joiner {\n+    let a = Big::new();\n+    let b = Big::new();\n+    let c = Big::new();\n+\n+    fut().await;\n+    noop();\n+    Joiner { a: Some(a), b: Some(b), c: Some(c) }\n+}\n+\n+fn main() {\n+    assert_eq!(8, std::mem::size_of_val(&single()));\n+    assert_eq!(12, std::mem::size_of_val(&single_with_noop()));\n+    assert_eq!(3084, std::mem::size_of_val(&joined()));\n+    assert_eq!(3084, std::mem::size_of_val(&joined_with_noop()));\n+    assert_eq!(3084, std::mem::size_of_val(&join_retval()));\n+}"}, {"sha": "b313992db4ecbc38883d389a3d365735ac0c3dce", "filename": "src/test/ui/async-await/async-fn-size.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -89,10 +89,10 @@ fn main() {\n     assert_eq!(8, std::mem::size_of_val(&await1_level1()));\n     assert_eq!(12, std::mem::size_of_val(&await2_level1()));\n     assert_eq!(12, std::mem::size_of_val(&await3_level1()));\n-    assert_eq!(20, std::mem::size_of_val(&await3_level2()));\n-    assert_eq!(28, std::mem::size_of_val(&await3_level3()));\n-    assert_eq!(36, std::mem::size_of_val(&await3_level4()));\n-    assert_eq!(44, std::mem::size_of_val(&await3_level5()));\n+    assert_eq!(24, std::mem::size_of_val(&await3_level2()));\n+    assert_eq!(36, std::mem::size_of_val(&await3_level3()));\n+    assert_eq!(48, std::mem::size_of_val(&await3_level4()));\n+    assert_eq!(60, std::mem::size_of_val(&await3_level5()));\n \n     assert_eq!(1,   wait(base()));\n     assert_eq!(1,   wait(await1_level1()));"}, {"sha": "398bcb7ec0e82977b86cac8489632bded0fe3c5c", "filename": "src/test/ui/drop/dynamic-drop-async.rs", "status": "modified", "additions": 110, "deletions": 53, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -7,7 +7,7 @@\n // edition:2018\n // ignore-wasm32-bare compiled with panic=abort by default\n \n-#![feature(slice_patterns)]\n+#![feature(slice_patterns, arbitrary_self_types)]\n #![allow(unused)]\n \n use std::{\n@@ -45,6 +45,7 @@ impl<T: Unpin> Future for Defer<T> {\n /// The `failing_op`-th operation will panic.\n struct Allocator {\n     data: RefCell<Vec<bool>>,\n+    name: &'static str,\n     failing_op: usize,\n     cur_ops: Cell<usize>,\n }\n@@ -56,23 +57,28 @@ impl Drop for Allocator {\n     fn drop(&mut self) {\n         let data = self.data.borrow();\n         if data.iter().any(|d| *d) {\n-            panic!(\"missing free: {:?}\", data);\n+            panic!(\"missing free in {:?}: {:?}\", self.name, data);\n         }\n     }\n }\n \n impl Allocator {\n-    fn new(failing_op: usize) -> Self {\n-        Allocator { failing_op, cur_ops: Cell::new(0), data: RefCell::new(vec![]) }\n+    fn new(failing_op: usize, name: &'static str) -> Self {\n+        Allocator {\n+            failing_op,\n+            name,\n+            cur_ops: Cell::new(0),\n+            data: RefCell::new(vec![]),\n+        }\n     }\n-    fn alloc(&self) -> impl Future<Output = Ptr<'_>> + '_ {\n+    fn alloc(self: &Rc<Allocator>) -> impl Future<Output = Ptr> + 'static {\n         self.fallible_operation();\n \n         let mut data = self.data.borrow_mut();\n \n         let addr = data.len();\n         data.push(true);\n-        Defer { ready: false, value: Some(Ptr(addr, self)) }\n+        Defer { ready: false, value: Some(Ptr(addr, self.clone())) }\n     }\n     fn fallible_operation(&self) {\n         self.cur_ops.set(self.cur_ops.get() + 1);\n@@ -85,11 +91,11 @@ impl Allocator {\n \n // Type that tracks whether it was dropped and can panic when it's created or\n // destroyed.\n-struct Ptr<'a>(usize, &'a Allocator);\n-impl<'a> Drop for Ptr<'a> {\n+struct Ptr(usize, Rc<Allocator>);\n+impl Drop for Ptr {\n     fn drop(&mut self) {\n         match self.1.data.borrow_mut()[self.0] {\n-            false => panic!(\"double free at index {:?}\", self.0),\n+            false => panic!(\"double free in {:?} at index {:?}\", self.1.name, self.0),\n             ref mut d => *d = false,\n         }\n \n@@ -113,7 +119,7 @@ async fn dynamic_drop(a: Rc<Allocator>, c: bool) {\n     };\n }\n \n-struct TwoPtrs<'a>(Ptr<'a>, Ptr<'a>);\n+struct TwoPtrs(Ptr, Ptr);\n async fn struct_dynamic_drop(a: Rc<Allocator>, c0: bool, c1: bool, c: bool) {\n     for i in 0..2 {\n         let x;\n@@ -228,21 +234,62 @@ async fn subslice_pattern_reassign(a: Rc<Allocator>) {\n     a.alloc().await;\n }\n \n-fn run_test<F, G>(cx: &mut Context<'_>, ref f: F)\n+async fn panic_after_return(a: Rc<Allocator>, c: bool) -> (Ptr,) {\n+    a.alloc().await;\n+    let p = a.alloc().await;\n+    if c {\n+        a.alloc().await;\n+        let q = a.alloc().await;\n+        // We use a return type that isn't used anywhere else to make sure that\n+        // the return place doesn't incorrectly end up in the generator state.\n+        return (a.alloc().await,);\n+    }\n+    (a.alloc().await,)\n+}\n+\n+\n+async fn panic_after_init_by_loop(a: Rc<Allocator>) {\n+    a.alloc().await;\n+    let p = a.alloc().await;\n+    let q = loop {\n+        a.alloc().await;\n+        let r = a.alloc().await;\n+        break a.alloc().await;\n+    };\n+}\n+\n+async fn panic_after_init_by_match_with_bindings_and_guard(a: Rc<Allocator>, b: bool) {\n+    a.alloc().await;\n+    let p = a.alloc().await;\n+    let q = match a.alloc().await {\n+        ref _x if b => {\n+            a.alloc().await;\n+            let r = a.alloc().await;\n+            a.alloc().await\n+        }\n+        _x => {\n+            a.alloc().await;\n+            let r = a.alloc().await;\n+            a.alloc().await\n+        },\n+    };\n+}\n+\n+fn run_test<F, G, O>(cx: &mut Context<'_>, ref f: F, name: &'static str)\n where\n     F: Fn(Rc<Allocator>) -> G,\n-    G: Future<Output = ()>,\n+    G: Future<Output = O>,\n {\n     for polls in 0.. {\n         // Run without any panics to find which operations happen after the\n         // penultimate `poll`.\n-        let first_alloc = Rc::new(Allocator::new(usize::MAX));\n+        let first_alloc = Rc::new(Allocator::new(usize::MAX, name));\n         let mut fut = Box::pin(f(first_alloc.clone()));\n         let mut ops_before_last_poll = 0;\n         let mut completed = false;\n         for _ in 0..polls {\n             ops_before_last_poll = first_alloc.cur_ops.get();\n-            if let Poll::Ready(()) = fut.as_mut().poll(cx) {\n+            if let Poll::Ready(_) = fut.as_mut().poll(cx) {\n                 completed = true;\n             }\n         }\n@@ -251,7 +298,7 @@ where\n         // Start at `ops_before_last_poll` so that we will always be able to\n         // `poll` the expected number of times.\n         for failing_op in ops_before_last_poll..first_alloc.cur_ops.get() {\n-            let alloc = Rc::new(Allocator::new(failing_op + 1));\n+            let alloc = Rc::new(Allocator::new(failing_op + 1, name));\n             let f = &f;\n             let cx = &mut *cx;\n             let result = panic::catch_unwind(panic::AssertUnwindSafe(move || {\n@@ -281,46 +328,56 @@ fn clone_waker(data: *const ()) -> RawWaker {\n     RawWaker::new(data, &RawWakerVTable::new(clone_waker, drop, drop, drop))\n }\n \n+macro_rules! run_test {\n+    ($ctxt:expr, $e:expr) => { run_test($ctxt, $e, stringify!($e)); };\n+}\n+\n fn main() {\n     let waker = unsafe { Waker::from_raw(clone_waker(ptr::null())) };\n     let context = &mut Context::from_waker(&waker);\n \n-    run_test(context, |a| dynamic_init(a, false));\n-    run_test(context, |a| dynamic_init(a, true));\n-    run_test(context, |a| dynamic_drop(a, false));\n-    run_test(context, |a| dynamic_drop(a, true));\n-\n-    run_test(context, |a| assignment(a, false, false));\n-    run_test(context, |a| assignment(a, false, true));\n-    run_test(context, |a| assignment(a, true, false));\n-    run_test(context, |a| assignment(a, true, true));\n-\n-    run_test(context, |a| array_simple(a));\n-    run_test(context, |a| vec_simple(a));\n-    run_test(context, |a| vec_unreachable(a));\n-\n-    run_test(context, |a| struct_dynamic_drop(a, false, false, false));\n-    run_test(context, |a| struct_dynamic_drop(a, false, false, true));\n-    run_test(context, |a| struct_dynamic_drop(a, false, true, false));\n-    run_test(context, |a| struct_dynamic_drop(a, false, true, true));\n-    run_test(context, |a| struct_dynamic_drop(a, true, false, false));\n-    run_test(context, |a| struct_dynamic_drop(a, true, false, true));\n-    run_test(context, |a| struct_dynamic_drop(a, true, true, false));\n-    run_test(context, |a| struct_dynamic_drop(a, true, true, true));\n-\n-    run_test(context, |a| field_assignment(a, false));\n-    run_test(context, |a| field_assignment(a, true));\n-\n-    run_test(context, |a| mixed_drop_and_nondrop(a));\n-\n-    run_test(context, |a| slice_pattern_one_of(a, 0));\n-    run_test(context, |a| slice_pattern_one_of(a, 1));\n-    run_test(context, |a| slice_pattern_one_of(a, 2));\n-    run_test(context, |a| slice_pattern_one_of(a, 3));\n-\n-    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, true));\n-    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, false));\n-    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n-    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n-    run_test(context, |a| subslice_pattern_reassign(a));\n+    run_test!(context, |a| dynamic_init(a, false));\n+    run_test!(context, |a| dynamic_init(a, true));\n+    run_test!(context, |a| dynamic_drop(a, false));\n+    run_test!(context, |a| dynamic_drop(a, true));\n+\n+    run_test!(context, |a| assignment(a, false, false));\n+    run_test!(context, |a| assignment(a, false, true));\n+    run_test!(context, |a| assignment(a, true, false));\n+    run_test!(context, |a| assignment(a, true, true));\n+\n+    run_test!(context, |a| array_simple(a));\n+    run_test!(context, |a| vec_simple(a));\n+    run_test!(context, |a| vec_unreachable(a));\n+\n+    run_test!(context, |a| struct_dynamic_drop(a, false, false, false));\n+    run_test!(context, |a| struct_dynamic_drop(a, false, false, true));\n+    run_test!(context, |a| struct_dynamic_drop(a, false, true, false));\n+    run_test!(context, |a| struct_dynamic_drop(a, false, true, true));\n+    run_test!(context, |a| struct_dynamic_drop(a, true, false, false));\n+    run_test!(context, |a| struct_dynamic_drop(a, true, false, true));\n+    run_test!(context, |a| struct_dynamic_drop(a, true, true, false));\n+    run_test!(context, |a| struct_dynamic_drop(a, true, true, true));\n+\n+    run_test!(context, |a| field_assignment(a, false));\n+    run_test!(context, |a| field_assignment(a, true));\n+\n+    run_test!(context, |a| mixed_drop_and_nondrop(a));\n+\n+    run_test!(context, |a| slice_pattern_one_of(a, 0));\n+    run_test!(context, |a| slice_pattern_one_of(a, 1));\n+    run_test!(context, |a| slice_pattern_one_of(a, 2));\n+    run_test!(context, |a| slice_pattern_one_of(a, 3));\n+\n+    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test!(context, |a| subslice_pattern_reassign(a));\n+\n+    run_test!(context, |a| panic_after_return(a, false));\n+    run_test!(context, |a| panic_after_return(a, true));\n+    run_test!(context, |a| panic_after_init_by_loop(a));\n+    run_test!(context, |a| panic_after_init_by_match_with_bindings_and_guard(a, false));\n+    run_test!(context, |a| panic_after_init_by_match_with_bindings_and_guard(a, true));\n }"}, {"sha": "6f9112ae006053a05edbe0f0bba31d4748d6b26d", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 176, "deletions": 105, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c9cece7b6829e6fd7854a1aee6a1619a81a38c/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=f3c9cece7b6829e6fd7854a1aee6a1619a81a38c", "patch": "@@ -17,6 +17,7 @@ struct InjectedFailure;\n \n struct Allocator {\n     data: RefCell<Vec<bool>>,\n+    name: &'static str,\n     failing_op: usize,\n     cur_ops: Cell<usize>,\n }\n@@ -28,17 +29,18 @@ impl Drop for Allocator {\n     fn drop(&mut self) {\n         let data = self.data.borrow();\n         if data.iter().any(|d| *d) {\n-            panic!(\"missing free: {:?}\", data);\n+            panic!(\"missing free in {:?}: {:?}\", self.name, data);\n         }\n     }\n }\n \n impl Allocator {\n-    fn new(failing_op: usize) -> Self {\n+    fn new(failing_op: usize, name: &'static str) -> Self {\n         Allocator {\n             failing_op: failing_op,\n             cur_ops: Cell::new(0),\n-            data: RefCell::new(vec![])\n+            data: RefCell::new(vec![]),\n+            name,\n         }\n     }\n     fn alloc(&self) -> Ptr<'_> {\n@@ -53,28 +55,14 @@ impl Allocator {\n         data.push(true);\n         Ptr(addr, self)\n     }\n-    // FIXME(#47949) Any use of this indicates a bug in rustc: we should never\n-    // be leaking values in the cases here.\n-    //\n-    // Creates a `Ptr<'_>` and checks that the allocated value is leaked if the\n-    // `failing_op` is in the list of exception.\n-    fn alloc_leaked(&self, exceptions: Vec<usize>) -> Ptr<'_> {\n-        let ptr = self.alloc();\n-\n-        if exceptions.iter().any(|operation| *operation == self.failing_op) {\n-            let mut data = self.data.borrow_mut();\n-            data[ptr.0] = false;\n-        }\n-        ptr\n-    }\n }\n \n struct Ptr<'a>(usize, &'a Allocator);\n impl<'a> Drop for Ptr<'a> {\n     fn drop(&mut self) {\n         match self.1.data.borrow_mut()[self.0] {\n             false => {\n-                panic!(\"double free at index {:?}\", self.0)\n+                panic!(\"double free in {:?} at index {:?}\", self.1.name, self.0)\n             }\n             ref mut d => *d = false\n         }\n@@ -270,79 +258,148 @@ fn subslice_pattern_reassign(a: &Allocator) {\n }\n \n fn panic_after_return(a: &Allocator) -> Ptr<'_> {\n-    // Panic in the drop of `p` or `q` can leak\n-    let exceptions = vec![8, 9];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let p = a.alloc();\n-        // FIXME (#47949) We leak values when we panic in a destructor after\n-        // evaluating an expression with `rustc_mir::build::Builder::into`.\n-        a.alloc_leaked(exceptions)\n+        a.alloc()\n     }\n }\n \n fn panic_after_return_expr(a: &Allocator) -> Ptr<'_> {\n-    // Panic in the drop of `p` or `q` can leak\n-    let exceptions = vec![8, 9];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let q = a.alloc();\n-        // FIXME (#47949)\n-        return a.alloc_leaked(exceptions);\n+        return a.alloc();\n     }\n }\n \n fn panic_after_init(a: &Allocator) {\n-    // Panic in the drop of `r` can leak\n-    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     let q = {\n         a.alloc();\n         let r = a.alloc();\n-        // FIXME (#47949)\n-        a.alloc_leaked(exceptions)\n+        a.alloc()\n     };\n }\n \n fn panic_after_init_temp(a: &Allocator) {\n-    // Panic in the drop of `r` can leak\n-    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let r = a.alloc();\n-        // FIXME (#47949)\n-        a.alloc_leaked(exceptions)\n+        a.alloc()\n     };\n }\n \n fn panic_after_init_by_loop(a: &Allocator) {\n-    // Panic in the drop of `r` can leak\n-    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     let q = loop {\n         a.alloc();\n         let r = a.alloc();\n-        // FIXME (#47949)\n-        break a.alloc_leaked(exceptions);\n+        break a.alloc();\n+    };\n+}\n+\n+fn panic_after_init_by_match(a: &Allocator, b: bool) {\n+    a.alloc();\n+    let p = a.alloc();\n+    loop {\n+        let q = match b {\n+            true => {\n+                a.alloc();\n+                let r = a.alloc();\n+                a.alloc()\n+            }\n+            false => {\n+                a.alloc();\n+                let r = a.alloc();\n+                break a.alloc();\n+            }\n+        };\n+        return;\n+    };\n+}\n+\n+fn panic_after_init_by_match_with_guard(a: &Allocator, b: bool) {\n+    a.alloc();\n+    let p = a.alloc();\n+    let q = match a.alloc() {\n+        _ if b => {\n+            a.alloc();\n+            let r = a.alloc();\n+            a.alloc()\n+        }\n+        _ => {\n+            a.alloc();\n+            let r = a.alloc();\n+            a.alloc()\n+        },\n+    };\n+}\n+\n+fn panic_after_init_by_match_with_bindings_and_guard(a: &Allocator, b: bool) {\n+    a.alloc();\n+    let p = a.alloc();\n+    let q = match a.alloc() {\n+        _x if b => {\n+            a.alloc();\n+            let r = a.alloc();\n+            a.alloc()\n+        }\n+        _x => {\n+            a.alloc();\n+            let r = a.alloc();\n+            a.alloc()\n+        },\n+    };\n+}\n+\n+fn panic_after_init_by_match_with_ref_bindings_and_guard(a: &Allocator, b: bool) {\n+    a.alloc();\n+    let p = a.alloc();\n+    let q = match a.alloc() {\n+        ref _x if b => {\n+            a.alloc();\n+            let r = a.alloc();\n+            a.alloc()\n+        }\n+        ref _x => {\n+            a.alloc();\n+            let r = a.alloc();\n+            a.alloc()\n+        },\n+    };\n+}\n+\n+fn panic_after_init_by_break_if(a: &Allocator, b: bool) {\n+    a.alloc();\n+    let p = a.alloc();\n+    let q = loop {\n+        let r = a.alloc();\n+        break if b {\n+            let s = a.alloc();\n+            a.alloc()\n+        } else {\n+            a.alloc()\n+        };\n     };\n }\n \n-fn run_test<F>(mut f: F)\n+fn run_test<F>(mut f: F, name: &'static str)\n     where F: FnMut(&Allocator)\n {\n-    let first_alloc = Allocator::new(usize::MAX);\n+    let first_alloc = Allocator::new(usize::MAX, name);\n     f(&first_alloc);\n \n     for failing_op in 1..first_alloc.cur_ops.get()+1 {\n-        let alloc = Allocator::new(failing_op);\n+        let alloc = Allocator::new(failing_op, name);\n         let alloc = &alloc;\n         let f = panic::AssertUnwindSafe(&mut f);\n         let result = panic::catch_unwind(move || {\n@@ -360,77 +417,91 @@ fn run_test<F>(mut f: F)\n     }\n }\n \n-fn run_test_nopanic<F>(mut f: F)\n+fn run_test_nopanic<F>(mut f: F, name: &'static str)\n     where F: FnMut(&Allocator)\n {\n-    let first_alloc = Allocator::new(usize::MAX);\n+    let first_alloc = Allocator::new(usize::MAX, name);\n     f(&first_alloc);\n }\n \n+macro_rules! run_test {\n+    ($e:expr) => { run_test($e, stringify!($e)); }\n+}\n+\n fn main() {\n-    run_test(|a| dynamic_init(a, false));\n-    run_test(|a| dynamic_init(a, true));\n-    run_test(|a| dynamic_drop(a, false));\n-    run_test(|a| dynamic_drop(a, true));\n-\n-    run_test(|a| assignment2(a, false, false));\n-    run_test(|a| assignment2(a, false, true));\n-    run_test(|a| assignment2(a, true, false));\n-    run_test(|a| assignment2(a, true, true));\n-\n-    run_test(|a| assignment1(a, false));\n-    run_test(|a| assignment1(a, true));\n-\n-    run_test(|a| array_simple(a));\n-    run_test(|a| vec_simple(a));\n-    run_test(|a| vec_unreachable(a));\n-\n-    run_test(|a| struct_dynamic_drop(a, false, false, false));\n-    run_test(|a| struct_dynamic_drop(a, false, false, true));\n-    run_test(|a| struct_dynamic_drop(a, false, true, false));\n-    run_test(|a| struct_dynamic_drop(a, false, true, true));\n-    run_test(|a| struct_dynamic_drop(a, true, false, false));\n-    run_test(|a| struct_dynamic_drop(a, true, false, true));\n-    run_test(|a| struct_dynamic_drop(a, true, true, false));\n-    run_test(|a| struct_dynamic_drop(a, true, true, true));\n-\n-    run_test(|a| field_assignment(a, false));\n-    run_test(|a| field_assignment(a, true));\n-\n-    run_test(|a| generator(a, 0));\n-    run_test(|a| generator(a, 1));\n-    run_test(|a| generator(a, 2));\n-    run_test(|a| generator(a, 3));\n-\n-    run_test(|a| mixed_drop_and_nondrop(a));\n-\n-    run_test(|a| slice_pattern_first(a));\n-    run_test(|a| slice_pattern_middle(a));\n-    run_test(|a| slice_pattern_two(a));\n-    run_test(|a| slice_pattern_last(a));\n-    run_test(|a| slice_pattern_one_of(a, 0));\n-    run_test(|a| slice_pattern_one_of(a, 1));\n-    run_test(|a| slice_pattern_one_of(a, 2));\n-    run_test(|a| slice_pattern_one_of(a, 3));\n-\n-    run_test(|a| subslice_pattern_from_end(a, true));\n-    run_test(|a| subslice_pattern_from_end(a, false));\n-    run_test(|a| subslice_pattern_from_end_with_drop(a, true, true));\n-    run_test(|a| subslice_pattern_from_end_with_drop(a, true, false));\n-    run_test(|a| subslice_pattern_from_end_with_drop(a, false, true));\n-    run_test(|a| subslice_pattern_from_end_with_drop(a, false, false));\n-    run_test(|a| slice_pattern_reassign(a));\n-    run_test(|a| subslice_pattern_reassign(a));\n-\n-    run_test(|a| {\n+    run_test!(|a| dynamic_init(a, false));\n+    run_test!(|a| dynamic_init(a, true));\n+    run_test!(|a| dynamic_drop(a, false));\n+    run_test!(|a| dynamic_drop(a, true));\n+\n+    run_test!(|a| assignment2(a, false, false));\n+    run_test!(|a| assignment2(a, false, true));\n+    run_test!(|a| assignment2(a, true, false));\n+    run_test!(|a| assignment2(a, true, true));\n+\n+    run_test!(|a| assignment1(a, false));\n+    run_test!(|a| assignment1(a, true));\n+\n+    run_test!(|a| array_simple(a));\n+    run_test!(|a| vec_simple(a));\n+    run_test!(|a| vec_unreachable(a));\n+\n+    run_test!(|a| struct_dynamic_drop(a, false, false, false));\n+    run_test!(|a| struct_dynamic_drop(a, false, false, true));\n+    run_test!(|a| struct_dynamic_drop(a, false, true, false));\n+    run_test!(|a| struct_dynamic_drop(a, false, true, true));\n+    run_test!(|a| struct_dynamic_drop(a, true, false, false));\n+    run_test!(|a| struct_dynamic_drop(a, true, false, true));\n+    run_test!(|a| struct_dynamic_drop(a, true, true, false));\n+    run_test!(|a| struct_dynamic_drop(a, true, true, true));\n+\n+    run_test!(|a| field_assignment(a, false));\n+    run_test!(|a| field_assignment(a, true));\n+\n+    run_test!(|a| generator(a, 0));\n+    run_test!(|a| generator(a, 1));\n+    run_test!(|a| generator(a, 2));\n+    run_test!(|a| generator(a, 3));\n+\n+    run_test!(|a| mixed_drop_and_nondrop(a));\n+\n+    run_test!(|a| slice_pattern_first(a));\n+    run_test!(|a| slice_pattern_middle(a));\n+    run_test!(|a| slice_pattern_two(a));\n+    run_test!(|a| slice_pattern_last(a));\n+    run_test!(|a| slice_pattern_one_of(a, 0));\n+    run_test!(|a| slice_pattern_one_of(a, 1));\n+    run_test!(|a| slice_pattern_one_of(a, 2));\n+    run_test!(|a| slice_pattern_one_of(a, 3));\n+\n+    run_test!(|a| subslice_pattern_from_end(a, true));\n+    run_test!(|a| subslice_pattern_from_end(a, false));\n+    run_test!(|a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test!(|a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test!(|a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test!(|a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test!(|a| slice_pattern_reassign(a));\n+    run_test!(|a| subslice_pattern_reassign(a));\n+\n+    run_test!(|a| {\n         panic_after_return(a);\n     });\n-    run_test(|a| {\n+    run_test!(|a| {\n         panic_after_return_expr(a);\n     });\n-    run_test(|a| panic_after_init(a));\n-    run_test(|a| panic_after_init_temp(a));\n-    run_test(|a| panic_after_init_by_loop(a));\n-\n-    run_test_nopanic(|a| union1(a));\n+    run_test!(|a| panic_after_init(a));\n+    run_test!(|a| panic_after_init_temp(a));\n+    run_test!(|a| panic_after_init_by_loop(a));\n+    run_test!(|a| panic_after_init_by_match(a, false));\n+    run_test!(|a| panic_after_init_by_match(a, true));\n+    run_test!(|a| panic_after_init_by_match_with_guard(a, false));\n+    run_test!(|a| panic_after_init_by_match_with_guard(a, true));\n+    run_test!(|a| panic_after_init_by_match_with_bindings_and_guard(a, false));\n+    run_test!(|a| panic_after_init_by_match_with_bindings_and_guard(a, true));\n+    run_test!(|a| panic_after_init_by_match_with_ref_bindings_and_guard(a, false));\n+    run_test!(|a| panic_after_init_by_match_with_ref_bindings_and_guard(a, true));\n+    run_test!(|a| panic_after_init_by_break_if(a, false));\n+    run_test!(|a| panic_after_init_by_break_if(a, true));\n+\n+    run_test_nopanic(|a| union1(a), \"|a| union1(a)\");\n }"}]}