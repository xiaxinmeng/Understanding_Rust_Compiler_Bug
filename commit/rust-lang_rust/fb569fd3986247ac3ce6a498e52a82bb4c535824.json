{"sha": "fb569fd3986247ac3ce6a498e52a82bb4c535824", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNTY5ZmQzOTg2MjQ3YWMzY2U2YTQ5OGU1MmE4MmJiNGM1MzU4MjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-11T09:26:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-11T09:26:43Z"}, "message": "auto merge of #14069 : alexcrichton/rust/cast-module, r=brson\n\nThis commit revisits the `cast` module in libcore and libstd, and scrutinizes\r\nall functions inside of it. The result was to remove the `cast` module entirely,\r\nfolding all functionality into the `mem` module. Specifically, this is the fate\r\nof each function in the `cast` module.\r\n\r\n* transmute - This function was moved to `mem`, but it is now marked as\r\n              #[unstable]. This is due to planned changes to the `transmute`\r\n              function and how it can be invoked (see the #[unstable] comment).\r\n              For more information, see RFC 5 and #12898\r\n\r\n* transmute_copy - This function was moved to `mem`, with clarification that is\r\n                   is not an error to invoke it with T/U that are different\r\n                   sizes, but rather that it is strongly discouraged. This\r\n                   function is now #[stable]\r\n\r\n* forget - This function was moved to `mem` and marked #[stable]\r\n\r\n* bump_box_refcount - This function was removed due to the deprecation of\r\n                      managed boxes as well as its questionable utility.\r\n\r\n* transmute_mut - This function was previously deprecated, and removed as part\r\n                  of this commit.\r\n\r\n* transmute_mut_unsafe - This function doesn't serve much of a purpose when it\r\n                         can be achieved with an `as` in safe code, so it was\r\n                         removed.\r\n\r\n* transmute_lifetime - This function was removed because it is likely a strong\r\n                       indication that code is incorrect in the first place.\r\n\r\n* transmute_mut_lifetime - This function was removed for the same reasons as\r\n                           `transmute_lifetime`\r\n\r\n* copy_lifetime - This function was moved to `mem`, but it is marked\r\n                  `#[unstable]` now due to the likelihood of being removed in\r\n                  the future if it is found to not be very useful.\r\n\r\n* copy_mut_lifetime - This function was also moved to `mem`, but had the same\r\n                      treatment as `copy_lifetime`.\r\n\r\n* copy_lifetime_vec - This function was removed because it is not used today,\r\n                      and its existence is not necessary with DST\r\n                      (copy_lifetime will suffice).\r\n\r\nIn summary, the cast module was stripped down to these functions, and then the\r\nfunctions were moved to the `mem` module.\r\n\r\n    transmute - #[unstable]\r\n    transmute_copy - #[stable]\r\n    forget - #[stable]\r\n    copy_lifetime - #[unstable]\r\n    copy_mut_lifetime - #[unstable]", "tree": {"sha": "97bea161eb7fff71a0e9a484aa9f190dbe037f58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97bea161eb7fff71a0e9a484aa9f190dbe037f58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb569fd3986247ac3ce6a498e52a82bb4c535824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb569fd3986247ac3ce6a498e52a82bb4c535824", "html_url": "https://github.com/rust-lang/rust/commit/fb569fd3986247ac3ce6a498e52a82bb4c535824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb569fd3986247ac3ce6a498e52a82bb4c535824/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "html_url": "https://github.com/rust-lang/rust/commit/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f"}, {"sha": "f94d671bfae5d8e9a4a4add310b1c40af0ab62a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f94d671bfae5d8e9a4a4add310b1c40af0ab62a6", "html_url": "https://github.com/rust-lang/rust/commit/f94d671bfae5d8e9a4a4add310b1c40af0ab62a6"}], "stats": {"total": 1489, "additions": 723, "deletions": 766}, "files": [{"sha": "d78e2103daca1584d227aef27cdb4d8da57169cf", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -66,11 +66,11 @@ restrictions is undefined behaviour. For example, the following\n creates two aliasing `&mut` pointers, and is invalid.\n \n ```\n-use std::cast;\n+use std::mem;\n let mut x: u8 = 1;\n \n let ref_1: &mut u8 = &mut x;\n-let ref_2: &mut u8 = unsafe { cast::transmute_mut_lifetime(ref_1) };\n+let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };\n \n // oops, ref_1 and ref_2 point to the same piece of data (x) and are\n // both usable"}, {"sha": "af9ffd5a4b6bfddf9759774fd22791fa4883f4b0", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -26,8 +26,6 @@\n \n extern crate collections;\n \n-use std::cast::{transmute, transmute_mut_lifetime};\n-use std::cast;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::intrinsics::{TyDesc, get_tydesc};\n@@ -137,7 +135,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     let fill = chunk.fill.get();\n \n     while idx < fill {\n-        let tydesc_data: *uint = transmute(buf.offset(idx as int));\n+        let tydesc_data: *uint = mem::transmute(buf.offset(idx as int));\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n@@ -187,28 +185,27 @@ impl Arena {\n     #[inline]\n     fn alloc_copy_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         unsafe {\n-            let this = transmute_mut_lifetime(self);\n-            let start = round_up(this.copy_head.fill.get(), align);\n+            let start = round_up(self.copy_head.fill.get(), align);\n             let end = start + n_bytes;\n             if end > self.chunk_size() {\n-                return this.alloc_copy_grow(n_bytes, align);\n+                return self.alloc_copy_grow(n_bytes, align);\n             }\n-            this.copy_head.fill.set(end);\n+            self.copy_head.fill.set(end);\n \n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill.get());\n \n-            this.copy_head.as_ptr().offset(start as int)\n+            self.copy_head.as_ptr().offset(start as int)\n         }\n     }\n \n     #[inline]\n     fn alloc_copy<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n         unsafe {\n             let ptr = self.alloc_copy_inner(mem::size_of::<T>(), min_align_of::<T>());\n-            let ptr: *mut T = transmute(ptr);\n+            let ptr = ptr as *mut T;\n             mem::move_val_init(&mut (*ptr), op());\n-            return transmute(ptr);\n+            return &*ptr;\n         }\n     }\n \n@@ -228,26 +225,16 @@ impl Arena {\n     fn alloc_noncopy_inner(&mut self, n_bytes: uint, align: uint)\n                           -> (*u8, *u8) {\n         unsafe {\n-            let start;\n-            let end;\n-            let tydesc_start;\n-            let after_tydesc;\n-\n-            {\n-                let head = transmute_mut_lifetime(&mut self.head);\n-\n-                tydesc_start = head.fill.get();\n-                after_tydesc = head.fill.get() + mem::size_of::<*TyDesc>();\n-                start = round_up(after_tydesc, align);\n-                end = start + n_bytes;\n-            }\n+            let tydesc_start = self.head.fill.get();\n+            let after_tydesc = self.head.fill.get() + mem::size_of::<*TyDesc>();\n+            let start = round_up(after_tydesc, align);\n+            let end = start + n_bytes;\n \n             if end > self.head.capacity() {\n                 return self.alloc_noncopy_grow(n_bytes, align);\n             }\n \n-            let head = transmute_mut_lifetime(&mut self.head);\n-            head.fill.set(round_up(end, mem::pref_align_of::<*TyDesc>()));\n+            self.head.fill.set(round_up(end, mem::pref_align_of::<*TyDesc>()));\n \n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n@@ -263,18 +250,18 @@ impl Arena {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n                 self.alloc_noncopy_inner(mem::size_of::<T>(), min_align_of::<T>());\n-            let ty_ptr: *mut uint = transmute(ty_ptr);\n-            let ptr: *mut T = transmute(ptr);\n+            let ty_ptr = ty_ptr as *mut uint;\n+            let ptr = ptr as *mut T;\n             // Write in our tydesc along with a bit indicating that it\n             // has *not* been initialized yet.\n-            *ty_ptr = transmute(tydesc);\n+            *ty_ptr = mem::transmute(tydesc);\n             // Actually initialize it\n             mem::move_val_init(&mut(*ptr), op());\n             // Now that we are done, update the tydesc to indicate that\n             // the object is there.\n             *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n \n-            return transmute(ptr);\n+            return &*ptr;\n         }\n     }\n \n@@ -283,7 +270,7 @@ impl Arena {\n     pub fn alloc<'a, T>(&'a self, op: || -> T) -> &'a T {\n         unsafe {\n             // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n-            let this: &mut Arena = transmute::<&_, &mut _>(self);\n+            let this: &mut Arena = mem::transmute::<&_, &mut _>(self);\n             if intrinsics::needs_drop::<T>() {\n                 this.alloc_noncopy(op)\n             } else {\n@@ -366,7 +353,7 @@ impl<T> TypedArenaChunk<T> {\n \n         let mut chunk = unsafe {\n             let chunk = exchange_malloc(size);\n-            let mut chunk: Box<TypedArenaChunk<T>> = cast::transmute(chunk);\n+            let mut chunk: Box<TypedArenaChunk<T>> = mem::transmute(chunk);\n             mem::move_val_init(&mut chunk.next, next);\n             chunk\n         };\n@@ -387,7 +374,7 @@ impl<T> TypedArenaChunk<T> {\n \n         let mut chunk = unsafe {\n             let chunk = exchange_malloc(size, min_align_of::<TypedArenaChunk<T>>());\n-            let mut chunk: Box<TypedArenaChunk<T>> = cast::transmute(chunk);\n+            let mut chunk: Box<TypedArenaChunk<T>> = mem::transmute(chunk);\n             mem::move_val_init(&mut chunk.next, next);\n             chunk\n         };\n@@ -425,7 +412,7 @@ impl<T> TypedArenaChunk<T> {\n     fn start(&self) -> *u8 {\n         let this: *TypedArenaChunk<T> = self;\n         unsafe {\n-            cast::transmute(round_up(this.offset(1) as uint, min_align_of::<T>()))\n+            mem::transmute(round_up(this.offset(1) as uint, min_align_of::<T>()))\n         }\n     }\n \n@@ -463,12 +450,12 @@ impl<T> TypedArena<T> {\n     pub fn alloc<'a>(&'a self, object: T) -> &'a T {\n         unsafe {\n             // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n-            let this: &mut TypedArena<T> = cast::transmute::<&_, &mut _>(self);\n+            let this: &mut TypedArena<T> = mem::transmute::<&_, &mut _>(self);\n             if this.ptr == this.end {\n                 this.grow()\n             }\n \n-            let ptr: &'a mut T = cast::transmute(this.ptr);\n+            let ptr: &'a mut T = mem::transmute(this.ptr);\n             mem::move_val_init(ptr, object);\n             this.ptr = this.ptr.offset(1);\n             let ptr: &'a T = ptr;"}, {"sha": "3a797cc935461ac91ab8236eb5a8374f910bf015", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -21,10 +21,9 @@\n // Backlinks over DList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n-use std::cast;\n use std::iter::Rev;\n use std::iter;\n-use std::mem::{replace, swap};\n+use std::mem;\n use std::ptr;\n \n use deque::Deque;\n@@ -93,13 +92,13 @@ impl<T> Rawlink<T> {\n         if self.p.is_null() {\n             None\n         } else {\n-            Some(unsafe { cast::transmute(self.p) })\n+            Some(unsafe { mem::transmute(self.p) })\n         }\n     }\n \n     /// Return the `Rawlink` and replace with `Rawlink::none()`\n     fn take(&mut self) -> Rawlink<T> {\n-        replace(self, Rawlink::none())\n+        mem::replace(self, Rawlink::none())\n     }\n }\n \n@@ -159,7 +158,7 @@ impl<T> DList<T> {\n             Some(ref mut head) => {\n                 new_head.prev = Rawlink::none();\n                 head.prev = Rawlink::some(new_head);\n-                swap(head, &mut new_head);\n+                mem::swap(head, &mut new_head);\n                 head.next = Some(new_head);\n             }\n         }\n@@ -317,7 +316,7 @@ impl<T> DList<T> {\n     /// O(1)\n     #[inline]\n     pub fn prepend(&mut self, mut other: DList<T>) {\n-        swap(self, &mut other);\n+        mem::swap(self, &mut other);\n         self.append(other);\n     }\n "}, {"sha": "41501f2d261ec01d502fcb94c77a6502e8a261b5", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -137,7 +137,7 @@ impl<E:CLike> Iterator<E> for Items<E> {\n #[cfg(test)]\n mod test {\n \n-    use std::cast;\n+    use std::mem;\n \n     use enum_set::{EnumSet, CLike};\n \n@@ -153,7 +153,7 @@ mod test {\n         }\n \n         fn from_uint(v: uint) -> Foo {\n-            unsafe { cast::transmute(v) }\n+            unsafe { mem::transmute(v) }\n         }\n     }\n "}, {"sha": "c062fc74c1d0e8f767dd90e7b945ac301f38363f", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -37,7 +37,6 @@\n //! assert!(cache.get(&2).is_none());\n //! ```\n \n-use std::cast;\n use std::container::Container;\n use std::hash::Hash;\n use std::fmt;\n@@ -93,7 +92,7 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n         let cache = LruCache {\n             map: HashMap::new(),\n             max_size: capacity,\n-            head: unsafe{ cast::transmute(box mem::uninit::<LruEntry<K, V>>()) },\n+            head: unsafe{ mem::transmute(box mem::uninit::<LruEntry<K, V>>()) },\n         };\n         unsafe {\n             (*cache.head).next = cache.head;\n@@ -241,11 +240,11 @@ impl<K: Hash + TotalEq, V> Mutable for LruCache<K, V> {\n impl<K, V> Drop for LruCache<K, V> {\n     fn drop(&mut self) {\n         unsafe {\n-            let node: Box<LruEntry<K, V>> = cast::transmute(self.head);\n+            let node: Box<LruEntry<K, V>> = mem::transmute(self.head);\n             // Prevent compiler from trying to drop the un-initialized field in the sigil node.\n             let box LruEntry { key: k, value: v, .. } = node;\n-            cast::forget(k);\n-            cast::forget(v);\n+            mem::forget(k);\n+            mem::forget(v);\n         }\n     }\n }"}, {"sha": "b0227fd60bfebcd5a256d58de57518f812adbbea", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -20,7 +20,7 @@\n //! value. `Box<Any>` adds the `move` method, which will unwrap a `Box<T>` from the object.  See\n //! the extension traits (`*Ext`) for the full details.\n \n-use cast::{transmute, transmute_copy};\n+use mem::{transmute, transmute_copy};\n use option::{Option, Some, None};\n use owned::Box;\n use raw::TraitObject;"}, {"sha": "cf99fdbd5d4c229739d746f424e4e9bb51fbcef6", "filename": "src/libcore/cast.rs", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -1,127 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Unsafe casting functions\n-\n-use mem;\n-use intrinsics;\n-use ptr::copy_nonoverlapping_memory;\n-\n-/**\n- * Transform a value of one type into a value of another type.\n- * Both types must have the same size and alignment.\n- *\n- * # Example\n- *\n- * ```rust\n- * use std::cast;\n- *\n- * let v: &[u8] = unsafe { cast::transmute(\"L\") };\n- * assert!(v == [76u8]);\n- * ```\n- */\n-#[inline]\n-pub unsafe fn transmute<T, U>(thing: T) -> U {\n-    intrinsics::transmute(thing)\n-}\n-\n-/**\n- * Move a thing into the void\n- *\n- * The forget function will take ownership of the provided value but neglect\n- * to run any required cleanup or memory-management operations on it.\n- */\n-#[inline]\n-pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing); }\n-\n-/// Casts the value at `src` to U. The two types must have the same length.\n-#[inline]\n-pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    let mut dest: U = mem::uninit();\n-    let dest_ptr: *mut u8 = transmute(&mut dest);\n-    let src_ptr: *u8 = transmute(src);\n-    copy_nonoverlapping_memory(dest_ptr, src_ptr, mem::size_of::<U>());\n-    dest\n-}\n-\n-/// Coerce an immutable reference to be mutable.\n-#[inline]\n-#[deprecated=\"casting &T to &mut T is undefined behaviour: use Cell<T>, RefCell<T> or Unsafe<T>\"]\n-pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }\n-\n-/// Coerce a reference to have an arbitrary associated lifetime.\n-#[inline]\n-pub unsafe fn transmute_lifetime<'a,'b,T>(ptr: &'a T) -> &'b T {\n-    transmute(ptr)\n-}\n-\n-/// Coerce an immutable reference to be mutable.\n-#[inline]\n-pub unsafe fn transmute_mut_unsafe<T>(ptr: *T) -> *mut T {\n-    transmute(ptr)\n-}\n-\n-/// Coerce a mutable reference to have an arbitrary associated lifetime.\n-#[inline]\n-pub unsafe fn transmute_mut_lifetime<'a,'b,T>(ptr: &'a mut T) -> &'b mut T {\n-    transmute(ptr)\n-}\n-\n-/// Transforms lifetime of the second pointer to match the first.\n-#[inline]\n-pub unsafe fn copy_lifetime<'a,S,T>(_ptr: &'a S, ptr: &T) -> &'a T {\n-    transmute_lifetime(ptr)\n-}\n-\n-/// Transforms lifetime of the second pointer to match the first.\n-#[inline]\n-pub unsafe fn copy_mut_lifetime<'a,S,T>(_ptr: &'a mut S, ptr: &mut T) -> &'a mut T {\n-    transmute_mut_lifetime(ptr)\n-}\n-\n-/// Transforms lifetime of the second pointer to match the first.\n-#[inline]\n-pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n-    transmute_lifetime(ptr)\n-}\n-\n-\n-/****************************************************************************\n- * Tests\n- ****************************************************************************/\n-\n-#[cfg(test)]\n-mod tests {\n-    use cast::transmute;\n-    use raw;\n-    use realstd::str::StrAllocating;\n-\n-    #[test]\n-    fn test_transmute_copy() {\n-        assert_eq!(1u, unsafe { ::cast::transmute_copy(&1) });\n-    }\n-\n-    #[test]\n-    fn test_transmute() {\n-        unsafe {\n-            let x = @100u8;\n-            let x: *raw::Box<u8> = transmute(x);\n-            assert!((*x).data == 100);\n-            let _x: @int = transmute(x);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_transmute2() {\n-        unsafe {\n-            assert_eq!(box [76u8], transmute(\"L\".to_owned()));\n-        }\n-    }\n-}"}, {"sha": "7f2deb81f8c90c2a43622a2464111fc7ed9245dc", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -24,7 +24,7 @@\n //! and, as such, should be performed via the `from_u32` function..\n \n \n-use cast::transmute;\n+use mem::transmute;\n use option::{None, Option, Some};\n use iter::{Iterator, range_step};\n use unicode::{derived_property, property, general_category, decompose, conversions};"}, {"sha": "148b63dfbfeaeec1ec7fc06e6b38a5e8aad9aab1", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -112,12 +112,12 @@ pub mod marker {\n     /// but does not actually *reference* that type parameter:\n     ///\n     /// ```ignore\n-    /// use std::cast;\n+    /// use std::mem;\n     ///\n     /// struct S<T> { x: *() }\n     /// fn get<T>(s: &S<T>) -> T {\n     ///    unsafe {\n-    ///        let x: *T = cast::transmute(s.x);\n+    ///        let x: *T = mem::transmute(s.x);\n     ///        *x\n     ///    }\n     /// }\n@@ -153,12 +153,12 @@ pub mod marker {\n     /// but does not actually *reference* that type parameter:\n     ///\n     /// ```\n-    /// use std::cast;\n+    /// use std::mem;\n     ///\n     /// struct S<T> { x: *() }\n     /// fn get<T>(s: &S<T>, v: T) {\n     ///    unsafe {\n-    ///        let x: fn(T) = cast::transmute(s.x);\n+    ///        let x: fn(T) = mem::transmute(s.x);\n     ///        x(v)\n     ///    }\n     /// }"}, {"sha": "41719d1354a1697be17bc919b7694f6325490c82", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -63,7 +63,6 @@ pub mod prelude;\n \n /* Core modules for ownership management */\n \n-pub mod cast;\n pub mod intrinsics;\n pub mod mem;\n pub mod ptr;"}, {"sha": "feb66f569645bde60ecc6fa5e5b702ca16d6db32", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 112, "deletions": 2, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -13,7 +13,6 @@\n //! This module contains functions for querying the size and alignment of\n //! types, initializing and manipulating memory.\n \n-use cast;\n use ptr;\n use intrinsics;\n use intrinsics::{bswap16, bswap32, bswap64};\n@@ -239,7 +238,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n \n         // y and t now point to the same thing, but we need to completely forget `t`\n         // because it's no longer relevant.\n-        cast::forget(t);\n+        forget(t);\n     }\n }\n \n@@ -286,14 +285,103 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n }\n \n /// Disposes of a value.\n+///\n+/// This function can be used to destroy any value by allowing `drop` to take\n+/// ownership of its argument.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::cell::RefCell;\n+///\n+/// let x = RefCell::new(1);\n+///\n+/// let mut mutable_borrow = x.borrow_mut();\n+/// *mutable_borrow = 1;\n+/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n+///\n+/// let borrow = x.borrow();\n+/// println!(\"{}\", *borrow);\n+/// ```\n #[inline]\n pub fn drop<T>(_x: T) { }\n \n+/// Moves a thing into the void.\n+///\n+/// The forget function will take ownership of the provided value but neglect\n+/// to run any required cleanup or memory management operations on it.\n+///\n+/// This function is the unsafe version of the `drop` function because it does\n+/// not run any destructors.\n+#[inline]\n+#[stable]\n+pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing) }\n+\n+/// Unsafely transforms a value of one type into a value of another type.\n+///\n+/// Both types must have the same size and alignment, and this guarantee is\n+/// enforced at compile-time.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::mem;\n+///\n+/// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n+/// assert!(v == [76u8]);\n+/// ```\n+#[inline]\n+#[unstable = \"this function will be modified to reject invocations of it which \\\n+              cannot statically prove that T and U are the same size. For \\\n+              example, this function, as written today, will be rejected in \\\n+              the future because the size of T and U cannot be statically \\\n+              known to be the same\"]\n+pub unsafe fn transmute<T, U>(thing: T) -> U {\n+    intrinsics::transmute(thing)\n+}\n+\n+/// Interprets `src` as `&U`, and then reads `src` without moving the contained\n+/// value.\n+///\n+/// This function will unsafely assume the pointer `src` is valid for\n+/// `sizeof(U)` bytes by transmuting `&T` to `&U` and then reading the `&U`. It\n+/// will also unsafely create a copy of the contained value instead of moving\n+/// out of `src`.\n+///\n+/// It is not a compile-time error if `T` and `U` have different sizes, but it\n+/// is highly encouraged to only invoke this function where `T` and `U` have the\n+/// same size. This function triggers undefined behavior if `U` is larger than\n+/// `T`.\n+#[inline]\n+#[stable]\n+pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n+    ptr::read(src as *T as *U)\n+}\n+\n+/// Transforms lifetime of the second pointer to match the first.\n+#[inline]\n+#[unstable = \"this function may be removed in the future due to its \\\n+              questionable utility\"]\n+pub unsafe fn copy_lifetime<'a, S, T>(_ptr: &'a S, ptr: &T) -> &'a T {\n+    transmute(ptr)\n+}\n+\n+/// Transforms lifetime of the second mutable pointer to match the first.\n+#[inline]\n+#[unstable = \"this function may be removed in the future due to its \\\n+              questionable utility\"]\n+pub unsafe fn copy_mut_lifetime<'a, S, T>(_ptr: &'a mut S,\n+                                          ptr: &mut T) -> &'a mut T {\n+    transmute(ptr)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use mem::*;\n     use option::{Some,None};\n     use realstd::str::StrAllocating;\n+    use owned::Box;\n+    use raw;\n \n     #[test]\n     fn size_of_basic() {\n@@ -389,6 +477,28 @@ mod tests {\n         assert!(x.is_none());\n         assert!(y.is_some());\n     }\n+\n+    #[test]\n+    fn test_transmute_copy() {\n+        assert_eq!(1u, unsafe { ::mem::transmute_copy(&1) });\n+    }\n+\n+    #[test]\n+    fn test_transmute() {\n+        trait Foo {}\n+        impl Foo for int {}\n+\n+        let a = box 100 as Box<Foo>;\n+        unsafe {\n+            let x: raw::TraitObject = transmute(a);\n+            assert!(*(x.data as *int) == 100);\n+            let _x: Box<Foo> = transmute(x);\n+        }\n+\n+        unsafe {\n+            assert_eq!(box [76u8], transmute(\"L\".to_owned()));\n+        }\n+    }\n }\n \n // FIXME #13642 (these benchmarks should be in another place)"}, {"sha": "fd6d174a7036e29edd2481ef3b01ad94691515d8", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -604,10 +604,10 @@ mod tests {\n     fn test_get_ptr() {\n         unsafe {\n             let x = box 0;\n-            let addr_x: *int = ::cast::transmute(&*x);\n+            let addr_x: *int = ::mem::transmute(&*x);\n             let opt = Some(x);\n             let y = opt.unwrap();\n-            let addr_y: *int = ::cast::transmute(&*y);\n+            let addr_y: *int = ::mem::transmute(&*y);\n             assert_eq!(addr_x, addr_y);\n         }\n     }"}, {"sha": "438e18d999b6c77b5369b8b01aafa02b16e07688", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -52,18 +52,18 @@\n //! though unsafely, transformed from one type to the other.\n //!\n //! ```\n-//! use std::cast;\n+//! use std::mem;\n //!\n //! unsafe {\n //!     let my_num: Box<int> = box 10;\n-//!     let my_num: *int = cast::transmute(my_num);\n+//!     let my_num: *int = mem::transmute(my_num);\n //!     let my_speed: Box<int> = box 88;\n-//!     let my_speed: *mut int = cast::transmute(my_speed);\n+//!     let my_speed: *mut int = mem::transmute(my_speed);\n //!\n //!     // By taking ownership of the original `Box<T>` though\n //!     // we are obligated to transmute it back later to be destroyed.\n-//!     drop(cast::transmute::<_, Box<int>>(my_speed));\n-//!     drop(cast::transmute::<_, Box<int>>(my_num));\n+//!     drop(mem::transmute::<_, Box<int>>(my_speed));\n+//!     drop(mem::transmute::<_, Box<int>>(my_num));\n //! }\n //! ```\n //!\n@@ -92,11 +92,10 @@\n //! but C APIs hand out a lot of pointers generally, so are a common source\n //! of unsafe pointers in Rust.\n \n-use cast;\n+use mem;\n use clone::Clone;\n use intrinsics;\n use iter::{range, Iterator};\n-use mem;\n use option::{Some, None, Option};\n \n #[cfg(not(test))] use cmp::{Eq, TotalEq, Ord, Equiv};\n@@ -196,7 +195,6 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n /// A safe swap function:\n ///\n /// ```\n-/// use std::cast;\n /// use std::mem;\n /// use std::ptr;\n ///\n@@ -212,7 +210,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n ///\n ///         // y and t now point to the same thing, but we need to completely forget `tmp`\n ///         // because it's no longer relevant.\n-///         cast::forget(t);\n+///         mem::forget(t);\n ///     }\n /// }\n /// ```\n@@ -256,14 +254,14 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n \n     // y and t now point to the same thing, but we need to completely forget `tmp`\n     // because it's no longer relevant.\n-    cast::forget(tmp);\n+    mem::forget(tmp);\n }\n \n /// Replace the value at a mutable location with a new one, returning the old\n /// value, without deinitialising either.\n #[inline]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n-    mem::swap(cast::transmute(dest), &mut src); // cannot overlap\n+    mem::swap(mem::transmute(dest), &mut src); // cannot overlap\n     src\n }\n \n@@ -361,7 +359,7 @@ impl<T> RawPtr<T> for *T {\n         if self.is_null() {\n             None\n         } else {\n-            Some(cast::transmute(*self))\n+            Some(mem::transmute(*self))\n         }\n     }\n }\n@@ -386,7 +384,7 @@ impl<T> RawPtr<T> for *mut T {\n         if self.is_null() {\n             None\n         } else {\n-            Some(cast::transmute(*self))\n+            Some(mem::transmute(*self))\n         }\n     }\n }\n@@ -436,14 +434,14 @@ impl<T> Equiv<*T> for *mut T {\n // Equality for extern \"C\" fn pointers\n #[cfg(not(test))]\n mod externfnpointers {\n-    use cast;\n+    use mem;\n     use cmp::Eq;\n \n     impl<_R> Eq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n-            let self_: *() = unsafe { cast::transmute(*self) };\n-            let other_: *() = unsafe { cast::transmute(*other) };\n+            let self_: *() = unsafe { mem::transmute(*self) };\n+            let other_: *() = unsafe { mem::transmute(*other) };\n             self_ == other_\n         }\n     }\n@@ -452,8 +450,8 @@ mod externfnpointers {\n             impl<_R,$($p),*> Eq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n-                    let self_: *() = unsafe { cast::transmute(*self) };\n-                    let other_: *() = unsafe { cast::transmute(*other) };\n+                    let self_: *() = unsafe { mem::transmute(*self) };\n+                    let other_: *() = unsafe { mem::transmute(*other) };\n                     self_ == other_\n                 }\n             }\n@@ -485,7 +483,7 @@ pub mod ptr_tests {\n     use realstd::prelude::*;\n \n     use realstd::c_str::ToCStr;\n-    use cast;\n+    use mem;\n     use libc;\n     use realstd::str;\n     use slice::{ImmutableVector, MutableVector};\n@@ -499,7 +497,7 @@ pub mod ptr_tests {\n             };\n             let mut p = Pair {fst: 10, snd: 20};\n             let pptr: *mut Pair = &mut p;\n-            let iptr: *mut int = cast::transmute(pptr);\n+            let iptr: *mut int = mem::transmute(pptr);\n             assert_eq!(*iptr, 10);\n             *iptr = 30;\n             assert_eq!(*iptr, 30);"}, {"sha": "25f40b358ab259fbb0df60d4fa9feac6a4b3b673", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -18,7 +18,7 @@\n //!\n //! Their definition should always match the ABI defined in `rustc::back::abi`.\n \n-use cast;\n+use mem;\n \n /// The representation of a Rust managed box\n pub struct Box<T> {\n@@ -74,7 +74,7 @@ pub trait Repr<T> {\n     /// for the struct. This is a safe method because by default it does not\n     /// enable write-access to the fields of the return value in safe code.\n     #[inline]\n-    fn repr(&self) -> T { unsafe { cast::transmute_copy(self) } }\n+    fn repr(&self) -> T { unsafe { mem::transmute_copy(self) } }\n }\n \n impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n@@ -87,7 +87,7 @@ impl Repr<*String> for ~str {}\n mod tests {\n     use super::*;\n \n-    use cast;\n+    use mem;\n \n     #[test]\n     fn synthesize_closure() {\n@@ -97,7 +97,7 @@ mod tests {\n \n             assert_eq!(f(20), 30);\n \n-            let original_closure: Closure = cast::transmute(f);\n+            let original_closure: Closure = mem::transmute(f);\n \n             let actual_function_pointer = original_closure.code;\n             let environment = original_closure.env;\n@@ -107,7 +107,7 @@ mod tests {\n                 env: environment\n             };\n \n-            let new_f: |int| -> int = cast::transmute(new_closure);\n+            let new_f: |int| -> int = mem::transmute(new_closure);\n             assert_eq!(new_f(20), 30);\n         }\n     }"}, {"sha": "d8df20218c5ad2def2e2afce6081f3927f69af43", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cast;\n use char::Char;\n use clone::Clone;\n use container::Container;\n@@ -73,7 +72,7 @@ impl Default for ~str {\n             (*ptr).fill = 0;\n             (*ptr).alloc = 0;\n \n-            cast::transmute(ptr)\n+            mem::transmute(ptr)\n         }\n     }\n }\n@@ -91,7 +90,7 @@ impl Clone for ~str {\n             (*ptr).fill = len;\n             (*ptr).alloc = len;\n \n-            cast::transmute(ptr)\n+            mem::transmute(ptr)\n         }\n     }\n }\n@@ -106,7 +105,7 @@ impl FromIterator<char> for ~str {\n \n         unsafe {\n             let mut ptr = alloc(cap) as *mut Vec<u8>;\n-            let mut ret = cast::transmute(ptr);\n+            let mut ret = mem::transmute(ptr);\n             for ch in iterator {\n                 let amt = ch.encode_utf8(tmp);\n \n@@ -121,8 +120,8 @@ impl FromIterator<char> for ~str {\n                                                     len);\n                     // FIXME: #13994: port to the sized deallocation API when available\n                     rust_free(ptr as *u8, 0, 8);\n-                    cast::forget(ret);\n-                    ret = cast::transmute(ptr2);\n+                    mem::forget(ret);\n+                    ret = mem::transmute(ptr2);\n                     ptr = ptr2;\n                 }\n \n@@ -155,7 +154,7 @@ impl<'a> Add<&'a str,~str> for &'a str {\n                                             rhs.len());\n             (*ptr).fill = amt;\n             (*ptr).alloc = amt;\n-            cast::transmute(ptr)\n+            mem::transmute(ptr)\n         }\n     }\n }\n@@ -192,7 +191,7 @@ impl<A: Clone> Clone for ~[A] {\n                     }\n                     rust_free(ret as *u8, 0, 8);\n                 });\n-            cast::transmute(ret)\n+            mem::transmute(ret)\n         }\n     }\n }"}, {"sha": "11309b44a6006ea65d5cc64b1e5692e3d7b06b5d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -12,8 +12,7 @@\n //!\n //! For more details `std::slice`.\n \n-use cast;\n-use cast::transmute;\n+use mem::transmute;\n use clone::Clone;\n use container::Container;\n use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n@@ -1012,7 +1011,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n             let len = self.len();\n-            let self2: &'a mut [T] = cast::transmute_copy(&self);\n+            let self2: &'a mut [T] = mem::transmute_copy(&self);\n             (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n         }\n     }\n@@ -1162,7 +1161,7 @@ impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n \n /// Unsafe operations\n pub mod raw {\n-    use cast::transmute;\n+    use mem::transmute;\n     use iter::Iterator;\n     use ptr::RawPtr;\n     use raw::Slice;"}, {"sha": "e677c4880b58db0d5d12226ab6368845341f12e0", "filename": "src/libcore/str.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -12,8 +12,7 @@\n //!\n //! For more details, see std::str\n \n-use cast::transmute;\n-use cast;\n+use mem;\n use char;\n use clone::Clone;\n use cmp::{Eq, TotalEq};\n@@ -572,7 +571,7 @@ impl<'a> Iterator<UTF16Item> for UTF16Items<'a> {\n \n         if u < 0xD800 || 0xDFFF < u {\n             // not a surrogate\n-            Some(ScalarValue(unsafe {cast::transmute(u as u32)}))\n+            Some(ScalarValue(unsafe {mem::transmute(u as u32)}))\n         } else if u >= 0xDC00 {\n             // a trailing surrogate\n             Some(LoneSurrogate(u))\n@@ -594,7 +593,7 @@ impl<'a> Iterator<UTF16Item> for UTF16Items<'a> {\n \n             // all ok, so lets decode it.\n             let c = ((u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n-            Some(ScalarValue(unsafe {cast::transmute(c)}))\n+            Some(ScalarValue(unsafe {mem::transmute(c)}))\n         }\n     }\n \n@@ -710,7 +709,7 @@ static TAG_CONT_U8: u8 = 128u8;\n \n /// Unsafe operations\n pub mod raw {\n-    use cast;\n+    use mem;\n     use container::Container;\n     use iter::Iterator;\n     use ptr::RawPtr;\n@@ -721,7 +720,7 @@ pub mod raw {\n     /// Converts a slice of bytes to a string slice without checking\n     /// that the string contains valid UTF-8.\n     pub unsafe fn from_utf8<'a>(v: &'a [u8]) -> &'a str {\n-        cast::transmute(v)\n+        mem::transmute(v)\n     }\n \n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n@@ -736,8 +735,8 @@ pub mod raw {\n             curr = s.offset(len as int);\n         }\n         let v = Slice { data: s, len: len };\n-        assert!(is_utf8(::cast::transmute(v)));\n-        ::cast::transmute(v)\n+        assert!(is_utf8(::mem::transmute(v)));\n+        ::mem::transmute(v)\n     }\n \n     /// Takes a bytewise (not UTF-8) slice from a string.\n@@ -762,7 +761,7 @@ pub mod raw {\n     /// Caller must check slice boundaries!\n     #[inline]\n     pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        cast::transmute(Slice {\n+        mem::transmute(Slice {\n                 data: s.as_ptr().offset(begin as int),\n                 len: end - begin,\n             })\n@@ -1747,7 +1746,7 @@ impl<'a> StrSlice<'a> for &'a str {\n             if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n             if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n-            return CharRange {ch: unsafe { transmute(val) }, next: i + w};\n+            return CharRange {ch: unsafe { mem::transmute(val) }, next: i + w};\n         }\n \n         return multibyte_char_range_at(*self, i);\n@@ -1776,7 +1775,7 @@ impl<'a> StrSlice<'a> for &'a str {\n             if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n             if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n-            return CharRange {ch: unsafe { transmute(val) }, next: i};\n+            return CharRange {ch: unsafe { mem::transmute(val) }, next: i};\n         }\n \n         return multibyte_char_range_at_reverse(*self, prev);\n@@ -1794,7 +1793,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn as_bytes(&self) -> &'a [u8] {\n-        unsafe { cast::transmute(*self) }\n+        unsafe { mem::transmute(*self) }\n     }\n \n     fn find<C: CharEq>(&self, mut search: C) -> Option<uint> {"}, {"sha": "47a2005fef1e6e9f9ab979aa4cfcef26cf469aa8", "filename": "src/libcore/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibcore%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fty.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,7 +10,6 @@\n \n //! Types dealing with unsafe actions.\n \n-use cast;\n use kinds::marker;\n \n /// Unsafe type that wraps a type T and indicates unsafe interior operations on the\n@@ -63,7 +62,7 @@ impl<T> Unsafe<T> {\n \n     /// Gets a mutable pointer to the wrapped value\n     #[inline]\n-    pub unsafe fn get(&self) -> *mut T { cast::transmute_mut_unsafe(&self.value) }\n+    pub unsafe fn get(&self) -> *mut T { &self.value as *T as *mut T }\n \n     /// Unwraps the value\n     #[inline]"}, {"sha": "9e42e2f67c485042e725d277e2f47822f720e5cb", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -15,8 +15,7 @@\n //! This implementation is also used as the fallback implementation of an event\n //! loop if no other one is provided (and M:N scheduling is desired).\n \n-use std::cast;\n-use std::mem::replace;\n+use std::mem;\n use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback};\n use std::rt::rtio::{PausableIdleCallback, Callback};\n use std::unstable::sync::Exclusive;\n@@ -50,7 +49,7 @@ impl BasicLoop {\n     /// Process everything in the work queue (continually)\n     fn work(&mut self) {\n         while self.work.len() > 0 {\n-            for work in replace(&mut self.work, vec![]).move_iter() {\n+            for work in mem::replace(&mut self.work, vec![]).move_iter() {\n                 work();\n             }\n         }\n@@ -60,7 +59,7 @@ impl BasicLoop {\n         let messages = unsafe {\n             self.messages.with(|messages| {\n                 if messages.len() > 0 {\n-                    Some(replace(messages, vec![]))\n+                    Some(mem::replace(messages, vec![]))\n                 } else {\n                     None\n                 }\n@@ -145,7 +144,7 @@ impl EventLoop for BasicLoop {\n         let callback = box BasicPausable::new(self, cb);\n         rtassert!(self.idle.is_none());\n         unsafe {\n-            let cb_ptr: &*mut BasicPausable = cast::transmute(&callback);\n+            let cb_ptr: &*mut BasicPausable = mem::transmute(&callback);\n             self.idle = Some(*cb_ptr);\n         }\n         callback as Box<PausableIdleCallback:Send>"}, {"sha": "0a13ffa0b5e314b0fb0061d17753c32ce8c09f9d", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,7 +10,7 @@\n \n use stack::Stack;\n use std::uint;\n-use std::cast::{transmute, transmute_mut_unsafe};\n+use std::mem::transmute;\n use std::rt::stack;\n use std::raw;\n \n@@ -50,7 +50,7 @@ impl Context {\n                stack: &mut Stack) -> Context {\n \n         let sp: *uint = stack.end();\n-        let sp: *mut uint = unsafe { transmute_mut_unsafe(sp) };\n+        let sp: *mut uint = sp as *mut uint;\n         // Save and then immediately load the current context,\n         // which we will then modify to call the given function when restored\n         let mut regs = new_regs();"}, {"sha": "8c294fa2928f0a5e35f31e37e6becb8d3069b89b", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n+use std::mem;\n use std::rt::local::Local;\n use std::rt::rtio::{RemoteCallback, PausableIdleCallback, Callback, EventLoop};\n use std::rt::task::BlockedTask;\n@@ -633,7 +633,7 @@ impl Scheduler {\n         unsafe {\n \n             let sched: &mut Scheduler =\n-                cast::transmute_mut_lifetime(*next_task.sched.get_mut_ref());\n+                mem::transmute(&**next_task.sched.get_mut_ref());\n \n             let current_task: &mut GreenTask = match sched.cleanup_job {\n                 Some(CleanupJob { task: ref mut task, .. }) => &mut **task,\n@@ -647,7 +647,7 @@ impl Scheduler {\n             // works because due to transmute the borrow checker\n             // believes that we have no internal pointers to\n             // next_task.\n-            cast::forget(next_task);\n+            mem::forget(next_task);\n \n             // The raw context swap operation. The next action taken\n             // will be running the cleanup job from the context of the\n@@ -659,7 +659,7 @@ impl Scheduler {\n         // run the cleanup job, as expected by the previously called\n         // swap_contexts function.\n         let mut current_task: Box<GreenTask> = unsafe {\n-            cast::transmute(current_task_dupe)\n+            mem::transmute(current_task_dupe)\n         };\n         current_task.sched.get_mut_ref().run_cleanup_job();\n \n@@ -677,15 +677,17 @@ impl Scheduler {\n     // references to keep even when we don't own the tasks. It looks\n     // kinda safe because we are doing transmutes before passing in\n     // the arguments.\n-    pub fn get_contexts<'a>(current_task: &mut GreenTask, next_task: &mut GreenTask) ->\n-        (&'a mut Context, &'a mut Context) {\n+    pub fn get_contexts<'a>(current_task: &mut GreenTask,\n+                            next_task: &mut GreenTask)\n+        -> (&'a mut Context, &'a mut Context)\n+    {\n         let current_task_context =\n             &mut current_task.coroutine.get_mut_ref().saved_context;\n         let next_task_context =\n                 &mut next_task.coroutine.get_mut_ref().saved_context;\n         unsafe {\n-            (cast::transmute_mut_lifetime(current_task_context),\n-             cast::transmute_mut_lifetime(next_task_context))\n+            (mem::transmute(current_task_context),\n+             mem::transmute(next_task_context))\n         }\n     }\n \n@@ -961,10 +963,10 @@ trait ClosureConverter {\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n     fn from_fn(f: |&mut Scheduler, Box<GreenTask>|) -> UnsafeTaskReceiver {\n-        unsafe { cast::transmute(f) }\n+        unsafe { mem::transmute(f) }\n     }\n     fn to_fn(self) -> |&mut Scheduler, Box<GreenTask>| {\n-        unsafe { cast::transmute(self) }\n+        unsafe { mem::transmute(self) }\n     }\n }\n "}, {"sha": "49aef15f93b61bd24d6a091fffc2d09106c3b38e", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -12,7 +12,7 @@\n //! scheduler pool and then interacting with it.\n \n use std::any::Any;\n-use std::cast;\n+use std::mem;\n use std::rt::Runtime;\n use std::rt::local::Local;\n use std::rt::rtio;\n@@ -48,18 +48,18 @@ impl Runtime for SimpleTask {\n                         guard.wait();\n                     }\n                 }\n-                Err(task) => { cast::forget(task.wake()); }\n+                Err(task) => { mem::forget(task.wake()); }\n             }\n             drop(guard);\n-            cur_task = cast::transmute(cur_dupe);\n+            cur_task = mem::transmute(cur_dupe);\n         }\n         Local::put(cur_task);\n     }\n     fn reawaken(mut ~self, mut to_wake: Box<Task>) {\n         let me = &mut *self as *mut SimpleTask;\n         to_wake.put_runtime(self);\n         unsafe {\n-            cast::forget(to_wake);\n+            mem::forget(to_wake);\n             let guard = (*me).lock.lock();\n             (*me).awoken = true;\n             guard.signal();"}, {"sha": "f50f65af6f9ebe83a8b9fcbb1ddd3a1341df72dd", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -19,7 +19,7 @@\n //! values.\n \n use std::any::Any;\n-use std::cast;\n+use std::mem;\n use std::raw;\n use std::rt::Runtime;\n use std::rt::env;\n@@ -93,11 +93,11 @@ pub enum Home {\n extern fn bootstrap_green_task(task: uint, code: *(), env: *()) -> ! {\n     // Acquire ownership of the `proc()`\n     let start: proc() = unsafe {\n-        cast::transmute(raw::Procedure { code: code, env: env })\n+        mem::transmute(raw::Procedure { code: code, env: env })\n     };\n \n     // Acquire ownership of the `Box<GreenTask>`\n-    let mut task: Box<GreenTask> = unsafe { cast::transmute(task) };\n+    let mut task: Box<GreenTask> = unsafe { mem::transmute(task) };\n \n     // First code after swap to this new context. Run our cleanup job\n     task.pool_id = {\n@@ -271,7 +271,7 @@ impl GreenTask {\n     }\n \n     pub unsafe fn from_uint(val: uint) -> Box<GreenTask> {\n-        cast::transmute(val)\n+        mem::transmute(val)\n     }\n \n     // Runtime glue functions and helpers"}, {"sha": "dbff4150d7274bd30d2c53a69628eda163c84111", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -118,10 +118,10 @@ if logging is disabled, none of the components of the log will be executed.\n \n extern crate sync;\n \n-use std::cast;\n use std::fmt;\n use std::io::LineBufferedWriter;\n use std::io;\n+use std::mem;\n use std::os;\n use std::rt;\n use std::slice;\n@@ -343,13 +343,13 @@ fn init() {\n         LOG_LEVEL = max_level;\n \n         assert!(DIRECTIVES.is_null());\n-        DIRECTIVES = cast::transmute(box directives);\n+        DIRECTIVES = mem::transmute(box directives);\n \n         // Schedule the cleanup for this global for when the runtime exits.\n         rt::at_exit(proc() {\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n-                cast::transmute(DIRECTIVES);\n+                mem::transmute(DIRECTIVES);\n             DIRECTIVES = 0 as *Vec<directive::LogDirective>;\n         });\n     }"}, {"sha": "8ebae70f73c04c0e08120e2e620dc8fca7c5f300", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use ai = std::io::net::addrinfo;\n+use libc::{c_char, c_int};\n+use libc;\n use std::c_str::CString;\n-use std::cast;\n use std::io::IoError;\n-use libc;\n-use libc::{c_char, c_int};\n+use std::mem;\n use std::ptr::{null, mut_null};\n \n use super::net::sockaddr_to_addr;\n@@ -61,7 +61,7 @@ impl GetAddrInfoRequest {\n         let mut rp = res;\n         while rp.is_not_null() {\n             unsafe {\n-                let addr = match sockaddr_to_addr(cast::transmute((*rp).ai_addr),\n+                let addr = match sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n                                                   (*rp).ai_addrlen as uint) {\n                     Ok(a) => a,\n                     Err(e) => return Err(e)"}, {"sha": "fc08a7f128fec54bf440ae7d3f195ce13cf97479", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,7 +11,6 @@\n //! Blocking win32-based file I/O\n \n use std::c_str::CString;\n-use std::cast;\n use std::io::IoError;\n use std::io;\n use libc::{c_int, c_void};\n@@ -175,7 +174,7 @@ impl rtio::RtioFileStream for FileDesc {\n         // This transmute is fine because our seek implementation doesn't\n         // actually use the mutable self at all.\n         // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n-        unsafe { cast::transmute::<&_, &mut FileDesc>(self).seek(0, io::SeekCur) }\n+        unsafe { mem::transmute::<&_, &mut FileDesc>(self).seek(0, io::SeekCur) }\n     }\n \n     fn fsync(&mut self) -> Result<(), IoError> {"}, {"sha": "40b66cc526f2aa8968d3b086418fe3aac370cda7", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use libc;\n-use std::cast;\n use std::io::net::ip;\n use std::io;\n use std::mem;\n@@ -72,14 +71,14 @@ fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n         let storage: libc::sockaddr_storage = mem::init();\n         let len = match ip_to_inaddr(addr.ip) {\n             InAddr(inaddr) => {\n-                let storage: *mut libc::sockaddr_in = cast::transmute(&storage);\n+                let storage: *mut libc::sockaddr_in = mem::transmute(&storage);\n                 (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n                 (*storage).sin_port = htons(addr.port);\n                 (*storage).sin_addr = inaddr;\n                 mem::size_of::<libc::sockaddr_in>()\n             }\n             In6Addr(inaddr) => {\n-                let storage: *mut libc::sockaddr_in6 = cast::transmute(&storage);\n+                let storage: *mut libc::sockaddr_in6 = mem::transmute(&storage);\n                 (*storage).sin6_family = libc::AF_INET6 as libc::sa_family_t;\n                 (*storage).sin6_port = htons(addr.port);\n                 (*storage).sin6_addr = inaddr;\n@@ -173,7 +172,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n         libc::AF_INET => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n             let storage: &libc::sockaddr_in = unsafe {\n-                cast::transmute(storage)\n+                mem::transmute(storage)\n             };\n             let addr = storage.sin_addr.s_addr as u32;\n             let a = (addr >>  0) as u8;\n@@ -188,7 +187,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n         libc::AF_INET6 => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in6>());\n             let storage: &libc::sockaddr_in6 = unsafe {\n-                cast::transmute(storage)\n+                mem::transmute(storage)\n             };\n             let a = ntohs(storage.sin6_addr.s6_addr[0]);\n             let b = ntohs(storage.sin6_addr.s6_addr[1]);"}, {"sha": "d66075f44190daef3a93c0b7d720e4fbacf251c4", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,7 +10,6 @@\n \n use libc;\n use std::c_str::CString;\n-use std::cast;\n use std::intrinsics;\n use std::io;\n use std::mem;\n@@ -36,7 +35,7 @@ fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint\n     assert!(mem::size_of::<libc::sockaddr_storage>() >=\n             mem::size_of::<libc::sockaddr_un>());\n     let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n-    let s: &mut libc::sockaddr_un = unsafe { cast::transmute(&mut storage) };\n+    let s: &mut libc::sockaddr_un = unsafe { mem::transmute(&mut storage) };\n \n     let len = addr.len();\n     if len > s.sun_path.len() - 1 {"}, {"sha": "81c76bba7a0eb36522034f21c85a5743473fbb62", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -19,7 +19,7 @@ use p = std::io::process;\n use super::IoResult;\n use super::file;\n \n-#[cfg(windows)] use std::cast;\n+#[cfg(windows)] use std::mem;\n #[cfg(windows)] use std::strbuf::StrBuf;\n #[cfg(not(windows))] use super::retry;\n \n@@ -326,7 +326,7 @@ fn spawn_process_os(config: p::ProcessConfig,\n         with_envp(env, |envp| {\n             with_dirp(dir, |dirp| {\n                 cmd.with_c_str(|cmdp| {\n-                    let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n+                    let created = CreateProcessA(ptr::null(), mem::transmute(cmdp),\n                                                  ptr::mut_null(), ptr::mut_null(), TRUE,\n                                                  flags, envp, dirp, &mut si,\n                                                  &mut pi);\n@@ -714,7 +714,7 @@ fn with_dirp<T>(d: Option<&Path>, cb: |*libc::c_char| -> T) -> T {\n #[cfg(windows)]\n fn free_handle(handle: *()) {\n     assert!(unsafe {\n-        libc::CloseHandle(cast::transmute(handle)) != 0\n+        libc::CloseHandle(mem::transmute(handle)) != 0\n     })\n }\n "}, {"sha": "95b2620f3c7987e1989bc03c0921bbbe21e6d870", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -20,7 +20,7 @@\n //! can be created in the future and there must be no active timers at that\n //! time.\n \n-use std::cast;\n+use std::mem;\n use std::rt::bookkeeping;\n use std::rt;\n use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n@@ -48,7 +48,7 @@ pub fn boot(helper: fn(imp::signal, Receiver<Req>)) {\n             let (tx, rx) = channel();\n             // promote this to a shared channel\n             drop(tx.clone());\n-            HELPER_CHAN = cast::transmute(box tx);\n+            HELPER_CHAN = mem::transmute(box tx);\n             let (receive, send) = imp::new();\n             HELPER_SIGNAL = send;\n \n@@ -86,7 +86,7 @@ fn shutdown() {\n     // Clean up after ther helper thread\n     unsafe {\n         imp::close(HELPER_SIGNAL);\n-        let _chan: Box<Sender<Req>> = cast::transmute(HELPER_CHAN);\n+        let _chan: Box<Sender<Req>> = mem::transmute(HELPER_CHAN);\n         HELPER_CHAN = 0 as *mut Sender<Req>;\n         HELPER_SIGNAL = 0 as imp::signal;\n     }"}, {"sha": "0df45f7d5a0a92cbb7ab011e9ed23ef8b1f6d0cc", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -73,9 +73,9 @@ static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n #[lang = \"start\"]\n #[cfg(not(test))]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n-    use std::cast;\n+    use std::mem;\n     start(argc, argv, proc() {\n-        let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n+        let main: extern \"Rust\" fn() = unsafe { mem::transmute(main) };\n         main();\n     })\n }"}, {"sha": "4183dec19d02dfe1e074f13e8e50a6cded147ce3", "filename": "src/libnative/task.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -15,7 +15,7 @@\n //! in order to spawn new tasks and deschedule the current task.\n \n use std::any::Any;\n-use std::cast;\n+use std::mem;\n use std::rt::bookkeeping;\n use std::rt::env;\n use std::rt::local::Local;\n@@ -169,7 +169,7 @@ impl rt::Runtime for Ops {\n     // for both tasks because these operations are all done inside of a mutex.\n     //\n     // You'll also find that if blocking fails (the `f` function hands the\n-    // BlockedTask back to us), we will `cast::forget` the handles. The\n+    // BlockedTask back to us), we will `mem::forget` the handles. The\n     // reasoning for this is the same logic as above in that the task silently\n     // transfers ownership via the `uint`, not through normal compiler\n     // semantics.\n@@ -198,7 +198,7 @@ impl rt::Runtime for Ops {\n                             guard.wait();\n                         }\n                     }\n-                    Err(task) => { cast::forget(task.wake()); }\n+                    Err(task) => { mem::forget(task.wake()); }\n                 }\n             } else {\n                 let iter = task.make_selectable(times);\n@@ -217,7 +217,7 @@ impl rt::Runtime for Ops {\n                     Some(task) => {\n                         match task.wake() {\n                             Some(task) => {\n-                                cast::forget(task);\n+                                mem::forget(task);\n                                 (*me).awoken = true;\n                             }\n                             None => {}\n@@ -229,7 +229,7 @@ impl rt::Runtime for Ops {\n                 }\n             }\n             // re-acquire ownership of the task\n-            cur_task = cast::transmute(cur_task_dupe);\n+            cur_task = mem::transmute(cur_task_dupe);\n         }\n \n         // put the task back in TLS, and everything is as it once was.\n@@ -242,7 +242,7 @@ impl rt::Runtime for Ops {\n         unsafe {\n             let me = &mut *self as *mut Ops;\n             to_wake.put_runtime(self);\n-            cast::forget(to_wake);\n+            mem::forget(to_wake);\n             let guard = (*me).lock.lock();\n             (*me).awoken = true;\n             guard.signal();"}, {"sha": "03c87eb931d604428fead709072ffa1ba6d572b9", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -18,7 +18,7 @@ use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n ///\n /// See `Exp` for the general exponential distribution.Note that this\n  // has to be unwrapped before use as an `f64` (using either\n-/// `*` or `cast::transmute` is safe).\n+/// `*` or `mem::transmute` is safe).\n ///\n /// Implemented via the ZIGNOR variant[1] of the Ziggurat method. The\n /// exact description in the paper was adjusted to use tables for the"}, {"sha": "dea73945b4384058a5e23c4a0bdb91f147942dda", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -19,7 +19,7 @@ use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n ///\n /// See `Normal` for the general normal distribution. That this has to\n /// be unwrapped before use as an `f64` (using either `*` or\n-/// `cast::transmute` is safe).\n+/// `mem::transmute` is safe).\n ///\n /// Implemented via the ZIGNOR variant[1] of the Ziggurat method.\n ///"}, {"sha": "006c4d89e2f8523bbe8c2e937a7676739ec1f946", "filename": "src/librand/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -76,9 +76,9 @@ println!(\"{:?}\", tuple_ptr)\n #[cfg(test)]\n #[phase(syntax, link)] extern crate log;\n \n-use std::cast;\n use std::io::IoResult;\n use std::kinds::marker;\n+use std::mem;\n use std::strbuf::StrBuf;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n@@ -454,11 +454,11 @@ impl<'a> SeedableRng<&'a [uint]> for StdRng {\n     fn reseed(&mut self, seed: &'a [uint]) {\n         // the internal RNG can just be seeded from the above\n         // randomness.\n-        self.rng.reseed(unsafe {cast::transmute(seed)})\n+        self.rng.reseed(unsafe {mem::transmute(seed)})\n     }\n \n     fn from_seed(seed: &'a [uint]) -> StdRng {\n-        StdRng { rng: SeedableRng::from_seed(unsafe {cast::transmute(seed)}) }\n+        StdRng { rng: SeedableRng::from_seed(unsafe {mem::transmute(seed)}) }\n     }\n }\n \n@@ -547,7 +547,7 @@ impl XorShiftRng {\n                 break;\n             }\n         }\n-        let s: [u32, ..4] = unsafe { cast::transmute(s) };\n+        let s: [u32, ..4] = unsafe { mem::transmute(s) };\n         Ok(SeedableRng::from_seed(s))\n     }\n }"}, {"sha": "f41d7a628631cd88b66e4ca10633b2f2a37d02b2", "filename": "src/librand/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fos.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -61,8 +61,8 @@ mod imp {\n     extern crate libc;\n \n     use Rng;\n-    use std::cast;\n     use std::io::{IoResult, IoError};\n+    use std::mem;\n     use std::os;\n     use std::rt::stack;\n     use self::libc::{c_ulong, DWORD, BYTE, LPCSTR, BOOL};\n@@ -156,12 +156,12 @@ mod imp {\n         fn next_u32(&mut self) -> u32 {\n             let mut v = [0u8, .. 4];\n             self.fill_bytes(v);\n-            unsafe { cast::transmute(v) }\n+            unsafe { mem::transmute(v) }\n         }\n         fn next_u64(&mut self) -> u64 {\n             let mut v = [0u8, .. 8];\n             self.fill_bytes(v);\n-            unsafe { cast::transmute(v) }\n+            unsafe { mem::transmute(v) }\n         }\n         fn fill_bytes(&mut self, v: &mut [u8]) {\n             let ret = unsafe {"}, {"sha": "184146d9a29c809a443ed893d909d67accdf71be", "filename": "src/librand/reader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freader.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -72,14 +72,14 @@ impl<R: Reader> Rng for ReaderRng<R> {\n mod test {\n     use super::ReaderRng;\n     use std::io::MemReader;\n-    use std::cast;\n+    use std::mem;\n     use Rng;\n \n     #[test]\n     fn test_reader_rng_u64() {\n         // transmute from the target to avoid endianness concerns.\n         let v = box [1u64, 2u64, 3u64];\n-        let bytes: ~[u8] = unsafe {cast::transmute(v)};\n+        let bytes: ~[u8] = unsafe {mem::transmute(v)};\n         let mut rng = ReaderRng::new(MemReader::new(bytes.move_iter().collect()));\n \n         assert_eq!(rng.next_u64(), 1);\n@@ -90,7 +90,7 @@ mod test {\n     fn test_reader_rng_u32() {\n         // transmute from the target to avoid endianness concerns.\n         let v = box [1u32, 2u32, 3u32];\n-        let bytes: ~[u8] = unsafe {cast::transmute(v)};\n+        let bytes: ~[u8] = unsafe {mem::transmute(v)};\n         let mut rng = ReaderRng::new(MemReader::new(bytes.move_iter().collect()));\n \n         assert_eq!(rng.next_u32(), 1);"}, {"sha": "a0b38700ecf0a0825758496e7d84bc8d187fcdf6", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -15,14 +15,14 @@ use driver::session::Session;\n use metadata::filesearch;\n use lib::llvm::{ArchiveRef, llvm};\n \n-use std::cast;\n-use std::io;\n-use std::io::{fs, TempDir};\n use libc;\n-use std::os;\n use std::io::process::{ProcessConfig, Process, ProcessOutput};\n-use std::str;\n+use std::io::{fs, TempDir};\n+use std::io;\n+use std::mem;\n+use std::os;\n use std::raw;\n+use std::str;\n use syntax::abi;\n \n pub static METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n@@ -230,7 +230,7 @@ impl ArchiveRO {\n             if ptr.is_null() {\n                 None\n             } else {\n-                Some(cast::transmute(raw::Slice {\n+                Some(mem::transmute(raw::Slice {\n                     data: ptr,\n                     len: size as uint,\n                 }))"}, {"sha": "518dc4b05ca20b27a43002725a1648c4da7096f7", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(non_camel_case_types)]\n \n-use std::cast;\n+use std::mem;\n use syntax::crateid::CrateId;\n use back::svh::Svh;\n \n@@ -147,7 +147,7 @@ impl astencode_tag {\n     pub fn from_uint(value : uint) -> Option<astencode_tag> {\n         let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;\n         if !is_a_tag { None } else {\n-            Some(unsafe { cast::transmute(value) })\n+            Some(unsafe { mem::transmute(value) })\n         }\n     }\n }"}, {"sha": "70f740f7557e12235535bd4aa00c1c692718d3d3", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -27,7 +27,7 @@ use middle;\n use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::Encodable;\n-use std::cast;\n+use std::mem;\n use std::cell::RefCell;\n use std::hash;\n use std::hash::Hash;\n@@ -1247,7 +1247,7 @@ fn my_visit_item(i: &Item,\n                  index: &mut Vec<entry<i64>>) {\n     let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n     // See above\n-    let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n+    let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n     ecx.tcx.map.with_path(i.id, |path| {\n         encode_info_for_item(ecx, &mut ebml_w, i, index, path, i.vis);\n     });\n@@ -1258,7 +1258,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n                          ecx_ptr:*int,\n                          index: &mut Vec<entry<i64>>) {\n     // See above\n-    let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n+    let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n     debug!(\"writing foreign item {}::{}\",\n             ecx.tcx.map.path_to_str(ni.id),\n             token::get_ident(ni.ident));\n@@ -1320,7 +1320,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         Public);\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n-    let ecx_ptr: *int = unsafe { cast::transmute(ecx) };\n+    let ecx_ptr: *int = unsafe { mem::transmute(ecx) };\n     visit::walk_crate(&mut EncodeVisitor {\n         index: &mut index,\n         ecx_ptr: ecx_ptr,"}, {"sha": "c872df3deade9ba819f2e93169f5200579a11bfb", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -25,9 +25,9 @@ use syntax::attr::AttrMetaMethods;\n use util::fs;\n \n use std::c_str::ToCStr;\n-use std::cast;\n use std::cmp;\n use std::io;\n+use std::mem;\n use std::ptr;\n use std::slice;\n use std::str;\n@@ -469,7 +469,7 @@ impl ArchiveMetadata {\n             // Hence, we're guaranteed that the buffer will never be used after\n             // this object is dead, so this is a safe operation to transmute and\n             // store the data as a static buffer.\n-            unsafe { cast::transmute(data) }\n+            unsafe { mem::transmute(data) }\n         };\n         Some(ArchiveMetadata {\n             archive: ar,\n@@ -532,7 +532,7 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~st\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found = Err(format!(\"metadata not found: '{}'\", filename.display()));\n-                let cvbuf: *u8 = cast::transmute(cbuf);\n+                let cvbuf: *u8 = mem::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);"}, {"sha": "ae1a12901049d2bc9fb06db7e17fa86e1113b15c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -34,9 +34,9 @@ use syntax::parse::token;\n use syntax;\n \n use libc;\n-use std::cast;\n use std::io::Seek;\n use std::io::MemWriter;\n+use std::mem;\n use std::rc::Rc;\n use std::strbuf::StrBuf;\n \n@@ -913,7 +913,7 @@ impl<'a,'b> ast_util::IdVisitingOperation for\n         };\n         // See above\n         let ecx: &e::EncodeContext = unsafe {\n-            cast::transmute(self.ecx_ptr)\n+            mem::transmute(self.ecx_ptr)\n         };\n         encode_side_tables_for_id(ecx, &mut new_ebml_w, id)\n     }\n@@ -932,7 +932,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n     // tied to the CrateContext that lives throughout this entire section.\n     ast_util::visit_ids_for_inlined_item(ii, &SideTableEncodingIdVisitor {\n         ecx_ptr: unsafe {\n-            cast::transmute(ecx)\n+            mem::transmute(ecx)\n         },\n         new_ebml_w: &mut new_ebml_w,\n     });"}, {"sha": "0ca1a07e1a370c9ab9e848e6e49a9932afd39c6a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -109,7 +109,7 @@ use middle::pat_util;\n use middle::ty;\n use util::nodemap::NodeMap;\n \n-use std::cast::transmute;\n+use std::mem::transmute;\n use std::fmt;\n use std::io;\n use std::rc::Rc;"}, {"sha": "a0744037dc0081650abd545b2a1cbee3fabbad0d", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -19,7 +19,7 @@ use syntax::ast;\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n use std::c_str::ToCStr;\n-use std::cast;\n+use std::mem;\n \n use libc::{c_uint};\n \n@@ -140,19 +140,19 @@ impl Type {\n     }\n \n     pub fn func(args: &[Type], ret: &Type) -> Type {\n-        let vec : &[TypeRef] = unsafe { cast::transmute(args) };\n+        let vec : &[TypeRef] = unsafe { mem::transmute(args) };\n         ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n                                    args.len() as c_uint, False))\n     }\n \n     pub fn variadic_func(args: &[Type], ret: &Type) -> Type {\n-        let vec : &[TypeRef] = unsafe { cast::transmute(args) };\n+        let vec : &[TypeRef] = unsafe { mem::transmute(args) };\n         ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n                                    args.len() as c_uint, True))\n     }\n \n     pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n-        let els : &[TypeRef] = unsafe { cast::transmute(els) };\n+        let els : &[TypeRef] = unsafe { mem::transmute(els) };\n         ty!(llvm::LLVMStructTypeInContext(ccx.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n                                           packed as Bool))\n@@ -245,7 +245,7 @@ impl Type {\n \n     pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n         unsafe {\n-            let vec : &[TypeRef] = cast::transmute(els);\n+            let vec : &[TypeRef] = mem::transmute(els);\n             llvm::LLVMStructSetBody(self.to_ref(), vec.as_ptr(),\n                                     els.len() as c_uint, packed as Bool)\n         }\n@@ -281,7 +281,7 @@ impl Type {\n             }\n             let mut elts = Vec::from_elem(n_elts, 0 as TypeRef);\n             llvm::LLVMGetStructElementTypes(self.to_ref(), elts.get_mut(0));\n-            cast::transmute(elts)\n+            mem::transmute(elts)\n         }\n     }\n \n@@ -294,7 +294,7 @@ impl Type {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n             let args = Vec::from_elem(n_args, 0 as TypeRef);\n             llvm::LLVMGetParamTypes(self.to_ref(), args.as_ptr());\n-            cast::transmute(args)\n+            mem::transmute(args)\n         }\n     }\n "}, {"sha": "f37a4ab0aaa4aafb2da24cd9dceb0048ba8d8885", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -34,13 +34,13 @@ use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet, FnvHashMap};\n \n-use std::cast;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt::Show;\n use std::fmt;\n use std::hash::{Hash, sip};\n use std::iter::AdditiveIterator;\n+use std::mem;\n use std::ops;\n use std::rc::Rc;\n use collections::{HashMap, HashSet};\n@@ -394,7 +394,7 @@ impl fmt::Show for t {\n \n pub fn get(t: t) -> t_box {\n     unsafe {\n-        let t2: t_box = cast::transmute(t);\n+        let t2: t_box = mem::transmute(t);\n         t2\n     }\n }\n@@ -854,7 +854,7 @@ impl CLike for BuiltinBound {\n         *self as uint\n     }\n     fn from_uint(v: uint) -> BuiltinBound {\n-        unsafe { cast::transmute(v) }\n+        unsafe { mem::transmute(v) }\n     }\n }\n \n@@ -1158,7 +1158,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     let key = intern_key { sty: &st };\n \n     match cx.interner.borrow().find(&key) {\n-        Some(t) => unsafe { return cast::transmute(&t.sty); },\n+        Some(t) => unsafe { return mem::transmute(&t.sty); },\n         _ => ()\n     }\n \n@@ -1259,14 +1259,14 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     cx.next_id.set(cx.next_id.get() + 1);\n \n     unsafe {\n-        cast::transmute::<*sty, t>(sty_ptr)\n+        mem::transmute::<*sty, t>(sty_ptr)\n     }\n }\n \n #[inline]\n pub fn mk_prim_t(primitive: &'static t_box_) -> t {\n     unsafe {\n-        cast::transmute::<&'static t_box_, t>(primitive)\n+        mem::transmute::<&'static t_box_, t>(primitive)\n     }\n }\n "}, {"sha": "81ddc9d32eb2c6b7543412704e6a58f24b7fbf91", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -14,7 +14,7 @@\n /// It is assumed that all invocations of this struct happen on the same thread\n /// (the uv event loop).\n \n-use std::cast;\n+use std::mem;\n use std::rt::local::Local;\n use std::rt::task::{BlockedTask, Task};\n use std::sync::arc::UnsafeArc;\n@@ -110,7 +110,7 @@ impl<'a> Drop for Guard<'a> {\n         // on the same I/O event loop, so this unsafety should be ok.\n         assert!(self.missile.is_some());\n         let inner: &mut Inner = unsafe {\n-            cast::transmute(self.access.inner.get())\n+            mem::transmute(self.access.inner.get())\n         };\n \n         match inner.queue.shift() {"}, {"sha": "1e18f2ea9ec2540153d67f55db017b750a844738", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use ai = std::io::net::addrinfo;\n-use std::cast;\n-use libc;\n use libc::c_int;\n+use libc;\n+use std::mem;\n use std::ptr::null;\n use std::rt::task::BlockedTask;\n \n@@ -140,7 +140,7 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<ai::Info> {\n \n         let mut addrs = Vec::new();\n         loop {\n-            let rustaddr = net::sockaddr_to_addr(cast::transmute((*addr).ai_addr),\n+            let rustaddr = net::sockaddr_to_addr(mem::transmute((*addr).ai_addr),\n                                                  (*addr).ai_addrlen as uint);\n \n             let mut flags = 0;"}, {"sha": "7a16baaa9f2a6bfc8e3713183d6495802e683f47", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n+use std::mem;\n use std::rt::rtio::{Callback, RemoteCallback};\n use std::unstable::sync::Exclusive;\n \n@@ -39,7 +39,7 @@ impl AsyncWatcher {\n         let flag = Exclusive::new(false);\n         let payload = box Payload { callback: cb, exit_flag: flag.clone() };\n         unsafe {\n-            let payload: *u8 = cast::transmute(payload);\n+            let payload: *u8 = mem::transmute(payload);\n             uvll::set_data_for_uv_handle(handle, payload);\n         }\n         return AsyncWatcher { handle: handle, exit_flag: flag, };\n@@ -55,7 +55,7 @@ impl UvHandle<uvll::uv_async_t> for AsyncWatcher {\n \n extern fn async_cb(handle: *uvll::uv_async_t) {\n     let payload: &mut Payload = unsafe {\n-        cast::transmute(uvll::get_data_for_uv_handle(handle))\n+        mem::transmute(uvll::get_data_for_uv_handle(handle))\n     };\n \n     // The synchronization logic here is subtle. To review,\n@@ -94,7 +94,7 @@ extern fn async_cb(handle: *uvll::uv_async_t) {\n extern fn close_cb(handle: *uvll::uv_handle_t) {\n     // drop the payload\n     let _payload: Box<Payload> = unsafe {\n-        cast::transmute(uvll::get_data_for_uv_handle(handle))\n+        mem::transmute(uvll::get_data_for_uv_handle(handle))\n     };\n     // and then free the handle\n     unsafe { uvll::free_handle(handle) }"}, {"sha": "cd56e76aff667d1d224e16742d3e4f7693c60367", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,16 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::c_str::CString;\n-use std::c_str;\n-use std::cast::transmute;\n-use std::cast;\n use libc::{c_int, c_char, c_void, ssize_t};\n use libc;\n-use std::rt::task::BlockedTask;\n+use std::c_str::CString;\n+use std::c_str;\n use std::io::{FileStat, IoError};\n use std::io;\n+use std::mem;\n use std::rt::rtio;\n+use std::rt::task::BlockedTask;\n \n use homing::{HomingIO, HomeHandle};\n use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after, wakeup};\n@@ -341,7 +340,7 @@ fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n \n     extern fn fs_cb(req: *uvll::uv_fs_t) {\n         let slot: &mut Option<BlockedTask> = unsafe {\n-            cast::transmute(uvll::get_data_for_req(req))\n+            mem::transmute(uvll::get_data_for_req(req))\n         };\n         wakeup(slot);\n     }\n@@ -448,7 +447,7 @@ impl rtio::RtioFileStream for FileWatcher {\n         use libc::SEEK_CUR;\n         // this is temporary\n         // FIXME #13933: Remove/justify all `&T` to `&mut T` transmutes\n-        let self_ = unsafe { cast::transmute::<&_, &mut FileWatcher>(self) };\n+        let self_ = unsafe { mem::transmute::<&_, &mut FileWatcher>(self) };\n         self_.seek_common(0, SEEK_CUR)\n     }\n     fn fsync(&mut self) -> Result<(), IoError> {"}, {"sha": "b9025397b8d22ea54c2bbea6264c48b1be16217f", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -33,7 +33,7 @@\n \n #![allow(dead_code)]\n \n-use std::cast;\n+use std::mem;\n use std::rt::local::Local;\n use std::rt::rtio::LocalIo;\n use std::rt::task::{Task, BlockedTask};\n@@ -77,7 +77,7 @@ pub fn local_id() -> uint {\n     };\n     let io = io.get();\n     unsafe {\n-        let (_vtable, ptr): (uint, uint) = cast::transmute(io);\n+        let (_vtable, ptr): (uint, uint) = mem::transmute(io);\n         return ptr;\n     }\n }"}, {"sha": "f5cde39bc8343405cde618df3f69e4a8824fbe0b", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n use libc::c_void;\n+use std::mem;\n \n use uvll;\n use super::{Loop, UvHandle};\n@@ -41,15 +41,15 @@ impl IdleWatcher {\n         let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         unsafe {\n             assert_eq!(uvll::uv_idle_init(loop_.handle, handle), 0);\n-            let data: *c_void = cast::transmute(box f);\n+            let data: *c_void = mem::transmute(box f);\n             uvll::set_data_for_uv_handle(handle, data);\n             assert_eq!(uvll::uv_idle_start(handle, onetime_cb), 0)\n         }\n \n         extern fn onetime_cb(handle: *uvll::uv_idle_t) {\n             unsafe {\n                 let data = uvll::get_data_for_uv_handle(handle);\n-                let f: Box<proc()> = cast::transmute(data);\n+                let f: Box<proc()> = mem::transmute(data);\n                 (*f)();\n                 assert_eq!(uvll::uv_idle_stop(handle), 0);\n                 uvll::uv_close(handle, close_cb);\n@@ -95,7 +95,7 @@ impl Drop for IdleWatcher {\n \n #[cfg(test)]\n mod test {\n-    use std::cast;\n+    use std::mem;\n     use std::cell::RefCell;\n     use std::rc::Rc;\n     use std::rt::rtio::{Callback, PausableIdleCallback};\n@@ -130,7 +130,7 @@ mod test {\n         let rc = Rc::new(RefCell::new((None, 0)));\n         let cb = box MyCallback(rc.clone(), v);\n         let cb = cb as Box<Callback:>;\n-        let cb = unsafe { cast::transmute(cb) };\n+        let cb = unsafe { mem::transmute(cb) };\n         (IdleWatcher::new(&mut local_loop().loop_, cb), rc)\n     }\n "}, {"sha": "6568254237620052c2d3add23fa0431aedbac44d", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -48,10 +48,10 @@ via `close` and `delete` methods.\n extern crate libc;\n \n use libc::{c_int, c_void};\n-use std::cast;\n use std::fmt;\n use std::io::IoError;\n use std::io;\n+use std::mem;\n use std::ptr::null;\n use std::ptr;\n use std::rt::local::Local;\n@@ -147,12 +147,12 @@ pub trait UvHandle<T> {\n     }\n \n     unsafe fn from_uv_handle<'a>(h: &'a *T) -> &'a mut Self {\n-        cast::transmute(uvll::get_data_for_uv_handle(*h))\n+        mem::transmute(uvll::get_data_for_uv_handle(*h))\n     }\n \n     fn install(~self) -> Box<Self> {\n         unsafe {\n-            let myptr = cast::transmute::<&Box<Self>, &*u8>(&self);\n+            let myptr = mem::transmute::<&Box<Self>, &*u8>(&self);\n             uvll::set_data_for_uv_handle(self.uv_handle(), *myptr);\n         }\n         self\n@@ -188,7 +188,7 @@ pub trait UvHandle<T> {\n                 let data = uvll::get_data_for_uv_handle(handle);\n                 uvll::free_handle(handle);\n                 if data == ptr::null() { return }\n-                let slot: &mut Option<BlockedTask> = cast::transmute(data);\n+                let slot: &mut Option<BlockedTask> = mem::transmute(data);\n                 wakeup(slot);\n             }\n         }\n@@ -284,7 +284,7 @@ impl Request {\n     pub unsafe fn get_data<T>(&self) -> &'static mut T {\n         let data = uvll::get_data_for_req(self.handle);\n         assert!(data != null());\n-        cast::transmute(data)\n+        mem::transmute(data)\n     }\n \n     // This function should be used when the request handle has been given to an\n@@ -459,19 +459,19 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n #[cfg(test)]\n fn local_loop() -> &'static mut uvio::UvIoFactory {\n     unsafe {\n-        cast::transmute({\n+        mem::transmute({\n             let mut task = Local::borrow(None::<Task>);\n             let mut io = task.local_io().unwrap();\n             let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n-                cast::transmute(io.get());\n+                mem::transmute(io.get());\n             uvio\n         })\n     }\n }\n \n #[cfg(test)]\n mod test {\n-    use std::cast::transmute;\n+    use std::mem::transmute;\n     use std::unstable::run_in_bare_thread;\n \n     use super::{slice_to_uv_buf, Loop};"}, {"sha": "798c9ac3cab169140936377eac56d78b037bed01", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,7 +10,6 @@\n \n use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use libc;\n-use std::cast;\n use std::io;\n use std::io::IoError;\n use std::io::net::ip;\n@@ -42,7 +41,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n         libc::AF_INET => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n             let storage: &libc::sockaddr_in = unsafe {\n-                cast::transmute(storage)\n+                mem::transmute(storage)\n             };\n             let addr = storage.sin_addr.s_addr as u32;\n             let a = (addr >>  0) as u8;\n@@ -57,7 +56,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n         libc::AF_INET6 => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in6>());\n             let storage: &libc::sockaddr_in6 = unsafe {\n-                cast::transmute(storage)\n+                mem::transmute(storage)\n             };\n             let a = ntohs(storage.sin6_addr.s6_addr[0]);\n             let b = ntohs(storage.sin6_addr.s6_addr[1]);\n@@ -84,7 +83,7 @@ fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n         let len = match addr.ip {\n             ip::Ipv4Addr(a, b, c, d) => {\n                 let storage: &mut libc::sockaddr_in =\n-                    cast::transmute(&mut storage);\n+                    mem::transmute(&mut storage);\n                 (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n                 (*storage).sin_port = htons(addr.port);\n                 (*storage).sin_addr = libc::in_addr {\n@@ -97,7 +96,7 @@ fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n             }\n             ip::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n                 let storage: &mut libc::sockaddr_in6 =\n-                    cast::transmute(&mut storage);\n+                    mem::transmute(&mut storage);\n                 storage.sin6_family = libc::AF_INET6 as libc::sa_family_t;\n                 storage.sin6_port = htons(addr.port);\n                 storage.sin6_addr = libc::in6_addr {\n@@ -316,7 +315,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n                                      &self.stream as *_ as uint);\n \n         fn cancel_read(stream: uint) -> Option<BlockedTask> {\n-            let stream: &mut StreamWatcher = unsafe { cast::transmute(stream) };\n+            let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n             stream.cancel_read(uvll::ECANCELED as ssize_t)\n         }\n     }\n@@ -328,7 +327,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n                                       &self.stream as *_ as uint);\n \n         fn cancel_write(stream: uint) -> Option<BlockedTask> {\n-            let stream: &mut StreamWatcher = unsafe { cast::transmute(stream) };\n+            let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n             stream.cancel_write()\n         }\n     }\n@@ -602,7 +601,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 None\n             } else {\n                 let len = mem::size_of::<libc::sockaddr_storage>();\n-                Some(sockaddr_to_addr(unsafe { cast::transmute(addr) }, len))\n+                Some(sockaddr_to_addr(unsafe { mem::transmute(addr) }, len))\n             };\n             cx.result = Some((nread, addr));\n             wakeup(&mut cx.task);\n@@ -652,7 +651,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 };\n                 unsafe {\n                     req.set_data(&*new_cx);\n-                    cast::forget(new_cx);\n+                    mem::forget(new_cx);\n                 }\n                 Err(uv_error_to_io_error(UvError(cx.result)))\n             }\n@@ -670,7 +669,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 let udp: &mut UdpWatcher = unsafe { &mut *cx.udp };\n                 wakeup(&mut udp.blocked_sender);\n             } else {\n-                let _cx: Box<UdpSendCtx> = unsafe { cast::transmute(cx) };\n+                let _cx: Box<UdpSendCtx> = unsafe { mem::transmute(cx) };\n             }\n         }\n     }\n@@ -789,7 +788,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                                       self as *mut _ as uint);\n \n         fn cancel_write(stream: uint) -> Option<BlockedTask> {\n-            let stream: &mut UdpWatcher = unsafe { cast::transmute(stream) };\n+            let stream: &mut UdpWatcher = unsafe { mem::transmute(stream) };\n             stream.blocked_sender.take()\n         }\n     }"}, {"sha": "ba39f8a7f5f32fbbf5d4f10b7832169e05024631", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,9 +10,9 @@\n \n use libc;\n use std::c_str::CString;\n-use std::cast;\n use std::io::IoError;\n use std::io;\n+use std::mem;\n use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n use std::rt::task::BlockedTask;\n \n@@ -185,7 +185,7 @@ impl RtioPipe for PipeWatcher {\n                                      &self.stream as *_ as uint);\n \n         fn cancel_read(stream: uint) -> Option<BlockedTask> {\n-            let stream: &mut StreamWatcher = unsafe { cast::transmute(stream) };\n+            let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n             stream.cancel_read(uvll::ECANCELED as libc::ssize_t)\n         }\n     }\n@@ -197,7 +197,7 @@ impl RtioPipe for PipeWatcher {\n                                       &self.stream as *_ as uint);\n \n         fn cancel_write(stream: uint) -> Option<BlockedTask> {\n-            let stream: &mut StreamWatcher = unsafe { cast::transmute(stream) };\n+            let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n             stream.cancel_write()\n         }\n     }"}, {"sha": "57b5e7105b20e3afff5acd0f00ef6736e5b1f8dd", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -21,10 +21,10 @@\n #![allow(dead_code)]\n \n use libc::c_void;\n-use std::cast;\n+use std::mem;\n use std::rt::task::BlockedTask;\n-use std::unstable::mutex::NativeMutex;\n use std::sync::arc::UnsafeArc;\n+use std::unstable::mutex::NativeMutex;\n use mpsc = std::sync::mpsc_queue;\n \n use async::AsyncWatcher;\n@@ -57,9 +57,9 @@ pub struct Queue {\n \n extern fn async_cb(handle: *uvll::uv_async_t) {\n     let pool: &mut QueuePool = unsafe {\n-        cast::transmute(uvll::get_data_for_uv_handle(handle))\n+        mem::transmute(uvll::get_data_for_uv_handle(handle))\n     };\n-    let state: &mut State = unsafe { cast::transmute(pool.queue.get()) };\n+    let state: &mut State = unsafe { mem::transmute(pool.queue.get()) };\n \n     // Remember that there is no guarantee about how many times an async\n     // callback is called with relation to the number of sends, so process the\n@@ -183,7 +183,7 @@ impl Drop for Queue {\n impl Drop for State {\n     fn drop(&mut self) {\n         unsafe {\n-            uvll::uv_close(self.handle, cast::transmute(0));\n+            uvll::uv_close(self.handle, mem::transmute(0));\n             // Note that this does *not* free the handle, that is the\n             // responsibility of the caller because the uv loop must be closed\n             // before we deallocate this uv handle."}, {"sha": "8ce985eb76d658e778a19f90e33ff40d67cd1166", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n use libc::{c_int, size_t, ssize_t};\n+use std::mem;\n use std::ptr;\n use std::rt::task::BlockedTask;\n \n@@ -212,7 +212,7 @@ impl StreamWatcher {\n                 };\n                 unsafe {\n                     req.set_data(&*new_wcx);\n-                    cast::forget(new_wcx);\n+                    mem::forget(new_wcx);\n                 }\n                 Err(UvError(wcx.result))\n             }\n@@ -232,7 +232,7 @@ extern fn alloc_cb(stream: *uvll::uv_stream_t, _hint: size_t, buf: *mut Buf) {\n     uvdebug!(\"alloc_cb\");\n     unsafe {\n         let rcx: &mut ReadContext =\n-            cast::transmute(uvll::get_data_for_uv_handle(stream));\n+            mem::transmute(uvll::get_data_for_uv_handle(stream));\n         *buf = rcx.buf.take().expect(\"stream alloc_cb called more than once\");\n     }\n }\n@@ -243,7 +243,7 @@ extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: *Buf) {\n     uvdebug!(\"read_cb {}\", nread);\n     assert!(nread != uvll::ECANCELED as ssize_t);\n     let rcx: &mut ReadContext = unsafe {\n-        cast::transmute(uvll::get_data_for_uv_handle(handle))\n+        mem::transmute(uvll::get_data_for_uv_handle(handle))\n     };\n     // Stop reading so that no read callbacks are\n     // triggered before the user calls `read` again.\n@@ -272,6 +272,6 @@ extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n         let stream: &mut StreamWatcher = unsafe { &mut *wcx.stream };\n         wakeup(&mut stream.blocked_writer);\n     } else {\n-        let _wcx: Box<WriteContext> = unsafe { cast::transmute(wcx) };\n+        let _wcx: Box<WriteContext> = unsafe { mem::transmute(wcx) };\n     }\n }"}, {"sha": "99b568b12605c7203057c9a69f9ebb00c29e64f8", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use libc::c_int;\n-use std::cast;\n use std::io::IoResult;\n use std::mem;\n use std::rt::task::BlockedTask;\n@@ -127,7 +126,7 @@ impl AccessTimeout {\n             };\n             unsafe {\n                 timer.set_data(&*cx);\n-                cast::forget(cx);\n+                mem::forget(cx);\n             }\n             self.timer = Some(timer);\n         }\n@@ -199,7 +198,7 @@ impl Drop for AccessTimeout {\n         match self.timer {\n             Some(ref timer) => unsafe {\n                 let data = uvll::get_data_for_uv_handle(timer.handle);\n-                let _data: Box<TimerContext> = cast::transmute(data);\n+                let _data: Box<TimerContext> = mem::transmute(data);\n             },\n             None => {}\n         }"}, {"sha": "c42b17cc3256e92787060891e4a1792f02c51146", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,14 +11,14 @@\n //! The implementation of `rtio` for libuv\n \n use std::c_str::CString;\n-use std::cast;\n use std::io::IoError;\n use std::io::net::ip::SocketAddr;\n use std::io::process::ProcessConfig;\n use std::io::signal::Signum;\n use std::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n               ReadWrite, FileStat};\n use std::io;\n+use std::mem;\n use libc::c_int;\n use libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY, S_IRUSR,\n                 S_IWUSR};\n@@ -140,7 +140,7 @@ impl UvIoFactory {\n     pub fn make_handle(&mut self) -> HomeHandle {\n         // It's understood by the homing code that the \"local id\" is just the\n         // pointer of the local I/O factory cast to a uint.\n-        let id: uint = unsafe { cast::transmute_copy(&self) };\n+        let id: uint = unsafe { mem::transmute_copy(&self) };\n         HomeHandle::new(id, &mut **self.handle_pool.get_mut_ref())\n     }\n }"}, {"sha": "ea506931d76eef7350f22cf0f06b8d7ab4c6be08", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -88,7 +88,7 @@ pub enum Error {\n pub mod reader {\n     use std::char;\n \n-    use std::cast::transmute;\n+    use std::mem::transmute;\n     use std::int;\n     use std::option::{None, Option, Some};\n     use std::io::extensions::u64_from_be_bytes;\n@@ -617,11 +617,11 @@ pub mod reader {\n }\n \n pub mod writer {\n-    use std::cast;\n     use std::clone::Clone;\n-    use std::io;\n-    use std::io::{Writer, Seek};\n     use std::io::extensions::u64_to_be_bytes;\n+    use std::io::{Writer, Seek};\n+    use std::io;\n+    use std::mem;\n \n     use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n         EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n@@ -679,7 +679,7 @@ pub mod writer {\n         /// FIXME(pcwalton): Workaround for badness in trans. DO NOT USE ME.\n         pub unsafe fn unsafe_clone(&self) -> Encoder<'a, W> {\n             Encoder {\n-                writer: cast::transmute_copy(&self.writer),\n+                writer: mem::transmute_copy(&self.writer),\n                 size_positions: self.size_positions.clone(),\n             }\n         }\n@@ -853,11 +853,11 @@ pub mod writer {\n         }\n \n         fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-            let bits = unsafe { cast::transmute(v) };\n+            let bits = unsafe { mem::transmute(v) };\n             self.wr_tagged_u64(EsF64 as uint, bits)\n         }\n         fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-            let bits = unsafe { cast::transmute(v) };\n+            let bits = unsafe { mem::transmute(v) };\n             self.wr_tagged_u32(EsF32 as uint, bits)\n         }\n         fn emit_char(&mut self, v: char) -> EncodeResult {"}, {"sha": "e087b3d1774995f5486beac433064bf4fcb9231a", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,18 +10,18 @@\n \n //! Operations on ASCII strings and characters\n \n-use to_str::{IntoStr};\n-use str;\n-use str::Str;\n-use str::{StrAllocating, StrSlice};\n-use str::OwnedStr;\n use container::Container;\n-use cast;\n use fmt;\n use iter::Iterator;\n+use mem;\n+use option::{Option, Some, None};\n use slice::{ImmutableVector, MutableVector, Vector};\n+use str::OwnedStr;\n+use str::Str;\n+use str::{StrAllocating, StrSlice};\n+use str;\n+use to_str::{IntoStr};\n use vec::Vec;\n-use option::{Option, Some, None};\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n #[deriving(Clone, Eq, Ord, TotalOrd, TotalEq, Hash)]\n@@ -162,7 +162,7 @@ pub trait AsciiCast<T> {\n impl<'a> AsciiCast<&'a[Ascii]> for &'a [u8] {\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> &'a[Ascii] {\n-        cast::transmute(*self)\n+        mem::transmute(*self)\n     }\n \n     #[inline]\n@@ -177,7 +177,7 @@ impl<'a> AsciiCast<&'a[Ascii]> for &'a [u8] {\n impl<'a> AsciiCast<&'a [Ascii]> for &'a str {\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> &'a [Ascii] {\n-        cast::transmute(*self)\n+        mem::transmute(*self)\n     }\n \n     #[inline]\n@@ -245,7 +245,7 @@ impl OwnedAsciiCast for ~[u8] {\n \n     #[inline]\n     unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n-        cast::transmute(Vec::from_slice(self.as_slice()))\n+        mem::transmute(Vec::from_slice(self.as_slice()))\n     }\n }\n \n@@ -257,7 +257,7 @@ impl OwnedAsciiCast for ~str {\n \n     #[inline]\n     unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n-        let v: ~[u8] = cast::transmute(self);\n+        let v: ~[u8] = mem::transmute(self);\n         v.into_ascii_nocheck()\n     }\n }\n@@ -270,7 +270,7 @@ impl OwnedAsciiCast for Vec<u8> {\n \n     #[inline]\n     unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n-        cast::transmute(self)\n+        mem::transmute(self)\n     }\n }\n \n@@ -293,7 +293,7 @@ pub trait AsciiStr {\n impl<'a> AsciiStr for &'a [Ascii] {\n     #[inline]\n     fn as_str_ascii<'a>(&'a self) -> &'a str {\n-        unsafe { cast::transmute(*self) }\n+        unsafe { mem::transmute(*self) }\n     }\n \n     #[inline]\n@@ -315,15 +315,15 @@ impl<'a> AsciiStr for &'a [Ascii] {\n impl IntoStr for ~[Ascii] {\n     #[inline]\n     fn into_str(self) -> ~str {\n-        unsafe { cast::transmute(self) }\n+        unsafe { mem::transmute(self) }\n     }\n }\n \n impl IntoStr for Vec<Ascii> {\n     #[inline]\n     fn into_str(self) -> ~str {\n         unsafe {\n-            let s: &str = cast::transmute(self.as_slice());\n+            let s: &str = mem::transmute(self.as_slice());\n             s.to_owned()\n         }\n     }\n@@ -337,7 +337,7 @@ pub trait IntoBytes {\n \n impl IntoBytes for Vec<Ascii> {\n     fn into_bytes(self) -> Vec<u8> {\n-        unsafe { cast::transmute(self) }\n+        unsafe { mem::transmute(self) }\n     }\n }\n "}, {"sha": "0885a7af00b4d4d2be1be96780e5aed75e979cf1", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -65,24 +65,23 @@ fn main() {\n \n */\n \n-use cast;\n+use clone::Clone;\n+use cmp::Eq;\n use container::Container;\n use iter::{Iterator, range};\n-use libc;\n use kinds::marker;\n-use ops::Drop;\n-use cmp::Eq;\n-use clone::Clone;\n+use libc;\n use mem;\n+use ops::Drop;\n use option::{Option, Some, None};\n use ptr::RawPtr;\n use ptr;\n-use str::StrSlice;\n-use str;\n+use raw::Slice;\n+use rt::libc_heap::malloc_raw;\n use slice::{ImmutableVector, MutableVector};\n use slice;\n-use rt::libc_heap::malloc_raw;\n-use raw::Slice;\n+use str::StrSlice;\n+use str;\n \n /// The representation of a C String.\n ///\n@@ -154,7 +153,7 @@ impl CString {\n     /// Fails if the CString is null.\n     pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n-        f(unsafe { cast::transmute_mut_unsafe(self.buf) })\n+        f(self.buf as *mut libc::c_char)\n     }\n \n     /// Returns true if the CString is a null.\n@@ -182,7 +181,7 @@ impl CString {\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n-            cast::transmute(Slice { data: self.buf, len: self.len() + 1 })\n+            mem::transmute(Slice { data: self.buf, len: self.len() + 1 })\n         }\n     }\n \n@@ -196,7 +195,7 @@ impl CString {\n     pub fn as_bytes_no_nul<'a>(&'a self) -> &'a [u8] {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n-            cast::transmute(Slice { data: self.buf, len: self.len() })\n+            mem::transmute(Slice { data: self.buf, len: self.len() })\n         }\n     }\n "}, {"sha": "817b54fb692f20b8e5838d53671de59ae7c2b38d", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -33,9 +33,9 @@\n //! handled correctly, i.e. that allocated memory is eventually freed\n //! if necessary.\n \n-use cast;\n use container::Container;\n use kinds::Send;\n+use mem;\n use ops::Drop;\n use option::{Option, Some, None};\n use ptr::RawPtr;\n@@ -102,14 +102,14 @@ impl<T> CVec<T> {\n     /// View the stored data as a slice.\n     pub fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n-            cast::transmute(raw::Slice { data: self.base as *T, len: self.len })\n+            mem::transmute(raw::Slice { data: self.base as *T, len: self.len })\n         }\n     }\n \n     /// View the stored data as a mutable slice.\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n-            cast::transmute(raw::Slice { data: self.base as *T, len: self.len })\n+            mem::transmute(raw::Slice { data: self.base as *T, len: self.len })\n         }\n     }\n "}, {"sha": "ed884647fb6ffd6112c76e71e2011edb07003605", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -45,11 +45,11 @@\n \n #![allow(dead_code)]\n \n-use cast;\n use cell::Cell;\n use iter::Iterator;\n-use kinds::marker;\n use kinds::Send;\n+use kinds::marker;\n+use mem;\n use ops::Drop;\n use option::{Some, None, Option};\n use owned::Box;\n@@ -247,8 +247,8 @@ impl<'rx, T: Send> Handle<'rx, T> {\n     /// while it is added to the `Select` set.\n     pub unsafe fn add(&mut self) {\n         if self.added { return }\n-        let selector: &mut Select = cast::transmute(&*self.selector);\n-        let me: *mut Handle<'static, ()> = cast::transmute(&*self);\n+        let selector: &mut Select = mem::transmute(&*self.selector);\n+        let me: *mut Handle<'static, ()> = mem::transmute(&*self);\n \n         if selector.head.is_null() {\n             selector.head = me;\n@@ -268,8 +268,8 @@ impl<'rx, T: Send> Handle<'rx, T> {\n     pub unsafe fn remove(&mut self) {\n         if !self.added { return }\n \n-        let selector: &mut Select = cast::transmute(&*self.selector);\n-        let me: *mut Handle<'static, ()> = cast::transmute(&*self);\n+        let selector: &mut Select = mem::transmute(&*self.selector);\n+        let me: *mut Handle<'static, ()> = mem::transmute(&*self);\n \n         if self.prev.is_null() {\n             assert_eq!(selector.head, me);"}, {"sha": "819e885526cbf5f31852a6a15bec0ac9c470797b", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -33,7 +33,6 @@\n /// of a synchronous channel. There are a few branches for the unbuffered case,\n /// but they're mostly just relevant to blocking senders.\n \n-use cast;\n use container::Container;\n use iter::Iterator;\n use kinds::Send;\n@@ -187,7 +186,7 @@ impl<T: Send> Packet<T> {\n             NoneBlocked if state.cap == 0 => {\n                 let mut canceled = false;\n                 assert!(state.canceled.is_none());\n-                state.canceled = Some(unsafe { cast::transmute(&mut canceled) });\n+                state.canceled = Some(unsafe { mem::transmute(&mut canceled) });\n                 wait(&mut state.blocker, BlockedSender, &self.lock);\n                 if canceled {Err(state.buf.dequeue())} else {Ok(())}\n             }"}, {"sha": "b4bb6236f08ab1543180589aed9d551dcbb35c75", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -484,26 +484,26 @@ will look like `\"\\\\{\"`.\n */\n \n use any;\n-use cast;\n use cell::Cell;\n use char::Char;\n use cmp;\n use container::Container;\n+use intrinsics::TypeId;\n use io::MemWriter;\n use io;\n-use iter;\n use iter::{Iterator, range};\n+use iter;\n use kinds::Copy;\n+use mem;\n use num::Signed;\n use option::{Option, Some, None};\n use owned::Box;\n use repr;\n use result::{Ok, Err, ResultUnwrap};\n-use str::{StrSlice, StrAllocating, UTF16Item, ScalarValue, LoneSurrogate};\n-use str;\n use slice::{Vector, ImmutableVector};\n use slice;\n-use intrinsics::TypeId;\n+use str::{StrSlice, StrAllocating, UTF16Item, ScalarValue, LoneSurrogate};\n+use str;\n \n pub use self::num::radix;\n pub use self::num::Radix;\n@@ -552,7 +552,7 @@ impl<'a> Arguments<'a> {\n     #[doc(hidden)] #[inline]\n     pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],\n                           args: &'a [Argument<'a>]) -> Arguments<'a> {\n-        Arguments{ fmt: cast::transmute(fmt), args: args }\n+        Arguments{ fmt: mem::transmute(fmt), args: args }\n     }\n }\n \n@@ -870,7 +870,7 @@ impl<'a> Formatter<'a> {\n             rt::Plural(offset, ref selectors, ref default) => {\n                 // This is validated at compile-time to be a pointer to a\n                 // '&uint' value.\n-                let value: &uint = unsafe { cast::transmute(arg.value) };\n+                let value: &uint = unsafe { mem::transmute(arg.value) };\n                 let value = *value;\n \n                 // First, attempt to match against explicit values without the\n@@ -913,7 +913,7 @@ impl<'a> Formatter<'a> {\n             rt::Select(ref selectors, ref default) => {\n                 // This is validated at compile-time to be a pointer to a\n                 // string slice,\n-                let value: & &str = unsafe { cast::transmute(arg.value) };\n+                let value: & &str = unsafe { mem::transmute(arg.value) };\n                 let value = *value;\n \n                 for s in selectors.iter() {\n@@ -1093,8 +1093,8 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n     unsafe {\n         Argument {\n-            formatter: cast::transmute(f),\n-            value: cast::transmute(t)\n+            formatter: mem::transmute(f),\n+            value: mem::transmute(t)\n         }\n     }\n }\n@@ -1141,7 +1141,7 @@ impl Char for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8, ..4];\n         let amt = self.encode_utf8(utf8);\n-        let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };\n+        let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n         secret_string(&s, f)\n     }\n }"}, {"sha": "a510aa90343e5bec8a61409e87d07ad88ada0523", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -307,7 +307,7 @@ impl<S: Writer, T: Hash<S>, U: Hash<S>> Hash<S> for Result<T, U> {\n \n #[cfg(test)]\n mod tests {\n-    use cast;\n+    use mem;\n     use io::{IoResult, Writer};\n     use iter::{Iterator};\n     use option::{Some, None};\n@@ -367,12 +367,12 @@ mod tests {\n         assert_eq!(hasher.hash(& &[1u8, 2u8, 3u8]), 9);\n \n         unsafe {\n-            let ptr: *int = cast::transmute(5);\n+            let ptr: *int = mem::transmute(5);\n             assert_eq!(hasher.hash(&ptr), 5);\n         }\n \n         unsafe {\n-            let ptr: *mut int = cast::transmute(5);\n+            let ptr: *mut int = mem::transmute(5);\n             assert_eq!(hasher.hash(&ptr), 5);\n         }\n     }"}, {"sha": "bb4bd50815a90928679d1bad4634e8aa074d6949", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -77,7 +77,7 @@ impl<'r, R: Reader> Iterator<IoResult<u8>> for Bytes<'r, R> {\n /// This function returns the value returned by the callback, for convenience.\n pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     use mem::{to_le16, to_le32, to_le64};\n-    use cast::transmute;\n+    use mem::transmute;\n \n     // LLVM fails to properly optimize this when using shifts instead of the to_le* intrinsics\n     assert!(size <= 8u);\n@@ -117,7 +117,7 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n /// This function returns the value returned by the callback, for convenience.\n pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     use mem::{to_be16, to_be32, to_be64};\n-    use cast::transmute;\n+    use mem::transmute;\n \n     // LLVM fails to properly optimize this when using shifts instead of the to_be* intrinsics\n     assert!(size <= 8u);"}, {"sha": "37edab9991598ab69494efc8eb1fcadc2659b75d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -217,24 +217,24 @@ responding to errors that may occur while attempting to read the numbers.\n \n #![deny(unused_must_use)]\n \n-use cast;\n use char::Char;\n use container::Container;\n use fmt;\n use int;\n use iter::Iterator;\n use libc;\n+use mem::transmute;\n use ops::{BitOr, BitAnd, Sub};\n-use os;\n use option::{Option, Some, None};\n+use os;\n use owned::Box;\n use path::Path;\n use result::{Ok, Err, Result};\n+use slice::{Vector, MutableVector, ImmutableVector};\n use str::{StrSlice, StrAllocating};\n use str;\n use uint;\n use unstable::finally::try_finally;\n-use slice::{Vector, MutableVector, ImmutableVector};\n use vec::Vec;\n \n // Reexports\n@@ -729,7 +729,7 @@ pub trait Reader {\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n     fn read_be_f64(&mut self) -> IoResult<f64> {\n         self.read_be_u64().map(|i| unsafe {\n-            cast::transmute::<u64, f64>(i)\n+            transmute::<u64, f64>(i)\n         })\n     }\n \n@@ -738,7 +738,7 @@ pub trait Reader {\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n     fn read_be_f32(&mut self) -> IoResult<f32> {\n         self.read_be_u32().map(|i| unsafe {\n-            cast::transmute::<u32, f32>(i)\n+            transmute::<u32, f32>(i)\n         })\n     }\n \n@@ -789,7 +789,7 @@ pub trait Reader {\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n     fn read_le_f64(&mut self) -> IoResult<f64> {\n         self.read_le_u64().map(|i| unsafe {\n-            cast::transmute::<u64, f64>(i)\n+            transmute::<u64, f64>(i)\n         })\n     }\n \n@@ -798,7 +798,7 @@ pub trait Reader {\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n     fn read_le_f32(&mut self) -> IoResult<f32> {\n         self.read_le_u32().map(|i| unsafe {\n-            cast::transmute::<u32, f32>(i)\n+            transmute::<u32, f32>(i)\n         })\n     }\n \n@@ -995,14 +995,14 @@ pub trait Writer {\n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n     fn write_be_f64(&mut self, f: f64) -> IoResult<()> {\n         unsafe {\n-            self.write_be_u64(cast::transmute(f))\n+            self.write_be_u64(transmute(f))\n         }\n     }\n \n     /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n     fn write_be_f32(&mut self, f: f32) -> IoResult<()> {\n         unsafe {\n-            self.write_be_u32(cast::transmute(f))\n+            self.write_be_u32(transmute(f))\n         }\n     }\n \n@@ -1040,15 +1040,15 @@ pub trait Writer {\n     /// (8 bytes).\n     fn write_le_f64(&mut self, f: f64) -> IoResult<()> {\n         unsafe {\n-            self.write_le_u64(cast::transmute(f))\n+            self.write_le_u64(transmute(f))\n         }\n     }\n \n     /// Write a little-endian IEEE754 single-precision floating-point\n     /// (4 bytes).\n     fn write_le_f32(&mut self, f: f32) -> IoResult<()> {\n         unsafe {\n-            self.write_le_u32(cast::transmute(f))\n+            self.write_le_u32(transmute(f))\n         }\n     }\n "}, {"sha": "864a70105412ab30c2e75c6cb531ce751344a06f", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -226,6 +226,7 @@ impl Writer for UdpStream {\n }\n \n #[cfg(test)]\n+#[allow(experimental)]\n mod test {\n     use super::*;\n     use io::net::ip::{SocketAddr};"}, {"sha": "8f0c1e413097137e6bd891421881d124e21d40d4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -143,7 +143,6 @@ extern crate core;\n \n pub use core::any;\n pub use core::bool;\n-pub use core::cast;\n pub use core::cell;\n pub use core::char;\n pub use core::clone;"}, {"sha": "1a971594837df31e91ab622dda3138ec8d00cafa", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -38,11 +38,11 @@ assert_eq!(*key_vector.get().unwrap(), ~[4]);\n // Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation\n // magic.\n \n-use cast;\n use iter::{Iterator};\n use kinds::Send;\n use kinds::marker;\n use mem::replace;\n+use mem;\n use ops::{Drop, Deref};\n use option::{None, Option, Some};\n use owned::Box;\n@@ -172,7 +172,7 @@ impl<T: 'static> KeyValue<T> {\n         // anything.\n         let newval = data.map(|d| {\n             let d = box d as Box<LocalData>;\n-            let d: Box<LocalData:Send> = unsafe { cast::transmute(d) };\n+            let d: Box<LocalData:Send> = unsafe { mem::transmute(d) };\n             (keyval, d, 0)\n         });\n \n@@ -188,8 +188,8 @@ impl<T: 'static> KeyValue<T> {\n                 replace(map.get_mut(i), newval).map(|(_, data, _)| {\n                     // Move `data` into transmute to get out the memory that it\n                     // owns, we must free it manually later.\n-                    let t: raw::TraitObject = unsafe { cast::transmute(data) };\n-                    let alloc: Box<T> = unsafe { cast::transmute(t.data) };\n+                    let t: raw::TraitObject = unsafe { mem::transmute(data) };\n+                    let alloc: Box<T> = unsafe { mem::transmute(t.data) };\n \n                     // Now that we own `alloc`, we can just move out of it as we\n                     // would with any other data."}, {"sha": "29c206b32fc36a89617360bfbadda42993166071", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -15,13 +15,13 @@\n \n use prelude::*;\n \n-use cast;\n use from_str::FromStr;\n+use intrinsics;\n use libc::c_int;\n-use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n+use mem;\n use num::strconv;\n+use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use num;\n-use intrinsics;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -111,7 +111,7 @@ impl Float for f32 {\n         static EXP_MASK: u32 = 0x7f800000;\n         static MAN_MASK: u32 = 0x007fffff;\n \n-        let bits: u32 = unsafe { cast::transmute(self) };\n+        let bits: u32 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0)        => FPZero,\n             (_, 0)        => FPSubnormal,\n@@ -168,7 +168,7 @@ impl Float for f32 {\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe { cast::transmute(self) };\n+        let bits: u32 = unsafe { mem::transmute(self) };\n         let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n         let mantissa = if exponent == 0 {"}, {"sha": "c18ea5caba6298c3a1ce5fcefbc691262495137d", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -14,13 +14,13 @@\n \n use prelude::*;\n \n-use cast;\n use from_str::FromStr;\n+use intrinsics;\n use libc::{c_int};\n+use mem;\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use num::{strconv};\n use num;\n-use intrinsics;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -119,7 +119,7 @@ impl Float for f64 {\n         static EXP_MASK: u64 = 0x7ff0000000000000;\n         static MAN_MASK: u64 = 0x000fffffffffffff;\n \n-        let bits: u64 = unsafe { cast::transmute(self) };\n+        let bits: u64 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0)        => FPZero,\n             (_, 0)        => FPSubnormal,\n@@ -176,7 +176,7 @@ impl Float for f64 {\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe { cast::transmute(self) };\n+        let bits: u64 = unsafe { mem::transmute(self) };\n         let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n         let mantissa = if exponent == 0 {"}, {"sha": "dfe7241d7af035b9c82f4d7201443a98f376bda4", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -12,13 +12,13 @@\n \n use ascii::AsciiCast;\n use c_str::{CString, ToCStr};\n-use cast;\n use clone::Clone;\n-use container::Container;\n use cmp::{Eq, TotalEq};\n+use container::Container;\n use from_str::FromStr;\n use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map};\n+use mem;\n use option::{Option, Some, None};\n use slice::{Vector, OwnedVector, ImmutableVector};\n use str::{CharSplits, Str, StrAllocating, StrVector, StrSlice};\n@@ -389,13 +389,13 @@ impl GenericPath for Path {\n     #[inline]\n     fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n         // filestem() returns a byte vector that's guaranteed valid UTF-8\n-        self.filestem().map(|t| unsafe { cast::transmute(t) })\n+        self.filestem().map(|t| unsafe { mem::transmute(t) })\n     }\n \n     #[inline]\n     fn extension_str<'a>(&'a self) -> Option<&'a str> {\n         // extension() returns a byte vector that's guaranteed valid UTF-8\n-        self.extension().map(|t| unsafe { cast::transmute(t) })\n+        self.extension().map(|t| unsafe { mem::transmute(t) })\n     }\n \n     fn dir_path(&self) -> Path {"}, {"sha": "bc489bc399f848d8070e03b276b3768d9dd5c903", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -23,7 +23,7 @@ pointers, and then storing the parent pointers as `Weak` pointers.\n \n */\n \n-use cast::transmute;\n+use mem::transmute;\n use cell::Cell;\n use clone::Clone;\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};"}, {"sha": "6029f504d10b62a5b426e935f628d852f011282f", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -16,7 +16,7 @@ More runtime type reflection\n \n #![allow(missing_doc)]\n \n-use cast::transmute;\n+use mem::transmute;\n use char;\n use container::Container;\n use io;\n@@ -157,7 +157,7 @@ impl<'a> ReprVisitor<'a> {\n                 ptr: ptr,\n                 ptr_stk: vec!(),\n                 var_stk: vec!(),\n-                writer: ::cast::transmute_copy(&self.writer),\n+                writer: ::mem::transmute_copy(&self.writer),\n                 last_err: None,\n             };\n             let mut v = reflect::MovePtrAdaptor(u);"}, {"sha": "95d0eabd336d86416c0923091642e6fb175fc6a1", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -40,7 +40,7 @@ pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n #[cfg(not(test))] pub fn take() -> Option<Vec<~[u8]>> { imp::take() }\n #[cfg(test)]      pub fn take() -> Option<Vec<~[u8]>> {\n     match realargs::take() {\n-        realstd::option::Some(v) => Some(unsafe{ ::cast::transmute(v) }),\n+        realstd::option::Some(v) => Some(unsafe{ ::mem::transmute(v) }),\n         realstd::option::None => None,\n     }\n }\n@@ -49,13 +49,13 @@ pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n ///\n /// It is an error if the arguments already exist.\n #[cfg(not(test))] pub fn put(args: Vec<~[u8]>) { imp::put(args) }\n-#[cfg(test)]      pub fn put(args: Vec<~[u8]>) { realargs::put(unsafe { ::cast::transmute(args) }) }\n+#[cfg(test)]      pub fn put(args: Vec<~[u8]>) { realargs::put(unsafe { ::mem::transmute(args) }) }\n \n /// Make a clone of the global arguments.\n #[cfg(not(test))] pub fn clone() -> Option<Vec<~[u8]>> { imp::clone() }\n #[cfg(test)]      pub fn clone() -> Option<Vec<~[u8]>> {\n     match realargs::clone() {\n-        realstd::option::Some(v) => Some(unsafe { ::cast::transmute(v) }),\n+        realstd::option::Some(v) => Some(unsafe { ::mem::transmute(v) }),\n         realstd::option::None => None,\n     }\n }\n@@ -64,10 +64,9 @@ pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n mod imp {\n-    use cast;\n     use clone::Clone;\n-    use option::{Option, Some, None};\n     use iter::Iterator;\n+    use option::{Option, Some, None};\n     use owned::Box;\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use mem;\n@@ -120,7 +119,7 @@ mod imp {\n     }\n \n     fn get_global_ptr() -> *mut Option<Box<Vec<~[u8]>>> {\n-        unsafe { cast::transmute(&global_args_ptr) }\n+        unsafe { mem::transmute(&global_args_ptr) }\n     }\n \n     // Copied from `os`."}, {"sha": "c892a73d9348433101e348968681400ee3b7ae96", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -12,15 +12,14 @@\n //!\n //! Documentation can be found on the `rt::at_exit` function.\n \n-use cast;\n use iter::Iterator;\n use kinds::Send;\n use mem;\n use option::{Some, None};\n use owned::Box;\n use ptr::RawPtr;\n-use unstable::sync::Exclusive;\n use slice::OwnedVector;\n+use unstable::sync::Exclusive;\n use vec::Vec;\n \n type Queue = Exclusive<Vec<proc():Send>>;\n@@ -38,15 +37,15 @@ pub fn init() {\n         rtassert!(!RUNNING);\n         rtassert!(QUEUE.is_null());\n         let state: Box<Queue> = box Exclusive::new(vec!());\n-        QUEUE = cast::transmute(state);\n+        QUEUE = mem::transmute(state);\n     }\n }\n \n pub fn push(f: proc():Send) {\n     unsafe {\n         rtassert!(!RUNNING);\n         rtassert!(!QUEUE.is_null());\n-        let state: &mut Queue = cast::transmute(QUEUE);\n+        let state: &mut Queue = mem::transmute(QUEUE);\n         let mut f = Some(f);\n         state.with(|arr|  {\n             arr.push(f.take_unwrap());\n@@ -59,7 +58,7 @@ pub fn run() {\n         rtassert!(!RUNNING);\n         rtassert!(!QUEUE.is_null());\n         RUNNING = true;\n-        let state: Box<Queue> = cast::transmute(QUEUE);\n+        let state: Box<Queue> = mem::transmute(QUEUE);\n         QUEUE = 0 as *mut Queue;\n         let mut vec = None;\n         state.with(|arr| {"}, {"sha": "f4cb770544c46f96579d804755647d5f4e4d9cee", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -237,9 +237,9 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n #[cfg(unix)]\n mod imp {\n     use c_str::CString;\n-    use cast;\n     use io::{IoResult, IoError, Writer};\n     use libc;\n+    use mem;\n     use option::{Some, None, Option};\n     use result::{Ok, Err};\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n@@ -280,7 +280,7 @@ mod imp {\n \n         extern fn trace_fn(ctx: *uw::_Unwind_Context,\n                            arg: *libc::c_void) -> uw::_Unwind_Reason_Code {\n-            let cx: &mut Context = unsafe { cast::transmute(arg) };\n+            let cx: &mut Context = unsafe { mem::transmute(arg) };\n             let ip = unsafe { uw::_Unwind_GetIP(ctx) as *libc::c_void };\n             // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n             // it appears to work fine without it, so we only use"}, {"sha": "5feec7fd9d2d93641a04fdf081ca21b4a8c9f26a", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,18 +10,17 @@\n \n //! The local, garbage collected heap\n \n-use cast;\n use iter::Iterator;\n use libc::{c_void, free};\n use mem;\n use ops::Drop;\n use option::{Option, None, Some};\n-use ptr;\n use ptr::RawPtr;\n+use ptr;\n+use raw;\n use rt::libc_heap;\n use rt::local::Local;\n use rt::task::Task;\n-use raw;\n use slice::{ImmutableVector, Vector};\n use vec::Vec;\n \n@@ -63,7 +62,7 @@ impl LocalHeap {\n         let alloc = self.memory_region.malloc(total_size);\n         {\n             // Make sure that we can't use `mybox` outside of this scope\n-            let mybox: &mut Box = unsafe { cast::transmute(alloc) };\n+            let mybox: &mut Box = unsafe { mem::transmute(alloc) };\n             // Clear out this box, and move it to the front of the live\n             // allocations list\n             mybox.drop_glue = drop_glue;\n@@ -85,7 +84,7 @@ impl LocalHeap {\n         let new_box = self.memory_region.realloc(ptr, total_size);\n         {\n             // Fix links because we could have moved around\n-            let mybox: &mut Box = unsafe { cast::transmute(new_box) };\n+            let mybox: &mut Box = unsafe { mem::transmute(new_box) };\n             if !mybox.prev.is_null() {\n                 unsafe { (*mybox.prev).next = new_box; }\n             }\n@@ -103,7 +102,7 @@ impl LocalHeap {\n     pub fn free(&mut self, alloc: *mut Box) {\n         {\n             // Make sure that we can't use `mybox` outside of this scope\n-            let mybox: &mut Box = unsafe { cast::transmute(alloc) };\n+            let mybox: &mut Box = unsafe { mem::transmute(alloc) };\n \n             // Unlink it from the linked list\n             if !mybox.prev.is_null() {\n@@ -167,7 +166,7 @@ impl AllocHeader {\n     fn update_size(&mut self, _size: u32) {}\n \n     fn as_box(&mut self) -> *mut Box {\n-        let myaddr: uint = unsafe { cast::transmute(self) };\n+        let myaddr: uint = unsafe { mem::transmute(self) };\n         (myaddr + AllocHeader::size()) as *mut Box\n     }\n \n@@ -191,7 +190,7 @@ impl MemoryRegion {\n             libc_heap::malloc_raw(total_size) as *AllocHeader\n         };\n \n-        let alloc: &mut AllocHeader = unsafe { cast::transmute(alloc) };\n+        let alloc: &mut AllocHeader = unsafe { mem::transmute(alloc) };\n         alloc.init(size as u32);\n         self.claim(alloc);\n         self.live_allocations += 1;\n@@ -210,7 +209,7 @@ impl MemoryRegion {\n             libc_heap::realloc_raw(orig_alloc as *mut u8, total_size) as *AllocHeader\n         };\n \n-        let alloc: &mut AllocHeader = unsafe { cast::transmute(alloc) };\n+        let alloc: &mut AllocHeader = unsafe { mem::transmute(alloc) };\n         alloc.assert_sane();\n         alloc.update_size(size as u32);\n         self.update(alloc, orig_alloc as *AllocHeader);\n@@ -223,7 +222,7 @@ impl MemoryRegion {\n         let alloc = AllocHeader::from(alloc);\n         unsafe {\n             (*alloc).assert_sane();\n-            self.release(cast::transmute(alloc));\n+            self.release(mem::transmute(alloc));\n             rtassert!(self.live_allocations > 0);\n             self.live_allocations -= 1;\n             free(alloc as *mut c_void)"}, {"sha": "1197a4ccbe670078c3ee1ed2843c53f311bf57de", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -17,7 +17,7 @@\n \n #![allow(dead_code)]\n \n-use cast;\n+use mem;\n use ops::{Drop, Deref, DerefMut};\n use owned::Box;\n use ptr::RawPtr;\n@@ -44,7 +44,7 @@ impl<T> Drop for Borrowed<T> {\n             if self.val.is_null() {\n                 rtabort!(\"Aiee, returning null borrowed object!\");\n             }\n-            let val: Box<T> = cast::transmute(self.val);\n+            let val: Box<T> = mem::transmute(self.val);\n             put::<T>(val);\n             rtassert!(exists());\n         }\n@@ -71,7 +71,7 @@ impl<T> DerefMut<T> for Borrowed<T> {\n /// Does not validate the pointer type.\n #[inline]\n pub unsafe fn borrow<T>() -> Borrowed<T> {\n-    let val: *() = cast::transmute(take::<T>());\n+    let val: *() = mem::transmute(take::<T>());\n     Borrowed {\n         val: val,\n     }\n@@ -83,7 +83,7 @@ pub unsafe fn borrow<T>() -> Borrowed<T> {\n /// it wherever possible.\n #[cfg(not(windows), not(target_os = \"android\"))]\n pub mod compiled {\n-    use cast;\n+    use mem;\n     use option::{Option, Some, None};\n     use owned::Box;\n     use ptr::RawPtr;\n@@ -157,7 +157,7 @@ pub mod compiled {\n     /// Does not validate the pointer type.\n     #[inline(never)] // see comments above\n     pub unsafe fn put<T>(sched: Box<T>) {\n-        RT_TLS_PTR = cast::transmute(sched)\n+        RT_TLS_PTR = mem::transmute(sched)\n     }\n \n     /// Take ownership of a pointer from thread-local storage.\n@@ -169,9 +169,9 @@ pub mod compiled {\n     pub unsafe fn take<T>() -> Box<T> {\n         let ptr = RT_TLS_PTR;\n         rtassert!(!ptr.is_null());\n-        let ptr: Box<T> = cast::transmute(ptr);\n+        let ptr: Box<T> = mem::transmute(ptr);\n         // can't use `as`, due to type not matching with `cfg(test)`\n-        RT_TLS_PTR = cast::transmute(0);\n+        RT_TLS_PTR = mem::transmute(0);\n         ptr\n     }\n \n@@ -186,9 +186,9 @@ pub mod compiled {\n         if ptr.is_null() {\n             None\n         } else {\n-            let ptr: Box<T> = cast::transmute(ptr);\n+            let ptr: Box<T> = mem::transmute(ptr);\n             // can't use `as`, due to type not matching with `cfg(test)`\n-            RT_TLS_PTR = cast::transmute(0);\n+            RT_TLS_PTR = mem::transmute(0);\n             Some(ptr)\n         }\n     }\n@@ -201,7 +201,7 @@ pub mod compiled {\n     /// Leaves the old pointer in TLS for speed.\n     #[inline(never)] // see comments above\n     pub unsafe fn unsafe_take<T>() -> Box<T> {\n-        cast::transmute(RT_TLS_PTR)\n+        mem::transmute(RT_TLS_PTR)\n     }\n \n     /// Check whether there is a thread-local pointer installed.\n@@ -234,11 +234,11 @@ pub mod compiled {\n /// implementation uses the `thread_local_storage` module to provide a\n /// thread-local value.\n pub mod native {\n-    use cast;\n+    use mem;\n     use option::{Option, Some, None};\n     use owned::Box;\n-    use ptr;\n     use ptr::RawPtr;\n+    use ptr;\n     use tls = rt::thread_local_storage;\n \n     static mut RT_TLS_KEY: tls::Key = -1;\n@@ -264,7 +264,7 @@ pub mod native {\n     #[inline]\n     pub unsafe fn put<T>(sched: Box<T>) {\n         let key = tls_key();\n-        let void_ptr: *mut u8 = cast::transmute(sched);\n+        let void_ptr: *mut u8 = mem::transmute(sched);\n         tls::set(key, void_ptr);\n     }\n \n@@ -280,7 +280,7 @@ pub mod native {\n         if void_ptr.is_null() {\n             rtabort!(\"thread-local pointer is null. bogus!\");\n         }\n-        let ptr: Box<T> = cast::transmute(void_ptr);\n+        let ptr: Box<T> = mem::transmute(void_ptr);\n         tls::set(key, ptr::mut_null());\n         return ptr;\n     }\n@@ -298,7 +298,7 @@ pub mod native {\n                 if void_ptr.is_null() {\n                     None\n                 } else {\n-                    let ptr: Box<T> = cast::transmute(void_ptr);\n+                    let ptr: Box<T> = mem::transmute(void_ptr);\n                     tls::set(key, ptr::mut_null());\n                     Some(ptr)\n                 }\n@@ -320,7 +320,7 @@ pub mod native {\n         if void_ptr.is_null() {\n             rtabort!(\"thread-local pointer is null. bogus!\");\n         }\n-        let ptr: Box<T> = cast::transmute(void_ptr);\n+        let ptr: Box<T> = mem::transmute(void_ptr);\n         return ptr;\n     }\n \n@@ -398,7 +398,7 @@ pub mod native {\n     pub fn maybe_tls_key() -> Option<tls::Key> {\n         use realstd;\n         unsafe {\n-            cast::transmute(realstd::rt::shouldnt_be_public::maybe_tls_key())\n+            mem::transmute(realstd::rt::shouldnt_be_public::maybe_tls_key())\n         }\n     }\n }"}, {"sha": "bc3a483f30d2b5d471d63719b866a673d695f4f7", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,11 +11,11 @@\n //! The EventLoop and internal synchronous I/O interface.\n \n use c_str::CString;\n-use cast;\n use comm::{Sender, Receiver};\n+use kinds::Send;\n use libc::c_int;\n use libc;\n-use kinds::Send;\n+use mem;\n use ops::Drop;\n use option::{Option, Some, None};\n use owned::Box;\n@@ -118,7 +118,7 @@ impl<'a> LocalIo<'a> {\n         // in order to have what is likely a static lifetime (bad).\n         let mut t: Box<Task> = Local::take();\n         let ret = t.local_io().map(|t| {\n-            unsafe { cast::transmute_copy(&t) }\n+            unsafe { mem::transmute_copy(&t) }\n         });\n         Local::put(t);\n         return ret;\n@@ -143,7 +143,7 @@ impl<'a> LocalIo<'a> {\n         // FIXME(pcwalton): I think this is actually sound? Could borrow check\n         // allow this safely?\n         unsafe {\n-            cast::transmute_copy(&self.factory)\n+            mem::transmute_copy(&self.factory)\n         }\n     }\n }"}, {"sha": "cd0445056b29034fc416ee75a292a63bc10594d3", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -14,14 +14,14 @@\n //! to implement this.\n \n use any::AnyOwnExt;\n-use cast;\n use cleanup;\n use clone::Clone;\n use comm::Sender;\n use io::Writer;\n use iter::{Iterator, Take};\n use kinds::Send;\n use local_data;\n+use mem;\n use ops::Drop;\n use option::{Option, Some, None};\n use owned::Box;\n@@ -116,7 +116,7 @@ impl Task {\n         // Unsafely get a handle to the task so we can continue to use it after\n         // putting it in tls (so we can invoke the unwinder).\n         let handle: *mut Task = unsafe {\n-            *cast::transmute::<&Box<Task>, &*mut Task>(&self)\n+            *mem::transmute::<&Box<Task>, &*mut Task>(&self)\n         };\n         Local::put(self);\n \n@@ -222,13 +222,13 @@ impl Task {\n         //      crops up.\n         unsafe {\n             let imp = self.imp.take_unwrap();\n-            let &(vtable, _): &(uint, uint) = cast::transmute(&imp);\n+            let &(vtable, _): &(uint, uint) = mem::transmute(&imp);\n             match imp.wrap().move::<T>() {\n                 Ok(t) => Some(t),\n                 Err(t) => {\n-                    let (_, obj): (uint, uint) = cast::transmute(t);\n+                    let (_, obj): (uint, uint) = mem::transmute(t);\n                     let obj: Box<Runtime:Send> =\n-                        cast::transmute((vtable, obj));\n+                        mem::transmute((vtable, obj));\n                     self.put_runtime(obj);\n                     None\n                 }\n@@ -317,7 +317,7 @@ impl BlockedTask {\n             Shared(arc) => unsafe {\n                 match (*arc.get()).swap(0, SeqCst) {\n                     0 => None,\n-                    n => Some(cast::transmute(n)),\n+                    n => Some(mem::transmute(n)),\n                 }\n             }\n         }\n@@ -343,7 +343,7 @@ impl BlockedTask {\n     pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks> {\n         let arc = match self {\n             Owned(task) => {\n-                let flag = unsafe { AtomicUint::new(cast::transmute(task)) };\n+                let flag = unsafe { AtomicUint::new(mem::transmute(task)) };\n                 UnsafeArc::new(flag)\n             }\n             Shared(arc) => arc.clone(),\n@@ -357,12 +357,12 @@ impl BlockedTask {\n     pub unsafe fn cast_to_uint(self) -> uint {\n         match self {\n             Owned(task) => {\n-                let blocked_task_ptr: uint = cast::transmute(task);\n+                let blocked_task_ptr: uint = mem::transmute(task);\n                 rtassert!(blocked_task_ptr & 0x1 == 0);\n                 blocked_task_ptr\n             }\n             Shared(arc) => {\n-                let blocked_task_ptr: uint = cast::transmute(box arc);\n+                let blocked_task_ptr: uint = mem::transmute(box arc);\n                 rtassert!(blocked_task_ptr & 0x1 == 0);\n                 blocked_task_ptr | 0x1\n             }\n@@ -374,10 +374,10 @@ impl BlockedTask {\n     #[inline]\n     pub unsafe fn cast_from_uint(blocked_task_ptr: uint) -> BlockedTask {\n         if blocked_task_ptr & 0x1 == 0 {\n-            Owned(cast::transmute(blocked_task_ptr))\n+            Owned(mem::transmute(blocked_task_ptr))\n         } else {\n             let ptr: Box<UnsafeArc<AtomicUint>> =\n-                cast::transmute(blocked_task_ptr & !1);\n+                mem::transmute(blocked_task_ptr & !1);\n             Shared(*ptr)\n         }\n     }"}, {"sha": "4f0d7d35ce892f4618821719cce83558fa4c36a1", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -17,9 +17,9 @@\n #![allow(non_camel_case_types)]\n #![allow(unsigned_negate)]\n \n-use cast;\n use kinds::Send;\n use libc;\n+use mem;\n use ops::Drop;\n use option::{Option, Some, None};\n use owned::Box;\n@@ -46,9 +46,9 @@ extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return {\n     use rt::stack;\n     unsafe {\n         stack::record_stack_bounds(0, uint::MAX);\n-        let f: Box<proc()> = cast::transmute(main);\n+        let f: Box<proc()> = mem::transmute(main);\n         (*f)();\n-        cast::transmute(0 as imp::rust_thread_return)\n+        mem::transmute(0 as imp::rust_thread_return)\n     }\n }\n \n@@ -83,7 +83,7 @@ impl Thread<()> {\n         // so.\n         let packet = box None;\n         let packet2: *mut Option<T> = unsafe {\n-            *cast::transmute::<&Box<Option<T>>, **mut Option<T>>(&packet)\n+            *mem::transmute::<&Box<Option<T>>, **mut Option<T>>(&packet)\n         };\n         let main = proc() unsafe { *packet2 = Some(main()); };\n         let native = unsafe { imp::create(stack, box main) };\n@@ -146,7 +146,7 @@ impl<T: Send> Drop for Thread<T> {\n \n #[cfg(windows)]\n mod imp {\n-    use cast;\n+    use mem;\n     use cmp;\n     use kinds::Send;\n     use libc;\n@@ -161,7 +161,7 @@ mod imp {\n     pub type rust_thread_return = DWORD;\n \n     pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n-        let arg: *mut libc::c_void = cast::transmute(p);\n+        let arg: *mut libc::c_void = mem::transmute(p);\n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n         // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n@@ -177,7 +177,7 @@ mod imp {\n \n         if ret as uint == 0 {\n             // be sure to not leak the closure\n-            let _p: Box<proc():Send> = cast::transmute(arg);\n+            let _p: Box<proc():Send> = mem::transmute(arg);\n             fail!(\"failed to spawn native thread: {}\", os::last_os_error());\n         }\n         return ret;\n@@ -213,7 +213,6 @@ mod imp {\n \n #[cfg(unix)]\n mod imp {\n-    use cast;\n     use cmp;\n     use kinds::Send;\n     use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n@@ -254,13 +253,13 @@ mod imp {\n             },\n         };\n \n-        let arg: *libc::c_void = cast::transmute(p);\n+        let arg: *libc::c_void = mem::transmute(p);\n         let ret = pthread_create(&mut native, &attr, super::thread_start, arg);\n         assert_eq!(pthread_attr_destroy(&mut attr), 0);\n \n         if ret != 0 {\n             // be sure to not leak the closure\n-            let _p: Box<proc():Send> = cast::transmute(arg);\n+            let _p: Box<proc():Send> = mem::transmute(arg);\n             fail!(\"failed to spawn native thread: {}\", os::last_os_error());\n         }\n         native\n@@ -302,7 +301,7 @@ mod imp {\n         if __pthread_get_minstack.is_null() {\n             PTHREAD_STACK_MIN\n         } else {\n-            unsafe { cast::transmute::<*(), F>(__pthread_get_minstack)(attr) }\n+            unsafe { mem::transmute::<*(), F>(__pthread_get_minstack)(attr) }\n         }\n     }\n "}, {"sha": "2551c89972e59e0fb21cfcdec8ed24e17c173b51", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -95,7 +95,7 @@ extern \"system\" {\n \n #[test]\n fn tls_smoke_test() {\n-    use cast::transmute;\n+    use mem::transmute;\n     unsafe {\n         let mut key = 0;\n         let value = box 20;"}, {"sha": "e10e0716f67f2bea6c58168c7289280deb30f9f8", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -58,8 +58,8 @@\n // Currently Rust uses unwind runtime provided by libgcc.\n \n use any::{Any, AnyRefExt};\n-use cast;\n use fmt;\n+use intrinsics;\n use kinds::Send;\n use mem;\n use option::{Some, None, Option};\n@@ -72,7 +72,6 @@ use rt::local::Local;\n use rt::task::Task;\n use str::Str;\n use task::TaskResult;\n-use intrinsics;\n \n use uw = rt::libunwind;\n \n@@ -98,7 +97,7 @@ impl Unwinder {\n         use libc::{c_void};\n \n         unsafe {\n-            let closure: Closure = cast::transmute(f);\n+            let closure: Closure = mem::transmute(f);\n             let ep = rust_try(try_fn, closure.code as *c_void,\n                               closure.env as *c_void);\n             if !ep.is_null() {\n@@ -109,7 +108,7 @@ impl Unwinder {\n \n         extern fn try_fn(code: *c_void, env: *c_void) {\n             unsafe {\n-                let closure: || = cast::transmute(Closure {\n+                let closure: || = mem::transmute(Closure {\n                     code: code as *(),\n                     env: env as *(),\n                 });\n@@ -146,7 +145,7 @@ impl Unwinder {\n                     exception_cleanup: exception_cleanup,\n                     private: [0, ..uw::unwinder_private_data_size],\n                 };\n-                let error = uw::_Unwind_RaiseException(cast::transmute(exception));\n+                let error = uw::_Unwind_RaiseException(mem::transmute(exception));\n                 rtabort!(\"Could not unwind stack, error = {}\", error as int)\n             }\n \n@@ -155,7 +154,7 @@ impl Unwinder {\n                 rtdebug!(\"exception_cleanup()\");\n                 unsafe {\n                     let _: Box<uw::_Unwind_Exception> =\n-                        cast::transmute(exception);\n+                        mem::transmute(exception);\n                 }\n             }\n         }"}, {"sha": "b0868dd0daf54d1d56b80b59226f1dfe3e54ba65", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -97,8 +97,7 @@ There are a number of free functions that create or take vectors, for example:\n \n */\n \n-use cast::transmute;\n-use cast;\n+use mem::transmute;\n use clone::Clone;\n use cmp::{TotalOrd, Ordering, Less, Greater};\n use cmp;\n@@ -333,7 +332,7 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n                     // FIXME: #13994 (should pass align and size here)\n                     exchange_free(ret as *mut u8, 0, 8);\n                 });\n-            cast::transmute(ret)\n+            mem::transmute(ret)\n         }\n     }\n \n@@ -380,7 +379,7 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n                     // FIXME: #13994 (should pass align and size here)\n                     exchange_free(ret as *mut u8, 0, 8);\n                 });\n-            cast::transmute(ret)\n+            mem::transmute(ret)\n         }\n     }\n \n@@ -531,7 +530,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n                 ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n                                                 &tmp as *T,\n                                                 1);\n-                cast::forget(tmp);\n+                mem::forget(tmp);\n             }\n         }\n     }"}, {"sha": "24cf9681ca84dfc648e977d7ed3798687c7bcd03", "filename": "src/libstd/str.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -74,23 +74,23 @@ The actual representation of strings have direct mappings to vectors:\n \n */\n \n-use cast;\n-use cast::transmute;\n-use char;\n use char::Char;\n+use char;\n use clone::Clone;\n use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv, Ordering};\n use container::Container;\n+use default::Default;\n use fmt;\n+use from_str::FromStr;\n use io::Writer;\n use iter::{Iterator, range, AdditiveIterator};\n+use mem::transmute;\n+use mem;\n use option::{None, Option, Some};\n-use from_str::FromStr;\n-use slice::{ImmutableVector, MutableVector, CloneableVector};\n use slice::Vector;\n-use vec::Vec;\n-use default::Default;\n+use slice::{ImmutableVector, MutableVector, CloneableVector};\n use strbuf::StrBuf;\n+use vec::Vec;\n \n pub use core::str::{from_utf8, CharEq, Chars, CharOffsets, RevChars};\n pub use core::str::{RevCharOffsets, Bytes, RevBytes, CharSplits, RevCharSplits};\n@@ -126,7 +126,7 @@ impl FromStr for ~str {\n /// Fails if invalid UTF-8\n pub fn from_byte(b: u8) -> ~str {\n     assert!(b < 128u8);\n-    unsafe { ::cast::transmute(box [b]) }\n+    unsafe { ::mem::transmute(box [b]) }\n }\n \n /// Convert a char to a string\n@@ -403,7 +403,7 @@ static TAG_CONT_U8: u8 = 128u8;\n /// ```\n pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n     if is_utf8(v) {\n-        return Slice(unsafe { cast::transmute(v) })\n+        return Slice(unsafe { mem::transmute(v) })\n     }\n \n     static REPLACEMENT: &'static [u8] = bytes!(0xEF, 0xBF, 0xBD); // U+FFFD in UTF-8\n@@ -666,8 +666,8 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n \n /// Unsafe operations\n pub mod raw {\n-    use cast;\n     use libc;\n+    use mem;\n     use ptr::RawPtr;\n     use raw::Slice;\n     use slice::CloneableVector;\n@@ -679,9 +679,9 @@ pub mod raw {\n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let v = Slice { data: buf, len: len };\n-        let bytes: &[u8] = ::cast::transmute(v);\n+        let bytes: &[u8] = ::mem::transmute(v);\n         assert!(is_utf8(bytes));\n-        let s: &str = ::cast::transmute(bytes);\n+        let s: &str = ::mem::transmute(bytes);\n         s.to_owned()\n     }\n \n@@ -707,7 +707,7 @@ pub mod raw {\n     /// that the utf-8-ness of the vector has already been validated\n     #[inline]\n     pub unsafe fn from_utf8_owned(v: ~[u8]) -> ~str {\n-        cast::transmute(v)\n+        mem::transmute(v)\n     }\n \n     /// Converts a byte to a string.\n@@ -717,7 +717,7 @@ pub mod raw {\n     /// The caller must preserve the valid UTF-8 property when modifying.\n     #[inline]\n     pub unsafe fn as_owned_vec<'a>(s: &'a mut ~str) -> &'a mut ~[u8] {\n-        cast::transmute(s)\n+        mem::transmute(s)\n     }\n \n     /// Sets the length of a string\n@@ -823,7 +823,7 @@ pub trait StrAllocating: Str {\n         use slice::Vector;\n \n         unsafe {\n-            ::cast::transmute(self.as_slice().as_bytes().to_owned())\n+            ::mem::transmute(self.as_slice().as_bytes().to_owned())\n         }\n     }\n \n@@ -933,7 +933,7 @@ pub trait OwnedStr {\n impl OwnedStr for ~str {\n     #[inline]\n     fn into_bytes(self) -> ~[u8] {\n-        unsafe { cast::transmute(self) }\n+        unsafe { mem::transmute(self) }\n     }\n \n     #[inline]"}, {"sha": "45ab690b0a2be8afa4fbf9ef068e0cffacca3b21", "filename": "src/libstd/strbuf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,12 +11,12 @@\n //! An owned, growable string that enforces that its contents are valid UTF-8.\n \n use c_vec::CVec;\n-use cast;\n use char::Char;\n use container::Container;\n use fmt;\n use io::Writer;\n use iter::{Extendable, FromIterator, Iterator, range};\n+use mem;\n use option::{None, Option, Some};\n use ptr::RawPtr;\n use slice::{OwnedVector, Vector, CloneableVector};\n@@ -265,7 +265,7 @@ impl Str for StrBuf {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         unsafe {\n-            cast::transmute(self.vec.as_slice())\n+            mem::transmute(self.vec.as_slice())\n         }\n     }\n }\n@@ -274,7 +274,7 @@ impl StrAllocating for StrBuf {\n     #[inline]\n     fn into_owned(self) -> ~str {\n         unsafe {\n-            cast::transmute(self.vec.as_slice().to_owned())\n+            mem::transmute(self.vec.as_slice().to_owned())\n         }\n     }\n "}, {"sha": "7dcfe62ffb8a673ff603773ca627b290284bdb62", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -21,10 +21,10 @@\n //! the underlying data will remain valid (not free'd) so long as the reference\n //! count is greater than one.\n \n-use cast;\n use clone::Clone;\n use iter::Iterator;\n use kinds::Send;\n+use mem;\n use ops::Drop;\n use owned::Box;\n use ptr::RawPtr;\n@@ -50,7 +50,7 @@ unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {\n                     count: AtomicUint::new(refcount),\n                     data: Unsafe::new(data)\n                  };\n-    cast::transmute(data)\n+    mem::transmute(data)\n }\n \n impl<T: Send> UnsafeArc<T> {\n@@ -158,7 +158,7 @@ impl<T> Drop for UnsafeArc<T>{\n                 //  happened before), and an \"acquire\" operation before deleting the object.\n                 // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n                 fence(Acquire);\n-                let _: Box<ArcData<T>> = cast::transmute(self.data);\n+                let _: Box<ArcData<T>> = mem::transmute(self.data);\n             }\n         }\n     }"}, {"sha": "6ddae97e901ae1f017ee2773d7654913ea804019", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -108,11 +108,11 @@\n #![allow(missing_doc)]\n \n use intrinsics;\n-use cast;\n-use std::kinds::marker;\n-use option::{Option,Some,None};\n+use mem;\n use ops::Drop;\n+use option::{Option,Some,None};\n use owned::Box;\n+use std::kinds::marker;\n use ty::Unsafe;\n \n /// An atomic boolean type.\n@@ -665,7 +665,7 @@ impl<T> AtomicPtr<T> {\n impl<T> AtomicOption<T> {\n     /// Create a new `AtomicOption`\n     pub fn new(p: Box<T>) -> AtomicOption<T> {\n-        unsafe { AtomicOption { p: Unsafe::new(cast::transmute(p)) } }\n+        unsafe { AtomicOption { p: Unsafe::new(mem::transmute(p)) } }\n     }\n \n     /// Create a new `AtomicOption` that doesn't contain a value\n@@ -675,21 +675,21 @@ impl<T> AtomicOption<T> {\n     #[inline]\n     pub fn swap(&self, val: Box<T>, order: Ordering) -> Option<Box<T>> {\n         unsafe {\n-            let val = cast::transmute(val);\n+            let val = mem::transmute(val);\n \n             let p = atomic_swap(self.p.get(), val, order);\n             if p as uint == 0 {\n                 None\n             } else {\n-                Some(cast::transmute(p))\n+                Some(mem::transmute(p))\n             }\n         }\n     }\n \n     /// Remove the value, leaving the `AtomicOption` empty.\n     #[inline]\n     pub fn take(&self, order: Ordering) -> Option<Box<T>> {\n-        unsafe { self.swap(cast::transmute(0), order) }\n+        unsafe { self.swap(mem::transmute(0), order) }\n     }\n \n     /// Replace an empty value with a non-empty value.\n@@ -700,13 +700,13 @@ impl<T> AtomicOption<T> {\n     #[inline]\n     pub fn fill(&self, val: Box<T>, order: Ordering) -> Option<Box<T>> {\n         unsafe {\n-            let val = cast::transmute(val);\n-            let expected = cast::transmute(0);\n+            let val = mem::transmute(val);\n+            let expected = mem::transmute(0);\n             let oldval = atomic_compare_and_swap(self.p.get(), expected, val, order);\n             if oldval == expected {\n                 None\n             } else {\n-                Some(cast::transmute(val))\n+                Some(mem::transmute(val))\n             }\n         }\n     }"}, {"sha": "175bb03d2620cc7a16de874624474c4b93e7df38", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -48,7 +48,6 @@\n // FIXME: all atomic operations in this module use a SeqCst ordering. That is\n //      probably overkill\n \n-use cast;\n use clone::Clone;\n use iter::{range, Iterator};\n use kinds::Send;\n@@ -57,12 +56,12 @@ use mem;\n use ops::Drop;\n use option::{Option, Some, None};\n use owned::Box;\n-use ptr;\n use ptr::RawPtr;\n+use ptr;\n+use slice::ImmutableVector;\n use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n use unstable::sync::Exclusive;\n-use slice::ImmutableVector;\n use vec::Vec;\n \n // Once the queue is less than 1/K full, then it will be downsized. Note that\n@@ -230,7 +229,7 @@ impl<T: Send> Deque<T> {\n         Deque {\n             bottom: AtomicInt::new(0),\n             top: AtomicInt::new(0),\n-            array: AtomicPtr::new(unsafe { cast::transmute(buf) }),\n+            array: AtomicPtr::new(unsafe { mem::transmute(buf) }),\n             pool: pool,\n         }\n     }\n@@ -272,7 +271,7 @@ impl<T: Send> Deque<T> {\n             return Some(data);\n         } else {\n             self.bottom.store(t + 1, SeqCst);\n-            cast::forget(data); // someone else stole this value\n+            mem::forget(data); // someone else stole this value\n             return None;\n         }\n     }\n@@ -294,7 +293,7 @@ impl<T: Send> Deque<T> {\n         if self.top.compare_and_swap(t, t + 1, SeqCst) == t {\n             Data(data)\n         } else {\n-            cast::forget(data); // someone else stole this value\n+            mem::forget(data); // someone else stole this value\n             Abort\n         }\n     }\n@@ -315,15 +314,15 @@ impl<T: Send> Deque<T> {\n     // continue to be read after we flag this buffer for reclamation.\n     unsafe fn swap_buffer(&mut self, b: int, old: *mut Buffer<T>,\n                           buf: Buffer<T>) -> *mut Buffer<T> {\n-        let newbuf: *mut Buffer<T> = cast::transmute(box buf);\n+        let newbuf: *mut Buffer<T> = mem::transmute(box buf);\n         self.array.store(newbuf, SeqCst);\n         let ss = (*newbuf).size();\n         self.bottom.store(b + ss, SeqCst);\n         let t = self.top.load(SeqCst);\n         if self.top.compare_and_swap(t, t + ss, SeqCst) != t {\n             self.bottom.store(b, SeqCst);\n         }\n-        self.pool.free(cast::transmute(old));\n+        self.pool.free(mem::transmute(old));\n         return newbuf;\n     }\n }\n@@ -340,7 +339,7 @@ impl<T: Send> Drop for Deque<T> {\n         for i in range(t, b) {\n             let _: T = unsafe { (*a).get(i) };\n         }\n-        self.pool.free(unsafe { cast::transmute(a) });\n+        self.pool.free(unsafe { mem::transmute(a) });\n     }\n }\n \n@@ -373,7 +372,7 @@ impl<T: Send> Buffer<T> {\n     unsafe fn put(&mut self, i: int, t: T) {\n         let ptr = self.storage.offset(i & self.mask());\n         ptr::copy_nonoverlapping_memory(ptr as *mut T, &t as *T, 1);\n-        cast::forget(t);\n+        mem::forget(t);\n     }\n \n     // Again, unsafe because this has incredibly dubious ownership violations.\n@@ -400,7 +399,7 @@ mod tests {\n     use prelude::*;\n     use super::{Data, BufferPool, Abort, Empty, Worker, Stealer};\n \n-    use cast;\n+    use mem;\n     use owned::Box;\n     use rt::thread::Thread;\n     use rand;\n@@ -607,7 +606,7 @@ mod tests {\n             let s = s.clone();\n             let unique_box = box AtomicUint::new(0);\n             let thread_box = unsafe {\n-                *cast::transmute::<&Box<AtomicUint>,\n+                *mem::transmute::<&Box<AtomicUint>,\n                                    **mut AtomicUint>(&unique_box)\n             };\n             (Thread::start(proc() {"}, {"sha": "4cdcd05e9b450a4d787108f76a587a77d6e6c186", "filename": "src/libstd/sync/mpsc_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc_queue.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -38,8 +38,8 @@\n // http://www.1024cores.net/home/lock-free-algorithms\n //                         /queues/non-intrusive-mpsc-node-based-queue\n \n-use cast;\n use kinds::Send;\n+use mem;\n use ops::Drop;\n use option::{Option, None, Some};\n use owned::Box;\n@@ -74,7 +74,7 @@ pub struct Queue<T> {\n \n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n-        cast::transmute(box Node {\n+        mem::transmute(box Node {\n             next: AtomicPtr::new(0 as *mut Node<T>),\n             value: v,\n         })\n@@ -121,7 +121,7 @@ impl<T: Send> Queue<T> {\n                 assert!((*tail).value.is_none());\n                 assert!((*next).value.is_some());\n                 let ret = (*next).value.take_unwrap();\n-                let _: Box<Node<T>> = cast::transmute(tail);\n+                let _: Box<Node<T>> = mem::transmute(tail);\n                 return Data(ret);\n             }\n \n@@ -146,7 +146,7 @@ impl<T: Send> Drop for Queue<T> {\n             let mut cur = self.tail;\n             while !cur.is_null() {\n                 let next = (*cur).next.load(Relaxed);\n-                let _: Box<Node<T>> = cast::transmute(cur);\n+                let _: Box<Node<T>> = mem::transmute(cur);\n                 cur = next;\n             }\n         }"}, {"sha": "ed6d690def06aef480e6cba286bf32049bd4af72", "filename": "src/libstd/sync/spsc_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -33,8 +33,8 @@\n //! concurrently between two tasks. This data structure is safe to use and\n //! enforces the semantics that there is one pusher and one popper.\n \n-use cast;\n use kinds::Send;\n+use mem;\n use ops::Drop;\n use option::{Some, None, Option};\n use owned::Box;\n@@ -74,7 +74,7 @@ pub struct Queue<T> {\n impl<T: Send> Node<T> {\n     fn new() -> *mut Node<T> {\n         unsafe {\n-            cast::transmute(box Node {\n+            mem::transmute(box Node {\n                 value: None,\n                 next: AtomicPtr::new(0 as *mut Node<T>),\n             })\n@@ -188,7 +188,7 @@ impl<T: Send> Queue<T> {\n                     (*self.tail_prev.load(Relaxed)).next.store(next, Relaxed);\n                     // We have successfully erased all references to 'tail', so\n                     // now we can safely drop it.\n-                    let _: Box<Node<T>> = cast::transmute(tail);\n+                    let _: Box<Node<T>> = mem::transmute(tail);\n                 }\n             }\n             return ret;\n@@ -216,7 +216,7 @@ impl<T: Send> Drop for Queue<T> {\n             let mut cur = self.first;\n             while !cur.is_null() {\n                 let next = (*cur).next.load(Relaxed);\n-                let _n: Box<Node<T>> = cast::transmute(cur);\n+                let _n: Box<Node<T>> = mem::transmute(cur);\n                 cur = next;\n             }\n         }"}, {"sha": "87d531cc627e093dbc7723749e800086931d2a43", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -17,8 +17,8 @@ A simple wrapper over the platform's dynamic library facilities\n */\n \n use c_str::ToCStr;\n-use cast;\n use iter::Iterator;\n+use mem;\n use ops::*;\n use option::*;\n use os;\n@@ -97,7 +97,7 @@ impl DynamicLibrary {\n         // the destructor does not run.\n         match maybe_symbol_value {\n             Err(err) => Err(err),\n-            Ok(symbol_value) => Ok(cast::transmute(symbol_value))\n+            Ok(symbol_value) => Ok(mem::transmute(symbol_value))\n         }\n     }\n }"}, {"sha": "528ab72762aab904a695541dba25c27fc79e700b", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,23 +10,21 @@\n \n //! An owned, growable vector.\n \n-use cast::{forget, transmute};\n+use RawVec = raw::Vec;\n use clone::Clone;\n use cmp::{Ord, Eq, Ordering, TotalEq, TotalOrd, max};\n use container::{Container, Mutable};\n use default::Default;\n use fmt;\n use iter::{DoubleEndedIterator, FromIterator, Extendable, Iterator, range};\n-use mem::{min_align_of, move_val_init, size_of};\n use mem;\n-use num;\n use num::{CheckedMul, CheckedAdd};\n+use num;\n use ops::{Add, Drop};\n use option::{None, Option, Some, Expect};\n use ptr::RawPtr;\n use ptr;\n use raw::Slice;\n-use RawVec = raw::Vec;\n use rt::heap::{allocate, reallocate, deallocate};\n use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n use slice::{MutableTotalOrdVector, OwnedVector, Vector};\n@@ -91,12 +89,14 @@ impl<T> Vec<T> {\n     /// let vec: Vec<int> = Vec::with_capacity(10);\n     /// ```\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n-        if size_of::<T>() == 0 { return Vec { len: 0, cap: ::uint::MAX, ptr: 0 as *mut T } }\n-        if capacity == 0 {\n+        if mem::size_of::<T>() == 0 {\n+            Vec { len: 0, cap: ::uint::MAX, ptr: 0 as *mut T }\n+        } else if capacity == 0 {\n             Vec::new()\n         } else {\n-            let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n-            let ptr = unsafe { allocate(size, min_align_of::<T>()) };\n+            let size = capacity.checked_mul(&mem::size_of::<T>())\n+                               .expect(\"capacity overflow\");\n+            let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             Vec { len: 0, cap: capacity, ptr: ptr as *mut T }\n         }\n     }\n@@ -117,7 +117,8 @@ impl<T> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n-                move_val_init(xs.as_mut_slice().unsafe_mut_ref(xs.len), op(xs.len));\n+                mem::move_val_init(xs.as_mut_slice().unsafe_mut_ref(xs.len),\n+                                   op(xs.len));\n                 xs.len += 1;\n             }\n             xs\n@@ -133,7 +134,8 @@ impl<T> Vec<T> {\n     /// - there must be `length` valid instances of type `T` at the\n     ///   beginning of that allocation\n     /// - `ptr` must be allocated by the default `Vec` allocator\n-    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut T) -> Vec<T> {\n+    pub unsafe fn from_raw_parts(length: uint, capacity: uint,\n+                                 ptr: *mut T) -> Vec<T> {\n         Vec { len: length, cap: capacity, ptr: ptr }\n     }\n \n@@ -212,7 +214,8 @@ impl<T: Clone> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n-                move_val_init(xs.as_mut_slice().unsafe_mut_ref(xs.len), value.clone());\n+                mem::move_val_init(xs.as_mut_slice().unsafe_mut_ref(xs.len),\n+                                   value.clone());\n                 xs.len += 1;\n             }\n             xs\n@@ -405,16 +408,19 @@ impl<T> Container for Vec<T> {\n #[inline(never)]\n unsafe fn alloc_or_realloc<T>(ptr: *mut T, size: uint, old_size: uint) -> *mut T {\n     if old_size == 0 {\n-        allocate(size, min_align_of::<T>()) as *mut T\n+        allocate(size, mem::min_align_of::<T>()) as *mut T\n     } else {\n-        reallocate(ptr as *mut u8, size, min_align_of::<T>(), old_size) as *mut T\n+        reallocate(ptr as *mut u8, size,\n+                   mem::min_align_of::<T>(), old_size) as *mut T\n     }\n }\n \n #[inline]\n unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n-    if size_of::<T>() != 0 {\n-        deallocate(ptr as *mut u8, len * size_of::<T>(), min_align_of::<T>())\n+    if mem::size_of::<T>() != 0 {\n+        deallocate(ptr as *mut u8,\n+                   len * mem::size_of::<T>(),\n+                   mem::min_align_of::<T>())\n     }\n }\n \n@@ -494,11 +500,14 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec.capacity(), 11);\n     /// ```\n     pub fn reserve_exact(&mut self, capacity: uint) {\n-        if size_of::<T>() == 0 { return }\n+        if mem::size_of::<T>() == 0 { return }\n+\n         if capacity > self.cap {\n-            let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n+            let size = capacity.checked_mul(&mem::size_of::<T>())\n+                               .expect(\"capacity overflow\");\n             unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, size, self.cap * size_of::<T>());\n+                self.ptr = alloc_or_realloc(self.ptr, size,\n+                                            self.cap * mem::size_of::<T>());\n             }\n             self.cap = capacity;\n         }\n@@ -513,7 +522,8 @@ impl<T> Vec<T> {\n     /// vec.shrink_to_fit();\n     /// ```\n     pub fn shrink_to_fit(&mut self) {\n-        if size_of::<T>() == 0 { return }\n+        if mem::size_of::<T>() == 0 { return }\n+\n         if self.len == 0 {\n             if self.cap != 0 {\n                 unsafe {\n@@ -523,9 +533,12 @@ impl<T> Vec<T> {\n             }\n         } else {\n             unsafe {\n-                // Overflow check is unnecessary as the vector is already at least this large.\n-                self.ptr = reallocate(self.ptr as *mut u8, self.len * size_of::<T>(),\n-                                      min_align_of::<T>(), self.cap * size_of::<T>()) as *mut T;\n+                // Overflow check is unnecessary as the vector is already at\n+                // least this large.\n+                self.ptr = reallocate(self.ptr as *mut u8,\n+                                      self.len * mem::size_of::<T>(),\n+                                      mem::min_align_of::<T>(),\n+                                      self.cap * mem::size_of::<T>()) as *mut T;\n             }\n             self.cap = self.len;\n         }\n@@ -568,25 +581,26 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn push(&mut self, value: T) {\n-        if size_of::<T>() == 0 {\n+        if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the address space running out\n             self.len = self.len.checked_add(&1).expect(\"length overflow\");\n-            unsafe { forget(value); }\n+            unsafe { mem::forget(value); }\n             return\n         }\n         if self.len == self.cap {\n-            let old_size = self.cap * size_of::<T>();\n-            let size = max(old_size, 2 * size_of::<T>()) * 2;\n+            let old_size = self.cap * mem::size_of::<T>();\n+            let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n             if old_size > size { fail!(\"capacity overflow\") }\n             unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, size, self.cap * size_of::<T>());\n+                self.ptr = alloc_or_realloc(self.ptr, size,\n+                                            self.cap * mem::size_of::<T>());\n             }\n             self.cap = max(self.cap, 2) * 2;\n         }\n \n         unsafe {\n             let end = (self.ptr as *T).offset(self.len as int) as *mut T;\n-            move_val_init(&mut *end, value);\n+            mem::move_val_init(&mut *end, value);\n             self.len += 1;\n         }\n     }\n@@ -644,7 +658,7 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n-            transmute(Slice { data: self.as_mut_ptr() as *T, len: self.len })\n+            mem::transmute(Slice { data: self.as_mut_ptr() as *T, len: self.len })\n         }\n     }\n \n@@ -664,10 +678,10 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn move_iter(self) -> MoveItems<T> {\n         unsafe {\n-            let iter = transmute(self.as_slice().iter());\n+            let iter = mem::transmute(self.as_slice().iter());\n             let ptr = self.ptr;\n             let cap = self.cap;\n-            forget(self);\n+            mem::forget(self);\n             MoveItems { allocation: ptr, cap: cap, iter: iter }\n         }\n     }\n@@ -949,7 +963,7 @@ impl<T> Vec<T> {\n                 ptr::copy_memory(p.offset(1), &*p, len - index);\n                 // Write it in, overwriting the first copy of the `index`th\n                 // element.\n-                move_val_init(&mut *p, element);\n+                mem::move_val_init(&mut *p, element);\n             }\n             self.set_len(len + 1);\n         }\n@@ -1395,7 +1409,7 @@ impl<T> Vector<T> for Vec<T> {\n     /// ```\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n-        unsafe { transmute(Slice { data: self.as_ptr(), len: self.len }) }\n+        unsafe { mem::transmute(Slice { data: self.as_ptr(), len: self.len }) }\n     }\n }\n \n@@ -1538,7 +1552,7 @@ impl<T> FromVec<T> for ~[T] {\n             // as it still needs to free its own allocation.\n             v.set_len(0);\n \n-            transmute(ret)\n+            mem::transmute(ret)\n         }\n     }\n }"}, {"sha": "4dc965d5d841ca26f7bc70cd7d44a6caf1113a86", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -13,7 +13,7 @@\n  * between tasks.\n  */\n \n-use std::cast;\n+use std::mem;\n use std::ptr;\n use std::rt::heap::exchange_free;\n use std::sync::atomics;\n@@ -76,7 +76,7 @@ impl<T: Share + Send> Arc<T> {\n             weak: atomics::AtomicUint::new(1),\n             data: data,\n         };\n-        Arc { x: unsafe { cast::transmute(x) } }\n+        Arc { x: unsafe { mem::transmute(x) } }\n     }\n \n     #[inline]\n@@ -149,7 +149,7 @@ impl<T: Send + Share + Clone> Arc<T> {\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the Arc itself to be `mut`, so we're returning the only possible\n         // reference to the inner data.\n-        unsafe { cast::transmute::<&_, &mut _>(self.deref()) }\n+        unsafe { mem::transmute::<&_, &mut _>(self.deref()) }\n     }\n }\n "}, {"sha": "acbb2982c90311abe5b0f6fd6c4acf5f623330b7", "filename": "src/libsync/mpsc_intrusive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsync%2Fmpsc_intrusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsync%2Fmpsc_intrusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_intrusive.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -33,7 +33,7 @@\n // http://www.1024cores.net/home/lock-free-algorithms\n //                         /queues/intrusive-mpsc-node-based-queue\n \n-use std::cast;\n+use std::mem;\n use std::sync::atomics;\n use std::ty::Unsafe;\n \n@@ -97,7 +97,7 @@ impl<T: Send> Queue<T> {\n     pub unsafe fn pop(&self) -> Option<*mut Node<T>> {\n         let tail = *self.tail.get();\n         let mut tail = if !tail.is_null() {tail} else {\n-            cast::transmute(&self.stub)\n+            mem::transmute(&self.stub)\n         };\n         let mut next = (*tail).next(atomics::Relaxed);\n         if tail as uint == &self.stub as *DummyNode as uint {\n@@ -116,7 +116,7 @@ impl<T: Send> Queue<T> {\n         if tail != head {\n             return None;\n         }\n-        let stub = cast::transmute(&self.stub);\n+        let stub = mem::transmute(&self.stub);\n         self.push(stub);\n         next = (*tail).next(atomics::Relaxed);\n         if !next.is_null() {\n@@ -135,6 +135,6 @@ impl<T: Send> Node<T> {\n         }\n     }\n     pub unsafe fn next(&self, ord: atomics::Ordering) -> *mut Node<T> {\n-        cast::transmute::<uint, *mut Node<T>>(self.next.load(ord))\n+        mem::transmute::<uint, *mut Node<T>>(self.next.load(ord))\n     }\n }"}, {"sha": "990aba3ebff611605ff9a2983be3faaa58de8735", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -15,9 +15,8 @@\n //! `sync` crate which wrap values directly and provide safer abstractions for\n //! containing data.\n \n-use std::cast;\n use std::kinds::marker;\n-use std::mem::replace;\n+use std::mem;\n use std::sync::atomics;\n use std::unstable::finally::Finally;\n \n@@ -109,7 +108,7 @@ struct SemGuard<'a, Q> {\n impl<Q: Send> Sem<Q> {\n     fn new(count: int, q: Q) -> Sem<Q> {\n         let inner = unsafe {\n-            cast::transmute(box SemInner {\n+            mem::transmute(box SemInner {\n                 waiters: WaitQueue::new(),\n                 count: count,\n                 blocked: q,\n@@ -168,7 +167,7 @@ impl<Q: Send> Sem<Q> {\n impl<Q: Send> Drop for Sem<Q> {\n     fn drop(&mut self) {\n         let _waiters: Box<SemInner<Q>> = unsafe {\n-            cast::transmute(self.inner)\n+            mem::transmute(self.inner)\n         };\n         self.inner = 0 as *();\n     }\n@@ -317,8 +316,8 @@ impl<'a> Condvar<'a> {\n                     // To avoid :broadcast_heavy, we make a new waitqueue,\n                     // swap it out with the old one, and broadcast on the\n                     // old one outside of the little-lock.\n-                    queue = Some(replace(state.blocked.get_mut(condvar_id),\n-                                               WaitQueue::new()));\n+                    queue = Some(mem::replace(state.blocked.get_mut(condvar_id),\n+                                              WaitQueue::new()));\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n@@ -578,7 +577,7 @@ impl<'a> RWLockWriteGuard<'a> {\n         let lock = self.lock;\n         // Don't run the destructor of the write guard, we're in charge of\n         // things from now on\n-        unsafe { cast::forget(self) }\n+        unsafe { mem::forget(self) }\n \n         let old_count = lock.read_count.fetch_add(1, atomics::Release);\n         // If another reader was already blocking, we need to hand-off\n@@ -626,7 +625,7 @@ mod tests {\n     use arc::Arc;\n     use super::{Semaphore, Mutex, RWLock, Condvar};\n \n-    use std::cast;\n+    use std::mem;\n     use std::result;\n     use std::task;\n \n@@ -902,7 +901,7 @@ mod tests {\n             let ptr: *int = &*sharedstate;\n             task::spawn(proc() {\n                 let sharedstate: &mut int =\n-                    unsafe { cast::transmute(ptr) };\n+                    unsafe { mem::transmute(ptr) };\n                 access_shared(sharedstate, &x2, mode1, 10);\n                 tx.send(());\n             });"}, {"sha": "84525718bd95b08b0e34affa7a875c8ecee97b83", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -29,9 +29,9 @@ use visit;\n use visit::Visitor;\n use util::small_vector::SmallVector;\n \n-use std::cast;\n-use std::unstable::dynamic_lib::DynamicLibrary;\n+use std::mem;\n use std::os;\n+use std::unstable::dynamic_lib::DynamicLibrary;\n \n pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n     match e.node {\n@@ -544,7 +544,7 @@ fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can do things that will outlive the expansion\n         // phase (e.g. make an @-box cycle or launch a task).\n-        cast::forget(lib);\n+        mem::forget(lib);\n     }\n }\n "}, {"sha": "f93c3576943ef8252203e1a2834fd7917bdddb4e", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,7 +10,7 @@\n \n use std::default::Default;\n use std::hash::Hash;\n-use std::{cast, mem, raw, ptr, slice};\n+use std::{mem, raw, ptr, slice};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A non-growable owned slice. This would preferably become `~[T]`\n@@ -48,7 +48,7 @@ impl<T> OwnedSlice<T> {\n         } else {\n             let p = v.as_mut_ptr();\n             // we own the allocation now\n-            unsafe {cast::forget(v)}\n+            unsafe {mem::forget(v)}\n \n             OwnedSlice { data: p, len: len }\n         }\n@@ -60,7 +60,7 @@ impl<T> OwnedSlice<T> {\n         unsafe {\n             let ret = Vec::from_raw_parts(self.len, self.len, self.data);\n             // the vector owns the allocation now\n-            cast::forget(self);\n+            mem::forget(self);\n             ret\n         }\n     }\n@@ -74,7 +74,7 @@ impl<T> OwnedSlice<T> {\n             self.data as *T\n         };\n \n-        let slice: &[T] = unsafe {cast::transmute(raw::Slice {\n+        let slice: &[T] = unsafe {mem::transmute(raw::Slice {\n             data: ptr,\n             len: self.len\n         })};"}, {"sha": "3888ed6b8d1d48528523bb32178b44e7e02e29d0", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -17,9 +17,9 @@ use util::interner::{RcStr, StrInterner};\n use util::interner;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n-use std::cast;\n use std::fmt;\n use std::path::BytesContainer;\n+use std::mem;\n use std::rc::Rc;\n use std::strbuf::StrBuf;\n \n@@ -585,7 +585,7 @@ impl BytesContainer for InternedString {\n         // DST.\n         unsafe {\n             let this = self.get();\n-            cast::transmute(this.container_as_bytes())\n+            mem::transmute(this.container_as_bytes())\n         }\n     }\n }"}, {"sha": "71c2f6337e0e6cfd5e7f292115058a963787d6cf", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -26,9 +26,9 @@ use print::pp::{break_offset, word, space, zerobreak, hardbreak};\n use print::pp::{Breaks, Consistent, Inconsistent, eof};\n use print::pp;\n \n-use std::cast;\n use std::io::{IoResult, MemWriter};\n use std::io;\n+use std::mem;\n use std::rc::Rc;\n use std::str;\n use std::strbuf::StrBuf;\n@@ -140,9 +140,9 @@ pub fn to_str(f: |&mut State| -> IoResult<()>) -> StrBuf {\n         // FIXME(pcwalton): A nasty function to extract the string from an `io::Writer`\n         // that we \"know\" to be a `MemWriter` that works around the lack of checked\n         // downcasts.\n-        let (_, wr): (uint, Box<MemWriter>) = cast::transmute_copy(&s.s.out);\n+        let (_, wr): (uint, Box<MemWriter>) = mem::transmute_copy(&s.s.out);\n         let result = str::from_utf8_owned(wr.get_ref().to_owned()).unwrap();\n-        cast::forget(wr);\n+        mem::forget(wr);\n         result.to_strbuf()\n     }\n }"}, {"sha": "c3c9596bfc469f841ea189ebaf195c60b5a738cb", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -15,11 +15,11 @@\n use ast::Name;\n \n use collections::HashMap;\n-use std::cast;\n use std::cell::RefCell;\n use std::cmp::Equiv;\n use std::fmt;\n use std::hash::Hash;\n+use std::mem;\n use std::rc::Rc;\n \n pub struct Interner<T> {\n@@ -198,7 +198,7 @@ impl StrInterner {\n         let vect = self.vect.borrow();\n         let s: &str = vect.get(idx as uint).as_slice();\n         unsafe {\n-            cast::transmute(s)\n+            mem::transmute(s)\n         }\n     }\n "}, {"sha": "25188d699beb4c38b6e3c8686fffc46727eb28c6", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -71,7 +71,7 @@ extern crate test;\n extern crate rand;\n extern crate serialize;\n \n-use std::cast::{transmute,transmute_copy};\n+use std::mem::{transmute,transmute_copy};\n use std::char::Char;\n use std::default::Default;\n use std::fmt;"}, {"sha": "0831993119ae829b2b5c7959a2b3669741767b19", "filename": "src/test/auxiliary/issue_8401.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fauxiliary%2Fissue_8401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fauxiliary%2Fissue_8401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_8401.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,7 +10,7 @@\n \n // for this issue, this code must be built in a library\n \n-use std::cast;\n+use std::mem;\n \n trait A {}\n struct B;\n@@ -20,6 +20,6 @@ fn bar<T>(_: &mut A, _: &T) {}\n \n fn foo<T>(t: &T) {\n     let b = B;\n-    bar(unsafe { cast::transmute(&b as &A) }, t)\n+    bar(unsafe { mem::transmute(&b as &A) }, t)\n }\n "}, {"sha": "d9fbc08b3211dd39a9d5ad6bb15100ac2d8603c4", "filename": "src/test/compile-fail/coerce-unsafe-to-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    let x: Option<&[u8]> = Some(\"foo\").map(std::cast::transmute);\n+    let x: Option<&[u8]> = Some(\"foo\").map(std::mem::transmute);\n     //~^ ERROR: mismatched types\n }"}, {"sha": "4e0131a580128349e4f50450ff15f63c97cead87", "filename": "src/test/compile-fail/issue-6458-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n+use std::mem;\n \n fn main() {\n-    cast::transmute(0);  //~ ERROR: cannot determine a type for this expression: unconstrained type\n+    mem::transmute(0);  //~ ERROR: cannot determine a type for this expression: unconstrained type\n }"}, {"sha": "45e6b76e200386aa2f9ad3df2f044e101e6d77c7", "filename": "src/test/compile-fail/packed-struct-generic-transmute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -15,7 +15,7 @@\n \n // error-pattern: transmute called on types with different size\n \n-use std::cast;\n+use std::mem;\n \n #[packed]\n struct Foo<T,S> {\n@@ -31,7 +31,7 @@ struct Oof<T, S> {\n fn main() {\n     let foo = Foo { bar: [1u8, 2, 3, 4, 5], baz: 10i32 };\n     unsafe {\n-        let oof: Oof<[u8, .. 5], i32> = cast::transmute(foo);\n+        let oof: Oof<[u8, .. 5], i32> = mem::transmute(foo);\n         println!(\"{:?}\", oof);\n     }\n }"}, {"sha": "24be7d3a2972f8d9113a4adb4a01616c570fd6ae", "filename": "src/test/compile-fail/packed-struct-transmute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -15,7 +15,7 @@\n \n // error-pattern: transmute called on types with different size\n \n-use std::cast;\n+use std::mem;\n \n #[packed]\n struct Foo {\n@@ -31,7 +31,7 @@ struct Oof {\n fn main() {\n     let foo = Foo { bar: 1, baz: 10 };\n     unsafe {\n-        let oof: Oof = cast::transmute(foo);\n+        let oof: Oof = mem::transmute(foo);\n         println!(\"{:?}\", oof);\n     }\n }"}, {"sha": "43d82e75c4dda0e516d160ce0f040702fe46390f", "filename": "src/test/debuginfo/nil-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -32,8 +32,8 @@ enum AnotherNilEnum {}\n // 2. That gdb prints the string \"{<No data fields>}\" for empty structs (which may change some time)\n fn main() {\n     unsafe {\n-        let first: ANilEnum = std::cast::transmute(());\n-        let second: AnotherNilEnum = std::cast::transmute(());\n+        let first: ANilEnum = std::mem::transmute(());\n+        let second: AnotherNilEnum = std::mem::transmute(());\n \n         zzz();\n     }"}, {"sha": "5c44703f6f2c90b712d394a3a5aaa115b1527903", "filename": "src/test/debuginfo/option-like-enum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -69,21 +69,21 @@ struct NamedFieldsRepr<'a> {\n \n fn main() {\n \n-    let some: Option<&u32> = Some(unsafe { std::cast::transmute(0x12345678) });\n+    let some: Option<&u32> = Some(unsafe { std::mem::transmute(0x12345678) });\n     let none: Option<&u32> = None;\n \n-    let full = Full(454545, unsafe { std::cast::transmute(0x87654321) }, 9988);\n+    let full = Full(454545, unsafe { std::mem::transmute(0x87654321) }, 9988);\n \n     let int_val = 0;\n-    let empty: &MoreFieldsRepr = unsafe { std::cast::transmute(&Empty) };\n+    let empty: &MoreFieldsRepr = unsafe { std::mem::transmute(&Empty) };\n \n     let droid = Droid {\n         id: 675675,\n         range: 10000001,\n-        internals: unsafe { std::cast::transmute(0x43218765) }\n+        internals: unsafe { std::mem::transmute(0x43218765) }\n     };\n \n-    let void_droid: &NamedFieldsRepr = unsafe { std::cast::transmute(&Void) };\n+    let void_droid: &NamedFieldsRepr = unsafe { std::mem::transmute(&Void) };\n \n     zzz();\n }"}, {"sha": "2044d6f1cc815c5083034c06eba31bf33ce3a041", "filename": "src/test/run-fail/unwind-box-res.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-res.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(managed_boxes)]\n \n-use std::cast;\n+use std::mem;\n \n fn failfn() {\n     fail!();\n@@ -25,7 +25,7 @@ struct r {\n impl Drop for r {\n     fn drop(&mut self) {\n         unsafe {\n-            let _v2: Box<int> = cast::transmute(self.v);\n+            let _v2: Box<int> = mem::transmute(self.v);\n         }\n     }\n }\n@@ -39,8 +39,8 @@ fn r(v: *int) -> r {\n fn main() {\n     unsafe {\n         let i1 = box 0;\n-        let i1p = cast::transmute_copy(&i1);\n-        cast::forget(i1);\n+        let i1p = mem::transmute_copy(&i1);\n+        mem::forget(i1);\n         let x = @r(i1p);\n         failfn();\n         println!(\"{:?}\", x);"}, {"sha": "d60cc05cc9f9cbeca66d87eb58550a75ac635c56", "filename": "src/test/run-make/mixing-deps/dylib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-make%2Fmixing-deps%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-make%2Fmixing-deps%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmixing-deps%2Fdylib.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,6 +11,6 @@\n #![crate_type = \"dylib\"]\n extern crate both;\n \n-use std::cast;\n+use std::mem;\n \n-pub fn addr() -> uint { unsafe { cast::transmute(&both::foo) } }\n+pub fn addr() -> uint { unsafe { mem::transmute(&both::foo) } }"}, {"sha": "8006987e9f349152d125f7aa4e651ce3ec74f659", "filename": "src/test/run-make/mixing-deps/prog.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-make%2Fmixing-deps%2Fprog.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-make%2Fmixing-deps%2Fprog.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmixing-deps%2Fprog.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,9 +11,9 @@\n extern crate dylib;\n extern crate both;\n \n-use std::cast;\n+use std::mem;\n \n fn main() {\n-    assert_eq!(unsafe { cast::transmute::<&int, uint>(&both::foo) },\n+    assert_eq!(unsafe { mem::transmute::<&int, uint>(&both::foo) },\n                dylib::addr());\n }"}, {"sha": "331e947586ab8fa160cc6a96f08be5d294020bb5", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -48,9 +48,9 @@ fn test_box() {\n \n fn test_ptr() {\n     unsafe {\n-        let p1: *u8 = ::std::cast::transmute(0);\n-        let p2: *u8 = ::std::cast::transmute(0);\n-        let p3: *u8 = ::std::cast::transmute(1);\n+        let p1: *u8 = ::std::mem::transmute(0);\n+        let p2: *u8 = ::std::mem::transmute(0);\n+        let p3: *u8 = ::std::mem::transmute(1);\n \n         assert_eq!(p1, p2);\n         assert!(p1 != p3);\n@@ -82,8 +82,8 @@ fn test_class() {\n \n   unsafe {\n   println!(\"q = {:x}, r = {:x}\",\n-         (::std::cast::transmute::<*p, uint>(&q)),\n-         (::std::cast::transmute::<*p, uint>(&r)));\n+         (::std::mem::transmute::<*p, uint>(&q)),\n+         (::std::mem::transmute::<*p, uint>(&r)));\n   }\n   assert_eq!(q, r);\n   r.y = 17;"}, {"sha": "202ec7edb1939e30745c076746806dd3ff73543e", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,7 +11,7 @@\n /* Any copyright is dedicated to the Public Domain.\n  * http://creativecommons.org/publicdomain/zero/1.0/ */\n \n-use std::cast;\n+use std::mem;\n use std::io::stdio::println;\n \n fn call_it(f: proc(~str) -> ~str) {\n@@ -74,7 +74,7 @@ pub fn main() {\n \n     call_cramped(|| 1, || unsafe {\n         static a: uint = 100;\n-        cast::transmute(&a)\n+        mem::transmute(&a)\n     });\n \n     // External functions"}, {"sha": "2a8293fcba8d0ec5e2e15790209c9d4b148cfe43", "filename": "src/test/run-pass/enum-alignment.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-alignment.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n use std::mem;\n \n fn addr_of<T>(ptr: &T) -> uint {\n@@ -17,7 +16,7 @@ fn addr_of<T>(ptr: &T) -> uint {\n \n fn is_aligned<T>(ptr: &T) -> bool {\n     unsafe {\n-        let addr: uint = cast::transmute(ptr);\n+        let addr: uint = mem::transmute(ptr);\n         (addr % mem::min_align_of::<T>()) == 0\n     }\n }"}, {"sha": "41e5381d73c2b727e1fd7939812a8a57b47845ad", "filename": "src/test/run-pass/enum-clike-ffi-as-int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fenum-clike-ffi-as-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fenum-clike-ffi-as-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-clike-ffi-as-int.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -33,7 +33,7 @@ extern \"C\" fn foo(_x: uint) -> Foo { B }\n \n pub fn main() {\n   unsafe {\n-    let f: extern \"C\" fn(uint) -> u32 = ::std::cast::transmute(foo);\n+    let f: extern \"C\" fn(uint) -> u32 = ::std::mem::transmute(foo);\n     assert_eq!(f(0xDEADBEEF), B as u32);\n   }\n }"}, {"sha": "b56847b2da0d61b5b779136f71445640ae19f137", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,7 +10,7 @@\n \n extern crate libc;\n \n-use std::cast;\n+use std::mem;\n use std::unstable::run_in_bare_thread;\n \n #[link(name = \"rustrt\")]\n@@ -23,14 +23,14 @@ pub fn main() {\n     unsafe {\n         run_in_bare_thread(proc() {\n             let i = &100;\n-            rust_dbg_call(callback, cast::transmute(i));\n+            rust_dbg_call(callback, mem::transmute(i));\n         });\n     }\n }\n \n extern fn callback(data: libc::uintptr_t) {\n     unsafe {\n-        let data: *int = cast::transmute(data);\n+        let data: *int = mem::transmute(data);\n         assert_eq!(*data, 100);\n     }\n }"}, {"sha": "1ac3602293807ddc614bad706c0dca91ca034952", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -149,7 +149,7 @@ pub fn main() {\n     // make sure that format! doesn't cause spurious unused-unsafe warnings when\n     // it's inside of an outer unsafe block\n     unsafe {\n-        let a: int = ::std::cast::transmute(3u);\n+        let a: int = ::std::mem::transmute(3u);\n         format!(\"{}\", a);\n     }\n "}, {"sha": "752c9464cf62008776c05801e3661fdecb84e023", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast::transmute;\n+use std::mem::transmute;\n \n mod rusti {\n     extern \"rust-intrinsic\" {"}, {"sha": "a319ee5e600cc5046bafbcb2252279a32377f810", "filename": "src/test/run-pass/issue-2214.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,12 +11,12 @@\n \n extern crate libc;\n \n-use std::cast;\n+use std::mem;\n use libc::{c_double, c_int};\n \n fn to_c_int(v: &mut int) -> &mut c_int {\n     unsafe {\n-        cast::transmute_copy(&v)\n+        mem::transmute_copy(&v)\n     }\n }\n "}, {"sha": "9636a61269cae710cae2c9f11c1f5b09e45b5973", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -14,9 +14,9 @@ pub type Task = int;\n // tjc: I don't know why\n pub mod pipes {\n     use super::Task;\n-    use std::cast::{forget, transmute};\n-    use std::cast;\n+    use std::mem::{forget, transmute};\n     use std::mem::{replace, swap};\n+    use std::mem;\n     use std::task;\n \n     pub struct Stuff<T> {\n@@ -42,7 +42,7 @@ pub mod pipes {\n \n     pub fn packet<T:Send>() -> *packet<T> {\n         unsafe {\n-            let p: *packet<T> = cast::transmute(box Stuff{\n+            let p: *packet<T> = mem::transmute(box Stuff{\n                 state: empty,\n                 blocked_task: None::<Task>,\n                 payload: None::<T>\n@@ -60,7 +60,7 @@ pub mod pipes {\n     // We should consider moving this to ::std::unsafe, although I\n     // suspect graydon would want us to use void pointers instead.\n     pub unsafe fn uniquify<T>(x: *T) -> Box<T> {\n-        cast::transmute(x)\n+        mem::transmute(x)\n     }\n \n     pub fn swap_state_acq(dst: &mut state, src: state) -> state {\n@@ -165,7 +165,7 @@ pub mod pipes {\n             unsafe {\n                 if self.p != None {\n                     let self_p: &mut Option<*packet<T>> =\n-                        cast::transmute(&self.p);\n+                        mem::transmute(&self.p);\n                     let p = replace(self_p, None);\n                     sender_terminate(p.unwrap())\n                 }\n@@ -195,7 +195,7 @@ pub mod pipes {\n             unsafe {\n                 if self.p != None {\n                     let self_p: &mut Option<*packet<T>> =\n-                        cast::transmute(&self.p);\n+                        mem::transmute(&self.p);\n                     let p = replace(self_p, None);\n                     receiver_terminate(p.unwrap())\n                 }\n@@ -222,15 +222,15 @@ pub mod pipes {\n }\n \n pub mod pingpong {\n-    use std::cast;\n+    use std::mem;\n \n     pub struct ping(::pipes::send_packet<pong>);\n     pub struct pong(::pipes::send_packet<ping>);\n \n     pub fn liberate_ping(p: ping) -> ::pipes::send_packet<pong> {\n         unsafe {\n             let _addr : *::pipes::send_packet<pong> = match &p {\n-              &ping(ref x) => { cast::transmute(x) }\n+              &ping(ref x) => { mem::transmute(x) }\n             };\n             fail!()\n         }\n@@ -239,7 +239,7 @@ pub mod pingpong {\n     pub fn liberate_pong(p: pong) -> ::pipes::send_packet<ping> {\n         unsafe {\n             let _addr : *::pipes::send_packet<ping> = match &p {\n-              &pong(ref x) => { cast::transmute(x) }\n+              &pong(ref x) => { mem::transmute(x) }\n             };\n             fail!()\n         }"}, {"sha": "d96568df63a4dd57293ad9d85de76fac2a86ac10", "filename": "src/test/run-pass/issue-4735.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fissue-4735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fissue-4735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4735.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -12,7 +12,7 @@\n \n extern crate libc;\n \n-use std::cast::transmute;\n+use std::mem::transmute;\n use libc::c_void;\n \n struct NonCopyable(*c_void);"}, {"sha": "fb61bea83da8d7e5c1521914e2e8a45d39b10c06", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(macro_rules)]\n \n-use std::{option, cast};\n+use std::{option, mem};\n \n // Iota-reduction is a rule in the Calculus of (Co-)Inductive Constructions,\n // which \"says that a destructor applied to an object built from a constructor\n@@ -78,8 +78,8 @@ pub fn main() {\n     check_type!(@19: @int);\n     check_type!(\"foo\".to_owned(): ~str);\n     check_type!(vec!(20, 22): Vec<int> );\n-    let mint: uint = unsafe { cast::transmute(main) };\n+    let mint: uint = unsafe { mem::transmute(main) };\n     check_type!(main: fn(), |pthing| {\n-        assert!(mint == unsafe { cast::transmute(*pthing) })\n+        assert!(mint == unsafe { mem::transmute(*pthing) })\n     });\n }"}, {"sha": "202697661582f75058b5dd1840c5fc69c9f86a8f", "filename": "src/test/run-pass/packed-struct-generic-layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n+use std::mem;\n \n #[packed]\n struct S<T, S> {\n@@ -20,7 +20,7 @@ struct S<T, S> {\n pub fn main() {\n     unsafe {\n         let s = S { a: 0xff_ff_ff_ffu32, b: 1, c: 0xaa_aa_aa_aa as i32 };\n-        let transd : [u8, .. 9] = cast::transmute(s);\n+        let transd : [u8, .. 9] = mem::transmute(s);\n         // Don't worry about endianness, the numbers are palindromic.\n         assert!(transd ==\n                    [0xff, 0xff, 0xff, 0xff,\n@@ -29,7 +29,7 @@ pub fn main() {\n \n \n         let s = S { a: 1u8, b: 2u8, c: 0b10000001_10000001 as i16};\n-        let transd : [u8, .. 4] = cast::transmute(s);\n+        let transd : [u8, .. 4] = mem::transmute(s);\n         // Again, no endianness problems.\n         assert!(transd ==\n                    [1, 2, 0b10000001, 0b10000001]);"}, {"sha": "7f9bf8e7d57fe458602f22e9a1b63d2aeffd6c57", "filename": "src/test/run-pass/packed-struct-layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n+use std::mem;\n \n #[packed]\n struct S4 {\n@@ -25,11 +25,11 @@ struct S5 {\n pub fn main() {\n     unsafe {\n         let s4 = S4 { a: 1, b: [2,3,4] };\n-        let transd : [u8, .. 4] = cast::transmute(s4);\n+        let transd : [u8, .. 4] = mem::transmute(s4);\n         assert!(transd == [1, 2, 3, 4]);\n \n         let s5 = S5 { a: 1, b: 0xff_00_00_ff };\n-        let transd : [u8, .. 5] = cast::transmute(s5);\n+        let transd : [u8, .. 5] = mem::transmute(s5);\n         // Don't worry about endianness, the u32 is palindromic.\n         assert!(transd == [1, 0xff, 0, 0, 0xff]);\n     }"}, {"sha": "3ec6182beb2615ab0dca92c94e10c75824b36108", "filename": "src/test/run-pass/packed-tuple-struct-layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n+use std::mem;\n \n #[packed]\n struct S4(u8,[u8, .. 3]);\n@@ -19,11 +19,11 @@ struct S5(u8,u32);\n pub fn main() {\n     unsafe {\n         let s4 = S4(1, [2,3,4]);\n-        let transd : [u8, .. 4] = cast::transmute(s4);\n+        let transd : [u8, .. 4] = mem::transmute(s4);\n         assert!(transd == [1, 2, 3, 4]);\n \n         let s5 = S5(1, 0xff_00_00_ff);\n-        let transd : [u8, .. 5] = cast::transmute(s5);\n+        let transd : [u8, .. 5] = mem::transmute(s5);\n         // Don't worry about endianness, the u32 is palindromic.\n         assert!(transd == [1, 0xff, 0, 0, 0xff]);\n     }"}, {"sha": "26bf06794ca0c215f4a67d5b30af8ac3a73c0fcc", "filename": "src/test/run-pass/pub-extern-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast::transmute;\n+use std::mem::transmute;\n \n mod a {\n     extern {"}, {"sha": "7e071177ff9f1241246467a9bdf24113559a4888", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -21,7 +21,6 @@ extern crate libc;\n \n use arena::Arena;\n use collections::HashMap;\n-use std::cast;\n use std::mem;\n \n type Type<'tcx> = &'tcx TypeStructure<'tcx>;"}, {"sha": "e6b997f758814475e30f21cc634ea1d7e782e048", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n extern crate libc;\n-use std::cast;\n use std::mem;\n \n struct arena(());\n@@ -29,7 +28,7 @@ struct Ccx {\n \n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n-        cast::transmute(libc::malloc(mem::size_of::<Bcx<'a>>()\n+        mem::transmute(libc::malloc(mem::size_of::<Bcx<'a>>()\n             as libc::size_t))\n     }\n }\n@@ -42,7 +41,7 @@ fn g(fcx : &Fcx) {\n     let bcx = Bcx { fcx: fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n-        libc::free(cast::transmute(bcx2));\n+        libc::free(mem::transmute(bcx2));\n     }\n }\n "}, {"sha": "a260ad66ce294c6bd4b0da36ae4552ef4119877b", "filename": "src/test/run-pass/tag-align-dyn-u64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,7 +11,7 @@\n // ignore-linux #7340 fails on 32-bit linux\n // ignore-macos #7340 fails on 32-bit macos\n \n-use std::cast;\n+use std::mem;\n \n enum Tag<A> {\n     Tag(A)\n@@ -27,7 +27,7 @@ fn mk_rec() -> Rec {\n }\n \n fn is_8_byte_aligned(u: &Tag<u64>) -> bool {\n-    let p: uint = unsafe { cast::transmute(u) };\n+    let p: uint = unsafe { mem::transmute(u) };\n     return (p & 7u) == 0u;\n }\n "}, {"sha": "1e22f0f3dee80d6a4fa6d303a7451152a1a28f6d", "filename": "src/test/run-pass/tag-align-dyn-variants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,7 +11,7 @@\n // ignore-linux #7340 fails on 32-bit linux\n // ignore-macos #7340 fails on 32-bit macos\n \n-use std::cast;\n+use std::mem;\n \n enum Tag<A,B> {\n     VarA(A),\n@@ -30,7 +30,7 @@ fn mk_rec<A,B>(a: A, b: B) -> Rec<A,B> {\n }\n \n fn is_aligned<A>(amnt: uint, u: &A) -> bool {\n-    let p: uint = unsafe { cast::transmute(u) };\n+    let p: uint = unsafe { mem::transmute(u) };\n     return (p & (amnt-1u)) == 0u;\n }\n "}, {"sha": "f3996065936554e743c313536083853b36bdddbf", "filename": "src/test/run-pass/tag-align-u64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -11,7 +11,7 @@\n // ignore-linux #7340 fails on 32-bit linux\n // ignore-macos #7340 fails on 32-bit macos\n \n-use std::cast;\n+use std::mem;\n \n enum Tag {\n     Tag(u64)\n@@ -27,7 +27,7 @@ fn mk_rec() -> Rec {\n }\n \n fn is_8_byte_aligned(u: &Tag) -> bool {\n-    let p: uint = unsafe { cast::transmute(u) };\n+    let p: uint = unsafe { mem::transmute(u) };\n     return (p & 7u) == 0u;\n }\n "}, {"sha": "e070757eaf4ea1b2f04a40d7bb65db50809b5680", "filename": "src/test/run-pass/transmute-non-immediate-to-immediate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Ftransmute-non-immediate-to-immediate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Ftransmute-non-immediate-to-immediate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftransmute-non-immediate-to-immediate.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -13,6 +13,6 @@\n \n pub fn main() {\n     unsafe {\n-        ::std::cast::transmute::<[int,..1],int>([1])\n+        ::std::mem::transmute::<[int,..1],int>([1])\n     };\n }"}, {"sha": "7f46b0ff6e797983bf5afa172c40523d48cda5a0", "filename": "src/test/run-pass/unify-return-ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb569fd3986247ac3ce6a498e52a82bb4c535824/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funify-return-ty.rs?ref=fb569fd3986247ac3ce6a498e52a82bb4c535824", "patch": "@@ -12,11 +12,11 @@\n // unified with the type *T, and so the type variable\n // in that type gets resolved.\n \n-use std::cast;\n+use std::mem;\n \n fn null<T>() -> *T {\n     unsafe {\n-        cast::transmute(0)\n+        mem::transmute(0)\n     }\n }\n "}]}