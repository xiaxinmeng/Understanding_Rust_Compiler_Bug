{"sha": "dba3ddd8d4e037db390f54536b4cb77ea988eab1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYTNkZGQ4ZDRlMDM3ZGIzOTBmNTQ1MzZiNGNiNzdlYTk4OGVhYjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-12T16:32:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-17T16:41:43Z"}, "message": "rustc: Calculate `ExportedSymbols` in a query\n\nThis commit moves the definition of the `ExportedSymbols` structure to the\n`rustc` crate and then creates a query that'll be used to construct the\n`ExportedSymbols` set. This in turn uses the reachablity query exposed in the\nprevious commit.", "tree": {"sha": "81494aa8aee2bc7fa67f317c1be97a696a35443d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81494aa8aee2bc7fa67f317c1be97a696a35443d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dba3ddd8d4e037db390f54536b4cb77ea988eab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dba3ddd8d4e037db390f54536b4cb77ea988eab1", "html_url": "https://github.com/rust-lang/rust/commit/dba3ddd8d4e037db390f54536b4cb77ea988eab1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dba3ddd8d4e037db390f54536b4cb77ea988eab1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baca9a6240115996d35336f5bb7d78e60babd722", "url": "https://api.github.com/repos/rust-lang/rust/commits/baca9a6240115996d35336f5bb7d78e60babd722", "html_url": "https://github.com/rust-lang/rust/commit/baca9a6240115996d35336f5bb7d78e60babd722"}], "stats": {"total": 481, "additions": 266, "deletions": 215}, "files": [{"sha": "757a256164e08fac495d67222e66f4016d4ae4b1", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -535,7 +535,7 @@ define_dep_nodes!( <'tcx>\n     [] GetPanicStrategy(CrateNum),\n     [] IsNoBuiltins(CrateNum),\n     [] ImplDefaultness(DefId),\n-    [] ExportedSymbols(CrateNum),\n+    [] ExportedSymbolIds(CrateNum),\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),\n     [] DeriveRegistrarFn(CrateNum),\n@@ -575,6 +575,7 @@ define_dep_nodes!( <'tcx>\n     [] MaybeUnusedExternCrates,\n     [] StabilityIndex,\n     [] AllCrateNums,\n+    [] ExportedSymbols,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "59edc9fb083aca79445f3812edeb79dc5e73aabe", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -92,6 +92,7 @@ pub mod middle {\n     pub mod dependency_format;\n     pub mod effect;\n     pub mod entry;\n+    pub mod exported_symbols;\n     pub mod free_region;\n     pub mod intrinsicck;\n     pub mod lang_items;"}, {"sha": "7f03f8a5a29860d91108a0eb089d6e4cead4096a", "filename": "src/librustc/middle/exported_symbols.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use util::nodemap::{FxHashMap, NodeSet};\n+use hir::def_id::{DefId, CrateNum};\n+\n+/// The SymbolExportLevel of a symbols specifies from which kinds of crates\n+/// the symbol will be exported. `C` symbols will be exported from any\n+/// kind of crate, including cdylibs which export very few things.\n+/// `Rust` will only be exported if the crate produced is a Rust\n+/// dylib.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum SymbolExportLevel {\n+    C,\n+    Rust,\n+}\n+\n+/// The set of symbols exported from each crate in the crate graph.\n+#[derive(Debug)]\n+pub struct ExportedSymbols {\n+    pub export_threshold: SymbolExportLevel,\n+    exports: FxHashMap<CrateNum, Vec<(String, DefId, SymbolExportLevel)>>,\n+    local_exports: NodeSet,\n+}\n+\n+impl ExportedSymbols {\n+    pub fn new(export_threshold: SymbolExportLevel,\n+               exports: FxHashMap<CrateNum, Vec<(String, DefId, SymbolExportLevel)>>,\n+               local_exports: NodeSet) -> ExportedSymbols {\n+        ExportedSymbols {\n+            export_threshold,\n+            exports,\n+            local_exports,\n+        }\n+    }\n+\n+    pub fn local_exports(&self) -> &NodeSet {\n+        &self.local_exports\n+    }\n+\n+    pub fn exported_symbols(&self, cnum: CrateNum)\n+        -> &[(String, DefId, SymbolExportLevel)]\n+    {\n+        match self.exports.get(&cnum) {\n+            Some(exports) => exports,\n+            None => &[]\n+        }\n+    }\n+\n+    pub fn for_each_exported_symbol<F>(&self, cnum: CrateNum, mut f: F)\n+        where F: FnMut(&str, DefId, SymbolExportLevel)\n+    {\n+        for &(ref name, def_id, export_level) in self.exported_symbols(cnum) {\n+            if is_below_threshold(export_level, self.export_threshold) {\n+                f(&name, def_id, export_level)\n+            }\n+        }\n+    }\n+}\n+\n+pub fn is_below_threshold(level: SymbolExportLevel,\n+                          threshold: SymbolExportLevel)\n+                          -> bool {\n+    if threshold == SymbolExportLevel::Rust {\n+        // We export everything from Rust dylibs\n+        true\n+    } else {\n+        level == SymbolExportLevel::C\n+    }\n+}"}, {"sha": "af5c37e0f1605d59655abc5877f7810463f4bb4c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -27,6 +27,7 @@ use middle::cstore::EncodedMetadata;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n+use middle::exported_symbols::ExportedSymbols;\n use middle::stability;\n use mir::Mir;\n use mir::transform::Passes;\n@@ -64,6 +65,7 @@ use std::mem;\n use std::ops::Deref;\n use std::iter;\n use std::rc::Rc;\n+use std::sync::Arc;\n use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n@@ -1218,6 +1220,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Rc<Any> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n+\n+    pub fn exported_symbols(self) -> Arc<ExportedSymbols> {\n+        self.exported_symbol_set(LOCAL_CRATE)\n+    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "2d3dc6cd65bf8be33d864f1b129cf9d5b4d23ecd", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -23,6 +23,7 @@ use middle::region;\n use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n+use middle::exported_symbols::ExportedSymbols;\n use mir;\n use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n@@ -48,6 +49,7 @@ use std::mem;\n use std::collections::BTreeMap;\n use std::ops::Deref;\n use std::rc::Rc;\n+use std::sync::Arc;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::attr;\n use syntax::ast;\n@@ -595,7 +597,7 @@ impl<'tcx> QueryDescription for queries::is_sanitizer_runtime<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n+impl<'tcx> QueryDescription for queries::exported_symbol_ids<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the exported symbols of a crate\")\n     }\n@@ -745,6 +747,12 @@ impl<'tcx> QueryDescription for queries::all_crate_nums<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::exported_symbol_set<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"exported symbol set\")\n+    }\n+}\n+\n // If enabled, send a message to the profile-queries thread\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n@@ -1322,7 +1330,7 @@ define_maps! { <'tcx>\n     [] fn lint_levels: lint_levels_node(CrateNum) -> Rc<lint::LintLevelMap>,\n \n     [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n-    [] fn exported_symbols: ExportedSymbols(CrateNum) -> Rc<Vec<DefId>>,\n+    [] fn exported_symbol_ids: ExportedSymbolIds(CrateNum) -> Rc<Vec<DefId>>,\n     [] fn native_libraries: NativeLibraries(CrateNum) -> Rc<Vec<NativeLibrary>>,\n     [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n@@ -1371,6 +1379,9 @@ define_maps! { <'tcx>\n \n     [] fn stability_index: stability_index_node(CrateNum) -> Rc<stability::Index<'tcx>>,\n     [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n+\n+    [] fn exported_symbol_set: exported_symbol_set_node(CrateNum)\n+        -> Arc<ExportedSymbols>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n@@ -1484,3 +1495,7 @@ fn stability_index_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n fn all_crate_nums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::AllCrateNums\n }\n+\n+fn exported_symbol_set_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::ExportedSymbols\n+}"}, {"sha": "9f7cb06488ddec322299ad9b55eb515785ea97dc", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -956,7 +956,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     mir::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n-    trans::provide(&mut local_providers);\n+    trans::provide_local(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n     traits::provide(&mut local_providers);\n@@ -968,7 +968,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n-    trans::provide(&mut extern_providers);\n+    trans::provide_extern(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n     traits::provide_extern(&mut extern_providers);\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri."}, {"sha": "3a116160bcab2daa3ea734b444a15616f098bc7d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -175,7 +175,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     extern_crate => { Rc::new(cdata.extern_crate.get()) }\n     is_no_builtins => { cdata.is_no_builtins() }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n-    exported_symbols => { Rc::new(cdata.get_exported_symbols()) }\n+    exported_symbol_ids => { Rc::new(cdata.get_exported_symbols()) }\n     native_libraries => { Rc::new(cdata.get_native_libraries()) }\n     plugin_registrar_fn => {\n         cdata.root.plugin_registrar_fn.map(|index| {"}, {"sha": "ec436bcb241b00fef5c683fe327536707b53611e", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -19,8 +19,8 @@ use context::SharedCrateContext;\n \n use back::archive;\n use back::command::Command;\n-use back::symbol_export::ExportedSymbols;\n use rustc::middle::dependency_format::Linkage;\n+use rustc::middle::exported_symbols::ExportedSymbols;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n use rustc_back::LinkerFlavor;\n use rustc::session::Session;"}, {"sha": "125b07a9505b193754b5583733bba9f3a0755643", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -16,6 +16,7 @@ use errors::{FatalError, Handler};\n use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n+use rustc::middle::exported_symbols;\n use rustc::util::common::time;\n use rustc::util::common::path2cstr;\n use rustc::hir::def_id::LOCAL_CRATE;\n@@ -68,7 +69,7 @@ pub fn run(cgcx: &CodegenContext,\n         symbol_export::crates_export_threshold(&cgcx.crate_types);\n \n     let symbol_filter = &|&(ref name, _, level): &(String, _, _)| {\n-        if symbol_export::is_below_threshold(level, export_threshold) {\n+        if exported_symbols::is_below_threshold(level, export_threshold) {\n             let mut bytes = Vec::with_capacity(name.len() + 1);\n             bytes.extend(name.bytes());\n             Some(CString::new(bytes).unwrap())"}, {"sha": "b47d6f8ac2d70e5f0bef293b3cf49f53fc280d7c", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 115, "deletions": 182, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -8,199 +8,143 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use base;\n use monomorphize::Instance;\n use rustc::util::nodemap::{FxHashMap, NodeSet};\n-use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE, INVALID_CRATE, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE, INVALID_CRATE, CRATE_DEF_INDEX};\n use rustc::session::config;\n use rustc::ty::TyCtxt;\n use rustc_allocator::ALLOCATOR_METHODS;\n+use rustc::middle::exported_symbols::{ExportedSymbols, SymbolExportLevel};\n+use rustc::middle::exported_symbols::is_below_threshold;\n use syntax::attr;\n \n-/// The SymbolExportLevel of a symbols specifies from which kinds of crates\n-/// the symbol will be exported. `C` symbols will be exported from any\n-/// kind of crate, including cdylibs which export very few things.\n-/// `Rust` will only be exported if the crate produced is a Rust\n-/// dylib.\n-#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n-pub enum SymbolExportLevel {\n-    C,\n-    Rust,\n-}\n-\n-/// The set of symbols exported from each crate in the crate graph.\n-#[derive(Debug)]\n-pub struct ExportedSymbols {\n-    pub export_threshold: SymbolExportLevel,\n-    exports: FxHashMap<CrateNum, Vec<(String, DefId, SymbolExportLevel)>>,\n-    local_exports: NodeSet,\n-}\n-\n-impl ExportedSymbols {\n-    pub fn empty() -> ExportedSymbols {\n-        ExportedSymbols {\n-            export_threshold: SymbolExportLevel::C,\n-            exports: FxHashMap(),\n-            local_exports: NodeSet(),\n-        }\n-    }\n-\n-    pub fn compute<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             local_exported_symbols: &NodeSet)\n-                             -> ExportedSymbols {\n-        let export_threshold = crates_export_threshold(&tcx.sess.crate_types.borrow());\n-\n-        let mut local_crate: Vec<_> = local_exported_symbols\n-            .iter()\n-            .map(|&node_id| {\n-                tcx.hir.local_def_id(node_id)\n-            })\n-            .map(|def_id| {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                let export_level = export_level(tcx, def_id);\n-                debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), def_id, export_level)\n-            })\n-            .collect();\n-\n-        let mut local_exports = local_crate\n-            .iter()\n-            .filter_map(|&(_, def_id, level)| {\n-                if is_below_threshold(level, export_threshold) {\n-                    tcx.hir.as_local_node_id(def_id)\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect::<NodeSet>();\n-\n-        const INVALID_DEF_ID: DefId = DefId {\n-            krate: INVALID_CRATE,\n-            index: CRATE_DEF_INDEX,\n-        };\n-\n-        if let Some(_) = *tcx.sess.entry_fn.borrow() {\n-            local_crate.push((\"main\".to_string(),\n-                              INVALID_DEF_ID,\n-                              SymbolExportLevel::C));\n-        }\n-\n-        if tcx.sess.allocator_kind.get().is_some() {\n-            for method in ALLOCATOR_METHODS {\n-                local_crate.push((format!(\"__rust_{}\", method.name),\n-                                  INVALID_DEF_ID,\n-                                  SymbolExportLevel::Rust));\n+pub fn compute<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ExportedSymbols {\n+    let export_threshold = crates_export_threshold(&tcx.sess.crate_types.borrow());\n+    let local_exported_symbols = base::find_exported_symbols(tcx);\n+\n+    let mut local_crate: Vec<_> = local_exported_symbols\n+        .iter()\n+        .map(|&node_id| {\n+            tcx.hir.local_def_id(node_id)\n+        })\n+        .map(|def_id| {\n+            let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+            let export_level = export_level(tcx, def_id);\n+            debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n+            (str::to_owned(&name), def_id, export_level)\n+        })\n+        .collect();\n+\n+    let mut local_exports = local_crate\n+        .iter()\n+        .filter_map(|&(_, def_id, level)| {\n+            if is_below_threshold(level, export_threshold) {\n+                tcx.hir.as_local_node_id(def_id)\n+            } else {\n+                None\n             }\n-        }\n-\n-        if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n-            let def_id = tcx.hir.local_def_id(id);\n-            let idx = def_id.index;\n-            let disambiguator = tcx.sess.local_crate_disambiguator();\n-            let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n-            local_crate.push((registrar, def_id, SymbolExportLevel::C));\n-            local_exports.insert(id);\n-        }\n+        })\n+        .collect::<NodeSet>();\n+\n+    const INVALID_DEF_ID: DefId = DefId {\n+        krate: INVALID_CRATE,\n+        index: CRATE_DEF_INDEX,\n+    };\n+\n+    if let Some(_) = *tcx.sess.entry_fn.borrow() {\n+        local_crate.push((\"main\".to_string(),\n+                          INVALID_DEF_ID,\n+                          SymbolExportLevel::C));\n+    }\n \n-        if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n-            local_crate.push((metadata_symbol_name(tcx),\n+    if tcx.sess.allocator_kind.get().is_some() {\n+        for method in ALLOCATOR_METHODS {\n+            local_crate.push((format!(\"__rust_{}\", method.name),\n                               INVALID_DEF_ID,\n                               SymbolExportLevel::Rust));\n         }\n+    }\n \n-        let mut exports = FxHashMap();\n-        exports.insert(LOCAL_CRATE, local_crate);\n+    if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n+        let def_id = tcx.hir.local_def_id(id);\n+        let idx = def_id.index;\n+        let disambiguator = tcx.sess.local_crate_disambiguator();\n+        let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n+        local_crate.push((registrar, def_id, SymbolExportLevel::C));\n+        local_exports.insert(id);\n+    }\n \n-        for &cnum in tcx.crates().iter() {\n-            debug_assert!(cnum != LOCAL_CRATE);\n+    if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n+        local_crate.push((metadata_symbol_name(tcx),\n+                          INVALID_DEF_ID,\n+                          SymbolExportLevel::Rust));\n+    }\n \n-            // If this crate is a plugin and/or a custom derive crate, then\n-            // we're not even going to link those in so we skip those crates.\n-            if tcx.plugin_registrar_fn(cnum).is_some() ||\n-               tcx.derive_registrar_fn(cnum).is_some() {\n-                continue;\n-            }\n+    let mut exports = FxHashMap();\n+    exports.insert(LOCAL_CRATE, local_crate);\n \n-            // Check to see if this crate is a \"special runtime crate\". These\n-            // crates, implementation details of the standard library, typically\n-            // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n-            // ABI between them. We don't want their symbols to have a `C`\n-            // export level, however, as they're just implementation details.\n-            // Down below we'll hardwire all of the symbols to the `Rust` export\n-            // level instead.\n-            let special_runtime_crate =\n-                tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n-\n-            let crate_exports = tcx\n-                .exported_symbols(cnum)\n-                .iter()\n-                .map(|&def_id| {\n-                    let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                    let export_level = if special_runtime_crate {\n-                        // We can probably do better here by just ensuring that\n-                        // it has hidden visibility rather than public\n-                        // visibility, as this is primarily here to ensure it's\n-                        // not stripped during LTO.\n-                        //\n-                        // In general though we won't link right if these\n-                        // symbols are stripped, and LTO currently strips them.\n-                        if &*name == \"rust_eh_personality\" ||\n-                           &*name == \"rust_eh_register_frames\" ||\n-                           &*name == \"rust_eh_unregister_frames\" {\n-                            SymbolExportLevel::C\n-                        } else {\n-                            SymbolExportLevel::Rust\n-                        }\n-                    } else {\n-                        export_level(tcx, def_id)\n-                    };\n-                    debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-                    (str::to_owned(&name), def_id, export_level)\n-                })\n-                .collect();\n-\n-            exports.insert(cnum, crate_exports);\n-        }\n+    for &cnum in tcx.crates().iter() {\n+        debug_assert!(cnum != LOCAL_CRATE);\n \n-        return ExportedSymbols {\n-            export_threshold,\n-            exports,\n-            local_exports,\n-        };\n-\n-        fn export_level(tcx: TyCtxt,\n-                        sym_def_id: DefId)\n-                        -> SymbolExportLevel {\n-            let attrs = tcx.get_attrs(sym_def_id);\n-            if attr::contains_extern_indicator(tcx.sess.diagnostic(), &attrs) {\n-                SymbolExportLevel::C\n-            } else {\n-                SymbolExportLevel::Rust\n-            }\n+        // If this crate is a plugin and/or a custom derive crate, then\n+        // we're not even going to link those in so we skip those crates.\n+        if tcx.plugin_registrar_fn(cnum).is_some() ||\n+           tcx.derive_registrar_fn(cnum).is_some() {\n+            continue;\n         }\n-    }\n \n-    pub fn local_exports(&self) -> &NodeSet {\n-        &self.local_exports\n-    }\n+        // Check to see if this crate is a \"special runtime crate\". These\n+        // crates, implementation details of the standard library, typically\n+        // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n+        // ABI between them. We don't want their symbols to have a `C`\n+        // export level, however, as they're just implementation details.\n+        // Down below we'll hardwire all of the symbols to the `Rust` export\n+        // level instead.\n+        let special_runtime_crate =\n+            tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n+\n+        let crate_exports = tcx\n+            .exported_symbol_ids(cnum)\n+            .iter()\n+            .map(|&def_id| {\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+                let export_level = if special_runtime_crate {\n+                    // We can probably do better here by just ensuring that\n+                    // it has hidden visibility rather than public\n+                    // visibility, as this is primarily here to ensure it's\n+                    // not stripped during LTO.\n+                    //\n+                    // In general though we won't link right if these\n+                    // symbols are stripped, and LTO currently strips them.\n+                    if &*name == \"rust_eh_personality\" ||\n+                       &*name == \"rust_eh_register_frames\" ||\n+                       &*name == \"rust_eh_unregister_frames\" {\n+                        SymbolExportLevel::C\n+                    } else {\n+                        SymbolExportLevel::Rust\n+                    }\n+                } else {\n+                    export_level(tcx, def_id)\n+                };\n+                debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n+                (str::to_owned(&name), def_id, export_level)\n+            })\n+            .collect();\n \n-    pub fn exported_symbols(&self,\n-                            cnum: CrateNum)\n-                            -> &[(String, DefId, SymbolExportLevel)] {\n-        match self.exports.get(&cnum) {\n-            Some(exports) => exports,\n-            None => &[]\n-        }\n+        exports.insert(cnum, crate_exports);\n     }\n \n-    pub fn for_each_exported_symbol<F>(&self,\n-                                       cnum: CrateNum,\n-                                       mut f: F)\n-        where F: FnMut(&str, DefId, SymbolExportLevel)\n-    {\n-        for &(ref name, def_id, export_level) in self.exported_symbols(cnum) {\n-            if is_below_threshold(export_level, self.export_threshold) {\n-                f(&name, def_id, export_level)\n-            }\n+    return ExportedSymbols::new(export_threshold, exports, local_exports);\n+\n+    fn export_level(tcx: TyCtxt,\n+                    sym_def_id: DefId)\n+                    -> SymbolExportLevel {\n+        let attrs = tcx.get_attrs(sym_def_id);\n+        if attr::contains_extern_indicator(tcx.sess.diagnostic(), &attrs) {\n+            SymbolExportLevel::C\n+        } else {\n+            SymbolExportLevel::Rust\n         }\n     }\n }\n@@ -233,14 +177,3 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType])\n         SymbolExportLevel::C\n     }\n }\n-\n-pub fn is_below_threshold(level: SymbolExportLevel,\n-                          threshold: SymbolExportLevel)\n-                          -> bool {\n-    if threshold == SymbolExportLevel::Rust {\n-        // We export everything from Rust dylibs\n-        true\n-    } else {\n-        level == SymbolExportLevel::C\n-    }\n-}"}, {"sha": "d241edca0ead79d66d2314b2319519618c30d1df", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -11,7 +11,7 @@\n use back::lto;\n use back::link::{self, get_linker, remove};\n use back::linker::LinkerInfo;\n-use back::symbol_export::ExportedSymbols;\n+use rustc::middle::exported_symbols::ExportedSymbols;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::{LinkMeta, EncodedMetadata};"}, {"sha": "5f8e95b6ca98fbd9cf3246b9833e255e3e13b153", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -31,7 +31,7 @@ use super::ModuleKind;\n use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n-use back::symbol_export::{self, ExportedSymbols};\n+use back::symbol_export;\n use back::write::{self, OngoingCrateTranslation};\n use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n@@ -42,6 +42,7 @@ use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::dep_graph::AssertDepGraphSafe;\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n+use rustc::middle::exported_symbols::{ExportedSymbols, SymbolExportLevel};\n use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n@@ -973,7 +974,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n        !tcx.sess.opts.output_types.should_trans() {\n-        let empty_exported_symbols = ExportedSymbols::empty();\n+        let empty_exported_symbols = ExportedSymbols::new(\n+            SymbolExportLevel::C,\n+            Default::default(),\n+            Default::default(),\n+        );\n         let linker_info = LinkerInfo::new(&shared_ccx, &empty_exported_symbols);\n         let ongoing_translation = write::start_async_translation(\n             tcx.sess,\n@@ -1001,13 +1006,12 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return ongoing_translation;\n     }\n \n-    let exported_symbols = Arc::new(ExportedSymbols::compute(tcx,\n-                                                             &exported_symbol_node_ids));\n+    let exported_symbols = tcx.exported_symbols();\n \n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n     let (translation_items, codegen_units) =\n-        collect_and_partition_translation_items(&shared_ccx, &exported_symbols);\n+        collect_and_partition_translation_items(shared_ccx.tcx(), &exported_symbols);\n \n     assert!(codegen_units.len() <= 1 || !tcx.sess.lto());\n \n@@ -1394,13 +1398,13 @@ fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_i\n     }\n }\n \n-fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn collect_and_partition_translation_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                      exported_symbols: &ExportedSymbols)\n                                                      -> (FxHashSet<TransItem<'tcx>>,\n                                                          Vec<CodegenUnit<'tcx>>) {\n-    let time_passes = scx.sess().time_passes();\n+    let time_passes = tcx.sess.time_passes();\n \n-    let collection_mode = match scx.sess().opts.debugging_opts.print_trans_items {\n+    let collection_mode = match tcx.sess.opts.debugging_opts.print_trans_items {\n         Some(ref s) => {\n             let mode_string = s.to_lowercase();\n             let mode_string = mode_string.trim();\n@@ -1411,7 +1415,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                     let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n                                            Falling back to 'lazy' mode.\",\n                                            mode_string);\n-                    scx.sess().warn(&message);\n+                    tcx.sess.warn(&message);\n                 }\n \n                 TransItemCollectionMode::Lazy\n@@ -1422,33 +1426,33 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n \n     let (items, inlining_map) =\n         time(time_passes, \"translation item collection\", || {\n-            collector::collect_crate_translation_items(scx.tcx(),\n+            collector::collect_crate_translation_items(tcx,\n                                                        exported_symbols,\n                                                        collection_mode)\n     });\n \n-    assert_symbols_are_distinct(scx.tcx(), items.iter());\n+    assert_symbols_are_distinct(tcx, items.iter());\n \n-    let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n+    let strategy = if tcx.sess.opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n     } else {\n-        PartitioningStrategy::FixedUnitCount(scx.sess().opts.cg.codegen_units)\n+        PartitioningStrategy::FixedUnitCount(tcx.sess.opts.cg.codegen_units)\n     };\n \n     let codegen_units = time(time_passes, \"codegen unit partitioning\", || {\n-        partitioning::partition(scx.tcx(),\n+        partitioning::partition(tcx,\n                                 items.iter().cloned(),\n                                 strategy,\n                                 &inlining_map,\n                                 exported_symbols)\n     });\n \n-    assert!(scx.tcx().sess.opts.cg.codegen_units == codegen_units.len() ||\n-            scx.tcx().sess.opts.debugging_opts.incremental.is_some());\n+    assert!(tcx.sess.opts.cg.codegen_units == codegen_units.len() ||\n+            tcx.sess.opts.debugging_opts.incremental.is_some());\n \n     let translation_items: FxHashSet<TransItem<'tcx>> = items.iter().cloned().collect();\n \n-    if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n+    if tcx.sess.opts.debugging_opts.print_trans_items.is_some() {\n         let mut item_to_cgus = FxHashMap();\n \n         for cgu in &codegen_units {\n@@ -1462,7 +1466,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         let mut item_keys: Vec<_> = items\n             .iter()\n             .map(|i| {\n-                let mut output = i.to_string(scx.tcx());\n+                let mut output = i.to_string(tcx);\n                 output.push_str(\" @@\");\n                 let mut empty = Vec::new();\n                 let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);"}, {"sha": "ff550d10c6d75f9eb2411242fcf01490bbba1177", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -194,6 +194,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n+use rustc::middle::exported_symbols::ExportedSymbols;\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n use rustc::traits;\n use rustc::ty::subst::Substs;\n@@ -209,7 +210,6 @@ use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n use trans_item::{TransItem, DefPathBasedNames, InstantiationMode};\n \n use rustc_data_structures::bitvec::BitVector;\n-use back::symbol_export::ExportedSymbols;\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {"}, {"sha": "94695b4e0463c909328b6717a78ed4941e5a5ca7", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -14,10 +14,10 @@ use llvm::{ContextRef, ModuleRef, ValueRef};\n use rustc::dep_graph::{DepGraph, DepGraphSafe};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::middle::exported_symbols::ExportedSymbols;\n use rustc::traits;\n use debuginfo;\n use callee;\n-use back::symbol_export::ExportedSymbols;\n use base;\n use declare;\n use monomorphize::Instance;"}, {"sha": "8c8bd6a5e509af13f7ef29a26df149f23b4314f1", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -64,16 +64,17 @@ extern crate serialize;\n extern crate gcc; // Used to locate MSVC, not gcc :)\n \n pub use base::trans_crate;\n-pub use back::symbol_names::provide;\n \n pub use metadata::LlvmMetadataLoader;\n pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n \n use std::rc::Rc;\n+use std::sync::Arc;\n \n-use rustc::hir::def_id::CrateNum;\n-use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::middle::cstore::{NativeLibrary, CrateSource, LibSource};\n+use rustc::ty::maps::Providers;\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n \n pub mod back {\n     mod archive;\n@@ -247,3 +248,15 @@ pub struct CrateInfo {\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }\n+\n+pub fn provide_local(providers: &mut Providers) {\n+    back::symbol_names::provide(providers);\n+    providers.exported_symbol_set = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Arc::new(back::symbol_export::compute(tcx))\n+    };\n+}\n+\n+pub fn provide_extern(providers: &mut Providers) {\n+    back::symbol_names::provide(providers);\n+}"}, {"sha": "d47739b906cdc11e8d57f8f7965faf6100fa6296", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba3ddd8d4e037db390f54536b4cb77ea988eab1/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=dba3ddd8d4e037db390f54536b4cb77ea988eab1", "patch": "@@ -102,14 +102,14 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use back::symbol_export::ExportedSymbols;\n use collector::InliningMap;\n use common;\n use context::SharedCrateContext;\n use llvm;\n use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n+use rustc::middle::exported_symbols::ExportedSymbols;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;"}]}