{"sha": "d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MGE0YjhhZTljNjI4M2JmYWU1MzdmNjVlMGNlZTQxYTY5ZWQ1Zjc=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-08-13T02:05:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-13T02:05:35Z"}, "message": "Rollup merge of #75372 - estebank:lt-sugg-in-type, r=lcnr\n\nFix suggestion to use lifetime in type and in assoc const\n\n_Do not merge until #75363 has landed, as it has the test case for this._\n\n* Account for associated types\n* Associated `const`s can't have generics (fix #74264)\n* Do not suggest duplicate lifetimes and suggest `for<'a>` more (fix #72404)", "tree": {"sha": "ed28ce01b8adb85f874befc37459de8b121e2912", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed28ce01b8adb85f874befc37459de8b121e2912"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfNJ/vCRBK7hj4Ov3rIwAAdHIIABL7ZwiCQEQaiwT1YqqOelKW\nfYMtBLWqzyHpe7J8Aq/L1RnIXO5huGhhiLTi9ezVqabCJO+ZDBiwxD3rhjznATmc\nBGZcmaY40NGmLNoOZPwOAfDNesGsVCLc7DzAKSEXA6ImLU+ahzZYihs7xldr+ZG5\nEptwPpempppo8Kp/a++l6WleXun5kDmq6RkSL3cY/avHs1H8DNjMjtAng2qmHaq9\nzN/EBq4RmAshBKqyPvPs3O5lZ9k5Or8izmWdIzdLMCaDJfw4nhQkPIOLKpHPptRL\nH2G3z7y3ql3o1/FKUskwbFJ2JTnfr8VBgAXa7fnLoXs4H/1+xnkoFmAatsIBov8=\n=wckL\n-----END PGP SIGNATURE-----\n", "payload": "tree ed28ce01b8adb85f874befc37459de8b121e2912\nparent d0414b57b45e8670223f2403fb34888dbc48da1e\nparent 6a3deb0ae04c4cb6400b30fecd1cbbee0506348b\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1597284335 +0900\ncommitter GitHub <noreply@github.com> 1597284335 +0900\n\nRollup merge of #75372 - estebank:lt-sugg-in-type, r=lcnr\n\nFix suggestion to use lifetime in type and in assoc const\n\n_Do not merge until #75363 has landed, as it has the test case for this._\n\n* Account for associated types\n* Associated `const`s can't have generics (fix #74264)\n* Do not suggest duplicate lifetimes and suggest `for<'a>` more (fix #72404)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "html_url": "https://github.com/rust-lang/rust/commit/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0414b57b45e8670223f2403fb34888dbc48da1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0414b57b45e8670223f2403fb34888dbc48da1e", "html_url": "https://github.com/rust-lang/rust/commit/d0414b57b45e8670223f2403fb34888dbc48da1e"}, {"sha": "6a3deb0ae04c4cb6400b30fecd1cbbee0506348b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3deb0ae04c4cb6400b30fecd1cbbee0506348b", "html_url": "https://github.com/rust-lang/rust/commit/6a3deb0ae04c4cb6400b30fecd1cbbee0506348b"}], "stats": {"total": 398, "additions": 360, "deletions": 38}, "files": [{"sha": "a7d3697405751782b82f579613424af3a6ae6351", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 137, "deletions": 24, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "patch": "@@ -16,8 +16,8 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::config::nightly_options;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use log::debug;\n \n@@ -33,6 +33,7 @@ enum AssocSuggestion {\n crate enum MissingLifetimeSpot<'tcx> {\n     Generics(&'tcx hir::Generics<'tcx>),\n     HigherRanked { span: Span, span_type: ForLifetimeSpanType },\n+    Static,\n }\n \n crate enum ForLifetimeSpanType {\n@@ -1195,6 +1196,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                             https://doc.rust-lang.org/nomicon/hrtb.html\",\n                     );\n                 }\n+                _ => {}\n             }\n         }\n         if nightly_options::is_nightly_build()\n@@ -1253,7 +1255,8 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         count: usize,\n-        lifetime_names: &FxHashSet<Ident>,\n+        lifetime_names: &FxHashSet<Symbol>,\n+        lifetime_spans: Vec<Span>,\n         params: &[ElisionFailureInfo],\n     ) {\n         let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n@@ -1267,11 +1270,60 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             ),\n         );\n \n-        let suggest_existing = |err: &mut DiagnosticBuilder<'_>, sugg| {\n+        let suggest_existing = |err: &mut DiagnosticBuilder<'_>,\n+                                name: &str,\n+                                formatter: &dyn Fn(&str) -> String| {\n+            if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n+                self.missing_named_lifetime_spots.iter().rev().next()\n+            {\n+                // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n+                // using `'a`, but also introduce the concept of HRLTs by suggesting\n+                // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n+                let mut introduce_suggestion = vec![];\n+\n+                let a_to_z_repeat_n = |n| {\n+                    (b'a'..=b'z').map(move |c| {\n+                        let mut s = '\\''.to_string();\n+                        s.extend(std::iter::repeat(char::from(c)).take(n));\n+                        s\n+                    })\n+                };\n+\n+                // If all single char lifetime names are present, we wrap around and double the chars.\n+                let lt_name = (1..)\n+                    .flat_map(a_to_z_repeat_n)\n+                    .find(|lt| !lifetime_names.contains(&Symbol::intern(&lt)))\n+                    .unwrap();\n+                let msg = format!(\n+                    \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                    span_type.descr(),\n+                    lt_name,\n+                );\n+                err.note(\n+                    \"for more information on higher-ranked polymorphism, visit \\\n+                    https://doc.rust-lang.org/nomicon/hrtb.html\",\n+                );\n+                let for_sugg = span_type.suggestion(&lt_name);\n+                for param in params {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n+                        if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n+                            introduce_suggestion\n+                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n+                        } else if snippet.starts_with(\"&'_ \") {\n+                            introduce_suggestion\n+                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[4..])));\n+                        }\n+                    }\n+                }\n+                introduce_suggestion.push((*for_span, for_sugg.to_string()));\n+                introduce_suggestion.push((span, formatter(&lt_name)));\n+                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n+            }\n+\n             err.span_suggestion_verbose(\n                 span,\n                 &format!(\"consider using the `{}` lifetime\", lifetime_names.iter().next().unwrap()),\n-                sugg,\n+                formatter(name),\n                 Applicability::MaybeIncorrect,\n             );\n         };\n@@ -1282,6 +1334,15 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                 let should_break;\n                 introduce_suggestion.push(match missing {\n                     MissingLifetimeSpot::Generics(generics) => {\n+                        if generics.span == DUMMY_SP {\n+                            // Account for malformed generics in the HIR. This shouldn't happen,\n+                            // but if we make a mistake elsewhere, mainly by keeping something in\n+                            // `missing_named_lifetime_spots` that we shouldn't, like associated\n+                            // `const`s or making a mistake in the AST lowering we would provide\n+                            // non-sensical suggestions. Guard against that by skipping these.\n+                            // (#74264)\n+                            continue;\n+                        }\n                         msg = \"consider introducing a named lifetime parameter\".to_string();\n                         should_break = true;\n                         if let Some(param) = generics.params.iter().find(|p| match p.kind {\n@@ -1308,6 +1369,42 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         );\n                         (*span, span_type.suggestion(\"'a\"))\n                     }\n+                    MissingLifetimeSpot::Static => {\n+                        let (span, sugg) = match snippet.as_deref() {\n+                            Some(\"&\") => (span.shrink_to_hi(), \"'static \".to_owned()),\n+                            Some(\"'_\") => (span, \"'static\".to_owned()),\n+                            Some(snippet) if !snippet.ends_with('>') => {\n+                                if snippet == \"\" {\n+                                    (\n+                                        span,\n+                                        std::iter::repeat(\"'static\")\n+                                            .take(count)\n+                                            .collect::<Vec<_>>()\n+                                            .join(\", \"),\n+                                    )\n+                                } else {\n+                                    (\n+                                        span.shrink_to_hi(),\n+                                        format!(\n+                                            \"<{}>\",\n+                                            std::iter::repeat(\"'static\")\n+                                                .take(count)\n+                                                .collect::<Vec<_>>()\n+                                                .join(\", \")\n+                                        ),\n+                                    )\n+                                }\n+                            }\n+                            _ => continue,\n+                        };\n+                        err.span_suggestion_verbose(\n+                            span,\n+                            \"consider using the `'static` lifetime\",\n+                            sugg.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        continue;\n+                    }\n                 });\n                 for param in params {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n@@ -1328,41 +1425,57 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             }\n         };\n \n-        match (lifetime_names.len(), lifetime_names.iter().next(), snippet.as_deref()) {\n-            (1, Some(name), Some(\"&\")) => {\n-                suggest_existing(err, format!(\"&{} \", name));\n+        let lifetime_names: Vec<_> = lifetime_names.into_iter().collect();\n+        match (&lifetime_names[..], snippet.as_deref()) {\n+            ([name], Some(\"&\")) => {\n+                suggest_existing(err, &name.as_str()[..], &|name| format!(\"&{} \", name));\n             }\n-            (1, Some(name), Some(\"'_\")) => {\n-                suggest_existing(err, name.to_string());\n+            ([name], Some(\"'_\")) => {\n+                suggest_existing(err, &name.as_str()[..], &|n| n.to_string());\n             }\n-            (1, Some(name), Some(\"\")) => {\n-                suggest_existing(err, format!(\"{}, \", name).repeat(count));\n+            ([name], Some(\"\")) => {\n+                suggest_existing(err, &name.as_str()[..], &|n| format!(\"{}, \", n).repeat(count));\n             }\n-            (1, Some(name), Some(snippet)) if !snippet.ends_with('>') => {\n-                suggest_existing(\n-                    err,\n+            ([name], Some(snippet)) if !snippet.ends_with('>') => {\n+                let f = |name: &str| {\n                     format!(\n                         \"{}<{}>\",\n                         snippet,\n                         std::iter::repeat(name.to_string())\n                             .take(count)\n                             .collect::<Vec<_>>()\n                             .join(\", \")\n-                    ),\n-                );\n+                    )\n+                };\n+                suggest_existing(err, &name.as_str()[..], &f);\n             }\n-            (0, _, Some(\"&\")) if count == 1 => {\n+            ([], Some(\"&\")) if count == 1 => {\n                 suggest_new(err, \"&'a \");\n             }\n-            (0, _, Some(\"'_\")) if count == 1 => {\n+            ([], Some(\"'_\")) if count == 1 => {\n                 suggest_new(err, \"'a\");\n             }\n-            (0, _, Some(snippet)) if !snippet.ends_with('>') && count == 1 => {\n-                suggest_new(err, &format!(\"{}<'a>\", snippet));\n+            ([], Some(snippet)) if !snippet.ends_with('>') => {\n+                if snippet == \"\" {\n+                    // This happens when we have `type Bar<'a> = Foo<T>` where we point at the space\n+                    // before `T`. We will suggest `type Bar<'a> = Foo<'a, T>`.\n+                    suggest_new(\n+                        err,\n+                        &std::iter::repeat(\"'a, \").take(count).collect::<Vec<_>>().join(\"\"),\n+                    );\n+                } else {\n+                    suggest_new(\n+                        err,\n+                        &format!(\n+                            \"{}<{}>\",\n+                            snippet,\n+                            std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \")\n+                        ),\n+                    );\n+                }\n             }\n-            (n, ..) if n > 1 => {\n-                let spans: Vec<Span> = lifetime_names.iter().map(|lt| lt.span).collect();\n-                err.span_note(spans, \"these named lifetimes are available to use\");\n+            (lts, ..) if lts.len() > 1 => {\n+                err.span_note(lifetime_spans, \"these named lifetimes are available to use\");\n                 if Some(\"\") == snippet.as_deref() {\n                     // This happens when we have `Foo<T>` where we point at the space before `T`,\n                     // but this can be confusing so we give a suggestion with placeholders."}, {"sha": "2046419d984d0fd0be20c2e0fb0fe87f793cb2a2", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "patch": "@@ -711,18 +711,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         use self::hir::TraitItemKind::*;\n-        self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n         match trait_item.kind {\n             Fn(ref sig, _) => {\n+                self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(trait_item.hir_id)),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n                 );\n+                self.missing_named_lifetime_spots.pop();\n             }\n             Type(bounds, ref ty) => {\n+                self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n@@ -757,31 +759,35 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         this.visit_ty(ty);\n                     }\n                 });\n+                self.missing_named_lifetime_spots.pop();\n             }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(trait_item.generics.params.is_empty());\n+                self.missing_named_lifetime_spots.push(MissingLifetimeSpot::Static);\n                 intravisit::walk_trait_item(self, trait_item);\n+                self.missing_named_lifetime_spots.pop();\n             }\n         }\n-        self.missing_named_lifetime_spots.pop();\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         use self::hir::ImplItemKind::*;\n-        self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n         match impl_item.kind {\n             Fn(ref sig, _) => {\n+                self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(impl_item.hir_id)),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n-                )\n+                );\n+                self.missing_named_lifetime_spots.pop();\n             }\n             TyAlias(ref ty) => {\n                 let generics = &impl_item.generics;\n+                self.missing_named_lifetime_spots.push(generics.into());\n                 let mut index = self.next_early_index();\n                 let mut non_lifetime_count = 0;\n                 debug!(\"visit_ty: index = {}\", index);\n@@ -810,14 +816,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.visit_generics(generics);\n                     this.visit_ty(ty);\n                 });\n+                self.missing_named_lifetime_spots.pop();\n             }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(impl_item.generics.params.is_empty());\n+                self.missing_named_lifetime_spots.push(MissingLifetimeSpot::Static);\n                 intravisit::walk_impl_item(self, impl_item);\n+                self.missing_named_lifetime_spots.pop();\n             }\n         }\n-        self.missing_named_lifetime_spots.pop();\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n@@ -2315,6 +2323,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n+        let mut lifetime_spans = vec![];\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n@@ -2326,7 +2335,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     // collect named lifetimes for suggestions\n                     for name in lifetimes.keys() {\n                         if let hir::ParamName::Plain(name) = name {\n-                            lifetime_names.insert(*name);\n+                            lifetime_names.insert(name.name);\n+                            lifetime_spans.push(name.span);\n                         }\n                     }\n                     late_depth += 1;\n@@ -2344,12 +2354,24 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n                         Elide::Exact(l) => l.shifted(late_depth),\n                         Elide::Error(ref e) => {\n-                            if let Scope::Binder { ref lifetimes, .. } = s {\n-                                // collect named lifetimes for suggestions\n-                                for name in lifetimes.keys() {\n-                                    if let hir::ParamName::Plain(name) = name {\n-                                        lifetime_names.insert(*name);\n+                            let mut scope = s;\n+                            loop {\n+                                match scope {\n+                                    Scope::Binder { ref lifetimes, s, .. } => {\n+                                        // Collect named lifetimes for suggestions.\n+                                        for name in lifetimes.keys() {\n+                                            if let hir::ParamName::Plain(name) = name {\n+                                                lifetime_names.insert(name.name);\n+                                                lifetime_spans.push(name.span);\n+                                            }\n+                                        }\n+                                        scope = s;\n+                                    }\n+                                    Scope::ObjectLifetimeDefault { ref s, .. }\n+                                    | Scope::Elision { ref s, .. } => {\n+                                        scope = s;\n                                     }\n+                                    _ => break,\n                                 }\n                             }\n                             break Some(e);\n@@ -2373,14 +2395,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if let Some(params) = error {\n             // If there's no lifetime available, suggest `'static`.\n             if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n-                lifetime_names.insert(Ident::with_dummy_span(kw::StaticLifetime));\n+                lifetime_names.insert(kw::StaticLifetime);\n             }\n         }\n         self.add_missing_lifetime_specifiers_label(\n             &mut err,\n             span,\n             lifetime_refs.len(),\n             &lifetime_names,\n+            lifetime_spans,\n             error.map(|p| &p[..]).unwrap_or(&[]),\n         );\n         err.emit();"}, {"sha": "6c68cc7bc61aa94e25067b7431d84f80d7326f9e", "filename": "src/test/ui/associated-types/bound-lifetime-in-binding-only.elision.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr?ref=d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "patch": "@@ -5,6 +5,11 @@ LL | fn elision<T: Fn() -> &i32>() {\n    |                       ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL | fn elision<T: for<'a> Fn() -> &'a i32>() {\n+   |               ^^^^^^^         ^^^\n help: consider using the `'static` lifetime\n    |\n LL | fn elision<T: Fn() -> &'static i32>() {"}, {"sha": "93d2f8e7911f08ceee48ca3eb3291a1b374722d8", "filename": "src/test/ui/associated-types/bound-lifetime-in-return-only.elision.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr?ref=d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "patch": "@@ -5,6 +5,11 @@ LL | fn elision(_: fn() -> &i32) {\n    |                       ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the type lifetime-generic with a new `'a` lifetime\n+   |\n+LL | fn elision(_: for<'a> fn() -> &'a i32) {\n+   |               ^^^^^^^         ^^^\n help: consider using the `'static` lifetime\n    |\n LL | fn elision(_: fn() -> &'static i32) {"}, {"sha": "ac70e887626ab8348a1cdb7963064c1525c4cb99", "filename": "src/test/ui/error-codes/E0106.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0106.stderr?ref=d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "patch": "@@ -51,6 +51,15 @@ error[E0106]: missing lifetime specifiers\n    |\n LL |     buzz: Buzz,\n    |           ^^^^ expected 2 lifetime parameters\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | struct Quux<'a> {\n+LL |     baz: Baz,\n+LL |\n+LL |\n+LL |     buzz: Buzz<'a, 'a>,\n+   |\n \n error: aborting due to 5 previous errors\n "}, {"sha": "d260addef481388ebfc3f314e3cfb80080790463", "filename": "src/test/ui/mismatched_types/issue-74918-missing-lifetime.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr?ref=d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "patch": "@@ -6,8 +6,8 @@ LL |     type Item = IteratorChunk<T, S>;\n    |\n help: consider introducing a named lifetime parameter\n    |\n-LL |     type Item<'a> = IteratorChunk<<'a>T, S>;\n-   |              ^^^^                 ^^^^\n+LL |     type Item<'a> = IteratorChunk<'a, T, S>;\n+   |              ^^^^                 ^^^\n \n error: `impl` item signature doesn't match `trait` item signature\n   --> $DIR/issue-74918-missing-lifetime.rs:11:5"}, {"sha": "38332627f4c87a86a2a819151f6d0c40769bb9b7", "filename": "src/test/ui/suggestions/missing-lifetime-in-assoc-const-type.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.rs?ref=d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "patch": "@@ -0,0 +1,16 @@\n+trait ZstAssert: Sized {\n+    const A: &str = \"\"; //~ ERROR missing lifetime specifier\n+    const B: S = S { s: &() }; //~ ERROR missing lifetime specifier\n+    const C: &'_ str = \"\"; //~ ERROR missing lifetime specifier\n+    const D: T = T { a: &(), b: &() }; //~ ERROR missing lifetime specifier\n+}\n+\n+struct S<'a> {\n+    s: &'a (),\n+}\n+struct T<'a, 'b> {\n+    a: &'a (),\n+    b: &'b (),\n+}\n+\n+fn main() {}"}, {"sha": "b20778ce208176346db23b7fc4c09d294c16bc48", "filename": "src/test/ui/suggestions/missing-lifetime-in-assoc-const-type.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-in-assoc-const-type.stderr?ref=d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "patch": "@@ -0,0 +1,73 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-in-assoc-const-type.rs:2:14\n+   |\n+LL |     const A: &str = \"\";\n+   |              ^ expected named lifetime parameter\n+   |\n+help: consider using the `'static` lifetime\n+   |\n+LL |     const A: &'static str = \"\";\n+   |               ^^^^^^^\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | trait ZstAssert<'a>: Sized {\n+LL |     const A: &'a str = \"\";\n+   |\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-in-assoc-const-type.rs:3:14\n+   |\n+LL |     const B: S = S { s: &() };\n+   |              ^ expected named lifetime parameter\n+   |\n+help: consider using the `'static` lifetime\n+   |\n+LL |     const B: S<'static> = S { s: &() };\n+   |               ^^^^^^^^^\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | trait ZstAssert<'a>: Sized {\n+LL |     const A: &str = \"\";\n+LL |     const B: S<'a> = S { s: &() };\n+   |\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-in-assoc-const-type.rs:4:15\n+   |\n+LL |     const C: &'_ str = \"\";\n+   |               ^^ expected named lifetime parameter\n+   |\n+help: consider using the `'static` lifetime\n+   |\n+LL |     const C: &'static str = \"\";\n+   |               ^^^^^^^\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | trait ZstAssert<'a>: Sized {\n+LL |     const A: &str = \"\";\n+LL |     const B: S = S { s: &() };\n+LL |     const C: &'a str = \"\";\n+   |\n+\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/missing-lifetime-in-assoc-const-type.rs:5:14\n+   |\n+LL |     const D: T = T { a: &(), b: &() };\n+   |              ^ expected 2 lifetime parameters\n+   |\n+help: consider using the `'static` lifetime\n+   |\n+LL |     const D: T<'static, 'static> = T { a: &(), b: &() };\n+   |               ^^^^^^^^^^^^^^^^^^\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | trait ZstAssert<'a>: Sized {\n+LL |     const A: &str = \"\";\n+LL |     const B: S = S { s: &() };\n+LL |     const C: &'_ str = \"\";\n+LL |     const D: T<'a, 'a> = T { a: &(), b: &() };\n+   |\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "a90a90122ad19f1cb3f79b8c881f544eaea1e84d", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs?ref=d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "patch": "@@ -0,0 +1,15 @@\n+struct X<'a>(&'a ());\n+struct S<'a>(&'a dyn Fn(&X) -> &X);\n+//~^ ERROR missing lifetime specifier\n+//~| ERROR missing lifetime specifier\n+struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+//~^ ERROR missing lifetime specifier\n+//~| ERROR missing lifetime specifier\n+\n+fn main() {\n+    let x = S(&|x| {\n+        println!(\"hi\");\n+        x\n+    });\n+    x.0(&X(&()));\n+}"}, {"sha": "2cb63500e48b919e571026ce0a0c865a307da0cf", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr?ref=d90a4b8ae9c6283bfae537f65e0cee41a69ed5f7", "patch": "@@ -0,0 +1,63 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:2:32\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &X);\n+   |                         --     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn for<'b> Fn(&'b X) -> &'b X);\n+   |                      ^^^^^^^    ^^^^^     ^^^\n+help: consider using the `'a` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &'a X);\n+   |                                ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:2:33\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &X);\n+   |                         --      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn for<'b> Fn(&'b X) -> &X<'b>);\n+   |                      ^^^^^^^    ^^^^^      ^^^^^\n+help: consider using the `'a` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &X<'a>);\n+   |                                 ^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:5:40\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |                                 --     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+note: these named lifetimes are available to use\n+  --> $DIR/missing-lt-for-hrtb.rs:5:10\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |          ^^              ^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:5:41\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |                                 --      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+note: these named lifetimes are available to use\n+  --> $DIR/missing-lt-for-hrtb.rs:5:10\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |          ^^              ^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}]}