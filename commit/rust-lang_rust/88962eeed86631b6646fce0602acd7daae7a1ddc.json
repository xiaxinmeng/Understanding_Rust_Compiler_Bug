{"sha": "88962eeed86631b6646fce0602acd7daae7a1ddc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4OTYyZWVlZDg2NjMxYjY2NDZmY2UwNjAyYWNkN2RhYWU3YTFkZGM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-11T17:06:56Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-18T06:01:38Z"}, "message": "core: Add &self to core::iter methods", "tree": {"sha": "3ab945c8056330d28b349830c6fdc5dd4ee42fb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ab945c8056330d28b349830c6fdc5dd4ee42fb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88962eeed86631b6646fce0602acd7daae7a1ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88962eeed86631b6646fce0602acd7daae7a1ddc", "html_url": "https://github.com/rust-lang/rust/commit/88962eeed86631b6646fce0602acd7daae7a1ddc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88962eeed86631b6646fce0602acd7daae7a1ddc/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fc74df7a423f5af0e951ab0b45faffca6bfa393", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fc74df7a423f5af0e951ab0b45faffca6bfa393", "html_url": "https://github.com/rust-lang/rust/commit/3fc74df7a423f5af0e951ab0b45faffca6bfa393"}], "stats": {"total": 153, "additions": 83, "deletions": 70}, "files": [{"sha": "eed439823fcf766f3166a23fd5297b11e301f8be", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88962eeed86631b6646fce0602acd7daae7a1ddc/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88962eeed86631b6646fce0602acd7daae7a1ddc/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=88962eeed86631b6646fce0602acd7daae7a1ddc", "patch": "@@ -98,12 +98,12 @@ impl T: iter::Times {\n         will execute the given function exactly x times. If we assume that \\\n         `x` is an int, this is functionally equivalent to \\\n         `for int::range(0, x) |_i| { /* anything */ }`.\"]\n-    pure fn times(it: fn() -> bool) {\n-        if self < 0 {\n+    pure fn times(&self, it: fn() -> bool) {\n+        if *self < 0 {\n             fail fmt!(\"The .times method expects a nonnegative number, \\\n                        but found %?\", self);\n         }\n-        let mut i = self;\n+        let mut i = *self;\n         while i > 0 {\n             if !it() { break }\n             i -= 1;"}, {"sha": "001e7f5648d46710bd4d24d0b21138c50feb2e1b", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/88962eeed86631b6646fce0602acd7daae7a1ddc/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88962eeed86631b6646fce0602acd7daae7a1ddc/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=88962eeed86631b6646fce0602acd7daae7a1ddc", "patch": "@@ -20,46 +20,53 @@ use cmp::{Eq, Ord};\n use self::inst::{IMPL_T, EACH, SIZE_HINT};\n \n impl<A> IMPL_T<A>: iter::BaseIter<A> {\n-    pure fn each(blk: fn(v: &A) -> bool) { EACH(&self, blk) }\n-    pure fn size_hint() -> Option<uint> { SIZE_HINT(&self) }\n+    pure fn each(&self, blk: fn(v: &A) -> bool) { EACH(self, blk) }\n+    pure fn size_hint(&self) -> Option<uint> { SIZE_HINT(self) }\n }\n \n impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n-    pure fn eachi(blk: fn(uint, v: &A) -> bool) { iter::eachi(&self, blk) }\n-    pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n-    pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n-    pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B {\n-        iter::foldl(&self, move b0, blk)\n+    pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n+        iter::eachi(self, blk)\n     }\n-    pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n-        iter::position(&self, f)\n+    pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::all(self, blk)\n+    }\n+    pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::any(self, blk)\n+    }\n+    pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n+        iter::foldl(self, move b0, blk)\n+    }\n+    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+        iter::position(self, f)\n     }\n }\n \n impl<A: Eq> IMPL_T<A>: iter::EqIter<A> {\n-    pure fn contains(x: &A) -> bool { iter::contains(&self, x) }\n-    pure fn count(x: &A) -> uint { iter::count(&self, x) }\n+    pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n impl<A: Copy> IMPL_T<A>: iter::CopyableIter<A> {\n-    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(&self, pred)\n+    pure fn filter_to_vec(&self, pred: fn(a: A) -> bool) -> ~[A] {\n+        iter::filter_to_vec(self, pred)\n     }\n-    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B] {\n-        iter::map_to_vec(&self, op)\n+    pure fn map_to_vec<B>(&self, op: fn(v: A) -> B) -> ~[B] {\n+        iter::map_to_vec(self, op)\n     }\n-    pure fn to_vec() -> ~[A] { iter::to_vec(&self) }\n+    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n \n-    pure fn flat_map_to_vec<B:Copy,IB:BaseIter<B>>(op: fn(a: A) -> IB)\n+    pure fn flat_map_to_vec<B:Copy,IB:BaseIter<B>>(&self, op: fn(a: A) -> IB)\n         -> ~[B] {\n-        iter::flat_map_to_vec(&self, op)\n+        iter::flat_map_to_vec(self, op)\n+    }\n+    pure fn find(&self, f: fn(A) -> bool) -> Option<A> {\n+        iter::find(self, f)\n     }\n-\n-    pure fn find(p: fn(a: A) -> bool) -> Option<A> { iter::find(&self, p) }\n }\n \n impl<A: Copy Ord> IMPL_T<A>: iter::CopyableOrderedIter<A> {\n-    pure fn min() -> A { iter::min(&self) }\n-    pure fn max() -> A { iter::max(&self) }\n+    pure fn min(&self) -> A { iter::min(self) }\n+    pure fn max(&self) -> A { iter::max(self) }\n }\n "}, {"sha": "2933259a18e8c9d7c4ac9d0e1c61617815650388", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/88962eeed86631b6646fce0602acd7daae7a1ddc/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88962eeed86631b6646fce0602acd7daae7a1ddc/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=88962eeed86631b6646fce0602acd7daae7a1ddc", "patch": "@@ -23,38 +23,39 @@ use cmp::{Eq, Ord};\n pub type InitOp<T> = &fn(uint) -> T;\n \n pub trait BaseIter<A> {\n-    pure fn each(blk: fn(v: &A) -> bool);\n-    pure fn size_hint() -> Option<uint>;\n+    pure fn each(&self, blk: fn(v: &A) -> bool);\n+    pure fn size_hint(&self) -> Option<uint>;\n }\n \n pub trait ExtendedIter<A> {\n-    pure fn eachi(blk: fn(uint, v: &A) -> bool);\n-    pure fn all(blk: fn(&A) -> bool) -> bool;\n-    pure fn any(blk: fn(&A) -> bool) -> bool;\n-    pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B;\n-    pure fn position(f: fn(&A) -> bool) -> Option<uint>;\n+    pure fn eachi(&self, blk: fn(uint, v: &A) -> bool);\n+    pure fn all(&self, blk: fn(&A) -> bool) -> bool;\n+    pure fn any(&self, blk: fn(&A) -> bool) -> bool;\n+    pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B;\n+    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint>;\n }\n \n pub trait EqIter<A:Eq> {\n-    pure fn contains(x: &A) -> bool;\n-    pure fn count(x: &A) -> uint;\n+    pure fn contains(&self, x: &A) -> bool;\n+    pure fn count(&self, x: &A) -> uint;\n }\n \n pub trait Times {\n-    pure fn times(it: fn() -> bool);\n+    pure fn times(&self, it: fn() -> bool);\n }\n \n pub trait CopyableIter<A:Copy> {\n-    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A];\n-    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B];\n-    pure fn flat_map_to_vec<B:Copy,IB: BaseIter<B>>(op: fn(A) -> IB) -> ~[B];\n-    pure fn to_vec() -> ~[A];\n-    pure fn find(p: fn(a: A) -> bool) -> Option<A>;\n+    pure fn filter_to_vec(&self, pred: fn(a: A) -> bool) -> ~[A];\n+    pure fn map_to_vec<B>(&self, op: fn(v: A) -> B) -> ~[B];\n+    pure fn flat_map_to_vec<B:Copy,IB: BaseIter<B>>(&self, op: fn(A) -> IB)\n+        -> ~[B];\n+    pure fn to_vec(&self) -> ~[A];\n+    pure fn find(&self, p: fn(A) -> bool) -> Option<A>;\n }\n \n pub trait CopyableOrderedIter<A:Copy Ord> {\n-    pure fn min() -> A;\n-    pure fn max() -> A;\n+    pure fn min(&self) -> A;\n+    pure fn max(&self) -> A;\n }\n \n pub trait CopyableNonstrictIter<A:Copy> {\n@@ -222,9 +223,9 @@ pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n pub pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n-                                     p: fn(a: A) -> bool) -> Option<A> {\n+                                   f: fn(A) -> bool) -> Option<A> {\n     for self.each |i| {\n-        if p(*i) { return Some(*i) }\n+        if f(*i) { return Some(*i) }\n     }\n     return None;\n }"}, {"sha": "1a9bca92d1faa111aba8e763628b30fedbdd0e81", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88962eeed86631b6646fce0602acd7daae7a1ddc/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88962eeed86631b6646fce0602acd7daae7a1ddc/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=88962eeed86631b6646fce0602acd7daae7a1ddc", "patch": "@@ -92,8 +92,8 @@ impl T: iter::Times {\n         will execute the given function exactly x times. If we assume that \\\n         `x` is an int, this is functionally equivalent to \\\n         `for int::range(0, x) |_i| { /* anything */ }`.\"]\n-    pure fn times(it: fn() -> bool) {\n-        let mut i = self;\n+    pure fn times(&self, it: fn() -> bool) {\n+        let mut i = *self;\n         while i > 0 {\n             if !it() { break }\n             i -= 1;"}, {"sha": "912f9b1bf1b9b60e3f6e053c2c9a180fd67dc953", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/88962eeed86631b6646fce0602acd7daae7a1ddc/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88962eeed86631b6646fce0602acd7daae7a1ddc/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=88962eeed86631b6646fce0602acd7daae7a1ddc", "patch": "@@ -2013,57 +2013,62 @@ pub mod bytes {\n // required in the slice.\n \n impl<A> &[A]: iter::BaseIter<A> {\n-    pub pure fn each(blk: fn(v: &A) -> bool) {\n+    pub pure fn each(&self, blk: fn(v: &A) -> bool) {\n         // FIXME(#2263)---should be able to call each(self, blk)\n-        for each(self) |e| {\n+        for each(*self) |e| {\n             if (!blk(e)) {\n                 return;\n             }\n         }\n     }\n-    pure fn size_hint() -> Option<uint> { Some(len(self)) }\n+    pure fn size_hint(&self) -> Option<uint> { Some(len(*self)) }\n }\n \n impl<A> &[A]: iter::ExtendedIter<A> {\n-    pub pure fn eachi(blk: fn(uint, v: &A) -> bool) {\n-        iter::eachi(&self, blk)\n+    pub pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n+        iter::eachi(self, blk)\n     }\n-    pub pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n-    pub pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n-    pub pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B {\n-        iter::foldl(&self, b0, blk)\n+    pub pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::all(self, blk)\n     }\n-    pub pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n-        iter::position(&self, f)\n+    pub pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::any(self, blk)\n+    }\n+    pub pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n+        iter::foldl(self, b0, blk)\n+    }\n+    pub pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+        iter::position(self, f)\n     }\n }\n \n impl<A: Eq> &[A]: iter::EqIter<A> {\n-    pub pure fn contains(x: &A) -> bool { iter::contains(&self, x) }\n-    pub pure fn count(x: &A) -> uint { iter::count(&self, x) }\n+    pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n impl<A: Copy> &[A]: iter::CopyableIter<A> {\n-    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(&self, pred)\n+    pure fn filter_to_vec(&self, pred: fn(a: A) -> bool) -> ~[A] {\n+        iter::filter_to_vec(self, pred)\n     }\n-    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B] {\n-        iter::map_to_vec(&self, op)\n+    pure fn map_to_vec<B>(&self, op: fn(v: A) -> B) -> ~[B] {\n+        iter::map_to_vec(self, op)\n     }\n-    pure fn to_vec() -> ~[A] { iter::to_vec(&self) }\n+    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n \n-    pure fn flat_map_to_vec<B:Copy,IB:BaseIter<B>>(op: fn(A) -> IB) -> ~[B] {\n-        iter::flat_map_to_vec(&self, op)\n+    pure fn flat_map_to_vec<B:Copy,IB:BaseIter<B>>(&self, op: fn(A) -> IB)\n+        -> ~[B] {\n+        iter::flat_map_to_vec(self, op)\n     }\n \n-    pub pure fn find(p: fn(a: A) -> bool) -> Option<A> {\n-        iter::find(&self, p)\n+    pub pure fn find(&self, f: fn(A) -> bool) -> Option<A> {\n+        iter::find(self, f)\n     }\n }\n \n impl<A: Copy Ord> &[A]: iter::CopyableOrderedIter<A> {\n-    pure fn min() -> A { iter::min(&self) }\n-    pure fn max() -> A { iter::max(&self) }\n+    pure fn min(&self) -> A { iter::min(self) }\n+    pure fn max(&self) -> A { iter::max(self) }\n }\n \n impl<A:Copy> &[A] : iter::CopyableNonstrictIter<A> {"}]}