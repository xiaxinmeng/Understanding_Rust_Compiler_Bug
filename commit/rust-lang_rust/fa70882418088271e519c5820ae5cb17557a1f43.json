{"sha": "fa70882418088271e519c5820ae5cb17557a1f43", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNzA4ODI0MTgwODgyNzFlNTE5YzU4MjBhZTVjYjE3NTU3YTFmNDM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-26T15:02:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-26T15:02:00Z"}, "message": "Merge #5075\n\n5075: Be more precise about flycheck status r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "338c3148cc7f0b1b27ebb383929cf2ba044022f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/338c3148cc7f0b1b27ebb383929cf2ba044022f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa70882418088271e519c5820ae5cb17557a1f43", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9g3oCRBK7hj4Ov3rIwAAdHIIAFFCpR7IDukC9OGa7nSO68Dl\n59b7xM6PnavdM0fIfOFVD0MdZRcXACtKPJzZDuqO/HggAL549l337ZsNgN5+N5r6\nqooO8/3jOS5o+d7RBMJ3qCG7fOaXK/DuT+WmAAKX5i1L40w2EvSMAH12gpPNDfmq\nRq6WnWGZFuxIjfRcvku7lx6OqVXFqFZiQmnm2CJfvC5hk1WnwEpZmxUZ6WczlShT\nkCn4ReTUnhDVvyIGpSZ38yqN1UqSzwrusF42kdY21pBkB3mkBMuH7dAGAVpTOg+w\nfTeY5gX0TdX5ctaBI7UQqbEnCcqLXNKD9jyo3PPFm9AO9QrtK/tvVdkW1OeH73s=\n=q+cC\n-----END PGP SIGNATURE-----\n", "payload": "tree 338c3148cc7f0b1b27ebb383929cf2ba044022f5\nparent 4f60b4f2a32190830215defe6cf81836f34d99c9\nparent 1893289e5c7cebeeb9705c031c996fc29d8c5b54\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593183720 +0000\ncommitter GitHub <noreply@github.com> 1593183720 +0000\n\nMerge #5075\n\n5075: Be more precise about flycheck status r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa70882418088271e519c5820ae5cb17557a1f43", "html_url": "https://github.com/rust-lang/rust/commit/fa70882418088271e519c5820ae5cb17557a1f43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa70882418088271e519c5820ae5cb17557a1f43/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f60b4f2a32190830215defe6cf81836f34d99c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f60b4f2a32190830215defe6cf81836f34d99c9", "html_url": "https://github.com/rust-lang/rust/commit/4f60b4f2a32190830215defe6cf81836f34d99c9"}, {"sha": "1893289e5c7cebeeb9705c031c996fc29d8c5b54", "url": "https://api.github.com/repos/rust-lang/rust/commits/1893289e5c7cebeeb9705c031c996fc29d8c5b54", "html_url": "https://github.com/rust-lang/rust/commit/1893289e5c7cebeeb9705c031c996fc29d8c5b54"}], "stats": {"total": 284, "additions": 127, "deletions": 157}, "files": [{"sha": "92ec4f92e3102fab0eae76d65c0ac1db37a2a9d7", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 30, "deletions": 62, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=fa70882418088271e519c5820ae5cb17557a1f43", "patch": "@@ -7,7 +7,7 @@ use std::{\n     io::{self, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n-    time::Instant,\n+    time::Duration,\n };\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n@@ -74,9 +74,6 @@ impl FlycheckHandle {\n \n #[derive(Debug)]\n pub enum Message {\n-    /// Request a clearing of all cached diagnostics from the check watcher\n-    ClearDiagnostics,\n-\n     /// Request adding a diagnostic with fixes included to a file\n     AddDiagnostic { workspace_root: PathBuf, diagnostic: Diagnostic },\n \n@@ -86,9 +83,10 @@ pub enum Message {\n \n #[derive(Debug)]\n pub enum Progress {\n-    Being,\n+    DidStart,\n     DidCheckCrate(String),\n-    End,\n+    DidFinish,\n+    DidCancel,\n }\n \n struct Restart;\n@@ -97,19 +95,18 @@ struct FlycheckActor {\n     sender: Box<dyn Fn(Message) + Send>,\n     config: FlycheckConfig,\n     workspace_root: PathBuf,\n-    last_update_req: Option<Instant>,\n     /// WatchThread exists to wrap around the communication needed to be able to\n     /// run `cargo check` without blocking. Currently the Rust standard library\n     /// doesn't provide a way to read sub-process output without blocking, so we\n     /// have to wrap sub-processes output handling in a thread and pass messages\n     /// back over a channel.\n     // XXX: drop order is significant\n-    check_process: Option<(Receiver<CheckEvent>, jod_thread::JoinHandle)>,\n+    check_process: Option<(Receiver<cargo_metadata::Message>, jod_thread::JoinHandle)>,\n }\n \n enum Event {\n     Restart(Restart),\n-    CheckEvent(Option<CheckEvent>),\n+    CheckEvent(Option<cargo_metadata::Message>),\n }\n \n impl FlycheckActor {\n@@ -118,7 +115,7 @@ impl FlycheckActor {\n         config: FlycheckConfig,\n         workspace_root: PathBuf,\n     ) -> FlycheckActor {\n-        FlycheckActor { sender, config, workspace_root, last_update_req: None, check_process: None }\n+        FlycheckActor { sender, config, workspace_root, check_process: None }\n     }\n     fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n         let check_chan = self.check_process.as_ref().map(|(chan, _thread)| chan);\n@@ -128,65 +125,48 @@ impl FlycheckActor {\n         }\n     }\n     fn run(&mut self, inbox: Receiver<Restart>) {\n-        // If we rerun the thread, we need to discard the previous check results first\n-        self.send(Message::ClearDiagnostics);\n-        self.send(Message::Progress(Progress::End));\n-\n         while let Some(event) = self.next_event(&inbox) {\n             match event {\n-                Event::Restart(Restart) => self.last_update_req = Some(Instant::now()),\n+                Event::Restart(Restart) => {\n+                    while let Ok(Restart) = inbox.recv_timeout(Duration::from_millis(50)) {}\n+                    self.cancel_check_process();\n+                    self.check_process = Some(self.start_check_process());\n+                    self.send(Message::Progress(Progress::DidStart));\n+                }\n                 Event::CheckEvent(None) => {\n                     // Watcher finished, replace it with a never channel to\n                     // avoid busy-waiting.\n-                    self.check_process = None;\n+                    assert!(self.check_process.take().is_some());\n+                    self.send(Message::Progress(Progress::DidFinish));\n                 }\n-                Event::CheckEvent(Some(event)) => match event {\n-                    CheckEvent::Begin => {\n-                        self.send(Message::Progress(Progress::Being));\n-                    }\n-\n-                    CheckEvent::End => {\n-                        self.send(Message::Progress(Progress::End));\n-                    }\n-\n-                    CheckEvent::Msg(cargo_metadata::Message::CompilerArtifact(msg)) => {\n+                Event::CheckEvent(Some(message)) => match message {\n+                    cargo_metadata::Message::CompilerArtifact(msg) => {\n                         self.send(Message::Progress(Progress::DidCheckCrate(msg.target.name)));\n                     }\n \n-                    CheckEvent::Msg(cargo_metadata::Message::CompilerMessage(msg)) => {\n+                    cargo_metadata::Message::CompilerMessage(msg) => {\n                         self.send(Message::AddDiagnostic {\n                             workspace_root: self.workspace_root.clone(),\n                             diagnostic: msg.message,\n                         });\n                     }\n \n-                    CheckEvent::Msg(cargo_metadata::Message::BuildScriptExecuted(_))\n-                    | CheckEvent::Msg(cargo_metadata::Message::BuildFinished(_))\n-                    | CheckEvent::Msg(cargo_metadata::Message::TextLine(_))\n-                    | CheckEvent::Msg(cargo_metadata::Message::Unknown) => {}\n+                    cargo_metadata::Message::BuildScriptExecuted(_)\n+                    | cargo_metadata::Message::BuildFinished(_)\n+                    | cargo_metadata::Message::TextLine(_)\n+                    | cargo_metadata::Message::Unknown => {}\n                 },\n             }\n-            if self.should_recheck() {\n-                self.last_update_req = None;\n-                self.send(Message::ClearDiagnostics);\n-                self.restart_check_process();\n-            }\n         }\n+        // If we rerun the thread, we need to discard the previous check results first\n+        self.cancel_check_process();\n     }\n-    fn should_recheck(&mut self) -> bool {\n-        if let Some(_last_update_req) = &self.last_update_req {\n-            // We currently only request an update on save, as we need up to\n-            // date source on disk for cargo check to do it's magic, so we\n-            // don't really need to debounce the requests at this point.\n-            return true;\n+    fn cancel_check_process(&mut self) {\n+        if self.check_process.take().is_some() {\n+            self.send(Message::Progress(Progress::DidCancel));\n         }\n-        false\n     }\n-\n-    fn restart_check_process(&mut self) {\n-        // First, clear and cancel the old thread\n-        self.check_process = None;\n-\n+    fn start_check_process(&self) -> (Receiver<cargo_metadata::Message>, jod_thread::JoinHandle) {\n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand {\n                 command,\n@@ -223,8 +203,6 @@ impl FlycheckActor {\n         let thread = jod_thread::spawn(move || {\n             // If we trigger an error here, we will do so in the loop instead,\n             // which will break out of the loop, and continue the shutdown\n-            let _ = message_send.send(CheckEvent::Begin);\n-\n             let res = run_cargo(cmd, &mut |message| {\n                 // Skip certain kinds of messages to only spend time on what's useful\n                 match &message {\n@@ -237,33 +215,23 @@ impl FlycheckActor {\n                 }\n \n                 // if the send channel was closed, we want to shutdown\n-                message_send.send(CheckEvent::Msg(message)).is_ok()\n+                message_send.send(message).is_ok()\n             });\n \n             if let Err(err) = res {\n                 // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n                 // to display user-caused misconfiguration errors instead of just logging them here\n                 log::error!(\"Cargo watcher failed {:?}\", err);\n             }\n-\n-            // We can ignore any error here, as we are already in the progress\n-            // of shutting down.\n-            let _ = message_send.send(CheckEvent::End);\n         });\n-        self.check_process = Some((message_recv, thread))\n+        (message_recv, thread)\n     }\n \n     fn send(&self, check_task: Message) {\n         (self.sender)(check_task)\n     }\n }\n \n-enum CheckEvent {\n-    Begin,\n-    Msg(cargo_metadata::Message),\n-    End,\n-}\n-\n fn run_cargo(\n     mut command: Command,\n     on_message: &mut dyn FnMut(cargo_metadata::Message) -> bool,"}, {"sha": "384e1f0d2a6f8a4796d83a1d943e4c00db698036", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=fa70882418088271e519c5820ae5cb17557a1f43", "patch": "@@ -21,7 +21,6 @@ use crate::{\n     main_loop::Task,\n     reload::SourceRootConfig,\n     request_metrics::{LatestRequests, RequestMetrics},\n-    show_message,\n     thread_pool::TaskPool,\n     to_proto::url_from_abs_path,\n     Result,\n@@ -182,9 +181,6 @@ impl GlobalState {\n             self.send(response.into());\n         }\n     }\n-    pub(crate) fn show_message(&self, typ: lsp_types::MessageType, message: String) {\n-        show_message(typ, message, &self.sender)\n-    }\n }\n \n impl Drop for GlobalState {"}, {"sha": "407944d852c86febb79eb5643bf83b57f6fbeac3", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=fa70882418088271e519c5820ae5cb17557a1f43", "patch": "@@ -39,7 +39,7 @@ pub mod config;\n use serde::de::DeserializeOwned;\n \n pub type Result<T, E = Box<dyn std::error::Error + Send + Sync>> = std::result::Result<T, E>;\n-pub use crate::{caps::server_capabilities, lsp_utils::show_message, main_loop::main_loop};\n+pub use crate::{caps::server_capabilities, main_loop::main_loop};\n use std::fmt;\n \n pub fn from_json<T: DeserializeOwned>(what: &'static str, json: serde_json::Value) -> Result<T> {"}, {"sha": "fd793a17cfa03c938c4b50cb3f7c8b0adcfadeb9", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 71, "deletions": 14, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=fa70882418088271e519c5820ae5cb17557a1f43", "patch": "@@ -1,24 +1,13 @@\n //! Utilities for LSP-related boilerplate code.\n use std::{error::Error, ops::Range};\n \n-use crossbeam_channel::Sender;\n-use lsp_server::{Message, Notification};\n+use lsp_server::Notification;\n+use lsp_types::request::Request;\n use ra_db::Canceled;\n use ra_ide::LineIndex;\n use serde::Serialize;\n \n-use crate::from_proto;\n-\n-pub fn show_message(\n-    typ: lsp_types::MessageType,\n-    message: impl Into<String>,\n-    sender: &Sender<Message>,\n-) {\n-    let message = message.into();\n-    let params = lsp_types::ShowMessageParams { typ, message };\n-    let not = notification_new::<lsp_types::notification::ShowMessage>(params);\n-    sender.send(not.into()).unwrap();\n-}\n+use crate::{from_proto, global_state::GlobalState};\n \n pub(crate) fn is_canceled(e: &(dyn Error + 'static)) -> bool {\n     e.downcast_ref::<Canceled>().is_some()\n@@ -38,6 +27,74 @@ where\n     Notification::new(N::METHOD.to_string(), params)\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n+pub(crate) enum Progress {\n+    Begin,\n+    Report,\n+    End,\n+}\n+\n+impl Progress {\n+    pub(crate) fn percentage(done: usize, total: usize) -> f64 {\n+        (done as f64 / total.max(1) as f64) * 100.0\n+    }\n+}\n+\n+impl GlobalState {\n+    pub(crate) fn show_message(&mut self, typ: lsp_types::MessageType, message: String) {\n+        let message = message.into();\n+        let params = lsp_types::ShowMessageParams { typ, message };\n+        let not = notification_new::<lsp_types::notification::ShowMessage>(params);\n+        self.send(not.into());\n+    }\n+\n+    pub(crate) fn report_progress(\n+        &mut self,\n+        title: &str,\n+        state: Progress,\n+        message: Option<String>,\n+        percentage: Option<f64>,\n+    ) {\n+        if !self.config.client_caps.work_done_progress {\n+            return;\n+        }\n+        let token = lsp_types::ProgressToken::String(format!(\"rustAnalyzer/{}\", title));\n+        let work_done_progress = match state {\n+            Progress::Begin => {\n+                let work_done_progress_create = self.req_queue.outgoing.register(\n+                    lsp_types::request::WorkDoneProgressCreate::METHOD.to_string(),\n+                    lsp_types::WorkDoneProgressCreateParams { token: token.clone() },\n+                    |_, _| (),\n+                );\n+                self.send(work_done_progress_create.into());\n+\n+                lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n+                    title: title.into(),\n+                    cancellable: None,\n+                    message,\n+                    percentage,\n+                })\n+            }\n+            Progress::Report => {\n+                lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n+                    cancellable: None,\n+                    message,\n+                    percentage,\n+                })\n+            }\n+            Progress::End => {\n+                lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd { message })\n+            }\n+        };\n+        let notification =\n+            notification_new::<lsp_types::notification::Progress>(lsp_types::ProgressParams {\n+                token,\n+                value: lsp_types::ProgressParamsValue::WorkDone(work_done_progress),\n+            });\n+        self.send(notification.into());\n+    }\n+}\n+\n pub(crate) fn apply_document_changes(\n     old_text: &mut String,\n     content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,"}, {"sha": "ae3c7e30eb042779717aa2817ab05646876d2fd9", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 11, "deletions": 66, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=fa70882418088271e519c5820ae5cb17557a1f43", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     from_proto,\n     global_state::{file_id_to_url, url_to_file_id, GlobalState, Status},\n     handlers, lsp_ext,\n-    lsp_utils::{apply_document_changes, is_canceled, notification_is, notification_new},\n+    lsp_utils::{apply_document_changes, is_canceled, notification_is, notification_new, Progress},\n     Result,\n };\n \n@@ -181,18 +181,15 @@ impl GlobalState {\n                         became_ready = true;\n                         Progress::End\n                     };\n-                    report_progress(\n-                        self,\n+                    self.report_progress(\n                         \"roots scanned\",\n                         state,\n                         Some(format!(\"{}/{}\", n_done, n_total)),\n-                        Some(percentage(n_done, n_total)),\n+                        Some(Progress::percentage(n_done, n_total)),\n                     )\n                 }\n             },\n             Event::Flycheck(task) => match task {\n-                flycheck::Message::ClearDiagnostics => self.diagnostics.clear_check(),\n-\n                 flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n                     let diagnostics = crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n                         &self.config.diagnostics,\n@@ -215,14 +212,19 @@ impl GlobalState {\n \n                 flycheck::Message::Progress(status) => {\n                     let (state, message) = match status {\n-                        flycheck::Progress::Being => (Progress::Begin, None),\n+                        flycheck::Progress::DidStart => {\n+                            self.diagnostics.clear_check();\n+                            (Progress::Begin, None)\n+                        }\n                         flycheck::Progress::DidCheckCrate(target) => {\n                             (Progress::Report, Some(target))\n                         }\n-                        flycheck::Progress::End => (Progress::End, None),\n+                        flycheck::Progress::DidFinish | flycheck::Progress::DidCancel => {\n+                            (Progress::End, None)\n+                        }\n                     };\n \n-                    report_progress(self, \"cargo check\", state, message, None);\n+                    self.report_progress(\"cargo check\", state, message, None);\n                 }\n             },\n         }\n@@ -465,60 +467,3 @@ impl GlobalState {\n         });\n     }\n }\n-\n-#[derive(Eq, PartialEq)]\n-enum Progress {\n-    Begin,\n-    Report,\n-    End,\n-}\n-\n-fn percentage(done: usize, total: usize) -> f64 {\n-    (done as f64 / total.max(1) as f64) * 100.0\n-}\n-\n-fn report_progress(\n-    global_state: &mut GlobalState,\n-    title: &str,\n-    state: Progress,\n-    message: Option<String>,\n-    percentage: Option<f64>,\n-) {\n-    if !global_state.config.client_caps.work_done_progress {\n-        return;\n-    }\n-    let token = lsp_types::ProgressToken::String(format!(\"rustAnalyzer/{}\", title));\n-    let work_done_progress = match state {\n-        Progress::Begin => {\n-            let work_done_progress_create = global_state.req_queue.outgoing.register(\n-                lsp_types::request::WorkDoneProgressCreate::METHOD.to_string(),\n-                lsp_types::WorkDoneProgressCreateParams { token: token.clone() },\n-                |_, _| (),\n-            );\n-            global_state.send(work_done_progress_create.into());\n-\n-            lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n-                title: title.into(),\n-                cancellable: None,\n-                message,\n-                percentage,\n-            })\n-        }\n-        Progress::Report => {\n-            lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n-                cancellable: None,\n-                message,\n-                percentage,\n-            })\n-        }\n-        Progress::End => {\n-            lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd { message })\n-        }\n-    };\n-    let notification =\n-        notification_new::<lsp_types::notification::Progress>(lsp_types::ProgressParams {\n-            token,\n-            value: lsp_types::ProgressParamsValue::WorkDone(work_done_progress),\n-        });\n-    global_state.send(notification.into());\n-}"}, {"sha": "fece6176e72edf0b497a7c4068848580b5c96188", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70882418088271e519c5820ae5cb17557a1f43/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=fa70882418088271e519c5820ae5cb17557a1f43", "patch": "@@ -36,27 +36,31 @@ impl GlobalState {\n             self.config\n                 .linked_projects\n                 .iter()\n-                .filter_map(|project| match project {\n+                .map(|project| match project {\n                     LinkedProject::ProjectManifest(manifest) => {\n                         ra_project_model::ProjectWorkspace::load(\n                             manifest.clone(),\n                             &self.config.cargo,\n                             self.config.with_sysroot,\n                         )\n-                        .map_err(|err| {\n-                            log::error!(\"failed to load workspace: {:#}\", err);\n-                            self.show_message(\n-                                lsp_types::MessageType::Error,\n-                                format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n-                            );\n-                        })\n-                        .ok()\n                     }\n                     LinkedProject::InlineJsonProject(it) => {\n-                        Some(ra_project_model::ProjectWorkspace::Json { project: it.clone() })\n+                        Ok(ra_project_model::ProjectWorkspace::Json { project: it.clone() })\n                     }\n                 })\n                 .collect::<Vec<_>>()\n+                .into_iter()\n+                .filter_map(|res| {\n+                    res.map_err(|err| {\n+                        log::error!(\"failed to load workspace: {:#}\", err);\n+                        self.show_message(\n+                            lsp_types::MessageType::Error,\n+                            format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n+                        );\n+                    })\n+                    .ok()\n+                })\n+                .collect::<Vec<_>>()\n         };\n \n         if let FilesWatcher::Client = self.config.files.watcher {"}]}