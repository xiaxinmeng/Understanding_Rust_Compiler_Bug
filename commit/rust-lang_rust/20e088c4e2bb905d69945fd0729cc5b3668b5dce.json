{"sha": "20e088c4e2bb905d69945fd0729cc5b3668b5dce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZTA4OGM0ZTJiYjkwNWQ2OTk0NWZkMDcyOWNjNWIzNjY4YjVkY2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-12-23T00:51:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-16T10:22:32Z"}, "message": "fallout from removing the `errors_will_be_reported` flag", "tree": {"sha": "4338a555ec265bb4fcd4314c2e2dd82ef1e43b8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4338a555ec265bb4fcd4314c2e2dd82ef1e43b8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20e088c4e2bb905d69945fd0729cc5b3668b5dce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20e088c4e2bb905d69945fd0729cc5b3668b5dce", "html_url": "https://github.com/rust-lang/rust/commit/20e088c4e2bb905d69945fd0729cc5b3668b5dce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20e088c4e2bb905d69945fd0729cc5b3668b5dce/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c3f0123e9e3da95cf32ba789b11c522ae3c9afc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c3f0123e9e3da95cf32ba789b11c522ae3c9afc", "html_url": "https://github.com/rust-lang/rust/commit/2c3f0123e9e3da95cf32ba789b11c522ae3c9afc"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "f9e78274b4f92062ee3da7b0b4b3560ac57a5d1c", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             None => self.tcx.empty_parameter_environment()\n         };\n \n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env), false);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env));\n \n         f(&mut euv::ExprUseVisitor::new(self, &infcx))\n     }\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_static_type(&self, e: &hir::Expr) {\n         let ty = self.tcx.node_id_to_type(e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None, false);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);"}, {"sha": "7e9a8a28f1f1b09666dc3d5611aadf20774191f9", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -1094,8 +1094,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                         //FIXME: (@jroesch) this code should be floated up as well\n                         let infcx = infer::new_infer_ctxt(cx.tcx,\n                                                           &cx.tcx.tables,\n-                                                          Some(cx.param_env.clone()),\n-                                                          false);\n+                                                          Some(cx.param_env.clone()));\n                         if infcx.type_moves_by_default(pat_ty, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n@@ -1127,8 +1126,7 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n \n     let infcx = infer::new_infer_ctxt(cx.tcx,\n                                       &cx.tcx.tables,\n-                                      Some(checker.cx.param_env.clone()),\n-                                      false);\n+                                      Some(checker.cx.param_env.clone()));\n \n     let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n     visitor.walk_expr(guard);"}, {"sha": "5ead8fb95f8eb98508c283cdfe0e4889e61ac55b", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -44,8 +44,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n             let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n             let infcx = infer::new_infer_ctxt(self.tcx,\n                                               &self.tcx.tables,\n-                                              Some(param_env.clone()),\n-                                              false);\n+                                              Some(param_env.clone()));\n             let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, b);"}, {"sha": "4830fbc74c74838b7f47118de7378e0582837233", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -1247,7 +1247,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                               substs: trait_substs });\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n \n     let mut selcx = traits::SelectionContext::new(&infcx);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),"}, {"sha": "15e368812f25d99a9ec729c68beafeeacd88eeea", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -354,16 +354,9 @@ pub fn fixup_err_to_string(f: FixupError) -> String {\n     }\n }\n \n-/// errors_will_be_reported is required to proxy to the fulfillment context\n-/// FIXME -- a better option would be to hold back on modifying\n-/// the global cache until we know that all dependent obligations\n-/// are also satisfied. In that case, we could actually remove\n-/// this boolean flag, and we'd also avoid the problem of squelching\n-/// duplicate errors that occur across fns.\n pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n                                 tables: &'a RefCell<ty::Tables<'tcx>>,\n-                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>,\n-                                errors_will_be_reported: bool)\n+                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>)\n                                 -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n@@ -373,7 +366,7 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n         float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n         parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n-        fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(errors_will_be_reported)),\n+        fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         reported_trait_errors: RefCell::new(FnvHashSet()),\n         normalize: false,\n         err_count_on_creation: tcx.sess.err_count()\n@@ -383,7 +376,7 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n pub fn normalizing_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n                                         tables: &'a RefCell<ty::Tables<'tcx>>)\n                                         -> InferCtxt<'a, 'tcx> {\n-    let mut infcx = new_infer_ctxt(tcx, tables, None, false);\n+    let mut infcx = new_infer_ctxt(tcx, tables, None);\n     infcx.normalize = true;\n     infcx\n }\n@@ -522,7 +515,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n         return value;\n     }\n \n-    let infcx = new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let infcx = new_infer_ctxt(tcx, &tcx.tables, None);\n     let mut selcx = traits::SelectionContext::new(&infcx);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } ="}, {"sha": "4a92a8a9d580e8077234d7e31fea7455fe533250", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -356,7 +356,7 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n         // this function's result remains infallible, we must confirm\n         // that guess. While imperfect, I believe this is sound.\n \n-        let mut fulfill_cx = FulfillmentContext::new(false);\n+        let mut fulfill_cx = FulfillmentContext::new();\n \n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n@@ -434,8 +434,9 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env), false);\n-    let predicates = match fully_normalize(&infcx, cause,\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env));\n+    let predicates = match fully_normalize(&infcx,\n+                                           cause,\n                                            &infcx.parameter_environment.caller_bounds) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n@@ -444,6 +445,9 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n         }\n     };\n \n+    debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n+           predicates);\n+\n     let free_regions = FreeRegionMap::new();\n     infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n     let predicates = match infcx.fully_resolve(&predicates) {\n@@ -462,6 +466,9 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n         }\n     };\n \n+    debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n+           predicates);\n+\n     infcx.parameter_environment.with_caller_bounds(predicates)\n }\n \n@@ -471,7 +478,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx>\n {\n-    debug!(\"normalize_param_env(value={:?})\", value);\n+    debug!(\"fully_normalize(value={:?})\", value);\n \n     let mut selcx = &mut SelectionContext::new(infcx);\n     // FIXME (@jroesch) ISSUE 26721\n@@ -487,20 +494,28 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     //\n     // I think we should probably land this refactor and then come\n     // back to this is a follow-up patch.\n-    let mut fulfill_cx = FulfillmentContext::new(false);\n+    let mut fulfill_cx = FulfillmentContext::new();\n \n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, cause, value);\n-    debug!(\"normalize_param_env: normalized_value={:?} obligations={:?}\",\n+    debug!(\"fully_normalize: normalized_value={:?} obligations={:?}\",\n            normalized_value,\n            obligations);\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n     }\n \n-    try!(fulfill_cx.select_all_or_error(infcx));\n+    debug!(\"fully_normalize: select_all_or_error start\");\n+    match fulfill_cx.select_all_or_error(infcx) {\n+        Ok(()) => { }\n+        Err(e) => {\n+            debug!(\"fully_normalize: error={:?}\", e);\n+            return Err(e);\n+        }\n+    }\n+    debug!(\"fully_normalize: select_all_or_error complete\");\n     let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n-    debug!(\"normalize_param_env: resolved_value={:?}\", resolved_value);\n+    debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n     Ok(resolved_value)\n }\n "}, {"sha": "03145951367f9bb6b7614bffad966ddcd6aa5dd0", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         // FIXME: (@jroesch) float this code up\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()), false);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()));\n \n         let adt = match self_type.sty {\n             ty::TyStruct(struct_def, substs) => {\n@@ -655,7 +655,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                        -> bool\n     {\n         let tcx = param_env.tcx;\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()), false);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()));\n \n         let is_impld = traits::type_known_to_meet_builtin_bound(&infcx,\n                                                                 self, bound, span);"}, {"sha": "5e8495ceddd970c7fcf4e7363ddc202ec29e8645", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -202,7 +202,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env), false);\n+    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env));\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,"}, {"sha": "8cf10cb9b05a030b8a41f7739a75f493170d1434", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -55,7 +55,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env), false);\n+    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env));\n     {\n         let mut euv = euv::ExprUseVisitor::new(&mut glcx, &infcx);\n         euv.walk_fn(decl, body);\n@@ -525,7 +525,7 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let infcx = infer::new_infer_ctxt(self.bccx.tcx, &self.bccx.tcx.tables, None, false);\n+            let infcx = infer::new_infer_ctxt(self.bccx.tcx, &self.bccx.tcx.tables, None);\n             let mc = mc::MemCategorizationContext::new(&infcx);\n             let base_cmt = mc.cat_expr(&**base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);"}, {"sha": "3886a6b83ac9a00add3f742a137264a38a4a2049", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n \n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n \n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env), true);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env));\n \n         match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n             Ok(mut mir) => {"}, {"sha": "d5f242201892512ce71f85fe74d496b279a8834d", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -42,7 +42,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n \n-    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let mut fulfillment_cx = infcx.fulfillment_cx.borrow_mut();\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n@@ -416,7 +416,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let mut fulfillment_cx = infcx.fulfillment_cx.borrow_mut();\n \n     // The below is for the most part highly similar to the procedure"}, {"sha": "deda0b818ee06d4e90f7af1386de524addf182d4", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -83,7 +83,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(impl_param_env), true);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(impl_param_env));\n \n     let named_type = tcx.lookup_item_type(self_type_did).ty;\n     let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);"}, {"sha": "e9184a12d722d8cf09290bfedeab2887d9886110", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n            -> Inherited<'a, 'tcx> {\n \n         Inherited {\n-            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env), true),\n+            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env)),\n             locals: RefCell::new(NodeMap()),\n             tables: tables,\n             deferred_call_resolutions: RefCell::new(DefIdMap()),"}, {"sha": "7e63fd47d61e15c61bd8163320ecad34dedceaab", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -384,7 +384,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env), true);\n+            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n \n             let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>, mt_b: ty::TypeAndMut<'tcx>,\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n@@ -528,7 +528,7 @@ fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id:\n \n pub fn check_coherence(crate_context: &CrateCtxt) {\n     let _task = crate_context.tcx.dep_graph.in_task(DepNode::Coherence);\n-    let infcx = new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None, true);\n+    let infcx = new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None);\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: infcx,"}, {"sha": "470e954781f8bbb6377fe9c84e63cb23af1ebe0e", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -127,7 +127,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                    impl1_def_id,\n                    impl2_def_id);\n \n-            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None, false);\n+            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n             if let Some(trait_ref) = traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n                 self.report_overlap_error(impl1_def_id, impl2_def_id, trait_ref);\n             }"}, {"sha": "acffbeabb24c13bd68e4efe4b390231922b3725a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20e088c4e2bb905d69945fd0729cc5b3668b5dce/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=20e088c4e2bb905d69945fd0729cc5b3668b5dce", "patch": "@@ -193,7 +193,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n {\n     let result = match maybe_infcx {\n         None => {\n-            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n             infer::mk_eqty(&infcx, t1_is_expected, TypeOrigin::Misc(span), t1, t2)\n         }\n         Some(infcx) => {"}]}