{"sha": "e100ce4f924138725d092ead2f3f22fd945ae8ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMDBjZTRmOTI0MTM4NzI1ZDA5MmVhZDJmM2YyMmZkOTQ1YWU4YWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-01T10:41:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-01T10:41:51Z"}, "message": "Auto merge of #51855 - Eh2406:i51821, r=nikomatsakis\n\nA fix for 51821\n\nThis dedupe the vec of `OutlivesConstraint` using a `FxHashSet<(RegionVid, RegionVid)>` it alsow adds a `struct ConstraintSet` to encapsulate/ensure this behavere.", "tree": {"sha": "06ccaef8b30c3d9a814ebcc1075809296567d817", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06ccaef8b30c3d9a814ebcc1075809296567d817"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e100ce4f924138725d092ead2f3f22fd945ae8ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e100ce4f924138725d092ead2f3f22fd945ae8ac", "html_url": "https://github.com/rust-lang/rust/commit/e100ce4f924138725d092ead2f3f22fd945ae8ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e100ce4f924138725d092ead2f3f22fd945ae8ac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d94b804863f96f4302c0f0414743b5b3ec75f234", "url": "https://api.github.com/repos/rust-lang/rust/commits/d94b804863f96f4302c0f0414743b5b3ec75f234", "html_url": "https://github.com/rust-lang/rust/commit/d94b804863f96f4302c0f0414743b5b3ec75f234"}, {"sha": "ac5bd5dd2b4abd8eb888f14ea01b59028173c0db", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac5bd5dd2b4abd8eb888f14ea01b59028173c0db", "html_url": "https://github.com/rust-lang/rust/commit/ac5bd5dd2b4abd8eb888f14ea01b59028173c0db"}], "stats": {"total": 204, "additions": 137, "deletions": 67}, "files": [{"sha": "4c6e445293d5456bd05bc0be9989435f3b043ea6", "filename": "src/librustc_mir/borrow_check/nll/constraint_set.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs?ref=e100ce4f924138725d092ead2f3f22fd945ae8ac", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::mir::Location;\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+\n+use std::fmt;\n+use syntax_pos::Span;\n+use std::ops::Deref;\n+\n+#[derive(Clone, Default)]\n+crate struct ConstraintSet {\n+    constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n+}\n+\n+impl ConstraintSet {\n+    pub fn push(&mut self, constraint: OutlivesConstraint) {\n+        debug!(\n+            \"add_outlives({:?}: {:?} @ {:?}\",\n+            constraint.sup, constraint.sub, constraint.point\n+        );\n+        if constraint.sup == constraint.sub {\n+            // 'a: 'a is pretty uninteresting\n+            return;\n+        }\n+        self.constraints.push(constraint);\n+    }\n+\n+    /// Once all constraints have been added, `link()` is used to thread together the constraints\n+    /// based on which would be affected when a particular region changes. See the next field of\n+    /// `OutlivesContraint` for more details.\n+    /// link returns a map that is needed later by `each_affected_by_dirty`.\n+    pub fn link(&mut self, len: usize) -> IndexVec<RegionVid, Option<ConstraintIndex>> {\n+        let mut map = IndexVec::from_elem_n(None, len);\n+\n+        for (idx, constraint) in self.constraints.iter_enumerated_mut().rev() {\n+            let mut head = &mut map[constraint.sub];\n+            debug_assert!(constraint.next.is_none());\n+            constraint.next = *head;\n+            *head = Some(idx);\n+        }\n+\n+        map\n+    }\n+\n+    /// When a region R1 changes, we need to reprocess all constraints R2: R1 to take into account\n+    /// any new elements that R1 now has. This method will quickly enumerate all such constraints\n+    /// (that is, constraints where R1 is in the \"subregion\" position).\n+    /// To use it, invoke with `map[R1]` where map is the map returned by `link`;\n+    /// the callback op will be invoked for each affected constraint.\n+    pub fn each_affected_by_dirty(\n+        &self,\n+        mut opt_dep_idx: Option<ConstraintIndex>,\n+        mut op: impl FnMut(ConstraintIndex),\n+    ) {\n+        while let Some(dep_idx) = opt_dep_idx {\n+            op(dep_idx);\n+            opt_dep_idx = self.constraints[dep_idx].next;\n+        }\n+    }\n+}\n+\n+impl Deref for ConstraintSet {\n+    type Target = IndexVec<ConstraintIndex, OutlivesConstraint>;\n+\n+    fn deref(&self) -> &Self::Target { &self.constraints }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct OutlivesConstraint {\n+    // NB. The ordering here is not significant for correctness, but\n+    // it is for convenience. Before we dump the constraints in the\n+    // debugging logs, we sort them, and we'd like the \"super region\"\n+    // to be first, etc. (In particular, span should remain last.)\n+    /// The region SUP must outlive SUB...\n+    pub sup: RegionVid,\n+\n+    /// Region that must be outlived.\n+    pub sub: RegionVid,\n+\n+    /// At this location.\n+    pub point: Location,\n+\n+    /// Later on, we thread the constraints onto a linked list\n+    /// grouped by their `sub` field. So if you had:\n+    ///\n+    /// Index | Constraint | Next Field\n+    /// ----- | ---------- | ----------\n+    /// 0     | `'a: 'b`   | Some(2)\n+    /// 1     | `'b: 'c`   | None\n+    /// 2     | `'c: 'b`   | None\n+    pub next: Option<ConstraintIndex>,\n+\n+    /// Where did this constraint arise?\n+    pub span: Span,\n+}\n+\n+impl fmt::Debug for OutlivesConstraint {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        write!(\n+            formatter,\n+            \"({:?}: {:?} @ {:?}) due to {:?}\",\n+            self.sup, self.sub, self.point, self.span\n+        )\n+    }\n+}\n+\n+newtype_index!(ConstraintIndex { DEBUG_FORMAT = \"ConstraintIndex({})\" });"}, {"sha": "07b160ed66f8ac9da1573dbdb7aacdbb23e75459", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=e100ce4f924138725d092ead2f3f22fd945ae8ac", "patch": "@@ -45,6 +45,8 @@ mod renumber;\n crate mod type_check;\n mod universal_regions;\n \n+crate mod constraint_set;\n+\n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;"}, {"sha": "106dd003ceab9fb902621cec8e7ec281dc4d083c", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=e100ce4f924138725d092ead2f3f22fd945ae8ac", "patch": "@@ -17,6 +17,8 @@ use rustc_data_structures::indexed_vec::Idx;\n use std::borrow::Cow;\n use std::io::{self, Write};\n use super::*;\n+use borrow_check::nll::constraint_set::OutlivesConstraint;\n+\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Write out the region constraint graph."}, {"sha": "a576dc5f7f47b0a1f323e9cd6fb8348a8db006f5", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 9, "deletions": 62, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=e100ce4f924138725d092ead2f3f22fd945ae8ac", "patch": "@@ -10,6 +10,7 @@\n \n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::region_infer::values::ToElementIndex;\n+use borrow_check::nll::constraint_set::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n@@ -25,7 +26,6 @@ use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use std::fmt;\n use std::rc::Rc;\n use syntax_pos::Span;\n \n@@ -65,7 +65,7 @@ pub struct RegionInferenceContext<'tcx> {\n     dependency_map: Option<IndexVec<RegionVid, Option<ConstraintIndex>>>,\n \n     /// The constraints we have accumulated and used during solving.\n-    constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n+    constraints: ConstraintSet,\n \n     /// Type constraints that we check after solving.\n     type_tests: Vec<TypeTest<'tcx>>,\n@@ -114,37 +114,6 @@ pub(crate) enum Cause {\n     UniversalRegion(RegionVid),\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct OutlivesConstraint {\n-    // NB. The ordering here is not significant for correctness, but\n-    // it is for convenience. Before we dump the constraints in the\n-    // debugging logs, we sort them, and we'd like the \"super region\"\n-    // to be first, etc. (In particular, span should remain last.)\n-    /// The region SUP must outlive SUB...\n-    pub sup: RegionVid,\n-\n-    /// Region that must be outlived.\n-    pub sub: RegionVid,\n-\n-    /// At this location.\n-    pub point: Location,\n-\n-    /// Later on, we thread the constraints onto a linked list\n-    /// grouped by their `sub` field. So if you had:\n-    ///\n-    /// Index | Constraint | Next Field\n-    /// ----- | ---------- | ----------\n-    /// 0     | `'a: 'b`   | Some(2)\n-    /// 1     | `'b: 'c`   | None\n-    /// 2     | `'c: 'b`   | None\n-    pub next: Option<ConstraintIndex>,\n-\n-    /// Where did this constraint arise?\n-    pub span: Span,\n-}\n-\n-newtype_index!(ConstraintIndex { DEBUG_FORMAT = \"ConstraintIndex({})\" });\n-\n /// A \"type test\" corresponds to an outlives constraint between a type\n /// and a lifetime, like `T: 'x` or `<T as Foo>::Bar: 'x`.  They are\n /// translated from the `Verify` region constraints in the ordinary\n@@ -243,7 +212,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         var_infos: VarInfos,\n         universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n-        outlives_constraints: Vec<OutlivesConstraint>,\n+        outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n     ) -> Self {\n         // The `next` field should not yet have been initialized:\n@@ -266,7 +235,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n             dependency_map: None,\n-            constraints: IndexVec::from_raw(outlives_constraints),\n+            constraints: outlives_constraints,\n             type_tests,\n             universal_regions,\n         };\n@@ -392,15 +361,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         sub: RegionVid,\n         point: Location,\n     ) {\n-        debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n         self.constraints.push(OutlivesConstraint {\n             span,\n             sup,\n             sub,\n             point,\n             next: None,\n-        });\n+        })\n     }\n \n     /// Perform region inference and report errors if we see any\n@@ -498,13 +466,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n                 debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n \n-                let mut opt_dep_idx = dependency_map[constraint.sup];\n-                while let Some(dep_idx) = opt_dep_idx {\n+                self.constraints.each_affected_by_dirty(dependency_map[constraint.sup], |dep_idx| {\n                     if clean_bit_vec.remove(dep_idx.index()) {\n                         dirty_list.push(dep_idx);\n                     }\n-                    opt_dep_idx = self.constraints[dep_idx].next;\n-                }\n+                });\n             }\n \n             debug!(\"\\n\");\n@@ -518,16 +484,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// These are constraints like Y: X @ P -- so if X changed, we may\n     /// need to grow Y.\n     fn build_dependency_map(&mut self) -> IndexVec<RegionVid, Option<ConstraintIndex>> {\n-        let mut map = IndexVec::from_elem(None, &self.definitions);\n-\n-        for (idx, constraint) in self.constraints.iter_enumerated_mut().rev() {\n-            let mut head = &mut map[constraint.sub];\n-            debug_assert!(constraint.next.is_none());\n-            constraint.next = *head;\n-            *head = Some(idx);\n-        }\n-\n-        map\n+        self.constraints.link(self.definitions.len())\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -1115,7 +1072,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         while changed {\n             changed = false;\n-            for constraint in &self.constraints {\n+            for constraint in self.constraints.iter() {\n                 if let Some(n) = result_set[constraint.sup] {\n                     let m = n + 1;\n                     if result_set[constraint.sub]\n@@ -1146,16 +1103,6 @@ impl<'tcx> RegionDefinition<'tcx> {\n     }\n }\n \n-impl fmt::Debug for OutlivesConstraint {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-        write!(\n-            formatter,\n-            \"({:?}: {:?} @ {:?}) due to {:?}\",\n-            self.sup, self.sub, self.point, self.span\n-        )\n-    }\n-}\n-\n pub trait ClosureRegionRequirementsExt<'gcx, 'tcx> {\n     fn apply_requirements(\n         &self,"}, {"sha": "3100df3e8f629aa19dd606ba9fe35b2849c0d236", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=e100ce4f924138725d092ead2f3f22fd945ae8ac", "patch": "@@ -9,10 +9,12 @@\n // except according to those terms.\n \n use borrow_check::location::LocationTable;\n+use borrow_check::nll::constraint_set::OutlivesConstraint;\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::{OutlivesConstraint, RegionTest, TypeTest};\n+use borrow_check::nll::region_infer::{RegionTest, TypeTest};\n use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::constraint_set::ConstraintSet;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n@@ -31,7 +33,7 @@ crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n-    outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n+    outlives_constraints: &'a mut ConstraintSet,\n     type_tests: &'a mut Vec<TypeTest<'tcx>>,\n     all_facts: &'a mut Option<AllFacts>,\n }\n@@ -46,7 +48,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n-        outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n+        outlives_constraints: &'a mut ConstraintSet,\n         type_tests: &'a mut Vec<TypeTest<'tcx>>,\n         all_facts: &'a mut Option<AllFacts>,\n     ) -> Self {"}, {"sha": "611050a406020e87e65ea77efc90ec9035062f9a", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e100ce4f924138725d092ead2f3f22fd945ae8ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=e100ce4f924138725d092ead2f3f22fd945ae8ac", "patch": "@@ -12,9 +12,10 @@\n #![allow(unreachable_code)]\n \n use borrow_check::location::LocationTable;\n+use borrow_check::nll::constraint_set::ConstraintSet;\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::Cause;\n-use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, OutlivesConstraint, TypeTest};\n+use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -621,7 +622,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// hence it must report on their liveness constraints.\n     crate liveness_set: Vec<(ty::Region<'tcx>, Location, Cause)>,\n \n-    crate outlives_constraints: Vec<OutlivesConstraint>,\n+    crate outlives_constraints: ConstraintSet,\n \n     crate type_tests: Vec<TypeTest<'tcx>>,\n }"}]}