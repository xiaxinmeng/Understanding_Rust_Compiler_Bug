{"sha": "b0f6d8868ca33a9907e372de2a2f868c3ef8d00c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZjZkODg2OGNhMzNhOTkwN2UzNzJkZTJhMmY4NjhjM2VmOGQwMGM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-04T11:47:39Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-04T11:47:39Z"}, "message": "Reorganize inlay_hints tests", "tree": {"sha": "19b100a5f930a8739c8a89506782d306ff935129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19b100a5f930a8739c8a89506782d306ff935129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0f6d8868ca33a9907e372de2a2f868c3ef8d00c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0f6d8868ca33a9907e372de2a2f868c3ef8d00c", "html_url": "https://github.com/rust-lang/rust/commit/b0f6d8868ca33a9907e372de2a2f868c3ef8d00c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0f6d8868ca33a9907e372de2a2f868c3ef8d00c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14153671caaca852c94bd1d0d7f279acb8eb1913", "url": "https://api.github.com/repos/rust-lang/rust/commits/14153671caaca852c94bd1d0d7f279acb8eb1913", "html_url": "https://github.com/rust-lang/rust/commit/14153671caaca852c94bd1d0d7f279acb8eb1913"}], "stats": {"total": 1159, "additions": 565, "deletions": 594}, "files": [{"sha": "9f2f6c80a596c6f72ca81d08cbf5b490ad089107", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 565, "deletions": 594, "changes": 1159, "blob_url": "https://github.com/rust-lang/rust/blob/b0f6d8868ca33a9907e372de2a2f868c3ef8d00c/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f6d8868ca33a9907e372de2a2f868c3ef8d00c/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=b0f6d8868ca33a9907e372de2a2f868c3ef8d00c", "patch": "@@ -299,9 +299,8 @@ fn should_not_display_type_hint(\n                     // Type of expr should be iterable.\n                     return it.in_token().is_none() ||\n                         it.iterable()\n-                            .and_then(|iterable_expr|sema.type_of_expr(&iterable_expr))\n-                            .map(|iterable_ty| iterable_ty.is_unknown() || iterable_ty.is_unit())\n-                            .unwrap_or(true)\n+                            .and_then(|iterable_expr| sema.type_of_expr(&iterable_expr))\n+                            .map_or(true, |iterable_ty| iterable_ty.is_unknown() || iterable_ty.is_unit())\n                 },\n                 _ => (),\n             }\n@@ -319,8 +318,8 @@ fn should_hide_param_name_hint(\n     // hide when:\n     // - the parameter name is a suffix of the function's name\n     // - the argument is an enum whose name is equal to the parameter\n-    // - exact argument<->parameter match(ignoring leading underscore) or argument is a prefix/suffix\n-    //   of parameter with _ splitting it off\n+    // - exact argument<->parameter match(ignoring leading underscore) or parameter is a prefix/suffix\n+    //   of argument with _ splitting it off\n     // - param starts with `ra_fixture`\n     // - param is a well known name in an unary function\n \n@@ -342,23 +341,22 @@ fn should_hide_param_name_hint(\n }\n \n fn is_argument_similar_to_param_name(argument: &ast::Expr, param_name: &str) -> bool {\n-    match get_string_representation(argument) {\n-        None => false,\n-        Some(argument) => {\n-            let mut res = false;\n-            if let Some(first) = argument.bytes().skip_while(|&c| c == b'_').position(|c| c == b'_')\n-            {\n-                res |= param_name == argument[..first].trim_start_matches('_');\n-            }\n-            if let Some(last) =\n-                argument.bytes().rev().skip_while(|&c| c == b'_').position(|c| c == b'_')\n-            {\n-                res |= param_name == argument[last..].trim_end_matches('_');\n-            }\n-            res |= argument == param_name;\n-            res\n-        }\n+    // check whether param_name and argument are the same or\n+    // whether param_name is a prefix/suffix of argument(split at `_`)\n+    let argument = match get_string_representation(argument) {\n+        Some(argument) => argument,\n+        None => return false,\n+    };\n+\n+    let param_name = param_name.trim_start_matches('_');\n+    let argument = argument.trim_start_matches('_');\n+    if argument.strip_prefix(param_name).map_or(false, |s| s.starts_with('_')) {\n+        return true;\n+    }\n+    if argument.strip_suffix(param_name).map_or(false, |s| s.ends_with('_')) {\n+        return true;\n     }\n+    argument == param_name\n }\n \n /// Hide the parameter name of an unary function if it is a `_` - prefixed suffix of the function's name, or equal.\n@@ -451,6 +449,42 @@ mod tests {\n         check_with_config(TEST_CONFIG, ra_fixture);\n     }\n \n+    fn check_params(ra_fixture: &str) {\n+        check_with_config(\n+            InlayHintsConfig {\n+                parameter_hints: true,\n+                type_hints: false,\n+                chaining_hints: false,\n+                max_length: None,\n+            },\n+            ra_fixture,\n+        );\n+    }\n+\n+    fn check_types(ra_fixture: &str) {\n+        check_with_config(\n+            InlayHintsConfig {\n+                parameter_hints: false,\n+                type_hints: true,\n+                chaining_hints: false,\n+                max_length: None,\n+            },\n+            ra_fixture,\n+        );\n+    }\n+\n+    fn check_chains(ra_fixture: &str) {\n+        check_with_config(\n+            InlayHintsConfig {\n+                parameter_hints: false,\n+                type_hints: false,\n+                chaining_hints: true,\n+                max_length: None,\n+            },\n+            ra_fixture,\n+        );\n+    }\n+\n     fn check_with_config(config: InlayHintsConfig, ra_fixture: &str) {\n         let ra_fixture =\n             format!(\"//- /main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n@@ -471,16 +505,27 @@ mod tests {\n     }\n \n     #[test]\n-    fn param_hints_only() {\n+    fn hints_disabled() {\n         check_with_config(\n             InlayHintsConfig {\n-                parameter_hints: true,\n                 type_hints: false,\n+                parameter_hints: false,\n                 chaining_hints: false,\n                 max_length: None,\n             },\n             r#\"\n fn foo(a: i32, b: i32) -> i32 { a + b }\n+fn main() {\n+    let _x = foo(4, 4);\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_hints_only() {\n+        check_params(\n+            r#\"\n+fn foo(a: i32, b: i32) -> i32 { a + b }\n fn main() {\n     let _x = foo(\n         4,\n@@ -494,13 +539,7 @@ fn main() {\n \n     #[test]\n     fn param_name_similar_to_fn_name_still_hints() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                parameter_hints: true,\n-                type_hints: false,\n-                chaining_hints: false,\n-                max_length: None,\n-            },\n+        check_params(\n             r#\"\n fn max(x: i32, y: i32) -> i32 { x + y }\n fn main() {\n@@ -516,13 +555,7 @@ fn main() {\n \n     #[test]\n     fn param_name_similar_to_fn_name() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                parameter_hints: true,\n-                type_hints: false,\n-                chaining_hints: false,\n-                max_length: None,\n-            },\n+        check_params(\n             r#\"\n fn param_with_underscore(with_underscore: i32) -> i32 { with_underscore }\n fn main() {\n@@ -535,13 +568,7 @@ fn main() {\n \n     #[test]\n     fn param_name_same_as_fn_name() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                parameter_hints: true,\n-                type_hints: false,\n-                chaining_hints: false,\n-                max_length: None,\n-            },\n+        check_params(\n             r#\"\n fn foo(foo: i32) -> i32 { foo }\n fn main() {\n@@ -554,13 +581,7 @@ fn main() {\n \n     #[test]\n     fn never_hide_param_when_multiple_params() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                parameter_hints: true,\n-                type_hints: false,\n-                chaining_hints: false,\n-                max_length: None,\n-            },\n+        check_params(\n             r#\"\n fn foo(bar: i32, baz: i32) -> i32 { bar + baz }\n fn main() {\n@@ -575,285 +596,132 @@ fn main() {\n     }\n \n     #[test]\n-    fn hints_disabled() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                type_hints: false,\n-                parameter_hints: false,\n-                chaining_hints: false,\n-                max_length: None,\n-            },\n+    fn hide_param_hints_for_clones() {\n+        check_params(\n             r#\"\n-fn foo(a: i32, b: i32) -> i32 { a + b }\n+fn foo(bar: i32, baz: String, qux: f32) {}\n+\n fn main() {\n-    let _x = foo(4, 4);\n-}\"#,\n+    let bar = 3;\n+    let baz = &\"baz\";\n+    let fez = 1.0;\n+    foo(bar.clone(), baz.clone(), fez.clone());\n+                                //^^^^^^^^^^^ qux\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn type_hints_only() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                type_hints: true,\n-                parameter_hints: false,\n-                chaining_hints: false,\n-                max_length: None,\n-            },\n+    fn self_param_hints() {\n+        check_params(\n             r#\"\n-fn foo(a: i32, b: i32) -> i32 { a + b }\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(self: Self) {}\n+    fn bar(self: &Self) {}\n+}\n+\n fn main() {\n-    let _x = foo(4, 4);\n-      //^^ i32\n-}\"#,\n-        );\n+    Foo::foo(Foo);\n+           //^^^ self\n+    Foo::bar(&Foo);\n+           //^^^^ self\n+}\n+\"#,\n+        )\n     }\n \n     #[test]\n-    fn default_generic_types_should_not_be_displayed() {\n-        check(\n-            r#\"\n-struct Test<K, T = u8> { k: K, t: T }\n-\n+    fn param_name_hints_show_for_literals() {\n+        check_params(\n+            r#\"pub fn test(a: i32, b: i32) -> [i32; 2] { [a, b] }\n fn main() {\n-    let zz = Test { t: 23u8, k: 33 };\n-      //^^ Test<i32>\n-    let zz_ref = &zz;\n-      //^^^^^^ &Test<i32>\n-    let test = || zz;\n-      //^^^^ || -> Test<i32>\n+    test(\n+        0x0fab272b,\n+      //^^^^^^^^^^ a\n+        0x0fab272b\n+      //^^^^^^^^^^ b\n+    );\n }\"#,\n-        );\n+        )\n     }\n \n     #[test]\n-    fn let_statement() {\n+    fn function_call_parameter_hint() {\n         check(\n             r#\"\n-#[derive(PartialEq)]\n enum Option<T> { None, Some(T) }\n+use Option::*;\n \n-#[derive(PartialEq)]\n-struct Test { a: Option<u32>, b: u8 }\n+struct FileId {}\n+struct SmolStr {}\n \n-fn main() {\n-    struct InnerStruct {}\n+struct TextRange {}\n+struct SyntaxKind {}\n+struct NavigationTarget {}\n \n-    let test = 54;\n-      //^^^^ i32\n-    let test: i32 = 33;\n-    let mut test = 33;\n-      //^^^^^^^^ i32\n-    let _ = 22;\n-    let test = \"test\";\n-      //^^^^ &str\n-    let test = InnerStruct {};\n-      //^^^^ InnerStruct\n+struct Test {}\n \n-    let test = unresolved();\n+impl Test {\n+    fn method(&self, mut param: i32) -> i32 { param * 2 }\n \n-    let test = (42, 'a');\n-      //^^^^ (i32, char)\n-    let (a,    (b,     (c,)) = (2, (3, (9.2,));\n-       //^ i32  ^ i32   ^ f64\n-    let &x = &92;\n-       //^ i32\n-}\"#,\n-        );\n+    fn from_syntax(\n+        file_id: FileId,\n+        name: SmolStr,\n+        focus_range: Option<TextRange>,\n+        full_range: TextRange,\n+        kind: SyntaxKind,\n+        docs: Option<String>,\n+    ) -> NavigationTarget {\n+        NavigationTarget {}\n     }\n+}\n \n-    #[test]\n-    fn closure_parameters() {\n-        check(\n-            r#\"\n-fn main() {\n-    let mut start = 0;\n-      //^^^^^^^^^ i32\n-    (0..2).for_each(|increment| { start += increment; });\n-                   //^^^^^^^^^ i32\n-\n-    let multiply =\n-      //^^^^^^^^ |\u2026| -> i32\n-      | a,     b| a * b\n-      //^ i32  ^ i32\n-    ;\n-\n-    let _: i32 = multiply(1, 2);\n-    let multiply_ref = &multiply;\n-      //^^^^^^^^^^^^ &|\u2026| -> i32\n+fn test_func(mut foo: i32, bar: i32, msg: &str, _: i32, last: i32) -> i32 {\n+    foo + bar\n+}\n \n-    let return_42 = || 42;\n-      //^^^^^^^^^ || -> i32\n+fn main() {\n+    let not_literal = 1;\n+      //^^^^^^^^^^^ i32\n+    let _: i32 = test_func(1,    2,      \"hello\", 3,  not_literal);\n+                         //^ foo ^ bar   ^^^^^^^ msg  ^^^^^^^^^^^ last\n+    let t: Test = Test {};\n+    t.method(123);\n+           //^^^ param\n+    Test::method(&t,      3456);\n+               //^^ self  ^^^^ param\n+    Test::from_syntax(\n+        FileId {},\n+      //^^^^^^^^^ file_id\n+        \"impl\".into(),\n+      //^^^^^^^^^^^^^ name\n+        None,\n+      //^^^^ focus_range\n+        TextRange {},\n+      //^^^^^^^^^^^^ full_range\n+        SyntaxKind {},\n+      //^^^^^^^^^^^^^ kind\n+        None,\n+      //^^^^ docs\n+    );\n }\"#,\n         );\n     }\n \n     #[test]\n-    fn if_expr() {\n-        check(\n+    fn omitted_parameters_hints_heuristics() {\n+        check_with_config(\n+            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n             r#\"\n-enum Option<T> { None, Some(T) }\n-use Option::*;\n+fn map(f: i32) {}\n+fn filter(predicate: i32) {}\n \n-struct Test { a: Option<u32>, b: u8 }\n-\n-fn main() {\n-    let test = Some(Test { a: Some(3), b: 1 });\n-      //^^^^ Option<Test>\n-    if let None = &test {};\n-    if let test = &test {};\n-         //^^^^ &Option<Test>\n-    if let Some(test) = &test {};\n-              //^^^^ &Test\n-    if let Some(Test { a,             b }) = &test {};\n-                     //^ &Option<u32> ^ &u8\n-    if let Some(Test { a: x,             b: y }) = &test {};\n-                        //^ &Option<u32>    ^ &u8\n-    if let Some(Test { a: Some(x),  b: y }) = &test {};\n-                             //^ &u32  ^ &u8\n-    if let Some(Test { a: None,  b: y }) = &test {};\n-                                  //^ &u8\n-    if let Some(Test { b: y, .. }) = &test {};\n-                        //^ &u8\n-    if test == None {}\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn while_expr() {\n-        check(\n-            r#\"\n-enum Option<T> { None, Some(T) }\n-use Option::*;\n-\n-struct Test { a: Option<u32>, b: u8 }\n-\n-fn main() {\n-    let test = Some(Test { a: Some(3), b: 1 });\n-      //^^^^ Option<Test>\n-    while let Some(Test { a: Some(x),  b: y }) = &test {};\n-                                //^ &u32  ^ &u8\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn match_arm_list() {\n-        check(\n-            r#\"\n-enum Option<T> { None, Some(T) }\n-use Option::*;\n-\n-struct Test { a: Option<u32>, b: u8 }\n-\n-fn main() {\n-    match Some(Test { a: Some(3), b: 1 }) {\n-        None => (),\n-        test => (),\n-      //^^^^ Option<Test>\n-        Some(Test { a: Some(x), b: y }) => (),\n-                          //^ u32  ^ u8\n-        _ => {}\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn hint_truncation() {\n-        check_with_config(\n-            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n-            r#\"\n-struct Smol<T>(T);\n-\n-struct VeryLongOuterName<T>(T);\n-\n-fn main() {\n-    let a = Smol(0u32);\n-      //^ Smol<u32>\n-    let b = VeryLongOuterName(0usize);\n-      //^ VeryLongOuterName<\u2026>\n-    let c = Smol(Smol(0u32))\n-      //^ Smol<Smol<\u2026>>\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn function_call_parameter_hint() {\n-        check(\n-            r#\"\n-enum Option<T> { None, Some(T) }\n-use Option::*;\n-\n-struct FileId {}\n-struct SmolStr {}\n-\n-struct TextRange {}\n-struct SyntaxKind {}\n-struct NavigationTarget {}\n-\n-struct Test {}\n-\n-impl Test {\n-    fn method(&self, mut param: i32) -> i32 { param * 2 }\n-\n-    fn from_syntax(\n-        file_id: FileId,\n-        name: SmolStr,\n-        focus_range: Option<TextRange>,\n-        full_range: TextRange,\n-        kind: SyntaxKind,\n-        docs: Option<String>,\n-    ) -> NavigationTarget {\n-        NavigationTarget {}\n-    }\n-}\n-\n-fn test_func(mut foo: i32, bar: i32, msg: &str, _: i32, last: i32) -> i32 {\n-    foo + bar\n-}\n-\n-fn main() {\n-    let not_literal = 1;\n-      //^^^^^^^^^^^ i32\n-    let _: i32 = test_func(1,    2,      \"hello\", 3,  not_literal);\n-                         //^ foo ^ bar   ^^^^^^^ msg  ^^^^^^^^^^^ last\n-    let t: Test = Test {};\n-    t.method(123);\n-           //^^^ param\n-    Test::method(&t,      3456);\n-               //^^ self  ^^^^ param\n-    Test::from_syntax(\n-        FileId {},\n-      //^^^^^^^^^ file_id\n-        \"impl\".into(),\n-      //^^^^^^^^^^^^^ name\n-        None,\n-      //^^^^ focus_range\n-        TextRange {},\n-      //^^^^^^^^^^^^ full_range\n-        SyntaxKind {},\n-      //^^^^^^^^^^^^^ kind\n-        None,\n-      //^^^^ docs\n-    );\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn omitted_parameters_hints_heuristics() {\n-        check_with_config(\n-            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n-            r#\"\n-fn map(f: i32) {}\n-fn filter(predicate: i32) {}\n-\n-struct TestVarContainer {\n-    test_var: i32,\n-}\n+struct TestVarContainer {\n+    test_var: i32,\n+}\n \n impl TestVarContainer {\n     fn test_var(&self) -> i32 {\n@@ -939,179 +807,255 @@ fn main() {\n         );\n     }\n \n+    // Type-Hint tests\n+\n     #[test]\n-    fn unit_structs_have_no_type_hints() {\n-        check_with_config(\n-            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n+    fn type_hints_only() {\n+        check_types(\n             r#\"\n-enum Result<T, E> { Ok(T), Err(E) }\n-use Result::*;\n-\n-struct SyntheticSyntax;\n-\n+fn foo(a: i32, b: i32) -> i32 { a + b }\n fn main() {\n-    match Ok(()) {\n-        Ok(_) => (),\n-        Err(SyntheticSyntax) => (),\n-    }\n+    let _x = foo(4, 4);\n+      //^^ i32\n }\"#,\n         );\n     }\n \n     #[test]\n-    fn chaining_hints_ignore_comments() {\n-        check_expect(\n-            InlayHintsConfig {\n-                parameter_hints: false,\n-                type_hints: false,\n-                chaining_hints: true,\n-                max_length: None,\n-            },\n+    fn default_generic_types_should_not_be_displayed() {\n+        check(\n             r#\"\n-struct A(B);\n-impl A { fn into_b(self) -> B { self.0 } }\n-struct B(C);\n-impl B { fn into_c(self) -> C { self.0 } }\n-struct C;\n+struct Test<K, T = u8> { k: K, t: T }\n \n fn main() {\n-    let c = A(B(C))\n-        .into_b() // This is a comment\n-        // This is another comment\n-        .into_c();\n-}\n-\"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 148..173,\n-                        kind: ChainingHint,\n-                        label: \"B\",\n-                    },\n-                    InlayHint {\n-                        range: 148..155,\n-                        kind: ChainingHint,\n-                        label: \"A\",\n-                    },\n-                ]\n-            \"#]],\n+    let zz = Test { t: 23u8, k: 33 };\n+      //^^ Test<i32>\n+    let zz_ref = &zz;\n+      //^^^^^^ &Test<i32>\n+    let test = || zz;\n+      //^^^^ || -> Test<i32>\n+}\"#,\n         );\n     }\n \n     #[test]\n-    fn chaining_hints_without_newlines() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                parameter_hints: false,\n-                type_hints: false,\n-                chaining_hints: true,\n-                max_length: None,\n-            },\n+    fn shorten_iterators_in_associated_params() {\n+        check_types(\n             r#\"\n-struct A(B);\n-impl A { fn into_b(self) -> B { self.0 } }\n-struct B(C);\n-impl B { fn into_c(self) -> C { self.0 } }\n-struct C;\n+use core::iter;\n+\n+pub struct SomeIter<T> {}\n+\n+impl<T> SomeIter<T> {\n+    pub fn new() -> Self { SomeIter {} }\n+    pub fn push(&mut self, t: T) {}\n+}\n+\n+impl<T> Iterator for SomeIter<T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n \n fn main() {\n-    let c = A(B(C)).into_b().into_c();\n-}\"#,\n+    let mut some_iter = SomeIter::new();\n+      //^^^^^^^^^^^^^ SomeIter<Take<Repeat<i32>>>\n+      some_iter.push(iter::repeat(2).take(2));\n+    let iter_of_iters = some_iter.take(2);\n+      //^^^^^^^^^^^^^ impl Iterator<Item = impl Iterator<Item = i32>>\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn struct_access_chaining_hints() {\n-        check_expect(\n-            InlayHintsConfig {\n-                parameter_hints: false,\n-                type_hints: false,\n-                chaining_hints: true,\n-                max_length: None,\n-            },\n+    fn infer_call_method_return_associated_types_with_generic() {\n+        check_types(\n             r#\"\n-struct A { pub b: B }\n-struct B { pub c: C }\n-struct C(pub bool);\n-struct D;\n+            pub trait Default {\n+                fn default() -> Self;\n+            }\n+            pub trait Foo {\n+                type Bar: Default;\n+            }\n \n-impl D {\n-    fn foo(&self) -> i32 { 42 }\n+            pub fn quux<T: Foo>() -> T::Bar {\n+                let y = Default::default();\n+                  //^ <T as Foo>::Bar\n+\n+                y\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fn_hints() {\n+        check_types(\n+            r#\"\n+trait Sized {}\n+\n+fn foo() -> impl Fn() { loop {} }\n+fn foo1() -> impl Fn(f64) { loop {} }\n+fn foo2() -> impl Fn(f64, f64) { loop {} }\n+fn foo3() -> impl Fn(f64, f64) -> u32 { loop {} }\n+fn foo4() -> &'static dyn Fn(f64, f64) -> u32 { loop {} }\n+fn foo5() -> &'static dyn Fn(&'static dyn Fn(f64, f64) -> u32, f64) -> u32 { loop {} }\n+fn foo6() -> impl Fn(f64, f64) -> u32 + Sized { loop {} }\n+fn foo7() -> *const (impl Fn(f64, f64) -> u32 + Sized) { loop {} }\n+\n+fn main() {\n+    let foo = foo();\n+     // ^^^ impl Fn()\n+    let foo = foo1();\n+     // ^^^ impl Fn(f64)\n+    let foo = foo2();\n+     // ^^^ impl Fn(f64, f64)\n+    let foo = foo3();\n+     // ^^^ impl Fn(f64, f64) -> u32\n+    let foo = foo4();\n+     // ^^^ &dyn Fn(f64, f64) -> u32\n+    let foo = foo5();\n+     // ^^^ &dyn Fn(&dyn Fn(f64, f64) -> u32, f64) -> u32\n+    let foo = foo6();\n+     // ^^^ impl Fn(f64, f64) -> u32 + Sized\n+    let foo = foo7();\n+     // ^^^ *const (impl Fn(f64, f64) -> u32 + Sized)\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unit_structs_have_no_type_hints() {\n+        check_types(\n+            r#\"\n+enum Result<T, E> { Ok(T), Err(E) }\n+use Result::*;\n+\n+struct SyntheticSyntax;\n \n fn main() {\n-    let x = A { b: B { c: C(true) } }\n-        .b\n-        .c\n-        .0;\n-    let x = D\n-        .foo();\n+    match Ok(()) {\n+        Ok(_) => (),\n+        Err(SyntheticSyntax) => (),\n+    }\n }\"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 144..191,\n-                        kind: ChainingHint,\n-                        label: \"C\",\n-                    },\n-                    InlayHint {\n-                        range: 144..180,\n-                        kind: ChainingHint,\n-                        label: \"B\",\n-                    },\n-                ]\n-            \"#]],\n         );\n     }\n \n     #[test]\n-    fn generic_chaining_hints() {\n-        check_expect(\n-            InlayHintsConfig {\n-                parameter_hints: false,\n-                type_hints: false,\n-                chaining_hints: true,\n-                max_length: None,\n-            },\n+    fn let_statement() {\n+        check_types(\n             r#\"\n-struct A<T>(T);\n-struct B<T>(T);\n-struct C<T>(T);\n-struct X<T,R>(T, R);\n+#[derive(PartialEq)]\n+enum Option<T> { None, Some(T) }\n+\n+#[derive(PartialEq)]\n+struct Test { a: Option<u32>, b: u8 }\n \n-impl<T> A<T> {\n-    fn new(t: T) -> Self { A(t) }\n-    fn into_b(self) -> B<T> { B(self.0) }\n-}\n-impl<T> B<T> {\n-    fn into_c(self) -> C<T> { C(self.0) }\n-}\n fn main() {\n-    let c = A::new(X(42, true))\n-        .into_b()\n-        .into_c();\n-}\n-\"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 247..284,\n-                        kind: ChainingHint,\n-                        label: \"B<X<i32, bool>>\",\n-                    },\n-                    InlayHint {\n-                        range: 247..266,\n-                        kind: ChainingHint,\n-                        label: \"A<X<i32, bool>>\",\n-                    },\n-                ]\n-            \"#]],\n+    struct InnerStruct {}\n+\n+    let test = 54;\n+      //^^^^ i32\n+    let test: i32 = 33;\n+    let mut test = 33;\n+      //^^^^^^^^ i32\n+    let _ = 22;\n+    let test = \"test\";\n+      //^^^^ &str\n+    let test = InnerStruct {};\n+      //^^^^ InnerStruct\n+\n+    let test = unresolved();\n+\n+    let test = (42, 'a');\n+      //^^^^ (i32, char)\n+    let (a,    (b,     (c,)) = (2, (3, (9.2,));\n+       //^ i32  ^ i32   ^ f64\n+    let &x = &92;\n+       //^ i32\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn if_expr() {\n+        check_types(\n+            r#\"\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n+\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    let test = Some(Test { a: Some(3), b: 1 });\n+      //^^^^ Option<Test>\n+    if let None = &test {};\n+    if let test = &test {};\n+         //^^^^ &Option<Test>\n+    if let Some(test) = &test {};\n+              //^^^^ &Test\n+    if let Some(Test { a,             b }) = &test {};\n+                     //^ &Option<u32> ^ &u8\n+    if let Some(Test { a: x,             b: y }) = &test {};\n+                        //^ &Option<u32>    ^ &u8\n+    if let Some(Test { a: Some(x),  b: y }) = &test {};\n+                             //^ &u32  ^ &u8\n+    if let Some(Test { a: None,  b: y }) = &test {};\n+                                  //^ &u8\n+    if let Some(Test { b: y, .. }) = &test {};\n+                        //^ &u8\n+    if test == None {}\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn while_expr() {\n+        check_types(\n+            r#\"\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n+\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    let test = Some(Test { a: Some(3), b: 1 });\n+      //^^^^ Option<Test>\n+    while let Some(Test { a: Some(x),  b: y }) = &test {};\n+                                //^ &u32  ^ &u8\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_arm_list() {\n+        check_types(\n+            r#\"\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n+\n+struct Test { a: Option<u32>, b: u8 }\n+\n+fn main() {\n+    match Some(Test { a: Some(3), b: 1 }) {\n+        None => (),\n+        test => (),\n+      //^^^^ Option<Test>\n+        Some(Test { a: Some(x), b: y }) => (),\n+                          //^ u32  ^ u8\n+        _ => {}\n+    }\n+}\"#,\n         );\n     }\n \n     #[test]\n     fn incomplete_for_no_hint() {\n-        check(\n+        check_types(\n             r#\"\n fn main() {\n     let data = &[1i32, 2, 3];\n@@ -1146,7 +1090,7 @@ fn main() {\n \n     #[test]\n     fn complete_for_hint() {\n-        check(\n+        check_types(\n             r#\"\n pub struct Vec<T> {}\n \n@@ -1175,13 +1119,7 @@ fn main() {\n \n     #[test]\n     fn multi_dyn_trait_bounds() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                type_hints: true,\n-                parameter_hints: false,\n-                chaining_hints: false,\n-                max_length: None,\n-            },\n+        check_types(\n             r#\"\n pub struct Vec<T> {}\n \n@@ -1208,13 +1146,7 @@ fn main() {\n \n     #[test]\n     fn shorten_iterator_hints() {\n-        check_with_config(\n-            InlayHintsConfig {\n-                parameter_hints: false,\n-                type_hints: true,\n-                chaining_hints: false,\n-                max_length: None,\n-            },\n+        check_types(\n             r#\"\n use core::iter;\n \n@@ -1244,212 +1176,251 @@ fn main() {\n     }\n \n     #[test]\n-    fn shorten_iterator_chaining_hints() {\n-        check_expect(\n-            InlayHintsConfig {\n-                parameter_hints: false,\n-                type_hints: false,\n-                chaining_hints: true,\n-                max_length: None,\n-            },\n+    fn closures() {\n+        check(\n             r#\"\n-use core::iter;\n+fn main() {\n+    let mut start = 0;\n+      //^^^^^^^^^ i32\n+    (0..2).for_each(|increment| { start += increment; });\n+                   //^^^^^^^^^ i32\n \n-struct MyIter;\n+    let multiply =\n+      //^^^^^^^^ |\u2026| -> i32\n+      | a,     b| a * b\n+      //^ i32  ^ i32\n+    ;\n \n-impl Iterator for MyIter {\n-    type Item = ();\n-    fn next(&mut self) -> Option<Self::Item> {\n-        None\n+    let _: i32 = multiply(1, 2);\n+    let multiply_ref = &multiply;\n+      //^^^^^^^^^^^^ &|\u2026| -> i32\n+\n+    let return_42 = || 42;\n+      //^^^^^^^^^ || -> i32\n+}\"#,\n+        );\n     }\n-}\n+\n+    #[test]\n+    fn hint_truncation() {\n+        check_with_config(\n+            InlayHintsConfig { max_length: Some(8), ..TEST_CONFIG },\n+            r#\"\n+struct Smol<T>(T);\n+\n+struct VeryLongOuterName<T>(T);\n \n fn main() {\n-    let _x = MyIter.by_ref()\n-        .take(5)\n-        .by_ref()\n-        .take(5)\n-        .by_ref();\n+    let a = Smol(0u32);\n+      //^ Smol<u32>\n+    let b = VeryLongOuterName(0usize);\n+      //^ VeryLongOuterName<\u2026>\n+    let c = Smol(Smol(0u32))\n+      //^ Smol<Smol<\u2026>>\n+}\"#,\n+        );\n+    }\n+\n+    // Chaining hint tests\n+\n+    #[test]\n+    fn chaining_hints_ignore_comments() {\n+        check_expect(\n+            InlayHintsConfig {\n+                parameter_hints: false,\n+                type_hints: false,\n+                chaining_hints: true,\n+                max_length: None,\n+            },\n+            r#\"\n+struct A(B);\n+impl A { fn into_b(self) -> B { self.0 } }\n+struct B(C);\n+impl B { fn into_c(self) -> C { self.0 } }\n+struct C;\n+\n+fn main() {\n+    let c = A(B(C))\n+        .into_b() // This is a comment\n+        // This is another comment\n+        .into_c();\n }\n \"#,\n             expect![[r#\"\n                 [\n                     InlayHint {\n-                        range: 175..242,\n-                        kind: ChainingHint,\n-                        label: \"impl Iterator<Item = ()>\",\n-                    },\n-                    InlayHint {\n-                        range: 175..225,\n-                        kind: ChainingHint,\n-                        label: \"impl Iterator<Item = ()>\",\n-                    },\n-                    InlayHint {\n-                        range: 175..207,\n+                        range: 148..173,\n                         kind: ChainingHint,\n-                        label: \"impl Iterator<Item = ()>\",\n+                        label: \"B\",\n                     },\n                     InlayHint {\n-                        range: 175..190,\n+                        range: 148..155,\n                         kind: ChainingHint,\n-                        label: \"&mut MyIter\",\n+                        label: \"A\",\n                     },\n                 ]\n             \"#]],\n         );\n     }\n \n     #[test]\n-    fn shorten_iterators_in_associated_params() {\n-        check_with_config(\n+    fn chaining_hints_without_newlines() {\n+        check_chains(\n+            r#\"\n+struct A(B);\n+impl A { fn into_b(self) -> B { self.0 } }\n+struct B(C);\n+impl B { fn into_c(self) -> C { self.0 } }\n+struct C;\n+\n+fn main() {\n+    let c = A(B(C)).into_b().into_c();\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_access_chaining_hints() {\n+        check_expect(\n             InlayHintsConfig {\n                 parameter_hints: false,\n-                type_hints: true,\n-                chaining_hints: false,\n+                type_hints: false,\n+                chaining_hints: true,\n                 max_length: None,\n             },\n             r#\"\n-use core::iter;\n-\n-pub struct SomeIter<T> {}\n-\n-impl<T> SomeIter<T> {\n-    pub fn new() -> Self { SomeIter {} }\n-    pub fn push(&mut self, t: T) {}\n-}\n+struct A { pub b: B }\n+struct B { pub c: C }\n+struct C(pub bool);\n+struct D;\n \n-impl<T> Iterator for SomeIter<T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        None\n-    }\n+impl D {\n+    fn foo(&self) -> i32 { 42 }\n }\n \n fn main() {\n-    let mut some_iter = SomeIter::new();\n-      //^^^^^^^^^^^^^ SomeIter<Take<Repeat<i32>>>\n-      some_iter.push(iter::repeat(2).take(2));\n-    let iter_of_iters = some_iter.take(2);\n-      //^^^^^^^^^^^^^ impl Iterator<Item = impl Iterator<Item = i32>>\n-}\n-\"#,\n+    let x = A { b: B { c: C(true) } }\n+        .b\n+        .c\n+        .0;\n+    let x = D\n+        .foo();\n+}\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 144..191,\n+                        kind: ChainingHint,\n+                        label: \"C\",\n+                    },\n+                    InlayHint {\n+                        range: 144..180,\n+                        kind: ChainingHint,\n+                        label: \"B\",\n+                    },\n+                ]\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn hide_param_hints_for_clones() {\n-        check_with_config(\n+    fn generic_chaining_hints() {\n+        check_expect(\n             InlayHintsConfig {\n-                parameter_hints: true,\n+                parameter_hints: false,\n                 type_hints: false,\n-                chaining_hints: false,\n+                chaining_hints: true,\n                 max_length: None,\n             },\n             r#\"\n-fn foo(bar: i32, baz: String, qux: f32) {}\n+struct A<T>(T);\n+struct B<T>(T);\n+struct C<T>(T);\n+struct X<T,R>(T, R);\n \n+impl<T> A<T> {\n+    fn new(t: T) -> Self { A(t) }\n+    fn into_b(self) -> B<T> { B(self.0) }\n+}\n+impl<T> B<T> {\n+    fn into_c(self) -> C<T> { C(self.0) }\n+}\n fn main() {\n-    let bar = 3;\n-    let baz = &\"baz\";\n-    let fez = 1.0;\n-    foo(bar.clone(), baz.clone(), fez.clone());\n-                                //^^^^^^^^^^^ qux\n+    let c = A::new(X(42, true))\n+        .into_b()\n+        .into_c();\n }\n \"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 247..284,\n+                        kind: ChainingHint,\n+                        label: \"B<X<i32, bool>>\",\n+                    },\n+                    InlayHint {\n+                        range: 247..266,\n+                        kind: ChainingHint,\n+                        label: \"A<X<i32, bool>>\",\n+                    },\n+                ]\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn infer_call_method_return_associated_types_with_generic() {\n-        check(\n+    fn shorten_iterator_chaining_hints() {\n+        check_expect(\n+            InlayHintsConfig {\n+                parameter_hints: false,\n+                type_hints: false,\n+                chaining_hints: true,\n+                max_length: None,\n+            },\n             r#\"\n-            pub trait Default {\n-                fn default() -> Self;\n-            }\n-            pub trait Foo {\n-                type Bar: Default;\n-            }\n+use core::iter;\n \n-            pub fn quux<T: Foo>() -> T::Bar {\n-                let y = Default::default();\n-                  //^ <T as Foo>::Bar\n+struct MyIter;\n \n-                y\n-            }\n-            \"#,\n-        );\n+impl Iterator for MyIter {\n+    type Item = ();\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n     }\n-\n-    #[test]\n-    fn self_param_hints() {\n-        check(\n-            r#\"\n-struct Foo;\n-\n-impl Foo {\n-    fn foo(self: Self) {}\n-    fn bar(self: &Self) {}\n-}\n-\n-fn main() {\n-    Foo::foo(Foo);\n-           //^^^ self\n-    Foo::bar(&Foo);\n-           //^^^^ self\n }\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn fn_hints() {\n-        check(\n-            r#\"\n-trait Sized {}\n-\n-fn foo() -> impl Fn() { loop {} }\n-fn foo1() -> impl Fn(f64) { loop {} }\n-fn foo2() -> impl Fn(f64, f64) { loop {} }\n-fn foo3() -> impl Fn(f64, f64) -> u32 { loop {} }\n-fn foo4() -> &'static dyn Fn(f64, f64) -> u32 { loop {} }\n-fn foo5() -> &'static dyn Fn(&'static dyn Fn(f64, f64) -> u32, f64) -> u32 { loop {} }\n-fn foo6() -> impl Fn(f64, f64) -> u32 + Sized { loop {} }\n-fn foo7() -> *const (impl Fn(f64, f64) -> u32 + Sized) { loop {} }\n \n fn main() {\n-    let foo = foo();\n-     // ^^^ impl Fn()\n-    let foo = foo1();\n-     // ^^^ impl Fn(f64)\n-    let foo = foo2();\n-     // ^^^ impl Fn(f64, f64)\n-    let foo = foo3();\n-     // ^^^ impl Fn(f64, f64) -> u32\n-    let foo = foo4();\n-     // ^^^ &dyn Fn(f64, f64) -> u32\n-    let foo = foo5();\n-     // ^^^ &dyn Fn(&dyn Fn(f64, f64) -> u32, f64) -> u32\n-    let foo = foo6();\n-     // ^^^ impl Fn(f64, f64) -> u32 + Sized\n-    let foo = foo7();\n-     // ^^^ *const (impl Fn(f64, f64) -> u32 + Sized)\n+    let _x = MyIter.by_ref()\n+        .take(5)\n+        .by_ref()\n+        .take(5)\n+        .by_ref();\n }\n \"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn param_name_hints_show_for_literals() {\n-        check(\n-            r#\"pub fn test(a: i32, b: i32) -> [i32; 2] { [a, b] }\n-fn main() {\n-    test(\n-        0x0fab272b,\n-      //^^^^^^^^^^ a\n-        0x0fab272b\n-      //^^^^^^^^^^ b\n-    );\n-}\"#,\n-        )\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 175..242,\n+                        kind: ChainingHint,\n+                        label: \"impl Iterator<Item = ()>\",\n+                    },\n+                    InlayHint {\n+                        range: 175..225,\n+                        kind: ChainingHint,\n+                        label: \"impl Iterator<Item = ()>\",\n+                    },\n+                    InlayHint {\n+                        range: 175..207,\n+                        kind: ChainingHint,\n+                        label: \"impl Iterator<Item = ()>\",\n+                    },\n+                    InlayHint {\n+                        range: 175..190,\n+                        kind: ChainingHint,\n+                        label: \"&mut MyIter\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n     }\n }"}]}