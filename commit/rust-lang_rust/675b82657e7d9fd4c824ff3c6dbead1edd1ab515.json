{"sha": "675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NWI4MjY1N2U3ZDlmZDRjODI0ZmYzYzZkYmVhZDFlZGQxYWI1MTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-17T22:59:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-18T17:57:10Z"}, "message": "Update the rest of the compiler with ~[T] changes", "tree": {"sha": "ac2ffc0405647555976c3b6b90e98a4e9398eb11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac2ffc0405647555976c3b6b90e98a4e9398eb11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "html_url": "https://github.com/rust-lang/rust/commit/675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d3b0bf3912fabf52fdd6926900e578e55af1b49", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d3b0bf3912fabf52fdd6926900e578e55af1b49", "html_url": "https://github.com/rust-lang/rust/commit/7d3b0bf3912fabf52fdd6926900e578e55af1b49"}], "stats": {"total": 308, "additions": 141, "deletions": 167}, "files": [{"sha": "17b5aa4a83af3a0bdc39a4a2b884b50dccf29ae8", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -33,7 +33,6 @@ use std::os;\n use std::str;\n use std::strbuf::StrBuf;\n use std::task;\n-use std::slice;\n use test::MetricMap;\n \n pub fn run(config: config, testfile: ~str) {\n@@ -509,7 +508,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                          proc_res: &ProcRes) {\n \n     // true if we found the error in question\n-    let mut found_flags = slice::from_elem(\n+    let mut found_flags = Vec::from_elem(\n         expected_errors.len(), false);\n \n     if proc_res.status.success() {\n@@ -554,13 +553,13 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n     for line in proc_res.stderr.lines() {\n         let mut was_expected = false;\n         for (i, ee) in expected_errors.iter().enumerate() {\n-            if !found_flags[i] {\n+            if !*found_flags.get(i) {\n                 debug!(\"prefix={} ee.kind={} ee.msg={} line={}\",\n                        *prefixes.get(i), ee.kind, ee.msg, line);\n                 if prefix_matches(line, *prefixes.get(i)) &&\n                     line.contains(ee.kind) &&\n                     line.contains(ee.msg) {\n-                    found_flags[i] = true;\n+                    *found_flags.get_mut(i) = true;\n                     was_expected = true;\n                     break;\n                 }"}, {"sha": "5dd58ccb61d9c1fddc68c2ef2c52b946aa8fe1f2", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -255,10 +255,9 @@ might look like the example below.\n \n ~~~\n # use std::task::spawn;\n-# use std::slice;\n \n // Create a vector of ports, one for each child task\n-let rxs = slice::from_fn(3, |init_val| {\n+let rxs = Vec::from_fn(3, |init_val| {\n     let (tx, rx) = channel();\n     spawn(proc() {\n         tx.send(some_expensive_computation(init_val));\n@@ -304,7 +303,6 @@ be distributed on the available cores.\n \n ~~~\n # extern crate sync;\n-# use std::slice;\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n     for num in range(start*100000, (start+1)*100000) {\n@@ -314,7 +312,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = slice::from_fn(1000, |ind| sync::Future::spawn( proc() { partial_sum(ind) }));\n+    let mut futures = Vec::from_fn(1000, |ind| sync::Future::spawn( proc() { partial_sum(ind) }));\n \n     let mut final_res = 0f64;\n     for ft in futures.mut_iter()  {\n@@ -342,25 +340,24 @@ a single large vector of floats. Each task needs the full vector to perform its\n extern crate rand;\n extern crate sync;\n \n-use std::slice;\n use sync::Arc;\n \n-fn pnorm(nums: &~[f64], p: uint) -> f64 {\n+fn pnorm(nums: &[f64], p: uint) -> f64 {\n     nums.iter().fold(0.0, |a,b| a+(*b).powf(&(p as f64)) ).powf(&(1.0 / (p as f64)))\n }\n \n fn main() {\n-    let numbers = slice::from_fn(1000000, |_| rand::random::<f64>());\n+    let numbers = Vec::from_fn(1000000, |_| rand::random::<f64>());\n     let numbers_arc = Arc::new(numbers);\n \n     for num in range(1u, 10) {\n         let (tx, rx) = channel();\n         tx.send(numbers_arc.clone());\n \n         spawn(proc() {\n-            let local_arc : Arc<~[f64]> = rx.recv();\n+            let local_arc : Arc<Vec<f64>> = rx.recv();\n             let task_numbers = &*local_arc;\n-            println!(\"{}-norm = {}\", num, pnorm(task_numbers, num));\n+            println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n         });\n     }\n }\n@@ -374,9 +371,8 @@ created by the line\n # extern crate sync;\n # extern crate rand;\n # use sync::Arc;\n-# use std::slice;\n # fn main() {\n-# let numbers = slice::from_fn(1000000, |_| rand::random::<f64>());\n+# let numbers = Vec::from_fn(1000000, |_| rand::random::<f64>());\n let numbers_arc=Arc::new(numbers);\n # }\n ~~~\n@@ -387,9 +383,8 @@ and a clone of it is sent to each task\n # extern crate sync;\n # extern crate rand;\n # use sync::Arc;\n-# use std::slice;\n # fn main() {\n-# let numbers=slice::from_fn(1000000, |_| rand::random::<f64>());\n+# let numbers=Vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc = Arc::new(numbers);\n # let (tx, rx) = channel();\n tx.send(numbers_arc.clone());\n@@ -404,13 +399,12 @@ Each task recovers the underlying data by\n # extern crate sync;\n # extern crate rand;\n # use sync::Arc;\n-# use std::slice;\n # fn main() {\n-# let numbers=slice::from_fn(1000000, |_| rand::random::<f64>());\n+# let numbers=Vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc=Arc::new(numbers);\n # let (tx, rx) = channel();\n # tx.send(numbers_arc.clone());\n-# let local_arc : Arc<~[f64]> = rx.recv();\n+# let local_arc : Arc<Vec<f64>> = rx.recv();\n let task_numbers = &*local_arc;\n # }\n ~~~"}, {"sha": "336f296ba2503d98704d93fe9e6acf0a1f50519f", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -1582,12 +1582,12 @@ the elements are mutable if the vector is mutable.\n use std::strbuf::StrBuf;\n \n // A dynamically sized vector (unique vector)\n-let mut numbers = ~[1, 2, 3];\n+let mut numbers = vec![1, 2, 3];\n numbers.push(4);\n numbers.push(5);\n \n // The type of a unique vector is written as `~[int]`\n-let more_numbers: ~[int] = numbers;\n+let more_numbers: ~[int] = numbers.move_iter().collect();\n \n // The original `numbers` value can no longer be used, due to move semantics.\n \n@@ -1955,8 +1955,8 @@ vector consisting of the result of applying `function` to each element\n of `vector`:\n \n ~~~~\n-fn map<T, U>(vector: &[T], function: |v: &T| -> U) -> ~[U] {\n-    let mut accumulator = ~[];\n+fn map<T, U>(vector: &[T], function: |v: &T| -> U) -> Vec<U> {\n+    let mut accumulator = Vec::new();\n     for element in vector.iter() {\n         accumulator.push(function(element));\n     }"}, {"sha": "71944202205ffcd47118e3f6e524f3c8ad739fcd", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -57,7 +57,7 @@ impl GetAddrInfoRequest {\n         }\n \n         // Collect all the results we found\n-        let mut addrs = ~[];\n+        let mut addrs = Vec::new();\n         let mut rp = res;\n         while rp.is_not_null() {\n             unsafe {\n@@ -80,7 +80,7 @@ impl GetAddrInfoRequest {\n \n         unsafe { freeaddrinfo(res); }\n \n-        Ok(addrs)\n+        Ok(addrs.move_iter().collect())\n     }\n }\n "}, {"sha": "d97a0430fea4b185b48155b217398a2c10e1c702", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -18,7 +18,6 @@ use libc::{c_int, c_void};\n use libc;\n use std::mem;\n use std::rt::rtio;\n-use std::slice;\n \n use io::{IoResult, retry, keep_going};\n \n@@ -416,7 +415,7 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n     if len == -1 {\n         len = 1024; // FIXME: read PATH_MAX from C ffi?\n     }\n-    let mut buf = slice::with_capacity::<u8>(len as uint);\n+    let mut buf: Vec<u8> = Vec::with_capacity(len as uint);\n     match retry(|| unsafe {\n         libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n                        len as libc::size_t) as libc::c_int"}, {"sha": "385287d998e630677fba84fc96e374aa79ecf259", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -74,7 +74,7 @@ impl Process {\n             return Err(super::unimpl());\n         }\n \n-        fn get_io(io: p::StdioContainer, ret: &mut ~[Option<file::FileDesc>])\n+        fn get_io(io: p::StdioContainer, ret: &mut Vec<Option<file::FileDesc>>)\n             -> (Option<os::Pipe>, c_int)\n         {\n             match io {\n@@ -93,7 +93,7 @@ impl Process {\n             }\n         }\n \n-        let mut ret_io = ~[];\n+        let mut ret_io = Vec::new();\n         let (in_pipe, in_fd) = get_io(config.stdin, &mut ret_io);\n         let (out_pipe, out_fd) = get_io(config.stdout, &mut ret_io);\n         let (err_pipe, err_fd) = get_io(config.stderr, &mut ret_io);\n@@ -117,7 +117,7 @@ impl Process {\n                         exit_code: None,\n                         exit_signal: None,\n                     },\n-                    ret_io))\n+                    ret_io.move_iter().collect()))\n             }\n             Err(e) => Err(e)\n         }\n@@ -641,12 +641,10 @@ fn spawn_process_os(config: p::ProcessConfig,\n \n #[cfg(unix)]\n fn with_argv<T>(prog: &str, args: &[~str], cb: proc(**libc::c_char) -> T) -> T {\n-    use std::slice;\n-\n     // We can't directly convert `str`s into `*char`s, as someone needs to hold\n     // a reference to the intermediary byte buffers. So first build an array to\n     // hold all the ~[u8] byte strings.\n-    let mut tmps = slice::with_capacity(args.len() + 1);\n+    let mut tmps = Vec::with_capacity(args.len() + 1);\n \n     tmps.push(prog.to_c_str());\n \n@@ -667,14 +665,12 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: proc(**libc::c_char) -> T) -> T {\n \n #[cfg(unix)]\n fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: proc(*c_void) -> T) -> T {\n-    use std::slice;\n-\n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n     // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n     match env {\n         Some(env) => {\n-            let mut tmps = slice::with_capacity(env.len());\n+            let mut tmps = Vec::with_capacity(env.len());\n \n             for pair in env.iter() {\n                 let kv = format!(\"{}={}\", *pair.ref0(), *pair.ref1());\n@@ -700,7 +696,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n     // \\0 to terminate.\n     match env {\n         Some(env) => {\n-            let mut blk = ~[];\n+            let mut blk = Vec::new();\n \n             for pair in env.iter() {\n                 let kv = format!(\"{}={}\", *pair.ref0(), *pair.ref1());"}, {"sha": "b96e4b06c46d3937bf6fe1d60aa2d1c3852eadd2", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -156,8 +156,6 @@ pub fn minimize_rpaths(rpaths: &[~str]) -> Vec<~str> {\n \n #[cfg(unix, test)]\n mod test {\n-    use std::os;\n-\n     use back::rpath::get_install_prefix_rpath;\n     use back::rpath::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n     use syntax::abi;"}, {"sha": "7b1d0068035c88ca6f86bce60e2b5b898db396ee", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -223,13 +223,13 @@ pub fn describe_codegen_flags() {\n }\n \n pub fn run_compiler(args: &[~str]) {\n-    let mut args = args.to_owned();\n+    let mut args = Vec::from_slice(args);\n     let binary = args.shift().unwrap();\n \n     if args.is_empty() { usage(binary); return; }\n \n     let matches =\n-        &match getopts::getopts(args, d::optgroups().as_slice()) {\n+        &match getopts::getopts(args.as_slice(), d::optgroups().as_slice()) {\n           Ok(m) => m,\n           Err(f) => {\n             d::early_error(f.to_err_msg());"}, {"sha": "f7a30ff44599771a3502086ee319d12e82de93a3", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -18,7 +18,6 @@\n \n \n use std::io;\n-use std::slice;\n use std::strbuf::StrBuf;\n use std::uint;\n use syntax::ast;\n@@ -308,13 +307,13 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n                 changed: true\n             };\n \n-            let mut temp = slice::from_elem(self.words_per_id, 0u);\n+            let mut temp = Vec::from_elem(self.words_per_id, 0u);\n             let mut loop_scopes = Vec::new();\n \n             while propcx.changed {\n                 propcx.changed = false;\n-                propcx.reset(temp);\n-                propcx.walk_block(blk, temp, &mut loop_scopes);\n+                propcx.reset(temp.as_mut_slice());\n+                propcx.walk_block(blk, temp.as_mut_slice(), &mut loop_scopes);\n             }\n         }\n "}, {"sha": "4aaa9760e8941538242bfe16ce5fa77fd8cfac69", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -16,8 +16,6 @@\n  * closure.\n  */\n \n-use std::slice;\n-\n use back::abi;\n use driver::session;\n use lib::llvm::{ValueRef, NoAliasAttribute, StructRetAttribute, NoCaptureAttribute};\n@@ -221,11 +219,12 @@ fn resolve_default_method_vtables(bcx: &Block,\n         Some(vtables) => {\n             let num_impl_type_parameters =\n                 vtables.len() - num_method_vtables;\n-            vtables.tailn(num_impl_type_parameters).to_owned()\n+            Vec::from_slice(vtables.tailn(num_impl_type_parameters))\n         },\n-        None => slice::from_elem(num_method_vtables, @Vec::new())\n+        None => Vec::from_elem(num_method_vtables, @Vec::new())\n     };\n \n+    let method_vtables = method_vtables.as_slice();\n     let param_vtables = @((*trait_vtables_fixed).clone().append(method_vtables));\n \n     let self_vtables = resolve_param_vtables_under_param_substs("}, {"sha": "03b442bae218f723a5a3f2e73f746582af41eb4a", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -593,11 +593,11 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = slice::from_elem(n, const_expr(cx, elem, is_local).val0());\n+            let vs = Vec::from_elem(n, const_expr(cx, elem, is_local).val0());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(cx, vs, false)\n+                C_struct(cx, vs.as_slice(), false)\n             } else {\n-                C_array(llunitty, vs)\n+                C_array(llunitty, vs.as_slice())\n             };\n             (v, true)\n           }"}, {"sha": "60c6c5ee97aa444bf3a09b0a6a9070fba67f2a5a", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -148,7 +148,6 @@ use collections::HashMap;\n use collections::HashSet;\n use libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n-use std::slice;\n use std::strbuf::StrBuf;\n use std::sync::atomics;\n use syntax::codemap::{Span, Pos};\n@@ -776,7 +775,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             return create_DIArray(DIB(cx), []);\n         }\n \n-        let mut signature = slice::with_capacity(fn_decl.inputs.len() + 1);\n+        let mut signature = Vec::with_capacity(fn_decl.inputs.len() + 1);\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n         match fn_decl.output.node {\n@@ -818,7 +817,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n-        return create_DIArray(DIB(cx), signature);\n+        return create_DIArray(DIB(cx), signature.as_slice());\n     }\n \n     fn get_template_parameters(cx: &CrateContext,\n@@ -961,15 +960,15 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                             // prepend \"./\" if necessary\n                             let dotdot = bytes!(\"..\");\n                             let prefix = &[dotdot[0], ::std::path::SEP_BYTE];\n-                            let mut path_bytes = p.as_vec().to_owned();\n+                            let mut path_bytes = Vec::from_slice(p.as_vec());\n \n                             if path_bytes.slice_to(2) != prefix &&\n                                path_bytes.slice_to(2) != dotdot {\n                                 path_bytes.insert(0, prefix[0]);\n                                 path_bytes.insert(1, prefix[1]);\n                             }\n \n-                            path_bytes.to_c_str()\n+                            path_bytes.as_slice().to_c_str()\n                         }\n                     _ => fallback_path(cx)\n                 }"}, {"sha": "ba050e8db33fe31fe798f08ff9d7c6ff57503646", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -71,7 +71,6 @@ use util::nodemap::NodeMap;\n use middle::trans::machine::{llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n \n-use std::slice;\n use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust::{expr_to_str};\n@@ -969,15 +968,15 @@ fn trans_rec_or_struct<'a>(\n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n     with_field_tys(tcx, ty, Some(id), |discr, field_tys| {\n-        let mut need_base = slice::from_elem(field_tys.len(), true);\n+        let mut need_base = Vec::from_elem(field_tys.len(), true);\n \n         let numbered_fields = fields.iter().map(|field| {\n             let opt_pos =\n                 field_tys.iter().position(|field_ty|\n                                           field_ty.ident.name == field.ident.node.name);\n             match opt_pos {\n                 Some(i) => {\n-                    need_base[i] = false;\n+                    *need_base.get_mut(i) = false;\n                     (i, field.expr)\n                 }\n                 None => {"}, {"sha": "b2529e4402607d524453086a4097e372855e5aa7", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -118,7 +118,6 @@ use std::cell::{Cell, RefCell};\n use collections::HashMap;\n use std::mem::replace;\n use std::result;\n-use std::slice;\n use std::vec::Vec;\n use syntax::abi;\n use syntax::ast::{Provided, Required};\n@@ -3906,13 +3905,13 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.len() == 0u { return; }\n-    let mut tps_used = slice::from_elem(tps.len(), false);\n+    let mut tps_used = Vec::from_elem(tps.len(), false);\n \n     ty::walk_ty(ty, |t| {\n             match ty::get(t).sty {\n                 ty::ty_param(param_ty {idx, ..}) => {\n                     debug!(\"Found use of ty param \\\\#{}\", idx);\n-                    tps_used[idx] = true;\n+                    *tps_used.get_mut(idx) = true;\n                 }\n                 _ => ()\n             }"}, {"sha": "a446b94027b29ff2a061ede79829ce03716be7d1", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -26,7 +26,6 @@ use util::ppaux::{Repr};\n \n use std::cell::{Cell, RefCell};\n use std::uint;\n-use std::slice;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n \n@@ -1004,7 +1003,7 @@ impl<'a> RegionVarBindings<'a> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = slice::from_elem(self.num_vars(), uint::MAX);\n+        let mut dup_vec = Vec::from_elem(self.num_vars(), uint::MAX);\n \n         let mut opt_graph = None;\n \n@@ -1052,11 +1051,13 @@ impl<'a> RegionVarBindings<'a> {\n                     match var_data[idx].classification {\n                         Expanding => {\n                             self.collect_error_for_expanding_node(\n-                                graph, var_data, dup_vec, node_vid, errors);\n+                                graph, var_data, dup_vec.as_mut_slice(),\n+                                node_vid, errors);\n                         }\n                         Contracting => {\n                             self.collect_error_for_contracting_node(\n-                                graph, var_data, dup_vec, node_vid, errors);\n+                                graph, var_data, dup_vec.as_mut_slice(),\n+                                node_vid, errors);\n                         }\n                     }\n                 }"}, {"sha": "8fba8589d4d3848082e92b26822003f72182000a", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -525,7 +525,6 @@ mod tests {\n \n     use super::{Digest, Sha256, FixedBuffer};\n     use std::num::Bounded;\n-    use std::slice;\n     use self::rand::isaac::IsaacRng;\n     use self::rand::Rng;\n     use serialize::hex::FromHex;\n@@ -600,7 +599,7 @@ mod tests {\n     /// correct.\n     fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n         let total_size = 1000000;\n-        let buffer = slice::from_elem(blocksize * 2, 'a' as u8);\n+        let buffer = Vec::from_elem(blocksize * 2, 'a' as u8);\n         let mut rng = IsaacRng::new_unseeded();\n         let mut count = 0;\n "}, {"sha": "1fb43c34b4e23aa15f9cdd34832594bc98e33302", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -38,7 +38,6 @@ use std::fmt;\n use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n use std::io;\n use std::local_data;\n-use std::slice;\n use std::str;\n use std::strbuf::StrBuf;\n \n@@ -1047,7 +1046,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     try!(document(w, item));\n     debug!(\"{:?}\", items);\n-    let mut indices = slice::from_fn(items.len(), |i| i);\n+    let mut indices = Vec::from_fn(items.len(), |i| i);\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n         if shortty(i1) == shortty(i2) {"}, {"sha": "30582fb0e41e21e0e596e76a3c43e42700ba3646", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -169,8 +169,8 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n \n fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> ~str {\n     let mut prog = StrBuf::from_str(r\"\n-#![deny(warnings)];\n-#![allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)];\n+#![deny(warnings)]\n+#![allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)]\n \");\n \n     if loose_feature_gating {"}, {"sha": "94a084fe055aefee17ba157532e4188b4de35219", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -138,7 +138,7 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n     unsafe {\n         let mut addr = addr.handle;\n \n-        let mut addrs = ~[];\n+        let mut addrs = Vec::new();\n         loop {\n             let rustaddr = net::sockaddr_to_addr(cast::transmute((*addr).ai_addr),\n                                                  (*addr).ai_addrlen as uint);\n@@ -180,6 +180,6 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n             }\n         }\n \n-        return addrs;\n+        return addrs.move_iter().collect();\n     }\n }"}, {"sha": "cde5cfa97c1d751f86a84901c0305001ee3f3418", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -469,7 +469,6 @@ mod test {\n     use libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n     use std::io;\n     use std::str;\n-    use std::slice;\n     use super::FsRequest;\n     use super::super::Loop;\n     use super::super::local_loop;\n@@ -505,8 +504,8 @@ mod test {\n             let fd = result.fd;\n \n             // read\n-            let mut read_mem = slice::from_elem(1000, 0u8);\n-            let result = FsRequest::read(l(), fd, read_mem, 0);\n+            let mut read_mem = Vec::from_elem(1000, 0u8);\n+            let result = FsRequest::read(l(), fd, read_mem.as_mut_slice(), 0);\n             assert!(result.is_ok());\n \n             let nread = result.unwrap();"}, {"sha": "7b5b5d3235ba0a916fa026c75b43e19cfe69ee8f", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -15,7 +15,6 @@ use libc;\n use std::ptr;\n use std::rt::rtio::RtioProcess;\n use std::rt::task::BlockedTask;\n-use std::slice;\n \n use homing::{HomingIO, HomeHandle};\n use pipe::PipeWatcher;\n@@ -44,12 +43,12 @@ impl Process {\n                 -> Result<(~Process, ~[Option<PipeWatcher>]), UvError>\n     {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n-        let mut io = ~[config.stdin, config.stdout, config.stderr];\n+        let mut io = vec![config.stdin, config.stdout, config.stderr];\n         for slot in config.extra_io.iter() {\n             io.push(*slot);\n         }\n-        let mut stdio = slice::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n-        let mut ret_io = slice::with_capacity(io.len());\n+        let mut stdio = Vec::<uvll::uv_stdio_container_t>::with_capacity(io.len());\n+        let mut ret_io = Vec::with_capacity(io.len());\n         unsafe {\n             stdio.set_len(io.len());\n             for (slot, other) in stdio.iter().zip(io.iter()) {\n@@ -104,7 +103,7 @@ impl Process {\n         });\n \n         match ret {\n-            Ok(p) => Ok((p, ret_io)),\n+            Ok(p) => Ok((p, ret_io.move_iter().collect())),\n             Err(e) => Err(e),\n         }\n     }\n@@ -167,14 +166,14 @@ unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n fn with_argv<T>(prog: &str, args: &[~str], f: |**libc::c_char| -> T) -> T {\n     // First, allocation space to put all the C-strings (we need to have\n     // ownership of them somewhere\n-    let mut c_strs = slice::with_capacity(args.len() + 1);\n+    let mut c_strs = Vec::with_capacity(args.len() + 1);\n     c_strs.push(prog.to_c_str());\n     for arg in args.iter() {\n         c_strs.push(arg.to_c_str());\n     }\n \n     // Next, create the char** array\n-    let mut c_args = slice::with_capacity(c_strs.len() + 1);\n+    let mut c_args = Vec::with_capacity(c_strs.len() + 1);\n     for s in c_strs.iter() {\n         c_args.push(s.with_ref(|p| p));\n     }\n@@ -189,11 +188,11 @@ fn with_env<T>(env: Option<&[(~str, ~str)]>, f: |**libc::c_char| -> T) -> T {\n         None => { return f(ptr::null()); }\n     };\n     // As with argv, create some temporary storage and then the actual array\n-    let mut envp = slice::with_capacity(env.len());\n+    let mut envp = Vec::with_capacity(env.len());\n     for &(ref key, ref value) in env.iter() {\n         envp.push(format!(\"{}={}\", *key, *value).to_c_str());\n     }\n-    let mut c_envp = slice::with_capacity(envp.len() + 1);\n+    let mut c_envp = Vec::with_capacity(envp.len() + 1);\n     for s in envp.iter() {\n         c_envp.push(s.with_ref(|p| p));\n     }"}, {"sha": "92622e6c59fa3515f404e985648491a9dc300ab9", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -79,7 +79,7 @@ impl<'a> ToBase64 for &'a [u8] {\n             UrlSafe => URLSAFE_CHARS\n         };\n \n-        let mut v: ~[u8] = ~[];\n+        let mut v = Vec::new();\n         let mut i = 0;\n         let mut cur_length = 0;\n         let len = self.len();\n@@ -146,7 +146,7 @@ impl<'a> ToBase64 for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8_owned(v)\n+            str::raw::from_utf8_owned(v.move_iter().collect())\n         }\n     }\n }\n@@ -208,7 +208,7 @@ impl<'a> FromBase64 for &'a str {\n      * ```\n      */\n     fn from_base64(&self) -> Result<~[u8], FromBase64Error> {\n-        let mut r = ~[];\n+        let mut r = Vec::new();\n         let mut buf: u32 = 0;\n         let mut modulus = 0;\n \n@@ -256,7 +256,7 @@ impl<'a> FromBase64 for &'a str {\n             _ => return Err(InvalidBase64Length),\n         }\n \n-        Ok(r)\n+        Ok(r.move_iter().collect())\n     }\n }\n \n@@ -337,12 +337,12 @@ mod tests {\n     #[test]\n     fn test_base64_random() {\n         use self::rand::{task_rng, random, Rng};\n-        use std::slice;\n \n         for _ in range(0, 1000) {\n             let times = task_rng().gen_range(1u, 100);\n-            let v = slice::from_fn(times, |_| random::<u8>());\n-            assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n+            let v = Vec::from_fn(times, |_| random::<u8>());\n+            assert_eq!(v.as_slice().to_base64(STANDARD).from_base64().unwrap(),\n+                       v.as_slice().to_owned());\n         }\n     }\n "}, {"sha": "486150f1741f6f9386fc0673f2ff6450c62f906b", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -1099,8 +1099,7 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100, |i| {\n+        let data = Vec::from_fn(4*100, |i| {\n             match i % 2 {\n               0 => 0x80u8,\n               _ => i as u8,\n@@ -1110,16 +1109,15 @@ mod bench {\n         b.iter(|| {\n             let mut i = 0;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).unwrap().val;\n+                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n                 i += 4;\n             }\n         });\n     }\n \n     #[bench]\n     pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100+1, |i| {\n+        let data = Vec::from_fn(4*100+1, |i| {\n             match i % 2 {\n               1 => 0x80u8,\n               _ => i as u8\n@@ -1129,16 +1127,15 @@ mod bench {\n         b.iter(|| {\n             let mut i = 1;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).unwrap().val;\n+                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n                 i += 4;\n             }\n         });\n     }\n \n     #[bench]\n     pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100, |i| {\n+        let data = Vec::from_fn(4*100, |i| {\n             match i % 4 {\n               0 => 0x10u8,\n               3 => i as u8,\n@@ -1149,16 +1146,15 @@ mod bench {\n         b.iter(|| {\n             let mut i = 0;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).unwrap().val;\n+                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n                 i += 4;\n             }\n         });\n     }\n \n     #[bench]\n     pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100+1, |i| {\n+        let data = Vec::from_fn(4*100+1, |i| {\n             match i % 4 {\n               1 => 0x10u8,\n               0 => i as u8,\n@@ -1169,7 +1165,7 @@ mod bench {\n         b.iter(|| {\n             let mut i = 1;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).unwrap().val;\n+                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n                 i += 4;\n             }\n         });"}, {"sha": "fa383bef2dc530763e344c795ece43066288ac64", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -10,7 +10,6 @@\n \n //! Hex binary-to-text encoding\n use std::str;\n-use std::slice;\n use std::fmt;\n \n /// A trait for converting a value to hexadecimal encoding\n@@ -39,14 +38,14 @@ impl<'a> ToHex for &'a [u8] {\n      * ```\n      */\n     fn to_hex(&self) -> ~str {\n-        let mut v = slice::with_capacity(self.len() * 2);\n+        let mut v = Vec::with_capacity(self.len() * 2);\n         for &byte in self.iter() {\n             v.push(CHARS[(byte >> 4) as uint]);\n             v.push(CHARS[(byte & 0xf) as uint]);\n         }\n \n         unsafe {\n-            str::raw::from_utf8_owned(v)\n+            str::raw::from_utf8_owned(v.move_iter().collect())\n         }\n     }\n }\n@@ -106,7 +105,7 @@ impl<'a> FromHex for &'a str {\n      */\n     fn from_hex(&self) -> Result<~[u8], FromHexError> {\n         // This may be an overestimate if there is any whitespace\n-        let mut b = slice::with_capacity(self.len() / 2);\n+        let mut b = Vec::with_capacity(self.len() / 2);\n         let mut modulus = 0;\n         let mut buf = 0u8;\n \n@@ -132,7 +131,7 @@ impl<'a> FromHex for &'a str {\n         }\n \n         match modulus {\n-            0 => Ok(b),\n+            0 => Ok(b.move_iter().collect()),\n             _ => Err(InvalidHexLength),\n         }\n     }"}, {"sha": "606f2b12af1635e88e49fa4f9946f6cfbfbb2851", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -1230,11 +1230,11 @@ impl<T : Iterator<char>> Parser<T> {\n         self.bump();\n         self.parse_whitespace();\n \n-        let mut values = ~[];\n+        let mut values = Vec::new();\n \n         if self.ch_is(']') {\n             self.bump();\n-            return Ok(List(values));\n+            return Ok(List(values.move_iter().collect()));\n         }\n \n         loop {\n@@ -1252,7 +1252,7 @@ impl<T : Iterator<char>> Parser<T> {\n                 self.bump();\n             } else if self.ch_is(']') {\n                 self.bump();\n-                return Ok(List(values));\n+                return Ok(List(values.move_iter().collect()));\n             } else {\n                 return self.error(~\"expected `,` or `]`\")\n             }\n@@ -1332,14 +1332,14 @@ pub fn from_str(s: &str) -> DecodeResult<Json> {\n \n /// A structure to decode JSON to values in rust.\n pub struct Decoder {\n-    stack: ~[Json],\n+    stack: Vec<Json>,\n }\n \n impl Decoder {\n     /// Creates a new decoder instance for decoding the specified JSON value.\n     pub fn new(json: Json) -> Decoder {\n         Decoder {\n-            stack: ~[json]\n+            stack: vec!(json),\n         }\n     }\n }"}, {"sha": "09b30077f6f64aa464cf3850250aa2c150165c1a", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -16,7 +16,6 @@ Core encoding and decoding interfaces.\n \n use std::path;\n use std::rc::Rc;\n-use std::slice;\n \n pub trait Encoder<E> {\n     // Primitive types:\n@@ -443,11 +442,15 @@ impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for ~[T] {\n impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for ~[T] {\n     fn decode(d: &mut D) -> Result<~[T], E> {\n         d.read_seq(|d, len| {\n-            let mut v: ~[T] = slice::with_capacity(len);\n+            let mut v: Vec<T> = Vec::with_capacity(len);\n             for i in range(0, len) {\n                 v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n-            Ok(v)\n+            println!(\"-------\");\n+            println!(\"{}\", v.len());\n+            let k = v.move_iter().collect::<~[T]>();\n+            println!(\"{}\", k.len());\n+            Ok(k)\n         })\n     }\n }\n@@ -594,11 +597,11 @@ pub trait DecoderHelpers<E> {\n impl<E, D:Decoder<E>> DecoderHelpers<E> for D {\n     fn read_to_vec<T>(&mut self, f: |&mut D| -> Result<T, E>) -> Result<~[T], E> {\n         self.read_seq(|this, len| {\n-            let mut v = slice::with_capacity(len);\n+            let mut v = Vec::with_capacity(len);\n             for i in range(0, len) {\n                 v.push(try!(this.read_seq_elt(i, |this| f(this))));\n             }\n-            Ok(v)\n+            Ok(v.move_iter().collect())\n         })\n     }\n }"}, {"sha": "dbb9530487397df15ecd3bec96fff1da0fed4831", "filename": "src/libstd/os.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -28,9 +28,6 @@\n \n #![allow(missing_doc)]\n \n-#[cfg(windows)]\n-use iter::range;\n-\n use clone::Clone;\n use container::Container;\n use libc;\n@@ -96,15 +93,16 @@ pub fn getcwd() -> Path {\n \n #[cfg(windows)]\n pub mod win32 {\n+    use iter::Iterator;\n     use libc::types::os::arch::extra::DWORD;\n     use libc;\n     use option::{None, Option};\n     use option;\n     use os::TMPBUF_SZ;\n+    use slice::{MutableVector, ImmutableVector, OwnedVector};\n     use str::StrSlice;\n     use str;\n-    use slice::{MutableVector, ImmutableVector, OwnedVector};\n-    use slice;\n+    use vec::Vec;\n \n     pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)\n         -> Option<~str> {\n@@ -114,7 +112,7 @@ pub mod win32 {\n             let mut res = None;\n             let mut done = false;\n             while !done {\n-                let mut buf = slice::from_elem(n as uint, 0u16);\n+                let mut buf = Vec::from_elem(n as uint, 0u16);\n                 let k = f(buf.as_mut_ptr(), n);\n                 if k == (0 as DWORD) {\n                     done = true;\n@@ -142,7 +140,7 @@ pub mod win32 {\n     }\n \n     pub fn as_utf16_p<T>(s: &str, f: |*u16| -> T) -> T {\n-        let mut t = s.to_utf16();\n+        let mut t = s.to_utf16().move_iter().collect::<Vec<u16>>();\n         // Null terminate before passing on.\n         t.push(0u16);\n         f(t.as_ptr())\n@@ -182,7 +180,7 @@ pub fn env() -> ~[(~str,~str)] {\n pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n     unsafe {\n         #[cfg(windows)]\n-        unsafe fn get_env_pairs() -> ~[~[u8]] {\n+        unsafe fn get_env_pairs() -> Vec<~[u8]> {\n             use c_str;\n             use str::StrSlice;\n \n@@ -195,7 +193,7 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n                 fail!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n-            let mut result = ~[];\n+            let mut result = Vec::new();\n             c_str::from_c_multistring(ch as *c_char, None, |cstr| {\n                 result.push(cstr.as_bytes_no_nul().to_owned());\n             });\n@@ -839,27 +837,24 @@ fn real_args() -> ~[~str] {\n     let lpCmdLine = unsafe { GetCommandLineW() };\n     let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n \n-    let mut args = ~[];\n-    for i in range(0u, nArgs as uint) {\n-        unsafe {\n-            // Determine the length of this argument.\n-            let ptr = *szArgList.offset(i as int);\n-            let mut len = 0;\n-            while *ptr.offset(len as int) != 0 { len += 1; }\n-\n-            // Push it onto the list.\n-            let opt_s = slice::raw::buf_as_slice(ptr, len, |buf| {\n-                    str::from_utf16(str::truncate_utf16_at_nul(buf))\n-                });\n-            args.push(opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\"));\n-        }\n-    }\n+    let args = Vec::from_fn(nArgs as uint, |i| unsafe {\n+        // Determine the length of this argument.\n+        let ptr = *szArgList.offset(i as int);\n+        let mut len = 0;\n+        while *ptr.offset(len as int) != 0 { len += 1; }\n+\n+        // Push it onto the list.\n+        let opt_s = slice::raw::buf_as_slice(ptr, len, |buf| {\n+            str::from_utf16(str::truncate_utf16_at_nul(buf))\n+        });\n+        opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\")\n+    });\n \n     unsafe {\n         LocalFree(szArgList as *c_void);\n     }\n \n-    return args;\n+    return args.move_iter().collect();\n }\n \n #[cfg(windows)]"}, {"sha": "84021f6362b7c9c1a916ec98a1ff0a3d837a08d2", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -20,7 +20,6 @@ use rsparse = parse;\n \n use std::fmt::parse;\n use collections::{HashMap, HashSet};\n-use std::slice;\n \n #[deriving(Eq)]\n enum ArgumentType {\n@@ -609,7 +608,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn to_expr(&self, extra: @ast::Expr) -> @ast::Expr {\n         let mut lets = Vec::new();\n         let mut locals = Vec::new();\n-        let mut names = slice::from_fn(self.name_positions.len(), |_| None);\n+        let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n@@ -673,7 +672,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let lname = self.ecx.ident_of(format!(\"__arg{}\", *name));\n             pats.push(self.ecx.pat_ident(e.span, lname));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n-            names[*self.name_positions.get(name)] =\n+            *names.get_mut(*self.name_positions.get(name)) =\n                 Some(self.format_arg(e.span,\n                                      Named((*name).clone()),\n                                      self.ecx.expr_ident(e.span, lname)));"}, {"sha": "4405245b9a0e1279e72add3e5bb5d55cc47598e2", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -16,7 +16,6 @@ use collections::{TrieMap, TreeMap, HashMap, HashSet};\n use std::os;\n use rand::{Rng, IsaacRng, SeedableRng};\n use std::uint;\n-use std::slice;\n \n fn timed(label: &str, f: ||) {\n     let start = time::precise_time_s();\n@@ -99,7 +98,7 @@ fn main() {\n         }\n     };\n \n-    let mut rand = slice::with_capacity(n_keys);\n+    let mut rand = Vec::with_capacity(n_keys);\n \n     {\n         let mut rng: IsaacRng = SeedableRng::from_seed(&[1, 1, 1, 1, 1, 1, 1]);\n@@ -130,7 +129,7 @@ fn main() {\n     {\n         println!(\" Random integers:\");\n         let mut map: TreeMap<uint,uint> = TreeMap::new();\n-        vector(&mut map, n_keys, rand);\n+        vector(&mut map, n_keys, rand.as_slice());\n     }\n \n     // FIXME: #9970\n@@ -149,7 +148,7 @@ fn main() {\n     {\n         println!(\" Random integers:\");\n         let mut map: HashMap<uint,uint> = HashMap::new();\n-        vector(&mut map, n_keys, rand);\n+        vector(&mut map, n_keys, rand.as_slice());\n     }\n \n     // FIXME: #9970\n@@ -168,6 +167,6 @@ fn main() {\n     {\n         println!(\" Random integers:\");\n         let mut map: TrieMap<uint> = TrieMap::new();\n-        vector(&mut map, n_keys, rand);\n+        vector(&mut map, n_keys, rand.as_slice());\n     }\n }"}, {"sha": "fbea63e65f1264f4be72327b0e87c734e5bf0894", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::os;\n-use std::slice;\n \n fn max(a: i32, b: i32) -> i32 {\n     if a > b {\n@@ -20,13 +19,17 @@ fn max(a: i32, b: i32) -> i32 {\n }\n \n fn fannkuch_redux(n: i32) -> i32 {\n-    let mut perm = slice::from_elem(n as uint, 0i32);\n-    let mut perm1 = slice::from_fn(n as uint, |i| i as i32);\n-    let mut count = slice::from_elem(n as uint, 0i32);\n+    let mut perm = Vec::from_elem(n as uint, 0i32);\n+    let mut perm1 = Vec::from_fn(n as uint, |i| i as i32);\n+    let mut count = Vec::from_elem(n as uint, 0i32);\n     let mut max_flips_count = 0i32;\n     let mut perm_count = 0i32;\n     let mut checksum = 0i32;\n \n+    let perm = perm.as_mut_slice();\n+    let perm1 = perm1.as_mut_slice();\n+    let count = count.as_mut_slice();\n+\n     let mut r = n;\n     loop {\n         while r != 1 {"}, {"sha": "01b75fa422f924474eb9a2e5bdfcb6923e740bc8", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -12,7 +12,6 @@ use std::cmp::min;\n use std::io::{stdout, IoResult};\n use std::os;\n use std::slice::bytes::copy_memory;\n-use std::slice;\n \n static LINE_LEN: uint = 60;\n static LOOKUP_SIZE: uint = 4 * 1024;\n@@ -90,10 +89,10 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n \n     fn make(&mut self, n: uint) -> IoResult<()> {\n         let alu_len = self.alu.len();\n-        let mut buf = slice::from_elem(alu_len + LINE_LEN, 0u8);\n+        let mut buf = Vec::from_elem(alu_len + LINE_LEN, 0u8);\n         let alu: &[u8] = self.alu.as_bytes();\n \n-        copy_memory(buf, alu);\n+        copy_memory(buf.as_mut_slice(), alu);\n         let buf_len = buf.len();\n         copy_memory(buf.mut_slice(alu_len, buf_len),\n                     alu.slice_to(LINE_LEN));"}, {"sha": "f0cdc020dc371a44931efb5f3a818a247b6c2717", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -14,7 +14,6 @@ use std::from_str::FromStr;\n use std::iter::count;\n use std::cmp::min;\n use std::os;\n-use std::slice::from_elem;\n use sync::{Arc, RWLock};\n \n fn A(i: uint, j: uint) -> f64 {"}, {"sha": "537f3c9f48a99ea0a384e9408c7556c13fa25991", "filename": "src/test/compile-fail/lint-deprecated-owned-vector.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -13,5 +13,4 @@\n fn main() {\n     ~[1]; //~ ERROR use of deprecated `~[]`\n     //~^ ERROR use of deprecated `~[]`\n-    std::slice::with_capacity::<int>(10); //~ ERROR use of deprecated `~[]`\n }"}, {"sha": "3a4844301d62e51f6a839363b8b94671a648d93a", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -29,7 +29,12 @@ use test::B;\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n-use std::slice::{from_fn, from_elem};   //~ ERROR unused import\n+use test2::{foo, bar}; //~ ERROR unused import\n+\n+mod test2 {\n+    pub fn foo() {}\n+    pub fn bar() {}\n+}\n \n mod test {\n     pub trait A { fn a(&self) {} }\n@@ -66,5 +71,5 @@ fn main() {\n     let mut b = 4;\n     swap(&mut a, &mut b);\n     test::C.b();\n-    let _a = from_elem(0, 0);\n+    let _a = foo();\n }"}, {"sha": "bf4e15c7ef51f1427784ac9092a711ef6b27ead0", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675b82657e7d9fd4c824ff3c6dbead1edd1ab515/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "patch": "@@ -36,7 +36,7 @@ fn double() {\n }\n \n fn runtest(me: &str) {\n-    let mut env = os::env();\n+    let mut env = os::env().move_iter().collect::<Vec<(~str, ~str)>>();\n     match env.iter().position(|&(ref s, _)| \"RUST_BACKTRACE\" == *s) {\n         Some(i) => { env.remove(i); }\n         None => {}"}]}