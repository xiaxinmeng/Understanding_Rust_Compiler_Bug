{"sha": "04700066f38409df2ca05de98d6998c41cbd7ba0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NzAwMDY2ZjM4NDA5ZGYyY2EwNWRlOThkNjk5OGM0MWNiZDdiYTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-31T22:09:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-31T23:24:08Z"}, "message": "Convert fuzzer to istrs. Issue #855", "tree": {"sha": "891a97f881dfbdcbdb10ed0b8108fa44b47a9558", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/891a97f881dfbdcbdb10ed0b8108fa44b47a9558"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04700066f38409df2ca05de98d6998c41cbd7ba0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04700066f38409df2ca05de98d6998c41cbd7ba0", "html_url": "https://github.com/rust-lang/rust/commit/04700066f38409df2ca05de98d6998c41cbd7ba0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04700066f38409df2ca05de98d6998c41cbd7ba0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81b31429e48ec6ea8fd91679246d847ecf0fc762", "url": "https://api.github.com/repos/rust-lang/rust/commits/81b31429e48ec6ea8fd91679246d847ecf0fc762", "html_url": "https://github.com/rust-lang/rust/commit/81b31429e48ec6ea8fd91679246d847ecf0fc762"}], "stats": {"total": 167, "additions": 84, "deletions": 83}, "files": [{"sha": "6ebaa0f593246fc4fac0db644dd526c6c12c52da", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 84, "deletions": 83, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/04700066f38409df2ca05de98d6998c41cbd7ba0/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04700066f38409df2ca05de98d6998c41cbd7ba0/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=04700066f38409df2ca05de98d6998c41cbd7ba0", "patch": "@@ -21,30 +21,30 @@ import rustc::syntax::codemap;\n import rustc::syntax::parse::parser;\n import rustc::syntax::print::pprust;\n \n-fn write_file(filename: &str, content: &str) {\n-    io::file_writer(istr::from_estr(filename), [io::create, io::truncate]).write_str(istr::from_estr(content));\n+fn write_file(filename: &istr, content: &istr) {\n+    io::file_writer(filename, [io::create, io::truncate]).write_str(content);\n     // Work around https://github.com/graydon/rust/issues/726\n-    std::run::run_program(~\"chmod\", [~\"644\", istr::from_estr(filename)]);\n+    std::run::run_program(~\"chmod\", [~\"644\", filename]);\n }\n \n-fn file_contains(filename: &str, needle: &str) -> bool {\n-    let contents = istr::to_estr(io::read_whole_file_str(istr::from_estr(filename)));\n-    ret str::find(contents, needle) != -1;\n+fn file_contains(filename: &istr, needle: &istr) -> bool {\n+    let contents = io::read_whole_file_str(filename);\n+    ret istr::find(contents, needle) != -1;\n }\n \n-fn contains(haystack: &str, needle: &str) -> bool {\n-    str::find(haystack, needle) != -1\n+fn contains(haystack: &istr, needle: &istr) -> bool {\n+    istr::find(haystack, needle) != -1\n }\n \n-fn find_rust_files(files: &mutable [str], path: str) {\n-    if str::ends_with(path, \".rs\") {\n-        if file_contains(path, \"xfail-test\") {\n+fn find_rust_files(files: &mutable [istr], path: &istr) {\n+    if istr::ends_with(path, ~\".rs\") {\n+        if file_contains(path, ~\"xfail-test\") {\n             //log_err \"Skipping \" + path + \" because it is marked as xfail-test\";\n         } else { files += [path]; }\n-    } else if fs::file_is_dir(istr::from_estr(path))\n-        && str::find(path, \"compile-fail\") == -1 {\n-        for p in fs::list_dir(istr::from_estr(path)) {\n-            find_rust_files(files, istr::to_estr(p));\n+    } else if fs::file_is_dir(path)\n+        && istr::find(path, ~\"compile-fail\") == -1 {\n+        for p in fs::list_dir(path) {\n+            find_rust_files(files, p);\n         }\n     }\n }\n@@ -151,14 +151,14 @@ iter under(n: uint) -> uint {\n \n fn devnull() -> io::writer { std::io::string_writer().get_writer() }\n \n-fn as_str(f: fn(io::writer)) -> str {\n+fn as_str(f: fn(io::writer)) -> istr {\n     let w = std::io::string_writer();\n     f(w.get_writer());\n-    ret istr::to_estr(w.get_str());\n+    ret w.get_str();\n }\n \n fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n-                         filename: &str) {\n+                         filename: &istr) {\n     let exprs = steal_exprs(crate);\n     let exprsL = vec::len(exprs);\n     if exprsL < 100u {\n@@ -171,7 +171,7 @@ fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n                 // string for stability is easier and ok for now.\n                 let str3 =\n                     as_str(bind pprust::print_crate(codemap, crate2,\n-                                                    istr::from_estr(filename),\n+                                                    filename,\n                                                     io::string_reader(~\"\"), _,\n                                                     pprust::no_ann()));\n                 // 1u would be sane here, but the pretty-printer currently has lots of whitespace and paren issues,\n@@ -187,93 +187,93 @@ fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n // - that would find many \"false positives\" or unimportant bugs\n // - that would be tricky, requiring use of tasks or serialization or randomness.\n // This seems to find plenty of bugs as it is :)\n-fn check_whole_compiler(code: &str) {\n-    let filename = \"test.rs\";\n+fn check_whole_compiler(code: &istr) {\n+    let filename = ~\"test.rs\";\n     write_file(filename, code);\n     let p =\n         std::run::program_output(\n             ~\"/Users/jruderman/code/rust/build/stage1/rustc\",\n-            [~\"-c\", istr::from_estr(filename)]);\n+            [~\"-c\", filename]);\n \n     //log_err #ifmt(\"Status: %d\", p.status);\n     //log_err \"Output: \" + p.out;\n     if p.err != ~\"\" {\n-        if contains(istr::to_estr(p.err), \"argument of incompatible type\") {\n+        if contains(p.err, ~\"argument of incompatible type\") {\n             log_err \"https://github.com/graydon/rust/issues/769\";\n-        } else if contains(istr::to_estr(p.err),\n-                           \"Cannot create binary operator with two operands of differing type\")\n+        } else if contains(p.err,\n+                           ~\"Cannot create binary operator with two operands of differing type\")\n          {\n             log_err \"https://github.com/graydon/rust/issues/770\";\n-        } else if contains(istr::to_estr(p.err), \"May only branch on boolean predicates!\") {\n+        } else if contains(p.err, ~\"May only branch on boolean predicates!\") {\n             log_err \"https://github.com/graydon/rust/issues/770 or https://github.com/graydon/rust/issues/776\";\n-        } else if contains(istr::to_estr(p.err), \"Invalid constantexpr cast!\") &&\n-                      contains(code, \"!\") {\n+        } else if contains(p.err, ~\"Invalid constantexpr cast!\") &&\n+                      contains(code, ~\"!\") {\n             log_err \"https://github.com/graydon/rust/issues/777\";\n-        } else if contains(istr::to_estr(p.err),\n-                           \"Both operands to ICmp instruction are not of the same type!\")\n-                      && contains(code, \"!\") {\n+        } else if contains(p.err,\n+                           ~\"Both operands to ICmp instruction are not of the same type!\")\n+                      && contains(code, ~\"!\") {\n             log_err \"https://github.com/graydon/rust/issues/777 #issuecomment-1678487\";\n-        } else if contains(istr::to_estr(p.err), \"Ptr must be a pointer to Val type!\") &&\n-                      contains(code, \"!\") {\n+        } else if contains(p.err, ~\"Ptr must be a pointer to Val type!\") &&\n+                      contains(code, ~\"!\") {\n             log_err \"https://github.com/graydon/rust/issues/779\";\n-        } else if contains(istr::to_estr(p.err), \"Calling a function with bad signature!\") &&\n-                      (contains(code, \"iter\") || contains(code, \"range\")) {\n+        } else if contains(p.err, ~\"Calling a function with bad signature!\") &&\n+                      (contains(code, ~\"iter\") || contains(code, ~\"range\")) {\n             log_err \"https://github.com/graydon/rust/issues/771 - calling an iter fails\";\n-        } else if contains(istr::to_estr(p.err), \"Calling a function with a bad signature!\")\n-                      && contains(code, \"empty\") {\n+        } else if contains(p.err, ~\"Calling a function with a bad signature!\")\n+                      && contains(code, ~\"empty\") {\n             log_err \"https://github.com/graydon/rust/issues/775 - possibly a modification of run-pass/import-glob-crate.rs\";\n-        } else if contains(istr::to_estr(p.err), \"Invalid type for pointer element!\") &&\n-                      contains(code, \"put\") {\n+        } else if contains(p.err, ~\"Invalid type for pointer element!\") &&\n+                      contains(code, ~\"put\") {\n             log_err \"https://github.com/graydon/rust/issues/773 - put put ()\";\n-        } else if contains(istr::to_estr(p.err), \"pointer being freed was not allocated\") &&\n-                      contains(istr::to_estr(p.out), \"Out of stack space, sorry\") {\n+        } else if contains(p.err, ~\"pointer being freed was not allocated\") &&\n+                      contains(p.out, ~\"Out of stack space, sorry\") {\n             log_err \"https://github.com/graydon/rust/issues/768 + https://github.com/graydon/rust/issues/778\"\n         } else {\n             log_err ~\"Stderr: \" + p.err;\n             fail \"Unfamiliar error message\";\n         }\n-    } else if contains(istr::to_estr(p.out), \"non-exhaustive match failure\") &&\n-                  contains(istr::to_estr(p.out), \"alias.rs\") {\n+    } else if contains(p.out, ~\"non-exhaustive match failure\") &&\n+                  contains(p.out, ~\"alias.rs\") {\n         log_err \"https://github.com/graydon/rust/issues/772\";\n-    } else if contains(istr::to_estr(p.out), \"non-exhaustive match failure\") &&\n-                  contains(istr::to_estr(p.out), \"trans.rs\") && contains(code, \"put\") {\n+    } else if contains(p.out, ~\"non-exhaustive match failure\") &&\n+                  contains(p.out, ~\"trans.rs\") && contains(code, ~\"put\") {\n         log_err \"https://github.com/graydon/rust/issues/774\";\n-    } else if contains(istr::to_estr(p.out), \"Out of stack space, sorry\") {\n+    } else if contains(p.out, ~\"Out of stack space, sorry\") {\n         log_err \"Possibly a variant of https://github.com/graydon/rust/issues/768\";\n     } else if p.status == 256 {\n-        if !contains(istr::to_estr(p.out), \"error:\") {\n+        if !contains(p.out, ~\"error:\") {\n             fail \"Exited with status 256 without a span-error\";\n         }\n     } else if p.status == 11 {\n         log_err \"What is this I don't even\";\n     } else if p.status != 0 { fail \"Unfamiliar status code\"; }\n }\n \n-fn parse_and_print(code: &str) -> str {\n-    let filename = \"tmp.rs\";\n+fn parse_and_print(code: &istr) -> istr {\n+    let filename = ~\"tmp.rs\";\n     let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n     //write_file(filename, code);\n     let crate = parser::parse_crate_from_source_str(\n-        istr::from_estr(filename), istr::from_estr(code), [], sess);\n+        filename, code, [], sess);\n     ret as_str(bind pprust::print_crate(sess.cm, crate,\n-                                        istr::from_estr(filename),\n-                                        io::string_reader(istr::from_estr(code)), _,\n+                                        filename,\n+                                        io::string_reader(code), _,\n                                         pprust::no_ann()));\n }\n \n-fn content_is_dangerous_to_modify(code: &str) -> bool {\n+fn content_is_dangerous_to_modify(code: &istr) -> bool {\n     let dangerous_patterns =\n-        [\"obj\", // not safe to steal; https://github.com/graydon/rust/issues/761\n-         \"#macro\", // not safe to steal things inside of it, because they have a special syntax\n-         \"#\", // strange representation of the arguments to #ifmt, for example\n-         \" be \", // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n-         \"@\"]; // hangs when compiling: https://github.com/graydon/rust/issues/768\n+        [~\"obj\", // not safe to steal; https://github.com/graydon/rust/issues/761\n+         ~\"#macro\", // not safe to steal things inside of it, because they have a special syntax\n+         ~\"#\", // strange representation of the arguments to #ifmt, for example\n+         ~\" be \", // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n+         ~\"@\"]; // hangs when compiling: https://github.com/graydon/rust/issues/768\n \n-    for p: str in dangerous_patterns { if contains(code, p) { ret true; } }\n+    for p: istr in dangerous_patterns { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn content_is_confusing(code: &str) ->\n+fn content_is_confusing(code: &istr) ->\n    bool { // https://github.com/graydon/rust/issues/671\n           // https://github.com/graydon/rust/issues/669\n           // https://github.com/graydon/rust/issues/669\n@@ -283,16 +283,16 @@ fn content_is_confusing(code: &str) ->\n           // more precedence issues?\n \n     let confusing_patterns =\n-        [\"#macro\", \"][]\", \"][mutable]\", \"][mutable ]\", \"self\", \"spawn\",\n-         \"bind\", \"\\n\\n\\n\\n\\n\", // https://github.com/graydon/rust/issues/759\n-         \" : \", // https://github.com/graydon/rust/issues/760\n-         \"if ret\", \"alt ret\", \"if fail\", \"alt fail\"];\n+        [~\"#macro\", ~\"][]\", ~\"][mutable]\", ~\"][mutable ]\", ~\"self\", ~\"spawn\",\n+         ~\"bind\", ~\"\\n\\n\\n\\n\\n\", // https://github.com/graydon/rust/issues/759\n+         ~\" : \", // https://github.com/graydon/rust/issues/760\n+         ~\"if ret\", ~\"alt ret\", ~\"if fail\", ~\"alt fail\"];\n \n-    for p: str in confusing_patterns { if contains(code, p) { ret true; } }\n+    for p: istr in confusing_patterns { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn file_is_confusing(filename: &str) -> bool {\n+fn file_is_confusing(filename: &istr) -> bool {\n \n     // https://github.com/graydon/rust/issues/674\n \n@@ -303,16 +303,16 @@ fn file_is_confusing(filename: &str) -> bool {\n     // which i can't reproduce using \"rustc\n     // --pretty normal\"???\n     let confusing_files =\n-        [\"block-expr-precedence.rs\", \"nil-pattern.rs\",\n-         \"syntax-extension-fmt.rs\",\n-         \"newtype.rs\"]; // modifying it hits something like https://github.com/graydon/rust/issues/670\n+        [~\"block-expr-precedence.rs\", ~\"nil-pattern.rs\",\n+         ~\"syntax-extension-fmt.rs\",\n+         ~\"newtype.rs\"]; // modifying it hits something like https://github.com/graydon/rust/issues/670\n \n     for f in confusing_files { if contains(filename, f) { ret true; } }\n \n     ret false;\n }\n \n-fn check_roundtrip_convergence(code: &str, maxIters: uint) {\n+fn check_roundtrip_convergence(code: &istr, maxIters: uint) {\n \n     let i = 0u;\n     let new = code;\n@@ -330,54 +330,55 @@ fn check_roundtrip_convergence(code: &str, maxIters: uint) {\n         log_err #ifmt[\"Converged after %u iterations\", i];\n     } else {\n         log_err #ifmt[\"Did not converge after %u iterations!\", i];\n-        write_file(\"round-trip-a.rs\", old);\n-        write_file(\"round-trip-b.rs\", new);\n+        write_file(~\"round-trip-a.rs\", old);\n+        write_file(~\"round-trip-b.rs\", new);\n         std::run::run_program(~\"diff\",\n                               [~\"-w\", ~\"-u\", ~\"round-trip-a.rs\",\n                                ~\"round-trip-b.rs\"]);\n         fail \"Mismatch\";\n     }\n }\n \n-fn check_convergence(files: &[str]) {\n+fn check_convergence(files: &[istr]) {\n     log_err #ifmt[\"pp convergence tests: %u files\", vec::len(files)];\n     for file in files {\n         if !file_is_confusing(file) {\n-            let s = istr::to_estr(io::read_whole_file_str(istr::from_estr(file)));\n+            let s = io::read_whole_file_str(file);\n             if !content_is_confusing(s) {\n-                log_err #ifmt[\"pp converge: %s\", istr::from_estr(file)];\n+                log_err #ifmt[\"pp converge: %s\", file];\n                 // Change from 7u to 2u when https://github.com/graydon/rust/issues/759 is fixed\n                 check_roundtrip_convergence(s, 7u);\n             }\n         }\n     }\n }\n \n-fn check_variants(files: &[str]) {\n+fn check_variants(files: &[istr]) {\n     for file in files {\n         if !file_is_confusing(file) {\n-            let s = istr::to_estr(io::read_whole_file_str(istr::from_estr(file)));\n+            let s = io::read_whole_file_str(file);\n             if content_is_dangerous_to_modify(s) || content_is_confusing(s) {\n                 cont;\n             }\n-            log_err \"check_variants: \" + file;\n+            log_err ~\"check_variants: \" + file;\n             let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n             let crate =\n                 parser::parse_crate_from_source_str(\n-                    istr::from_estr(file),\n-                    istr::from_estr(s), [], sess);\n+                    file,\n+                    s, [], sess);\n             log_err as_str(bind pprust::print_crate(sess.cm, crate,\n-                                                    istr::from_estr(file),\n-                                                    io::string_reader(istr::from_estr(s)), _,\n+                                                    file,\n+                                                    io::string_reader(s), _,\n                                                     pprust::no_ann()));\n             check_variants_of_ast(*crate, sess.cm, file);\n         }\n     }\n }\n \n fn main(args: [str]) {\n+    let args = istr::from_estrs(args);\n     if vec::len(args) != 2u {\n-        log_err #ifmt[\"usage: %s <testdir>\", istr::from_estr(args[0])];\n+        log_err #ifmt[\"usage: %s <testdir>\", args[0]];\n         ret;\n     }\n     let files = [];"}]}