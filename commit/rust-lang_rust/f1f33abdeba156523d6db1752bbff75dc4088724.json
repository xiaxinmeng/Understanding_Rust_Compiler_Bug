{"sha": "f1f33abdeba156523d6db1752bbff75dc4088724", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZjMzYWJkZWJhMTU2NTIzZDZkYjE3NTJiYmZmNzVkYzQwODg3MjQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-15T01:46:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-15T01:46:28Z"}, "message": "Move all non-decl/non-expr stmts to exprs.", "tree": {"sha": "9591e536c2a2197756c36859727b20fd0af19cde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9591e536c2a2197756c36859727b20fd0af19cde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1f33abdeba156523d6db1752bbff75dc4088724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f33abdeba156523d6db1752bbff75dc4088724", "html_url": "https://github.com/rust-lang/rust/commit/f1f33abdeba156523d6db1752bbff75dc4088724", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1f33abdeba156523d6db1752bbff75dc4088724/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88cb9663639e915d2b69cef7ec514043ed39e5f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/88cb9663639e915d2b69cef7ec514043ed39e5f4", "html_url": "https://github.com/rust-lang/rust/commit/88cb9663639e915d2b69cef7ec514043ed39e5f4"}], "stats": {"total": 405, "additions": 212, "deletions": 193}, "files": [{"sha": "53ffdd87cb1f4298f7c2d2b4b3f452daf2da0357", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=f1f33abdeba156523d6db1752bbff75dc4088724", "patch": "@@ -116,11 +116,6 @@ tag mode {\n type stmt = spanned[stmt_];\n tag stmt_ {\n     stmt_decl(@decl);\n-    stmt_ret(option.t[@expr]);\n-    stmt_be(@expr);\n-    stmt_log(@expr);\n-    stmt_check_expr(@expr);\n-    stmt_fail;\n     stmt_expr(@expr);\n }\n \n@@ -165,6 +160,11 @@ tag expr_ {\n     expr_index(@expr, @expr, ann);\n     expr_path(path, option.t[def], ann);\n     expr_ext(vec[@expr], option.t[@expr], ann);\n+    expr_fail;\n+    expr_ret(option.t[@expr]);\n+    expr_be(@expr);\n+    expr_log(@expr);\n+    expr_check_expr(@expr);\n }\n \n type lit = spanned[lit_];"}, {"sha": "5ffaca197c3ccbe02d6ac34f8d5fce3a0223edf6", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=f1f33abdeba156523d6db1752bbff75dc4088724", "patch": "@@ -598,6 +598,59 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n             ex = ast.expr_ext(es.node, none[@ast.expr], ast.ann_none);\n         }\n \n+        case (token.FAIL) {\n+            p.bump();\n+            ex = ast.expr_fail;\n+        }\n+\n+        case (token.LOG) {\n+            p.bump();\n+            auto e = parse_expr(p);\n+            auto hi = e.span;\n+            ex = ast.expr_log(e);\n+        }\n+\n+        case (token.CHECK) {\n+            p.bump();\n+            alt (p.peek()) {\n+                case (token.LPAREN) {\n+                    auto e = parse_expr(p);\n+                    auto hi = e.span;\n+                    ex = ast.expr_check_expr(e);\n+                }\n+                case (_) {\n+                    p.get_session().unimpl(\"constraint-check stmt\");\n+                }\n+            }\n+        }\n+\n+        case (token.RET) {\n+            p.bump();\n+            alt (p.peek()) {\n+                case (token.SEMI) {\n+                    ex = ast.expr_ret(none[@ast.expr]);\n+                }\n+                case (_) {\n+                    auto e = parse_expr(p);\n+                    hi = e.span;\n+                    ex = ast.expr_ret(some[@ast.expr](e));\n+                }\n+            }\n+        }\n+\n+        case (token.BE) {\n+            p.bump();\n+            auto e = parse_expr(p);\n+            // FIXME: Is this the right place for this check?\n+            if /*check*/ (ast.is_call_expr(e)) {\n+                    hi = e.span;\n+                    ex = ast.expr_be(e);\n+            }\n+            else {\n+                p.err(\"Non-call expression in tail call\");\n+            }\n+        }\n+\n         case (_) {\n             auto lit = parse_lit(p);\n             hi = lit.span;\n@@ -1203,59 +1256,6 @@ impure fn parse_stmt(parser p) -> @ast.stmt {\n     auto lo = p.get_span();\n     alt (p.peek()) {\n \n-        case (token.LOG) {\n-            p.bump();\n-            auto e = parse_expr(p);\n-            auto hi = p.get_span();\n-            ret @spanned(lo, hi, ast.stmt_log(e));\n-        }\n-\n-        case (token.CHECK) {\n-            p.bump();\n-            alt (p.peek()) {\n-                case (token.LPAREN) {\n-                    auto e = parse_expr(p);\n-                    auto hi = p.get_span();\n-                    ret @spanned(lo, hi, ast.stmt_check_expr(e));\n-                }\n-                case (_) {\n-                    p.get_session().unimpl(\"constraint-check stmt\");\n-                }\n-            }\n-        }\n-\n-        case (token.FAIL) {\n-            p.bump();\n-            ret @spanned(lo, p.get_span(), ast.stmt_fail);\n-        }\n-\n-        case (token.RET) {\n-            p.bump();\n-            alt (p.peek()) {\n-                case (token.SEMI) {\n-                    ret @spanned(lo, p.get_span(),\n-                                 ast.stmt_ret(none[@ast.expr]));\n-                }\n-                case (_) {\n-                    auto e = parse_expr(p);\n-                    ret @spanned(lo, e.span,\n-                                 ast.stmt_ret(some[@ast.expr](e)));\n-                }\n-            }\n-        }\n-\n-        case (token.BE) {\n-            p.bump();\n-            auto e = parse_expr(p);\n-            // FIXME: Is this the right place for this check?\n-            if /*check*/ (ast.is_call_expr(e)) {\n-                ret @spanned(lo, e.span, ast.stmt_be(e));\n-            }\n-            else {\n-                p.err(\"Non-call expression in tail call\");\n-            }\n-        }\n-\n         case (token.LET) {\n             auto decl = parse_let(p);\n             auto hi = p.get_span();\n@@ -1396,11 +1396,6 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.decl_item(_)) { ret false; }\n             }\n         }\n-        case (ast.stmt_ret(_))                  { ret true; }\n-        case (ast.stmt_be(_))                   { ret true; }\n-        case (ast.stmt_log(_))                  { ret true; }\n-        case (ast.stmt_check_expr(_))           { ret true; }\n-        case (ast.stmt_fail)                    { ret true; }\n         case (ast.stmt_expr(?e)) {\n             alt (e.node) {\n                 case (ast.expr_vec(_,_))        { ret true; }\n@@ -1423,6 +1418,11 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.expr_field(_,_,_))    { ret true; }\n                 case (ast.expr_index(_,_,_))    { ret true; }\n                 case (ast.expr_path(_,_,_))     { ret true; }\n+                case (ast.expr_fail)            { ret true; }\n+                case (ast.expr_ret(_))          { ret true; }\n+                case (ast.expr_be(_))           { ret true; }\n+                case (ast.expr_log(_))          { ret true; }\n+                case (ast.expr_check_expr(_))   { ret true; }\n             }\n         }\n     }"}, {"sha": "4e8ea31745159a5f17f77af2a7bad6be169b7723", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 72, "deletions": 64, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=f1f33abdeba156523d6db1752bbff75dc4088724", "patch": "@@ -149,6 +149,20 @@ type ast_fold[ENV] =\n          &option.t[def] d,\n          ann a) -> @expr)                         fold_expr_path,\n \n+     (fn(&ENV e, &span sp) -> @expr)              fold_expr_fail,\n+\n+     (fn(&ENV e, &span sp,\n+         &option.t[@expr] rv) -> @expr)           fold_expr_ret,\n+\n+     (fn(&ENV e, &span sp,\n+         @expr e) -> @expr)                       fold_expr_be,\n+\n+     (fn(&ENV e, &span sp,\n+         @expr e) -> @expr)                       fold_expr_log,\n+\n+     (fn(&ENV e, &span sp,\n+         @expr e) -> @expr)                       fold_expr_check_expr,\n+\n      // Decl folds.\n      (fn(&ENV e, &span sp,\n          @ast.local local) -> @decl)              fold_decl_local,\n@@ -177,18 +191,6 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp,\n          @decl decl) -> @stmt)                    fold_stmt_decl,\n \n-     (fn(&ENV e, &span sp,\n-         &option.t[@expr] rv) -> @stmt)           fold_stmt_ret,\n-\n-     (fn(&ENV e, &span sp,\n-         @expr e) -> @stmt)                       fold_stmt_be,\n-\n-     (fn(&ENV e, &span sp,\n-         @expr e) -> @stmt)                       fold_stmt_log,\n-\n-     (fn(&ENV e, &span sp,\n-         @expr e) -> @stmt)                       fold_stmt_check_expr,\n-\n      (fn(&ENV e, &span sp,\n          @expr e) -> @stmt)                       fold_stmt_expr,\n \n@@ -622,6 +624,37 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             auto p_ = fold_path(env_, fld, p);\n             ret fld.fold_expr_path(env_, e.span, p_, r, t);\n         }\n+\n+        case (ast.expr_fail) {\n+            ret fld.fold_expr_fail(env_, e.span);\n+        }\n+\n+        case (ast.expr_ret(?oe)) {\n+            auto oee = none[@expr];\n+            alt (oe) {\n+                case (some[@expr](?x)) {\n+                    oee = some(fold_expr(env_, fld, x));\n+                }\n+                case (_) { /* fall through */  }\n+            }\n+            ret fld.fold_expr_ret(env_, e.span, oee);\n+        }\n+\n+        case (ast.expr_be(?x)) {\n+            auto ee = fold_expr(env_, fld, x);\n+            ret fld.fold_expr_be(env_, e.span, ee);\n+        }\n+\n+        case (ast.expr_log(?x)) {\n+            auto ee = fold_expr(env_, fld, x);\n+            ret fld.fold_expr_log(env_, e.span, ee);\n+        }\n+\n+        case (ast.expr_check_expr(?x)) {\n+            auto ee = fold_expr(env_, fld, x);\n+            ret fld.fold_expr_check_expr(env_, e.span, ee);\n+        }\n+\n     }\n \n     ret e;\n@@ -642,36 +675,6 @@ fn fold_stmt[ENV](&ENV env, ast_fold[ENV] fld, &@stmt s) -> @stmt {\n             ret fld.fold_stmt_decl(env_, s.span, dd);\n         }\n \n-        case (ast.stmt_ret(?oe)) {\n-            auto oee = none[@expr];\n-            alt (oe) {\n-                case (some[@expr](?e)) {\n-                    oee = some(fold_expr(env_, fld, e));\n-                }\n-                case (_) { /* fall through */  }\n-            }\n-            ret fld.fold_stmt_ret(env_, s.span, oee);\n-        }\n-\n-        case (ast.stmt_be(?e)) {\n-            auto ee = fold_expr(env_, fld, e);\n-            ret fld.fold_stmt_be(env_, s.span, ee);\n-        }\n-\n-        case (ast.stmt_log(?e)) {\n-            auto ee = fold_expr(env_, fld, e);\n-            ret fld.fold_stmt_log(env_, s.span, ee);\n-        }\n-\n-        case (ast.stmt_check_expr(?e)) {\n-            auto ee = fold_expr(env_, fld, e);\n-            ret fld.fold_stmt_check_expr(env_, s.span, ee);\n-        }\n-\n-        case (ast.stmt_fail) {\n-            ret s;\n-        }\n-\n         case (ast.stmt_expr(?e)) {\n             auto ee = fold_expr(env_, fld, e);\n             ret fld.fold_stmt_expr(env_, s.span, ee);\n@@ -1118,6 +1121,27 @@ fn identity_fold_expr_path[ENV](&ENV env, &span sp,\n     ret @respan(sp, ast.expr_path(p, d, a));\n }\n \n+fn identity_fold_expr_fail[ENV](&ENV env, &span sp) -> @expr {\n+    ret @respan(sp, ast.expr_fail);\n+}\n+\n+fn identity_fold_expr_ret[ENV](&ENV env, &span sp,\n+                               &option.t[@expr] rv) -> @expr {\n+    ret @respan(sp, ast.expr_ret(rv));\n+}\n+\n+fn identity_fold_expr_be[ENV](&ENV env, &span sp, @expr x) -> @expr {\n+    ret @respan(sp, ast.expr_be(x));\n+}\n+\n+fn identity_fold_expr_log[ENV](&ENV e, &span sp, @expr x) -> @expr {\n+    ret @respan(sp, ast.expr_log(x));\n+}\n+\n+fn identity_fold_expr_check_expr[ENV](&ENV e, &span sp, @expr x) -> @expr {\n+    ret @respan(sp, ast.expr_check_expr(x));\n+}\n+\n \n // Decl identities.\n \n@@ -1158,23 +1182,6 @@ fn identity_fold_stmt_decl[ENV](&ENV env, &span sp, @decl d) -> @stmt {\n     ret @respan(sp, ast.stmt_decl(d));\n }\n \n-fn identity_fold_stmt_ret[ENV](&ENV env, &span sp,\n-                               &option.t[@expr] rv) -> @stmt {\n-    ret @respan(sp, ast.stmt_ret(rv));\n-}\n-\n-fn identity_fold_stmt_be[ENV](&ENV env, &span sp, @expr x) -> @stmt {\n-    ret @respan(sp, ast.stmt_be(x));\n-}\n-\n-fn identity_fold_stmt_log[ENV](&ENV e, &span sp, @expr x) -> @stmt {\n-    ret @respan(sp, ast.stmt_log(x));\n-}\n-\n-fn identity_fold_stmt_check_expr[ENV](&ENV e, &span sp, @expr x) -> @stmt {\n-    ret @respan(sp, ast.stmt_check_expr(x));\n-}\n-\n fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, @expr x) -> @stmt {\n     ret @respan(sp, ast.stmt_expr(x));\n }\n@@ -1387,6 +1394,12 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_field  = bind identity_fold_expr_field[ENV](_,_,_,_,_),\n          fold_expr_index  = bind identity_fold_expr_index[ENV](_,_,_,_,_),\n          fold_expr_path   = bind identity_fold_expr_path[ENV](_,_,_,_,_),\n+         fold_expr_fail   = bind identity_fold_expr_fail[ENV](_,_),\n+         fold_expr_ret    = bind identity_fold_expr_ret[ENV](_,_,_),\n+         fold_expr_be     = bind identity_fold_expr_be[ENV](_,_,_),\n+         fold_expr_log    = bind identity_fold_expr_log[ENV](_,_,_),\n+         fold_expr_check_expr\n+                          = bind identity_fold_expr_check_expr[ENV](_,_,_),\n \n          fold_decl_local  = bind identity_fold_decl_local[ENV](_,_,_),\n          fold_decl_item   = bind identity_fold_decl_item[ENV](_,_,_),\n@@ -1397,11 +1410,6 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_pat_tag     = bind identity_fold_pat_tag[ENV](_,_,_,_,_,_),\n \n          fold_stmt_decl   = bind identity_fold_stmt_decl[ENV](_,_,_),\n-         fold_stmt_ret    = bind identity_fold_stmt_ret[ENV](_,_,_),\n-         fold_stmt_be     = bind identity_fold_stmt_be[ENV](_,_,_),\n-         fold_stmt_log    = bind identity_fold_stmt_log[ENV](_,_,_),\n-         fold_stmt_check_expr\n-                          = bind identity_fold_stmt_check_expr[ENV](_,_,_),\n          fold_stmt_expr   = bind identity_fold_stmt_expr[ENV](_,_,_),\n \n          fold_item_const= bind identity_fold_item_const[ENV](_,_,_,_,_,_,_),"}, {"sha": "e140ddccef16bac0fd515cfcfed93301a4f9e7cd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f1f33abdeba156523d6db1752bbff75dc4088724", "patch": "@@ -3106,6 +3106,26 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_rec(cx, args, base, ann);\n         }\n \n+        case (ast.expr_fail) {\n+            ret trans_fail(cx, e.span, \"explicit failure\");\n+        }\n+\n+        case (ast.expr_log(?a)) {\n+            ret trans_log(cx, a);\n+        }\n+\n+        case (ast.expr_check_expr(?a)) {\n+            ret trans_check_expr(cx, a);\n+        }\n+\n+        case (ast.expr_ret(?e)) {\n+            ret trans_ret(cx, e);\n+        }\n+\n+        case (ast.expr_be(?e)) {\n+            ret trans_be(cx, e);\n+        }\n+\n         // lval cases fall through to trans_lval and then\n         // possibly load the result (if it's non-structural).\n \n@@ -3255,26 +3275,6 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n     auto bcx = cx;\n     alt (s.node) {\n-        case (ast.stmt_log(?a)) {\n-            bcx = trans_log(cx, a).bcx;\n-        }\n-\n-        case (ast.stmt_check_expr(?a)) {\n-            bcx = trans_check_expr(cx, a).bcx;\n-        }\n-\n-        case (ast.stmt_fail) {\n-            bcx = trans_fail(cx, s.span, \"explicit failure\").bcx;\n-        }\n-\n-        case (ast.stmt_ret(?e)) {\n-            bcx = trans_ret(cx, e).bcx;\n-        }\n-\n-        case (ast.stmt_be(?e)) {\n-            bcx = trans_be(cx, e).bcx;\n-        }\n-\n         case (ast.stmt_expr(?e)) {\n             bcx = trans_expr(cx, e).bcx;\n         }"}, {"sha": "58529d0dc9c380818893d04a8ba594e864b021aa", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f1f33abdeba156523d6db1752bbff75dc4088724", "patch": "@@ -686,6 +686,12 @@ fn expr_ty(@ast.expr expr) -> @t {\n         case (ast.expr_field(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_index(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_path(_, _, ?ann))      { ret ann_to_type(ann); }\n+\n+        case (ast.expr_fail)                  { ret plain_ty(ty_nil); }\n+        case (ast.expr_log(_))                { ret plain_ty(ty_nil); }\n+        case (ast.expr_check_expr(_))         { ret plain_ty(ty_nil); }\n+        case (ast.expr_ret(_))                { ret plain_ty(ty_nil); }\n+        case (ast.expr_be(_))                 { ret plain_ty(ty_nil); }\n     }\n     fail;\n }"}, {"sha": "d0043c43940243e33f70041e915785fb72c82468", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f33abdeba156523d6db1752bbff75dc4088724/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f1f33abdeba156523d6db1752bbff75dc4088724", "patch": "@@ -1037,6 +1037,11 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                                  ann_to_type(ann), adk);\n             e_1 = ast.expr_path(pth, d, ast.ann_type(t));\n         }\n+        case (ast.expr_fail) { e_1 = e.node; }\n+        case (ast.expr_log(_)) { e_1 = e.node; }\n+        case (ast.expr_ret(_)) { e_1 = e.node; }\n+        case (ast.expr_be(_)) { e_1 = e.node; }\n+        case (ast.expr_check_expr(_)) { e_1 = e.node; }\n     }\n \n     ret @fold.respan[ast.expr_](e.span, e_1);\n@@ -1287,6 +1292,52 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                       ast.ann_type(t)));\n         }\n \n+        case (ast.expr_fail) {\n+            ret expr;\n+        }\n+\n+        case (ast.expr_ret(?expr_opt)) {\n+            alt (expr_opt) {\n+                case (none[@ast.expr]) {\n+                    auto nil = plain_ty(ty.ty_nil);\n+                    if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n+                        fcx.ccx.sess.err(\"ret; in function \"\n+                                         + \"returning non-nil\");\n+                    }\n+\n+                    ret expr;\n+                }\n+\n+                case (some[@ast.expr](?e)) {\n+                    auto expr_0 = check_expr(fcx, e);\n+                    auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n+                    ret @fold.respan[ast.expr_](expr.span,\n+                                                ast.expr_ret(some(expr_1)));\n+                }\n+            }\n+        }\n+\n+        case (ast.expr_be(?e)) {\n+            /* FIXME: prove instead of check */\n+            check ast.is_call_expr(e);\n+            auto expr_0 = check_expr(fcx, e);\n+            auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_be(expr_1));\n+        }\n+\n+        case (ast.expr_log(?e)) {\n+            auto expr_t = check_expr(fcx, e);\n+            ret @fold.respan[ast.expr_](expr.span, ast.expr_log(expr_t));\n+        }\n+\n+        case (ast.expr_check_expr(?e)) {\n+            auto expr_t = check_expr(fcx, e);\n+            demand(fcx, expr.span, plain_ty(ty.ty_bool), expr_ty(expr_t));\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_check_expr(expr_t));\n+        }\n+\n         case (ast.expr_assign(?lhs, ?rhs, _)) {\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n@@ -1806,52 +1857,6 @@ fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n             ret stmt;\n         }\n \n-        case (ast.stmt_ret(?expr_opt)) {\n-            alt (expr_opt) {\n-                case (none[@ast.expr]) {\n-                    auto nil = plain_ty(ty.ty_nil);\n-                    if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n-                        fcx.ccx.sess.err(\"ret; in function \"\n-                                         + \"returning non-nil\");\n-                    }\n-\n-                    ret stmt;\n-                }\n-\n-                case (some[@ast.expr](?expr)) {\n-                    auto expr_0 = check_expr(fcx, expr);\n-                    auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n-                    ret @fold.respan[ast.stmt_](stmt.span,\n-                                                ast.stmt_ret(some(expr_1)));\n-                }\n-            }\n-        }\n-\n-        case (ast.stmt_be(?expr)) {\n-            /* FIXME: prove instead of check */\n-            check ast.is_call_expr(expr);\n-            auto expr_0 = check_expr(fcx, expr);\n-            auto expr_1 = demand_expr(fcx, fcx.ret_ty, expr_0);\n-            ret @fold.respan[ast.stmt_](stmt.span,\n-                                        ast.stmt_be(expr_1));\n-        }\n-\n-        case (ast.stmt_log(?expr)) {\n-            auto expr_t = check_expr(fcx, expr);\n-            ret @fold.respan[ast.stmt_](stmt.span, ast.stmt_log(expr_t));\n-        }\n-\n-        case (ast.stmt_check_expr(?expr)) {\n-            auto expr_t = check_expr(fcx, expr);\n-            demand(fcx, expr.span, plain_ty(ty.ty_bool), expr_ty(expr_t));\n-            ret @fold.respan[ast.stmt_](stmt.span,\n-                                        ast.stmt_check_expr(expr_t));\n-        }\n-\n-        case (ast.stmt_fail) {\n-            ret stmt;\n-        }\n-\n         case (ast.stmt_expr(?expr)) {\n             auto expr_t = check_expr(fcx, expr);\n             ret @fold.respan[ast.stmt_](stmt.span, ast.stmt_expr(expr_t));"}]}