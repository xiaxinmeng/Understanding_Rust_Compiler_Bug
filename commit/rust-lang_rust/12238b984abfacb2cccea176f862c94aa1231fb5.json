{"sha": "12238b984abfacb2cccea176f862c94aa1231fb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMjM4Yjk4NGFiZmFjYjJjY2NlYTE3NmY4NjJjOTRhYTEyMzFmYjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-04T17:47:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-04T17:47:55Z"}, "message": "Auto merge of #33816 - nikomatsakis:projection-cache-2, r=arielb1\n\nProjection cache and better warnings for #32330\n\nThis PR does three things:\n\n- it lays the groundwork for the more precise subtyping rules discussed in #32330, but does not enable them;\n- it issues warnings when the result of a leak-check or subtyping check relies on a late-bound region which will late become early-bound when #32330 is fixed;\n- it introduces a cache for projection in the inference context.\n\nI'm not 100% happy with the approach taken by the cache here, but it seems like a step in the right direction. It results in big wins on some test cases, but not as big as previous versions -- I think because it is caching the `Vec<Obligation>` (whereas before I just returned the normalized type with an empty vector). However, that change was needed to fix an ICE in @alexcrichton's future-rs module (I haven't fully tracked the cause of that ICE yet). Also, because trans/the collector use a fresh inference context for every call to `fulfill_obligation`, they don't profit nearly as much from this cache as they ought to.\n\nStill, here are the results from the future-rs `retry.rs`:\n\n```\n06:26 <nmatsakis> time: 6.246; rss: 44MB  item-bodies checking\n06:26 <nmatsakis> time: 54.783; rss: 63MB   translation item collection\n06:26 <nmatsakis> time: 140.086; rss: 86MB    translation\n\n06:26 <nmatsakis> time: 0.361; rss: 46MB  item-bodies checking\n06:26 <nmatsakis> time: 5.299; rss: 63MB    translation item collection\n06:26 <nmatsakis> time: 12.140; rss: 86MB translation\n```\n\n~~Another example is the example from #31849. For that, I get 34s to run item-bodies without any cache. The version of the cache included here takes 2s to run item-bodies type-checking. An alternative version which doesn't track nested obligations takes 0.2s, but that version ICEs on @alexcrichton's future-rs (and may well be incorrect, I've not fully convinced myself of that). So, a definite win, but I think there's definitely room for further progress.~~\n\nPushed a modified version which improves performance of the case from #31849:\n\n```\nlunch-box. time rustc --stage0 ~/tmp/issue-31849.rs  -Z no-trans\nreal    0m33.539s\nuser    0m32.932s\nsys     0m0.570s\nlunch-box. time rustc --stage2 ~/tmp/issue-31849.rs  -Z no-trans\nreal    0m0.195s\nuser    0m0.154s\nsys     0m0.042s\n```\n\nSome sort of cache is also needed for unblocking further work on lazy normalization, since that will lean even more heavily on the cache, and will also require cycle detection.\n\nr? @arielb1", "tree": {"sha": "383ceb22756169dea5e2e192b1176010a7c0d4a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/383ceb22756169dea5e2e192b1176010a7c0d4a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12238b984abfacb2cccea176f862c94aa1231fb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12238b984abfacb2cccea176f862c94aa1231fb5", "html_url": "https://github.com/rust-lang/rust/commit/12238b984abfacb2cccea176f862c94aa1231fb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12238b984abfacb2cccea176f862c94aa1231fb5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "382ab92ceedc258e794c1a95aef21d3be3fa76c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/382ab92ceedc258e794c1a95aef21d3be3fa76c4", "html_url": "https://github.com/rust-lang/rust/commit/382ab92ceedc258e794c1a95aef21d3be3fa76c4"}, {"sha": "480d18ca311f5e0de2b6b0003f6cd0746e142652", "url": "https://api.github.com/repos/rust-lang/rust/commits/480d18ca311f5e0de2b6b0003f6cd0746e142652", "html_url": "https://github.com/rust-lang/rust/commit/480d18ca311f5e0de2b6b0003f6cd0746e142652"}], "stats": {"total": 2782, "additions": 2149, "deletions": 633}, "files": [{"sha": "1ba722b6baee76e79594b9d21d47b412a83f254a", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -1647,5 +1647,5 @@ register_diagnostics! {\n     E0490, // a value of type `..` is borrowed for too long\n     E0491, // in type `..`, reference has a longer lifetime than the data it...\n     E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n-    E0525, // expected a closure that implements `..` but this closure only implements `..`\n+    E0525  // expected a closure that implements `..` but this closure only implements `..`\n }"}, {"sha": "d47de676e796032f581973190125cfbc9fc57437", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -132,6 +132,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_generics(&mut self, g: &'v Generics) {\n         walk_generics(self, g)\n     }\n+    fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n+        walk_where_predicate(self, predicate)\n+    }\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, _: NodeId) {\n         walk_fn(self, fk, fd, b, s)\n     }\n@@ -529,29 +532,34 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n         walk_list!(visitor, visit_ty, &param.default);\n     }\n     walk_list!(visitor, visit_lifetime_def, &generics.lifetimes);\n-    for predicate in &generics.where_clause.predicates {\n-        match predicate {\n-            &WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n-                                                                          ref bounds,\n-                                                                          ref bound_lifetimes,\n-                                                                          ..}) => {\n-                visitor.visit_ty(bounded_ty);\n-                walk_list!(visitor, visit_ty_param_bound, bounds);\n-                walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n-            }\n-            &WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n-                                                                            ref bounds,\n-                                                                            ..}) => {\n-                visitor.visit_lifetime(lifetime);\n-                walk_list!(visitor, visit_lifetime, bounds);\n-            }\n-            &WherePredicate::EqPredicate(WhereEqPredicate{id,\n-                                                                    ref path,\n-                                                                    ref ty,\n-                                                                    ..}) => {\n-                visitor.visit_path(path, id);\n-                visitor.visit_ty(ty);\n-            }\n+    walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n+}\n+\n+pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    predicate: &'v WherePredicate)\n+{\n+    match predicate {\n+        &WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n+                                                            ref bounds,\n+                                                            ref bound_lifetimes,\n+                                                            ..}) => {\n+            visitor.visit_ty(bounded_ty);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n+        }\n+        &WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n+                                                              ref bounds,\n+                                                              ..}) => {\n+            visitor.visit_lifetime(lifetime);\n+            walk_list!(visitor, visit_lifetime, bounds);\n+        }\n+        &WherePredicate::EqPredicate(WhereEqPredicate{id,\n+                                                      ref path,\n+                                                      ref ty,\n+                                                      ..}) => {\n+            visitor.visit_path(path, id);\n+            visitor.visit_ty(ty);\n         }\n     }\n }"}, {"sha": "2f67042ca1c25f8f0512db17ed3752691c6d8608", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -77,6 +77,7 @@ use hir::map as ast_map;\n use hir;\n use hir::print as pprust;\n \n+use lint;\n use hir::def::Def;\n use hir::def_id::DefId;\n use infer::{self, TypeOrigin};\n@@ -1017,6 +1018,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let (fn_decl, generics) = rebuilder.rebuild();\n         self.give_expl_lifetime_param(err, &fn_decl, unsafety, constness, name, &generics, span);\n     }\n+\n+    pub fn issue_32330_warnings(&self, span: Span, issue32330s: &[ty::Issue32330]) {\n+        for issue32330 in issue32330s {\n+            match *issue32330 {\n+                ty::Issue32330::WontChange => { }\n+                ty::Issue32330::WillChange { fn_def_id, region_name } => {\n+                    self.tcx.sess.add_lint(\n+                        lint::builtin::HR_LIFETIME_IN_ASSOC_TYPE,\n+                        ast::CRATE_NODE_ID,\n+                        span,\n+                        format!(\"lifetime parameter `{0}` declared on fn `{1}` \\\n+                                 appears only in the return type, \\\n+                                 but here is required to be higher-ranked, \\\n+                                 which means that `{0}` must appear in both \\\n+                                 argument and return types\",\n+                                region_name,\n+                                self.tcx.item_path_str(fn_def_id)));\n+                }\n+            }\n+        }\n+    }\n }\n \n struct RebuildPathInfo<'a> {\n@@ -1129,7 +1151,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 ty::BrAnon(i) => {\n                     anon_nums.insert(i);\n                 }\n-                ty::BrNamed(_, name) => {\n+                ty::BrNamed(_, name, _) => {\n                     region_names.insert(name);\n                 }\n                 _ => ()\n@@ -1143,7 +1165,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         for sr in self.same_regions {\n             for br in &sr.regions {\n                 match *br {\n-                    ty::BrNamed(_, name) => {\n+                    ty::BrNamed(_, name, _) => {\n                         all_region_names.insert(name);\n                     }\n                     _ => ()\n@@ -1923,3 +1945,4 @@ fn name_to_dummy_lifetime(name: ast::Name) -> hir::Lifetime {\n                     span: codemap::DUMMY_SP,\n                     name: name }\n }\n+"}, {"sha": "84b72d9be60a1d3f71d573e27615d695c5e88e5d", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 277, "deletions": 32, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -11,15 +11,34 @@\n //! Helper routines for higher-ranked things. See the `doc` module at\n //! the end of the file for details.\n \n-use super::{CombinedSnapshot, InferCtxt, HigherRankedType, SkolemizationMap};\n+use super::{CombinedSnapshot,\n+            InferCtxt,\n+            LateBoundRegion,\n+            HigherRankedType,\n+            SubregionOrigin,\n+            SkolemizationMap};\n use super::combine::CombineFields;\n+use super::region_inference::{TaintDirections};\n \n use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n+pub struct HrMatchResult<U> {\n+    pub value: U,\n+\n+    /// Normally, when we do a higher-ranked match operation, we\n+    /// expect all higher-ranked regions to be constrained as part of\n+    /// the match operation. However, in the transition period for\n+    /// #32330, it can happen that we sometimes have unconstrained\n+    /// regions that get instantiated with fresh variables. In that\n+    /// case, we collect the set of unconstrained bound regions here\n+    /// and replace them with fresh variables.\n+    pub unconstrained_regions: Vec<ty::BoundRegion>,\n+}\n+\n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     pub fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n                                 -> RelateResult<'tcx, Binder<T>>\n@@ -39,11 +58,13 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n         return self.infcx.commit_if_ok(|snapshot| {\n+            let span = self.trace.origin.span();\n+\n             // First, we instantiate each bound region in the subtype with a fresh\n             // region variable.\n             let (a_prime, _) =\n                 self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    self.trace.origin.span(),\n+                    span,\n                     HigherRankedType,\n                     a);\n \n@@ -60,14 +81,146 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n-            self.infcx.leak_check(!self.a_is_expected, &skol_map, snapshot)?;\n+            self.infcx.leak_check(!self.a_is_expected, span, &skol_map, snapshot)?;\n+\n+            // We are finished with the skolemized regions now so pop\n+            // them off.\n+            self.infcx.pop_skolemized(skol_map, snapshot);\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n             Ok(ty::Binder(result))\n         });\n     }\n \n+    /// The value consists of a pair `(t, u)` where `t` is the\n+    /// *matcher* and `u` is a *value*. The idea is to find a\n+    /// substitution `S` such that `S(t) == b`, and then return\n+    /// `S(u)`. In other words, find values for the late-bound regions\n+    /// in `a` that can make `t == b` and then replace the LBR in `u`\n+    /// with those values.\n+    ///\n+    /// This routine is (as of this writing) used in trait matching,\n+    /// particularly projection.\n+    ///\n+    /// NB. It should not happen that there are LBR appearing in `U`\n+    /// that do not appear in `T`. If that happens, those regions are\n+    /// unconstrained, and this routine replaces them with `'static`.\n+    pub fn higher_ranked_match<T, U>(&self,\n+                                     span: Span,\n+                                     a_pair: &Binder<(T, U)>,\n+                                     b_match: &T)\n+                                     -> RelateResult<'tcx, HrMatchResult<U>>\n+        where T: Relate<'tcx>,\n+              U: TypeFoldable<'tcx>\n+    {\n+        debug!(\"higher_ranked_match(a={:?}, b={:?})\",\n+               a_pair, b_match);\n+\n+        // Start a snapshot so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        return self.infcx.commit_if_ok(|snapshot| {\n+            // First, we instantiate each bound region in the matcher\n+            // with a skolemized region.\n+            let ((a_match, a_value), skol_map) =\n+                self.infcx.skolemize_late_bound_regions(a_pair, snapshot);\n+\n+            debug!(\"higher_ranked_match: a_match={:?}\", a_match);\n+            debug!(\"higher_ranked_match: skol_map={:?}\", skol_map);\n+\n+            // Equate types now that bound regions have been replaced.\n+            try!(self.equate().relate(&a_match, &b_match));\n+\n+            // Map each skolemized region to a vector of other regions that it\n+            // must be equated with. (Note that this vector may include other\n+            // skolemized regions from `skol_map`.)\n+            let skol_resolution_map: FnvHashMap<_, _> =\n+                skol_map\n+                .iter()\n+                .map(|(&br, &skol)| {\n+                    let tainted_regions =\n+                        self.infcx.tainted_regions(snapshot,\n+                                                   skol,\n+                                                   TaintDirections::incoming()); // [1]\n+\n+                    // [1] this routine executes after the skolemized\n+                    // regions have been *equated* with something\n+                    // else, so examining the incoming edges ought to\n+                    // be enough to collect all constraints\n+\n+                    (skol, (br, tainted_regions))\n+                })\n+                .collect();\n+\n+            // For each skolemized region, pick a representative -- which can\n+            // be any region from the sets above, except for other members of\n+            // `skol_map`. There should always be a representative if things\n+            // are properly well-formed.\n+            let mut unconstrained_regions = vec![];\n+            let skol_representatives: FnvHashMap<_, _> =\n+                skol_resolution_map\n+                .iter()\n+                .map(|(&skol, &(br, ref regions))| {\n+                    let representative =\n+                        regions.iter()\n+                               .filter(|r| !skol_resolution_map.contains_key(r))\n+                               .cloned()\n+                               .next()\n+                               .unwrap_or_else(|| { // [1]\n+                                   unconstrained_regions.push(br);\n+                                   self.infcx.next_region_var(\n+                                       LateBoundRegion(span, br, HigherRankedType))\n+                               });\n+\n+                    // [1] There should always be a representative,\n+                    // unless the higher-ranked region did not appear\n+                    // in the values being matched. We should reject\n+                    // as ill-formed cases that can lead to this, but\n+                    // right now we sometimes issue warnings (see\n+                    // #32330).\n+\n+                    (skol, representative)\n+                })\n+                .collect();\n+\n+            // Equate all the members of each skolemization set with the\n+            // representative.\n+            for (skol, &(_br, ref regions)) in &skol_resolution_map {\n+                let representative = &skol_representatives[skol];\n+                debug!(\"higher_ranked_match: \\\n+                        skol={:?} representative={:?} regions={:?}\",\n+                       skol, representative, regions);\n+                for region in regions.iter()\n+                                     .filter(|&r| !skol_resolution_map.contains_key(r))\n+                                     .filter(|&r| r != representative)\n+                {\n+                    let origin = SubregionOrigin::Subtype(self.trace.clone());\n+                    self.infcx.region_vars.make_eqregion(origin,\n+                                                         *representative,\n+                                                         *region);\n+                }\n+            }\n+\n+            // Replace the skolemized regions appearing in value with\n+            // their representatives\n+            let a_value =\n+                fold_regions_in(\n+                    self.tcx(),\n+                    &a_value,\n+                    |r, _| skol_representatives.get(&r).cloned().unwrap_or(r));\n+\n+            debug!(\"higher_ranked_match: value={:?}\", a_value);\n+\n+            // We are now done with these skolemized variables.\n+            self.infcx.pop_skolemized(skol_map, snapshot);\n+\n+            Ok(HrMatchResult {\n+                value: a_value,\n+                unconstrained_regions: unconstrained_regions,\n+            })\n+        });\n+    }\n+\n     pub fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n                                 -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'tcx>\n@@ -124,7 +277,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 return r0;\n             }\n \n-            let tainted = infcx.tainted_regions(snapshot, r0);\n+            let tainted = infcx.tainted_regions(snapshot, r0, TaintDirections::both());\n \n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n@@ -219,7 +372,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 return r0;\n             }\n \n-            let tainted = infcx.tainted_regions(snapshot, r0);\n+            let tainted = infcx.tainted_regions(snapshot, r0, TaintDirections::both());\n \n             let mut a_r = None;\n             let mut b_r = None;\n@@ -341,8 +494,12 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region> {\n-        self.region_vars.tainted(&snapshot.region_vars_snapshot, r)\n+    fn tainted_regions(&self,\n+                       snapshot: &CombinedSnapshot,\n+                       r: ty::Region,\n+                       directions: TaintDirections)\n+                       -> FnvHashSet<ty::Region> {\n+        self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n     }\n \n     fn region_vars_confined_to_snapshot(&self,\n@@ -422,22 +579,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         region_vars\n     }\n \n+    /// Replace all regions bound by `binder` with skolemized regions and\n+    /// return a map indicating which bound-region was replaced with what\n+    /// skolemized region. This is the first step of checking subtyping\n+    /// when higher-ranked things are involved.\n+    ///\n+    /// **Important:** you must call this function from within a snapshot.\n+    /// Moreover, before committing the snapshot, you must eventually call\n+    /// either `plug_leaks` or `pop_skolemized` to remove the skolemized\n+    /// regions. If you rollback the snapshot (or are using a probe), then\n+    /// the pop occurs as part of the rollback, so an explicit call is not\n+    /// needed (but is also permitted).\n+    ///\n+    /// See `README.md` for more details.\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            binder: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)\n                                            -> (T, SkolemizationMap)\n         where T : TypeFoldable<'tcx>\n     {\n-        /*!\n-         * Replace all regions bound by `binder` with skolemized regions and\n-         * return a map indicating which bound-region was replaced with what\n-         * skolemized region. This is the first step of checking subtyping\n-         * when higher-ranked things are involved. See `README.md` for more\n-         * details.\n-         */\n-\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n-            self.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n+            self.region_vars.push_skolemized(br, &snapshot.region_vars_snapshot)\n         });\n \n         debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n@@ -448,32 +610,80 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         (result, map)\n     }\n \n+    /// Searches the region constriants created since `snapshot` was started\n+    /// and checks to determine whether any of the skolemized regions created\n+    /// in `skol_map` would \"escape\" -- meaning that they are related to\n+    /// other regions in some way. If so, the higher-ranked subtyping doesn't\n+    /// hold. See `README.md` for more details.\n     pub fn leak_check(&self,\n                       overly_polymorphic: bool,\n+                      span: Span,\n                       skol_map: &SkolemizationMap,\n                       snapshot: &CombinedSnapshot)\n                       -> RelateResult<'tcx, ()>\n     {\n-        /*!\n-         * Searches the region constriants created since `snapshot` was started\n-         * and checks to determine whether any of the skolemized regions created\n-         * in `skol_map` would \"escape\" -- meaning that they are related to\n-         * other regions in some way. If so, the higher-ranked subtyping doesn't\n-         * hold. See `README.md` for more details.\n-         */\n-\n         debug!(\"leak_check: skol_map={:?}\",\n                skol_map);\n \n+        // ## Issue #32330 warnings\n+        //\n+        // When Issue #32330 is fixed, a certain number of late-bound\n+        // regions (LBR) will become early-bound. We wish to issue\n+        // warnings when the result of `leak_check` relies on such LBR, as\n+        // that means that compilation will likely start to fail.\n+        //\n+        // Recall that when we do a \"HR subtype\" check, we replace all\n+        // late-bound regions (LBR) in the subtype with fresh variables,\n+        // and skolemize the late-bound regions in the supertype. If those\n+        // skolemized regions from the supertype wind up being\n+        // super-regions (directly or indirectly) of either\n+        //\n+        // - another skolemized region; or,\n+        // - some region that pre-exists the HR subtype check\n+        //   - e.g., a region variable that is not one of those created\n+        //     to represent bound regions in the subtype\n+        //\n+        // then leak-check (and hence the subtype check) fails.\n+        //\n+        // What will change when we fix #32330 is that some of the LBR in the\n+        // subtype may become early-bound. In that case, they would no longer be in\n+        // the \"permitted set\" of variables that can be related to a skolemized\n+        // type.\n+        //\n+        // So the foundation for this warning is to collect variables that we found\n+        // to be related to a skolemized type. For each of them, we have a\n+        // `BoundRegion` which carries a `Issue32330` flag. We check whether any of\n+        // those flags indicate that this variable was created from a lifetime\n+        // that will change from late- to early-bound. If so, we issue a warning\n+        // indicating that the results of compilation may change.\n+        //\n+        // This is imperfect, since there are other kinds of code that will not\n+        // compile once #32330 is fixed. However, it fixes the errors observed in\n+        // practice on crater runs.\n+        let mut warnings = vec![];\n+\n         let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n         for (&skol_br, &skol) in skol_map {\n-            let tainted = self.tainted_regions(snapshot, skol);\n-            for &tainted_region in &tainted {\n+            // The inputs to a skolemized variable can only\n+            // be itself or other new variables.\n+            let incoming_taints = self.tainted_regions(snapshot,\n+                                                       skol,\n+                                                       TaintDirections::both());\n+            for &tainted_region in &incoming_taints {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n                 match tainted_region {\n                     ty::ReVar(vid) => {\n-                        if new_vars.iter().any(|&x| x == vid) { continue; }\n+                        if new_vars.contains(&vid) {\n+                            warnings.extend(\n+                                match self.region_vars.var_origin(vid) {\n+                                    LateBoundRegion(_,\n+                                                    ty::BrNamed(_, _, wc),\n+                                                    _) => Some(wc),\n+                                    _ => None,\n+                                });\n+                            continue;\n+                        }\n                     }\n                     _ => {\n                         if tainted_region == skol { continue; }\n@@ -496,6 +706,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         }\n+\n+        self.issue_32330_warnings(span, &warnings);\n+\n         Ok(())\n     }\n \n@@ -533,8 +746,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                          value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        debug_assert!(self.leak_check(false, &skol_map, snapshot).is_ok());\n-\n         debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n                skol_map,\n                value);\n@@ -545,9 +756,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // these taint sets are mutually disjoint.\n         let inv_skol_map: FnvHashMap<ty::Region, ty::BoundRegion> =\n             skol_map\n-            .into_iter()\n-            .flat_map(|(skol_br, skol)| {\n-                self.tainted_regions(snapshot, skol)\n+            .iter()\n+            .flat_map(|(&skol_br, &skol)| {\n+                self.tainted_regions(snapshot, skol, TaintDirections::both())\n                     .into_iter()\n                     .map(move |tainted_region| (tainted_region, skol_br))\n             })\n@@ -577,6 +788,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // binders, so this assert is satisfied.\n                     assert!(current_depth > 1);\n \n+                    // since leak-check passed, this skolemized region\n+                    // should only have incoming edges from variables\n+                    // (which ought not to escape the snapshot, but we\n+                    // don't check that) or itself\n+                    assert!(\n+                        match r {\n+                            ty::ReVar(_) => true,\n+                            ty::ReSkolemized(_, ref br1) => br == br1,\n+                            _ => false,\n+                        },\n+                        \"leak-check would have us replace {:?} with {:?}\",\n+                        r, br);\n+\n                     ty::ReLateBound(ty::DebruijnIndex::new(current_depth - 1), br.clone())\n                 }\n             }\n@@ -585,6 +809,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"plug_leaks: result={:?}\",\n                result);\n \n+        self.pop_skolemized(skol_map, snapshot);\n+\n+        debug!(\"plug_leaks: result={:?}\", result);\n+\n         result\n     }\n+\n+    /// Pops the skolemized regions found in `skol_map` from the region\n+    /// inference context. Whenever you create skolemized regions via\n+    /// `skolemize_late_bound_regions`, they must be popped before you\n+    /// commit the enclosing snapshot (if you do not commit, e.g. within a\n+    /// probe or as a result of an error, then this is not necessary, as\n+    /// popping happens as part of the rollback).\n+    ///\n+    /// Note: popping also occurs implicitly as part of `leak_check`.\n+    pub fn pop_skolemized(&self,\n+                          skol_map: SkolemizationMap,\n+                          snapshot: &CombinedSnapshot)\n+    {\n+        debug!(\"pop_skolemized({:?})\", skol_map);\n+        let skol_regions: FnvHashSet<_> = skol_map.values().cloned().collect();\n+        self.region_vars.pop_skolemized(&skol_regions, &snapshot.region_vars_snapshot);\n+    }\n }"}, {"sha": "4dbee6ffa79d998e697acc28e8c7e1a81c3872b9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 72, "deletions": 7, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -45,6 +45,7 @@ use syntax::errors::DiagnosticBuilder;\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n \n use self::combine::CombineFields;\n+use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::unify_key::ToType;\n \n@@ -63,6 +64,7 @@ pub mod sub;\n pub mod type_variable;\n pub mod unify_key;\n \n+#[must_use]\n pub struct InferOk<'tcx, T> {\n     pub value: T,\n     pub obligations: PredicateObligations<'tcx>,\n@@ -104,6 +106,12 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     pub tables: InferTables<'a, 'gcx, 'tcx>,\n \n+    // Cache for projections. This cache is snapshotted along with the\n+    // infcx.\n+    //\n+    // Public so that `traits::project` can use it.\n+    pub projection_cache: RefCell<traits::ProjectionCache<'tcx>>,\n+\n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n@@ -477,6 +485,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             parameter_environment: param_env,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n+            projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             reported_trait_errors: RefCell::new(FnvHashSet()),\n             normalize: false,\n             projection_mode: ProjectionMode::AnyFinal,\n@@ -510,6 +519,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         global_tcx.enter_local(arenas, |tcx| f(InferCtxt {\n             tcx: tcx,\n             tables: tables,\n+            projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n@@ -538,13 +548,14 @@ impl<T> ExpectedFound<T> {\n }\n \n impl<'tcx, T> InferOk<'tcx, T> {\n-    fn unit(self) -> InferOk<'tcx, ()> {\n+    pub fn unit(self) -> InferOk<'tcx, ()> {\n         InferOk { value: (), obligations: self.obligations }\n     }\n }\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot {\n+    projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot,\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n     float_snapshot: unify::Snapshot<ty::FloatVid>,\n@@ -643,6 +654,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                             -> T::Lifted\n         where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n     {\n+        debug!(\"drain_fulfillment_cx_or_panic()\");\n+\n         let when = \"resolving bounds after type-checking\";\n         let v = match self.drain_fulfillment_cx(fulfill_cx, result) {\n             Ok(v) => v,\n@@ -817,10 +830,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n+        debug!(\"start_snapshot()\");\n+\n         let obligations_in_snapshot = self.obligations_in_snapshot.get();\n         self.obligations_in_snapshot.set(false);\n \n         CombinedSnapshot {\n+            projection_cache_snapshot: self.projection_cache.borrow_mut().snapshot(),\n             type_snapshot: self.type_variables.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n@@ -831,7 +847,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot) {\n         debug!(\"rollback_to(cause={})\", cause);\n-        let CombinedSnapshot { type_snapshot,\n+        let CombinedSnapshot { projection_cache_snapshot,\n+                               type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n@@ -840,6 +857,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         assert!(!self.obligations_in_snapshot.get());\n         self.obligations_in_snapshot.set(obligations_in_snapshot);\n \n+        self.projection_cache\n+            .borrow_mut()\n+            .rollback_to(projection_cache_snapshot);\n         self.type_variables\n             .borrow_mut()\n             .rollback_to(type_snapshot);\n@@ -854,15 +874,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn commit_from(&self, snapshot: CombinedSnapshot) {\n-        debug!(\"commit_from!\");\n-        let CombinedSnapshot { type_snapshot,\n+        debug!(\"commit_from()\");\n+        let CombinedSnapshot { projection_cache_snapshot,\n+                               type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n                                obligations_in_snapshot } = snapshot;\n \n         self.obligations_in_snapshot.set(obligations_in_snapshot);\n \n+        self.projection_cache\n+            .borrow_mut()\n+            .commit(projection_cache_snapshot);\n         self.type_variables\n             .borrow_mut()\n             .commit(type_snapshot);\n@@ -920,7 +944,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         F: FnOnce() -> Result<T, E>\n     {\n         debug!(\"commit_regions_if_ok()\");\n-        let CombinedSnapshot { type_snapshot,\n+        let CombinedSnapshot { projection_cache_snapshot,\n+                               type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n@@ -935,6 +960,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // Roll back any non-region bindings - they should be resolved\n         // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n+        self.projection_cache\n+            .borrow_mut()\n+            .rollback_to(projection_cache_snapshot);\n         self.type_variables\n             .borrow_mut()\n             .rollback_to(type_snapshot);\n@@ -1076,7 +1104,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = TypeOrigin::EquatePredicate(span);\n             let eqty_ok = self.eq_types(false, origin, a, b)?;\n-            self.leak_check(false, &skol_map, snapshot).map(|_| eqty_ok.unit())\n+            self.leak_check(false, span, &skol_map, snapshot)?;\n+            self.pop_skolemized(skol_map, snapshot);\n+            Ok(eqty_ok.unit())\n         })\n     }\n \n@@ -1090,7 +1120,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = RelateRegionParamBound(span);\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, &skol_map, snapshot)\n+            self.leak_check(false, span, &skol_map, snapshot)?;\n+            Ok(self.pop_skolemized(skol_map, snapshot))\n         })\n     }\n \n@@ -1569,6 +1600,40 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             |br| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n     }\n \n+    /// Given a higher-ranked projection predicate like:\n+    ///\n+    ///     for<'a> <T as Fn<&'a u32>>::Output = &'a u32\n+    ///\n+    /// and a target trait-ref like:\n+    ///\n+    ///     <T as Fn<&'x u32>>\n+    ///\n+    /// find a substitution `S` for the higher-ranked regions (here,\n+    /// `['a => 'x]`) such that the predicate matches the trait-ref,\n+    /// and then return the value (here, `&'a u32`) but with the\n+    /// substitution applied (hence, `&'x u32`).\n+    ///\n+    /// See `higher_ranked_match` in `higher_ranked/mod.rs` for more\n+    /// details.\n+    pub fn match_poly_projection_predicate(&self,\n+                                           origin: TypeOrigin,\n+                                           match_a: ty::PolyProjectionPredicate<'tcx>,\n+                                           match_b: ty::TraitRef<'tcx>)\n+                                           -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n+    {\n+        let span = origin.span();\n+        let match_trait_ref = match_a.skip_binder().projection_ty.trait_ref;\n+        let trace = TypeTrace {\n+            origin: origin,\n+            values: TraitRefs(ExpectedFound::new(true, match_trait_ref, match_b))\n+        };\n+\n+        let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref, p.ty));\n+        let combine = self.combine_fields(true, trace);\n+        let result = combine.higher_ranked_match(span, &match_pair, &match_b)?;\n+        Ok(InferOk { value: result, obligations: combine.obligations })\n+    }\n+\n     /// See `verify_generic_bound` method in `region_inference`\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,"}, {"sha": "905ad7c0faa236c45e18c6eb5d03cc64e3663441", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -213,8 +213,12 @@ fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n     match *c {\n         Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n             (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n-        Constraint::ConstrainRegSubVar(r_1, rv_2) => (Node::Region(r_1), Node::RegionVid(rv_2)),\n-        Constraint::ConstrainVarSubReg(rv_1, r_2) => (Node::RegionVid(rv_1), Node::Region(r_2)),\n+        Constraint::ConstrainRegSubVar(r_1, rv_2) =>\n+            (Node::Region(r_1), Node::RegionVid(rv_2)),\n+        Constraint::ConstrainVarSubReg(rv_1, r_2) =>\n+            (Node::RegionVid(rv_1), Node::Region(r_2)),\n+        Constraint::ConstrainRegSubReg(r_1, r_2) =>\n+            (Node::Region(r_1), Node::Region(r_2)),\n     }\n }\n "}, {"sha": "2211a565a325f215a2af2ca7ead346fc61d0f6dc", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 409, "deletions": 241, "changes": 650, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -11,7 +11,6 @@\n //! See README.md\n \n pub use self::Constraint::*;\n-pub use self::Verify::*;\n pub use self::UndoLogEntry::*;\n pub use self::CombineMapType::*;\n pub use self::RegionResolutionError::*;\n@@ -20,19 +19,19 @@ pub use self::VarValue::*;\n use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n \n+use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n use ty::{self, Ty, TyCtxt};\n use ty::{BoundRegion, Region, RegionVid};\n use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound};\n use ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n-use util::common::indenter;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::fmt;\n+use std::mem;\n use std::u32;\n use syntax::ast;\n \n@@ -47,25 +46,28 @@ pub enum Constraint {\n     // Concrete region is subregion of region variable\n     ConstrainRegSubVar(Region, RegionVid),\n \n-    // Region variable is subregion of concrete region\n-    //\n-    // FIXME(#29436) -- should be remove in favor of a Verify\n+    // Region variable is subregion of concrete region. This does not\n+    // directly affect inference, but instead is checked after\n+    // inference is complete.\n     ConstrainVarSubReg(RegionVid, Region),\n+\n+    // A constraint where neither side is a variable. This does not\n+    // directly affect inference, but instead is checked after\n+    // inference is complete.\n+    ConstrainRegSubReg(Region, Region),\n }\n \n-// Something we have to verify after region inference is done, but\n-// which does not directly influence the inference process\n-pub enum Verify<'tcx> {\n-    // VerifyRegSubReg(a, b): Verify that `a <= b`. Neither `a` nor\n-    // `b` are inference variables.\n-    VerifyRegSubReg(SubregionOrigin<'tcx>, Region, Region),\n-\n-    // VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n-    // associated type) must outlive the region `R`. `T` is known to\n-    // outlive `RS`. Therefore verify that `R <= RS[i]` for some\n-    // `i`. Inference variables may be involved (but this verification\n-    // step doesn't influence inference).\n-    VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, VerifyBound),\n+// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+// associated type) must outlive the region `R`. `T` is known to\n+// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+// `i`. Inference variables may be involved (but this verification\n+// step doesn't influence inference).\n+#[derive(Debug)]\n+pub struct Verify<'tcx> {\n+    kind: GenericKind<'tcx>,\n+    origin: SubregionOrigin<'tcx>,\n+    region: Region,\n+    bound: VerifyBound,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -108,13 +110,36 @@ pub struct TwoRegions {\n \n #[derive(Copy, Clone, PartialEq)]\n pub enum UndoLogEntry {\n+    /// Pushed when we start a snapshot.\n     OpenSnapshot,\n+\n+    /// Replaces an `OpenSnapshot` when a snapshot is committed, but\n+    /// that snapshot is not the root. If the root snapshot is\n+    /// unrolled, all nested snapshots must be committed.\n     CommitedSnapshot,\n+\n+    /// We added `RegionVid`\n     AddVar(RegionVid),\n+\n+    /// We added the given `constraint`\n     AddConstraint(Constraint),\n+\n+    /// We added the given `verify`\n     AddVerify(usize),\n+\n+    /// We added the given `given`\n     AddGiven(ty::FreeRegion, ty::RegionVid),\n+\n+    /// We added a GLB/LUB \"combinaton variable\"\n     AddCombination(CombineMapType, TwoRegions),\n+\n+    /// During skolemization, we sometimes purge entries from the undo\n+    /// log in a kind of minisnapshot (unlike other snapshots, this\n+    /// purging actually takes place *on success*). In that case, we\n+    /// replace the corresponding entry with `Noop` so as to avoid the\n+    /// need to do a bunch of swapping. (We can't use `swap_remove` as\n+    /// the order of the vector is important.)\n+    Purged,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -253,6 +278,112 @@ pub struct RegionSnapshot {\n     skolemization_count: u32,\n }\n \n+/// When working with skolemized regions, we often wish to find all of\n+/// the regions that are either reachable from a skolemized region, or\n+/// which can reach a skolemized region, or both. We call such regions\n+/// *tained* regions.  This struct allows you to decide what set of\n+/// tainted regions you want.\n+#[derive(Debug)]\n+pub struct TaintDirections {\n+    incoming: bool,\n+    outgoing: bool,\n+}\n+\n+impl TaintDirections {\n+    pub fn incoming() -> Self {\n+        TaintDirections { incoming: true, outgoing: false }\n+    }\n+\n+    pub fn outgoing() -> Self {\n+        TaintDirections { incoming: false, outgoing: true }\n+    }\n+\n+    pub fn both() -> Self {\n+        TaintDirections { incoming: true, outgoing: true }\n+    }\n+}\n+\n+struct TaintSet {\n+    directions: TaintDirections,\n+    regions: FnvHashSet<ty::Region>\n+}\n+\n+impl TaintSet {\n+    fn new(directions: TaintDirections,\n+           initial_region: ty::Region)\n+           -> Self {\n+        let mut regions = FnvHashSet();\n+        regions.insert(initial_region);\n+        TaintSet { directions: directions, regions: regions }\n+    }\n+\n+    fn fixed_point(&mut self,\n+                   undo_log: &[UndoLogEntry],\n+                   verifys: &[Verify]) {\n+        let mut prev_len = 0;\n+        while prev_len < self.len() {\n+            debug!(\"tainted: prev_len = {:?} new_len = {:?}\",\n+                   prev_len, self.len());\n+\n+            prev_len = self.len();\n+\n+            for undo_entry in undo_log {\n+                match undo_entry {\n+                    &AddConstraint(ConstrainVarSubVar(a, b)) => {\n+                        self.add_edge(ReVar(a), ReVar(b));\n+                    }\n+                    &AddConstraint(ConstrainRegSubVar(a, b)) => {\n+                        self.add_edge(a, ReVar(b));\n+                    }\n+                    &AddConstraint(ConstrainVarSubReg(a, b)) => {\n+                        self.add_edge(ReVar(a), b);\n+                    }\n+                    &AddConstraint(ConstrainRegSubReg(a, b)) => {\n+                        self.add_edge(a, b);\n+                    }\n+                    &AddGiven(a, b) => {\n+                        self.add_edge(ReFree(a), ReVar(b));\n+                    }\n+                    &AddVerify(i) => {\n+                        verifys[i].bound.for_each_region(&mut |b| {\n+                            self.add_edge(verifys[i].region, b);\n+                        });\n+                    }\n+                    &Purged |\n+                    &AddCombination(..) |\n+                    &AddVar(..) |\n+                    &OpenSnapshot |\n+                    &CommitedSnapshot => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    fn into_set(self) -> FnvHashSet<ty::Region> {\n+        self.regions\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.regions.len()\n+    }\n+\n+    fn add_edge(&mut self,\n+                source: ty::Region,\n+                target: ty::Region) {\n+        if self.directions.incoming {\n+            if self.regions.contains(&target) {\n+                self.regions.insert(source);\n+            }\n+        }\n+\n+        if self.directions.outgoing {\n+            if self.regions.contains(&source) {\n+                self.regions.insert(target);\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> RegionVarBindings<'a, 'gcx, 'tcx> {\n         RegionVarBindings {\n@@ -290,14 +421,17 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         debug!(\"RegionVarBindings: commit({})\", snapshot.length);\n         assert!(self.undo_log.borrow().len() > snapshot.length);\n         assert!((*self.undo_log.borrow())[snapshot.length] == OpenSnapshot);\n+        assert!(self.skolemization_count.get() == snapshot.skolemization_count,\n+                \"failed to pop skolemized regions: {} now vs {} at start\",\n+                self.skolemization_count.get(),\n+                snapshot.skolemization_count);\n \n         let mut undo_log = self.undo_log.borrow_mut();\n         if snapshot.length == 0 {\n             undo_log.truncate(0);\n         } else {\n             (*undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n-        self.skolemization_count.set(snapshot.skolemization_count);\n         self.unification_table.borrow_mut().commit(snapshot.region_snapshot);\n     }\n \n@@ -307,33 +441,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         assert!(undo_log.len() > snapshot.length);\n         assert!((*undo_log)[snapshot.length] == OpenSnapshot);\n         while undo_log.len() > snapshot.length + 1 {\n-            match undo_log.pop().unwrap() {\n-                OpenSnapshot => {\n-                    bug!(\"Failure to observe stack discipline\");\n-                }\n-                CommitedSnapshot => {}\n-                AddVar(vid) => {\n-                    let mut var_origins = self.var_origins.borrow_mut();\n-                    var_origins.pop().unwrap();\n-                    assert_eq!(var_origins.len(), vid.index as usize);\n-                }\n-                AddConstraint(ref constraint) => {\n-                    self.constraints.borrow_mut().remove(constraint);\n-                }\n-                AddVerify(index) => {\n-                    self.verifys.borrow_mut().pop();\n-                    assert_eq!(self.verifys.borrow().len(), index);\n-                }\n-                AddGiven(sub, sup) => {\n-                    self.givens.borrow_mut().remove(&(sub, sup));\n-                }\n-                AddCombination(Glb, ref regions) => {\n-                    self.glbs.borrow_mut().remove(regions);\n-                }\n-                AddCombination(Lub, ref regions) => {\n-                    self.lubs.borrow_mut().remove(regions);\n-                }\n-            }\n+            self.rollback_undo_entry(undo_log.pop().unwrap());\n         }\n         let c = undo_log.pop().unwrap();\n         assert!(c == OpenSnapshot);\n@@ -342,6 +450,38 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             .rollback_to(snapshot.region_snapshot);\n     }\n \n+    pub fn rollback_undo_entry(&self, undo_entry: UndoLogEntry) {\n+        match undo_entry {\n+            OpenSnapshot => {\n+                panic!(\"Failure to observe stack discipline\");\n+            }\n+            Purged | CommitedSnapshot => {\n+                // nothing to do here\n+            }\n+            AddVar(vid) => {\n+                let mut var_origins = self.var_origins.borrow_mut();\n+                var_origins.pop().unwrap();\n+                assert_eq!(var_origins.len(), vid.index as usize);\n+            }\n+            AddConstraint(ref constraint) => {\n+                self.constraints.borrow_mut().remove(constraint);\n+            }\n+            AddVerify(index) => {\n+                self.verifys.borrow_mut().pop();\n+                assert_eq!(self.verifys.borrow().len(), index);\n+            }\n+            AddGiven(sub, sup) => {\n+                self.givens.borrow_mut().remove(&(sub, sup));\n+            }\n+            AddCombination(Glb, ref regions) => {\n+                self.glbs.borrow_mut().remove(regions);\n+            }\n+            AddCombination(Lub, ref regions) => {\n+                self.lubs.borrow_mut().remove(regions);\n+            }\n+        }\n+    }\n+\n     pub fn num_vars(&self) -> u32 {\n         let len = self.var_origins.borrow().len();\n         // enforce no overflow\n@@ -366,22 +506,30 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         return vid;\n     }\n \n+    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n+        self.var_origins.borrow()[vid.index as usize].clone()\n+    }\n+\n     /// Creates a new skolemized region. Skolemized regions are fresh\n     /// regions used when performing higher-ranked computations. They\n     /// must be used in a very particular way and are never supposed\n     /// to \"escape\" out into error messages or the code at large.\n     ///\n     /// The idea is to always create a snapshot. Skolemized regions\n-    /// can be created in the context of this snapshot, but once the\n-    /// snapshot is committed or rolled back, their numbers will be\n-    /// recycled, so you must be finished with them. See the extensive\n-    /// comments in `higher_ranked.rs` to see how it works (in\n-    /// particular, the subtyping comparison).\n+    /// can be created in the context of this snapshot, but before the\n+    /// snapshot is committed or rolled back, they must be popped\n+    /// (using `pop_skolemized_regions`), so that their numbers can be\n+    /// recycled. Normally you don't have to think about this: you use\n+    /// the APIs in `higher_ranked/mod.rs`, such as\n+    /// `skolemize_late_bound_regions` and `plug_leaks`, which will\n+    /// guide you on this path (ensure that the `SkolemizationMap` is\n+    /// consumed and you are good).  There are also somewhat extensive\n+    /// comments in `higher_ranked/README.md`.\n     ///\n     /// The `snapshot` argument to this function is not really used;\n     /// it's just there to make it explicit which snapshot bounds the\n-    /// skolemized region that results.\n-    pub fn new_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot) -> Region {\n+    /// skolemized region that results. It should always be the top-most snapshot.\n+    pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot) -> Region {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n \n@@ -390,6 +538,94 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br)\n     }\n \n+    /// Removes all the edges to/from the skolemized regions that are\n+    /// in `skols`. This is used after a higher-ranked operation\n+    /// completes to remove all trace of the skolemized regions\n+    /// created in that time.\n+    pub fn pop_skolemized(&self,\n+                          skols: &FnvHashSet<ty::Region>,\n+                          snapshot: &RegionSnapshot) {\n+        debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n+\n+        assert!(self.in_snapshot());\n+        assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n+        assert!(self.skolemization_count.get() as usize >= skols.len(),\n+                \"popping more skolemized variables than actually exist, \\\n+                 sc now = {}, skols.len = {}\",\n+                self.skolemization_count.get(),\n+                skols.len());\n+\n+        let last_to_pop = self.skolemization_count.get();\n+        let first_to_pop = last_to_pop - (skols.len() as u32);\n+\n+        assert!(first_to_pop >= snapshot.skolemization_count,\n+                \"popping more regions than snapshot contains, \\\n+                 sc now = {}, sc then = {}, skols.len = {}\",\n+                self.skolemization_count.get(),\n+                snapshot.skolemization_count,\n+                skols.len());\n+        debug_assert! {\n+            skols.iter()\n+                 .all(|k| match *k {\n+                     ty::ReSkolemized(index, _) =>\n+                         index.index >= first_to_pop &&\n+                         index.index < last_to_pop,\n+                     _ =>\n+                         false\n+                 }),\n+            \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n+            snapshot.skolemization_count,\n+            self.skolemization_count.get(),\n+            skols\n+        }\n+\n+        let mut undo_log = self.undo_log.borrow_mut();\n+\n+        let constraints_to_kill: Vec<usize> =\n+            undo_log.iter()\n+                    .enumerate()\n+                    .rev()\n+                    .filter(|&(_, undo_entry)| kill_constraint(skols, undo_entry))\n+                    .map(|(index, _)| index)\n+                    .collect();\n+\n+        for index in constraints_to_kill {\n+            let undo_entry = mem::replace(&mut undo_log[index], Purged);\n+            self.rollback_undo_entry(undo_entry);\n+        }\n+\n+        self.skolemization_count.set(snapshot.skolemization_count);\n+        return;\n+\n+        fn kill_constraint(skols: &FnvHashSet<ty::Region>,\n+                           undo_entry: &UndoLogEntry)\n+                           -> bool {\n+            match undo_entry {\n+                &AddConstraint(ConstrainVarSubVar(_, _)) =>\n+                    false,\n+                &AddConstraint(ConstrainRegSubVar(a, _)) =>\n+                    skols.contains(&a),\n+                &AddConstraint(ConstrainVarSubReg(_, b)) =>\n+                    skols.contains(&b),\n+                &AddConstraint(ConstrainRegSubReg(a, b)) =>\n+                    skols.contains(&a) || skols.contains(&b),\n+                &AddGiven(_, _) =>\n+                    false,\n+                &AddVerify(_) =>\n+                    false,\n+                &AddCombination(_, ref two_regions) =>\n+                    skols.contains(&two_regions.a) ||\n+                    skols.contains(&two_regions.b),\n+                &AddVar(..) |\n+                &OpenSnapshot |\n+                &Purged |\n+                &CommitedSnapshot =>\n+                    false,\n+            }\n+        }\n+\n+    }\n+\n     pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n@@ -443,11 +679,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         debug!(\"RegionVarBindings: add_verify({:?})\", verify);\n \n         // skip no-op cases known to be satisfied\n-        match verify {\n-            VerifyGenericBound(_, _, _, VerifyBound::AllBounds(ref bs)) if bs.len() == 0 => {\n-                return;\n-            }\n-            _ => {}\n+        match verify.bound {\n+            VerifyBound::AllBounds(ref bs) if bs.len() == 0 => { return; }\n+            _ => { }\n         }\n \n         let mut verifys = self.verifys.borrow_mut();\n@@ -515,7 +749,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n             }\n             _ => {\n-                self.add_verify(VerifyRegSubReg(origin, sub, sup));\n+                self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n             }\n         }\n     }\n@@ -526,7 +760,12 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                                 kind: GenericKind<'tcx>,\n                                 sub: Region,\n                                 bound: VerifyBound) {\n-        self.add_verify(VerifyGenericBound(kind, origin, sub, bound));\n+        self.add_verify(Verify {\n+            kind: kind,\n+            origin: origin,\n+            region: sub,\n+            bound: bound\n+        });\n     }\n \n     pub fn lub_regions(&self, origin: SubregionOrigin<'tcx>, a: Region, b: Region) -> Region {\n@@ -632,83 +871,30 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             .collect()\n     }\n \n-    /// Computes all regions that have been related to `r0` in any way since the mark `mark` was\n-    /// made---`r0` itself will be the first entry. This is used when checking whether skolemized\n-    /// regions are being improperly related to other regions.\n-    pub fn tainted(&self, mark: &RegionSnapshot, r0: Region) -> Vec<Region> {\n-        debug!(\"tainted(mark={:?}, r0={:?})\", mark, r0);\n-        let _indenter = indenter();\n+    /// Computes all regions that have been related to `r0` since the\n+    /// mark `mark` was made---`r0` itself will be the first\n+    /// entry. The `directions` parameter controls what kind of\n+    /// relations are considered. For example, one can say that only\n+    /// \"incoming\" edges to `r0` are desired, in which case one will\n+    /// get the set of regions `{r|r <= r0}`. This is used when\n+    /// checking whether skolemized regions are being improperly\n+    /// related to other regions.\n+    pub fn tainted(&self,\n+                   mark: &RegionSnapshot,\n+                   r0: Region,\n+                   directions: TaintDirections)\n+                   -> FnvHashSet<ty::Region> {\n+        debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n+               mark, r0, directions);\n \n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n-        let mut result_set = vec![r0];\n-        let mut result_index = 0;\n-        while result_index < result_set.len() {\n-            // nb: can't use usize::range() here because result_set grows\n-            let r = result_set[result_index];\n-            debug!(\"result_index={}, r={:?}\", result_index, r);\n-\n-            for undo_entry in self.undo_log.borrow()[mark.length..].iter() {\n-                match undo_entry {\n-                    &AddConstraint(ConstrainVarSubVar(a, b)) => {\n-                        consider_adding_bidirectional_edges(&mut result_set, r, ReVar(a), ReVar(b));\n-                    }\n-                    &AddConstraint(ConstrainRegSubVar(a, b)) => {\n-                        consider_adding_bidirectional_edges(&mut result_set, r, a, ReVar(b));\n-                    }\n-                    &AddConstraint(ConstrainVarSubReg(a, b)) => {\n-                        consider_adding_bidirectional_edges(&mut result_set, r, ReVar(a), b);\n-                    }\n-                    &AddGiven(a, b) => {\n-                        consider_adding_bidirectional_edges(&mut result_set,\n-                                                            r,\n-                                                            ReFree(a),\n-                                                            ReVar(b));\n-                    }\n-                    &AddVerify(i) => {\n-                        match (*self.verifys.borrow())[i] {\n-                            VerifyRegSubReg(_, a, b) => {\n-                                consider_adding_bidirectional_edges(&mut result_set, r, a, b);\n-                            }\n-                            VerifyGenericBound(_, _, a, ref bound) => {\n-                                bound.for_each_region(&mut |b| {\n-                                    consider_adding_bidirectional_edges(&mut result_set, r, a, b)\n-                                });\n-                            }\n-                        }\n-                    }\n-                    &AddCombination(..) |\n-                    &AddVar(..) |\n-                    &OpenSnapshot |\n-                    &CommitedSnapshot => {}\n-                }\n-            }\n-\n-            result_index += 1;\n-        }\n-\n-        return result_set;\n-\n-        fn consider_adding_bidirectional_edges(result_set: &mut Vec<Region>,\n-                                               r: Region,\n-                                               r1: Region,\n-                                               r2: Region) {\n-            consider_adding_directed_edge(result_set, r, r1, r2);\n-            consider_adding_directed_edge(result_set, r, r2, r1);\n-        }\n-\n-        fn consider_adding_directed_edge(result_set: &mut Vec<Region>,\n-                                         r: Region,\n-                                         r1: Region,\n-                                         r2: Region) {\n-            if r == r1 {\n-                // Clearly, this is potentially inefficient.\n-                if !result_set.iter().any(|x| *x == r2) {\n-                    result_set.push(r2);\n-                }\n-            }\n-        }\n+        let mut taint_set = TaintSet::new(directions, r0);\n+        taint_set.fixed_point(&self.undo_log.borrow()[mark.length..],\n+                              &self.verifys.borrow());\n+        debug!(\"tainted: result={:?}\", taint_set.regions);\n+        return taint_set.into_set();\n     }\n \n     /// This function performs the actual region resolution.  It must be\n@@ -805,10 +991,6 @@ pub enum VarValue {\n     ErrorValue,\n }\n \n-struct VarData {\n-    value: VarValue,\n-}\n-\n struct RegionAndOrigin<'tcx> {\n     region: Region,\n     origin: SubregionOrigin<'tcx>,\n@@ -834,18 +1016,14 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n         self.expansion(free_regions, &mut var_data);\n-        self.contraction(free_regions, &mut var_data);\n-        let values = self.extract_values_and_collect_conflicts(free_regions,\n-                                                               &var_data,\n-                                                               &graph,\n-                                                               errors);\n-        self.collect_concrete_region_errors(free_regions, &values, errors);\n-        values\n+        self.collect_errors(free_regions, &mut var_data, errors);\n+        self.collect_var_errors(free_regions, &var_data, &graph, errors);\n+        var_data\n     }\n \n-    fn construct_var_data(&self) -> Vec<VarData> {\n+    fn construct_var_data(&self) -> Vec<VarValue> {\n         (0..self.num_vars() as usize)\n-            .map(|_| VarData { value: Value(ty::ReEmpty) })\n+            .map(|_| Value(ty::ReEmpty))\n             .collect()\n     }\n \n@@ -882,30 +1060,28 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn expansion(&self, free_regions: &FreeRegionMap, var_data: &mut [VarData]) {\n-        self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n+    fn expansion(&self, free_regions: &FreeRegionMap, var_values: &mut [VarValue]) {\n+        self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\",\n-                   constraint,\n-                   self.constraints\n-                       .borrow()\n-                       .get(constraint)\n-                       .unwrap());\n+                   constraint, origin);\n             match *constraint {\n                 ConstrainRegSubVar(a_region, b_vid) => {\n-                    let b_data = &mut var_data[b_vid.index as usize];\n+                    let b_data = &mut var_values[b_vid.index as usize];\n                     self.expand_node(free_regions, a_region, b_vid, b_data)\n                 }\n                 ConstrainVarSubVar(a_vid, b_vid) => {\n-                    match var_data[a_vid.index as usize].value {\n+                    match var_values[a_vid.index as usize] {\n                         ErrorValue => false,\n                         Value(a_region) => {\n-                            let b_node = &mut var_data[b_vid.index as usize];\n+                            let b_node = &mut var_values[b_vid.index as usize];\n                             self.expand_node(free_regions, a_region, b_vid, b_node)\n                         }\n                     }\n                 }\n+                ConstrainRegSubReg(..) |\n                 ConstrainVarSubReg(..) => {\n-                    // This is a contraction constraint.  Ignore it.\n+                    // These constraints are checked after expansion\n+                    // is done, in `collect_errors`.\n                     false\n                 }\n             }\n@@ -916,12 +1092,12 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                    free_regions: &FreeRegionMap,\n                    a_region: Region,\n                    b_vid: RegionVid,\n-                   b_data: &mut VarData)\n+                   b_data: &mut VarValue)\n                    -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\",\n                a_region,\n                b_vid,\n-               b_data.value);\n+               b_data);\n \n         // Check if this relationship is implied by a given.\n         match a_region {\n@@ -934,7 +1110,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        match b_data.value {\n+        match *b_data {\n             Value(cur_region) => {\n                 let lub = self.lub_concrete_regions(free_regions, a_region, cur_region);\n                 if lub == cur_region {\n@@ -946,7 +1122,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                        cur_region,\n                        lub);\n \n-                b_data.value = Value(lub);\n+                *b_data = Value(lub);\n                 return true;\n             }\n \n@@ -956,94 +1132,92 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // FIXME(#29436) -- this fn would just go away if we removed ConstrainVarSubReg\n-    fn contraction(&self, free_regions: &FreeRegionMap, var_data: &mut [VarData]) {\n-        self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n-            debug!(\"contraction: constraint={:?} origin={:?}\",\n-                   constraint,\n-                   self.constraints\n-                       .borrow()\n-                       .get(constraint)\n-                       .unwrap());\n+    /// After expansion is complete, go and check upper bounds (i.e.,\n+    /// cases where the region cannot grow larger than a fixed point)\n+    /// and check that they are satisfied.\n+    fn collect_errors(&self,\n+                      free_regions: &FreeRegionMap,\n+                      var_data: &mut Vec<VarValue>,\n+                      errors: &mut Vec<RegionResolutionError<'tcx>>) {\n+        let constraints = self.constraints.borrow();\n+        for (constraint, origin) in constraints.iter() {\n+            debug!(\"collect_errors: constraint={:?} origin={:?}\",\n+                   constraint, origin);\n             match *constraint {\n                 ConstrainRegSubVar(..) |\n                 ConstrainVarSubVar(..) => {\n                     // Expansion will ensure that these constraints hold. Ignore.\n                 }\n+\n+                ConstrainRegSubReg(sub, sup) => {\n+                    if free_regions.is_subregion_of(self.tcx, sub, sup) {\n+                        continue;\n+                    }\n+\n+                    debug!(\"collect_errors: region error at {:?}: \\\n+                            cannot verify that {:?} <= {:?}\",\n+                           origin,\n+                           sub,\n+                           sup);\n+\n+                    errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n+                }\n+\n                 ConstrainVarSubReg(a_vid, b_region) => {\n                     let a_data = &mut var_data[a_vid.index as usize];\n                     debug!(\"contraction: {:?} == {:?}, {:?}\",\n                            a_vid,\n-                           a_data.value,\n+                           a_data,\n                            b_region);\n \n-                    let a_region = match a_data.value {\n-                        ErrorValue => return false,\n+                    let a_region = match *a_data {\n+                        ErrorValue => continue,\n                         Value(a_region) => a_region,\n                     };\n \n+                    // Do not report these errors immediately:\n+                    // instead, set the variable value to error and\n+                    // collect them later.\n                     if !free_regions.is_subregion_of(self.tcx, a_region, b_region) {\n-                        debug!(\"Setting {:?} to ErrorValue: {:?} not subregion of {:?}\",\n+                        debug!(\"collect_errors: region error at {:?}: \\\n+                                cannot verify that {:?}={:?} <= {:?}\",\n+                               origin,\n                                a_vid,\n                                a_region,\n                                b_region);\n-                        a_data.value = ErrorValue;\n+                        *a_data = ErrorValue;\n                     }\n                 }\n             }\n+        }\n \n-            false\n-        })\n-    }\n-\n-    fn collect_concrete_region_errors(&self,\n-                                      free_regions: &FreeRegionMap,\n-                                      values: &Vec<VarValue>,\n-                                      errors: &mut Vec<RegionResolutionError<'tcx>>) {\n-        let mut reg_reg_dups = FnvHashSet();\n         for verify in self.verifys.borrow().iter() {\n-            match *verify {\n-                VerifyRegSubReg(ref origin, sub, sup) => {\n-                    if free_regions.is_subregion_of(self.tcx, sub, sup) {\n-                        continue;\n-                    }\n-\n-                    if !reg_reg_dups.insert((sub, sup)) {\n-                        continue;\n-                    }\n-\n-                    debug!(\"region inference error at {:?}: {:?} <= {:?} is not true\",\n-                           origin,\n-                           sub,\n-                           sup);\n-\n-                    errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n-                }\n+            debug!(\"collect_errors: verify={:?}\", verify);\n+            let sub = normalize(var_data, verify.region);\n+            if verify.bound.is_met(self.tcx, free_regions, var_data, sub) {\n+                continue;\n+            }\n \n-                VerifyGenericBound(ref kind, ref origin, sub, ref bound) => {\n-                    let sub = normalize(values, sub);\n-                    if bound.is_met(self.tcx, free_regions, values, sub) {\n-                        continue;\n-                    }\n+            debug!(\"collect_errors: region error at {:?}: \\\n+                    cannot verify that {:?} <= {:?}\",\n+                   verify.origin,\n+                   verify.region,\n+                   verify.bound);\n \n-                    debug!(\"region inference error at {:?}: verifying {:?} <= {:?}\",\n-                           origin,\n-                           sub,\n-                           bound);\n-\n-                    errors.push(GenericBoundFailure((*origin).clone(), kind.clone(), sub));\n-                }\n-            }\n+            errors.push(GenericBoundFailure(verify.origin.clone(),\n+                                            verify.kind.clone(),\n+                                            sub));\n         }\n     }\n \n-    fn extract_values_and_collect_conflicts(&self,\n-                                            free_regions: &FreeRegionMap,\n-                                            var_data: &[VarData],\n-                                            graph: &RegionGraph,\n-                                            errors: &mut Vec<RegionResolutionError<'tcx>>)\n-                                            -> Vec<VarValue> {\n-        debug!(\"extract_values_and_collect_conflicts()\");\n+    /// Go over the variables that were declared to be error variables\n+    /// and create a `RegionResolutionError` for each of them.\n+    fn collect_var_errors(&self,\n+                          free_regions: &FreeRegionMap,\n+                          var_data: &[VarValue],\n+                          graph: &RegionGraph,\n+                          errors: &mut Vec<RegionResolutionError<'tcx>>) {\n+        debug!(\"collect_var_errors\");\n \n         // This is the best way that I have found to suppress\n         // duplicate and related errors. Basically we keep a set of\n@@ -1059,7 +1233,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         let mut dup_vec = vec![u32::MAX; self.num_vars() as usize];\n \n         for idx in 0..self.num_vars() as usize {\n-            match var_data[idx].value {\n+            match var_data[idx] {\n                 Value(_) => {\n                     /* Inference successful */\n                 }\n@@ -1096,8 +1270,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 }\n             }\n         }\n-\n-        (0..self.num_vars() as usize).map(|idx| var_data[idx].value).collect()\n     }\n \n     fn construct_graph(&self) -> RegionGraph {\n@@ -1132,6 +1304,10 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 ConstrainVarSubReg(a_id, _) => {\n                     graph.add_edge(NodeIndex(a_id.index as usize), dummy_sink, *constraint);\n                 }\n+                ConstrainRegSubReg(..) => {\n+                    // this would be an edge from `dummy_source` to\n+                    // `dummy_sink`; just ignore it.\n+                }\n             }\n         }\n \n@@ -1274,22 +1450,27 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                             origin: this.constraints.borrow().get(&edge.data).unwrap().clone(),\n                         });\n                     }\n+\n+                    ConstrainRegSubReg(..) => {\n+                        panic!(\"cannot reach reg-sub-reg edge in region inference \\\n+                                post-processing\")\n+                    }\n                 }\n             }\n         }\n     }\n \n     fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-        where F: FnMut(&Constraint) -> bool\n+        where F: FnMut(&Constraint, &SubregionOrigin<'tcx>) -> bool\n     {\n         let mut iteration = 0;\n         let mut changed = true;\n         while changed {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            for (constraint, _) in self.constraints.borrow().iter() {\n-                let edge_changed = body(constraint);\n+            for (constraint, origin) in self.constraints.borrow().iter() {\n+                let edge_changed = body(constraint, origin);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {:?}\", constraint);\n                     changed = true;\n@@ -1301,19 +1482,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n }\n \n-impl<'tcx> fmt::Debug for Verify<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            VerifyRegSubReg(_, ref a, ref b) => {\n-                write!(f, \"VerifyRegSubReg({:?}, {:?})\", a, b)\n-            }\n-            VerifyGenericBound(_, ref p, ref a, ref bs) => {\n-                write!(f, \"VerifyGenericBound({:?}, {:?}, {:?})\", p, a, bs)\n-            }\n-        }\n-    }\n-}\n-\n fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n     match r {\n         ty::ReVar(rid) => lookup(values, rid),"}, {"sha": "badbeccee83cf6efdfecda136ca7c554b73ca943", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -178,7 +178,9 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             value: Bounded { relations: vec![], default: default },\n             diverging: diverging\n         });\n-        ty::TyVid { index: index as u32 }\n+        let v = ty::TyVid { index: index as u32 };\n+        debug!(\"new_var() -> {:?}\", v);\n+        v\n     }\n \n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n@@ -219,6 +221,17 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n \n     pub fn rollback_to(&mut self, s: Snapshot) {\n+        debug!(\"rollback_to{:?}\", {\n+            for action in self.values.actions_since_snapshot(&s.snapshot) {\n+                match *action {\n+                    sv::UndoLog::NewElem(index) => {\n+                        debug!(\"inference variable _#{}t popped\", index)\n+                    }\n+                    _ => { }\n+                }\n+            }\n+        });\n+\n         self.values.rollback_to(s.snapshot);\n         self.eq_relations.rollback_to(s.eq_snapshot);\n     }"}, {"sha": "dcc84fb04399fa5ed812a5e9ca1735b468ed2185", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 179, "deletions": 110, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -22,6 +22,7 @@ use dep_graph::DepNode;\n use hir::map::Map;\n use session::Session;\n use hir::def::{Def, DefMap};\n+use hir::def_id::DefId;\n use middle::region;\n use ty::subst;\n use ty;\n@@ -32,6 +33,7 @@ use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n use util::nodemap::NodeMap;\n \n+use rustc_data_structures::fnv::FnvHashSet;\n use hir;\n use hir::print::lifetime_to_string;\n use hir::intravisit::{self, Visitor, FnKind};\n@@ -50,11 +52,21 @@ pub enum DefRegion {\n \n // Maps the id of each lifetime reference to the lifetime decl\n // that it corresponds to.\n-pub type NamedRegionMap = NodeMap<DefRegion>;\n+pub struct NamedRegionMap {\n+    // maps from every use of a named (not anonymous) lifetime to a\n+    // `DefRegion` describing how that region is bound\n+    pub defs: NodeMap<DefRegion>,\n+\n+    // the set of lifetime def ids that are late-bound; late-bound ids\n+    // are named regions appearing in fn arguments that do not appear\n+    // in where-clauses\n+    pub late_bound: NodeMap<ty::Issue32330>,\n+}\n \n-struct LifetimeContext<'a> {\n+struct LifetimeContext<'a, 'tcx: 'a> {\n     sess: &'a Session,\n-    named_region_map: &'a mut NamedRegionMap,\n+    hir_map: &'a Map<'tcx>,\n+    map: &'a mut NamedRegionMap,\n     scope: Scope<'a>,\n     def_map: &'a DefMap,\n     // Deep breath. Our representation for poly trait refs contains a single\n@@ -101,21 +113,25 @@ pub fn krate(sess: &Session,\n              -> Result<NamedRegionMap, usize> {\n     let _task = hir_map.dep_graph.in_task(DepNode::ResolveLifetimes);\n     let krate = hir_map.krate();\n-    let mut named_region_map = NodeMap();\n+    let mut map = NamedRegionMap {\n+        defs: NodeMap(),\n+        late_bound: NodeMap(),\n+    };\n     sess.track_errors(|| {\n         krate.visit_all_items(&mut LifetimeContext {\n             sess: sess,\n-            named_region_map: &mut named_region_map,\n+            hir_map: hir_map,\n+            map: &mut map,\n             scope: &ROOT_SCOPE,\n             def_map: def_map,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n         });\n     })?;\n-    Ok(named_region_map)\n+    Ok(map)\n }\n \n-impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         assert!(self.labels_in_fn.is_empty());\n \n@@ -164,8 +180,12 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n             match item.node {\n-                hir::ForeignItemFn(_, ref generics) => {\n-                    this.visit_early_late(subst::FnSpace, generics, |this| {\n+                hir::ForeignItemFn(ref decl, ref generics) => {\n+                    this.visit_early_late(item.id,\n+                                          subst::FnSpace,\n+                                          decl,\n+                                          generics,\n+                                          |this| {\n                         intravisit::walk_foreign_item(this, item);\n                     })\n                 }\n@@ -179,24 +199,27 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+    fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n                 b: &'v hir::Block, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n-                self.visit_early_late(subst::FnSpace, generics, |this| {\n-                    this.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n+                self.visit_early_late(fn_id, subst::FnSpace, decl, generics, |this| {\n+                    this.add_scope_and_walk_fn(fk, decl, b, s, fn_id)\n                 })\n             }\n             FnKind::Method(_, sig, _, _) => {\n-                self.visit_early_late(subst::FnSpace, &sig.generics, |this| {\n-                    this.add_scope_and_walk_fn(fk, fd, b, s, fn_id)\n-                })\n+                self.visit_early_late(\n+                    fn_id,\n+                    subst::FnSpace,\n+                    decl,\n+                    &sig.generics,\n+                    |this| this.add_scope_and_walk_fn(fk, decl, b, s, fn_id));\n             }\n             FnKind::Closure(_) => {\n                 // Closures have their own set of labels, save labels just\n                 // like for foreign items above.\n                 let saved = replace(&mut self.labels_in_fn, vec![]);\n-                let result = self.add_scope_and_walk_fn(fk, fd, b, s, fn_id);\n+                let result = self.add_scope_and_walk_fn(fk, decl, b, s, fn_id);\n                 replace(&mut self.labels_in_fn, saved);\n                 result\n             }\n@@ -240,7 +263,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n         if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             self.visit_early_late(\n-                subst::FnSpace, &sig.generics,\n+                trait_item.id, subst::FnSpace,\n+                &sig.decl, &sig.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item))\n         } else {\n             intravisit::walk_trait_item(self, trait_item);\n@@ -380,8 +404,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n-\n+fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n@@ -468,7 +491,7 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n     }\n }\n \n-impl<'a> LifetimeContext<'a> {\n+impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn add_scope_and_walk_fn<'b>(&mut self,\n                                  fk: FnKind,\n                                  fd: &hir::FnDecl,\n@@ -501,10 +524,11 @@ impl<'a> LifetimeContext<'a> {\n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n         F: FnOnce(Scope, &mut LifetimeContext),\n     {\n-        let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n+        let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n         let mut this = LifetimeContext {\n             sess: sess,\n-            named_region_map: *named_region_map,\n+            hir_map: hir_map,\n+            map: *map,\n             scope: &wrap_scope,\n             def_map: self.def_map,\n             trait_ref_hack: self.trait_ref_hack,\n@@ -534,20 +558,27 @@ impl<'a> LifetimeContext<'a> {\n     /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n+                           fn_id: ast::NodeId,\n                            early_space: subst::ParamSpace,\n+                           decl: &hir::FnDecl,\n                            generics: &hir::Generics,\n                            walk: F) where\n         F: FnOnce(&mut LifetimeContext),\n     {\n-        let referenced_idents = early_bound_lifetime_names(generics);\n-\n-        debug!(\"visit_early_late: referenced_idents={:?}\",\n-               referenced_idents);\n-\n-        let (early, late): (Vec<_>, _) = generics.lifetimes.iter().cloned().partition(\n-            |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n-\n-        self.with(EarlyScope(early_space, &early, self.scope), move |old_scope, this| {\n+        let fn_def_id = self.hir_map.local_def_id(fn_id);\n+        insert_late_bound_lifetimes(self.map,\n+                                    fn_def_id,\n+                                    decl,\n+                                    generics);\n+\n+        let (late, early): (Vec<_>, _) =\n+            generics.lifetimes\n+                    .iter()\n+                    .cloned()\n+                    .partition(|l| self.map.late_bound.contains_key(&l.lifetime.id));\n+\n+        let this = self;\n+        this.with(EarlyScope(early_space, &early, this.scope), move |old_scope, this| {\n             this.with(LateScope(&late, this.scope), move |_, this| {\n                 this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                 walk(this);\n@@ -756,11 +787,12 @@ impl<'a> LifetimeContext<'a> {\n                        probably a bug in syntax::fold\");\n         }\n \n-        debug!(\"lifetime_ref={:?} id={:?} resolved to {:?}\",\n-                lifetime_to_string(lifetime_ref),\n-                lifetime_ref.id,\n-                def);\n-        self.named_region_map.insert(lifetime_ref.id, def);\n+        debug!(\"lifetime_ref={:?} id={:?} resolved to {:?} span={:?}\",\n+               lifetime_to_string(lifetime_ref),\n+               lifetime_ref.id,\n+               def,\n+               self.sess.codemap().span_to_string(lifetime_ref.span));\n+        self.map.defs.insert(lifetime_ref.id, def);\n     }\n }\n \n@@ -777,95 +809,132 @@ fn search_lifetimes<'a>(lifetimes: &'a [hir::LifetimeDef],\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn early_bound_lifetimes<'a>(generics: &'a hir::Generics) -> Vec<hir::LifetimeDef> {\n-    let referenced_idents = early_bound_lifetime_names(generics);\n-    if referenced_idents.is_empty() {\n-        return Vec::new();\n+/// Detects late-bound lifetimes and inserts them into\n+/// `map.late_bound`.\n+///\n+/// A region declared on a fn is **late-bound** if:\n+/// - it is constrained by an argument type;\n+/// - it does not appear in a where-clause.\n+///\n+/// \"Constrained\" basically means that it appears in any type but\n+/// not amongst the inputs to a projection.  In other words, `<&'a\n+/// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n+fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n+                               fn_def_id: DefId,\n+                               decl: &hir::FnDecl,\n+                               generics: &hir::Generics) {\n+    debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n+\n+    let mut constrained_by_input = ConstrainedCollector { regions: FnvHashSet() };\n+    for arg in &decl.inputs {\n+        constrained_by_input.visit_ty(&arg.ty);\n     }\n \n-    generics.lifetimes.iter()\n-        .filter(|l| referenced_idents.iter().any(|&i| i == l.lifetime.name))\n-        .cloned()\n-        .collect()\n-}\n-\n-/// Given a set of generic declarations, returns a list of names containing all early bound\n-/// lifetime names for those generics. (In fact, this list may also contain other names.)\n-fn early_bound_lifetime_names(generics: &hir::Generics) -> Vec<ast::Name> {\n-    // Create two lists, dividing the lifetimes into early/late bound.\n-    // Initially, all of them are considered late, but we will move\n-    // things from late into early as we go if we find references to\n-    // them.\n-    let mut early_bound = Vec::new();\n-    let mut late_bound = generics.lifetimes.iter()\n-                                           .map(|l| l.lifetime.name)\n-                                           .collect();\n-\n-    // Any lifetime that appears in a type bound is early.\n-    {\n-        let mut collector =\n-            FreeLifetimeCollector { early_bound: &mut early_bound,\n-                                    late_bound: &mut late_bound };\n-        for ty_param in generics.ty_params.iter() {\n-            walk_list!(&mut collector, visit_ty_param_bound, &ty_param.bounds);\n+    let mut appears_in_output = AllCollector { regions: FnvHashSet() };\n+    intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n+\n+    debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n+           constrained_by_input.regions);\n+\n+    // Walk the lifetimes that appear in where clauses.\n+    //\n+    // Subtle point: because we disallow nested bindings, we can just\n+    // ignore binders here and scrape up all names we see.\n+    let mut appears_in_where_clause = AllCollector { regions: FnvHashSet() };\n+    for ty_param in generics.ty_params.iter() {\n+        walk_list!(&mut appears_in_where_clause,\n+                   visit_ty_param_bound,\n+                   &ty_param.bounds);\n+    }\n+    walk_list!(&mut appears_in_where_clause,\n+               visit_where_predicate,\n+               &generics.where_clause.predicates);\n+    for lifetime_def in &generics.lifetimes {\n+        if !lifetime_def.bounds.is_empty() {\n+            // `'a: 'b` means both `'a` and `'b` are referenced\n+            appears_in_where_clause.visit_lifetime_def(lifetime_def);\n         }\n-        for predicate in &generics.where_clause.predicates {\n-            match predicate {\n-                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ref bounds,\n-                                                                              ref bounded_ty,\n-                                                                              ..}) => {\n-                    collector.visit_ty(&bounded_ty);\n-                    walk_list!(&mut collector, visit_ty_param_bound, bounds);\n+    }\n+\n+    debug!(\"insert_late_bound_lifetimes: appears_in_where_clause={:?}\",\n+           appears_in_where_clause.regions);\n+\n+    // Late bound regions are those that:\n+    // - appear in the inputs\n+    // - do not appear in the where-clauses\n+    for lifetime in &generics.lifetimes {\n+        let name = lifetime.lifetime.name;\n+\n+        // appears in the where clauses? early-bound.\n+        if appears_in_where_clause.regions.contains(&name) { continue; }\n+\n+        // does not appear in the inputs, but appears in the return\n+        // type? eventually this will be early-bound, but for now we\n+        // just mark it so we can issue warnings.\n+        let constrained_by_input = constrained_by_input.regions.contains(&name);\n+        let appears_in_output = appears_in_output.regions.contains(&name);\n+        let will_change = !constrained_by_input && appears_in_output;\n+        let issue_32330 = if will_change {\n+            ty::Issue32330::WillChange {\n+                fn_def_id: fn_def_id,\n+                region_name: name,\n+            }\n+        } else {\n+            ty::Issue32330::WontChange\n+        };\n+\n+        debug!(\"insert_late_bound_lifetimes: \\\n+                lifetime {:?} with id {:?} is late-bound ({:?}\",\n+               lifetime.lifetime.name, lifetime.lifetime.id, issue_32330);\n+\n+        let prev = map.late_bound.insert(lifetime.lifetime.id, issue_32330);\n+        assert!(prev.is_none(), \"visited lifetime {:?} twice\", lifetime.lifetime.id);\n+    }\n+\n+    return;\n+\n+    struct ConstrainedCollector {\n+        regions: FnvHashSet<ast::Name>,\n+    }\n+\n+    impl<'v> Visitor<'v> for ConstrainedCollector {\n+        fn visit_ty(&mut self, ty: &'v hir::Ty) {\n+            match ty.node {\n+                hir::TyPath(Some(_), _) => {\n+                    // ignore lifetimes appearing in associated type\n+                    // projections, as they are not *constrained*\n+                    // (defined above)\n                 }\n-                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n-                                                                                ref bounds,\n-                                                                                ..}) => {\n-                    collector.visit_lifetime(lifetime);\n \n-                    for bound in bounds {\n-                        collector.visit_lifetime(bound);\n+                hir::TyPath(None, ref path) => {\n+                    // consider only the lifetimes on the final\n+                    // segment; I am not sure it's even currently\n+                    // valid to have them elsewhere, but even if it\n+                    // is, those would be potentially inputs to\n+                    // projections\n+                    if let Some(last_segment) = path.segments.last() {\n+                        self.visit_path_segment(path.span, last_segment);\n                     }\n                 }\n-                &hir::WherePredicate::EqPredicate(_) => bug!(\"unimplemented\")\n-            }\n-        }\n-    }\n \n-    // Any lifetime that either has a bound or is referenced by a\n-    // bound is early.\n-    for lifetime_def in &generics.lifetimes {\n-        if !lifetime_def.bounds.is_empty() {\n-            shuffle(&mut early_bound, &mut late_bound,\n-                    lifetime_def.lifetime.name);\n-            for bound in &lifetime_def.bounds {\n-                shuffle(&mut early_bound, &mut late_bound,\n-                        bound.name);\n+                _ => {\n+                    intravisit::walk_ty(self, ty);\n+                }\n             }\n         }\n-    }\n-    return early_bound;\n \n-    struct FreeLifetimeCollector<'a> {\n-        early_bound: &'a mut Vec<ast::Name>,\n-        late_bound: &'a mut Vec<ast::Name>,\n+        fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n+            self.regions.insert(lifetime_ref.name);\n+        }\n     }\n \n-    impl<'a, 'v> Visitor<'v> for FreeLifetimeCollector<'a> {\n-        fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-            shuffle(self.early_bound, self.late_bound,\n-                    lifetime_ref.name);\n-        }\n+    struct AllCollector {\n+        regions: FnvHashSet<ast::Name>,\n     }\n \n-    fn shuffle(early_bound: &mut Vec<ast::Name>,\n-               late_bound: &mut Vec<ast::Name>,\n-               name: ast::Name) {\n-        match late_bound.iter().position(|n| *n == name) {\n-            Some(index) => {\n-                late_bound.swap_remove(index);\n-                early_bound.push(name);\n-            }\n-            None => { }\n+    impl<'v> Visitor<'v> for AllCollector {\n+        fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n+            self.regions.insert(lifetime_ref.name);\n         }\n     }\n }"}, {"sha": "23ffa4db96f77549b9382d7910c968d63ab64b14", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -171,10 +171,12 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n \n+        debug!(\"register_predicate_obligation(obligation={:?})\", obligation);\n+\n         infcx.obligations_in_snapshot.set(true);\n \n-        if infcx.tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate)\n-        {\n+        if infcx.tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n+            debug!(\"register_predicate_obligation: duplicate\");\n             return\n         }\n \n@@ -406,6 +408,8 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                     // also includes references to its upvars as part\n                     // of its type, and those types are resolved at\n                     // the same time.\n+                    //\n+                    // FIXME(#32286) logic seems false if no upvars\n                     pending_obligation.stalled_on =\n                         trait_ref_type_vars(selcx, data.to_poly_trait_ref());\n "}, {"sha": "5b363d90578b1e7c2d996c904bc5bd5b468f1af7", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Trait Resolution. See the Book for more.\n+//! Trait Resolution. See README.md for an overview of how this works.\n \n pub use self::SelectionError::*;\n pub use self::FulfillmentErrorCode::*;\n@@ -30,8 +30,9 @@ pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n-pub use self::project::{MismatchedProjectionTypes, ProjectionMode};\n+pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n+pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, ProjectionMode};\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};"}, {"sha": "30faf1a5f8b91b75fc13bf0ea69aaaec3f7acef3", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 302, "deletions": 75, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -24,12 +24,13 @@ use super::VtableImplData;\n use super::util;\n \n use hir::def_id::DefId;\n-use infer::{self, InferOk, TypeOrigin};\n+use infer::{InferOk, TypeOrigin};\n+use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n+use syntax::parse::token;\n+use syntax::ast;\n use ty::subst::Subst;\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n-use syntax::parse::token;\n-use syntax::ast;\n use util::common::FN_OUTPUT_NAME;\n \n use std::rc::Rc;\n@@ -182,7 +183,8 @@ pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n         let skol_obligation = obligation.with(skol_predicate);\n         match project_and_unify_type(selcx, &skol_obligation) {\n             Ok(result) => {\n-                match infcx.leak_check(false, &skol_map, snapshot) {\n+                let span = obligation.cause.span;\n+                match infcx.leak_check(false, span, &skol_map, snapshot) {\n                     Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, &result)),\n                     Err(e) => Err(MismatchedProjectionTypes { err: e }),\n                 }\n@@ -256,9 +258,13 @@ pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n \n     where T : TypeFoldable<'tcx>\n {\n+    debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n     let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n     let result = normalizer.fold(value);\n-\n+    debug!(\"normalize_with_depth: depth={} result={:?} with {} obligations\",\n+           depth, result, normalizer.obligations.len());\n+    debug!(\"normalize_with_depth: depth={} obligations={:?}\",\n+           depth, normalizer.obligations);\n     Normalized {\n         value: result,\n         obligations: normalizer.obligations,\n@@ -330,13 +336,16 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                 // binder). It would be better to normalize in a\n                 // binding-aware fashion.\n \n-                let Normalized { value: ty, obligations } =\n+                let Normalized { value: normalized_ty, obligations } =\n                     normalize_projection_type(self.selcx,\n                                               data.clone(),\n                                               self.cause.clone(),\n                                               self.depth);\n+                debug!(\"AssociatedTypeNormalizer: depth={} normalized {:?} to {:?} \\\n+                        with {} add'l obligations\",\n+                       self.depth, ty, normalized_ty, obligations.len());\n                 self.obligations.extend(obligations);\n-                ty\n+                normalized_ty\n             }\n \n             _ => {\n@@ -404,64 +413,161 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     depth: usize)\n     -> Option<NormalizedTy<'tcx>>\n {\n-    debug!(\"normalize_projection_type(\\\n+    let infcx = selcx.infcx();\n+\n+    let projection_ty = infcx.resolve_type_vars_if_possible(&projection_ty);\n+\n+    debug!(\"opt_normalize_projection_type(\\\n            projection_ty={:?}, \\\n            depth={})\",\n            projection_ty,\n            depth);\n \n+    // FIXME(#20304) For now, I am caching here, which is good, but it\n+    // means we don't capture the type variables that are created in\n+    // the case of ambiguity. Which means we may create a large stream\n+    // of such variables. OTOH, if we move the caching up a level, we\n+    // would not benefit from caching when proving `T: Trait<U=Foo>`\n+    // bounds. It might be the case that we want two distinct caches,\n+    // or else another kind of cache entry.\n+\n+    match infcx.projection_cache.borrow_mut().try_start(projection_ty) {\n+        Ok(()) => { }\n+        Err(ProjectionCacheEntry::Ambiguous) => {\n+            // If we found ambiguity the last time, that generally\n+            // means we will continue to do so until some type in the\n+            // key changes (and we know it hasn't, because we just\n+            // fully resolved it). One exception though is closure\n+            // types, which can transition from having a fixed kind to\n+            // no kind with no visible change in the key.\n+            //\n+            // FIXME(#32286) refactor this so that closure type\n+            // changes\n+            debug!(\"opt_normalize_projection_type: \\\n+                    found cache entry: ambiguous\");\n+            if !projection_ty.has_closure_types() {\n+                return None;\n+            }\n+        }\n+        Err(ProjectionCacheEntry::InProgress) => {\n+            // If while normalized A::B, we are asked to normalize\n+            // A::B, just return A::B itself. This is a conservative\n+            // answer, in the sense that A::B *is* clearly equivalent\n+            // to A::B, though there may be a better value we can\n+            // find.\n+\n+            // Under lazy normalization, this can arise when\n+            // bootstrapping.  That is, imagine an environment with a\n+            // where-clause like `A::B == u32`. Now, if we are asked\n+            // to normalize `A::B`, we will want to check the\n+            // where-clauses in scope. So we will try to unify `A::B`\n+            // with `A::B`, which can trigger a recursive\n+            // normalization. In that case, I think we will want this code:\n+            //\n+            // ```\n+            // let ty = selcx.tcx().mk_projection(projection_ty.trait_ref,\n+            //                                    projection_ty.item_name);\n+            // return Some(NormalizedTy { value: v, obligations: vec![] });\n+            // ```\n+\n+            debug!(\"opt_normalize_projection_type: \\\n+                    found cache entry: in-progress\");\n+\n+            // But for now, let's classify this as an overflow:\n+            let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n+            let obligation = Obligation::with_depth(cause.clone(),\n+                                                    recursion_limit,\n+                                                    projection_ty);\n+            selcx.infcx().report_overflow_error(&obligation, false);\n+        }\n+        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+            // If we find the value in the cache, then the obligations\n+            // have already been returned from the previous entry (and\n+            // should therefore have been honored).\n+            debug!(\"opt_normalize_projection_type: \\\n+                    found normalized ty `{:?}`\",\n+                   ty);\n+            return Some(NormalizedTy { value: ty, obligations: vec![] });\n+        }\n+        Err(ProjectionCacheEntry::Error) => {\n+            debug!(\"opt_normalize_projection_type: \\\n+                    found error\");\n+            return Some(normalize_to_error(selcx, projection_ty, cause, depth));\n+        }\n+    }\n+\n     let obligation = Obligation::with_depth(cause.clone(), depth, projection_ty.clone());\n     match project_type(selcx, &obligation) {\n-        Ok(ProjectedTy::Progress(projected_ty, mut obligations)) => {\n+        Ok(ProjectedTy::Progress(Progress { ty: projected_ty,\n+                                            mut obligations,\n+                                            cacheable })) => {\n             // if projection succeeded, then what we get out of this\n             // is also non-normalized (consider: it was derived from\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            debug!(\"normalize_projection_type: projected_ty={:?} depth={} obligations={:?}\",\n+            debug!(\"opt_normalize_projection_type: \\\n+                    projected_ty={:?} \\\n+                    depth={} \\\n+                    obligations={:?} \\\n+                    cacheable={:?}\",\n                    projected_ty,\n                    depth,\n-                   obligations);\n+                   obligations,\n+                   cacheable);\n \n-            if projected_ty.has_projection_types() {\n+            let result = if projected_ty.has_projection_types() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth+1);\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n-                debug!(\"normalize_projection_type: normalized_ty={:?} depth={}\",\n+                debug!(\"opt_normalize_projection_type: \\\n+                        normalized_ty={:?} depth={}\",\n                        normalized_ty,\n                        depth);\n \n                 obligations.extend(normalizer.obligations);\n-                Some(Normalized {\n+                Normalized {\n                     value: normalized_ty,\n                     obligations: obligations,\n-                })\n+                }\n             } else {\n-                Some(Normalized {\n+                Normalized {\n                     value: projected_ty,\n                     obligations: obligations,\n-                })\n-            }\n+                }\n+            };\n+            infcx.projection_cache.borrow_mut()\n+                                  .complete(projection_ty, &result, cacheable);\n+            Some(result)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n-            debug!(\"normalize_projection_type: projected_ty={:?} no progress\",\n+            debug!(\"opt_normalize_projection_type: \\\n+                    projected_ty={:?} no progress\",\n                    projected_ty);\n-            Some(Normalized {\n+            let result = Normalized {\n                 value: projected_ty,\n                 obligations: vec!()\n-            })\n+            };\n+            infcx.projection_cache.borrow_mut()\n+                                  .complete(projection_ty, &result, true);\n+            Some(result)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n-            debug!(\"normalize_projection_type: too many candidates\");\n+            debug!(\"opt_normalize_projection_type: \\\n+                    too many candidates\");\n+            infcx.projection_cache.borrow_mut()\n+                                  .ambiguous(projection_ty);\n             None\n         }\n         Err(ProjectionTyError::TraitSelectionError(_)) => {\n-            debug!(\"normalize_projection_type: ERROR\");\n+            debug!(\"opt_normalize_projection_type: ERROR\");\n             // if we got an error processing the `T as Trait` part,\n             // just return `ty::err` but add the obligation `T :\n             // Trait`, which when processed will cause the error to be\n             // reported later\n \n+            infcx.projection_cache.borrow_mut()\n+                                  .error(projection_ty);\n             Some(normalize_to_error(selcx, projection_ty, cause, depth))\n         }\n     }\n@@ -504,11 +610,43 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n }\n \n enum ProjectedTy<'tcx> {\n-    Progress(Ty<'tcx>, Vec<PredicateObligation<'tcx>>),\n+    Progress(Progress<'tcx>),\n     NoProgress(Ty<'tcx>),\n }\n \n+struct Progress<'tcx> {\n+    ty: Ty<'tcx>,\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+    cacheable: bool,\n+}\n+\n+impl<'tcx> Progress<'tcx> {\n+    fn error<'a,'gcx>(tcx: TyCtxt<'a,'gcx,'tcx>) -> Self {\n+        Progress {\n+            ty: tcx.types.err,\n+            obligations: vec![],\n+            cacheable: true\n+        }\n+    }\n+\n+    fn with_addl_obligations(mut self,\n+                             mut obligations: Vec<PredicateObligation<'tcx>>)\n+                             -> Self {\n+        debug!(\"with_addl_obligations: self.obligations.len={} obligations.len={}\",\n+               self.obligations.len(), obligations.len());\n+\n+        debug!(\"with_addl_obligations: self.obligations={:?} obligations={:?}\",\n+               self.obligations, obligations);\n+\n+        self.obligations.append(&mut obligations);\n+        self\n+    }\n+}\n+\n /// Compute the result of a projection type (if we can).\n+///\n+/// IMPORTANT:\n+/// - `obligation` must be fully normalized\n fn project_type<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>)\n@@ -523,13 +661,12 @@ fn project_type<'cx, 'gcx, 'tcx>(\n         selcx.infcx().report_overflow_error(&obligation, true);\n     }\n \n-    let obligation_trait_ref =\n-        selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n+    let obligation_trait_ref = &obligation.predicate.trait_ref;\n \n     debug!(\"project: obligation_trait_ref={:?}\", obligation_trait_ref);\n \n     if obligation_trait_ref.references_error() {\n-        return Ok(ProjectedTy::Progress(selcx.tcx().types.err, vec!()));\n+        return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n     }\n \n     let mut candidates = ProjectionTyCandidateSet {\n@@ -607,16 +744,17 @@ fn project_type<'cx, 'gcx, 'tcx>(\n \n     match candidates.vec.pop() {\n         Some(candidate) => {\n-            let (ty, obligations) = confirm_candidate(selcx,\n-                                                      obligation,\n-                                                      &obligation_trait_ref,\n-                                                      candidate);\n-            Ok(ProjectedTy::Progress(ty, obligations))\n+            Ok(ProjectedTy::Progress(\n+                confirm_candidate(selcx,\n+                                  obligation,\n+                                  &obligation_trait_ref,\n+                                  candidate)))\n         }\n         None => {\n-            Ok(ProjectedTy::NoProgress(selcx.tcx().mk_projection(\n-                obligation.predicate.trait_ref.clone(),\n-                obligation.predicate.item_name)))\n+            Ok(ProjectedTy::NoProgress(\n+                selcx.tcx().mk_projection(\n+                    obligation.predicate.trait_ref.clone(),\n+                    obligation.predicate.item_name)))\n         }\n     }\n }\n@@ -919,7 +1057,7 @@ fn confirm_candidate<'cx, 'gcx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\",\n            candidate,\n@@ -941,7 +1079,7 @@ fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n@@ -979,7 +1117,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let self_ty = obligation_trait_ref.self_ty();\n     let object_ty = selcx.infcx().shallow_resolve(self_ty);\n@@ -991,7 +1129,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n             span_bug!(\n                 obligation.cause.span,\n                 \"confirm_object_candidate called with non-object: {:?}\",\n-                object_ty);\n+                object_ty)\n         }\n     };\n     let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n@@ -1035,7 +1173,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n                 debug!(\"confirm_object_candidate: no env-predicate \\\n                         found in object type `{:?}`; ill-formed\",\n                        object_ty);\n-                return (selcx.tcx().types.err, vec!());\n+                return Progress::error(selcx.tcx());\n             }\n         }\n     };\n@@ -1047,7 +1185,7 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     // FIXME(#32730) drop this assertion once obligations are propagated from inference (fn pointer\n     // vtable nested obligations ONLY come from unification in inference)\n@@ -1061,31 +1199,37 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let closure_typer = selcx.closure_typer();\n     let closure_type = closure_typer.closure_type(vtable.closure_def_id, vtable.substs);\n     let Normalized {\n         value: closure_type,\n-        mut obligations\n+        obligations\n     } = normalize_with_depth(selcx,\n                              obligation.cause.clone(),\n                              obligation.recursion_depth+1,\n                              &closure_type);\n-    let (ty, mut cc_obligations) = confirm_callable_candidate(selcx,\n-                                                              obligation,\n-                                                              &closure_type.sig,\n-                                                              util::TupleArgumentsFlag::No);\n-    obligations.append(&mut cc_obligations);\n-    (ty, obligations)\n+\n+    debug!(\"confirm_closure_candidate: obligation={:?},closure_type={:?},obligations={:?}\",\n+           obligation,\n+           closure_type,\n+           obligations);\n+\n+    confirm_callable_candidate(selcx,\n+                               obligation,\n+                               &closure_type.sig,\n+                               util::TupleArgumentsFlag::No)\n+        .with_addl_obligations(obligations)\n+        .with_addl_obligations(vtable.nested)\n }\n \n fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_sig: &ty::PolyFnSig<'tcx>,\n     flag: util::TupleArgumentsFlag)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let tcx = selcx.tcx();\n \n@@ -1118,47 +1262,38 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     poly_projection: ty::PolyProjectionPredicate<'tcx>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let infcx = selcx.infcx();\n-\n-    let projection =\n-        infcx.replace_late_bound_regions_with_fresh_var(\n-            obligation.cause.span,\n-            infer::LateBoundRegionConversionTime::HigherRankedType,\n-            &poly_projection).0;\n-\n-    assert_eq!(projection.projection_ty.item_name,\n-               obligation.predicate.item_name);\n-\n     let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-    let obligations = match infcx.eq_trait_refs(false,\n-                                                origin,\n-                                                obligation.predicate.trait_ref.clone(),\n-                                                projection.projection_ty.trait_ref.clone()) {\n-        Ok(InferOk { obligations, .. }) => {\n-            // FIXME(#32730) once obligations are generated in inference, remove this assertion\n+    let trait_ref = obligation.predicate.trait_ref;\n+    match infcx.match_poly_projection_predicate(origin, poly_projection, trait_ref) {\n+        Ok(InferOk { value: ty_match, obligations }) => {\n+            // FIXME(#32730) once obligations are generated in inference, drop this assertion\n             assert!(obligations.is_empty());\n-            obligations\n+            Progress {\n+                ty: ty_match.value,\n+                obligations: obligations,\n+                cacheable: ty_match.unconstrained_regions.is_empty(),\n+            }\n         }\n         Err(e) => {\n             span_bug!(\n                 obligation.cause.span,\n-                \"Failed to unify `{:?}` and `{:?}` in projection: {}\",\n+                \"Failed to unify obligation `{:?}` \\\n+                 with poly_projection `{:?}`: {:?}\",\n                 obligation,\n-                projection,\n+                poly_projection,\n                 e);\n         }\n-    };\n-\n-    (projection.ty, obligations)\n+    }\n }\n \n fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n \n@@ -1179,7 +1314,11 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n                 tcx.types.err\n             });\n             let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n-            (ty.subst(tcx, substs), nested)\n+            Progress {\n+                ty: ty.subst(tcx, substs),\n+                obligations: nested,\n+                cacheable: true\n+            }\n         }\n         None => {\n             span_bug!(obligation.cause.span,\n@@ -1222,3 +1361,91 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n             .next()\n     }\n }\n+\n+// # Cache\n+\n+pub struct ProjectionCache<'tcx> {\n+    map: SnapshotMap<ty::ProjectionTy<'tcx>, ProjectionCacheEntry<'tcx>>,\n+}\n+\n+#[derive(Clone, Debug)]\n+enum ProjectionCacheEntry<'tcx> {\n+    InProgress,\n+    Ambiguous,\n+    Error,\n+    NormalizedTy(Ty<'tcx>),\n+}\n+\n+// NB: intentionally not Clone\n+pub struct ProjectionCacheSnapshot {\n+    snapshot: Snapshot\n+}\n+\n+impl<'tcx> ProjectionCache<'tcx> {\n+    pub fn new() -> Self {\n+        ProjectionCache {\n+            map: SnapshotMap::new()\n+        }\n+    }\n+\n+    pub fn snapshot(&mut self) -> ProjectionCacheSnapshot {\n+        ProjectionCacheSnapshot { snapshot: self.map.snapshot() }\n+    }\n+\n+    pub fn rollback_to(&mut self, snapshot: ProjectionCacheSnapshot) {\n+        self.map.rollback_to(snapshot.snapshot);\n+    }\n+\n+    pub fn commit(&mut self, snapshot: ProjectionCacheSnapshot) {\n+        self.map.commit(snapshot.snapshot);\n+    }\n+\n+    /// Try to start normalize `key`; returns an error if\n+    /// normalization already occured (this error corresponds to a\n+    /// cache hit, so it's actually a good thing).\n+    fn try_start(&mut self, key: ty::ProjectionTy<'tcx>)\n+                 -> Result<(), ProjectionCacheEntry<'tcx>> {\n+        match self.map.get(&key) {\n+            Some(entry) => return Err(entry.clone()),\n+            None => { }\n+        }\n+\n+        self.map.insert(key, ProjectionCacheEntry::InProgress);\n+        Ok(())\n+    }\n+\n+    /// Indicates that `key` was normalized to `value`. If `cacheable` is false,\n+    /// then this result is sadly not cacheable.\n+    fn complete(&mut self,\n+                key: ty::ProjectionTy<'tcx>,\n+                value: &NormalizedTy<'tcx>,\n+                cacheable: bool) {\n+        let fresh_key = if cacheable {\n+            debug!(\"ProjectionCacheEntry::complete: adding cache entry: key={:?}, value={:?}\",\n+                   key, value);\n+            self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.value))\n+        } else {\n+            debug!(\"ProjectionCacheEntry::complete: cannot cache: key={:?}, value={:?}\",\n+                   key, value);\n+            !self.map.remove(key)\n+        };\n+\n+        assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n+    }\n+\n+    /// Indicates that trying to normalize `key` resulted in\n+    /// ambiguity. No point in trying it again then until we gain more\n+    /// type information (in which case, the \"fully resolved\" key will\n+    /// be different).\n+    fn ambiguous(&mut self, key: ty::ProjectionTy<'tcx>) {\n+        let fresh = self.map.insert(key, ProjectionCacheEntry::Ambiguous);\n+        assert!(!fresh, \"never started projecting `{:?}`\", key);\n+    }\n+\n+    /// Indicates that trying to normalize `key` resulted in\n+    /// error.\n+    fn error(&mut self, key: ty::ProjectionTy<'tcx>) {\n+        let fresh = self.map.insert(key, ProjectionCacheEntry::Error);\n+        assert!(!fresh, \"never started projecting `{:?}`\", key);\n+    }\n+}"}, {"sha": "7a20b43b8f2e69a470c67810c95a1be71a48a819", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -46,6 +46,7 @@ use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::cell::RefCell;\n use std::fmt;\n use std::marker::PhantomData;\n+use std::mem;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n@@ -1237,6 +1238,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                    skol_trait_predicate.trait_ref.clone(),\n                                                    &skol_map,\n                                                    snapshot);\n+\n+                self.infcx.pop_skolemized(skol_map, snapshot);\n+\n                 assert!(result);\n                 true\n             }\n@@ -1263,7 +1267,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             Err(_) => { return false; }\n         }\n \n-        self.infcx.leak_check(false, skol_map, snapshot).is_ok()\n+        self.infcx.leak_check(false, obligation.cause.span, skol_map, snapshot).is_ok()\n     }\n \n     /// Given an obligation like `<SomeTrait for T>`, search the obligations that the caller\n@@ -1422,9 +1426,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.tcx(),\n             obligation.predicate.0.trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.probe(|this, snapshot| {\n-                    if let Ok(_) = this.match_impl(impl_def_id, obligation, snapshot) {\n-                        candidates.vec.push(ImplCandidate(impl_def_id));\n+                self.probe(|this, snapshot| { /* [1] */\n+                    match this.match_impl(impl_def_id, obligation, snapshot) {\n+                        Ok(skol_map) => {\n+                            candidates.vec.push(ImplCandidate(impl_def_id));\n+\n+                            // NB: we can safely drop the skol map\n+                            // since we are in a probe [1]\n+                            mem::drop(skol_map);\n+                        }\n+                        Err(_) => { }\n                     }\n                 });\n             }\n@@ -1509,9 +1520,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        self.probe(|this, snapshot| {\n-            let (self_ty, _) =\n-                this.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n+        self.probe(|this, _snapshot| {\n+            // the code below doesn't care about regions, and the\n+            // self-ty here doesn't escape this probe, so just erase\n+            // any LBR.\n+            let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n             let poly_trait_ref = match self_ty.sty {\n                 ty::TyTrait(ref data) => {\n                     match this.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n@@ -2710,7 +2723,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             })?;\n         self.inferred_obligations.extend(obligations);\n \n-        if let Err(e) = self.infcx.leak_check(false, &skol_map, snapshot) {\n+        if let Err(e) = self.infcx.leak_check(false,\n+                                              obligation.cause.span,\n+                                              &skol_map,\n+                                              snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n             return Err(());\n         }"}, {"sha": "b12581b34003d64841a6d5253171254fb0edba37", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -176,9 +176,13 @@ impl FlagComputation {\n \n     fn add_region(&mut self, r: ty::Region) {\n         match r {\n-            ty::ReVar(..) |\n+            ty::ReVar(..) => {\n+                self.add_flags(TypeFlags::HAS_RE_INFER);\n+                self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX);\n+            }\n             ty::ReSkolemized(..) => {\n                 self.add_flags(TypeFlags::HAS_RE_INFER);\n+                self.add_flags(TypeFlags::HAS_RE_SKOL);\n                 self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX);\n             }\n             ty::ReLateBound(debruijn, _) => { self.add_depth(debruijn.depth); }"}, {"sha": "4069aa6b955d4af9f951bc737500410edbda3791", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -60,6 +60,7 @@ pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n pub use self::sty::{ClosureSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n+pub use self::sty::Issue32330;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::FnOutput::*;\n@@ -514,19 +515,20 @@ bitflags! {\n         const HAS_SELF           = 1 << 1,\n         const HAS_TY_INFER       = 1 << 2,\n         const HAS_RE_INFER       = 1 << 3,\n-        const HAS_RE_EARLY_BOUND = 1 << 4,\n-        const HAS_FREE_REGIONS   = 1 << 5,\n-        const HAS_TY_ERR         = 1 << 6,\n-        const HAS_PROJECTION     = 1 << 7,\n-        const HAS_TY_CLOSURE     = 1 << 8,\n+        const HAS_RE_SKOL        = 1 << 4,\n+        const HAS_RE_EARLY_BOUND = 1 << 5,\n+        const HAS_FREE_REGIONS   = 1 << 6,\n+        const HAS_TY_ERR         = 1 << 7,\n+        const HAS_PROJECTION     = 1 << 8,\n+        const HAS_TY_CLOSURE     = 1 << 9,\n \n         // true if there are \"names\" of types and regions and so forth\n         // that are local to a particular fn\n-        const HAS_LOCAL_NAMES   = 1 << 9,\n+        const HAS_LOCAL_NAMES    = 1 << 10,\n \n         // Present if the type belongs in a local type context.\n         // Only set for TyInfer other than Fresh.\n-        const KEEP_IN_LOCAL_TCX = 1 << 10,\n+        const KEEP_IN_LOCAL_TCX  = 1 << 11,\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n@@ -739,7 +741,8 @@ impl RegionParameterDef {\n         })\n     }\n     pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        ty::BoundRegion::BrNamed(self.def_id, self.name)\n+        // this is an early bound region, so unaffected by #32330\n+        ty::BoundRegion::BrNamed(self.def_id, self.name, Issue32330::WontChange)\n     }\n }\n \n@@ -1013,7 +1016,7 @@ pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::R\n /// equality between arbitrary types. Processing an instance of Form\n /// #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -2855,7 +2858,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         for def in generics.regions.as_slice() {\n             let region =\n                 ReFree(FreeRegion { scope: free_id_outlive,\n-                                    bound_region: BrNamed(def.def_id, def.name) });\n+                                    bound_region: def.to_bound_region() });\n             debug!(\"push_region_params {:?}\", region);\n             regions.push(def.space, region);\n         }"}, {"sha": "1e2920ca87ea6d712b3a2f64839160f1fcc7a542", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -827,7 +827,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n             def_id: self.def_id,\n             space: self.space,\n             index: self.index,\n-            bounds: self.bounds.fold_with(folder)\n+            bounds: self.bounds.fold_with(folder),\n         }\n     }\n "}, {"sha": "2bb88e52f8887b06496e6b0100a3626322ca8179", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -58,7 +58,7 @@ pub enum BoundRegion {\n     ///\n     /// The def-id is needed to distinguish free regions in\n     /// the event of shadowing.\n-    BrNamed(DefId, Name),\n+    BrNamed(DefId, Name, Issue32330),\n \n     /// Fresh bound identifiers created during GLB computations.\n     BrFresh(u32),\n@@ -68,6 +68,25 @@ pub enum BoundRegion {\n     BrEnv\n }\n \n+/// True if this late-bound region is unconstrained, and hence will\n+/// become early-bound once #32330 is fixed.\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash,\n+         RustcEncodable, RustcDecodable)]\n+pub enum Issue32330 {\n+    WontChange,\n+\n+    /// this region will change from late-bound to early-bound once\n+    /// #32330 is fixed.\n+    WillChange {\n+        /// fn where is region declared\n+        fn_def_id: DefId,\n+\n+        /// name of region; duplicates the info in BrNamed but convenient\n+        /// to have it here, and this code is only temporary\n+        region_name: ast::Name,\n+    }\n+}\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n@@ -697,7 +716,7 @@ pub struct EarlyBoundRegion {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TyVid {\n-    pub index: u32\n+    pub index: u32,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "a851e8354a9234995b64c2ebe9b43debe0cf89aa", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -261,7 +261,7 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n     let new_value = tcx.replace_late_bound_regions(&value, |br| {\n         let _ = start_or_continue(f, \"for<\", \", \");\n         ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n-            ty::BrNamed(_, name) => {\n+            ty::BrNamed(_, name, _) => {\n                 let _ = write!(f, \"{}\", name);\n                 br\n             }\n@@ -270,7 +270,9 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrEnv => {\n                 let name = token::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(tcx.map.local_def_id(CRATE_NODE_ID), name)\n+                ty::BrNamed(tcx.map.local_def_id(CRATE_NODE_ID),\n+                            name,\n+                            ty::Issue32330::WontChange)\n             }\n         })\n     }).0;\n@@ -485,7 +487,7 @@ impl fmt::Display for ty::BoundRegion {\n         }\n \n         match *self {\n-            BrNamed(_, name) => write!(f, \"{}\", name),\n+            BrNamed(_, name, _) => write!(f, \"{}\", name),\n             BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n         }\n     }\n@@ -496,8 +498,9 @@ impl fmt::Debug for ty::BoundRegion {\n         match *self {\n             BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n             BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n-            BrNamed(did, name) => {\n-                write!(f, \"BrNamed({:?}:{:?}, {:?})\", did.krate, did.index, name)\n+            BrNamed(did, name, issue32330) => {\n+                write!(f, \"BrNamed({:?}:{:?}, {:?}, {:?})\",\n+                       did.krate, did.index, name, issue32330)\n             }\n             BrEnv => \"BrEnv\".fmt(f),\n         }"}, {"sha": "00f797d1b9022640241af909f0248fdb6eacce11", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -42,6 +42,7 @@ pub mod bitvec;\n pub mod graph;\n pub mod ivar;\n pub mod obligation_forest;\n+pub mod snapshot_map;\n pub mod snapshot_vec;\n pub mod transitive_relation;\n pub mod unify;"}, {"sha": "b3989013d21145044c0a88ffa0b9841711d07e72", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -0,0 +1,138 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fnv::FnvHashMap;\n+use std::hash::Hash;\n+use std::ops;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub struct SnapshotMap<K, V>\n+    where K: Hash + Clone + Eq\n+{\n+    map: FnvHashMap<K, V>,\n+    undo_log: Vec<UndoLog<K, V>>,\n+}\n+\n+pub struct Snapshot {\n+    len: usize\n+}\n+\n+enum UndoLog<K, V> {\n+    OpenSnapshot,\n+    CommittedSnapshot,\n+    Inserted(K),\n+    Overwrite(K, V),\n+}\n+\n+impl<K, V> SnapshotMap<K, V>\n+    where K: Hash + Clone + Eq\n+{\n+    pub fn new() -> Self {\n+        SnapshotMap {\n+            map: FnvHashMap(),\n+            undo_log: vec![]\n+        }\n+    }\n+\n+    pub fn insert(&mut self, key: K, value: V) -> bool {\n+        match self.map.insert(key.clone(), value) {\n+            None => {\n+                if !self.undo_log.is_empty() {\n+                    self.undo_log.push(UndoLog::Inserted(key));\n+                }\n+                true\n+            }\n+            Some(old_value) => {\n+                if !self.undo_log.is_empty() {\n+                    self.undo_log.push(UndoLog::Overwrite(key, old_value));\n+                }\n+                false\n+            }\n+        }\n+    }\n+\n+    pub fn remove(&mut self, key: K) -> bool {\n+        match self.map.remove(&key) {\n+            Some(old_value) => {\n+                if !self.undo_log.is_empty() {\n+                    self.undo_log.push(UndoLog::Overwrite(key, old_value));\n+                }\n+                true\n+            }\n+            None => {\n+                false\n+            }\n+        }\n+    }\n+\n+    pub fn get(&self, key: &K) -> Option<&V> {\n+        self.map.get(key)\n+    }\n+\n+    pub fn snapshot(&mut self) -> Snapshot {\n+        self.undo_log.push(UndoLog::OpenSnapshot);\n+        let len = self.undo_log.len() - 1;\n+        Snapshot { len: len }\n+    }\n+\n+    fn assert_open_snapshot(&self, snapshot: &Snapshot) {\n+        assert!(snapshot.len < self.undo_log.len());\n+        assert!(match self.undo_log[snapshot.len] {\n+            UndoLog::OpenSnapshot => true,\n+            _ => false\n+        });\n+    }\n+\n+    pub fn commit(&mut self, snapshot: Snapshot) {\n+        self.assert_open_snapshot(&snapshot);\n+        if snapshot.len == 0 {\n+            // The root snapshot.\n+            self.undo_log.truncate(0);\n+        } else {\n+            self.undo_log[snapshot.len] = UndoLog::CommittedSnapshot;\n+        }\n+    }\n+\n+    pub fn rollback_to(&mut self, snapshot: Snapshot) {\n+        self.assert_open_snapshot(&snapshot);\n+        while self.undo_log.len() > snapshot.len + 1 {\n+            match self.undo_log.pop().unwrap() {\n+                UndoLog::OpenSnapshot => {\n+                    panic!(\"cannot rollback an uncommitted snapshot\");\n+                }\n+\n+                UndoLog::CommittedSnapshot => { }\n+\n+                UndoLog::Inserted(key) => {\n+                    self.map.remove(&key);\n+                }\n+\n+                UndoLog::Overwrite(key, old_value) => {\n+                    self.map.insert(key, old_value);\n+                }\n+            }\n+        }\n+\n+        let v = self.undo_log.pop().unwrap();\n+        assert!(match v { UndoLog::OpenSnapshot => true, _ => false });\n+        assert!(self.undo_log.len() == snapshot.len);\n+    }\n+}\n+\n+impl<'k, K, V> ops::Index<&'k K> for SnapshotMap<K, V>\n+    where K: Hash + Clone + Eq\n+{\n+    type Output = V;\n+    fn index(&self, key: &'k K) -> &V {\n+        &self.map[key]\n+    }\n+}"}, {"sha": "4114082839b0b9a6a3a10e4f9cde5ba9f26c4031", "filename": "src/librustc_data_structures/snapshot_map/test.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftest.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::SnapshotMap;\n+\n+#[test]\n+fn basic() {\n+    let mut map = SnapshotMap::new();\n+    map.insert(22, \"twenty-two\");\n+    let snapshot = map.snapshot();\n+    map.insert(22, \"thirty-three\");\n+    assert_eq!(map[&22], \"thirty-three\");\n+    map.insert(44, \"fourty-four\");\n+    assert_eq!(map[&44], \"fourty-four\");\n+    assert_eq!(map.get(&33), None);\n+    map.rollback_to(snapshot);\n+    assert_eq!(map[&22], \"twenty-two\");\n+    assert_eq!(map.get(&33), None);\n+    assert_eq!(map.get(&44), None);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn out_of_order() {\n+    let mut map = SnapshotMap::new();\n+    map.insert(22, \"twenty-two\");\n+    let snapshot1 = map.snapshot();\n+    let _snapshot2 = map.snapshot();\n+    map.rollback_to(snapshot1);\n+}\n+\n+#[test]\n+fn nested_commit_then_rollback() {\n+    let mut map = SnapshotMap::new();\n+    map.insert(22, \"twenty-two\");\n+    let snapshot1 = map.snapshot();\n+    let snapshot2 = map.snapshot();\n+    map.insert(22, \"thirty-three\");\n+    map.commit(snapshot2);\n+    assert_eq!(map[&22], \"thirty-three\");\n+    map.rollback_to(snapshot1);\n+    assert_eq!(map[&22], \"twenty-two\");\n+}"}, {"sha": "1131e409aa05048d7a9770408d8f9d07831c88c6", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -1662,31 +1662,12 @@ fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n     }\n \n     let mut regions = subst::VecPerParamSpace::empty();\n-    for rp_doc in reader::tagged_docs(doc, tag_region_param_def) {\n-        let ident_str_doc = reader::get_doc(rp_doc,\n-                                            tag_region_param_def_ident);\n-        let name = item_name(&token::get_ident_interner(), ident_str_doc);\n-        let def_id_doc = reader::get_doc(rp_doc,\n-                                         tag_region_param_def_def_id);\n-        let def_id = translated_def_id(cdata, def_id_doc);\n-\n-        let doc = reader::get_doc(rp_doc, tag_region_param_def_space);\n-        let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as usize);\n-\n-        let doc = reader::get_doc(rp_doc, tag_region_param_def_index);\n-        let index = reader::doc_as_u64(doc) as u32;\n-\n-        let bounds = reader::tagged_docs(rp_doc, tag_items_data_region).map(|p| {\n+    for p in reader::tagged_docs(doc, tag_region_param_def) {\n+        let bd =\n             TyDecoder::with_doc(tcx, cdata.cnum, p,\n                                 &mut |did| translate_def_id(cdata, did))\n-            .parse_region()\n-        }).collect();\n-\n-        regions.push(space, ty::RegionParameterDef { name: name,\n-                                                     def_id: def_id,\n-                                                     space: space,\n-                                                     index: index,\n-                                                     bounds: bounds });\n+            .parse_region_param_def();\n+        regions.push(bd.space, bd);\n     }\n \n     ty::Generics { types: types, regions: regions }"}, {"sha": "b14be158197e8ab379e45bcbf679dfe59e1d6536", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -203,15 +203,6 @@ fn encode_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.end_tag();\n }\n \n-fn encode_region(ecx: &EncodeContext,\n-                 rbml_w: &mut Encoder,\n-                 r: ty::Region) {\n-    rbml_w.start_tag(tag_items_data_region);\n-    tyencode::enc_region(rbml_w.writer, &ecx.ty_str_ctxt(), r);\n-    rbml_w.mark_stable_position();\n-    rbml_w.end_tag();\n-}\n-\n fn encode_disr_val(_: &EncodeContext,\n                    rbml_w: &mut Encoder,\n                    disr_val: ty::Disr) {\n@@ -535,24 +526,8 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n     // Region parameters\n     for param in &generics.regions {\n         rbml_w.start_tag(tag_region_param_def);\n-\n-        rbml_w.start_tag(tag_region_param_def_ident);\n-        encode_name(rbml_w, param.name);\n-        rbml_w.end_tag();\n-\n-        rbml_w.wr_tagged_u64(tag_region_param_def_def_id,\n-                             def_to_u64(param.def_id));\n-\n-        rbml_w.wr_tagged_u64(tag_region_param_def_space,\n-                             param.space.to_uint() as u64);\n-\n-        rbml_w.wr_tagged_u64(tag_region_param_def_index,\n-                             param.index as u64);\n-\n-        for &bound_region in &param.bounds {\n-            encode_region(ecx, rbml_w, bound_region);\n-        }\n-\n+        tyencode::enc_region_param_def(rbml_w.writer, &ecx.ty_str_ctxt(), param);\n+        rbml_w.mark_stable_position();\n         rbml_w.end_tag();\n     }\n "}, {"sha": "797af8964a14da196088b5a6acc0f8eff4cea786", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -158,8 +158,21 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             '[' => {\n                 let def = self.parse_def();\n-                let name = token::intern(&self.parse_str(']'));\n-                ty::BrNamed(def, name)\n+                let name = token::intern(&self.parse_str('|'));\n+                let issue32330 = match self.next() {\n+                    'n' => {\n+                        assert_eq!(self.next(), ']');\n+                        ty::Issue32330::WontChange\n+                    }\n+                    'y' => {\n+                        ty::Issue32330::WillChange {\n+                            fn_def_id: self.parse_def(),\n+                            region_name: token::intern(&self.parse_str(']')),\n+                        }\n+                    }\n+                    c => panic!(\"expected n or y not {}\", c)\n+                };\n+                ty::BrNamed(def, name, issue32330)\n             }\n             'f' => {\n                 let id = self.parse_u32();\n@@ -623,7 +636,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             def_id: def_id,\n             space: space,\n             index: index,\n-            bounds: bounds\n+            bounds: bounds,\n         }\n     }\n "}, {"sha": "87a2e50bb25e9b4e446778b56faef139f89844cd", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -308,10 +308,17 @@ fn enc_bound_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, br: ty::BoundRegion) {\n         ty::BrAnon(idx) => {\n             write!(w, \"a{}|\", idx);\n         }\n-        ty::BrNamed(d, name) => {\n-            write!(w, \"[{}|{}]\",\n-                     (cx.ds)(cx.tcx, d),\n-                     name);\n+        ty::BrNamed(d, name, issue32330) => {\n+            write!(w, \"[{}|{}|\",\n+                   (cx.ds)(cx.tcx, d),\n+                   name);\n+\n+            match issue32330 {\n+                ty::Issue32330::WontChange =>\n+                    write!(w, \"n]\"),\n+                ty::Issue32330::WillChange { fn_def_id, region_name } =>\n+                    write!(w, \"y{}|{}]\", (cx.ds)(cx.tcx, fn_def_id), region_name),\n+            };\n         }\n         ty::BrFresh(id) => {\n             write!(w, \"f{}|\", id);"}, {"sha": "1b13a662d369cc465c02b135d18daa1d05dfcc67", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -1061,7 +1061,7 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     let trait_ref = tcx.erase_regions(&trait_ref);\n \n     scx.trait_cache().memoize(trait_ref, || {\n-        debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n+        debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n                trait_ref, trait_ref.def_id());\n \n         // Do the initial selection for the obligation. This yields the\n@@ -1096,11 +1096,14 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 }\n             };\n \n+            debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n             // Currently, we use a fulfillment context to completely resolve\n             // all nested obligations. This is because they can inform the\n             // inference of the impl's type parameters.\n             let mut fulfill_cx = traits::FulfillmentContext::new();\n             let vtable = selection.map(|predicate| {\n+                debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n                 fulfill_cx.register_predicate_obligation(&infcx, predicate);\n             });\n             let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);"}, {"sha": "472d6ac67f4f19eca852f2d461e33a52a35143c1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -170,7 +170,7 @@ type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjection\n \n pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n                             -> ty::Region {\n-    let r = match tcx.named_region_map.get(&lifetime.id) {\n+    let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n         None => {\n             // should have been recorded by the `resolve_lifetime` pass\n             span_bug!(lifetime.span, \"unresolved lifetime\");\n@@ -181,7 +181,20 @@ pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n         }\n \n         Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n-            ty::ReLateBound(debruijn, ty::BrNamed(tcx.map.local_def_id(id), lifetime.name))\n+            // If this region is declared on a function, it will have\n+            // an entry in `late_bound`, but if it comes from\n+            // `for<'a>` in some type or something, it won't\n+            // necessarily have one. In that case though, we won't be\n+            // changed from late to early bound, so we can just\n+            // substitute false.\n+            let issue_32330 = tcx.named_region_map\n+                                 .late_bound\n+                                 .get(&id)\n+                                 .cloned()\n+                                 .unwrap_or(ty::Issue32330::WontChange);\n+            ty::ReLateBound(debruijn, ty::BrNamed(tcx.map.local_def_id(id),\n+                                                  lifetime.name,\n+                                                  issue_32330))\n         }\n \n         Some(&rl::DefEarlyBoundRegion(space, index, _)) => {\n@@ -193,11 +206,21 @@ pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n         }\n \n         Some(&rl::DefFreeRegion(scope, id)) => {\n+            // As in DefLateBoundRegion above, could be missing for some late-bound\n+            // regions, but also for early-bound regions.\n+            let issue_32330 = tcx.named_region_map\n+                                 .late_bound\n+                                 .get(&id)\n+                                 .cloned()\n+                                 .unwrap_or(ty::Issue32330::WontChange);\n             ty::ReFree(ty::FreeRegion {\n                     scope: scope.to_code_extent(&tcx.region_maps),\n                     bound_region: ty::BrNamed(tcx.map.local_def_id(id),\n-                                              lifetime.name)\n-                })\n+                                              lifetime.name,\n+                                              issue_32330)\n+            })\n+\n+                // (*) -- not late-bound, won't change\n         }\n     };\n \n@@ -911,7 +934,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n         for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n             let br_name = match *br {\n-                ty::BrNamed(_, name) => name,\n+                ty::BrNamed(_, name, _) => name,\n                 _ => {\n                     span_bug!(\n                         binding.span,\n@@ -1675,7 +1698,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n                 for br in late_bound_in_ret.difference(&late_bound_in_args) {\n                     let br_name = match *br {\n-                        ty::BrNamed(_, name) => name,\n+                        ty::BrNamed(_, name, _) => name,\n                         _ => {\n                             span_bug!(\n                                 bf.decl.output.span(),"}, {"sha": "e65f3f0ff413ff898fce31edf536569994498b11", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -64,7 +64,6 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n-use middle::resolve_lifetime;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n@@ -1745,14 +1744,16 @@ fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n /// the lifetimes that are declared. For fns or methods, we have to\n /// screen out those that do not appear in any where-clauses etc using\n /// `resolve_lifetime::early_bound_lifetimes`.\n-fn early_bound_lifetimes_from_generics(space: ParamSpace,\n-                                       ast_generics: &hir::Generics)\n-                                       -> Vec<hir::LifetimeDef>\n+fn early_bound_lifetimes_from_generics<'a, 'tcx, 'hir>(\n+    ccx: &CrateCtxt<'a, 'tcx>,\n+    ast_generics: &'hir hir::Generics)\n+    -> Vec<&'hir hir::LifetimeDef>\n {\n-    match space {\n-        SelfSpace | TypeSpace => ast_generics.lifetimes.to_vec(),\n-        FnSpace => resolve_lifetime::early_bound_lifetimes(ast_generics),\n-    }\n+    ast_generics\n+        .lifetimes\n+        .iter()\n+        .filter(|l| !ccx.tcx.named_region_map.late_bound.contains_key(&l.lifetime.id))\n+        .collect()\n }\n \n fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n@@ -1781,7 +1782,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     // Collect the region predicates that were declared inline as\n     // well. In the case of parameters declared on a fn or method, we\n     // have to be careful to only iterate over early-bound regions.\n-    let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n+    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n     for (index, param) in early_lifetimes.iter().enumerate() {\n         let index = index as u32;\n         let region =\n@@ -1864,7 +1865,7 @@ fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let tcx = ccx.tcx;\n     let mut result = base_generics.clone();\n \n-    let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n+    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n     for (i, l) in early_lifetimes.iter().enumerate() {\n         let bounds = l.bounds.iter()\n                              .map(|l| ast_region_to_region(tcx, l))"}, {"sha": "612007da0e97acf33992d1ffd36e59fd8904af2a", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.map, param_id));\n-        match tcx.named_region_map.get(&param_id) {\n+        match tcx.named_region_map.defs.get(&param_id) {\n             Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n                 => lifetime_decl_id,\n             Some(_) => bug!(\"should not encounter non early-bound cases\"),"}, {"sha": "0f3c62aca2a8595b51eba8be4f38b854ba3cbcce", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -819,7 +819,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n     fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n-            ty::ReLateBound(_, ty::BrNamed(_, name)) => Some(Lifetime(name.to_string())),\n+            ty::ReLateBound(_, ty::BrNamed(_, name, _)) => Some(Lifetime(name.to_string())),\n             ty::ReEarlyBound(ref data) => Some(Lifetime(data.name.clean(cx))),\n \n             ty::ReLateBound(..) |"}, {"sha": "871b0d4b1c023da205c3eb404c152ad87f7ddf57", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -422,7 +422,7 @@ pub fn expand_quote_expr<'cx>(cx: &'cx mut ExtCtxt,\n     base::MacEager::expr(expanded)\n }\n \n-pub fn expand_quote_item<'cx>(cx: &mut ExtCtxt,\n+pub fn expand_quote_item<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               tts: &[TokenTree])\n                               -> Box<base::MacResult+'cx> {"}, {"sha": "09c23682cd73f79afb8f46a045c6ae42314eaf34", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -17,7 +17,7 @@ use syntax::parse::token;\n use syntax::parse::token::str_to_ident;\n use syntax::ptr::P;\n \n-pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n+pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n                               -> Box<base::MacResult+'cx> {\n     if !cx.ecfg.enable_concat_idents() {\n         feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,"}, {"sha": "a753527ea53d55f341943aa9cedd98d90b4783de", "filename": "src/test/compile-fail/associated-types/cache/chrono-scan.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fchrono-scan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fchrono-scan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fchrono-scan.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+pub type ParseResult<T> = Result<T, ()>;\n+\n+pub enum Item<'a> {     Literal(&'a str),\n+ }\n+\n+pub fn colon_or_space(s: &str) -> ParseResult<&str> {\n+    unimplemented!()\n+}\n+\n+pub fn timezone_offset_zulu<F>(s: &str, colon: F) -> ParseResult<(&str, i32)>\n+        where F: FnMut(&str) -> ParseResult<&str> {\n+    unimplemented!()\n+}\n+\n+pub fn parse<'a, I>(mut s: &str, items: I) -> ParseResult<()>\n+        where I: Iterator<Item=Item<'a>> {\n+    macro_rules! try_consume {\n+        ($e:expr) => ({ let (s_, v) = try!($e); s = s_; v })\n+    }\n+    let offset = try_consume!(timezone_offset_zulu(s.trim_left(), colon_or_space));\n+    let offset = try_consume!(timezone_offset_zulu(s.trim_left(), colon_or_space));\n+    Ok(())\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "d1117328c8657b3213746f72714f027b46509037", "filename": "src/test/compile-fail/associated-types/cache/elision.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Felision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Felision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Felision.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+// Check that you are allowed to implement using elision but write\n+// trait without elision (a bug in this cropped up during\n+// bootstrapping, so this is a regression test).\n+\n+pub struct SplitWhitespace<'a> {\n+    x: &'a u8\n+}\n+\n+pub trait UnicodeStr {\n+    fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n+}\n+\n+impl UnicodeStr for str {\n+    #[inline]\n+    fn split_whitespace(&self) -> SplitWhitespace {\n+        unimplemented!()\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "c5557cee7cc1dce3d01d76fc8cf86418662fa93c", "filename": "src/test/compile-fail/associated-types/cache/project-fn-ret-contravariant.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+#![feature(rustc_attrs)]\n+\n+// Test for projection cache. We should be able to project distinct\n+// lifetimes from `foo` as we reinstantiate it multiple times, but not\n+// if we do it just once. In this variant, the region `'a` is used in\n+// an contravariant position, which affects the results.\n+\n+// revisions: ok oneuse transmute krisskross\n+\n+#![allow(dead_code, unused_variables)]\n+\n+fn foo<'a>() -> &'a u32 { loop { } }\n+\n+fn bar<T>(t: T, x: T::Output) -> T::Output\n+    where T: FnOnce<()>\n+{\n+    t()\n+}\n+\n+#[cfg(ok)] // two instantiations: OK\n+fn baz<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n+    let a = bar(foo, x);\n+    let b = bar(foo, y);\n+    (a, b)\n+}\n+\n+#[cfg(oneuse)] // one instantiation: OK (surprisingly)\n+fn baz<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n+    let f /* : fn() -> &'static u32 */ = foo; // <-- inferred type annotated\n+    let a = bar(f, x); // this is considered ok because fn args are contravariant...\n+    let b = bar(f, y); // ...and hence we infer T to distinct values in each call.\n+    (a, b)\n+}\n+\n+// FIXME(#32330)\n+//#[cfg(transmute)] // one instantiations: BAD\n+//fn baz<'a,'b>(x: &'a u32) -> &'static u32 {\n+//    bar(foo, x) //[transmute] ERROR E0495\n+//}\n+\n+// FIXME(#32330)\n+//#[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n+//fn transmute<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n+//    let a = bar(foo, y); //[krisskross] ERROR E0495\n+//    let b = bar(foo, x); //[krisskross] ERROR E0495\n+//    (a, b)\n+//}\n+\n+#[rustc_error]\n+fn main() { }\n+//[ok]~^ ERROR compilation successful\n+//[oneuse]~^^ ERROR compilation successful\n+//[transmute]~^^^ ERROR compilation successful\n+//[krisskross]~^^^^ ERROR compilation successful"}, {"sha": "a15422e42d94a339f617e675ff3aa590a65408f2", "filename": "src/test/compile-fail/associated-types/cache/project-fn-ret-invariant.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+#![feature(rustc_attrs)]\n+\n+// Test for projection cache. We should be able to project distinct\n+// lifetimes from `foo` as we reinstantiate it multiple times, but not\n+// if we do it just once. In this variant, the region `'a` is used in\n+// an invariant position, which affects the results.\n+\n+// revisions: ok oneuse transmute krisskross\n+\n+#![allow(dead_code, unused_variables)]\n+\n+use std::marker::PhantomData;\n+\n+struct Type<'a> {\n+    // Invariant\n+    data: PhantomData<fn(&'a u32) -> &'a u32>\n+}\n+\n+fn foo<'a>() -> Type<'a> { loop { } }\n+\n+fn bar<T>(t: T, x: T::Output) -> T::Output\n+    where T: FnOnce<()>\n+{\n+    t()\n+}\n+\n+#[cfg(ok)] // two instantiations: OK\n+fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+    let a = bar(foo, x);\n+    let b = bar(foo, y);\n+    (a, b)\n+}\n+\n+// FIXME(#32330)\n+//#[cfg(oneuse)] // one instantiation: BAD\n+//fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+//    let f = foo; // <-- No consistent type can be inferred for `f` here.\n+//    let a = bar(f, x); //[oneuse] ERROR E0495\n+//    let b = bar(f, y);\n+//    (a, b)\n+//}\n+\n+// FIXME(#32330)\n+//#[cfg(transmute)] // one instantiations: BAD\n+//fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {\n+//    // Cannot instantiate `foo` with any lifetime other than `'a`,\n+//    // since it is provided as input.\n+//\n+//    bar(foo, x) //[transmute] ERROR E0495\n+//}\n+\n+// FIXME(#32330)\n+//#[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n+//fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+//    let a = bar(foo, y); //[krisskross] ERROR E0495\n+//    let b = bar(foo, x); //[krisskross] ERROR E0495\n+//    (a, b)\n+//}\n+\n+#[rustc_error]\n+fn main() { }\n+//[ok]~^ ERROR compilation successful\n+//[oneuse]~^^ ERROR compilation successful\n+//[transmute]~^^^ ERROR compilation successful\n+//[krisskross]~^^^^ ERROR compilation successful"}, {"sha": "01db4770a38b2fd0501d723c202a8a6f6ea0d590", "filename": "src/test/compile-fail/associated-types/cache/wasm-issue-32330.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fwasm-issue-32330.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fwasm-issue-32330.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fwasm-issue-32330.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test was derived from the wasm and parsell crates.  They\n+// stopped compiling when #32330 is fixed.\n+\n+#![allow(dead_code, unused_variables)]\n+#![deny(hr_lifetime_in_assoc_type)]\n+#![feature(unboxed_closures)]\n+\n+use std::str::Chars;\n+\n+pub trait HasOutput<Ch, Str> {\n+    type Output;\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Ord, PartialOrd, Debug)]\n+pub enum Token<'a> {\n+    Begin(&'a str)\n+}\n+\n+fn mk_unexpected_char_err<'a>() -> Option<&'a i32> {\n+    unimplemented!()\n+}\n+\n+fn foo<'a>(data: &mut Chars<'a>) {\n+    bar(mk_unexpected_char_err)\n+    //~^ ERROR lifetime parameter `'a` declared on fn `mk_unexpected_char_err`\n+    //~| WARNING hard error in a future release\n+}\n+\n+fn bar<F>(t: F)\n+    // No type can satisfy this requirement, since `'a` does not\n+    // appear in any of the input types:\n+    where F: for<'a> Fn() -> Option<&'a i32>\n+    //~^ ERROR associated type `Output` references lifetime `'a`, which does not\n+    //~| WARNING hard error in a future release\n+{\n+}\n+\n+fn main() {\n+}"}, {"sha": "95e469ebcfd72fbbe163237579aead8b3952bd86", "filename": "src/test/compile-fail/hr-subtype.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Targeted tests for the higher-ranked subtyping code.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+// revisions: bound_a_vs_bound_a\n+// revisions: bound_a_vs_bound_b\n+// revisions: bound_inv_a_vs_bound_inv_b\n+// revisions: bound_co_a_vs_bound_co_b\n+// revisions: bound_a_vs_free_x\n+// revisions: free_x_vs_free_x\n+// revisions: free_x_vs_free_y\n+// revisions: free_inv_x_vs_free_inv_y\n+// revisions: bound_a_b_vs_bound_a\n+// revisions: bound_co_a_b_vs_bound_co_a\n+// revisions: bound_contra_a_contra_b_ret_co_a\n+// revisions: bound_co_a_co_b_ret_contra_a\n+// revisions: bound_inv_a_b_vs_bound_inv_a\n+// revisions: bound_a_b_ret_a_vs_bound_a_ret_a\n+\n+fn gimme<T>(_: Option<T>) { }\n+\n+struct Inv<'a> { x: *mut &'a u32 }\n+\n+struct Co<'a> { x: fn(&'a u32) }\n+\n+struct Contra<'a> { x: &'a u32 }\n+\n+macro_rules! check {\n+    ($rev:ident: ($t1:ty, $t2:ty)) => {\n+        #[cfg($rev)]\n+        fn subtype<'x,'y:'x,'z:'y>() {\n+            gimme::<$t2>(None::<$t1>);\n+            //[free_inv_x_vs_free_inv_y]~^ ERROR mismatched types\n+        }\n+\n+        #[cfg($rev)]\n+        fn supertype<'x,'y:'x,'z:'y>() {\n+            gimme::<$t1>(None::<$t2>);\n+            //[bound_a_vs_free_x]~^ ERROR mismatched types\n+            //[free_x_vs_free_y]~^^ ERROR mismatched types\n+            //[bound_inv_a_b_vs_bound_inv_a]~^^^ ERROR mismatched types\n+            //[bound_a_b_ret_a_vs_bound_a_ret_a]~^^^^ ERROR mismatched types\n+            //[free_inv_x_vs_free_inv_y]~^^^^^ ERROR mismatched types\n+            //[bound_a_b_vs_bound_a]~^^^^^^ ERROR mismatched types\n+            //[bound_co_a_b_vs_bound_co_a]~^^^^^^^ ERROR mismatched types\n+            //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^ ERROR mismatched types\n+            //[bound_co_a_co_b_ret_contra_a]~^^^^^^^^^ ERROR mismatched types\n+        }\n+    }\n+}\n+\n+// If both have bound regions, they are equivalent, regardless of\n+// variant.\n+check! { bound_a_vs_bound_a: (for<'a> fn(&'a u32),\n+                              for<'a> fn(&'a u32)) }\n+check! { bound_a_vs_bound_b: (for<'a> fn(&'a u32),\n+                              for<'b> fn(&'b u32)) }\n+check! { bound_inv_a_vs_bound_inv_b: (for<'a> fn(Inv<'a>),\n+                                      for<'b> fn(Inv<'b>)) }\n+check! { bound_co_a_vs_bound_co_b: (for<'a> fn(Co<'a>),\n+                                    for<'b> fn(Co<'b>)) }\n+\n+// Bound is a subtype of free.\n+check! { bound_a_vs_free_x: (for<'a> fn(&'a u32),\n+                             fn(&'x u32)) }\n+\n+// Two free regions are relatable if subtyping holds.\n+check! { free_x_vs_free_x: (fn(&'x u32),\n+                            fn(&'x u32)) }\n+check! { free_x_vs_free_y: (fn(&'x u32),\n+                            fn(&'y u32)) }\n+check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n+                                    fn(Inv<'y>)) }\n+\n+// Somewhat surprisingly, a fn taking two distinct bound lifetimes and\n+// a fn taking one bound lifetime can be interchangable, but only if\n+// we are co- or contra-variant with respect to both lifetimes.\n+//\n+// The reason is:\n+// - if we are covariant, then 'a and 'b can be set to the call-site\n+//   intersection;\n+// - if we are contravariant, then 'a can be inferred to 'static.\n+//\n+// FIXME(#32330) this is true, but we are not currently impl'ing this\n+// full semantics\n+check! { bound_a_b_vs_bound_a: (for<'a,'b> fn(&'a u32, &'b u32),\n+                                for<'a>    fn(&'a u32, &'a u32)) }\n+check! { bound_co_a_b_vs_bound_co_a: (for<'a,'b> fn(Co<'a>, Co<'b>),\n+                                      for<'a>    fn(Co<'a>, Co<'a>)) }\n+check! { bound_contra_a_contra_b_ret_co_a: (for<'a,'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>,\n+                                            for<'a>    fn(Contra<'a>, Contra<'a>) -> Co<'a>) }\n+check! { bound_co_a_co_b_ret_contra_a: (for<'a,'b> fn(Co<'a>, Co<'b>) -> Contra<'a>,\n+                                        for<'a>    fn(Co<'a>, Co<'a>) -> Contra<'a>) }\n+\n+// If we make those lifetimes invariant, then the two types are not interchangable.\n+check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n+                                        for<'a>    fn(Inv<'a>, Inv<'a>)) }\n+check! { bound_a_b_ret_a_vs_bound_a_ret_a: (for<'a,'b> fn(&'a u32, &'b u32) -> &'a u32,\n+                                            for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n+\n+#[rustc_error]\n+fn main() {\n+//[bound_a_vs_bound_a]~^ ERROR compilation successful\n+//[bound_a_vs_bound_b]~^^ ERROR compilation successful\n+//[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n+//[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n+//[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n+}"}, {"sha": "ceac7e968f65c1bceaa43574b75712d3ccd8e7ec", "filename": "src/test/compile-fail/issue-16048.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fissue-16048.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fissue-16048.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16048.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -28,7 +28,7 @@ impl<'a> Test<'a> for Foo<'a> {\n \n impl<'a> NoLifetime for Foo<'a> {\n     fn get<'p, T : Test<'a>>(&self) -> T {\n-//~^ ERROR lifetime parameters or bounds on method `get` do not match the trait declaration\n+//~^ ERROR E0195\n         return *self as T;\n     }\n }"}, {"sha": "dac1625159748d81fcb72e92062ee1b505b9107f", "filename": "src/test/compile-fail/issue-20831-debruijn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -39,7 +39,6 @@ impl<'a> Publisher<'a> for MyStruct<'a> {\n         // Not obvious, but there is an implicit lifetime here -------^\n         //~^^ ERROR cannot infer\n         //~|  ERROR cannot infer\n-        //~|  ERROR cannot infer\n         //\n         // The fact that `Publisher` is using an implicit lifetime is\n         // what was causing the debruijn accounting to be off, so"}, {"sha": "6b22d434804ffecafc2b56e71c8140e1ae6e5428", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -14,7 +14,7 @@ use std::marker::PhantomData;\n \n struct Bar<'x, 'y, 'z> { bar: &'y i32, baz: i32, marker: PhantomData<(&'x(),&'y(),&'z())> }\n fn bar1<'a>(x: &Bar) -> (&'a i32, &'a i32, &'a i32) {\n-    //~^ HELP: consider using an explicit lifetime parameter as shown: fn bar1<'a>(x: &'a Bar) -> (&'a i32, &'a i32, &'a i32)\n+    //~^ HELP consider using an explicit lifetime parameter as shown: fn bar1<'b, 'c, 'a>(x: &'a Bar<'b, 'a, 'c>) -> (&'a i32, &'a i32, &'a i32)\n     (x.bar, &x.baz, &x.baz)\n     //~^ ERROR E0312\n     //~| ERROR cannot infer"}, {"sha": "e34a3c4569d0a4c451d053ff13837bd0e9c7abad", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -49,7 +49,7 @@ struct Baz<'x> {\n \n impl<'a> Baz<'a> {\n     fn baz2<'b>(&self, x: &isize) -> (&'b isize, &'b isize) {\n-        //~^ HELP consider using an explicit lifetime parameter as shown: fn baz2<'b>(&self, x: &'b isize) -> (&'a isize, &'a isize)\n+        //~^ HELP consider using an explicit lifetime parameter as shown: fn baz2<'b>(&self, x: &'a isize) -> (&'a isize, &'a isize)\n         (self.bar, x) //~ ERROR E0312\n         //~^ ERROR E0312\n     }"}, {"sha": "b70ec59420db1f7cf0347ccd993194285521b1e7", "filename": "src/test/compile-fail/regions-close-over-type-parameter-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -19,7 +19,7 @@ trait SomeTrait { fn get(&self) -> isize; }\n fn make_object1<A:SomeTrait>(v: A) -> Box<SomeTrait+'static> {\n     box v as Box<SomeTrait+'static>\n         //~^ ERROR the parameter type `A` may not live long enough\n-        //~^^ ERROR the parameter type `A` may not live long enough\n+        //~| ERROR the parameter type `A` may not live long enough\n }\n \n fn make_object2<'a,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'a> {\n@@ -29,7 +29,7 @@ fn make_object2<'a,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'a> {\n fn make_object3<'a,'b,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'b> {\n     box v as Box<SomeTrait+'b>\n         //~^ ERROR the parameter type `A` may not live long enough\n-        //~^^ ERROR the parameter type `A` may not live long enough\n+        //~| ERROR the parameter type `A` may not live long enough\n }\n \n fn main() { }"}, {"sha": "eaf9a750570dbdb8966c100fe112068a9f02827c", "filename": "src/test/compile-fail/regions-early-bound-error-method.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -28,11 +28,7 @@ impl<'a> GetRef<'a> for Box<'a> {\n impl<'a> Box<'a> {\n     fn or<'b,G:GetRef<'b>>(&self, g2: G) -> &'a isize {\n         g2.get()\n-        //~^ ERROR mismatched types\n-        //~| expected type `&'a isize`\n-        //~| found type `&'b isize`\n-        //~| lifetime mismatch\n-\n+        //~^ ERROR E0312\n     }\n }\n "}, {"sha": "90a3395004776a2310e0164af183973d322ab323", "filename": "src/test/compile-fail/regions-early-bound-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -27,7 +27,7 @@ impl<'a,T:Clone> GetRef<'a,T> for Box<'a,T> {\n \n fn get<'a,'b,G:GetRef<'a, isize>>(g1: G, b: &'b isize) -> &'b isize {\n     g1.get()\n-    //~^ ERROR mismatched types\n+    //~^ ERROR E0312\n }\n \n fn main() {"}, {"sha": "87b5efbfadd865c5e1afa30690f1106f65b460b0", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -10,7 +10,7 @@\n \n \n struct Invariant<'a> {\n-    f: Box<for<'b> FnOnce() -> &'b mut &'a isize + 'static>,\n+    f: Box<FnOnce() -> *mut &'a isize + 'static>,\n }\n \n fn to_same_lifetime<'r>(b_isize: Invariant<'r>) {"}, {"sha": "eb04514271c7532891401dcbaf8e7e82f9307aa3", "filename": "src/test/run-pass/coherence-subtyping.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Frun-pass%2Fcoherence-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Frun-pass%2Fcoherence-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-subtyping.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -15,10 +15,10 @@ trait Contravariant {\n     fn foo(&self) { }\n }\n \n-impl Contravariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+impl Contravariant for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n }\n \n-impl Contravariant for for<'a> fn(&'a u8, &'a u8) {\n+impl Contravariant for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -27,10 +27,10 @@ trait Covariant {\n     fn foo(&self) { }\n }\n \n-impl Covariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+impl Covariant for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n }\n \n-impl Covariant for for<'a> fn(&'a u8, &'a u8) {\n+impl Covariant for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -39,10 +39,10 @@ trait Invariant {\n     fn foo(&self) { }\n }\n \n-impl Invariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+impl Invariant for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n }\n \n-impl Invariant for for<'a> fn(&'a u8, &'a u8) {\n+impl Invariant for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n }\n \n fn main() { }"}, {"sha": "2f8ecbe693f0752263d959df10d476b3db94554b", "filename": "src/test/run-pass/dropck_legal_cycles.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -458,7 +458,7 @@ struct S<'a> {\n }\n \n impl<'a> Named for S<'a> {\n-    fn new<'b>(name: &'static str) -> S<'b> {\n+    fn new(name: &'static str) -> S<'a> {\n         S { name: name, mark: Cell::new(0), next: Cell::new(None) }\n     }\n     fn name(&self) -> &str { self.name }\n@@ -476,7 +476,7 @@ struct S2<'a> {\n }\n \n impl<'a> Named for S2<'a> {\n-    fn new<'b>(name: &'static str) -> S2<'b> {\n+    fn new(name: &'static str) -> S2<'a> {\n         S2 { name: name, mark: Cell::new(0), next: Cell::new((None, None)) }\n     }\n     fn name(&self) -> &str { self.name }\n@@ -496,7 +496,7 @@ struct V<'a> {\n }\n \n impl<'a> Named for V<'a> {\n-    fn new<'b>(name: &'static str) -> V<'b> {\n+    fn new(name: &'static str) -> V<'a> {\n         V { name: name,\n             mark: Cell::new(0),\n             contents: vec![Cell::new(None), Cell::new(None)]\n@@ -518,7 +518,7 @@ struct H<'a> {\n }\n \n impl<'a> Named for H<'a> {\n-    fn new<'b>(name: &'static str) -> H<'b> {\n+    fn new(name: &'static str) -> H<'a> {\n         H { name: name, mark: Cell::new(0), next: Cell::new(None) }\n     }\n     fn name(&self) -> &str { self.name }\n@@ -549,7 +549,7 @@ struct HM<'a> {\n }\n \n impl<'a> Named for HM<'a> {\n-    fn new<'b>(name: &'static str) -> HM<'b> {\n+    fn new(name: &'static str) -> HM<'a> {\n         HM { name: name,\n              mark: Cell::new(0),\n              contents: Cell::new(None)\n@@ -583,7 +583,7 @@ struct VD<'a> {\n }\n \n impl<'a> Named for VD<'a> {\n-    fn new<'b>(name: &'static str) -> VD<'b> {\n+    fn new(name: &'static str) -> VD<'a> {\n         VD { name: name,\n              mark: Cell::new(0),\n              contents: Cell::new(None)\n@@ -604,7 +604,7 @@ struct VM<'a> {\n }\n \n impl<'a> Named for VM<'a> {\n-    fn new<'b>(name: &'static str) -> VM<'b> {\n+    fn new(name: &'static str) -> VM<'a> {\n         VM { name: name,\n              mark: Cell::new(0),\n              contents: Cell::new(None)\n@@ -625,7 +625,7 @@ struct LL<'a> {\n }\n \n impl<'a> Named for LL<'a> {\n-    fn new<'b>(name: &'static str) -> LL<'b> {\n+    fn new(name: &'static str) -> LL<'a> {\n         LL { name: name,\n              mark: Cell::new(0),\n              contents: Cell::new(None)\n@@ -646,7 +646,7 @@ struct BH<'a> {\n }\n \n impl<'a> Named for BH<'a> {\n-    fn new<'b>(name: &'static str) -> BH<'b> {\n+    fn new(name: &'static str) -> BH<'a> {\n         BH { name: name,\n              mark: Cell::new(0),\n              contents: Cell::new(None)\n@@ -687,7 +687,7 @@ struct BTM<'a> {\n }\n \n impl<'a> Named for BTM<'a> {\n-    fn new<'b>(name: &'static str) -> BTM<'b> {\n+    fn new(name: &'static str) -> BTM<'a> {\n         BTM { name: name,\n              mark: Cell::new(0),\n              contents: Cell::new(None)\n@@ -728,7 +728,7 @@ struct BTS<'a> {\n }\n \n impl<'a> Named for BTS<'a> {\n-    fn new<'b>(name: &'static str) -> BTS<'b> {\n+    fn new(name: &'static str) -> BTS<'a> {\n         BTS { name: name,\n              mark: Cell::new(0),\n              contents: Cell::new(None)"}, {"sha": "d03424b2b2b7afa28f23f0e79803faf3c9e002c3", "filename": "src/test/run-pass/project-cache-issue-31849.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Frun-pass%2Fproject-cache-issue-31849.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12238b984abfacb2cccea176f862c94aa1231fb5/src%2Ftest%2Frun-pass%2Fproject-cache-issue-31849.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fproject-cache-issue-31849.rs?ref=12238b984abfacb2cccea176f862c94aa1231fb5", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #31849: the problem here was actually a performance\n+// cliff, but I'm adding the test for reference.\n+\n+pub trait Upcast<T> {\n+    fn upcast(self) -> T;\n+}\n+\n+impl<S1, S2, T1, T2> Upcast<(T1, T2)> for (S1,S2)\n+    where S1: Upcast<T1>,\n+          S2: Upcast<T2>,\n+{\n+    fn upcast(self) -> (T1, T2) { (self.0.upcast(), self.1.upcast()) }\n+}\n+\n+impl Upcast<()> for ()\n+{\n+    fn upcast(self) -> () { () }\n+}\n+\n+pub trait ToStatic {\n+    type Static: 'static;\n+    fn to_static(self) -> Self::Static where Self: Sized;\n+}\n+\n+impl<T, U> ToStatic for (T, U)\n+    where T: ToStatic,\n+          U: ToStatic\n+{\n+    type Static = (T::Static, U::Static);\n+    fn to_static(self) -> Self::Static { (self.0.to_static(), self.1.to_static()) }\n+}\n+\n+impl ToStatic for ()\n+{\n+    type Static = ();\n+    fn to_static(self) -> () { () }\n+}\n+\n+\n+trait Factory {\n+    type Output;\n+    fn build(&self) -> Self::Output;\n+}\n+\n+impl<S,T> Factory for (S, T)\n+    where S: Factory,\n+          T: Factory,\n+          S::Output: ToStatic,\n+          <S::Output as ToStatic>::Static: Upcast<S::Output>,\n+{\n+    type Output = (S::Output, T::Output);\n+    fn build(&self) -> Self::Output { (self.0.build().to_static().upcast(), self.1.build()) }\n+}\n+\n+impl Factory for () {\n+    type Output = ();\n+    fn build(&self) -> Self::Output { () }\n+}\n+\n+fn main() {\n+    // More parens, more time.\n+    let it = ((((((((((),()),()),()),()),()),()),()),()),());\n+    it.build();\n+}\n+"}]}