{"sha": "9d244129296a1805f890640016719afcee66a320", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMjQ0MTI5Mjk2YTE4MDVmODkwNjQwMDE2NzE5YWZjZWU2NmEzMjA=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-15T17:16:14Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T14:53:14Z"}, "message": "Move collector", "tree": {"sha": "f2c36f261aa27a236b14bd0862cb87cd2e1d2f37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2c36f261aa27a236b14bd0862cb87cd2e1d2f37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d244129296a1805f890640016719afcee66a320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d244129296a1805f890640016719afcee66a320", "html_url": "https://github.com/rust-lang/rust/commit/9d244129296a1805f890640016719afcee66a320", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d244129296a1805f890640016719afcee66a320/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9417bcf49f531e0382afd405b9163f791f91c85", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9417bcf49f531e0382afd405b9163f791f91c85", "html_url": "https://github.com/rust-lang/rust/commit/f9417bcf49f531e0382afd405b9163f791f91c85"}], "stats": {"total": 301, "additions": 193, "deletions": 108}, "files": [{"sha": "b899a5fb357a37e3a13363a5e2743e661657fe4d", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 193, "deletions": 108, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/9d244129296a1805f890640016719afcee66a320/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d244129296a1805f890640016719afcee66a320/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=9d244129296a1805f890640016719afcee66a320", "patch": "@@ -4,6 +4,7 @@\n //! resolves imports and expands macros.\n \n use hir_expand::{\n+    ast_id_map::FileAstId,\n     builtin_derive::find_builtin_derive,\n     builtin_macro::find_builtin_macro,\n     name::{name, AsName, Name},\n@@ -19,14 +20,14 @@ use test_utils::mark;\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    item_tree::{Import, ItemTree, Mod, ModItem},\n+    item_tree::{Import, ItemTree, MacroCall, Mod, ModItem, ModKind, StructDefKind},\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n         BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n     },\n     path::{ImportAlias, ModPath, PathKind},\n     per_ns::PerNs,\n-    visibility::Visibility,\n+    visibility::{RawVisibility, Visibility},\n     AdtId, AsMacroCall, AstId, AstIdWithPath, ConstLoc, ContainerId, EnumLoc, EnumVariantId,\n     FunctionLoc, ImplLoc, Intern, LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc,\n     TraitLoc, TypeAliasLoc, UnionLoc,\n@@ -125,6 +126,13 @@ struct DeriveDirective {\n     ast_id: AstIdWithPath<ast::ModuleItem>,\n }\n \n+struct DefData<'a> {\n+    id: ModuleDefId,\n+    name: &'a Name,\n+    visibility: &'a RawVisibility,\n+    has_constructor: bool,\n+}\n+\n /// Walks the tree of module recursively\n struct DefCollector<'a> {\n     db: &'a dyn DefDatabase,\n@@ -693,35 +701,36 @@ impl ModCollector<'_, '_> {\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n         for item in items {\n-            if self.is_cfg_enabled(&item.attrs) {\n-                if let raw::RawItemKind::Import(import_id) = item.kind {\n-                    let import = self.item_tree[import_id].clone();\n+            if self.is_cfg_enabled(self.item_tree.attrs(*item)) {\n+                if let ModItem::Import(import_id) = item {\n+                    let import = self.item_tree[*import_id].clone();\n                     if import.is_extern_crate && import.is_macro_use {\n                         self.def_collector.import_macros_from_extern_crate(self.module_id, &import);\n                     }\n                 }\n             }\n         }\n \n-        for item in items {\n-            if self.is_cfg_enabled(&item.attrs) {\n-                match item.kind {\n-                    raw::RawItemKind::Module(m) => {\n-                        self.collect_module(&self.item_tree[m], &item.attrs)\n-                    }\n-                    raw::RawItemKind::Import(import_id) => {\n+        for &item in items {\n+            let attrs = self.item_tree.attrs(item);\n+            if self.is_cfg_enabled(attrs) {\n+                let module =\n+                    ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n+                let container = ContainerId::ModuleId(module);\n+\n+                let mut def = None;\n+                match item {\n+                    ModItem::Mod(m) => self.collect_module(&self.item_tree[m], attrs),\n+                    ModItem::Import(import_id) => {\n                         self.def_collector.unresolved_imports.push(ImportDirective {\n                             module_id: self.module_id,\n                             import_id,\n                             import: self.item_tree[import_id].clone(),\n                             status: PartialResolvedImport::Unresolved,\n                         })\n                     }\n-                    raw::RawItemKind::Def(def) => {\n-                        self.define_def(&self.item_tree[def], &item.attrs)\n-                    }\n-                    raw::RawItemKind::Macro(mac) => self.collect_macro(&self.item_tree[mac]),\n-                    raw::RawItemKind::Impl(imp) => {\n+                    ModItem::MacroCall(mac) => self.collect_macro(&self.item_tree[mac]),\n+                    ModItem::Impl(imp) => {\n                         let module = ModuleId {\n                             krate: self.def_collector.def_map.krate,\n                             local_id: self.module_id,\n@@ -735,6 +744,147 @@ impl ModCollector<'_, '_> {\n                             .scope\n                             .define_impl(impl_id)\n                     }\n+                    ModItem::Function(it) => {\n+                        let it = &self.item_tree[it];\n+                        def = Some(DefData {\n+                            id: FunctionLoc {\n+                                container: container.into(),\n+                                ast_id: AstId::new(self.file_id, it.ast_id),\n+                            }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                            name: &it.name,\n+                            visibility: &it.visibility,\n+                            has_constructor: false,\n+                        });\n+                    }\n+                    ModItem::Struct(it) => {\n+                        let it = &self.item_tree[it];\n+\n+                        // FIXME: check attrs to see if this is an attribute macro invocation;\n+                        // in which case we don't add the invocation, just a single attribute\n+                        // macro invocation\n+                        self.collect_derives(attrs, it.ast_id.upcast());\n+\n+                        def = Some(DefData {\n+                            id: StructLoc {\n+                                container,\n+                                ast_id: AstId::new(self.file_id, it.ast_id),\n+                            }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                            name: &it.name,\n+                            visibility: &it.visibility,\n+                            has_constructor: it.kind != StructDefKind::Record,\n+                        });\n+                    }\n+                    ModItem::Union(it) => {\n+                        let it = &self.item_tree[it];\n+\n+                        // FIXME: check attrs to see if this is an attribute macro invocation;\n+                        // in which case we don't add the invocation, just a single attribute\n+                        // macro invocation\n+                        self.collect_derives(attrs, it.ast_id.upcast());\n+\n+                        def = Some(DefData {\n+                            id: UnionLoc { container, ast_id: AstId::new(self.file_id, it.ast_id) }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n+                            name: &it.name,\n+                            visibility: &it.visibility,\n+                            has_constructor: false,\n+                        });\n+                    }\n+                    ModItem::Enum(it) => {\n+                        let it = &self.item_tree[it];\n+\n+                        // FIXME: check attrs to see if this is an attribute macro invocation;\n+                        // in which case we don't add the invocation, just a single attribute\n+                        // macro invocation\n+                        self.collect_derives(attrs, it.ast_id.upcast());\n+\n+                        def = Some(DefData {\n+                            id: EnumLoc { container, ast_id: AstId::new(self.file_id, it.ast_id) }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n+                            name: &it.name,\n+                            visibility: &it.visibility,\n+                            has_constructor: false,\n+                        });\n+                    }\n+                    ModItem::Const(it) => {\n+                        let it = &self.item_tree[it];\n+\n+                        if let Some(name) = &it.name {\n+                            def = Some(DefData {\n+                                id: ConstLoc {\n+                                    container: container.into(),\n+                                    ast_id: AstId::new(self.file_id, it.ast_id),\n+                                }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n+                                name,\n+                                visibility: &it.visibility,\n+                                has_constructor: false,\n+                            });\n+                        }\n+                    }\n+                    ModItem::Static(it) => {\n+                        let it = &self.item_tree[it];\n+\n+                        def = Some(DefData {\n+                            id: StaticLoc {\n+                                container,\n+                                ast_id: AstId::new(self.file_id, it.ast_id),\n+                            }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                            name: &it.name,\n+                            visibility: &it.visibility,\n+                            has_constructor: false,\n+                        });\n+                    }\n+                    ModItem::Trait(it) => {\n+                        let it = &self.item_tree[it];\n+\n+                        def = Some(DefData {\n+                            id: TraitLoc { container, ast_id: AstId::new(self.file_id, it.ast_id) }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n+                            name: &it.name,\n+                            visibility: &it.visibility,\n+                            has_constructor: false,\n+                        });\n+                    }\n+                    ModItem::TypeAlias(it) => {\n+                        let it = &self.item_tree[it];\n+\n+                        def = Some(DefData {\n+                            id: TypeAliasLoc {\n+                                container: container.into(),\n+                                ast_id: AstId::new(self.file_id, it.ast_id),\n+                            }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                            name: &it.name,\n+                            visibility: &it.visibility,\n+                            has_constructor: false,\n+                        });\n+                    }\n+                }\n+\n+                if let Some(DefData { id, name, visibility, has_constructor }) = def {\n+                    self.def_collector.def_map.modules[self.module_id].scope.define_def(id);\n+                    let vis = self\n+                        .def_collector\n+                        .def_map\n+                        .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n+                        .unwrap_or(Visibility::Public);\n+                    self.def_collector.update(\n+                        self.module_id,\n+                        &[(name.clone(), PerNs::from_def(id, vis, has_constructor))],\n+                        vis,\n+                    )\n                 }\n             }\n         }\n@@ -743,14 +893,14 @@ impl ModCollector<'_, '_> {\n     fn collect_module(&mut self, module: &Mod, attrs: &Attrs) {\n         let path_attr = attrs.by_key(\"path\").string_value();\n         let is_macro_use = attrs.by_key(\"macro_use\").exists();\n-        match module {\n+        match &module.kind {\n             // inline module, just recurse\n-            raw::ModuleData::Definition { name, visibility, items, ast_id } => {\n+            ModKind::Inline { items } => {\n                 let module_id = self.push_child_module(\n-                    name.clone(),\n-                    AstId::new(self.file_id, *ast_id),\n+                    module.name.clone(),\n+                    AstId::new(self.file_id, module.ast_id),\n                     None,\n-                    &visibility,\n+                    &module.visibility,\n                 );\n \n                 ModCollector {\n@@ -759,39 +909,39 @@ impl ModCollector<'_, '_> {\n                     module_id,\n                     file_id: self.file_id,\n                     item_tree: self.item_tree,\n-                    mod_dir: self.mod_dir.descend_into_definition(name, path_attr),\n+                    mod_dir: self.mod_dir.descend_into_definition(&module.name, path_attr),\n                 }\n                 .collect(&*items);\n                 if is_macro_use {\n                     self.import_all_legacy_macros(module_id);\n                 }\n             }\n             // out of line module, resolve, parse and recurse\n-            raw::ModuleData::Declaration { name, visibility, ast_id } => {\n-                let ast_id = AstId::new(self.file_id, *ast_id);\n+            ModKind::Outline {} => {\n+                let ast_id = AstId::new(self.file_id, module.ast_id);\n                 match self.mod_dir.resolve_declaration(\n                     self.def_collector.db,\n                     self.file_id,\n-                    name,\n+                    &module.name,\n                     path_attr,\n                 ) {\n                     Ok((file_id, is_mod_rs, mod_dir)) => {\n                         let module_id = self.push_child_module(\n-                            name.clone(),\n+                            module.name.clone(),\n                             ast_id,\n                             Some((file_id, is_mod_rs)),\n-                            &visibility,\n+                            &module.visibility,\n                         );\n-                        let raw_items = self.def_collector.db.raw_items(file_id.into());\n+                        let item_tree = self.def_collector.db.item_tree(file_id.into());\n                         ModCollector {\n                             def_collector: &mut *self.def_collector,\n                             macro_depth: self.macro_depth,\n                             module_id,\n                             file_id: file_id.into(),\n-                            item_tree: &raw_items,\n+                            item_tree: &item_tree,\n                             mod_dir,\n                         }\n-                        .collect(raw_items.items());\n+                        .collect(item_tree.top_level_items());\n                         if is_macro_use {\n                             self.import_all_legacy_macros(module_id);\n                         }\n@@ -840,77 +990,7 @@ impl ModCollector<'_, '_> {\n         res\n     }\n \n-    fn define_def(&mut self, def: &raw::DefData, attrs: &Attrs) {\n-        let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n-        // FIXME: check attrs to see if this is an attribute macro invocation;\n-        // in which case we don't add the invocation, just a single attribute\n-        // macro invocation\n-        self.collect_derives(attrs, def);\n-\n-        let name = def.name.clone();\n-        let container = ContainerId::ModuleId(module);\n-        let vis = &def.visibility;\n-        let mut has_constructor = false;\n-\n-        let def: ModuleDefId = match def.kind {\n-            raw::DefKind::Function(ast_id) => FunctionLoc {\n-                container: container.into(),\n-                ast_id: AstId::new(self.file_id, ast_id),\n-            }\n-            .intern(self.def_collector.db)\n-            .into(),\n-            raw::DefKind::Struct(ast_id, mode) => {\n-                has_constructor = mode != raw::StructDefKind::Record;\n-                StructLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::Union(ast_id) => {\n-                UnionLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::Enum(ast_id) => {\n-                EnumLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::Const(ast_id) => {\n-                ConstLoc { container: container.into(), ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::Static(ast_id) => {\n-                StaticLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::Trait(ast_id) => {\n-                TraitLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::TypeAlias(ast_id) => TypeAliasLoc {\n-                container: container.into(),\n-                ast_id: AstId::new(self.file_id, ast_id),\n-            }\n-            .intern(self.def_collector.db)\n-            .into(),\n-        };\n-        self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        let vis = self\n-            .def_collector\n-            .def_map\n-            .resolve_visibility(self.def_collector.db, self.module_id, vis)\n-            .unwrap_or(Visibility::Public);\n-        self.def_collector.update(\n-            self.module_id,\n-            &[(name, PerNs::from_def(def, vis, has_constructor))],\n-            vis,\n-        )\n-    }\n-\n-    fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {\n+    fn collect_derives(&mut self, attrs: &Attrs, ast_id: FileAstId<ast::ModuleItem>) {\n         for derive_subtree in attrs.by_key(\"derive\").tt_values() {\n             // for #[derive(Copy, Clone)], `derive_subtree` is the `(Copy, Clone)` subtree\n             for tt in &derive_subtree.token_trees {\n@@ -921,27 +1001,27 @@ impl ModCollector<'_, '_> {\n                 };\n                 let path = ModPath::from_tt_ident(ident);\n \n-                let ast_id = AstIdWithPath::new(self.file_id, def.kind.ast_id(), path);\n+                let ast_id = AstIdWithPath::new(self.file_id, ast_id, path);\n                 self.def_collector\n                     .unexpanded_attribute_macros\n                     .push(DeriveDirective { module_id: self.module_id, ast_id });\n             }\n         }\n     }\n \n-    fn collect_macro(&mut self, mac: &raw::MacroData) {\n+    fn collect_macro(&mut self, mac: &MacroCall) {\n         let mut ast_id = AstIdWithPath::new(self.file_id, mac.ast_id, mac.path.clone());\n \n         // Case 0: builtin macros\n-        if mac.builtin {\n+        if mac.is_builtin {\n             if let Some(name) = &mac.name {\n                 let krate = self.def_collector.def_map.krate;\n                 if let Some(macro_id) = find_builtin_macro(name, krate, ast_id.ast_id) {\n                     self.def_collector.define_macro(\n                         self.module_id,\n                         name.clone(),\n                         macro_id,\n-                        mac.export,\n+                        mac.is_export,\n                     );\n                     return;\n                 }\n@@ -955,9 +1035,14 @@ impl ModCollector<'_, '_> {\n                     ast_id: Some(ast_id.ast_id),\n                     krate: Some(self.def_collector.def_map.krate),\n                     kind: MacroDefKind::Declarative,\n-                    local_inner: mac.local_inner,\n+                    local_inner: mac.is_local_inner,\n                 };\n-                self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export);\n+                self.def_collector.define_macro(\n+                    self.module_id,\n+                    name.clone(),\n+                    macro_id,\n+                    mac.is_export,\n+                );\n             }\n             return;\n         }"}]}