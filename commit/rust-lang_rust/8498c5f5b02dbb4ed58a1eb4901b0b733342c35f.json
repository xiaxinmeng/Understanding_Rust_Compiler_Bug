{"sha": "8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0OThjNWY1YjAyZGJiNGVkNThhMWViNDkwMWIwYjczMzM0MmMzNWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-07T23:08:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-07T23:08:52Z"}, "message": "Auto merge of #65232 - nikomatsakis:lazy-norm-anon-const-push-2, r=matthewjasper\n\nreplace the leak check with universes, take 2\n\nThis PR is an attempt to revive the \"universe-based region check\", which is an important step towards lazy normalization. Unlike before, we also modify the definition of `'empty` so that it is indexed by a universe. This sidesteps some of the surprising effects we saw before -- at the core, we no longer think that `exists<'a> { forall<'b> { 'b: 'a } }` is solveable. The new region lattice looks like this:\n\n```\nstatic ----------+-----...------+       (greatest)\n|                |              |\nearly-bound and  |              |\nfree regions     |              |\n|                |              |\nscope regions    |              |\n|                |              |\nempty(root)   placeholder(U1)   |\n|            /                  |\n|           /         placeholder(Un)\nempty(U1) --         /\n|                   /\n...                /\n|                 /\nempty(Un) --------                      (smallest)\n```\nThis PR has three effects:\n\n* It changes a fair number of error messages, I think for the better.\n* It fixes a number of bugs. The old algorithm was too conservative and caused us to reject legal subtypings.\n* It also causes two regressions (things that used to compile, but now do not).\n    * `coherence-subtyping.rs` gets an additional error. This is expected.\n    * `issue-57639.rs` regresses as before, for the reasons covered in #57639.\n\nBoth of the regressions stem from the same underlying property: without the leak check, the instantaneous \"subtype\" check is not able to tell whether higher-ranked subtyping will succeed or not. In both cases, we might be able to fix the problem by doing a 'leak-check like change' at some later point (e.g., as part of coherence).\n\nThis is a draft PR because:\n\n* I didn't finish ripping out the leak-check completely.\n* We might want to consider a crater run before landing this.\n* We might want some kind of design meeting to cover the overall strategy.\n* I just remembered I never finished 100% integrating this into the canonicalization code.\n* I should also review what happens in NLL region checking -- it probably still has a notion of bottom (empty set).\n\nr? @matthewjasper", "tree": {"sha": "f9c52c26c185f50112ce9a318e6c6fe173a3cc1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9c52c26c185f50112ce9a318e6c6fe173a3cc1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "html_url": "https://github.com/rust-lang/rust/commit/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a29424a2265411dda7d7446516ac5fd7499e2b55", "url": "https://api.github.com/repos/rust-lang/rust/commits/a29424a2265411dda7d7446516ac5fd7499e2b55", "html_url": "https://github.com/rust-lang/rust/commit/a29424a2265411dda7d7446516ac5fd7499e2b55"}, {"sha": "4b3c66d2c309a16d48c2b7f992a2038016a098d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3c66d2c309a16d48c2b7f992a2038016a098d3", "html_url": "https://github.com/rust-lang/rust/commit/4b3c66d2c309a16d48c2b7f992a2038016a098d3"}], "stats": {"total": 820, "additions": 613, "deletions": 207}, "files": [{"sha": "844250f51a099536b67d57446d93ab57abb4ab5d", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -63,9 +63,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            ty::ReErased | ty::ReStatic | ty::ReEmpty => {\n+            ty::ReErased | ty::ReStatic => {\n                 // No variant fields to hash for these ...\n             }\n+            ty::ReEmpty(universe) => {\n+                universe.hash_stable(hcx, hasher);\n+            }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 db.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);"}, {"sha": "48a6c6d7413d195b93635543b559f30ee9b1ebf5", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -167,18 +167,29 @@ impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n-            ty::ReFree(_) | ty::ReEmpty | ty::ReErased | ty::ReStatic | ty::ReEarlyBound(..) => r,\n+            ty::ReFree(_)\n+            | ty::ReErased\n+            | ty::ReStatic\n+            | ty::ReEmpty(ty::UniverseIndex::ROOT)\n+            | ty::ReEarlyBound(..) => r,\n+\n             ty::RePlaceholder(placeholder) => canonicalizer.canonical_var_for_region(\n                 CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderRegion(*placeholder) },\n                 r,\n             ),\n+\n             ty::ReVar(vid) => {\n                 let universe = canonicalizer.region_var_universe(*vid);\n                 canonicalizer.canonical_var_for_region(\n                     CanonicalVarInfo { kind: CanonicalVarKind::Region(universe) },\n                     r,\n                 )\n             }\n+\n+            ty::ReEmpty(ui) => {\n+                bug!(\"canonicalizing 'empty in universe {:?}\", ui) // FIXME\n+            }\n+\n             _ => {\n                 // Other than `'static` or `'empty`, the query\n                 // response should be executing in a fully\n@@ -213,7 +224,7 @@ impl CanonicalizeRegionMode for CanonicalizeUserTypeAnnotation {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReEmpty | ty::ReStatic => r,\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReStatic => r,\n             ty::ReVar(_) => canonicalizer.canonical_var_for_region_in_root_universe(r),\n             _ => {\n                 // We only expect region names that the user can type.\n@@ -320,8 +331,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReScope(_)\n+            | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n             | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n \n             ty::ReClosureBound(..) => {"}, {"sha": "2518805a1ecfc618a7dc6b793509e9729349b768", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -577,7 +577,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n             ty::RePlaceholder(..)\n             | ty::ReVar(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReStatic\n             | ty::ReScope(..)\n             | ty::ReEarlyBound(..)"}, {"sha": "57a52a991edc85b0767e573e1e161cf452f777c1", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -138,7 +138,10 @@ pub(super) fn note_and_explain_region(\n             msg_span_from_free_region(tcx, region)\n         }\n \n-        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"the empty lifetime\".to_owned(), None),\n+\n+        // uh oh, hope no user ever sees THIS\n+        ty::ReEmpty(ui) => (format!(\"the empty lifetime in universe {:?}\", ui), None),\n \n         ty::RePlaceholder(_) => (format!(\"any other region\"), None),\n \n@@ -181,7 +184,8 @@ fn msg_span_from_free_region(\n             msg_span_from_early_bound_and_free_regions(tcx, region)\n         }\n         ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n-        ty::ReEmpty => (\"an empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"an empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ui) => (format!(\"an empty lifetime in universe {:?}\", ui), None),\n         _ => bug!(\"{:?}\", region),\n     }\n }\n@@ -375,6 +379,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n+                    RegionResolutionError::UpperBoundUniverseConflict(\n+                        _,\n+                        _,\n+                        var_universe,\n+                        sup_origin,\n+                        sup_r,\n+                    ) => {\n+                        assert!(sup_r.is_placeholder());\n+\n+                        // Make a dummy value for the \"sub region\" --\n+                        // this is the initial value of the\n+                        // placeholder. In practice, we expect more\n+                        // tailored errors that don't really use this\n+                        // value.\n+                        let sub_r = self.tcx.mk_region(ty::ReEmpty(var_universe));\n+\n+                        self.report_placeholder_failure(\n+                            region_scope_tree,\n+                            sup_origin,\n+                            sub_r,\n+                            sup_r,\n+                        )\n+                        .emit();\n+                    }\n+\n                     RegionResolutionError::MemberConstraintFailure {\n                         opaque_type_def_id,\n                         hidden_ty,\n@@ -429,6 +458,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n             RegionResolutionError::ConcreteFailure(..)\n             | RegionResolutionError::SubSupConflict(..)\n+            | RegionResolutionError::UpperBoundUniverseConflict(..)\n             | RegionResolutionError::MemberConstraintFailure { .. } => false,\n         };\n \n@@ -443,6 +473,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::UpperBoundUniverseConflict(_, ref rvo, _, _, _) => rvo.span(),\n             RegionResolutionError::MemberConstraintFailure { span, .. } => span,\n         });\n         errors"}, {"sha": "6a9fe19e1ac3d19948352db61564439d1da58e44", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ///\n     /// It will later be extended to trait objects.\n     pub(super) fn try_report_anon_anon_conflict(&self) -> Option<ErrorReported> {\n-        let (span, sub, sup) = self.regions();\n+        let (span, sub, sup) = self.regions()?;\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n         let anon_reg_sup = self.tcx().is_suitable_region(sup)?;"}, {"sha": "b10a60ef6f11fbee7c9c75dc9827ae65663bd536", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -17,11 +17,6 @@ mod util;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-        match *error {\n-            ConcreteFailure(..) | SubSupConflict(..) => {}\n-            _ => return false, // inapplicable\n-        }\n-\n         if let Some(tables) = self.in_progress_tables {\n             let tables = tables.borrow();\n             NiceRegionError::new(self, error.clone(), Some(&tables)).try_report().is_some()\n@@ -79,13 +74,14 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n             .or_else(|| self.try_report_impl_not_conforming_to_trait())\n     }\n \n-    pub fn regions(&self) -> (Span, ty::Region<'tcx>, ty::Region<'tcx>) {\n+    pub fn regions(&self) -> Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)> {\n         match (&self.error, self.regions) {\n-            (Some(ConcreteFailure(origin, sub, sup)), None) => (origin.span(), sub, sup),\n-            (Some(SubSupConflict(_, _, origin, sub, _, sup)), None) => (origin.span(), sub, sup),\n-            (None, Some((span, sub, sup))) => (span, sub, sup),\n-            (Some(_), Some(_)) => panic!(\"incorrectly built NiceRegionError\"),\n-            _ => panic!(\"trying to report on an incorrect lifetime failure\"),\n+            (Some(ConcreteFailure(origin, sub, sup)), None) => Some((origin.span(), sub, sup)),\n+            (Some(SubSupConflict(_, _, origin, sub, _, sup)), None) => {\n+                Some((origin.span(), sub, sup))\n+            }\n+            (None, Some((span, sub, sup))) => Some((span, sub, sup)),\n+            _ => None,\n         }\n     }\n }"}, {"sha": "250dcff372c593b5e35af1695a8ce80773a83464", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -9,7 +9,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n     pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n-        let (span, sub, sup) = self.regions();\n+        let (span, sub, sup) = self.regions()?;\n \n         debug!(\n             \"try_report_named_anon_conflict(sub={:?}, sup={:?}, error={:?})\","}, {"sha": "0b0bd61ce771e770a7dcd2a919aff509b4916ef5", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -107,6 +107,25 @@ impl NiceRegionError<'me, 'tcx> {\n                 found.substs,\n             )),\n \n+            Some(RegionResolutionError::UpperBoundUniverseConflict(\n+                vid,\n+                _,\n+                _,\n+                SubregionOrigin::Subtype(box TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                sup_placeholder @ ty::RePlaceholder(_),\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                cause,\n+                None,\n+                Some(*sup_placeholder),\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n+\n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(box TypeTrace {\n                     cause,"}, {"sha": "cf61cac0ac4bbf9042763ba7196c3e918e6e0afb", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::ReScope(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // replace all free regions with 'erased\n                 self.tcx().lifetimes.re_erased"}, {"sha": "d25d186f4d74e86756fc66abca5f134b78748db9", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -128,6 +128,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         placeholder_map: &PlaceholderMap<'tcx>,\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n+        // If the user gave `-Zno-leak-check`, or we have been\n+        // configured to skip the leak check, then skip the leak check\n+        // completely. The leak check is deprecated. Any legitimate\n+        // subtyping errors that it would have caught will now be\n+        // caught later on, during region checking. However, we\n+        // continue to use it for a transition period.\n+        if self.tcx.sess.opts.debugging_opts.no_leak_check || self.skip_leak_check.get() {\n+            return Ok(());\n+        }\n+\n         self.borrow_region_constraints().leak_check(\n             self.tcx,\n             overly_polymorphic,"}, {"sha": "e0a8c3b4e654a6f4eae4d9a796776425d644e1f8", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 123, "deletions": 25, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -82,6 +82,16 @@ pub enum RegionResolutionError<'tcx> {\n         Region<'tcx>,\n     ),\n \n+    /// Indicates a `'b: 'a` constraint where `'a` is in a universe that\n+    /// cannot name the placeholder `'b`.\n+    UpperBoundUniverseConflict(\n+        RegionVid,\n+        RegionVariableOrigin,\n+        ty::UniverseIndex,     // the universe index of the region variable\n+        SubregionOrigin<'tcx>, // cause of the constraint\n+        Region<'tcx>,          // the placeholder `'b`\n+    ),\n+\n     /// Indicates a failure of a `MemberConstraint`. These arise during\n     /// impl trait processing explicitly -- basically, the impl trait's hidden type\n     /// included some region that it was not supposed to.\n@@ -149,7 +159,14 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.lifetimes.re_static,\n-            values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars()),\n+            values: IndexVec::from_fn_n(\n+                |vid| {\n+                    let vid_universe = self.var_infos[vid].universe;\n+                    let re_empty = tcx.mk_region(ty::ReEmpty(vid_universe));\n+                    VarValue::Value(re_empty)\n+                },\n+                self.num_vars(),\n+            ),\n         }\n     }\n \n@@ -381,8 +398,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // This is a specialized version of the `lub_concrete_regions`\n                 // check below for a common case, here purely as an\n                 // optimization.\n-                if let ReEmpty = a_region {\n-                    return false;\n+                let b_universe = self.var_infos[b_vid].universe;\n+                if let ReEmpty(a_universe) = a_region {\n+                    if *a_universe == b_universe {\n+                        return false;\n+                    }\n                 }\n \n                 let mut lub = self.lub_concrete_regions(a_region, cur_region);\n@@ -399,7 +419,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // tighter bound than `'static`.\n                 //\n                 // (This might e.g. arise from being asked to prove `for<'a> { 'b: 'a }`.)\n-                let b_universe = self.var_infos[b_vid].universe;\n                 if let ty::RePlaceholder(p) = lub {\n                     if b_universe.cannot_name(p.universe) {\n                         lub = self.tcx().lifetimes.re_static;\n@@ -420,12 +439,38 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n     /// True if `a <= b`, but not defined over inference variables.\n     fn sub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> bool {\n+        let tcx = self.tcx();\n+        let sub_free_regions = |r1, r2| self.region_rels.free_regions.sub_free_regions(tcx, r1, r2);\n+\n+        // Check for the case where we know that `'b: 'static` -- in that case,\n+        // `a <= b` for all `a`.\n+        let b_free_or_static = self.region_rels.free_regions.is_free_or_static(b);\n+        if b_free_or_static && sub_free_regions(tcx.lifetimes.re_static, b) {\n+            return true;\n+        }\n+\n+        // If both `a` and `b` are free, consult the declared\n+        // relationships.  Note that this can be more precise than the\n+        // `lub` relationship defined below, since sometimes the \"lub\"\n+        // is actually the `postdom_upper_bound` (see\n+        // `TransitiveRelation` for more details).\n+        let a_free_or_static = self.region_rels.free_regions.is_free_or_static(a);\n+        if a_free_or_static && b_free_or_static {\n+            return sub_free_regions(a, b);\n+        }\n+\n+        // For other cases, leverage the LUB code to find the LUB and\n+        // check if it is equal to `b`.\n         self.lub_concrete_regions(a, b) == b\n     }\n \n-    /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n+    /// Returns the least-upper-bound of `a` and `b`; i.e., the\n+    /// smallest region `c` such that `a <= c` and `b <= c`.\n+    ///\n+    /// Neither `a` nor `b` may be an inference variable (hence the\n+    /// term \"concrete regions\").\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        match (a, b) {\n+        let r = match (a, b) {\n             (&ty::ReClosureBound(..), _)\n             | (_, &ty::ReClosureBound(..))\n             | (&ReLateBound(..), _)\n@@ -435,14 +480,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n \n-            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n-                r // nothing lives longer than static\n-            }\n-\n-            (&ReEmpty, r) | (r, &ReEmpty) => {\n-                r // everything lives longer than empty\n-            }\n-\n             (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!(\n                     self.var_infos[v_id].origin.span(),\n@@ -453,6 +490,41 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 );\n             }\n \n+            (&ReStatic, _) | (_, &ReStatic) => {\n+                // nothing lives longer than `'static`\n+                self.tcx().lifetimes.re_static\n+            }\n+\n+            (&ReEmpty(_), r @ ReEarlyBound(_))\n+            | (r @ ReEarlyBound(_), &ReEmpty(_))\n+            | (&ReEmpty(_), r @ ReFree(_))\n+            | (r @ ReFree(_), &ReEmpty(_))\n+            | (&ReEmpty(_), r @ ReScope(_))\n+            | (r @ ReScope(_), &ReEmpty(_)) => {\n+                // All empty regions are less than early-bound, free,\n+                // and scope regions.\n+                r\n+            }\n+\n+            (&ReEmpty(a_ui), &ReEmpty(b_ui)) => {\n+                // Empty regions are ordered according to the universe\n+                // they are associated with.\n+                let ui = a_ui.min(b_ui);\n+                self.tcx().mk_region(ReEmpty(ui))\n+            }\n+\n+            (&ReEmpty(empty_ui), &RePlaceholder(placeholder))\n+            | (&RePlaceholder(placeholder), &ReEmpty(empty_ui)) => {\n+                // If this empty region is from a universe that can\n+                // name the placeholder, then the placeholder is\n+                // larger; otherwise, the only ancestor is `'static`.\n+                if empty_ui.can_name(placeholder.universe) {\n+                    self.tcx().mk_region(RePlaceholder(placeholder))\n+                } else {\n+                    self.tcx().lifetimes.re_static\n+                }\n+            }\n+\n             (&ReEarlyBound(_), &ReScope(s_id))\n             | (&ReScope(s_id), &ReEarlyBound(_))\n             | (&ReFree(_), &ReScope(s_id))\n@@ -509,7 +581,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     self.tcx().lifetimes.re_static\n                 }\n             }\n-        }\n+        };\n+\n+        debug!(\"lub_concrete_regions({:?}, {:?}) = {:?}\", a, b, r);\n+\n+        r\n     }\n \n     /// After expansion is complete, go and check upper bounds (i.e.,\n@@ -528,7 +604,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 }\n \n                 Constraint::RegSubReg(sub, sup) => {\n-                    if self.region_rels.is_subregion_of(sub, sup) {\n+                    if self.sub_concrete_regions(sub, sup) {\n                         continue;\n                     }\n \n@@ -557,7 +633,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     // Do not report these errors immediately:\n                     // instead, set the variable value to error and\n                     // collect them later.\n-                    if !self.region_rels.is_subregion_of(a_region, b_region) {\n+                    if !self.sub_concrete_regions(a_region, b_region) {\n                         debug!(\n                             \"collect_errors: region error at {:?}: \\\n                              cannot verify that {:?}={:?} <= {:?}\",\n@@ -592,12 +668,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = var_data.normalize(self.tcx(), verify.region);\n \n-            // This was an inference variable which didn't get\n-            // constrained, therefore it can be assume to hold.\n-            if let ty::ReEmpty = *sub {\n-                continue;\n-            }\n-\n             let verify_kind_ty = verify.kind.to_ty(self.tcx());\n             if self.bound_is_met(&verify.bound, var_data, verify_kind_ty, sub) {\n                 continue;\n@@ -760,7 +830,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             };\n \n             for upper_bound in &upper_bounds {\n-                if !self.region_rels.is_subregion_of(effective_lower_bound, upper_bound.region) {\n+                if !self.sub_concrete_regions(effective_lower_bound, upper_bound.region) {\n                     let origin = self.var_infos[node_idx].origin;\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n@@ -780,6 +850,26 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n+        // If we have a scenario like `exists<'a> { forall<'b> { 'b:\n+        // 'a } }`, we wind up without any lower-bound -- all we have\n+        // are placeholders as upper bounds, but the universe of the\n+        // variable `'a` doesn't permit those placeholders.\n+        for upper_bound in &upper_bounds {\n+            if let ty::RePlaceholder(p) = upper_bound.region {\n+                if node_universe.cannot_name(p.universe) {\n+                    let origin = self.var_infos[node_idx].origin.clone();\n+                    errors.push(RegionResolutionError::UpperBoundUniverseConflict(\n+                        node_idx,\n+                        origin,\n+                        node_universe,\n+                        upper_bound.origin.clone(),\n+                        upper_bound.region,\n+                    ));\n+                    return;\n+                }\n+            }\n+        }\n+\n         // Errors in earlier passes can yield error variables without\n         // resolution errors here; delay ICE in favor of those errors.\n         self.tcx().sess.delay_span_bug(\n@@ -890,7 +980,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n \n             VerifyBound::OutlivedBy(r) => {\n-                self.region_rels.is_subregion_of(min, var_values.normalize(self.tcx(), r))\n+                self.sub_concrete_regions(min, var_values.normalize(self.tcx(), r))\n+            }\n+\n+            VerifyBound::IsEmpty => {\n+                if let ty::ReEmpty(_) = min {\n+                    true\n+                } else {\n+                    false\n+                }\n             }\n \n             VerifyBound::AnyBound(bs) => {"}, {"sha": "b93f4408cdc4627c888947d9a26da4359031659c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -125,6 +125,13 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// order, represented by its upper and lower bounds.\n     pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n+    /// If set, this flag causes us to skip the 'leak check' during\n+    /// higher-ranked subtyping operations. This flag is a temporary one used\n+    /// to manage the removal of the leak-check: for the time being, we still run the\n+    /// leak-check, but we issue warnings. This flag can only be set to true\n+    /// when entering a snapshot.\n+    skip_leak_check: Cell<bool>,\n+\n     /// Map from const parameter variable to the kind of const it represents.\n     const_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>>,\n \n@@ -246,7 +253,7 @@ pub enum ValuePairs<'tcx> {\n /// encounter an error or subtyping constraint.\n ///\n /// See the `error_reporting` module for more details.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct TypeTrace<'tcx> {\n     cause: ObligationCause<'tcx>,\n     values: ValuePairs<'tcx>,\n@@ -550,6 +557,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n                 tainted_by_errors_flag: Cell::new(false),\n                 err_count_on_creation: tcx.sess.err_count(),\n                 in_snapshot: Cell::new(false),\n+                skip_leak_check: Cell::new(false),\n                 region_obligations: RefCell::new(vec![]),\n                 universe: Cell::new(ty::UniverseIndex::ROOT),\n             })\n@@ -593,6 +601,7 @@ pub struct CombinedSnapshot<'a, 'tcx> {\n     region_obligations_snapshot: usize,\n     universe: ty::UniverseIndex,\n     was_in_snapshot: bool,\n+    was_skip_leak_check: bool,\n     _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n \n@@ -720,6 +729,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_obligations_snapshot: self.region_obligations.borrow().len(),\n             universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n+            was_skip_leak_check: self.skip_leak_check.get(),\n             // Borrow tables \"in progress\" (i.e., during typeck)\n             // to ban writes from within a snapshot to them.\n             _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n@@ -738,11 +748,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_obligations_snapshot,\n             universe,\n             was_in_snapshot,\n+            was_skip_leak_check,\n             _in_progress_tables,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n         self.universe.set(universe);\n+        self.skip_leak_check.set(was_skip_leak_check);\n \n         self.projection_cache.borrow_mut().rollback_to(projection_cache_snapshot);\n         self.type_variables.borrow_mut().rollback_to(type_snapshot);\n@@ -765,10 +777,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_obligations_snapshot: _,\n             universe: _,\n             was_in_snapshot,\n+            was_skip_leak_check,\n             _in_progress_tables,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n+        self.skip_leak_check.set(was_skip_leak_check);\n \n         self.projection_cache.borrow_mut().commit(projection_cache_snapshot);\n         self.type_variables.borrow_mut().commit(type_snapshot);\n@@ -822,6 +836,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n+    /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.\n+    pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n+    {\n+        debug!(\"probe()\");\n+        let snapshot = self.start_snapshot();\n+        let skip_leak_check = should_skip || self.skip_leak_check.get();\n+        self.skip_leak_check.set(skip_leak_check);\n+        let r = f(&snapshot);\n+        self.rollback_to(\"probe\", snapshot);\n+        r\n+    }\n+\n     /// Scan the constraints produced since `snapshot` began and returns:\n     ///\n     /// - `None` -- if none of them involve \"region outlives\" constraints\n@@ -1647,12 +1675,6 @@ impl<'tcx> TypeTrace<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for TypeTrace<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"TypeTrace({:?})\", self.cause)\n-    }\n-}\n-\n impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {"}, {"sha": "7fef9d27c4d4a353f5aa1c1950165baf8e73c052", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -384,9 +384,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             match least_region {\n                 None => least_region = Some(subst_arg),\n                 Some(lr) => {\n-                    if free_region_relations.sub_free_regions(lr, subst_arg) {\n+                    if free_region_relations.sub_free_regions(self.tcx, lr, subst_arg) {\n                         // keep the current least region\n-                    } else if free_region_relations.sub_free_regions(subst_arg, lr) {\n+                    } else if free_region_relations.sub_free_regions(self.tcx, subst_arg, lr) {\n                         // switch to `subst_arg`\n                         least_region = Some(subst_arg);\n                     } else {\n@@ -611,7 +611,7 @@ pub fn unexpected_hidden_region_diagnostic(\n     );\n \n     // Explain the region we are capturing.\n-    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty = hidden_region {\n+    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) = hidden_region {\n         // Assuming regionck succeeded (*), we ought to always be\n         // capturing *some* region from the fn header, and hence it\n         // ought to be free. So under normal circumstances, we will go\n@@ -844,7 +844,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                         .emit();\n                     }\n                 }\n-                self.tcx.lifetimes.re_empty\n+                self.tcx.lifetimes.re_root_empty\n             }\n             None => {\n                 self.tcx"}, {"sha": "a2c99064caa4e0c6b0e4ee79d70bb039789b41f2", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -60,7 +60,18 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         // scope type parameters:\n         let param_bounds = param_bounds.chain(self.implicit_region_bound);\n \n-        VerifyBound::AnyBound(param_bounds.map(|r| VerifyBound::OutlivedBy(r)).collect())\n+        let any_bounds: Vec<_> = param_bounds.map(|r| VerifyBound::OutlivedBy(r)).collect();\n+\n+        if any_bounds.is_empty() {\n+            // We know that all types `T` outlive `'empty`, so if we\n+            // can find no other bound, then check that the region\n+            // being tested is `'empty`.\n+            VerifyBound::IsEmpty\n+        } else {\n+            // If we can find any other bound `R` such that `T: R`, then\n+            // we don't need to check for `'empty`, because `R: 'empty`.\n+            VerifyBound::AnyBound(any_bounds)\n+        }\n     }\n \n     /// Given a projection like `T::Item`, searches the environment"}, {"sha": "29290cef2d28825b7e91ad98d959f419692240ad", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -33,18 +33,6 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n         assert!(self.in_snapshot());\n \n-        // If the user gave `-Zno-leak-check`, then skip the leak\n-        // check completely. This is wildly unsound and also not\n-        // unlikely to cause an ICE or two. It is intended for use\n-        // only during a transition period, in which the MIR typeck\n-        // uses the \"universe-style\" check, and the rest of typeck\n-        // uses the more conservative leak check.  Since the leak\n-        // check is more conservative, we can't test the\n-        // universe-style check without disabling it.\n-        if tcx.sess.opts.debugging_opts.no_leak_check {\n-            return Ok(());\n-        }\n-\n         // Go through each placeholder that we created.\n         for (_, &placeholder_region) in placeholder_map {\n             // Find the universe this placeholder inhabits."}, {"sha": "2c580e2e3490a4e0bcef02a6aa1e8c6727cb8bdc", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -233,6 +233,9 @@ pub enum VerifyBound<'tcx> {\n     /// if `R: min`, then by transitivity `G: min`.\n     OutlivedBy(Region<'tcx>),\n \n+    /// Given a region `R`, true if it is `'empty`.\n+    IsEmpty,\n+\n     /// Given a set of bounds `B`, expands to the function:\n     ///\n     /// ```rust\n@@ -792,10 +795,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         match *region {\n             ty::ReScope(..)\n             | ty::ReStatic\n-            | ty::ReEmpty\n             | ty::ReErased\n             | ty::ReFree(..)\n             | ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n+            ty::ReEmpty(ui) => ui,\n             ty::RePlaceholder(placeholder) => placeholder.universe,\n             ty::ReClosureBound(vid) | ty::ReVar(vid) => self.var_universe(vid),\n             ty::ReLateBound(..) => bug!(\"universe(): encountered bound region {:?}\", region),\n@@ -867,6 +870,7 @@ impl<'tcx> VerifyBound<'tcx> {\n             VerifyBound::IfEq(..) => false,\n             VerifyBound::OutlivedBy(ty::ReStatic) => true,\n             VerifyBound::OutlivedBy(_) => false,\n+            VerifyBound::IsEmpty => false,\n             VerifyBound::AnyBound(bs) => bs.iter().any(|b| b.must_hold()),\n             VerifyBound::AllBounds(bs) => bs.iter().all(|b| b.must_hold()),\n         }\n@@ -875,7 +879,7 @@ impl<'tcx> VerifyBound<'tcx> {\n     pub fn cannot_hold(&self) -> bool {\n         match self {\n             VerifyBound::IfEq(_, b) => b.cannot_hold(),\n-            VerifyBound::OutlivedBy(ty::ReEmpty) => true,\n+            VerifyBound::IsEmpty => false,\n             VerifyBound::OutlivedBy(_) => false,\n             VerifyBound::AnyBound(bs) => bs.iter().all(|b| b.cannot_hold()),\n             VerifyBound::AllBounds(bs) => bs.iter().any(|b| b.cannot_hold()),"}, {"sha": "62ccd94674488277ac66f6b3a405a8394e3fb50d", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 58, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -4,8 +4,8 @@\n //! and use that to decide when one free region outlives another, and so forth.\n \n use crate::middle::region;\n-use crate::ty::free_region_map::{FreeRegionMap, FreeRegionRelations};\n-use crate::ty::{self, Region, TyCtxt};\n+use crate::ty::free_region_map::FreeRegionMap;\n+use crate::ty::{Region, TyCtxt};\n use rustc_hir::def_id::DefId;\n \n /// Combines a `region::ScopeTree` (which governs relationships between\n@@ -38,62 +38,6 @@ impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n         Self { tcx, context, region_scope_tree, free_regions }\n     }\n \n-    /// Determines whether one region is a subregion of another. This is intended to run *after\n-    /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n-    pub fn is_subregion_of(\n-        &self,\n-        sub_region: ty::Region<'tcx>,\n-        super_region: ty::Region<'tcx>,\n-    ) -> bool {\n-        let result = sub_region == super_region || {\n-            match (sub_region, super_region) {\n-                (ty::ReEmpty, _) | (_, ty::ReStatic) => true,\n-\n-                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) => {\n-                    self.region_scope_tree.is_subscope_of(*sub_scope, *super_scope)\n-                }\n-\n-                (ty::ReScope(sub_scope), ty::ReEarlyBound(ref br)) => {\n-                    let fr_scope = self.region_scope_tree.early_free_scope(self.tcx, br);\n-                    self.region_scope_tree.is_subscope_of(*sub_scope, fr_scope)\n-                }\n-\n-                (ty::ReScope(sub_scope), ty::ReFree(fr)) => {\n-                    let fr_scope = self.region_scope_tree.free_scope(self.tcx, fr);\n-                    self.region_scope_tree.is_subscope_of(*sub_scope, fr_scope)\n-                }\n-\n-                (ty::ReEarlyBound(_), ty::ReEarlyBound(_))\n-                | (ty::ReFree(_), ty::ReEarlyBound(_))\n-                | (ty::ReEarlyBound(_), ty::ReFree(_))\n-                | (ty::ReFree(_), ty::ReFree(_)) => {\n-                    self.free_regions.sub_free_regions(sub_region, super_region)\n-                }\n-\n-                _ => false,\n-            }\n-        };\n-        let result = result || self.is_static(super_region);\n-        debug!(\n-            \"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n-            sub_region, super_region, result\n-        );\n-        result\n-    }\n-\n-    /// Determines whether this free region is required to be `'static`.\n-    fn is_static(&self, super_region: ty::Region<'tcx>) -> bool {\n-        debug!(\"is_static(super_region={:?})\", super_region);\n-        match *super_region {\n-            ty::ReStatic => true,\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                let re_static = self.tcx.mk_region(ty::ReStatic);\n-                self.free_regions.sub_free_regions(&re_static, &super_region)\n-            }\n-            _ => false,\n-        }\n-    }\n-\n     pub fn lub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> Region<'tcx> {\n         self.free_regions.lub_free_regions(self.tcx, r_a, r_b)\n     }"}, {"sha": "855da0367de067b71de012caea5567de95ac2e55", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -7,6 +7,7 @@\n use crate::infer::{CombinedSnapshot, InferOk};\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::IntercrateMode;\n+use crate::traits::SkipLeakCheck;\n use crate::traits::{self, Normalized, Obligation, ObligationCause, SelectionContext};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::Subst;\n@@ -53,6 +54,7 @@ pub fn overlapping_impls<F1, F2, R>(\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n+    skip_leak_check: SkipLeakCheck,\n     on_overlap: F1,\n     no_overlap: F2,\n ) -> R\n@@ -70,7 +72,7 @@ where\n \n     let overlaps = tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n-        overlap(selcx, impl1_def_id, impl2_def_id).is_some()\n+        overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id).is_some()\n     });\n \n     if !overlaps {\n@@ -83,7 +85,7 @@ where\n     tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n         selcx.enable_tracking_intercrate_ambiguity_causes();\n-        on_overlap(overlap(selcx, impl1_def_id, impl2_def_id).unwrap())\n+        on_overlap(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id).unwrap())\n     })\n }\n \n@@ -113,12 +115,15 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n /// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n+    skip_leak_check: SkipLeakCheck,\n     a_def_id: DefId,\n     b_def_id: DefId,\n ) -> Option<OverlapResult<'tcx>> {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\", a_def_id, b_def_id);\n \n-    selcx.infcx().probe(|snapshot| overlap_within_probe(selcx, a_def_id, b_def_id, snapshot))\n+    selcx.infcx().probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n+        overlap_within_probe(selcx, a_def_id, b_def_id, snapshot)\n+    })\n }\n \n fn overlap_within_probe(\n@@ -146,7 +151,9 @@ fn overlap_within_probe(\n         .eq_impl_headers(&a_impl_header, &b_impl_header)\n     {\n         Ok(InferOk { obligations, value: () }) => obligations,\n-        Err(_) => return None,\n+        Err(_) => {\n+            return None;\n+        }\n     };\n \n     debug!(\"overlap: unification check succeeded\");"}, {"sha": "50068b89687ba9a66f8cdaa431afd2a08dc21f43", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -83,6 +83,28 @@ pub enum IntercrateMode {\n     Fixed,\n }\n \n+/// Whether to skip the leak check, as part of a future compatibility warning step.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum SkipLeakCheck {\n+    Yes,\n+    No,\n+}\n+\n+impl SkipLeakCheck {\n+    fn is_yes(self) -> bool {\n+        self == SkipLeakCheck::Yes\n+    }\n+}\n+\n+/// The \"default\" for skip-leak-check corresponds to the current\n+/// behavior (do not skip the leak check) -- not the behavior we are\n+/// transitioning into.\n+impl Default for SkipLeakCheck {\n+    fn default() -> Self {\n+        SkipLeakCheck::No\n+    }\n+}\n+\n /// The mode that trait queries run in.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TraitQueryMode {"}, {"sha": "8b68d6f26039966f6b486b929005127b6f32f7c3", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -19,6 +19,7 @@ use crate::ty::{self, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::DefId;\n+use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n use rustc_span::DUMMY_SP;\n \n@@ -97,7 +98,7 @@ pub fn translate_substs<'a, 'tcx>(\n                 |_| {\n                     bug!(\n                         \"When translating substitutions for specialization, the expected \\\n-                          specialization failed to hold\"\n+                         specialization failed to hold\"\n                     )\n                 },\n             )\n@@ -268,7 +269,7 @@ fn fulfill_implication<'a, 'tcx>(\n                 // no dice!\n                 debug!(\n                     \"fulfill_implication: for impls on {:?} and {:?}, \\\n-                        could not fulfill: {:?} given {:?}\",\n+                     could not fulfill: {:?} given {:?}\",\n                     source_trait_ref, target_trait_ref, errors, param_env.caller_bounds\n                 );\n                 Err(())\n@@ -342,6 +343,7 @@ pub(super) fn specialization_graph_provider(\n                             FutureCompatOverlapErrorKind::Issue33140 => {\n                                 ORDER_DEPENDENT_TRAIT_OBJECTS\n                             }\n+                            FutureCompatOverlapErrorKind::LeakCheck => COHERENCE_LEAK_CHECK,\n                         };\n                         tcx.struct_span_lint_hir(\n                             lint,"}, {"sha": "98908e672f0aa1f9966a760e7c82588e4a829ac8", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -11,6 +11,7 @@ pub use rustc::traits::types::specialization_graph::*;\n pub enum FutureCompatOverlapErrorKind {\n     Issue43355,\n     Issue33140,\n+    LeakCheck,\n }\n \n #[derive(Debug)]\n@@ -111,6 +112,7 @@ impl<'tcx> Children {\n                 possible_sibling,\n                 impl_def_id,\n                 traits::IntercrateMode::Issue43355,\n+                traits::SkipLeakCheck::default(),\n                 |overlap| {\n                     if let Some(overlap_kind) =\n                         tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling)\n@@ -161,6 +163,7 @@ impl<'tcx> Children {\n                         possible_sibling,\n                         impl_def_id,\n                         traits::IntercrateMode::Fixed,\n+                        traits::SkipLeakCheck::default(),\n                         |overlap| {\n                             last_lint = Some(FutureCompatOverlapError {\n                                 error: overlap_error(overlap),\n@@ -169,6 +172,23 @@ impl<'tcx> Children {\n                         },\n                         || (),\n                     );\n+\n+                    if last_lint.is_none() {\n+                        traits::overlapping_impls(\n+                            tcx,\n+                            possible_sibling,\n+                            impl_def_id,\n+                            traits::IntercrateMode::Fixed,\n+                            traits::SkipLeakCheck::Yes,\n+                            |overlap| {\n+                                last_lint = Some(FutureCompatOverlapError {\n+                                    error: overlap_error(overlap),\n+                                    kind: FutureCompatOverlapErrorKind::LeakCheck,\n+                                });\n+                            },\n+                            || (),\n+                        );\n+                    }\n                 }\n \n                 // no overlap (error bailed already via ?)\n@@ -247,7 +267,7 @@ impl<'tcx> Graph {\n         if trait_ref.references_error() {\n             debug!(\n                 \"insert: inserting dummy node for erroneous TraitRef {:?}, \\\n-                    impl_def_id={:?}, trait_def_id={:?}\",\n+                 impl_def_id={:?}, trait_def_id={:?}\",\n                 trait_ref, impl_def_id, trait_def_id\n             );\n \n@@ -326,7 +346,7 @@ impl<'tcx> Graph {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\n                 \"When recording an impl from the crate store, information about its parent \\\n-                  was already present.\"\n+                 was already present.\"\n             );\n         }\n "}, {"sha": "92c5600362e01768a2a1bde61f53f1a916772a4e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -173,8 +173,13 @@ pub struct CommonTypes<'tcx> {\n }\n \n pub struct CommonLifetimes<'tcx> {\n-    pub re_empty: Region<'tcx>,\n+    /// `ReEmpty` in the root universe.\n+    pub re_root_empty: Region<'tcx>,\n+\n+    /// `ReStatic`\n     pub re_static: Region<'tcx>,\n+\n+    /// Erased region, used after type-checking\n     pub re_erased: Region<'tcx>,\n }\n \n@@ -876,7 +881,7 @@ impl<'tcx> CommonLifetimes<'tcx> {\n         let mk = |r| interners.region.intern(r, |r| Interned(interners.arena.alloc(r))).0;\n \n         CommonLifetimes {\n-            re_empty: mk(RegionKind::ReEmpty),\n+            re_root_empty: mk(RegionKind::ReEmpty(ty::UniverseIndex::ROOT)),\n             re_static: mk(RegionKind::ReStatic),\n             re_erased: mk(RegionKind::ReErased),\n         }"}, {"sha": "2ab12a4acbfa4affd6c5658da0a614b352f1c9e7", "filename": "src/librustc/ty/free_region_map.rs", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fty%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fty%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffree_region_map.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -23,11 +23,61 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     // (with the exception that `'static: 'x` is not notable)\n     pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n         debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n-        if is_free_or_static(sub) && is_free(sup) {\n+        if self.is_free_or_static(sub) && self.is_free(sup) {\n             self.relation.add(sub, sup)\n         }\n     }\n \n+    /// Tests whether `r_a <= r_b`.\n+    ///\n+    /// Both regions must meet `is_free_or_static`.\n+    ///\n+    /// Subtle: one tricky case that this code gets correct is as\n+    /// follows. If we know that `r_b: 'static`, then this function\n+    /// will return true, even though we don't know anything that\n+    /// directly relates `r_a` and `r_b`.\n+    ///\n+    /// Also available through the `FreeRegionRelations` trait below.\n+    pub fn sub_free_regions(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        r_a: Region<'tcx>,\n+        r_b: Region<'tcx>,\n+    ) -> bool {\n+        assert!(self.is_free_or_static(r_a) && self.is_free_or_static(r_b));\n+        let re_static = tcx.lifetimes.re_static;\n+        if self.check_relation(re_static, r_b) {\n+            // `'a <= 'static` is always true, and not stored in the\n+            // relation explicitly, so check if `'b` is `'static` (or\n+            // equivalent to it)\n+            true\n+        } else {\n+            self.check_relation(r_a, r_b)\n+        }\n+    }\n+\n+    /// Check whether `r_a <= r_b` is found in the relation.\n+    fn check_relation(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n+        r_a == r_b || self.relation.contains(&r_a, &r_b)\n+    }\n+\n+    /// True for free regions other than `'static`.\n+    pub fn is_free(&self, r: Region<'_>) -> bool {\n+        match *r {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// True if `r` is a free region or static of the sort that this\n+    /// free region map can be used with.\n+    pub fn is_free_or_static(&self, r: Region<'_>) -> bool {\n+        match *r {\n+            ty::ReStatic => true,\n+            _ => self.is_free(r),\n+        }\n+    }\n+\n     /// Computes the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n@@ -39,13 +89,13 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_b: Region<'tcx>,\n     ) -> Region<'tcx> {\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n-        assert!(is_free(r_a));\n-        assert!(is_free(r_b));\n+        assert!(self.is_free(r_a));\n+        assert!(self.is_free(r_b));\n         let result = if r_a == r_b {\n             r_a\n         } else {\n             match self.relation.postdom_upper_bound(&r_a, &r_b) {\n-                None => tcx.mk_region(ty::ReStatic),\n+                None => tcx.lifetimes.re_static,\n                 Some(r) => *r,\n             }\n         };\n@@ -60,31 +110,18 @@ impl<'tcx> FreeRegionMap<'tcx> {\n pub trait FreeRegionRelations<'tcx> {\n     /// Tests whether `r_a <= r_b`. Both must be free regions or\n     /// `'static`.\n-    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool;\n+    fn sub_free_regions(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        shorter: ty::Region<'tcx>,\n+        longer: ty::Region<'tcx>,\n+    ) -> bool;\n }\n \n impl<'tcx> FreeRegionRelations<'tcx> for FreeRegionMap<'tcx> {\n-    fn sub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n-        assert!(is_free_or_static(r_a) && is_free_or_static(r_b));\n-        if let ty::ReStatic = r_b {\n-            true // `'a <= 'static` is just always true, and not stored in the relation explicitly\n-        } else {\n-            r_a == r_b || self.relation.contains(&r_a, &r_b)\n-        }\n-    }\n-}\n-\n-fn is_free(r: Region<'_>) -> bool {\n-    match *r {\n-        ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n-        _ => false,\n-    }\n-}\n-\n-fn is_free_or_static(r: Region<'_>) -> bool {\n-    match *r {\n-        ty::ReStatic => true,\n-        _ => is_free(r),\n+    fn sub_free_regions(&self, tcx: TyCtxt<'tcx>, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n+        // invoke the \"inherent method\"\n+        self.sub_free_regions(tcx, r_a, r_b)\n     }\n }\n "}, {"sha": "0da680d1f915ee8c872640a41277d28a25e78276", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -1382,7 +1382,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n             ty::ReVar(_) | ty::ReScope(_) | ty::ReErased => false,\n \n-            ty::ReStatic | ty::ReEmpty | ty::ReClosureBound(_) => true,\n+            ty::ReStatic | ty::ReEmpty(_) | ty::ReClosureBound(_) => true,\n         }\n     }\n }\n@@ -1464,10 +1464,14 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n                 p!(write(\"'static\"));\n                 return Ok(self);\n             }\n-            ty::ReEmpty => {\n+            ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n                 p!(write(\"'<empty>\"));\n                 return Ok(self);\n             }\n+            ty::ReEmpty(ui) => {\n+                p!(write(\"'<empty:{:?}>\", ui));\n+                return Ok(self);\n+            }\n \n             // The user should never encounter these in unsubstituted form.\n             ty::ReClosureBound(vid) => {"}, {"sha": "acd6c9597518d361eafcd06e76eba44987039f1f", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -108,7 +108,7 @@ impl fmt::Debug for ty::RegionKind {\n \n             ty::RePlaceholder(placeholder) => write!(f, \"RePlaceholder({:?})\", placeholder),\n \n-            ty::ReEmpty => write!(f, \"ReEmpty\"),\n+            ty::ReEmpty(ui) => write!(f, \"ReEmpty({:?})\", ui),\n \n             ty::ReErased => write!(f, \"ReErased\"),\n         }"}, {"sha": "4c5bc3debde54ebb2945d6c55bc12e160788ddd3", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -1292,11 +1292,67 @@ rustc_index::newtype_index! {\n \n pub type Region<'tcx> = &'tcx RegionKind;\n \n-/// Representation of regions.\n+/// Representation of (lexical) regions. Note that the NLL checker\n+/// uses a distinct representation of regions. For this reason, it\n+/// internally replaces all the regions with inference variables --\n+/// the index of the variable is then used to index into internal NLL\n+/// data structures. See `rustc_mir::borrow_check` module for more\n+/// information.\n ///\n-/// Unlike types, most region variants are \"fictitious\", not concrete,\n-/// regions. Among these, `ReStatic`, `ReEmpty` and `ReScope` are the only\n-/// ones representing concrete regions.\n+/// ## The Region lattice within a given function\n+///\n+/// In general, the (lexical, and hence deprecated) region lattice\n+/// looks like\n+///\n+/// ```\n+/// static ----------+-----...------+       (greatest)\n+/// |                |              |\n+/// early-bound and  |              |\n+/// free regions     |              |\n+/// |                |              |\n+/// scope regions    |              |\n+/// |                |              |\n+/// empty(root)   placeholder(U1)   |\n+/// |            /                  |\n+/// |           /         placeholder(Un)\n+/// empty(U1) --         /\n+/// |                   /\n+/// ...                /\n+/// |                 /\n+/// empty(Un) --------                      (smallest)\n+/// ```\n+///\n+/// Early-bound/free regions are the named lifetimes in scope from the\n+/// function declaration. They have relationships to one another\n+/// determined based on the declared relationships from the\n+/// function. They all collectively outlive the scope regions. (See\n+/// `RegionRelations` type, and particularly\n+/// `crate::infer::outlives::free_region_map::FreeRegionMap`.)\n+///\n+/// The scope regions are related to one another based on the AST\n+/// structure. (See `RegionRelations` type, and particularly the\n+/// `rustc::middle::region::ScopeTree`.)\n+///\n+/// Note that inference variables and bound regions are not included\n+/// in this diagram. In the case of inference variables, they should\n+/// be inferred to some other region from the diagram.  In the case of\n+/// bound regions, they are excluded because they don't make sense to\n+/// include -- the diagram indicates the relationship between free\n+/// regions.\n+///\n+/// ## Inference variables\n+///\n+/// During region inference, we sometimes create inference variables,\n+/// represented as `ReVar`. These will be inferred by the code in\n+/// `infer::lexical_region_resolve` to some free region from the\n+/// lattice above (the minimal region that meets the\n+/// constraints).\n+///\n+/// During NLL checking, where regions are defined differently, we\n+/// also use `ReVar` -- in that case, the index is used to index into\n+/// the NLL region checker's data structures. The variable may in fact\n+/// represent either a free region or an inference variable, in that\n+/// case.\n ///\n /// ## Bound Regions\n ///\n@@ -1379,14 +1435,13 @@ pub enum RegionKind {\n     /// Should not exist after typeck.\n     RePlaceholder(ty::PlaceholderRegion),\n \n-    /// Empty lifetime is for data that is never accessed.\n-    /// Bottom in the region lattice. We treat ReEmpty somewhat\n-    /// specially; at least right now, we do not generate instances of\n-    /// it during the GLB computations, but rather\n-    /// generate an error instead. This is to improve error messages.\n-    /// The only way to get an instance of ReEmpty is to have a region\n-    /// variable with no constraints.\n-    ReEmpty,\n+    /// Empty lifetime is for data that is never accessed.  We tag the\n+    /// empty lifetime with a universe -- the idea is that we don't\n+    /// want `exists<'a> { forall<'b> { 'b: 'a } }` to be satisfiable.\n+    /// Therefore, the `'empty` in a universe `U` is less than all\n+    /// regions visible from `U`, but not less than regions not visible\n+    /// from `U`.\n+    ReEmpty(ty::UniverseIndex),\n \n     /// Erased region, used by trait selection, in MIR and during codegen.\n     ReErased,\n@@ -1635,7 +1690,7 @@ impl RegionKind {\n             RegionKind::ReStatic => true,\n             RegionKind::ReVar(..) => false,\n             RegionKind::RePlaceholder(placeholder) => placeholder.name.is_named(),\n-            RegionKind::ReEmpty => false,\n+            RegionKind::ReEmpty(_) => false,\n             RegionKind::ReErased => false,\n             RegionKind::ReClosureBound(..) => false,\n         }\n@@ -1718,7 +1773,7 @@ impl RegionKind {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_EARLY_BOUND;\n             }\n-            ty::ReEmpty | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n+            ty::ReEmpty(_) | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n             ty::ReErased => {}\n@@ -1728,7 +1783,7 @@ impl RegionKind {\n         }\n \n         match *self {\n-            ty::ReStatic | ty::ReEmpty | ty::ReErased | ty::ReLateBound(..) => (),\n+            ty::ReStatic | ty::ReEmpty(_) | ty::ReErased | ty::ReLateBound(..) => (),\n             _ => flags = flags | TypeFlags::HAS_FREE_LOCAL_NAMES,\n         }\n "}, {"sha": "1dfe97238a3df8b7f6235f08b0383733d7e86992", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -574,6 +574,14 @@ impl<I: Idx, T> IndexVec<I, T> {\n         IndexVec { raw: vec![elem; n], _marker: PhantomData }\n     }\n \n+    /// Create an `IndexVec` with `n` elements, where the value of each\n+    /// element is the result of `func(i)`\n+    #[inline]\n+    pub fn from_fn_n(func: impl FnMut(I) -> T, n: usize) -> Self {\n+        let indices = (0..n).map(I::new);\n+        Self::from_raw(indices.map(func).collect())\n+    }\n+\n     #[inline]\n     pub fn push(&mut self, d: T) -> I {\n         let idx = I::new(self.len());"}, {"sha": "09d61d9ad9ad130e5836cc98b4c6137c89ebc583", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -291,7 +291,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReErased\n             | ty::ReClosureBound(..) => None,\n         }"}, {"sha": "6abca481eac9c12302c09bb9b381a175079ccdd8", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -1108,6 +1108,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 self.eval_if_eq(tcx, body, generic_ty, lower_bound, test_ty, verify_bound1)\n             }\n \n+            VerifyBound::IsEmpty => {\n+                let lower_bound_scc = self.constraint_sccs.scc(lower_bound);\n+                self.scc_values.elements_contained_in(lower_bound_scc).next().is_none()\n+            }\n+\n             VerifyBound::OutlivedBy(r) => {\n                 let r_vid = self.to_region_vid(r);\n                 self.eval_outlives(r_vid, lower_bound)"}, {"sha": "a3e38cd7a5f856deb6096b0e62e08e00cf76ec72", "filename": "src/librustc_mir/borrow_check/type_check/constraint_conversion.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -160,7 +160,8 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) {\n-        if let ty::ReEmpty = a {\n+        // FIXME -- this is not the fix I would prefer\n+        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = a {\n             return;\n         }\n         let b = self.to_region_vid(b);\n@@ -175,7 +176,8 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         bound: VerifyBound<'tcx>,\n     ) {\n-        if let ty::ReEmpty = a {\n+        // FIXME: I'd prefer if NLL had a notion of empty\n+        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = a {\n             return;\n         }\n         let type_test = self.verify_to_type_test(kind, a, bound);"}, {"sha": "cf8c3449d666be4476f3fc2df59c868c02f2b2cd", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::ConstraintCategory;\n use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n use rustc::traits::query::type_op::{self, TypeOp};\n use rustc::ty::free_region_map::FreeRegionRelations;\n-use rustc::ty::{self, RegionVid, Ty};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_span::DUMMY_SP;\n use std::rc::Rc;\n@@ -333,7 +333,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                     // `where Type:` is lowered to `where Type: 'empty` so that\n                     // we check `Type` is well formed, but there's no use for\n                     // this bound here.\n-                    if let ty::ReEmpty = r1 {\n+                    if let ty::ReEmpty(_) = r1 {\n                         return;\n                     }\n \n@@ -359,7 +359,12 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n /// over the `FreeRegionMap` from lexical regions and\n /// `UniversalRegions` (from NLL)`.\n impl<'tcx> FreeRegionRelations<'tcx> for UniversalRegionRelations<'tcx> {\n-    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool {\n+    fn sub_free_regions(\n+        &self,\n+        _tcx: TyCtxt<'tcx>,\n+        shorter: ty::Region<'tcx>,\n+        longer: ty::Region<'tcx>,\n+    ) -> bool {\n         let shorter = shorter.to_region_vid();\n         assert!(self.universal_regions.is_universal_region(shorter));\n         let longer = longer.to_region_vid();"}, {"sha": "5a360b40d61b576fdd2fd7e064711c0cd8328569", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -260,6 +260,16 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    pub COHERENCE_LEAK_CHECK,\n+    Warn,\n+    \"distinct impls distinguished only by the leak-check code\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #56105 <https://github.com/rust-lang/rust/issues/56105>\",\n+        edition: None,\n+    };\n+}\n+\n declare_lint! {\n     pub DEPRECATED,\n     Warn,\n@@ -515,6 +525,7 @@ declare_lint_pass! {\n         MISSING_FRAGMENT_SPECIFIER,\n         LATE_BOUND_LIFETIME_ARGUMENTS,\n         ORDER_DEPENDENT_TRAIT_OBJECTS,\n+        COHERENCE_LEAK_CHECK,\n         DEPRECATED,\n         UNUSED_UNSAFE,\n         UNUSED_MUT,"}, {"sha": "301ebf8adc5c700086ba7977bc8d5dab4b80b29c", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -246,9 +246,11 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n                 assert_eq!(a_bound.assert_bound_var(), b_bound.assert_bound_var());\n             }\n \n-            (ty::ReStatic, ty::ReStatic)\n-            | (ty::ReErased, ty::ReErased)\n-            | (ty::ReEmpty, ty::ReEmpty) => (),\n+            (ty::ReStatic, ty::ReStatic) | (ty::ReErased, ty::ReErased) => (),\n+\n+            (ty::ReEmpty(a_ui), ty::ReEmpty(b_ui)) => {\n+                assert_eq!(a_ui, b_ui);\n+            }\n \n             (&ty::ReFree(a_free), &ty::ReFree(b_free)) => {\n                 assert_eq!(a_free, b_free);"}, {"sha": "3e17b661cf4cea49d55f17fe8f3267c54358ed79", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -1,5 +1,5 @@\n use crate::namespace::Namespace;\n-use rustc::traits::{self, IntercrateMode};\n+use rustc::traits::{self, IntercrateMode, SkipLeakCheck};\n use rustc::ty::TyCtxt;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -76,6 +76,9 @@ impl InherentOverlapChecker<'tcx> {\n                     impl1_def_id,\n                     impl2_def_id,\n                     IntercrateMode::Issue43355,\n+                    // We go ahead and just skip the leak check for\n+                    // inherent impls without warning.\n+                    SkipLeakCheck::Yes,\n                     |overlap| {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id, overlap);\n                         false"}, {"sha": "2a450f4b4e8b1852e7f1c9d1f9f68a35a5d38ae8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -2324,7 +2324,8 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         // compiler/tooling bugs from not handling WF predicates.\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n-                        let predicate = ty::OutlivesPredicate(ty, tcx.mk_region(ty::ReEmpty));\n+                        let re_root_empty = tcx.lifetimes.re_root_empty;\n+                        let predicate = ty::OutlivesPredicate(ty, re_root_empty);\n                         predicates.push((\n                             ty::Predicate::TypeOutlives(ty::Binder::dummy(predicate)),\n                             span,"}, {"sha": "0cc322f8c2d3da900a4d66542a44106acc02f619", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -166,7 +166,7 @@ fn is_free_region(tcx: TyCtxt<'_>, region: Region<'_>) -> bool {\n         //\n         //     struct Bar<T>(<Self as Foo>::Type) where Self: ;\n         //     struct Baz<'a>(&'a Self) where Self: ;\n-        RegionKind::ReEmpty => false,\n+        RegionKind::ReEmpty(_) => false,\n \n         // These regions don't appear in types from type declarations:\n         RegionKind::ReErased"}, {"sha": "6f5caea250b0719efda46dc9f36d521b529f132b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -453,7 +453,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types."}, {"sha": "f140f11b090980ec295ba17176dfee9013440354", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -447,7 +447,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReClosureBound(_)\n             | ty::ReErased => {\n                 debug!(\"cannot clean region {:?}\", self);\n@@ -521,7 +521,7 @@ impl<'tcx> Clean<Option<WherePredicate>>\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n \n         match (a, b) {\n-            (ty::ReEmpty, ty::ReEmpty) => {\n+            (ty::ReEmpty(_), ty::ReEmpty(_)) => {\n                 return None;\n             }\n             _ => {}\n@@ -539,7 +539,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n \n         match lt {\n-            ty::ReEmpty => return None,\n+            ty::ReEmpty(_) => return None,\n             _ => {}\n         }\n "}, {"sha": "6ea0b89be74d334a74ff804c66013cc5e9b2eb57", "filename": "src/test/ui/coherence/coherence-inherited-subtyping.old.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.old.stderr?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -0,0 +1,14 @@\n+error[E0592]: duplicate definitions with name `method1`\n+  --> $DIR/coherence-inherited-subtyping.rs:14:5\n+   |\n+LL |     fn method1(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `method1`\n+...\n+LL |     fn method1(&self) {}\n+   |     -------------------- other definition for `method1`\n+   |\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0592`."}, {"sha": "6ea0b89be74d334a74ff804c66013cc5e9b2eb57", "filename": "src/test/ui/coherence/coherence-inherited-subtyping.re.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.re.stderr?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -0,0 +1,14 @@\n+error[E0592]: duplicate definitions with name `method1`\n+  --> $DIR/coherence-inherited-subtyping.rs:14:5\n+   |\n+LL |     fn method1(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `method1`\n+...\n+LL |     fn method1(&self) {}\n+   |     -------------------- other definition for `method1`\n+   |\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0592`."}, {"sha": "8587eb77950c7a290080387b42072816c382c5a5", "filename": "src/test/ui/coherence/coherence-inherited-subtyping.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -0,0 +1,21 @@\n+// Test that two distinct impls which match subtypes of one another\n+// yield coherence errors (or not) depending on the variance.\n+//\n+// Note: This scenario is currently accepted, but as part of the\n+// universe transition (#56105) may eventually become an error.\n+\n+// revisions: old re\n+\n+struct Foo<T> {\n+    t: T,\n+}\n+\n+impl Foo<for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8> {\n+    fn method1(&self) {} //~ ERROR duplicate definitions with name `method1`\n+}\n+\n+impl Foo<for<'a> fn(&'a u8, &'a u8) -> &'a u8> {\n+    fn method1(&self) {}\n+}\n+\n+fn main() {}"}, {"sha": "76f5cc1b782325730c720e8643ee817a712e289f", "filename": "src/test/ui/coherence/coherence-subtyping.old.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.old.stderr?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -0,0 +1,14 @@\n+warning: conflicting implementations of trait `TheTrait` for type `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`:\n+  --> $DIR/coherence-subtyping.rs:16:1\n+   |\n+LL | impl TheTrait for for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8 {}\n+   | ---------------------------------------------------------- first implementation here\n+LL | \n+LL | impl TheTrait for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`\n+   |\n+   = note: `#[warn(coherence_leak_check)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56105 <https://github.com/rust-lang/rust/issues/56105>\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+"}, {"sha": "76f5cc1b782325730c720e8643ee817a712e289f", "filename": "src/test/ui/coherence/coherence-subtyping.re.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.re.stderr?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -0,0 +1,14 @@\n+warning: conflicting implementations of trait `TheTrait` for type `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`:\n+  --> $DIR/coherence-subtyping.rs:16:1\n+   |\n+LL | impl TheTrait for for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8 {}\n+   | ---------------------------------------------------------- first implementation here\n+LL | \n+LL | impl TheTrait for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`\n+   |\n+   = note: `#[warn(coherence_leak_check)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56105 <https://github.com/rust-lang/rust/issues/56105>\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+"}, {"sha": "f5c1d92411baafb0dbfa61520298f003ebf15965", "filename": "src/test/ui/coherence/coherence-subtyping.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -5,16 +5,19 @@\n // universe transition (#56105) may eventually become an error.\n \n // revisions: old re\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n \n trait TheTrait {\n-    fn foo(&self) { }\n+    fn foo(&self) {}\n }\n \n-impl TheTrait for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n-}\n+impl TheTrait for for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8 {}\n \n impl TheTrait for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n+    //[re]~^ WARNING conflicting implementation\n+    //[re]~^^ WARNING this was previously accepted by the compiler but is being phased out\n+    //[old]~^^^ WARNING conflicting implementation\n+    //[old]~^^^^ WARNING this was previously accepted by the compiler but is being phased out\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "2f18f600b753f7c1ce48c42aae9bef35eab18dbc", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs?ref=8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "patch": "@@ -36,7 +36,7 @@ where\n     T: Anything<'b, 'c>,\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ ERROR associated type `<T as Anything<'_#5r, '_#6r>>::AssocType` may not live long enough\n+    //~^ ERROR may not live long enough\n }\n \n #[rustc_regions]\n@@ -46,7 +46,7 @@ where\n     'a: 'a,\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ ERROR associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n+    //~^ ERROR may not live long enough\n }\n \n #[rustc_regions]"}]}