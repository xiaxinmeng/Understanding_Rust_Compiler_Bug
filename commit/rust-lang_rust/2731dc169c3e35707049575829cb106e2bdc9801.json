{"sha": "2731dc169c3e35707049575829cb106e2bdc9801", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MzFkYzE2OWMzZTM1NzA3MDQ5NTc1ODI5Y2IxMDZlMmJkYzk4MDE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-03-22T03:02:09Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-03-22T20:26:32Z"}, "message": "Error recovery in the tokeniser\n\nCloses #31994", "tree": {"sha": "a5195d634c61b0d909c91e8ae9b9c80d06e147bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5195d634c61b0d909c91e8ae9b9c80d06e147bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2731dc169c3e35707049575829cb106e2bdc9801", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2731dc169c3e35707049575829cb106e2bdc9801", "html_url": "https://github.com/rust-lang/rust/commit/2731dc169c3e35707049575829cb106e2bdc9801", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2731dc169c3e35707049575829cb106e2bdc9801/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ee841c3351326a7bea83b689f54d9fee27e6e85", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee841c3351326a7bea83b689f54d9fee27e6e85", "html_url": "https://github.com/rust-lang/rust/commit/3ee841c3351326a7bea83b689f54d9fee27e6e85"}], "stats": {"total": 83, "additions": 58, "deletions": 25}, "files": [{"sha": "3010c040914df401a53bf24b148d191914c663ec", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2731dc169c3e35707049575829cb106e2bdc9801/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2731dc169c3e35707049575829cb106e2bdc9801/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2731dc169c3e35707049575829cb106e2bdc9801", "patch": "@@ -268,8 +268,8 @@ pub struct Parser<'a> {\n     /// Used to determine the path to externally loaded source files\n     pub filename: Option<String>,\n     pub mod_path_stack: Vec<InternedString>,\n-    /// Stack of spans of open delimiters. Used for error message.\n-    pub open_braces: Vec<Span>,\n+    /// Stack of open delimiters and their spans. Used for error message.\n+    pub open_braces: Vec<(token::DelimToken, Span)>,\n     /// Flag if this parser \"owns\" the directory that it is currently parsing\n     /// in. This will affect how nested files are looked up.\n     pub owns_directory: bool,\n@@ -895,7 +895,7 @@ impl<'a> Parser<'a> {\n                                          sep: SeqSep,\n                                          f: F)\n                                          -> Vec<T>\n-        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>\n     {\n         self.parse_seq_to_before_tokens(&[ket], sep, f, |mut e| e.emit())\n     }\n@@ -2755,8 +2755,8 @@ impl<'a> Parser<'a> {\n                 let mut err: DiagnosticBuilder<'a> =\n                     self.diagnostic().struct_span_err(self.span,\n                                                       \"this file contains an un-closed delimiter\");\n-                for sp in &self.open_braces {\n-                    err.span_help(*sp, \"did you mean to close this delimiter?\");\n+                for &(_, sp) in &self.open_braces {\n+                    err.span_help(sp, \"did you mean to close this delimiter?\");\n                 }\n \n                 Err(err)\n@@ -2766,23 +2766,66 @@ impl<'a> Parser<'a> {\n                 let pre_span = self.span;\n \n                 // Parse the open delimiter.\n-                self.open_braces.push(self.span);\n+                self.open_braces.push((delim, self.span));\n                 let open_span = self.span;\n                 self.bump();\n \n-                // Parse the token trees within the delimiters\n-                let tts = self.parse_seq_to_before_end(&token::CloseDelim(delim),\n-                                                       SeqSep::none(),\n-                                                       |p| p.parse_token_tree());\n+                // Parse the token trees within the delimiters.\n+                // We stop at any delimiter so we can try to recover if the user\n+                // uses an incorrect delimiter.\n+                let tts = self.parse_seq_to_before_tokens(&[&token::CloseDelim(token::Brace),\n+                                                            &token::CloseDelim(token::Paren),\n+                                                            &token::CloseDelim(token::Bracket)],\n+                                                          SeqSep::none(),\n+                                                          |p| p.parse_token_tree(),\n+                                                          |mut e| e.emit());\n \n-                // Parse the close delimiter.\n                 let close_span = self.span;\n-                self.bump();\n-                self.open_braces.pop().unwrap();\n-\n                 // Expand to cover the entire delimited token tree\n                 let span = Span { hi: close_span.hi, ..pre_span };\n \n+                match self.token {\n+                    // Correct delmiter.\n+                    token::CloseDelim(d) if d == delim => {\n+                        self.open_braces.pop().unwrap();\n+\n+                        // Parse the close delimiter.\n+                        self.bump();\n+                    }\n+                    // Incorect delimiter.\n+                    token::CloseDelim(other) => {\n+                        let token_str = self.this_token_to_string();\n+                        let mut err = self.diagnostic().struct_span_err(self.span,\n+                            &format!(\"incorrect close delimiter: `{}`\", token_str));\n+                        // This is a conservative error: only report the last unclosed delimiter.\n+                        // The previous unclosed delimiters could actually be closed! The parser\n+                        // just hasn't gotten to them yet.\n+                        if let Some(&(_, sp)) = self.open_braces.last() {\n+                            err.span_note(sp, \"unclosed delimiter\");\n+                        };\n+                        err.emit();\n+\n+                        self.open_braces.pop().unwrap();\n+\n+                        // If the incorrect delimter matches an earlier opening\n+                        // delimiter, then don't consume it (it can be used to\n+                        // close the earlier one)Otherwise, consume it.\n+                        // E.g., we try to recover from:\n+                        // fn foo() {\n+                        //     bar(baz(\n+                        // }  // Incorrect delimiter but matches the earlier `{`\n+                        if !self.open_braces.iter().any(|&(b, _)| b == other) {\n+                            self.bump();\n+                        }\n+                    }\n+                    token::Eof => {\n+                        // Silently recover, the EOF token will be seen again\n+                        // and an error emitted then. Thus we don't pop from\n+                        // self.open_braces here.\n+                    },\n+                    _ => unreachable!(),\n+                }\n+\n                 Ok(TokenTree::Delimited(span, Rc::new(Delimited {\n                     delim: delim,\n                     open_span: open_span,\n@@ -2798,17 +2841,7 @@ impl<'a> Parser<'a> {\n                 maybe_whole!(deref self, NtTT);\n                 match self.token {\n                     token::CloseDelim(_) => {\n-                        let token_str = self.this_token_to_string();\n-                        let mut err = self.diagnostic().struct_span_err(self.span,\n-                            &format!(\"incorrect close delimiter: `{}`\", token_str));\n-                        // This is a conservative error: only report the last unclosed delimiter.\n-                        // The previous unclosed delimiters could actually be closed! The parser\n-                        // just hasn't gotten to them yet.\n-                        if let Some(&sp) = self.open_braces.last() {\n-                            err.span_note(sp, \"unclosed delimiter\");\n-                        };\n-\n-                        Err(err)\n+                        panic!(\"should have been caught above\");\n                     },\n                     /* we ought to allow different depths of unquotation */\n                     token::Dollar | token::SubstNt(..) if self.quote_depth > 0 => {"}]}