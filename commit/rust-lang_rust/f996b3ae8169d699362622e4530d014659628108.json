{"sha": "f996b3ae8169d699362622e4530d014659628108", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5OTZiM2FlODE2OWQ2OTkzNjI2MjJlNDUzMGQwMTQ2NTk2MjgxMDg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-20T00:37:09Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-20T02:08:32Z"}, "message": "core: Split local_data into local_data/local_data_priv", "tree": {"sha": "e0ff18f685973fe40a9e37874a561b0b7e9d742d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0ff18f685973fe40a9e37874a561b0b7e9d742d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f996b3ae8169d699362622e4530d014659628108", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f996b3ae8169d699362622e4530d014659628108", "html_url": "https://github.com/rust-lang/rust/commit/f996b3ae8169d699362622e4530d014659628108", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f996b3ae8169d699362622e4530d014659628108/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1397dca2dd07b93789226a22b2ccc456d0a5317a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1397dca2dd07b93789226a22b2ccc456d0a5317a", "html_url": "https://github.com/rust-lang/rust/commit/1397dca2dd07b93789226a22b2ccc456d0a5317a"}], "stats": {"total": 332, "additions": 169, "deletions": 163}, "files": [{"sha": "3a93d069ab8006221d565737790ef2a3bde9fb56", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f996b3ae8169d699362622e4530d014659628108/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f996b3ae8169d699362622e4530d014659628108/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=f996b3ae8169d699362622e4530d014659628108", "patch": "@@ -221,6 +221,7 @@ mod send_map;\n mod comm;\n mod task {\n     mod local_data;\n+    mod local_data_priv;\n }\n mod future;\n mod pipes;"}, {"sha": "1660a94e3f124fbf2ef4b888322f7d8e0dc5a4a6", "filename": "src/libcore/task.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f996b3ae8169d699362622e4530d014659628108/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b3ae8169d699362622e4530d014659628108/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=f996b3ae8169d699362622e4530d014659628108", "patch": "@@ -30,6 +30,7 @@\n use cmp::Eq;\n use result::Result;\n use pipes::{stream, Chan, Port};\n+use local_data_priv::{local_get, local_set};\n \n export Task;\n export TaskResult;\n@@ -1209,7 +1210,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     /*######################################################################*\n      * Step 1. Get spawner's taskgroup info.\n      *######################################################################*/\n-    let spawner_group = match unsafe { local_data::local_get(spawner,\n+    let spawner_group = match unsafe { local_get(spawner,\n                                                  taskgroup_key!()) } {\n         None => {\n             // Main task, doing first spawn ever. Lazily initialise here.\n@@ -1222,7 +1223,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             let group =\n                 @TCB(spawner, move tasks, AncestorList(None), true, None);\n             unsafe {\n-                local_data::local_set(spawner, taskgroup_key!(), group);\n+                local_set(spawner, taskgroup_key!(), group);\n             }\n             group\n         }\n@@ -1351,7 +1352,7 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n                 let group = @TCB(child, move child_arc, move ancestors,\n                                  is_main, move notifier);\n                 unsafe {\n-                    local_data::local_set(child, taskgroup_key!(), group);\n+                    local_set(child, taskgroup_key!(), group);\n                 }\n \n                 // Run the child's body."}, {"sha": "eefdb9eceee7b7cd81fc51d635201c05dca35b31", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 7, "deletions": 160, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/f996b3ae8169d699362622e4530d014659628108/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b3ae8169d699362622e4530d014659628108/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=f996b3ae8169d699362622e4530d014659628108", "patch": "@@ -14,15 +14,18 @@ Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation magic.\n \n */\n \n-export local_data_key;\n+export LocalDataKey;\n export local_data_pop;\n export local_data_get;\n export local_data_set;\n export local_data_modify;\n \n-// XXX: These shouldn't be exported but they are used by task.rs\n-export local_get;\n-export local_set;\n+use local_data_priv::{\n+    local_pop,\n+    local_get,\n+    local_set,\n+    local_modify\n+};\n \n /**\n  * Indexes a task-local data slot. The function's code pointer is used for\n@@ -40,162 +43,6 @@ export local_set;\n  */\n type LocalDataKey<T: Owned> = &fn(+@T);\n \n-trait LocalData { }\n-impl<T: Owned> @T: LocalData { }\n-\n-impl LocalData: Eq {\n-    pure fn eq(&&other: LocalData) -> bool unsafe {\n-        let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n-        let ptr_b: (uint, uint) = cast::reinterpret_cast(&other);\n-        return ptr_a == ptr_b;\n-    }\n-    pure fn ne(&&other: LocalData) -> bool { !self.eq(other) }\n-}\n-\n-// We use dvec because it's the best data structure in core. If TLS is used\n-// heavily in future, this could be made more efficient with a proper map.\n-type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n-// Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n-\n-extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n-    assert !map_ptr.is_null();\n-    // Get and keep the single reference that was created at the beginning.\n-    let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n-    // All local_data will be destroyed along with the map.\n-}\n-\n-// Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n-\n-    // Relies on the runtime initialising the pointer to null.\n-    // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n-    // we retrieve it for get/set, we make another reference, which get/set\n-    // drop when they finish. No \"re-storing after modifying\" is needed.\n-    let map_ptr = rustrt::rust_get_task_local_data(task);\n-    if map_ptr.is_null() {\n-        let map: TaskLocalMap = @dvec::DVec();\n-        // Use reinterpret_cast -- transmute would take map away from us also.\n-        rustrt::rust_set_task_local_data(\n-            task, cast::reinterpret_cast(&map));\n-        rustrt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n-        // Also need to reference it an extra time to keep it for now.\n-        cast::bump_box_refcount(map);\n-        map\n-    } else {\n-        let map = cast::transmute(move map_ptr);\n-        cast::bump_box_refcount(map);\n-        map\n-    }\n-}\n-\n-unsafe fn key_to_key_value<T: Owned>(\n-    key: LocalDataKey<T>) -> *libc::c_void {\n-\n-    // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n-    // Use reintepret_cast -- transmute would leak (forget) the closure.\n-    let pair: (*libc::c_void, *libc::c_void) = cast::reinterpret_cast(&key);\n-    pair.first()\n-}\n-\n-// If returning Some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T: Owned>(\n-    map: TaskLocalMap, key: LocalDataKey<T>)\n-    -> Option<(uint, *libc::c_void)> {\n-\n-    let key_value = key_to_key_value(key);\n-    let map_pos = (*map).position(|entry|\n-        match entry {\n-            Some((k,_,_)) => k == key_value,\n-            None => false\n-        }\n-    );\n-    do map_pos.map |index| {\n-        // .get() is guaranteed because of \"None { false }\" above.\n-        let (_, data_ptr, _) = (*map)[index].get();\n-        (index, data_ptr)\n-    }\n-}\n-\n-unsafe fn local_get_helper<T: Owned>(\n-    task: *rust_task, key: LocalDataKey<T>,\n-    do_pop: bool) -> Option<@T> {\n-\n-    let map = get_task_local_map(task);\n-    // Interpreturn our findings from the map\n-    do local_data_lookup(map, key).map |result| {\n-        // A reference count magically appears on 'data' out of thin air. It\n-        // was referenced in the local_data box, though, not here, so before\n-        // overwriting the local_data_box we need to give an extra reference.\n-        // We must also give an extra reference when not removing.\n-        let (index, data_ptr) = result;\n-        let data: @T = cast::transmute(move data_ptr);\n-        cast::bump_box_refcount(data);\n-        if do_pop {\n-            (*map).set_elt(index, None);\n-        }\n-        data\n-    }\n-}\n-\n-unsafe fn local_pop<T: Owned>(\n-    task: *rust_task,\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_get_helper(task, key, true)\n-}\n-\n-unsafe fn local_get<T: Owned>(\n-    task: *rust_task,\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_get_helper(task, key, false)\n-}\n-\n-unsafe fn local_set<T: Owned>(\n-    task: *rust_task, key: LocalDataKey<T>, +data: @T) {\n-\n-    let map = get_task_local_map(task);\n-    // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n-    let keyval = key_to_key_value(key);\n-    // We keep the data in two forms: one as an unsafe pointer, so we can get\n-    // it back by casting; another in an existential box, so the reference we\n-    // own on it can be dropped when the box is destroyed. The unsafe pointer\n-    // does not have a reference associated with it, so it may become invalid\n-    // when the box is destroyed.\n-    let data_ptr = cast::reinterpret_cast(&data);\n-    let data_box = data as LocalData;\n-    // Construct new entry to store in the map.\n-    let new_entry = Some((keyval, data_ptr, data_box));\n-    // Find a place to put it.\n-    match local_data_lookup(map, key) {\n-        Some((index, _old_data_ptr)) => {\n-            // Key already had a value set, _old_data_ptr, whose reference\n-            // will get dropped when the local_data box is overwritten.\n-            (*map).set_elt(index, new_entry);\n-        }\n-        None => {\n-            // Find an empty slot. If not, grow the vector.\n-            match (*map).position(|x| x.is_none()) {\n-                Some(empty_index) => (*map).set_elt(empty_index, new_entry),\n-                None => (*map).push(new_entry)\n-            }\n-        }\n-    }\n-}\n-\n-unsafe fn local_modify<T: Owned>(\n-    task: *rust_task, key: LocalDataKey<T>,\n-    modify_fn: fn(Option<@T>) -> Option<@T>) {\n-\n-    // Could be more efficient by doing the lookup work, but this is easy.\n-    let newdata = modify_fn(local_pop(task, key));\n-    if newdata.is_some() {\n-        local_set(task, key, option::unwrap(move newdata));\n-    }\n-}\n-\n-/* Exported interface for task-local data (plus local_data_key above). */\n /**\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it."}, {"sha": "640ea3577b33da50bdaac579acc798cafc6451ef", "filename": "src/libcore/task/local_data_priv.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/f996b3ae8169d699362622e4530d014659628108/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f996b3ae8169d699362622e4530d014659628108/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=f996b3ae8169d699362622e4530d014659628108", "patch": "@@ -0,0 +1,157 @@\n+use local_data::LocalDataKey;\n+\n+trait LocalData { }\n+impl<T: Owned> @T: LocalData { }\n+\n+impl LocalData: Eq {\n+    pure fn eq(&&other: LocalData) -> bool unsafe {\n+        let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n+        let ptr_b: (uint, uint) = cast::reinterpret_cast(&other);\n+        return ptr_a == ptr_b;\n+    }\n+    pure fn ne(&&other: LocalData) -> bool { !self.eq(other) }\n+}\n+\n+// We use dvec because it's the best data structure in core. If TLS is used\n+// heavily in future, this could be made more efficient with a proper map.\n+type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n+// Has to be a pointer at outermost layer; the foreign call returns void *.\n+type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n+\n+extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n+    assert !map_ptr.is_null();\n+    // Get and keep the single reference that was created at the beginning.\n+    let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n+    // All local_data will be destroyed along with the map.\n+}\n+\n+// Gets the map from the runtime. Lazily initialises if not done so already.\n+unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n+\n+    // Relies on the runtime initialising the pointer to null.\n+    // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n+    // we retrieve it for get/set, we make another reference, which get/set\n+    // drop when they finish. No \"re-storing after modifying\" is needed.\n+    let map_ptr = rustrt::rust_get_task_local_data(task);\n+    if map_ptr.is_null() {\n+        let map: TaskLocalMap = @dvec::DVec();\n+        // Use reinterpret_cast -- transmute would take map away from us also.\n+        rustrt::rust_set_task_local_data(\n+            task, cast::reinterpret_cast(&map));\n+        rustrt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n+        // Also need to reference it an extra time to keep it for now.\n+        cast::bump_box_refcount(map);\n+        map\n+    } else {\n+        let map = cast::transmute(move map_ptr);\n+        cast::bump_box_refcount(map);\n+        map\n+    }\n+}\n+\n+unsafe fn key_to_key_value<T: Owned>(\n+    key: LocalDataKey<T>) -> *libc::c_void {\n+\n+    // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n+    // Use reintepret_cast -- transmute would leak (forget) the closure.\n+    let pair: (*libc::c_void, *libc::c_void) = cast::reinterpret_cast(&key);\n+    pair.first()\n+}\n+\n+// If returning Some(..), returns with @T with the map's reference. Careful!\n+unsafe fn local_data_lookup<T: Owned>(\n+    map: TaskLocalMap, key: LocalDataKey<T>)\n+    -> Option<(uint, *libc::c_void)> {\n+\n+    let key_value = key_to_key_value(key);\n+    let map_pos = (*map).position(|entry|\n+        match entry {\n+            Some((k,_,_)) => k == key_value,\n+            None => false\n+        }\n+    );\n+    do map_pos.map |index| {\n+        // .get() is guaranteed because of \"None { false }\" above.\n+        let (_, data_ptr, _) = (*map)[index].get();\n+        (index, data_ptr)\n+    }\n+}\n+\n+unsafe fn local_get_helper<T: Owned>(\n+    task: *rust_task, key: LocalDataKey<T>,\n+    do_pop: bool) -> Option<@T> {\n+\n+    let map = get_task_local_map(task);\n+    // Interpreturn our findings from the map\n+    do local_data_lookup(map, key).map |result| {\n+        // A reference count magically appears on 'data' out of thin air. It\n+        // was referenced in the local_data box, though, not here, so before\n+        // overwriting the local_data_box we need to give an extra reference.\n+        // We must also give an extra reference when not removing.\n+        let (index, data_ptr) = result;\n+        let data: @T = cast::transmute(move data_ptr);\n+        cast::bump_box_refcount(data);\n+        if do_pop {\n+            (*map).set_elt(index, None);\n+        }\n+        data\n+    }\n+}\n+\n+\n+unsafe fn local_pop<T: Owned>(\n+    task: *rust_task,\n+    key: LocalDataKey<T>) -> Option<@T> {\n+\n+    local_get_helper(task, key, true)\n+}\n+\n+unsafe fn local_get<T: Owned>(\n+    task: *rust_task,\n+    key: LocalDataKey<T>) -> Option<@T> {\n+\n+    local_get_helper(task, key, false)\n+}\n+\n+unsafe fn local_set<T: Owned>(\n+    task: *rust_task, key: LocalDataKey<T>, +data: @T) {\n+\n+    let map = get_task_local_map(task);\n+    // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n+    let keyval = key_to_key_value(key);\n+    // We keep the data in two forms: one as an unsafe pointer, so we can get\n+    // it back by casting; another in an existential box, so the reference we\n+    // own on it can be dropped when the box is destroyed. The unsafe pointer\n+    // does not have a reference associated with it, so it may become invalid\n+    // when the box is destroyed.\n+    let data_ptr = cast::reinterpret_cast(&data);\n+    let data_box = data as LocalData;\n+    // Construct new entry to store in the map.\n+    let new_entry = Some((keyval, data_ptr, data_box));\n+    // Find a place to put it.\n+    match local_data_lookup(map, key) {\n+        Some((index, _old_data_ptr)) => {\n+            // Key already had a value set, _old_data_ptr, whose reference\n+            // will get dropped when the local_data box is overwritten.\n+            (*map).set_elt(index, new_entry);\n+        }\n+        None => {\n+            // Find an empty slot. If not, grow the vector.\n+            match (*map).position(|x| x.is_none()) {\n+                Some(empty_index) => (*map).set_elt(empty_index, new_entry),\n+                None => (*map).push(new_entry)\n+            }\n+        }\n+    }\n+}\n+\n+unsafe fn local_modify<T: Owned>(\n+    task: *rust_task, key: LocalDataKey<T>,\n+    modify_fn: fn(Option<@T>) -> Option<@T>) {\n+\n+    // Could be more efficient by doing the lookup work, but this is easy.\n+    let newdata = modify_fn(local_pop(task, key));\n+    if newdata.is_some() {\n+        local_set(task, key, option::unwrap(move newdata));\n+    }\n+}"}]}