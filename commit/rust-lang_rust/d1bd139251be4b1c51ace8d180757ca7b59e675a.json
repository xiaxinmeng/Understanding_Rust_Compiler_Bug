{"sha": "d1bd139251be4b1c51ace8d180757ca7b59e675a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxYmQxMzkyNTFiZTRiMWM1MWFjZThkMTgwNzU3Y2E3YjU5ZTY3NWE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-09-05T07:39:15Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-09-06T17:58:30Z"}, "message": "fix sized deallocation for Box<[T]>", "tree": {"sha": "9059378b02e36e3c17666e418767825e2834ad68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9059378b02e36e3c17666e418767825e2834ad68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1bd139251be4b1c51ace8d180757ca7b59e675a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1bd139251be4b1c51ace8d180757ca7b59e675a", "html_url": "https://github.com/rust-lang/rust/commit/d1bd139251be4b1c51ace8d180757ca7b59e675a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1bd139251be4b1c51ace8d180757ca7b59e675a/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aa2da013356e814204a0bd5751dbabb71307213", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa2da013356e814204a0bd5751dbabb71307213", "html_url": "https://github.com/rust-lang/rust/commit/5aa2da013356e814204a0bd5751dbabb71307213"}], "stats": {"total": 96, "additions": 77, "deletions": 19}, "files": [{"sha": "cdfb8e48a460e443d8c462655bc2937eb215a910", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d1bd139251be4b1c51ace8d180757ca7b59e675a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1bd139251be4b1c51ace8d180757ca7b59e675a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=d1bd139251be4b1c51ace8d180757ca7b59e675a", "patch": "@@ -340,6 +340,27 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n+    fn schedule_free_slice(&self,\n+                           cleanup_scope: ScopeId,\n+                           val: ValueRef,\n+                           size: ValueRef,\n+                           align: ValueRef,\n+                           heap: Heap) {\n+        /*!\n+         * Schedules a call to `free(val)`. Note that this is a shallow\n+         * operation.\n+         */\n+\n+        let drop = box FreeSlice { ptr: val, size: size, align: align, heap: heap };\n+\n+        debug!(\"schedule_free_slice({:?}, val={}, heap={:?})\",\n+               cleanup_scope,\n+               self.ccx.tn().val_to_string(val),\n+               heap);\n+\n+        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n+    }\n+\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n                       cleanup: CleanupObj) {\n@@ -926,6 +947,34 @@ impl Cleanup for FreeValue {\n     }\n }\n \n+pub struct FreeSlice {\n+    ptr: ValueRef,\n+    size: ValueRef,\n+    align: ValueRef,\n+    heap: Heap,\n+}\n+\n+impl Cleanup for FreeSlice {\n+    fn must_unwind(&self) -> bool {\n+        true\n+    }\n+\n+    fn clean_on_unwind(&self) -> bool {\n+        true\n+    }\n+\n+    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+        match self.heap {\n+            HeapManaged => {\n+                glue::trans_free(bcx, self.ptr)\n+            }\n+            HeapExchange => {\n+                glue::trans_exchange_free_dyn(bcx, self.ptr, self.size, self.align)\n+            }\n+        }\n+    }\n+}\n+\n pub struct LifetimeEnd {\n     ptr: ValueRef,\n }\n@@ -1020,6 +1069,12 @@ pub trait CleanupMethods<'a> {\n                            val: ValueRef,\n                            heap: Heap,\n                            content_ty: ty::t);\n+    fn schedule_free_slice(&self,\n+                           cleanup_scope: ScopeId,\n+                           val: ValueRef,\n+                           size: ValueRef,\n+                           align: ValueRef,\n+                           heap: Heap);\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n                       cleanup: CleanupObj);"}, {"sha": "09d28f03392cfe2bf751e18e9bcc22ffbd9326f3", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1bd139251be4b1c51ace8d180757ca7b59e675a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1bd139251be4b1c51ace8d180757ca7b59e675a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=d1bd139251be4b1c51ace8d180757ca7b59e675a", "patch": "@@ -53,7 +53,7 @@ pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n         Some(expr::Ignore)).bcx\n }\n \n-fn trans_exchange_free_internal<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueRef,\n+pub fn trans_exchange_free_dyn<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueRef,\n                                align: ValueRef) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     let ccx = cx.ccx();\n@@ -65,10 +65,8 @@ fn trans_exchange_free_internal<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueR\n \n pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n                                align: u64) -> &'a Block<'a> {\n-    trans_exchange_free_internal(cx,\n-                                 v,\n-                                 C_uint(cx.ccx(), size as uint),\n-                                 C_uint(cx.ccx(), align as uint))\n+    trans_exchange_free_dyn(cx, v, C_uint(cx.ccx(), size as uint),\n+                            C_uint(cx.ccx(), align as uint))\n }\n \n pub fn trans_exchange_free_ty<'a>(bcx: &'a Block<'a>, ptr: ValueRef,\n@@ -467,7 +465,7 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                         let info = GEPi(bcx, v0, [0, abi::slice_elt_len]);\n                         let info = Load(bcx, info);\n                         let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n-                        trans_exchange_free_internal(bcx, llbox, llsize, llalign)\n+                        trans_exchange_free_dyn(bcx, llbox, llsize, llalign)\n                     })\n                 }\n                 _ => {"}, {"sha": "285105d22f675efbcdb2981154b7a5e208eae26c", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d1bd139251be4b1c51ace8d180757ca7b59e675a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1bd139251be4b1c51ace8d180757ca7b59e675a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=d1bd139251be4b1c51ace8d180757ca7b59e675a", "patch": "@@ -25,6 +25,7 @@ use middle::trans::datum::*;\n use middle::trans::expr::{Dest, Ignore, SaveIn};\n use middle::trans::expr;\n use middle::trans::glue;\n+use middle::trans::machine;\n use middle::trans::machine::{nonzero_llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n@@ -59,6 +60,7 @@ pub fn make_drop_glue_unboxed<'a>(\n                               -> &'a Block<'a> {\n     let not_null = IsNotNull(bcx, vptr);\n     with_cond(bcx, not_null, |bcx| {\n+        let ccx = bcx.ccx();\n         let tcx = bcx.tcx();\n         let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n \n@@ -73,8 +75,11 @@ pub fn make_drop_glue_unboxed<'a>(\n         if should_deallocate {\n             let not_null = IsNotNull(bcx, dataptr);\n             with_cond(bcx, not_null, |bcx| {\n-                // FIXME: #13994: the old `Box<[T]>` will not support sized deallocation\n-                glue::trans_exchange_free(bcx, dataptr, 0, 8)\n+                let llty = type_of::type_of(ccx, unit_ty);\n+                let llsize = machine::llsize_of(ccx, llty);\n+                let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty) as uint);\n+                let size = Mul(bcx, llsize, get_len(bcx, vptr));\n+                glue::trans_exchange_free_dyn(bcx, dataptr, size, llalign)\n             })\n         } else {\n             bcx\n@@ -281,15 +286,16 @@ pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n     debug!(\"    vt={}, count={:?}\", vt.to_string(ccx), count);\n     let vec_ty = node_id_type(bcx, uniq_expr.id);\n \n-    let unit_sz = nonzero_llsize_of(ccx, type_of::type_of(ccx, vt.unit_ty));\n+    let llty = type_of::type_of(ccx, vt.unit_ty);\n+    let unit_sz = nonzero_llsize_of(ccx, llty);\n     let llcount = if count < 4u {\n         C_int(ccx, 4)\n     } else {\n         C_uint(ccx, count)\n     };\n     let alloc = Mul(bcx, llcount, unit_sz);\n-    let llty_ptr = type_of::type_of(ccx, vt.unit_ty).ptr_to();\n-    let align = C_uint(ccx, 8);\n+    let llty_ptr = llty.ptr_to();\n+    let align = C_uint(ccx, machine::llalign_of_min(ccx, llty) as uint);\n     let Result { bcx: bcx, val: dataptr } = malloc_raw_dyn(bcx,\n                                                            llty_ptr,\n                                                            vec_ty,\n@@ -299,16 +305,15 @@ pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n     // Create a temporary scope lest execution should fail while\n     // constructing the vector.\n     let temp_scope = fcx.push_custom_cleanup_scope();\n-    // FIXME: #13994: the old `Box<[T]> will not support sized deallocation,\n-    // this is a placeholder\n-    fcx.schedule_free_value(cleanup::CustomScope(temp_scope),\n-                            dataptr, cleanup::HeapExchange, vt.unit_ty);\n \n-        debug!(\"    alloc_uniq_vec() returned dataptr={}, len={}\",\n-               bcx.val_to_string(dataptr), count);\n+    fcx.schedule_free_slice(cleanup::CustomScope(temp_scope),\n+                            dataptr, alloc, align, cleanup::HeapExchange);\n \n-        let bcx = write_content(bcx, &vt, uniq_expr,\n-                                content_expr, SaveIn(dataptr));\n+    debug!(\"    alloc_uniq_vec() returned dataptr={}, len={}\",\n+           bcx.val_to_string(dataptr), count);\n+\n+    let bcx = write_content(bcx, &vt, uniq_expr,\n+                            content_expr, SaveIn(dataptr));\n \n     fcx.pop_custom_cleanup_scope(temp_scope);\n "}]}