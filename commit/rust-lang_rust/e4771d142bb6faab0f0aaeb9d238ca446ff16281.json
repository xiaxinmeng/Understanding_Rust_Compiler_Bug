{"sha": "e4771d142bb6faab0f0aaeb9d238ca446ff16281", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NzcxZDE0MmJiNmZhYWIwZjBhYWViOWQyMzhjYTQ0NmZmMTYyODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-15T04:46:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-15T04:46:13Z"}, "message": "auto merge of #16853 : tbu-/rust/pr_mapinplace, r=aturon\n\nThis is implemented using a new struct PartialVec which implements the proper\r\ndrop semantics in case the conversion is interrupted by an unwind.\r\n\r\nFor the old pull requests, see #15302, #16369.", "tree": {"sha": "25b48278ca50aab55893561393cea24599f3a95b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25b48278ca50aab55893561393cea24599f3a95b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4771d142bb6faab0f0aaeb9d238ca446ff16281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4771d142bb6faab0f0aaeb9d238ca446ff16281", "html_url": "https://github.com/rust-lang/rust/commit/e4771d142bb6faab0f0aaeb9d238ca446ff16281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4771d142bb6faab0f0aaeb9d238ca446ff16281/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "793a36617bdaec4ffb3fc0e8b1fb44d0b633ed5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/793a36617bdaec4ffb3fc0e8b1fb44d0b633ed5c", "html_url": "https://github.com/rust-lang/rust/commit/793a36617bdaec4ffb3fc0e8b1fb44d0b633ed5c"}, {"sha": "2c7f6eee0c6a3d5b67e523aa5c8dc0bd27cf8c4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c7f6eee0c6a3d5b67e523aa5c8dc0bd27cf8c4b", "html_url": "https://github.com/rust-lang/rust/commit/2c7f6eee0c6a3d5b67e523aa5c8dc0bd27cf8c4b"}], "stats": {"total": 275, "additions": 275, "deletions": 0}, "files": [{"sha": "6fc367474bb7bf3d1e97642be375015c8cc7384b", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/e4771d142bb6faab0f0aaeb9d238ca446ff16281/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4771d142bb6faab0f0aaeb9d238ca446ff16281/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e4771d142bb6faab0f0aaeb9d238ca446ff16281", "patch": "@@ -1710,6 +1710,268 @@ pub mod raw {\n     }\n }\n \n+/// An owned, partially type-converted vector.\n+///\n+/// This struct takes two type parameters `T` and `U` which must be of the\n+/// same, non-zero size having the same minimal alignment.\n+///\n+/// No allocations are performed by usage, only a deallocation happens in the\n+/// destructor which should only run when unwinding.\n+///\n+/// It can be used to convert a vector of `T`s into a vector of `U`s, by\n+/// converting the individual elements one-by-one.\n+///\n+/// You may call the `push` method as often as you get a `Some(t)` from `pop`.\n+/// After pushing the same number of `U`s as you got `T`s, you can `unwrap` the\n+/// vector.\n+///\n+/// # Example\n+///\n+/// ```ignore\n+/// let pv = PartialVec::from_vec(vec![0u32, 1]);\n+/// assert_eq!(pv.pop(), Some(0));\n+/// assert_eq!(pv.pop(), Some(1));\n+/// assert_eq!(pv.pop(), None);\n+/// pv.push(2u32);\n+/// pv.push(3);\n+/// assert_eq!(pv.into_vec().as_slice(), &[2, 3]);\n+/// ```\n+//\n+// Upheld invariants:\n+//\n+// (a) `vec` isn't modified except when the `PartialVec` goes out of scope, the\n+//     only thing it is used for is keeping the memory which the `PartialVec`\n+//     uses for the inplace conversion.\n+//\n+// (b) `start_u` points to the start of the vector.\n+//\n+// (c) `end_u` points to one element beyond the vector.\n+//\n+// (d) `start_u` <= `end_u` <= `start_t` <= `end_t`.\n+//\n+// (e) From `start_u` (incl.) to `end_u` (excl.) there are sequential instances\n+//     of type `U`.\n+//\n+// (f) From `start_t` (incl.) to `end_t` (excl.) there are sequential instances\n+//     of type `T`.\n+//\n+// (g) The size of `T` and `U` is equal and non-zero.\n+//\n+// (h) The `min_align_of` of `T` and `U` is equal.\n+\n+struct PartialVec<T,U> {\n+    vec: Vec<T>,\n+\n+    start_u: *mut U,\n+    end_u: *mut U,\n+    start_t: *mut T,\n+    end_t: *mut T,\n+}\n+\n+impl<T,U> PartialVec<T,U> {\n+    /// Creates a `PartialVec` from a `Vec`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `T` and `U` have differing sizes, are zero-sized or have\n+    /// differing minimal alignments.\n+    fn from_vec(mut vec: Vec<T>) -> PartialVec<T,U> {\n+        // FIXME: Assert statically that the types `T` and `U` have the same\n+        // size.\n+        //\n+        // These asserts make sure (g) and (h) are satisfied.\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(mem::size_of::<U>() != 0);\n+        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n+        assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n+\n+        let start = vec.as_mut_ptr();\n+\n+        // This `as int` cast is safe, because the size of the elements of the\n+        // vector is not 0, and:\n+        //\n+        // 1) If the size of the elements in the vector is 1, the `int` may\n+        //    overflow, but it has the correct bit pattern so that the\n+        //    `.offset()` function will work.\n+        //\n+        //    Example:\n+        //        Address space 0x0-0xF.\n+        //        `u8` array at: 0x1.\n+        //        Size of `u8` array: 0x8.\n+        //        Calculated `offset`: -0x8.\n+        //        After `array.offset(offset)`: 0x9.\n+        //        (0x1 + 0x8 = 0x1 - 0x8)\n+        //\n+        // 2) If the size of the elements in the vector is >1, the `uint` ->\n+        //    `int` conversion can't overflow.\n+        let offset = vec.len() as int;\n+\n+        let start_u = start as *mut U;\n+        let end_u = start as *mut U;\n+        let start_t = start;\n+\n+        // This points inside the vector, as the vector has length `offset`.\n+        let end_t = unsafe { start_t.offset(offset) };\n+\n+        // (b) is satisfied, `start_u` points to the start of `vec`.\n+        //\n+        // (c) is also satisfied, `end_t` points to the end of `vec`.\n+        //\n+        // `start_u == end_u == start_t <= end_t`, so also `start_u <= end_u <=\n+        // start_t <= end_t`, thus (b).\n+        //\n+        // As `start_u == end_u`, it is represented correctly that there are no\n+        // instances of `U` in `vec`, thus (e) is satisfied.\n+        //\n+        // At start, there are only elements of type `T` in `vec`, so (f) is\n+        // satisfied, as `start_t` points to the start of `vec` and `end_t` to\n+        // the end of it.\n+\n+        PartialVec {\n+            // (a) is satisfied, `vec` isn't modified in the function.\n+            vec: vec,\n+            start_u: start_u,\n+            end_u: end_u,\n+            start_t: start_t,\n+            end_t: end_t,\n+        }\n+    }\n+\n+    /// Pops a `T` from the `PartialVec`.\n+    ///\n+    /// Removes the next `T` from the vector and returns it as `Some(T)`, or\n+    /// `None` if there are none left.\n+    fn pop(&mut self) -> Option<T> {\n+        // The `if` ensures that there are more `T`s in `vec`.\n+        if self.start_t < self.end_t {\n+            let result;\n+            unsafe {\n+                // (f) is satisfied before, so in this if branch there actually\n+                // is a `T` at `start_t`.  After shifting the pointer by one,\n+                // (f) is again satisfied.\n+                result = ptr::read(self.start_t as *const T);\n+                self.start_t = self.start_t.offset(1);\n+            }\n+            Some(result)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Pushes a new `U` to the `PartialVec`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if not enough `T`s were popped to have enough space for the new\n+    /// `U`.\n+    fn push(&mut self, value: U) {\n+        // The assert assures that still `end_u <= start_t` (d) after\n+        // the function.\n+        assert!(self.end_u as *const () < self.start_t as *const (),\n+            \"writing more elements to PartialVec than reading from it\")\n+        unsafe {\n+            // (e) is satisfied before, and after writing one `U`\n+            // to `end_u` and shifting it by one, it's again\n+            // satisfied.\n+            ptr::write(self.end_u, value);\n+            self.end_u = self.end_u.offset(1);\n+        }\n+    }\n+\n+    /// Unwraps the new `Vec` of `U`s after having pushed enough `U`s and\n+    /// popped all `T`s.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if not all `T`s were popped, also fails if not the same amount of\n+    /// `U`s was pushed before calling `unwrap`.\n+    fn into_vec(mut self) -> Vec<U> {\n+        // If `self.end_u == self.end_t`, we know from (e) that there are no\n+        // more `T`s in `vec`, we also know that the whole length of `vec` is\n+        // now used by `U`s, thus we can just interpret `vec` as a vector of\n+        // `U` safely.\n+\n+        assert!(self.end_u as *const () == self.end_t as *const (),\n+            \"trying to unwrap a PartialVec before completing the writes to it\");\n+\n+        // Extract `vec` and prevent the destructor of `PartialVec` from\n+        // running. Note that none of the function calls can fail, thus no\n+        // resources can be leaked (as the `vec` member of `PartialVec` is the\n+        // only one which holds allocations -- and it is returned from this\n+        // function.\n+        unsafe {\n+            let vec_len = self.vec.len();\n+            let vec_cap = self.vec.capacity();\n+            let vec_ptr = self.vec.as_mut_ptr() as *mut U;\n+            mem::forget(self);\n+            Vec::from_raw_parts(vec_len, vec_cap, vec_ptr)\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T,U> Drop for PartialVec<T,U> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // As per (a) `vec` hasn't been modified until now. As it has a\n+            // length currently, this would run destructors of `T`s which might\n+            // not be there. So at first, set `vec`s length to `0`. This must\n+            // be done at first to remain memory-safe as the destructors of `U`\n+            // or `T` might cause unwinding where `vec`s destructor would be\n+            // executed.\n+            self.vec.set_len(0);\n+\n+            // As per (e) and (f) we have instances of `U`s and `T`s in `vec`.\n+            // Destruct them.\n+            while self.start_u < self.end_u {\n+                let _ = ptr::read(self.start_u as *const U); // Run a `U` destructor.\n+                self.start_u = self.start_u.offset(1);\n+            }\n+            while self.start_t < self.end_t {\n+                let _ = ptr::read(self.start_t as *const T); // Run a `T` destructor.\n+                self.start_t = self.start_t.offset(1);\n+            }\n+            // After this destructor ran, the destructor of `vec` will run,\n+            // deallocating the underlying memory.\n+        }\n+    }\n+}\n+\n+impl<T> Vec<T> {\n+    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n+    /// non-zero size and the same minimal alignment.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `T` and `U` have differing sizes, are zero-sized or have\n+    /// differing minimal alignments.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let v = vec![0u, 1, 2];\n+    /// let w = v.map_in_place(|i| i + 3);\n+    /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n+    ///\n+    /// #[deriving(PartialEq, Show)]\n+    /// struct Newtype(u8);\n+    /// let bytes = vec![0x11, 0x22];\n+    /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n+    /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n+    /// ```\n+    pub fn map_in_place<U>(self, f: |T| -> U) -> Vec<U> {\n+        let mut pv = PartialVec::from_vec(self);\n+        loop {\n+            let maybe_t = pv.pop();\n+            match maybe_t {\n+                Some(t) => pv.push(f(t)),\n+                None => return pv.into_vec(),\n+            };\n+        }\n+    }\n+}\n+\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;\n@@ -2041,6 +2303,19 @@ mod tests {\n         assert_eq!(vec.len(), 0);\n     }\n \n+    #[test]\n+    #[should_fail]\n+    fn test_map_inp_lace_incompatible_types_fail() {\n+        let v = vec![0u, 1, 2];\n+        v.map_in_place(|_| ());\n+    }\n+\n+    #[test]\n+    fn test_map_in_place() {\n+        let v = vec![0u, 1, 2];\n+        assert_eq!(v.map_in_place(|i: uint| i as int - 1).as_slice(), [-1i, 0, 1].as_slice());\n+    }\n+\n     #[bench]\n     fn bench_new(b: &mut Bencher) {\n         b.iter(|| {"}]}