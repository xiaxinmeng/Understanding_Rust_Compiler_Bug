{"sha": "be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b", "node_id": "C_kwDOAAsO6NoAKGJlMzE2OGRhYmUwYjVlZTNkN2ZlZDRhNWU3MTMzZTVmMmQ0ZjNhNGI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-21T10:51:53Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-22T09:20:44Z"}, "message": "Fix `expand_macro` not working for derive attributes", "tree": {"sha": "8558c846fa71e90d19a3f3e5142f6f29c5a0cdfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8558c846fa71e90d19a3f3e5142f6f29c5a0cdfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b", "html_url": "https://github.com/rust-lang/rust/commit/be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "html_url": "https://github.com/rust-lang/rust/commit/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51"}], "stats": {"total": 60, "additions": 42, "deletions": 18}, "files": [{"sha": "2c6378cd3eee669d74787a9877aa0d75fcb88e3a", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b", "patch": "@@ -219,9 +219,18 @@ impl HirFileId {\n \n                 let arg_tt = loc.kind.arg(db)?;\n \n+                let macro_def = db.macro_def(loc.def).ok()?;\n+                let (parse, exp_map) = db.parse_macro_expansion(macro_file).value?;\n+                let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n+\n                 let def = loc.def.ast_id().left().and_then(|id| {\n                     let def_tt = match id.to_node(db) {\n                         ast::Macro::MacroRules(mac) => mac.token_tree()?,\n+                        ast::Macro::MacroDef(_)\n+                            if matches!(*macro_def, TokenExpander::BuiltinAttr(_)) =>\n+                        {\n+                            return None\n+                        }\n                         ast::Macro::MacroDef(mac) => mac.body()?,\n                     };\n                     Some(InFile::new(id.file_id, def_tt))\n@@ -239,10 +248,6 @@ impl HirFileId {\n                     _ => None,\n                 });\n \n-                let macro_def = db.macro_def(loc.def).ok()?;\n-                let (parse, exp_map) = db.parse_macro_expansion(macro_file).value?;\n-                let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n-\n                 Some(ExpansionInfo {\n                     expanded: InFile::new(self, parse.syntax_node()),\n                     arg: InFile::new(loc.kind.file_id(), arg_tt),\n@@ -292,7 +297,7 @@ impl HirFileId {\n         }\n     }\n \n-    /// Return whether this file is an include macro\n+    /// Return whether this file is an attr macro\n     pub fn is_attr_macro(&self, db: &dyn db::AstDatabase) -> bool {\n         match self.0 {\n             HirFileIdRepr::MacroFile(macro_file) => {\n@@ -303,6 +308,17 @@ impl HirFileId {\n         }\n     }\n \n+    /// Return whether this file is the pseudo expansion of the derive attribute.\n+    pub fn is_derive_attr_macro(&self, db: &dyn db::AstDatabase) -> bool {\n+        match self.0 {\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n+                matches!(loc.kind, MacroCallKind::Attr { is_derive: true, .. })\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_macro(self) -> bool {\n         matches!(self.0, HirFileIdRepr::MacroFile(_))\n     }\n@@ -567,6 +583,9 @@ impl ExpansionInfo {\n \n         // Attributes are a bit special for us, they have two inputs, the input tokentree and the annotated item.\n         let (token_map, tt) = match &loc.kind {\n+            MacroCallKind::Attr { attr_args, is_derive: true, .. } => {\n+                (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+            }\n             MacroCallKind::Attr { attr_args, .. } => {\n                 // try unshifting the the token id, if unshifting fails, the token resides in the non-item attribute input\n                 // note that the `TokenExpander::map_id_up` earlier only unshifts for declarative macros, so we don't double unshift with this\n@@ -722,6 +741,13 @@ impl<'a> InFile<&'a SyntaxNode> {\n     }\n }\n \n+impl InFile<SyntaxToken> {\n+    pub fn upmap(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxToken>> {\n+        let expansion = self.file_id.expansion_info(db)?;\n+        expansion.map_token_up(db, self.as_ref()).map(|(it, _)| it)\n+    }\n+}\n+\n fn ascend_node_border_tokens(\n     db: &dyn db::AstDatabase,\n     InFile { file_id, value: node }: InFile<&SyntaxNode>,"}, {"sha": "c234eb3db6bd289d8044de2865de5a4f0dc1239f", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b", "patch": "@@ -41,20 +41,18 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n     // struct Bar;\n     // ```\n \n-    let derive = sema.descend_into_macros(tok.clone()).iter().find_map(|descended| {\n-        let attr = descended.ancestors().find_map(ast::Attr::cast)?;\n-        let (path, tt) = attr.as_simple_call()?;\n-        if path == \"derive\" {\n-            let mut tt = tt.syntax().children_with_tokens().skip(1).join(\"\");\n-            tt.pop();\n-            let expansions = sema.expand_derive_macro(&attr)?;\n-            Some(ExpandedMacro {\n-                name: tt,\n-                expansion: expansions.into_iter().map(insert_ws_into).join(\"\"),\n-            })\n-        } else {\n-            None\n+    let derive = sema.descend_into_macros(tok.clone()).into_iter().find_map(|descended| {\n+        let hir_file = sema.hir_file_for(&descended.parent()?);\n+        if !hir_file.is_derive_attr_macro(db) {\n+            return None;\n         }\n+\n+        let name = descended.ancestors().filter_map(ast::Path::cast).last()?.to_string();\n+        // up map out of the #[derive] expansion\n+        let token = hir::InFile::new(hir_file, descended).upmap(db)?.value;\n+        let attr = token.ancestors().find_map(ast::Attr::cast)?;\n+        let expansions = sema.expand_derive_macro(&attr)?;\n+        Some(ExpandedMacro { name, expansion: expansions.into_iter().map(insert_ws_into).join(\"\") })\n     });\n \n     if derive.is_some() {"}]}