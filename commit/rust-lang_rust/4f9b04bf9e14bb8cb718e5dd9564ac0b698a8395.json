{"sha": "4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmOWIwNGJmOWUxNGJiOGNiNzE4ZTVkZDk1NjRhYzBiNjk4YTgzOTU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-04T10:33:07Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-14T03:27:32Z"}, "message": "save-analysis: move csv dumping stuff to its own module and rename", "tree": {"sha": "98a84109a507f4f7b4aadf989cf20926c27b9959", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98a84109a507f4f7b4aadf989cf20926c27b9959"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395", "html_url": "https://github.com/rust-lang/rust/commit/4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5394240a295650b567aa406b4a0e1e3a6749a5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5394240a295650b567aa406b4a0e1e3a6749a5f", "html_url": "https://github.com/rust-lang/rust/commit/e5394240a295650b567aa406b4a0e1e3a6749a5f"}], "stats": {"total": 3050, "additions": 1540, "deletions": 1510}, "files": [{"sha": "ab66123c4d739234f2dd87e5c70898f8eb20d48b", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "added", "additions": 1522, "deletions": 0, "changes": 1522, "blob_url": "https://github.com/rust-lang/rust/blob/4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395", "patch": "@@ -0,0 +1,1522 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Output a CSV file containing the output from rustc's analysis. The data is\n+//! primarily designed to be used as input to the DXR tool, specifically its\n+//! Rust plugin. It could also be used by IDEs or other code browsing, search, or\n+//! cross-referencing tools.\n+//!\n+//! Dumping the analysis is implemented by walking the AST and getting a bunch of\n+//! info out from all over the place. We use Def IDs to identify objects. The\n+//! tricky part is getting syntactic (span, source text) and semantic (reference\n+//! Def IDs) information for parts of expressions which the compiler has discarded.\n+//! E.g., in a path `foo::bar::baz`, the compiler only keeps a span for the whole\n+//! path and a reference to `baz`, but we want spans and references for all three\n+//! idents.\n+//!\n+//! SpanUtils is used to manipulate spans. In particular, to extract sub-spans\n+//! from spans (e.g., the span for `bar` from the above example path).\n+//! Recorder is used for recording the output in csv format. FmtStrs separates\n+//! the format of the output away from extracting it from the compiler.\n+//! DumpCsvVisitor walks the AST and processes it.\n+\n+use super::{escape, generated_code, recorder};\n+\n+use session::Session;\n+\n+use middle::def;\n+use middle::ty::{self, Ty};\n+\n+use std::cell::Cell;\n+use std::fs::File;\n+use std::path::Path;\n+\n+use syntax::ast_util;\n+use syntax::ast::{self, NodeId, DefId};\n+use syntax::ast_map::NodeItem;\n+use syntax::codemap::*;\n+use syntax::parse::token::{self, get_ident, keywords};\n+use syntax::owned_slice::OwnedSlice;\n+use syntax::visit::{self, Visitor};\n+use syntax::print::pprust::{path_to_string, ty_to_string};\n+use syntax::ptr::P;\n+\n+use super::span_utils::SpanUtils;\n+use super::recorder::{Recorder, FmtStrs};\n+\n+use util::ppaux;\n+\n+\n+pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n+    sess: &'l Session,\n+    analysis: &'l ty::CrateAnalysis<'tcx>,\n+\n+    collected_paths: Vec<(NodeId, ast::Path, bool, recorder::Row)>,\n+    collecting: bool,\n+\n+    span: SpanUtils<'l>,\n+    fmt: FmtStrs<'l>,\n+\n+    cur_scope: NodeId\n+}\n+\n+impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n+    fn nest<F>(&mut self, scope_id: NodeId, f: F) where\n+        F: FnOnce(&mut DumpCsvVisitor<'l, 'tcx>),\n+    {\n+        let parent_scope = self.cur_scope;\n+        self.cur_scope = scope_id;\n+        f(self);\n+        self.cur_scope = parent_scope;\n+    }\n+\n+    pub fn new(sess: &'l Session,\n+               analysis: &'l ty::CrateAnalysis<'tcx>,\n+               output_file: Box<File>) -> DumpCsvVisitor<'l, 'tcx> {\n+        DumpCsvVisitor {\n+            sess: sess,\n+            analysis: analysis,\n+            collected_paths: vec![],\n+            collecting: false,\n+            span: SpanUtils {\n+                sess: sess,\n+                err_count: Cell::new(0)\n+            },\n+            fmt: FmtStrs::new(box Recorder {\n+                                out: output_file,\n+                                dump_spans: false,\n+                            },\n+                            SpanUtils {\n+                                sess: sess,\n+                                err_count: Cell::new(0)\n+                            }),\n+            cur_scope: 0            \n+        }\n+    }\n+\n+    pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n+        // the current crate\n+        self.fmt.crate_str(krate.span, name);\n+\n+        // dump info about all the external crates referenced from this crate\n+        self.sess.cstore.iter_crate_data(|n, cmd| {\n+            self.fmt.external_crate_str(krate.span, &cmd.name, n);\n+        });\n+        self.fmt.recorder.record(\"end_external_crates\\n\");\n+    }\n+\n+    // Return all non-empty prefixes of a path.\n+    // For each prefix, we return the span for the last segment in the prefix and\n+    // a str representation of the entire prefix.\n+    fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n+        let spans = self.span.spans_for_path_segments(path);\n+\n+        // Paths to enums seem to not match their spans - the span includes all the\n+        // variants too. But they seem to always be at the end, so I hope we can cope with\n+        // always using the first ones. So, only error out if we don't have enough spans.\n+        // What could go wrong...?\n+        if spans.len() < path.segments.len() {\n+            error!(\"Mis-calculated spans for path '{}'. \\\n+                    Found {} spans, expected {}. Found spans:\",\n+                   path_to_string(path), spans.len(), path.segments.len());\n+            for s in &spans {\n+                let loc = self.sess.codemap().lookup_char_pos(s.lo);\n+                error!(\"    '{}' in {}, line {}\",\n+                       self.span.snippet(*s), loc.file.name, loc.line);\n+            }\n+            return vec!();\n+        }\n+\n+        let mut result: Vec<(Span, String)> = vec!();\n+\n+        let mut segs = vec!();\n+        for (i, (seg, span)) in path.segments.iter().zip(spans.iter()).enumerate() {\n+            segs.push(seg.clone());\n+            let sub_path = ast::Path{span: *span, // span for the last segment\n+                                     global: path.global,\n+                                     segments: segs};\n+            let qualname = if i == 0 && path.global {\n+                format!(\"::{}\", path_to_string(&sub_path))\n+            } else {\n+                path_to_string(&sub_path)\n+            };\n+            result.push((*span, qualname));\n+            segs = sub_path.segments;\n+        }\n+\n+        result\n+    }\n+\n+    // The global arg allows us to override the global-ness of the path (which\n+    // actually means 'does the path start with `::`', rather than 'is the path\n+    // semantically global). We use the override for `use` imports (etc.) where\n+    // the syntax is non-global, but the semantics are global.\n+    fn write_sub_paths(&mut self, path: &ast::Path, global: bool) {\n+        let sub_paths = self.process_path_prefixes(path);\n+        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n+            let qualname = if i == 0 && global && !path.global {\n+                format!(\"::{}\", qualname)\n+            } else {\n+                qualname.clone()\n+            };\n+            self.fmt.sub_mod_ref_str(path.span,\n+                                     *span,\n+                                     &qualname[..],\n+                                     self.cur_scope);\n+        }\n+    }\n+\n+    // As write_sub_paths, but does not process the last ident in the path (assuming it\n+    // will be processed elsewhere). See note on write_sub_paths about global.\n+    fn write_sub_paths_truncated(&mut self, path: &ast::Path, global: bool) {\n+        let sub_paths = self.process_path_prefixes(path);\n+        let len = sub_paths.len();\n+        if len <= 1 {\n+            return;\n+        }\n+\n+        let sub_paths = &sub_paths[..len-1];\n+        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n+            let qualname = if i == 0 && global && !path.global {\n+                format!(\"::{}\", qualname)\n+            } else {\n+                qualname.clone()\n+            };\n+            self.fmt.sub_mod_ref_str(path.span,\n+                                     *span,\n+                                     &qualname[..],\n+                                     self.cur_scope);\n+        }\n+    }\n+\n+    // As write_sub_paths, but expects a path of the form module_path::trait::method\n+    // Where trait could actually be a struct too.\n+    fn write_sub_path_trait_truncated(&mut self, path: &ast::Path) {\n+        let sub_paths = self.process_path_prefixes(path);\n+        let len = sub_paths.len();\n+        if len <= 1 {\n+            return;\n+        }\n+        let sub_paths = &sub_paths[.. (len-1)];\n+\n+        // write the trait part of the sub-path\n+        let (ref span, ref qualname) = sub_paths[len-2];\n+        self.fmt.sub_type_ref_str(path.span,\n+                                  *span,\n+                                  &qualname[..]);\n+\n+        // write the other sub-paths\n+        if len <= 2 {\n+            return;\n+        }\n+        let sub_paths = &sub_paths[..len-2];\n+        for &(ref span, ref qualname) in sub_paths {\n+            self.fmt.sub_mod_ref_str(path.span,\n+                                     *span,\n+                                     &qualname[..],\n+                                     self.cur_scope);\n+        }\n+    }\n+\n+    // looks up anything, not just a type\n+    fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n+        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n+            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n+                                  ref_id));\n+        }\n+        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n+        match def {\n+            def::DefPrimTy(_) => None,\n+            _ => Some(def.def_id()),\n+        }\n+    }\n+\n+    fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n+        let def_map = self.analysis.ty_cx.def_map.borrow();\n+        if !def_map.contains_key(&ref_id) {\n+            self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n+                                             ref_id));\n+        }\n+        let def = def_map.get(&ref_id).unwrap().full_def();\n+        match def {\n+            def::DefMod(_) |\n+            def::DefForeignMod(_) => Some(recorder::ModRef),\n+            def::DefStruct(_) => Some(recorder::StructRef),\n+            def::DefTy(..) |\n+            def::DefAssociatedTy(..) |\n+            def::DefTrait(_) => Some(recorder::TypeRef),\n+            def::DefStatic(_, _) |\n+            def::DefConst(_) |\n+            def::DefAssociatedConst(..) |\n+            def::DefLocal(_) |\n+            def::DefVariant(_, _, _) |\n+            def::DefUpvar(..) => Some(recorder::VarRef),\n+\n+            def::DefFn(..) => Some(recorder::FnRef),\n+\n+            def::DefSelfTy(..) |\n+            def::DefRegion(_) |\n+            def::DefLabel(_) |\n+            def::DefTyParam(..) |\n+            def::DefUse(_) |\n+            def::DefMethod(..) |\n+            def::DefPrimTy(_) => {\n+                self.sess.span_bug(span, &format!(\"lookup_def_kind for unexpected item: {:?}\",\n+                                                 def));\n+            },\n+        }\n+    }\n+\n+    fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n+        for arg in formals {\n+            assert!(self.collected_paths.is_empty() && !self.collecting);\n+            self.collecting = true;\n+            self.visit_pat(&*arg.pat);\n+            self.collecting = false;\n+            let span_utils = self.span.clone();\n+            for &(id, ref p, _, _) in &self.collected_paths {\n+                let typ =\n+                    ppaux::ty_to_string(\n+                        &self.analysis.ty_cx,\n+                        *self.analysis.ty_cx.node_types().get(&id).unwrap());\n+                // get the span only for the name of the variable (I hope the path is only ever a\n+                // variable name, but who knows?)\n+                self.fmt.formal_str(p.span,\n+                                    span_utils.span_for_last_ident(p.span),\n+                                    id,\n+                                    qualname,\n+                                    &path_to_string(p),\n+                                    &typ[..]);\n+            }\n+            self.collected_paths.clear();\n+        }\n+    }\n+\n+    fn process_method(&mut self, sig: &ast::MethodSig,\n+                      body: Option<&ast::Block>,\n+                      id: ast::NodeId, name: ast::Name,\n+                      span: Span) {\n+        if generated_code(span) {\n+            return;\n+        }\n+\n+        debug!(\"process_method: {}:{}\", id, token::get_name(name));\n+\n+        let mut scope_id;\n+        // The qualname for a method is the trait name or name of the struct in an impl in\n+        // which the method is declared in, followed by the method's name.\n+        let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n+                                                ast_util::local_def(id)) {\n+            Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n+                NodeItem(item) => {\n+                    scope_id = item.id;\n+                    match item.node {\n+                        ast::ItemImpl(_, _, _, _, ref ty, _) => {\n+                            let mut result = String::from_str(\"<\");\n+                            result.push_str(&ty_to_string(&**ty));\n+\n+                            match ty::trait_of_item(&self.analysis.ty_cx,\n+                                                    ast_util::local_def(id)) {\n+                                Some(def_id) => {\n+                                    result.push_str(\" as \");\n+                                    result.push_str(\n+                                        &ty::item_path_str(&self.analysis.ty_cx, def_id));\n+                                },\n+                                None => {}\n+                            }\n+                            result.push_str(\">\");\n+                            result\n+                        }\n+                        _ => {\n+                            self.sess.span_bug(span,\n+                                &format!(\"Container {} for method {} not an impl?\",\n+                                         impl_id.node, id));\n+                        },\n+                    }\n+                },\n+                _ => {\n+                    self.sess.span_bug(span,\n+                        &format!(\"Container {} for method {} is not a node item {:?}\",\n+                                 impl_id.node, id, self.analysis.ty_cx.map.get(impl_id.node)));\n+                },\n+            },\n+            None => match ty::trait_of_item(&self.analysis.ty_cx,\n+                                            ast_util::local_def(id)) {\n+                Some(def_id) => {\n+                    scope_id = def_id.node;\n+                    match self.analysis.ty_cx.map.get(def_id.node) {\n+                        NodeItem(_) => {\n+                            format!(\"::{}\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n+                        }\n+                        _ => {\n+                            self.sess.span_bug(span,\n+                                &format!(\"Could not find container {} for method {}\",\n+                                         def_id.node, id));\n+                        }\n+                    }\n+                },\n+                None => {\n+                    self.sess.span_bug(span,\n+                        &format!(\"Could not find container for method {}\", id));\n+                },\n+            },\n+        };\n+\n+        let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n+\n+        // record the decl for this def (if it has one)\n+        let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n+                                             ast_util::local_def(id))\n+            .and_then(|new_id| {\n+                let def_id = new_id.def_id();\n+                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n+                    Some(def_id)\n+                } else {\n+                    None\n+                }\n+            });\n+\n+        let sub_span = self.span.sub_span_after_keyword(span, keywords::Fn);\n+        if body.is_some() {\n+            self.fmt.method_str(span,\n+                                sub_span,\n+                                id,\n+                                qualname,\n+                                decl_id,\n+                                scope_id);\n+            self.process_formals(&sig.decl.inputs, qualname);\n+        } else {\n+            self.fmt.method_decl_str(span,\n+                                     sub_span,\n+                                     id,\n+                                     qualname,\n+                                     scope_id);\n+        }\n+\n+        // walk arg and return types\n+        for arg in &sig.decl.inputs {\n+            self.visit_ty(&arg.ty);\n+        }\n+\n+        if let ast::Return(ref ret_ty) = sig.decl.output {\n+            self.visit_ty(ret_ty);\n+        }\n+\n+        // walk the fn body\n+        if let Some(body) = body {\n+            self.nest(id, |v| v.visit_block(body));\n+        }\n+\n+        self.process_generic_params(&sig.generics,\n+                                    span,\n+                                    qualname,\n+                                    id);\n+    }\n+\n+    fn process_trait_ref(&mut self,\n+                         trait_ref: &ast::TraitRef) {\n+        match self.lookup_type_ref(trait_ref.ref_id) {\n+            Some(id) => {\n+                let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n+                self.fmt.ref_str(recorder::TypeRef,\n+                                 trait_ref.path.span,\n+                                 sub_span,\n+                                 id,\n+                                 self.cur_scope);\n+                visit::walk_path(self, &trait_ref.path);\n+            },\n+            None => ()\n+        }\n+    }\n+\n+    fn process_struct_field_def(&mut self,\n+                                field: &ast::StructField,\n+                                qualname: &str,\n+                                scope_id: NodeId) {\n+        match field.node.kind {\n+            ast::NamedField(ident, _) => {\n+                let name = get_ident(ident);\n+                let qualname = format!(\"{}::{}\", qualname, name);\n+                let typ =\n+                    ppaux::ty_to_string(\n+                        &self.analysis.ty_cx,\n+                        *self.analysis.ty_cx.node_types().get(&field.node.id).unwrap());\n+                match self.span.sub_span_before_token(field.span, token::Colon) {\n+                    Some(sub_span) => self.fmt.field_str(field.span,\n+                                                         Some(sub_span),\n+                                                         field.node.id,\n+                                                         &name[..],\n+                                                         &qualname[..],\n+                                                         &typ[..],\n+                                                         scope_id),\n+                    None => self.sess.span_bug(field.span,\n+                                               &format!(\"Could not find sub-span for field {}\",\n+                                                       qualname)),\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    // Dump generic params bindings, then visit_generics\n+    fn process_generic_params(&mut self,\n+                              generics:&ast::Generics,\n+                              full_span: Span,\n+                              prefix: &str,\n+                              id: NodeId) {\n+        // We can't only use visit_generics since we don't have spans for param\n+        // bindings, so we reparse the full_span to get those sub spans.\n+        // However full span is the entire enum/fn/struct block, so we only want\n+        // the first few to match the number of generics we're looking for.\n+        let param_sub_spans = self.span.spans_for_ty_params(full_span,\n+                                                           (generics.ty_params.len() as isize));\n+        for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans.iter()) {\n+            // Append $id to name to make sure each one is unique\n+            let name = format!(\"{}::{}${}\",\n+                               prefix,\n+                               escape(self.span.snippet(*param_ss)),\n+                               id);\n+            self.fmt.typedef_str(full_span,\n+                                 Some(*param_ss),\n+                                 param.id,\n+                                 &name[..],\n+                                 \"\");\n+        }\n+        self.visit_generics(generics);\n+    }\n+\n+    fn process_fn(&mut self,\n+                  item: &ast::Item,\n+                  decl: &ast::FnDecl,\n+                  ty_params: &ast::Generics,\n+                  body: &ast::Block) {\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n+        self.fmt.fn_str(item.span,\n+                        sub_span,\n+                        item.id,\n+                        &qualname[..],\n+                        self.cur_scope);\n+\n+        self.process_formals(&decl.inputs, &qualname[..]);\n+\n+        // walk arg and return types\n+        for arg in &decl.inputs {\n+            self.visit_ty(&*arg.ty);\n+        }\n+\n+        if let ast::Return(ref ret_ty) = decl.output {\n+            self.visit_ty(&**ret_ty);\n+        }\n+\n+        // walk the body\n+        self.nest(item.id, |v| v.visit_block(&*body));\n+\n+        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n+    }\n+\n+    fn process_static(&mut self,\n+                      item: &ast::Item,\n+                      typ: &ast::Ty,\n+                      mt: ast::Mutability,\n+                      expr: &ast::Expr)\n+    {\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+\n+        // If the variable is immutable, save the initialising expression.\n+        let (value, keyword) = match mt {\n+            ast::MutMutable => (String::from_str(\"<mutable>\"), keywords::Mut),\n+            ast::MutImmutable => (self.span.snippet(expr.span), keywords::Static),\n+        };\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keyword);\n+        self.fmt.static_str(item.span,\n+                            sub_span,\n+                            item.id,\n+                            &get_ident(item.ident),\n+                            &qualname[..],\n+                            &value[..],\n+                            &ty_to_string(&*typ),\n+                            self.cur_scope);\n+\n+        // walk type and init value\n+        self.visit_ty(&*typ);\n+        self.visit_expr(expr);\n+    }\n+\n+    fn process_const(&mut self,\n+                     id: ast::NodeId,\n+                     ident: &ast::Ident,\n+                     span: Span,\n+                     typ: &ast::Ty,\n+                     expr: &ast::Expr)\n+    {\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(id));\n+\n+        let sub_span = self.span.sub_span_after_keyword(span,\n+                                                        keywords::Const);\n+        self.fmt.static_str(span,\n+                            sub_span,\n+                            id,\n+                            &get_ident((*ident).clone()),\n+                            &qualname[..],\n+                            \"\",\n+                            &ty_to_string(&*typ),\n+                            self.cur_scope);\n+\n+        // walk type and init value\n+        self.visit_ty(typ);\n+        self.visit_expr(expr);\n+    }\n+\n+    fn process_struct(&mut self,\n+                      item: &ast::Item,\n+                      def: &ast::StructDef,\n+                      ty_params: &ast::Generics) {\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+\n+        let ctor_id = match def.ctor_id {\n+            Some(node_id) => node_id,\n+            None => -1,\n+        };\n+        let val = self.span.snippet(item.span);\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n+        self.fmt.struct_str(item.span,\n+                            sub_span,\n+                            item.id,\n+                            ctor_id,\n+                            &qualname[..],\n+                            self.cur_scope,\n+                            &val[..]);\n+\n+        // fields\n+        for field in &def.fields {\n+            self.process_struct_field_def(field, &qualname[..], item.id);\n+            self.visit_ty(&*field.node.ty);\n+        }\n+\n+        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n+    }\n+\n+    fn process_enum(&mut self,\n+                    item: &ast::Item,\n+                    enum_definition: &ast::EnumDef,\n+                    ty_params: &ast::Generics) {\n+        let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let val = self.span.snippet(item.span);\n+        match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n+            Some(sub_span) => self.fmt.enum_str(item.span,\n+                                                Some(sub_span),\n+                                                item.id,\n+                                                &enum_name[..],\n+                                                self.cur_scope,\n+                                                &val[..]),\n+            None => self.sess.span_bug(item.span,\n+                                       &format!(\"Could not find subspan for enum {}\",\n+                                               enum_name)),\n+        }\n+        for variant in &enum_definition.variants {\n+            let name = get_ident(variant.node.name);\n+            let name = &name;\n+            let mut qualname = enum_name.clone();\n+            qualname.push_str(\"::\");\n+            qualname.push_str(name);\n+            let val = self.span.snippet(variant.span);\n+            match variant.node.kind {\n+                ast::TupleVariantKind(ref args) => {\n+                    // first ident in span is the variant's name\n+                    self.fmt.tuple_variant_str(variant.span,\n+                                               self.span.span_for_first_ident(variant.span),\n+                                               variant.node.id,\n+                                               name,\n+                                               &qualname[..],\n+                                               &enum_name[..],\n+                                               &val[..],\n+                                               item.id);\n+                    for arg in args {\n+                        self.visit_ty(&*arg.ty);\n+                    }\n+                }\n+                ast::StructVariantKind(ref struct_def) => {\n+                    let ctor_id = match struct_def.ctor_id {\n+                        Some(node_id) => node_id,\n+                        None => -1,\n+                    };\n+                    self.fmt.struct_variant_str(\n+                        variant.span,\n+                        self.span.span_for_first_ident(variant.span),\n+                        variant.node.id,\n+                        ctor_id,\n+                        &qualname[..],\n+                        &enum_name[..],\n+                        &val[..],\n+                        item.id);\n+\n+                    for field in &struct_def.fields {\n+                        self.process_struct_field_def(field, &qualname, variant.node.id);\n+                        self.visit_ty(&*field.node.ty);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.process_generic_params(ty_params, item.span, &enum_name[..], item.id);\n+    }\n+\n+    fn process_impl(&mut self,\n+                    item: &ast::Item,\n+                    type_parameters: &ast::Generics,\n+                    trait_ref: &Option<ast::TraitRef>,\n+                    typ: &ast::Ty,\n+                    impl_items: &[P<ast::ImplItem>]) {\n+        let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n+        match typ.node {\n+            // Common case impl for a struct or something basic.\n+            ast::TyPath(None, ref path) => {\n+                let sub_span = self.span.sub_span_for_type_name(path.span);\n+                let self_id = self.lookup_type_ref(typ.id).map(|id| {\n+                    self.fmt.ref_str(recorder::TypeRef,\n+                                     path.span,\n+                                     sub_span,\n+                                     id,\n+                                     self.cur_scope);\n+                    id\n+                });\n+                self.fmt.impl_str(path.span,\n+                                  sub_span,\n+                                  item.id,\n+                                  self_id,\n+                                  trait_id,\n+                                  self.cur_scope);\n+            },\n+            _ => {\n+                // Less useful case, impl for a compound type.\n+                self.visit_ty(&*typ);\n+\n+                let sub_span = self.span.sub_span_for_type_name(typ.span);\n+                self.fmt.impl_str(typ.span,\n+                                  sub_span,\n+                                  item.id,\n+                                  None,\n+                                  trait_id,\n+                                  self.cur_scope);\n+            }\n+        }\n+\n+        match *trait_ref {\n+            Some(ref trait_ref) => self.process_trait_ref(trait_ref),\n+            None => (),\n+        }\n+\n+        self.process_generic_params(type_parameters, item.span, \"\", item.id);\n+        for impl_item in impl_items {\n+            self.visit_impl_item(impl_item);\n+        }\n+    }\n+\n+    fn process_trait(&mut self,\n+                     item: &ast::Item,\n+                     generics: &ast::Generics,\n+                     trait_refs: &OwnedSlice<ast::TyParamBound>,\n+                     methods: &[P<ast::TraitItem>]) {\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let val = self.span.snippet(item.span);\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n+        self.fmt.trait_str(item.span,\n+                           sub_span,\n+                           item.id,\n+                           &qualname[..],\n+                           self.cur_scope,\n+                           &val[..]);\n+\n+        // super-traits\n+        for super_bound in &**trait_refs {\n+            let trait_ref = match *super_bound {\n+                ast::TraitTyParamBound(ref trait_ref, _) => {\n+                    trait_ref\n+                }\n+                ast::RegionTyParamBound(..) => {\n+                    continue;\n+                }\n+            };\n+\n+            let trait_ref = &trait_ref.trait_ref;\n+            match self.lookup_type_ref(trait_ref.ref_id) {\n+                Some(id) => {\n+                    let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n+                    self.fmt.ref_str(recorder::TypeRef,\n+                                     trait_ref.path.span,\n+                                     sub_span,\n+                                     id,\n+                                     self.cur_scope);\n+                    self.fmt.inherit_str(trait_ref.path.span,\n+                                         sub_span,\n+                                         id,\n+                                         item.id);\n+                },\n+                None => ()\n+            }\n+        }\n+\n+        // walk generics and methods\n+        self.process_generic_params(generics, item.span, &qualname[..], item.id);\n+        for method in methods {\n+            self.visit_trait_item(method)\n+        }\n+    }\n+\n+    fn process_mod(&mut self,\n+                   item: &ast::Item,  // The module in question, represented as an item.\n+                   m: &ast::Mod) {\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+\n+        let cm = self.sess.codemap();\n+        let filename = cm.span_to_filename(m.inner);\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Mod);\n+        self.fmt.mod_str(item.span,\n+                         sub_span,\n+                         item.id,\n+                         &qualname[..],\n+                         self.cur_scope,\n+                         &filename[..]);\n+\n+        self.nest(item.id, |v| visit::walk_mod(v, m));\n+    }\n+\n+    fn process_path(&mut self,\n+                    id: NodeId,\n+                    span: Span,\n+                    path: &ast::Path,\n+                    ref_kind: Option<recorder::Row>) {\n+        if generated_code(span) {\n+            return\n+        }\n+\n+        let def_map = self.analysis.ty_cx.def_map.borrow();\n+        if !def_map.contains_key(&id) {\n+            self.sess.span_bug(span,\n+                               &format!(\"def_map has no key for {} in visit_expr\", id));\n+        }\n+        let def = def_map.get(&id).unwrap().full_def();\n+        let sub_span = self.span.span_for_last_ident(span);\n+        match def {\n+            def::DefUpvar(..) |\n+            def::DefLocal(..) |\n+            def::DefStatic(..) |\n+            def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n+            def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n+                                                    span,\n+                                                    sub_span,\n+                                                    def.def_id(),\n+                                                    self.cur_scope),\n+            def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n+                                                       span,\n+                                                       sub_span,\n+                                                       def_id,\n+                                                       self.cur_scope),\n+            def::DefTy(def_id, _) => self.fmt.ref_str(recorder::TypeRef,\n+                                                      span,\n+                                                      sub_span,\n+                                                      def_id,\n+                                                      self.cur_scope),\n+            def::DefMethod(declid, provenence) => {\n+                let sub_span = self.span.sub_span_for_meth_name(span);\n+                let defid = if declid.krate == ast::LOCAL_CRATE {\n+                    let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n+                                                    declid);\n+                    match provenence {\n+                        def::FromTrait(def_id) => {\n+                            Some(ty::trait_items(&self.analysis.ty_cx,\n+                                                 def_id)\n+                                    .iter()\n+                                    .find(|mr| {\n+                                        mr.name() == ti.name()\n+                                    })\n+                                    .unwrap()\n+                                    .def_id())\n+                        }\n+                        def::FromImpl(def_id) => {\n+                            let impl_items = self.analysis\n+                                                 .ty_cx\n+                                                 .impl_items\n+                                                 .borrow();\n+                            Some(impl_items.get(&def_id)\n+                                           .unwrap()\n+                                           .iter()\n+                                           .find(|mr| {\n+                                                ty::impl_or_trait_item(\n+                                                    &self.analysis.ty_cx,\n+                                                    mr.def_id()\n+                                                ).name() == ti.name()\n+                                            })\n+                                           .unwrap()\n+                                           .def_id())\n+                        }\n+                    }\n+                } else {\n+                    None\n+                };\n+                self.fmt.meth_call_str(span,\n+                                       sub_span,\n+                                       defid,\n+                                       Some(declid),\n+                                       self.cur_scope);\n+            },\n+            def::DefFn(def_id, _) => {\n+                self.fmt.fn_call_str(span,\n+                                     sub_span,\n+                                     def_id,\n+                                     self.cur_scope)\n+            }\n+            _ => self.sess.span_bug(span,\n+                                    &format!(\"Unexpected def kind while looking \\\n+                                              up path in `{}`: `{:?}`\",\n+                                             self.span.snippet(span),\n+                                             def)),\n+        }\n+        // modules or types in the path prefix\n+        match def {\n+            def::DefMethod(did, _) => {\n+                let ti = ty::impl_or_trait_item(&self.analysis.ty_cx, did);\n+                if let ty::MethodTraitItem(m) = ti {\n+                    if m.explicit_self == ty::StaticExplicitSelfCategory {\n+                        self.write_sub_path_trait_truncated(path);\n+                    }\n+                }\n+            }\n+            def::DefLocal(_) |\n+            def::DefStatic(_,_) |\n+            def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n+            def::DefStruct(_) |\n+            def::DefVariant(..) |\n+            def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n+            _ => {},\n+        }\n+    }\n+\n+    fn process_struct_lit(&mut self,\n+                          ex: &ast::Expr,\n+                          path: &ast::Path,\n+                          fields: &Vec<ast::Field>,\n+                          base: &Option<P<ast::Expr>>) {\n+        if generated_code(path.span) {\n+            return\n+        }\n+\n+        self.write_sub_paths_truncated(path, false);\n+\n+        let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, ex).sty;\n+        let struct_def = match *ty {\n+            ty::ty_struct(def_id, _) => {\n+                let sub_span = self.span.span_for_last_ident(path.span);\n+                self.fmt.ref_str(recorder::StructRef,\n+                                 path.span,\n+                                 sub_span,\n+                                 def_id,\n+                                 self.cur_scope);\n+                Some(def_id)\n+            }\n+            _ => None\n+        };\n+\n+        for field in fields {\n+            match struct_def {\n+                Some(struct_def) => {\n+                    let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n+                    for f in &fields {\n+                        if generated_code(field.ident.span) {\n+                            continue;\n+                        }\n+                        if f.name == field.ident.node.name {\n+                            // We don't really need a sub-span here, but no harm done\n+                            let sub_span = self.span.span_for_last_ident(field.ident.span);\n+                            self.fmt.ref_str(recorder::VarRef,\n+                                             field.ident.span,\n+                                             sub_span,\n+                                             f.id,\n+                                             self.cur_scope);\n+                        }\n+                    }\n+                }\n+                None => {}\n+            }\n+\n+            self.visit_expr(&*field.expr)\n+        }\n+        visit::walk_expr_opt(self, base)\n+    }\n+\n+    fn process_method_call(&mut self,\n+                           ex: &ast::Expr,\n+                           args: &Vec<P<ast::Expr>>) {\n+        let method_map = self.analysis.ty_cx.method_map.borrow();\n+        let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n+        let (def_id, decl_id) = match method_callee.origin {\n+            ty::MethodStatic(def_id) |\n+            ty::MethodStaticClosure(def_id) => {\n+                // method invoked on an object with a concrete type (not a static method)\n+                let decl_id =\n+                    match ty::trait_item_of_item(&self.analysis.ty_cx,\n+                                                 def_id) {\n+                        None => None,\n+                        Some(decl_id) => Some(decl_id.def_id()),\n+                    };\n+\n+                // This incantation is required if the method referenced is a\n+                // trait's default implementation.\n+                let def_id = match ty::impl_or_trait_item(&self.analysis\n+                                                               .ty_cx,\n+                                                          def_id) {\n+                    ty::MethodTraitItem(method) => {\n+                        method.provided_source.unwrap_or(def_id)\n+                    }\n+                    _ => self.sess\n+                             .span_bug(ex.span,\n+                                       \"save::process_method_call: non-method \\\n+                                        DefId in MethodStatic or MethodStaticClosure\"),\n+                };\n+                (Some(def_id), decl_id)\n+            }\n+            ty::MethodTypeParam(ref mp) => {\n+                // method invoked on a type parameter\n+                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n+                                                mp.trait_ref.def_id,\n+                                                mp.method_num);\n+                (None, Some(trait_item.def_id()))\n+            }\n+            ty::MethodTraitObject(ref mo) => {\n+                // method invoked on a trait instance\n+                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n+                                                mo.trait_ref.def_id,\n+                                                mo.method_num);\n+                (None, Some(trait_item.def_id()))\n+            }\n+        };\n+        let sub_span = self.span.sub_span_for_meth_name(ex.span);\n+        self.fmt.meth_call_str(ex.span,\n+                               sub_span,\n+                               def_id,\n+                               decl_id,\n+                               self.cur_scope);\n+\n+        // walk receiver and args\n+        visit::walk_exprs(self, &args[..]);\n+    }\n+\n+    fn process_pat(&mut self, p:&ast::Pat) {\n+        if generated_code(p.span) {\n+            return\n+        }\n+\n+        match p.node {\n+            ast::PatStruct(ref path, ref fields, _) => {\n+                self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n+                visit::walk_path(self, path);\n+\n+                let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n+                let struct_def = match def {\n+                    def::DefConst(..) | def::DefAssociatedConst(..) => None,\n+                    def::DefVariant(_, variant_id, _) => Some(variant_id),\n+                    _ => {\n+                        match ty::ty_to_def_id(ty::node_id_to_type(&self.analysis.ty_cx, p.id)) {\n+                            None => {\n+                                self.sess.span_bug(p.span,\n+                                                   &format!(\"Could not find struct_def for `{}`\",\n+                                                            self.span.snippet(p.span)));\n+                            }\n+                            Some(def_id) => Some(def_id),\n+                        }\n+                    }\n+                };\n+\n+                if let Some(struct_def) = struct_def {\n+                    let struct_fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n+                    for &Spanned { node: ref field, span } in fields {\n+                        let sub_span = self.span.span_for_first_ident(span);\n+                        for f in &struct_fields {\n+                            if f.name == field.ident.name {\n+                                self.fmt.ref_str(recorder::VarRef,\n+                                                 span,\n+                                                 sub_span,\n+                                                 f.id,\n+                                                 self.cur_scope);\n+                                break;\n+                            }\n+                        }\n+                        self.visit_pat(&*field.pat);\n+                    }\n+                }\n+            }\n+            ast::PatEnum(ref path, _) |\n+            ast::PatQPath(_, ref path) => {\n+                self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n+                visit::walk_pat(self, p);\n+            }\n+            ast::PatIdent(bm, ref path1, ref optional_subpattern) => {\n+                let immut = match bm {\n+                    // Even if the ref is mut, you can't change the ref, only\n+                    // the data pointed at, so showing the initialising expression\n+                    // is still worthwhile.\n+                    ast::BindByRef(_) => true,\n+                    ast::BindByValue(mt) => {\n+                        match mt {\n+                            ast::MutMutable => false,\n+                            ast::MutImmutable => true,\n+                        }\n+                    }\n+                };\n+                // collect path for either visit_local or visit_arm\n+                let path = ast_util::ident_to_path(path1.span,path1.node);\n+                self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n+                match *optional_subpattern {\n+                    None => {}\n+                    Some(ref subpattern) => self.visit_pat(&**subpattern)\n+                }\n+            }\n+            _ => visit::walk_pat(self, p)\n+        }\n+    }\n+}\n+\n+impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        if generated_code(item.span) {\n+            return\n+        }\n+\n+        match item.node {\n+            ast::ItemUse(ref use_item) => {\n+                match use_item.node {\n+                    ast::ViewPathSimple(ident, ref path) => {\n+                        let sub_span = self.span.span_for_last_ident(path.span);\n+                        let mod_id = match self.lookup_type_ref(item.id) {\n+                            Some(def_id) => {\n+                                match self.lookup_def_kind(item.id, path.span) {\n+                                    Some(kind) => self.fmt.ref_str(kind,\n+                                                                   path.span,\n+                                                                   sub_span,\n+                                                                   def_id,\n+                                                                   self.cur_scope),\n+                                    None => {},\n+                                }\n+                                Some(def_id)\n+                            },\n+                            None => None,\n+                        };\n+\n+                        // 'use' always introduces an alias, if there is not an explicit\n+                        // one, there is an implicit one.\n+                        let sub_span =\n+                            match self.span.sub_span_after_keyword(use_item.span, keywords::As) {\n+                                Some(sub_span) => Some(sub_span),\n+                                None => sub_span,\n+                            };\n+\n+                        self.fmt.use_alias_str(path.span,\n+                                               sub_span,\n+                                               item.id,\n+                                               mod_id,\n+                                               &get_ident(ident),\n+                                               self.cur_scope);\n+                        self.write_sub_paths_truncated(path, true);\n+                    }\n+                    ast::ViewPathGlob(ref path) => {\n+                        // Make a comma-separated list of names of imported modules.\n+                        let mut name_string = String::new();\n+                        let glob_map = &self.analysis.glob_map;\n+                        let glob_map = glob_map.as_ref().unwrap();\n+                        if glob_map.contains_key(&item.id) {\n+                            for n in glob_map.get(&item.id).unwrap() {\n+                                if !name_string.is_empty() {\n+                                    name_string.push_str(\", \");\n+                                }\n+                                name_string.push_str(n.as_str());\n+                            }\n+                        }\n+\n+                        let sub_span = self.span.sub_span_of_token(path.span,\n+                                                                   token::BinOp(token::Star));\n+                        self.fmt.use_glob_str(path.span,\n+                                              sub_span,\n+                                              item.id,\n+                                              &name_string,\n+                                              self.cur_scope);\n+                        self.write_sub_paths(path, true);\n+                    }\n+                    ast::ViewPathList(ref path, ref list) => {\n+                        for plid in list {\n+                            match plid.node {\n+                                ast::PathListIdent { id, .. } => {\n+                                    match self.lookup_type_ref(id) {\n+                                        Some(def_id) =>\n+                                            match self.lookup_def_kind(id, plid.span) {\n+                                                Some(kind) => {\n+                                                    self.fmt.ref_str(\n+                                                        kind, plid.span,\n+                                                        Some(plid.span),\n+                                                        def_id, self.cur_scope);\n+                                                }\n+                                                None => ()\n+                                            },\n+                                        None => ()\n+                                    }\n+                                },\n+                                ast::PathListMod { .. } => ()\n+                            }\n+                        }\n+\n+                        self.write_sub_paths(path, true);\n+                    }\n+                }\n+            }\n+            ast::ItemExternCrate(ref s) => {\n+                let name = get_ident(item.ident);\n+                let name = &name;\n+                let location = match *s {\n+                    Some(s) => s.to_string(),\n+                    None => name.to_string(),\n+                };\n+                let alias_span = self.span.span_for_last_ident(item.span);\n+                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                    Some(cnum) => cnum,\n+                    None => 0,\n+                };\n+                self.fmt.extern_crate_str(item.span,\n+                                          alias_span,\n+                                          item.id,\n+                                          cnum,\n+                                          name,\n+                                          &location[..],\n+                                          self.cur_scope);\n+            }\n+            ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n+                self.process_fn(item, &**decl, ty_params, &**body),\n+            ast::ItemStatic(ref typ, mt, ref expr) =>\n+                self.process_static(item, &**typ, mt, &**expr),\n+            ast::ItemConst(ref typ, ref expr) =>\n+                self.process_const(item.id, &item.ident, item.span, &*typ, &*expr),\n+            ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n+            ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n+            ast::ItemImpl(_, _,\n+                          ref ty_params,\n+                          ref trait_ref,\n+                          ref typ,\n+                          ref impl_items) => {\n+                self.process_impl(item,\n+                                  ty_params,\n+                                  trait_ref,\n+                                  &**typ,\n+                                  impl_items)\n+            }\n+            ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>\n+                self.process_trait(item, generics, trait_refs, methods),\n+            ast::ItemMod(ref m) => self.process_mod(item, m),\n+            ast::ItemTy(ref ty, ref ty_params) => {\n+                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let value = ty_to_string(&**ty);\n+                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n+                self.fmt.typedef_str(item.span,\n+                                     sub_span,\n+                                     item.id,\n+                                     &qualname[..],\n+                                     &value[..]);\n+\n+                self.visit_ty(&**ty);\n+                self.process_generic_params(ty_params, item.span, &qualname, item.id);\n+            },\n+            ast::ItemMac(_) => (),\n+            _ => visit::walk_item(self, item),\n+        }\n+    }\n+\n+    fn visit_generics(&mut self, generics: &ast::Generics) {\n+        for param in &*generics.ty_params {\n+            for bound in &*param.bounds {\n+                if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n+                    self.process_trait_ref(&trait_ref.trait_ref);\n+                }\n+            }\n+            if let Some(ref ty) = param.default {\n+                self.visit_ty(&**ty);\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        match trait_item.node {\n+            ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n+                self.process_const(trait_item.id, &trait_item.ident,\n+                                   trait_item.span, &*ty, &*expr);\n+            }\n+            ast::MethodTraitItem(ref sig, ref body) => {\n+                self.process_method(sig, body.as_ref().map(|x| &**x),\n+                                    trait_item.id, trait_item.ident.name, trait_item.span);\n+            }\n+            ast::ConstTraitItem(_, None) |\n+            ast::TypeTraitItem(..) => {}\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        match impl_item.node {\n+            ast::ConstImplItem(ref ty, ref expr) => {\n+                self.process_const(impl_item.id, &impl_item.ident,\n+                                   impl_item.span, &ty, &expr);\n+            }\n+            ast::MethodImplItem(ref sig, ref body) => {\n+                self.process_method(sig, Some(body), impl_item.id,\n+                                    impl_item.ident.name, impl_item.span);\n+            }\n+            ast::TypeImplItem(_) |\n+            ast::MacImplItem(_) => {}\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n+        if generated_code(t.span) {\n+            return\n+        }\n+\n+        match t.node {\n+            ast::TyPath(_, ref path) => {\n+                match self.lookup_type_ref(t.id) {\n+                    Some(id) => {\n+                        let sub_span = self.span.sub_span_for_type_name(t.span);\n+                        self.fmt.ref_str(recorder::TypeRef,\n+                                         t.span,\n+                                         sub_span,\n+                                         id,\n+                                         self.cur_scope);\n+                    },\n+                    None => ()\n+                }\n+\n+                self.write_sub_paths_truncated(path, false);\n+\n+                visit::walk_path(self, path);\n+            },\n+            _ => visit::walk_ty(self, t),\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n+        if generated_code(ex.span) {\n+            return\n+        }\n+\n+        match ex.node {\n+            ast::ExprCall(ref _f, ref _args) => {\n+                // Don't need to do anything for function calls,\n+                // because just walking the callee path does what we want.\n+                visit::walk_expr(self, ex);\n+            }\n+            ast::ExprPath(_, ref path) => {\n+                self.process_path(ex.id, path.span, path, None);\n+                visit::walk_expr(self, ex);\n+            }\n+            ast::ExprStruct(ref path, ref fields, ref base) =>\n+                self.process_struct_lit(ex, path, fields, base),\n+            ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n+            ast::ExprField(ref sub_ex, ident) => {\n+                if generated_code(sub_ex.span) {\n+                    return\n+                }\n+\n+                self.visit_expr(&**sub_ex);\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                match *ty {\n+                    ty::ty_struct(def_id, _) => {\n+                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n+                        for f in &fields {\n+                            if f.name == ident.node.name {\n+                                let sub_span = self.span.span_for_last_ident(ex.span);\n+                                self.fmt.ref_str(recorder::VarRef,\n+                                                 ex.span,\n+                                                 sub_span,\n+                                                 f.id,\n+                                                 self.cur_scope);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    _ => self.sess.span_bug(ex.span,\n+                                            &format!(\"Expected struct type, found {:?}\", ty)),\n+                }\n+            },\n+            ast::ExprTupField(ref sub_ex, idx) => {\n+                if generated_code(sub_ex.span) {\n+                    return\n+                }\n+\n+                self.visit_expr(&**sub_ex);\n+\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n+                match *ty {\n+                    ty::ty_struct(def_id, _) => {\n+                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n+                        for (i, f) in fields.iter().enumerate() {\n+                            if i == idx.node {\n+                                let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n+                                self.fmt.ref_str(recorder::VarRef,\n+                                                 ex.span,\n+                                                 sub_span,\n+                                                 f.id,\n+                                                 self.cur_scope);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    ty::ty_tup(_) => {}\n+                    _ => self.sess.span_bug(ex.span,\n+                                            &format!(\"Expected struct or tuple \\\n+                                                      type, found {:?}\", ty)),\n+                }\n+            },\n+            ast::ExprClosure(_, ref decl, ref body) => {\n+                if generated_code(body.span) {\n+                    return\n+                }\n+\n+                let mut id = String::from_str(\"$\");\n+                id.push_str(&ex.id.to_string());\n+                self.process_formals(&decl.inputs, &id[..]);\n+\n+                // walk arg and return types\n+                for arg in &decl.inputs {\n+                    self.visit_ty(&*arg.ty);\n+                }\n+\n+                if let ast::Return(ref ret_ty) = decl.output {\n+                    self.visit_ty(&**ret_ty);\n+                }\n+\n+                // walk the body\n+                self.nest(ex.id, |v| v.visit_block(&**body));\n+            },\n+            _ => {\n+                visit::walk_expr(self, ex)\n+            },\n+        }\n+    }\n+\n+    fn visit_mac(&mut self, _: &ast::Mac) {\n+        // Just stop, macros are poison to us.\n+    }\n+\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n+        self.process_pat(p);\n+        if !self.collecting {\n+            self.collected_paths.clear();\n+        }\n+    }\n+\n+    fn visit_arm(&mut self, arm: &ast::Arm) {\n+        assert!(self.collected_paths.is_empty() && !self.collecting);\n+        self.collecting = true;\n+        for pattern in &arm.pats {\n+            // collect paths from the arm's patterns\n+            self.visit_pat(&**pattern);\n+        }\n+\n+        // This is to get around borrow checking, because we need mut self to call process_path.\n+        let mut paths_to_process = vec![];\n+        // process collected paths\n+        for &(id, ref p, ref immut, ref_kind) in &self.collected_paths {\n+            let def_map = self.analysis.ty_cx.def_map.borrow();\n+            if !def_map.contains_key(&id) {\n+                self.sess.span_bug(p.span,\n+                                   &format!(\"def_map has no key for {} in visit_arm\",\n+                                           id));\n+            }\n+            let def = def_map.get(&id).unwrap().full_def();\n+            match def {\n+                def::DefLocal(id)  => {\n+                    let value = if *immut {\n+                        self.span.snippet(p.span).to_string()\n+                    } else {\n+                        \"<mutable>\".to_string()\n+                    };\n+\n+                    assert!(p.segments.len() == 1, \"qualified path for local variable def in arm\");\n+                    self.fmt.variable_str(p.span,\n+                                          Some(p.span),\n+                                          id,\n+                                          &path_to_string(p),\n+                                          &value[..],\n+                                          \"\")\n+                }\n+                def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n+                    paths_to_process.push((id, p.clone(), Some(ref_kind)))\n+                }\n+                // FIXME(nrc) what are these doing here?\n+                def::DefStatic(_, _) |\n+                def::DefConst(..) |\n+                def::DefAssociatedConst(..) => {}\n+                _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n+                            def)\n+            }\n+        }\n+        for &(id, ref path, ref_kind) in &paths_to_process {\n+            self.process_path(id, path.span, path, ref_kind);\n+        }\n+        self.collecting = false;\n+        self.collected_paths.clear();\n+        visit::walk_expr_opt(self, &arm.guard);\n+        self.visit_expr(&*arm.body);\n+    }\n+\n+    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+        if generated_code(s.span) {\n+            return\n+        }\n+\n+        visit::walk_stmt(self, s)\n+    }\n+\n+    fn visit_local(&mut self, l: &ast::Local) {\n+        if generated_code(l.span) {\n+            return\n+        }\n+\n+        // The local could declare multiple new vars, we must walk the\n+        // pattern and collect them all.\n+        assert!(self.collected_paths.is_empty() && !self.collecting);\n+        self.collecting = true;\n+        self.visit_pat(&*l.pat);\n+        self.collecting = false;\n+\n+        let value = self.span.snippet(l.span);\n+\n+        for &(id, ref p, ref immut, _) in &self.collected_paths {\n+            let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n+            let types = self.analysis.ty_cx.node_types();\n+            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n+            // Get the span only for the name of the variable (I hope the path\n+            // is only ever a variable name, but who knows?).\n+            let sub_span = self.span.span_for_last_ident(p.span);\n+            // Rust uses the id of the pattern for var lookups, so we'll use it too.\n+            self.fmt.variable_str(p.span,\n+                                  sub_span,\n+                                  id,\n+                                  &path_to_string(p),\n+                                  &value[..],\n+                                  &typ[..]);\n+        }\n+        self.collected_paths.clear();\n+\n+        // Just walk the initialiser and type (don't want to walk the pattern again).\n+        visit::walk_ty_opt(self, &l.ty);\n+        visit::walk_expr_opt(self, &l.init);\n+    }\n+}"}, {"sha": "7421344548c4f1f17b06b55e6254480eb6e61dd8", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 18, "deletions": 1510, "changes": 1528, "blob_url": "https://github.com/rust-lang/rust/blob/4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=4f9b04bf9e14bb8cb718e5dd9564ac0b698a8395", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,1506 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Output a CSV file containing the output from rustc's analysis. The data is\n-//! primarily designed to be used as input to the DXR tool, specifically its\n-//! Rust plugin. It could also be used by IDEs or other code browsing, search, or\n-//! cross-referencing tools.\n-//!\n-//! Dumping the analysis is implemented by walking the AST and getting a bunch of\n-//! info out from all over the place. We use Def IDs to identify objects. The\n-//! tricky part is getting syntactic (span, source text) and semantic (reference\n-//! Def IDs) information for parts of expressions which the compiler has discarded.\n-//! E.g., in a path `foo::bar::baz`, the compiler only keeps a span for the whole\n-//! path and a reference to `baz`, but we want spans and references for all three\n-//! idents.\n-//!\n-//! SpanUtils is used to manipulate spans. In particular, to extract sub-spans\n-//! from spans (e.g., the span for `bar` from the above example path).\n-//! Recorder is used for recording the output in csv format. FmtStrs separates\n-//! the format of the output away from extracting it from the compiler.\n-//! DxrVisitor walks the AST and processes it.\n-\n use session::Session;\n+use middle::ty;\n \n-use middle::def;\n-use middle::ty::{self, Ty};\n-\n-use std::cell::Cell;\n use std::env;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n-use syntax::ast_util;\n-use syntax::ast::{self, NodeId, DefId};\n-use syntax::ast_map::NodeItem;\n-use syntax::attr;\n+use syntax::{ast, attr, visit};\n use syntax::codemap::*;\n-use syntax::parse::token::{self, get_ident, keywords};\n-use syntax::owned_slice::OwnedSlice;\n-use syntax::visit::{self, Visitor};\n-use syntax::print::pprust::{path_to_string, ty_to_string};\n-use syntax::ptr::P;\n-\n-use self::span_utils::SpanUtils;\n-use self::recorder::{Recorder, FmtStrs};\n-\n-use util::ppaux;\n \n mod span_utils;\n mod recorder;\n \n-// Helper function to escape quotes in a string\n-fn escape(s: String) -> String {\n-    s.replace(\"\\\"\", \"\\\"\\\"\")\n-}\n-\n-// If the expression is a macro expansion or other generated code, run screaming and don't index.\n-fn generated_code(span: Span) -> bool {\n-    span.expn_id != NO_EXPANSION || span  == DUMMY_SP\n-}\n-\n-struct DxrVisitor<'l, 'tcx: 'l> {\n-    sess: &'l Session,\n-    analysis: &'l ty::CrateAnalysis<'tcx>,\n-\n-    collected_paths: Vec<(NodeId, ast::Path, bool, recorder::Row)>,\n-    collecting: bool,\n-\n-    span: SpanUtils<'l>,\n-    fmt: FmtStrs<'l>,\n-\n-    cur_scope: NodeId\n-}\n-\n-impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n-    fn nest<F>(&mut self, scope_id: NodeId, f: F) where\n-        F: FnOnce(&mut DxrVisitor<'l, 'tcx>),\n-    {\n-        let parent_scope = self.cur_scope;\n-        self.cur_scope = scope_id;\n-        f(self);\n-        self.cur_scope = parent_scope;\n-    }\n-\n-    fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n-        // the current crate\n-        self.fmt.crate_str(krate.span, name);\n-\n-        // dump info about all the external crates referenced from this crate\n-        self.sess.cstore.iter_crate_data(|n, cmd| {\n-            self.fmt.external_crate_str(krate.span, &cmd.name, n);\n-        });\n-        self.fmt.recorder.record(\"end_external_crates\\n\");\n-    }\n-\n-    // Return all non-empty prefixes of a path.\n-    // For each prefix, we return the span for the last segment in the prefix and\n-    // a str representation of the entire prefix.\n-    fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n-        let spans = self.span.spans_for_path_segments(path);\n-\n-        // Paths to enums seem to not match their spans - the span includes all the\n-        // variants too. But they seem to always be at the end, so I hope we can cope with\n-        // always using the first ones. So, only error out if we don't have enough spans.\n-        // What could go wrong...?\n-        if spans.len() < path.segments.len() {\n-            error!(\"Mis-calculated spans for path '{}'. \\\n-                    Found {} spans, expected {}. Found spans:\",\n-                   path_to_string(path), spans.len(), path.segments.len());\n-            for s in &spans {\n-                let loc = self.sess.codemap().lookup_char_pos(s.lo);\n-                error!(\"    '{}' in {}, line {}\",\n-                       self.span.snippet(*s), loc.file.name, loc.line);\n-            }\n-            return vec!();\n-        }\n-\n-        let mut result: Vec<(Span, String)> = vec!();\n-\n-        let mut segs = vec!();\n-        for (i, (seg, span)) in path.segments.iter().zip(spans.iter()).enumerate() {\n-            segs.push(seg.clone());\n-            let sub_path = ast::Path{span: *span, // span for the last segment\n-                                     global: path.global,\n-                                     segments: segs};\n-            let qualname = if i == 0 && path.global {\n-                format!(\"::{}\", path_to_string(&sub_path))\n-            } else {\n-                path_to_string(&sub_path)\n-            };\n-            result.push((*span, qualname));\n-            segs = sub_path.segments;\n-        }\n-\n-        result\n-    }\n-\n-    // The global arg allows us to override the global-ness of the path (which\n-    // actually means 'does the path start with `::`', rather than 'is the path\n-    // semantically global). We use the override for `use` imports (etc.) where\n-    // the syntax is non-global, but the semantics are global.\n-    fn write_sub_paths(&mut self, path: &ast::Path, global: bool) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n-            let qualname = if i == 0 && global && !path.global {\n-                format!(\"::{}\", qualname)\n-            } else {\n-                qualname.clone()\n-            };\n-            self.fmt.sub_mod_ref_str(path.span,\n-                                     *span,\n-                                     &qualname[..],\n-                                     self.cur_scope);\n-        }\n-    }\n-\n-    // As write_sub_paths, but does not process the last ident in the path (assuming it\n-    // will be processed elsewhere). See note on write_sub_paths about global.\n-    fn write_sub_paths_truncated(&mut self, path: &ast::Path, global: bool) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        let len = sub_paths.len();\n-        if len <= 1 {\n-            return;\n-        }\n-\n-        let sub_paths = &sub_paths[..len-1];\n-        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n-            let qualname = if i == 0 && global && !path.global {\n-                format!(\"::{}\", qualname)\n-            } else {\n-                qualname.clone()\n-            };\n-            self.fmt.sub_mod_ref_str(path.span,\n-                                     *span,\n-                                     &qualname[..],\n-                                     self.cur_scope);\n-        }\n-    }\n-\n-    // As write_sub_paths, but expects a path of the form module_path::trait::method\n-    // Where trait could actually be a struct too.\n-    fn write_sub_path_trait_truncated(&mut self, path: &ast::Path) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        let len = sub_paths.len();\n-        if len <= 1 {\n-            return;\n-        }\n-        let sub_paths = &sub_paths[.. (len-1)];\n-\n-        // write the trait part of the sub-path\n-        let (ref span, ref qualname) = sub_paths[len-2];\n-        self.fmt.sub_type_ref_str(path.span,\n-                                  *span,\n-                                  &qualname[..]);\n-\n-        // write the other sub-paths\n-        if len <= 2 {\n-            return;\n-        }\n-        let sub_paths = &sub_paths[..len-2];\n-        for &(ref span, ref qualname) in sub_paths {\n-            self.fmt.sub_mod_ref_str(path.span,\n-                                     *span,\n-                                     &qualname[..],\n-                                     self.cur_scope);\n-        }\n-    }\n-\n-    // looks up anything, not just a type\n-    fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n-        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n-            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id));\n-        }\n-        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n-        match def {\n-            def::DefPrimTy(_) => None,\n-            _ => Some(def.def_id()),\n-        }\n-    }\n-\n-    fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n-        let def_map = self.analysis.ty_cx.def_map.borrow();\n-        if !def_map.contains_key(&ref_id) {\n-            self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id));\n-        }\n-        let def = def_map.get(&ref_id).unwrap().full_def();\n-        match def {\n-            def::DefMod(_) |\n-            def::DefForeignMod(_) => Some(recorder::ModRef),\n-            def::DefStruct(_) => Some(recorder::StructRef),\n-            def::DefTy(..) |\n-            def::DefAssociatedTy(..) |\n-            def::DefTrait(_) => Some(recorder::TypeRef),\n-            def::DefStatic(_, _) |\n-            def::DefConst(_) |\n-            def::DefAssociatedConst(..) |\n-            def::DefLocal(_) |\n-            def::DefVariant(_, _, _) |\n-            def::DefUpvar(..) => Some(recorder::VarRef),\n-\n-            def::DefFn(..) => Some(recorder::FnRef),\n-\n-            def::DefSelfTy(..) |\n-            def::DefRegion(_) |\n-            def::DefLabel(_) |\n-            def::DefTyParam(..) |\n-            def::DefUse(_) |\n-            def::DefMethod(..) |\n-            def::DefPrimTy(_) => {\n-                self.sess.span_bug(span, &format!(\"lookup_def_kind for unexpected item: {:?}\",\n-                                                 def));\n-            },\n-        }\n-    }\n-\n-    fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n-        for arg in formals {\n-            assert!(self.collected_paths.is_empty() && !self.collecting);\n-            self.collecting = true;\n-            self.visit_pat(&*arg.pat);\n-            self.collecting = false;\n-            let span_utils = self.span.clone();\n-            for &(id, ref p, _, _) in &self.collected_paths {\n-                let typ =\n-                    ppaux::ty_to_string(\n-                        &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types().get(&id).unwrap());\n-                // get the span only for the name of the variable (I hope the path is only ever a\n-                // variable name, but who knows?)\n-                self.fmt.formal_str(p.span,\n-                                    span_utils.span_for_last_ident(p.span),\n-                                    id,\n-                                    qualname,\n-                                    &path_to_string(p),\n-                                    &typ[..]);\n-            }\n-            self.collected_paths.clear();\n-        }\n-    }\n-\n-    fn process_method(&mut self, sig: &ast::MethodSig,\n-                      body: Option<&ast::Block>,\n-                      id: ast::NodeId, name: ast::Name,\n-                      span: Span) {\n-        if generated_code(span) {\n-            return;\n-        }\n-\n-        debug!(\"process_method: {}:{}\", id, token::get_name(name));\n-\n-        let mut scope_id;\n-        // The qualname for a method is the trait name or name of the struct in an impl in\n-        // which the method is declared in, followed by the method's name.\n-        let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n-                                                ast_util::local_def(id)) {\n-            Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n-                NodeItem(item) => {\n-                    scope_id = item.id;\n-                    match item.node {\n-                        ast::ItemImpl(_, _, _, _, ref ty, _) => {\n-                            let mut result = String::from_str(\"<\");\n-                            result.push_str(&ty_to_string(&**ty));\n-\n-                            match ty::trait_of_item(&self.analysis.ty_cx,\n-                                                    ast_util::local_def(id)) {\n-                                Some(def_id) => {\n-                                    result.push_str(\" as \");\n-                                    result.push_str(\n-                                        &ty::item_path_str(&self.analysis.ty_cx, def_id));\n-                                },\n-                                None => {}\n-                            }\n-                            result.push_str(\">\");\n-                            result\n-                        }\n-                        _ => {\n-                            self.sess.span_bug(span,\n-                                &format!(\"Container {} for method {} not an impl?\",\n-                                         impl_id.node, id));\n-                        },\n-                    }\n-                },\n-                _ => {\n-                    self.sess.span_bug(span,\n-                        &format!(\"Container {} for method {} is not a node item {:?}\",\n-                                 impl_id.node, id, self.analysis.ty_cx.map.get(impl_id.node)));\n-                },\n-            },\n-            None => match ty::trait_of_item(&self.analysis.ty_cx,\n-                                            ast_util::local_def(id)) {\n-                Some(def_id) => {\n-                    scope_id = def_id.node;\n-                    match self.analysis.ty_cx.map.get(def_id.node) {\n-                        NodeItem(_) => {\n-                            format!(\"::{}\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n-                        }\n-                        _ => {\n-                            self.sess.span_bug(span,\n-                                &format!(\"Could not find container {} for method {}\",\n-                                         def_id.node, id));\n-                        }\n-                    }\n-                },\n-                None => {\n-                    self.sess.span_bug(span,\n-                        &format!(\"Could not find container for method {}\", id));\n-                },\n-            },\n-        };\n-\n-        let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n-\n-        // record the decl for this def (if it has one)\n-        let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n-                                             ast_util::local_def(id))\n-            .and_then(|new_id| {\n-                let def_id = new_id.def_id();\n-                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n-                    Some(def_id)\n-                } else {\n-                    None\n-                }\n-            });\n-\n-        let sub_span = self.span.sub_span_after_keyword(span, keywords::Fn);\n-        if body.is_some() {\n-            self.fmt.method_str(span,\n-                                sub_span,\n-                                id,\n-                                qualname,\n-                                decl_id,\n-                                scope_id);\n-            self.process_formals(&sig.decl.inputs, qualname);\n-        } else {\n-            self.fmt.method_decl_str(span,\n-                                     sub_span,\n-                                     id,\n-                                     qualname,\n-                                     scope_id);\n-        }\n-\n-        // walk arg and return types\n-        for arg in &sig.decl.inputs {\n-            self.visit_ty(&arg.ty);\n-        }\n-\n-        if let ast::Return(ref ret_ty) = sig.decl.output {\n-            self.visit_ty(ret_ty);\n-        }\n-\n-        // walk the fn body\n-        if let Some(body) = body {\n-            self.nest(id, |v| v.visit_block(body));\n-        }\n-\n-        self.process_generic_params(&sig.generics,\n-                                    span,\n-                                    qualname,\n-                                    id);\n-    }\n-\n-    fn process_trait_ref(&mut self,\n-                         trait_ref: &ast::TraitRef) {\n-        match self.lookup_type_ref(trait_ref.ref_id) {\n-            Some(id) => {\n-                let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n-                self.fmt.ref_str(recorder::TypeRef,\n-                                 trait_ref.path.span,\n-                                 sub_span,\n-                                 id,\n-                                 self.cur_scope);\n-                visit::walk_path(self, &trait_ref.path);\n-            },\n-            None => ()\n-        }\n-    }\n-\n-    fn process_struct_field_def(&mut self,\n-                                field: &ast::StructField,\n-                                qualname: &str,\n-                                scope_id: NodeId) {\n-        match field.node.kind {\n-            ast::NamedField(ident, _) => {\n-                let name = get_ident(ident);\n-                let qualname = format!(\"{}::{}\", qualname, name);\n-                let typ =\n-                    ppaux::ty_to_string(\n-                        &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types().get(&field.node.id).unwrap());\n-                match self.span.sub_span_before_token(field.span, token::Colon) {\n-                    Some(sub_span) => self.fmt.field_str(field.span,\n-                                                         Some(sub_span),\n-                                                         field.node.id,\n-                                                         &name[..],\n-                                                         &qualname[..],\n-                                                         &typ[..],\n-                                                         scope_id),\n-                    None => self.sess.span_bug(field.span,\n-                                               &format!(\"Could not find sub-span for field {}\",\n-                                                       qualname)),\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    // Dump generic params bindings, then visit_generics\n-    fn process_generic_params(&mut self,\n-                              generics:&ast::Generics,\n-                              full_span: Span,\n-                              prefix: &str,\n-                              id: NodeId) {\n-        // We can't only use visit_generics since we don't have spans for param\n-        // bindings, so we reparse the full_span to get those sub spans.\n-        // However full span is the entire enum/fn/struct block, so we only want\n-        // the first few to match the number of generics we're looking for.\n-        let param_sub_spans = self.span.spans_for_ty_params(full_span,\n-                                                           (generics.ty_params.len() as isize));\n-        for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans.iter()) {\n-            // Append $id to name to make sure each one is unique\n-            let name = format!(\"{}::{}${}\",\n-                               prefix,\n-                               escape(self.span.snippet(*param_ss)),\n-                               id);\n-            self.fmt.typedef_str(full_span,\n-                                 Some(*param_ss),\n-                                 param.id,\n-                                 &name[..],\n-                                 \"\");\n-        }\n-        self.visit_generics(generics);\n-    }\n-\n-    fn process_fn(&mut self,\n-                  item: &ast::Item,\n-                  decl: &ast::FnDecl,\n-                  ty_params: &ast::Generics,\n-                  body: &ast::Block) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n-        self.fmt.fn_str(item.span,\n-                        sub_span,\n-                        item.id,\n-                        &qualname[..],\n-                        self.cur_scope);\n-\n-        self.process_formals(&decl.inputs, &qualname[..]);\n-\n-        // walk arg and return types\n-        for arg in &decl.inputs {\n-            self.visit_ty(&*arg.ty);\n-        }\n-\n-        if let ast::Return(ref ret_ty) = decl.output {\n-            self.visit_ty(&**ret_ty);\n-        }\n-\n-        // walk the body\n-        self.nest(item.id, |v| v.visit_block(&*body));\n-\n-        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n-    }\n-\n-    fn process_static(&mut self,\n-                      item: &ast::Item,\n-                      typ: &ast::Ty,\n-                      mt: ast::Mutability,\n-                      expr: &ast::Expr)\n-    {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-\n-        // If the variable is immutable, save the initialising expression.\n-        let (value, keyword) = match mt {\n-            ast::MutMutable => (String::from_str(\"<mutable>\"), keywords::Mut),\n-            ast::MutImmutable => (self.span.snippet(expr.span), keywords::Static),\n-        };\n-\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keyword);\n-        self.fmt.static_str(item.span,\n-                            sub_span,\n-                            item.id,\n-                            &get_ident(item.ident),\n-                            &qualname[..],\n-                            &value[..],\n-                            &ty_to_string(&*typ),\n-                            self.cur_scope);\n-\n-        // walk type and init value\n-        self.visit_ty(&*typ);\n-        self.visit_expr(expr);\n-    }\n-\n-    fn process_const(&mut self,\n-                     id: ast::NodeId,\n-                     ident: &ast::Ident,\n-                     span: Span,\n-                     typ: &ast::Ty,\n-                     expr: &ast::Expr)\n-    {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(id));\n-\n-        let sub_span = self.span.sub_span_after_keyword(span,\n-                                                        keywords::Const);\n-        self.fmt.static_str(span,\n-                            sub_span,\n-                            id,\n-                            &get_ident((*ident).clone()),\n-                            &qualname[..],\n-                            \"\",\n-                            &ty_to_string(&*typ),\n-                            self.cur_scope);\n-\n-        // walk type and init value\n-        self.visit_ty(typ);\n-        self.visit_expr(expr);\n-    }\n-\n-    fn process_struct(&mut self,\n-                      item: &ast::Item,\n-                      def: &ast::StructDef,\n-                      ty_params: &ast::Generics) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-\n-        let ctor_id = match def.ctor_id {\n-            Some(node_id) => node_id,\n-            None => -1,\n-        };\n-        let val = self.span.snippet(item.span);\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n-        self.fmt.struct_str(item.span,\n-                            sub_span,\n-                            item.id,\n-                            ctor_id,\n-                            &qualname[..],\n-                            self.cur_scope,\n-                            &val[..]);\n-\n-        // fields\n-        for field in &def.fields {\n-            self.process_struct_field_def(field, &qualname[..], item.id);\n-            self.visit_ty(&*field.node.ty);\n-        }\n-\n-        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n-    }\n-\n-    fn process_enum(&mut self,\n-                    item: &ast::Item,\n-                    enum_definition: &ast::EnumDef,\n-                    ty_params: &ast::Generics) {\n-        let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-        let val = self.span.snippet(item.span);\n-        match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n-            Some(sub_span) => self.fmt.enum_str(item.span,\n-                                                Some(sub_span),\n-                                                item.id,\n-                                                &enum_name[..],\n-                                                self.cur_scope,\n-                                                &val[..]),\n-            None => self.sess.span_bug(item.span,\n-                                       &format!(\"Could not find subspan for enum {}\",\n-                                               enum_name)),\n-        }\n-        for variant in &enum_definition.variants {\n-            let name = get_ident(variant.node.name);\n-            let name = &name;\n-            let mut qualname = enum_name.clone();\n-            qualname.push_str(\"::\");\n-            qualname.push_str(name);\n-            let val = self.span.snippet(variant.span);\n-            match variant.node.kind {\n-                ast::TupleVariantKind(ref args) => {\n-                    // first ident in span is the variant's name\n-                    self.fmt.tuple_variant_str(variant.span,\n-                                               self.span.span_for_first_ident(variant.span),\n-                                               variant.node.id,\n-                                               name,\n-                                               &qualname[..],\n-                                               &enum_name[..],\n-                                               &val[..],\n-                                               item.id);\n-                    for arg in args {\n-                        self.visit_ty(&*arg.ty);\n-                    }\n-                }\n-                ast::StructVariantKind(ref struct_def) => {\n-                    let ctor_id = match struct_def.ctor_id {\n-                        Some(node_id) => node_id,\n-                        None => -1,\n-                    };\n-                    self.fmt.struct_variant_str(\n-                        variant.span,\n-                        self.span.span_for_first_ident(variant.span),\n-                        variant.node.id,\n-                        ctor_id,\n-                        &qualname[..],\n-                        &enum_name[..],\n-                        &val[..],\n-                        item.id);\n-\n-                    for field in &struct_def.fields {\n-                        self.process_struct_field_def(field, &qualname, variant.node.id);\n-                        self.visit_ty(&*field.node.ty);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.process_generic_params(ty_params, item.span, &enum_name[..], item.id);\n-    }\n-\n-    fn process_impl(&mut self,\n-                    item: &ast::Item,\n-                    type_parameters: &ast::Generics,\n-                    trait_ref: &Option<ast::TraitRef>,\n-                    typ: &ast::Ty,\n-                    impl_items: &[P<ast::ImplItem>]) {\n-        let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n-        match typ.node {\n-            // Common case impl for a struct or something basic.\n-            ast::TyPath(None, ref path) => {\n-                let sub_span = self.span.sub_span_for_type_name(path.span);\n-                let self_id = self.lookup_type_ref(typ.id).map(|id| {\n-                    self.fmt.ref_str(recorder::TypeRef,\n-                                     path.span,\n-                                     sub_span,\n-                                     id,\n-                                     self.cur_scope);\n-                    id\n-                });\n-                self.fmt.impl_str(path.span,\n-                                  sub_span,\n-                                  item.id,\n-                                  self_id,\n-                                  trait_id,\n-                                  self.cur_scope);\n-            },\n-            _ => {\n-                // Less useful case, impl for a compound type.\n-                self.visit_ty(&*typ);\n-\n-                let sub_span = self.span.sub_span_for_type_name(typ.span);\n-                self.fmt.impl_str(typ.span,\n-                                  sub_span,\n-                                  item.id,\n-                                  None,\n-                                  trait_id,\n-                                  self.cur_scope);\n-            }\n-        }\n-\n-        match *trait_ref {\n-            Some(ref trait_ref) => self.process_trait_ref(trait_ref),\n-            None => (),\n-        }\n-\n-        self.process_generic_params(type_parameters, item.span, \"\", item.id);\n-        for impl_item in impl_items {\n-            self.visit_impl_item(impl_item);\n-        }\n-    }\n-\n-    fn process_trait(&mut self,\n-                     item: &ast::Item,\n-                     generics: &ast::Generics,\n-                     trait_refs: &OwnedSlice<ast::TyParamBound>,\n-                     methods: &[P<ast::TraitItem>]) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-        let val = self.span.snippet(item.span);\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n-        self.fmt.trait_str(item.span,\n-                           sub_span,\n-                           item.id,\n-                           &qualname[..],\n-                           self.cur_scope,\n-                           &val[..]);\n-\n-        // super-traits\n-        for super_bound in &**trait_refs {\n-            let trait_ref = match *super_bound {\n-                ast::TraitTyParamBound(ref trait_ref, _) => {\n-                    trait_ref\n-                }\n-                ast::RegionTyParamBound(..) => {\n-                    continue;\n-                }\n-            };\n-\n-            let trait_ref = &trait_ref.trait_ref;\n-            match self.lookup_type_ref(trait_ref.ref_id) {\n-                Some(id) => {\n-                    let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n-                    self.fmt.ref_str(recorder::TypeRef,\n-                                     trait_ref.path.span,\n-                                     sub_span,\n-                                     id,\n-                                     self.cur_scope);\n-                    self.fmt.inherit_str(trait_ref.path.span,\n-                                         sub_span,\n-                                         id,\n-                                         item.id);\n-                },\n-                None => ()\n-            }\n-        }\n-\n-        // walk generics and methods\n-        self.process_generic_params(generics, item.span, &qualname[..], item.id);\n-        for method in methods {\n-            self.visit_trait_item(method)\n-        }\n-    }\n-\n-    fn process_mod(&mut self,\n-                   item: &ast::Item,  // The module in question, represented as an item.\n-                   m: &ast::Mod) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-\n-        let cm = self.sess.codemap();\n-        let filename = cm.span_to_filename(m.inner);\n-\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Mod);\n-        self.fmt.mod_str(item.span,\n-                         sub_span,\n-                         item.id,\n-                         &qualname[..],\n-                         self.cur_scope,\n-                         &filename[..]);\n-\n-        self.nest(item.id, |v| visit::walk_mod(v, m));\n-    }\n-\n-    fn process_path(&mut self,\n-                    id: NodeId,\n-                    span: Span,\n-                    path: &ast::Path,\n-                    ref_kind: Option<recorder::Row>) {\n-        if generated_code(span) {\n-            return\n-        }\n-\n-        let def_map = self.analysis.ty_cx.def_map.borrow();\n-        if !def_map.contains_key(&id) {\n-            self.sess.span_bug(span,\n-                               &format!(\"def_map has no key for {} in visit_expr\", id));\n-        }\n-        let def = def_map.get(&id).unwrap().full_def();\n-        let sub_span = self.span.span_for_last_ident(span);\n-        match def {\n-            def::DefUpvar(..) |\n-            def::DefLocal(..) |\n-            def::DefStatic(..) |\n-            def::DefConst(..) |\n-            def::DefAssociatedConst(..) |\n-            def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n-                                                    span,\n-                                                    sub_span,\n-                                                    def.def_id(),\n-                                                    self.cur_scope),\n-            def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n-                                                       span,\n-                                                       sub_span,\n-                                                       def_id,\n-                                                       self.cur_scope),\n-            def::DefTy(def_id, _) => self.fmt.ref_str(recorder::TypeRef,\n-                                                      span,\n-                                                      sub_span,\n-                                                      def_id,\n-                                                      self.cur_scope),\n-            def::DefMethod(declid, provenence) => {\n-                let sub_span = self.span.sub_span_for_meth_name(span);\n-                let defid = if declid.krate == ast::LOCAL_CRATE {\n-                    let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n-                                                    declid);\n-                    match provenence {\n-                        def::FromTrait(def_id) => {\n-                            Some(ty::trait_items(&self.analysis.ty_cx,\n-                                                 def_id)\n-                                    .iter()\n-                                    .find(|mr| {\n-                                        mr.name() == ti.name()\n-                                    })\n-                                    .unwrap()\n-                                    .def_id())\n-                        }\n-                        def::FromImpl(def_id) => {\n-                            let impl_items = self.analysis\n-                                                 .ty_cx\n-                                                 .impl_items\n-                                                 .borrow();\n-                            Some(impl_items.get(&def_id)\n-                                           .unwrap()\n-                                           .iter()\n-                                           .find(|mr| {\n-                                                ty::impl_or_trait_item(\n-                                                    &self.analysis.ty_cx,\n-                                                    mr.def_id()\n-                                                ).name() == ti.name()\n-                                            })\n-                                           .unwrap()\n-                                           .def_id())\n-                        }\n-                    }\n-                } else {\n-                    None\n-                };\n-                self.fmt.meth_call_str(span,\n-                                       sub_span,\n-                                       defid,\n-                                       Some(declid),\n-                                       self.cur_scope);\n-            },\n-            def::DefFn(def_id, _) => {\n-                self.fmt.fn_call_str(span,\n-                                     sub_span,\n-                                     def_id,\n-                                     self.cur_scope)\n-            }\n-            _ => self.sess.span_bug(span,\n-                                    &format!(\"Unexpected def kind while looking \\\n-                                              up path in `{}`: `{:?}`\",\n-                                             self.span.snippet(span),\n-                                             def)),\n-        }\n-        // modules or types in the path prefix\n-        match def {\n-            def::DefMethod(did, _) => {\n-                let ti = ty::impl_or_trait_item(&self.analysis.ty_cx, did);\n-                if let ty::MethodTraitItem(m) = ti {\n-                    if m.explicit_self == ty::StaticExplicitSelfCategory {\n-                        self.write_sub_path_trait_truncated(path);\n-                    }\n-                }\n-            }\n-            def::DefLocal(_) |\n-            def::DefStatic(_,_) |\n-            def::DefConst(..) |\n-            def::DefAssociatedConst(..) |\n-            def::DefStruct(_) |\n-            def::DefVariant(..) |\n-            def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n-            _ => {},\n-        }\n-    }\n-\n-    fn process_struct_lit(&mut self,\n-                          ex: &ast::Expr,\n-                          path: &ast::Path,\n-                          fields: &Vec<ast::Field>,\n-                          base: &Option<P<ast::Expr>>) {\n-        if generated_code(path.span) {\n-            return\n-        }\n-\n-        self.write_sub_paths_truncated(path, false);\n-\n-        let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, ex).sty;\n-        let struct_def = match *ty {\n-            ty::ty_struct(def_id, _) => {\n-                let sub_span = self.span.span_for_last_ident(path.span);\n-                self.fmt.ref_str(recorder::StructRef,\n-                                 path.span,\n-                                 sub_span,\n-                                 def_id,\n-                                 self.cur_scope);\n-                Some(def_id)\n-            }\n-            _ => None\n-        };\n-\n-        for field in fields {\n-            match struct_def {\n-                Some(struct_def) => {\n-                    let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n-                    for f in &fields {\n-                        if generated_code(field.ident.span) {\n-                            continue;\n-                        }\n-                        if f.name == field.ident.node.name {\n-                            // We don't really need a sub-span here, but no harm done\n-                            let sub_span = self.span.span_for_last_ident(field.ident.span);\n-                            self.fmt.ref_str(recorder::VarRef,\n-                                             field.ident.span,\n-                                             sub_span,\n-                                             f.id,\n-                                             self.cur_scope);\n-                        }\n-                    }\n-                }\n-                None => {}\n-            }\n-\n-            self.visit_expr(&*field.expr)\n-        }\n-        visit::walk_expr_opt(self, base)\n-    }\n-\n-    fn process_method_call(&mut self,\n-                           ex: &ast::Expr,\n-                           args: &Vec<P<ast::Expr>>) {\n-        let method_map = self.analysis.ty_cx.method_map.borrow();\n-        let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n-        let (def_id, decl_id) = match method_callee.origin {\n-            ty::MethodStatic(def_id) |\n-            ty::MethodStaticClosure(def_id) => {\n-                // method invoked on an object with a concrete type (not a static method)\n-                let decl_id =\n-                    match ty::trait_item_of_item(&self.analysis.ty_cx,\n-                                                 def_id) {\n-                        None => None,\n-                        Some(decl_id) => Some(decl_id.def_id()),\n-                    };\n-\n-                // This incantation is required if the method referenced is a\n-                // trait's default implementation.\n-                let def_id = match ty::impl_or_trait_item(&self.analysis\n-                                                               .ty_cx,\n-                                                          def_id) {\n-                    ty::MethodTraitItem(method) => {\n-                        method.provided_source.unwrap_or(def_id)\n-                    }\n-                    _ => self.sess\n-                             .span_bug(ex.span,\n-                                       \"save::process_method_call: non-method \\\n-                                        DefId in MethodStatic or MethodStaticClosure\"),\n-                };\n-                (Some(def_id), decl_id)\n-            }\n-            ty::MethodTypeParam(ref mp) => {\n-                // method invoked on a type parameter\n-                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mp.trait_ref.def_id,\n-                                                mp.method_num);\n-                (None, Some(trait_item.def_id()))\n-            }\n-            ty::MethodTraitObject(ref mo) => {\n-                // method invoked on a trait instance\n-                let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mo.trait_ref.def_id,\n-                                                mo.method_num);\n-                (None, Some(trait_item.def_id()))\n-            }\n-        };\n-        let sub_span = self.span.sub_span_for_meth_name(ex.span);\n-        self.fmt.meth_call_str(ex.span,\n-                               sub_span,\n-                               def_id,\n-                               decl_id,\n-                               self.cur_scope);\n-\n-        // walk receiver and args\n-        visit::walk_exprs(self, &args[..]);\n-    }\n-\n-    fn process_pat(&mut self, p:&ast::Pat) {\n-        if generated_code(p.span) {\n-            return\n-        }\n-\n-        match p.node {\n-            ast::PatStruct(ref path, ref fields, _) => {\n-                self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n-                visit::walk_path(self, path);\n-\n-                let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n-                let struct_def = match def {\n-                    def::DefConst(..) | def::DefAssociatedConst(..) => None,\n-                    def::DefVariant(_, variant_id, _) => Some(variant_id),\n-                    _ => {\n-                        match ty::ty_to_def_id(ty::node_id_to_type(&self.analysis.ty_cx, p.id)) {\n-                            None => {\n-                                self.sess.span_bug(p.span,\n-                                                   &format!(\"Could not find struct_def for `{}`\",\n-                                                            self.span.snippet(p.span)));\n-                            }\n-                            Some(def_id) => Some(def_id),\n-                        }\n-                    }\n-                };\n-\n-                if let Some(struct_def) = struct_def {\n-                    let struct_fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n-                    for &Spanned { node: ref field, span } in fields {\n-                        let sub_span = self.span.span_for_first_ident(span);\n-                        for f in &struct_fields {\n-                            if f.name == field.ident.name {\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n-                        self.visit_pat(&*field.pat);\n-                    }\n-                }\n-            }\n-            ast::PatEnum(ref path, _) |\n-            ast::PatQPath(_, ref path) => {\n-                self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n-                visit::walk_pat(self, p);\n-            }\n-            ast::PatIdent(bm, ref path1, ref optional_subpattern) => {\n-                let immut = match bm {\n-                    // Even if the ref is mut, you can't change the ref, only\n-                    // the data pointed at, so showing the initialising expression\n-                    // is still worthwhile.\n-                    ast::BindByRef(_) => true,\n-                    ast::BindByValue(mt) => {\n-                        match mt {\n-                            ast::MutMutable => false,\n-                            ast::MutImmutable => true,\n-                        }\n-                    }\n-                };\n-                // collect path for either visit_local or visit_arm\n-                let path = ast_util::ident_to_path(path1.span,path1.node);\n-                self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n-                match *optional_subpattern {\n-                    None => {}\n-                    Some(ref subpattern) => self.visit_pat(&**subpattern)\n-                }\n-            }\n-            _ => visit::walk_pat(self, p)\n-        }\n-    }\n-}\n-\n-impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        if generated_code(item.span) {\n-            return\n-        }\n-\n-        match item.node {\n-            ast::ItemUse(ref use_item) => {\n-                match use_item.node {\n-                    ast::ViewPathSimple(ident, ref path) => {\n-                        let sub_span = self.span.span_for_last_ident(path.span);\n-                        let mod_id = match self.lookup_type_ref(item.id) {\n-                            Some(def_id) => {\n-                                match self.lookup_def_kind(item.id, path.span) {\n-                                    Some(kind) => self.fmt.ref_str(kind,\n-                                                                   path.span,\n-                                                                   sub_span,\n-                                                                   def_id,\n-                                                                   self.cur_scope),\n-                                    None => {},\n-                                }\n-                                Some(def_id)\n-                            },\n-                            None => None,\n-                        };\n-\n-                        // 'use' always introduces an alias, if there is not an explicit\n-                        // one, there is an implicit one.\n-                        let sub_span =\n-                            match self.span.sub_span_after_keyword(use_item.span, keywords::As) {\n-                                Some(sub_span) => Some(sub_span),\n-                                None => sub_span,\n-                            };\n-\n-                        self.fmt.use_alias_str(path.span,\n-                                               sub_span,\n-                                               item.id,\n-                                               mod_id,\n-                                               &get_ident(ident),\n-                                               self.cur_scope);\n-                        self.write_sub_paths_truncated(path, true);\n-                    }\n-                    ast::ViewPathGlob(ref path) => {\n-                        // Make a comma-separated list of names of imported modules.\n-                        let mut name_string = String::new();\n-                        let glob_map = &self.analysis.glob_map;\n-                        let glob_map = glob_map.as_ref().unwrap();\n-                        if glob_map.contains_key(&item.id) {\n-                            for n in glob_map.get(&item.id).unwrap() {\n-                                if !name_string.is_empty() {\n-                                    name_string.push_str(\", \");\n-                                }\n-                                name_string.push_str(n.as_str());\n-                            }\n-                        }\n-\n-                        let sub_span = self.span.sub_span_of_token(path.span,\n-                                                                   token::BinOp(token::Star));\n-                        self.fmt.use_glob_str(path.span,\n-                                              sub_span,\n-                                              item.id,\n-                                              &name_string,\n-                                              self.cur_scope);\n-                        self.write_sub_paths(path, true);\n-                    }\n-                    ast::ViewPathList(ref path, ref list) => {\n-                        for plid in list {\n-                            match plid.node {\n-                                ast::PathListIdent { id, .. } => {\n-                                    match self.lookup_type_ref(id) {\n-                                        Some(def_id) =>\n-                                            match self.lookup_def_kind(id, plid.span) {\n-                                                Some(kind) => {\n-                                                    self.fmt.ref_str(\n-                                                        kind, plid.span,\n-                                                        Some(plid.span),\n-                                                        def_id, self.cur_scope);\n-                                                }\n-                                                None => ()\n-                                            },\n-                                        None => ()\n-                                    }\n-                                },\n-                                ast::PathListMod { .. } => ()\n-                            }\n-                        }\n-\n-                        self.write_sub_paths(path, true);\n-                    }\n-                }\n-            }\n-            ast::ItemExternCrate(ref s) => {\n-                let name = get_ident(item.ident);\n-                let name = &name;\n-                let location = match *s {\n-                    Some(s) => s.to_string(),\n-                    None => name.to_string(),\n-                };\n-                let alias_span = self.span.span_for_last_ident(item.span);\n-                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n-                    Some(cnum) => cnum,\n-                    None => 0,\n-                };\n-                self.fmt.extern_crate_str(item.span,\n-                                          alias_span,\n-                                          item.id,\n-                                          cnum,\n-                                          name,\n-                                          &location[..],\n-                                          self.cur_scope);\n-            }\n-            ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n-                self.process_fn(item, &**decl, ty_params, &**body),\n-            ast::ItemStatic(ref typ, mt, ref expr) =>\n-                self.process_static(item, &**typ, mt, &**expr),\n-            ast::ItemConst(ref typ, ref expr) =>\n-                self.process_const(item.id, &item.ident, item.span, &*typ, &*expr),\n-            ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n-            ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n-            ast::ItemImpl(_, _,\n-                          ref ty_params,\n-                          ref trait_ref,\n-                          ref typ,\n-                          ref impl_items) => {\n-                self.process_impl(item,\n-                                  ty_params,\n-                                  trait_ref,\n-                                  &**typ,\n-                                  impl_items)\n-            }\n-            ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>\n-                self.process_trait(item, generics, trait_refs, methods),\n-            ast::ItemMod(ref m) => self.process_mod(item, m),\n-            ast::ItemTy(ref ty, ref ty_params) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-                let value = ty_to_string(&**ty);\n-                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n-                self.fmt.typedef_str(item.span,\n-                                     sub_span,\n-                                     item.id,\n-                                     &qualname[..],\n-                                     &value[..]);\n-\n-                self.visit_ty(&**ty);\n-                self.process_generic_params(ty_params, item.span, &qualname, item.id);\n-            },\n-            ast::ItemMac(_) => (),\n-            _ => visit::walk_item(self, item),\n-        }\n-    }\n-\n-    fn visit_generics(&mut self, generics: &ast::Generics) {\n-        for param in &*generics.ty_params {\n-            for bound in &*param.bounds {\n-                if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n-                    self.process_trait_ref(&trait_ref.trait_ref);\n-                }\n-            }\n-            if let Some(ref ty) = param.default {\n-                self.visit_ty(&**ty);\n-            }\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n-        match trait_item.node {\n-            ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n-                self.process_const(trait_item.id, &trait_item.ident,\n-                                   trait_item.span, &*ty, &*expr);\n-            }\n-            ast::MethodTraitItem(ref sig, ref body) => {\n-                self.process_method(sig, body.as_ref().map(|x| &**x),\n-                                    trait_item.id, trait_item.ident.name, trait_item.span);\n-            }\n-            ast::ConstTraitItem(_, None) |\n-            ast::TypeTraitItem(..) => {}\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n-        match impl_item.node {\n-            ast::ConstImplItem(ref ty, ref expr) => {\n-                self.process_const(impl_item.id, &impl_item.ident,\n-                                   impl_item.span, &ty, &expr);\n-            }\n-            ast::MethodImplItem(ref sig, ref body) => {\n-                self.process_method(sig, Some(body), impl_item.id,\n-                                    impl_item.ident.name, impl_item.span);\n-            }\n-            ast::TypeImplItem(_) |\n-            ast::MacImplItem(_) => {}\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, t: &ast::Ty) {\n-        if generated_code(t.span) {\n-            return\n-        }\n-\n-        match t.node {\n-            ast::TyPath(_, ref path) => {\n-                match self.lookup_type_ref(t.id) {\n-                    Some(id) => {\n-                        let sub_span = self.span.sub_span_for_type_name(t.span);\n-                        self.fmt.ref_str(recorder::TypeRef,\n-                                         t.span,\n-                                         sub_span,\n-                                         id,\n-                                         self.cur_scope);\n-                    },\n-                    None => ()\n-                }\n-\n-                self.write_sub_paths_truncated(path, false);\n-\n-                visit::walk_path(self, path);\n-            },\n-            _ => visit::walk_ty(self, t),\n-        }\n-    }\n-\n-    fn visit_expr(&mut self, ex: &ast::Expr) {\n-        if generated_code(ex.span) {\n-            return\n-        }\n-\n-        match ex.node {\n-            ast::ExprCall(ref _f, ref _args) => {\n-                // Don't need to do anything for function calls,\n-                // because just walking the callee path does what we want.\n-                visit::walk_expr(self, ex);\n-            }\n-            ast::ExprPath(_, ref path) => {\n-                self.process_path(ex.id, path.span, path, None);\n-                visit::walk_expr(self, ex);\n-            }\n-            ast::ExprStruct(ref path, ref fields, ref base) =>\n-                self.process_struct_lit(ex, path, fields, base),\n-            ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n-            ast::ExprField(ref sub_ex, ident) => {\n-                if generated_code(sub_ex.span) {\n-                    return\n-                }\n-\n-                self.visit_expr(&**sub_ex);\n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n-                match *ty {\n-                    ty::ty_struct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n-                        for f in &fields {\n-                            if f.name == ident.node.name {\n-                                let sub_span = self.span.span_for_last_ident(ex.span);\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 ex.span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    _ => self.sess.span_bug(ex.span,\n-                                            &format!(\"Expected struct type, found {:?}\", ty)),\n-                }\n-            },\n-            ast::ExprTupField(ref sub_ex, idx) => {\n-                if generated_code(sub_ex.span) {\n-                    return\n-                }\n-\n-                self.visit_expr(&**sub_ex);\n-\n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n-                match *ty {\n-                    ty::ty_struct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n-                        for (i, f) in fields.iter().enumerate() {\n-                            if i == idx.node {\n-                                let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 ex.span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    ty::ty_tup(_) => {}\n-                    _ => self.sess.span_bug(ex.span,\n-                                            &format!(\"Expected struct or tuple \\\n-                                                      type, found {:?}\", ty)),\n-                }\n-            },\n-            ast::ExprClosure(_, ref decl, ref body) => {\n-                if generated_code(body.span) {\n-                    return\n-                }\n-\n-                let mut id = String::from_str(\"$\");\n-                id.push_str(&ex.id.to_string());\n-                self.process_formals(&decl.inputs, &id[..]);\n-\n-                // walk arg and return types\n-                for arg in &decl.inputs {\n-                    self.visit_ty(&*arg.ty);\n-                }\n-\n-                if let ast::Return(ref ret_ty) = decl.output {\n-                    self.visit_ty(&**ret_ty);\n-                }\n-\n-                // walk the body\n-                self.nest(ex.id, |v| v.visit_block(&**body));\n-            },\n-            _ => {\n-                visit::walk_expr(self, ex)\n-            },\n-        }\n-    }\n-\n-    fn visit_mac(&mut self, _: &ast::Mac) {\n-        // Just stop, macros are poison to us.\n-    }\n-\n-    fn visit_pat(&mut self, p: &ast::Pat) {\n-        self.process_pat(p);\n-        if !self.collecting {\n-            self.collected_paths.clear();\n-        }\n-    }\n-\n-    fn visit_arm(&mut self, arm: &ast::Arm) {\n-        assert!(self.collected_paths.is_empty() && !self.collecting);\n-        self.collecting = true;\n-        for pattern in &arm.pats {\n-            // collect paths from the arm's patterns\n-            self.visit_pat(&**pattern);\n-        }\n-\n-        // This is to get around borrow checking, because we need mut self to call process_path.\n-        let mut paths_to_process = vec![];\n-        // process collected paths\n-        for &(id, ref p, ref immut, ref_kind) in &self.collected_paths {\n-            let def_map = self.analysis.ty_cx.def_map.borrow();\n-            if !def_map.contains_key(&id) {\n-                self.sess.span_bug(p.span,\n-                                   &format!(\"def_map has no key for {} in visit_arm\",\n-                                           id));\n-            }\n-            let def = def_map.get(&id).unwrap().full_def();\n-            match def {\n-                def::DefLocal(id)  => {\n-                    let value = if *immut {\n-                        self.span.snippet(p.span).to_string()\n-                    } else {\n-                        \"<mutable>\".to_string()\n-                    };\n-\n-                    assert!(p.segments.len() == 1, \"qualified path for local variable def in arm\");\n-                    self.fmt.variable_str(p.span,\n-                                          Some(p.span),\n-                                          id,\n-                                          &path_to_string(p),\n-                                          &value[..],\n-                                          \"\")\n-                }\n-                def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n-                    paths_to_process.push((id, p.clone(), Some(ref_kind)))\n-                }\n-                // FIXME(nrc) what are these doing here?\n-                def::DefStatic(_, _) |\n-                def::DefConst(..) |\n-                def::DefAssociatedConst(..) => {}\n-                _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n-                            def)\n-            }\n-        }\n-        for &(id, ref path, ref_kind) in &paths_to_process {\n-            self.process_path(id, path.span, path, ref_kind);\n-        }\n-        self.collecting = false;\n-        self.collected_paths.clear();\n-        visit::walk_expr_opt(self, &arm.guard);\n-        self.visit_expr(&*arm.body);\n-    }\n-\n-    fn visit_stmt(&mut self, s: &ast::Stmt) {\n-        if generated_code(s.span) {\n-            return\n-        }\n-\n-        visit::walk_stmt(self, s)\n-    }\n-\n-    fn visit_local(&mut self, l: &ast::Local) {\n-        if generated_code(l.span) {\n-            return\n-        }\n-\n-        // The local could declare multiple new vars, we must walk the\n-        // pattern and collect them all.\n-        assert!(self.collected_paths.is_empty() && !self.collecting);\n-        self.collecting = true;\n-        self.visit_pat(&*l.pat);\n-        self.collecting = false;\n-\n-        let value = self.span.snippet(l.span);\n-\n-        for &(id, ref p, ref immut, _) in &self.collected_paths {\n-            let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n-            let types = self.analysis.ty_cx.node_types();\n-            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n-            // Get the span only for the name of the variable (I hope the path\n-            // is only ever a variable name, but who knows?).\n-            let sub_span = self.span.span_for_last_ident(p.span);\n-            // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            self.fmt.variable_str(p.span,\n-                                  sub_span,\n-                                  id,\n-                                  &path_to_string(p),\n-                                  &value[..],\n-                                  &typ[..]);\n-        }\n-        self.collected_paths.clear();\n-\n-        // Just walk the initialiser and type (don't want to walk the pattern again).\n-        visit::walk_ty_opt(self, &l.ty);\n-        visit::walk_expr_opt(self, &l.init);\n-    }\n-}\n+mod dump_csv;\n \n #[allow(deprecated)]\n pub fn process_crate(sess: &Session,\n@@ -1562,27 +76,21 @@ pub fn process_crate(sess: &Session,\n     };\n     root_path.pop();\n \n-    let mut visitor = DxrVisitor {\n-        sess: sess,\n-        analysis: analysis,\n-        collected_paths: vec!(),\n-        collecting: false,\n-        fmt: FmtStrs::new(box Recorder {\n-                            out: output_file,\n-                            dump_spans: false,\n-                        },\n-                        SpanUtils {\n-                            sess: sess,\n-                            err_count: Cell::new(0)\n-                        }),\n-        span: SpanUtils {\n-            sess: sess,\n-            err_count: Cell::new(0)\n-        },\n-        cur_scope: 0\n-    };\n+    let mut visitor = dump_csv::DumpCsvVisitor::new(sess, analysis, output_file);\n \n     visitor.dump_crate_info(&cratename[..], krate);\n-\n     visit::walk_crate(&mut visitor, krate);\n }\n+\n+// Utility functions for the module.\n+\n+// Helper function to escape quotes in a string\n+fn escape(s: String) -> String {\n+    s.replace(\"\\\"\", \"\\\"\\\"\")\n+}\n+\n+// If the expression is a macro expansion or other generated code, run screaming\n+// and don't index.\n+fn generated_code(span: Span) -> bool {\n+    span.expn_id != NO_EXPANSION || span  == DUMMY_SP\n+}"}]}