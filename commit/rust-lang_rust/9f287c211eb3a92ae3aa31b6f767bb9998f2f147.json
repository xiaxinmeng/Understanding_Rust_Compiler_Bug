{"sha": "9f287c211eb3a92ae3aa31b6f767bb9998f2f147", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMjg3YzIxMWViM2E5MmFlM2FhMzFiNmY3NjdiYjk5OThmMmYxNDc=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-04T01:57:43Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-06T16:10:19Z"}, "message": "Refcount tasks in packets to avoid races.\n\nRevert \"Once again, revert \"Use pipes in compiletest\"\"\n\nFixes #3098", "tree": {"sha": "49a88b8e24ed1668f81292e1b6dcb9fec6202409", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49a88b8e24ed1668f81292e1b6dcb9fec6202409"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f287c211eb3a92ae3aa31b6f767bb9998f2f147", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f287c211eb3a92ae3aa31b6f767bb9998f2f147", "html_url": "https://github.com/rust-lang/rust/commit/9f287c211eb3a92ae3aa31b6f767bb9998f2f147", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86947e47ad057d50209cf8a022f088c22089433f", "url": "https://api.github.com/repos/rust-lang/rust/commits/86947e47ad057d50209cf8a022f088c22089433f", "html_url": "https://github.com/rust-lang/rust/commit/86947e47ad057d50209cf8a022f088c22089433f"}], "stats": {"total": 100, "additions": 61, "deletions": 39}, "files": [{"sha": "33b9655aeb2f0ef30adf6905858486c9d3591281", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=9f287c211eb3a92ae3aa31b6f767bb9998f2f147", "patch": "@@ -8,11 +8,6 @@ import task;\n import core::result;\n import result::{ok, err};\n \n-import comm::port;\n-import comm::chan;\n-import comm::send;\n-import comm::recv;\n-\n import common::config;\n import common::mode_run_pass;\n import common::mode_run_fail;"}, {"sha": "99b18a67e1e5206b12c8610d74c08c57a61f409d", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=9f287c211eb3a92ae3aa31b6f767bb9998f2f147", "patch": "@@ -2,6 +2,8 @@ import run::spawn_process;\n import io::{writer_util, reader_util};\n import libc::{c_int, pid_t};\n \n+import pipes::chan;\n+\n export run;\n \n #[cfg(target_os = \"win32\")]\n@@ -58,29 +60,30 @@ fn run(lib_path: ~str,\n \n \n     writeclose(pipe_in.out, input);\n-    let p = comm::port();\n-    let ch = comm::chan(p);\n+    let p = pipes::port_set();\n+    let ch = p.chan();\n     do task::spawn_sched(task::single_threaded) {\n         let errput = readclose(pipe_err.in);\n-        comm::send(ch, (2, errput));\n+        ch.send((2, errput));\n     }\n+    let ch = p.chan();\n     do task::spawn_sched(task::single_threaded) {\n         let output = readclose(pipe_out.in);\n-        comm::send(ch, (1, output));\n+        ch.send((1, output));\n     }\n     let status = run::waitpid(pid);\n     let mut errs = ~\"\";\n     let mut outs = ~\"\";\n     let mut count = 2;\n     while count > 0 {\n-        let stream = comm::recv(p);\n-        alt check stream {\n-            (1, s) => {\n-                outs = s;\n-            }\n-            (2, s) => {\n-                errs = s;\n-            }\n+        alt p.recv() {\n+          (1, s) => {\n+            outs = s;\n+          }\n+          (2, s) => {\n+            errs = s;\n+          }\n+          _ { fail }\n         };\n         count -= 1;\n     };"}, {"sha": "963be25b69ff1a80937576f04301cdf39967482a", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=9f287c211eb3a92ae3aa31b6f767bb9998f2f147", "patch": "@@ -113,27 +113,29 @@ type buffer<T: send> = {\n \n struct packet_header {\n     let mut state: state;\n-    let mut blocked_task: option<*rust_task>;\n+    let mut blocked_task: *rust_task;\n \n     // This is a reinterpret_cast of a ~buffer, that can also be cast\n     // to a buffer_header if need be.\n     let mut buffer: *libc::c_void;\n \n     new() {\n         self.state = empty;\n-        self.blocked_task = none;\n+        self.blocked_task = ptr::null();\n         self.buffer = ptr::null();\n     }\n \n     // Returns the old state.\n     unsafe fn mark_blocked(this: *rust_task) -> state {\n-        self.blocked_task = some(this);\n+        rustrt::rust_task_ref(this);\n+        let old_task = swap_task(self.blocked_task, this);\n+        assert old_task.is_null();\n         swap_state_acq(self.state, blocked)\n     }\n \n     unsafe fn unblock() {\n-        assert self.state != blocked || self.blocked_task != none;\n-        self.blocked_task = none;\n+        let old_task = swap_task(self.blocked_task, ptr::null());\n+        if !old_task.is_null() { rustrt::rust_task_deref(old_task) }\n         alt swap_state_acq(self.state, empty) {\n           empty | blocked => (),\n           terminated => self.state = terminated,\n@@ -240,12 +242,26 @@ fn atomic_sub_rel(&dst: int, src: int) -> int {\n     rusti::atomic_sub_rel(dst, src)\n }\n \n+#[doc(hidden)]\n+fn swap_task(&dst: *rust_task, src: *rust_task) -> *rust_task {\n+    // It might be worth making both acquire and release versions of\n+    // this.\n+    unsafe {\n+        reinterpret_cast(rusti::atomic_xchng(\n+            *(ptr::mut_addr_of(dst) as *mut int),\n+            src as int))\n+    }\n+}\n+\n #[doc(hidden)]\n type rust_task = libc::c_void;\n \n extern mod rustrt {\n     #[rust_stack]\n     fn rust_get_task() -> *rust_task;\n+    #[rust_stack]\n+    fn rust_task_ref(task: *rust_task);\n+    fn rust_task_deref(task: *rust_task);\n \n     #[rust_stack]\n     fn task_clear_event_reject(task: *rust_task);\n@@ -334,10 +350,11 @@ fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n       full => fail ~\"duplicate send\",\n       blocked => {\n         debug!{\"waking up task for %?\", p_};\n-        alt p.header.blocked_task {\n-          some(task) => rustrt::task_signal_event(\n-              task, ptr::addr_of(p.header) as *libc::c_void),\n-          none => debug!{\"just kidding!\"}\n+        let old_task = swap_task(p.header.blocked_task, ptr::null());\n+        if !old_task.is_null() {\n+            rustrt::task_signal_event(\n+                old_task, ptr::addr_of(p.header) as *libc::c_void);\n+            rustrt::rust_task_deref(old_task);\n         }\n \n         // The receiver will eventually clean this up.\n@@ -372,7 +389,9 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n     let p = unsafe { &*p_ };\n     let this = rustrt::rust_get_task();\n     rustrt::task_clear_event_reject(this);\n-    p.header.blocked_task = some(this);\n+    rustrt::rust_task_ref(this);\n+    let old_task = swap_task(p.header.blocked_task, this);\n+    assert old_task.is_null();\n     let mut first = true;\n     let mut count = SPIN_COUNT;\n     loop {\n@@ -402,14 +421,22 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n           full => {\n             let mut payload = none;\n             payload <-> p.payload;\n-            p.header.blocked_task = none;\n+            let old_task = swap_task(p.header.blocked_task, ptr::null());\n+            if !old_task.is_null() {\n+                rustrt::rust_task_deref(old_task);\n+            }\n             p.header.state = empty;\n             return some(option::unwrap(payload))\n           }\n           terminated => {\n             // This assert detects when we've accidentally unsafely\n             // casted too big of a number to a state.\n             assert old_state == terminated;\n+\n+            let old_task = swap_task(p.header.blocked_task, ptr::null());\n+            if !old_task.is_null() {\n+                rustrt::rust_task_deref(old_task);\n+            }\n             return none;\n           }\n         }\n@@ -437,17 +464,18 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { &*p };\n     alt swap_state_rel(p.header.state, terminated) {\n       empty => {\n+        assert p.header.blocked_task.is_null();\n         // The receiver will eventually clean up.\n         //unsafe { forget(p) }\n       }\n       blocked => {\n         // wake up the target\n-        alt p.header.blocked_task {\n-          some(target) =>\n+        let old_task = swap_task(p.header.blocked_task, ptr::null());\n+        if !old_task.is_null() {\n             rustrt::task_signal_event(\n-                target,\n-                ptr::addr_of(p.header) as *libc::c_void),\n-          none => { debug!{\"receiver is already shutting down\"} }\n+                old_task,\n+                ptr::addr_of(p.header) as *libc::c_void);\n+            rustrt::rust_task_deref(old_task);\n         }\n         // The receiver will eventually clean up.\n         //unsafe { forget(p) }\n@@ -457,6 +485,7 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n         fail ~\"you dun goofed\"\n       }\n       terminated => {\n+        assert p.header.blocked_task.is_null();\n         // I have to clean up, use drop_glue\n       }\n     }\n@@ -465,7 +494,7 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n #[doc(hidden)]\n fn receiver_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { &*p };\n-    assert p.header.blocked_task == none;\n+    assert p.header.blocked_task.is_null();\n     alt swap_state_rel(p.header.state, terminated) {\n       empty => {\n         // the sender will clean up"}, {"sha": "061e87ebff82d32f129eb9119a2b60ec594ba166", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=9f287c211eb3a92ae3aa31b6f767bb9998f2f147", "patch": "@@ -678,9 +678,6 @@ MUST_CHECK bool rust_task::wait_event(void **result) {\n \n void\n rust_task::signal_event(void *event) {\n-    assert(task_state_blocked == state ||\n-           task_state_running == state);\n-\n     scoped_lock with(lifecycle_lock);\n \n     this->event = event;"}, {"sha": "5b309659ee5056925a81a858d4f10fdf24462379", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f287c211eb3a92ae3aa31b6f767bb9998f2f147/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=9f287c211eb3a92ae3aa31b6f767bb9998f2f147", "patch": "@@ -1,8 +1,6 @@\n // -*- rust -*-\n // xfail-pretty\n \n-// xfail-test\n-\n /*\n   A parallel version of fibonacci numbers.\n "}]}