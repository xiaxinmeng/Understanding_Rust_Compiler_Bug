{"sha": "eb25c42fc86b52863f8f438893c3856ed3fc51bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMjVjNDJmYzg2YjUyODYzZjhmNDM4ODkzYzM4NTZlZDNmYzUxYmM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-02-25T02:20:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-20T20:33:43Z"}, "message": "std: Make the generic atomics take unsafe pointers\n\nThese mutate values behind references that are Freeze, which is not\nallowed.", "tree": {"sha": "f6d68a167079963e7207a0c4de022b98d10fa5b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6d68a167079963e7207a0c4de022b98d10fa5b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb25c42fc86b52863f8f438893c3856ed3fc51bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb25c42fc86b52863f8f438893c3856ed3fc51bc", "html_url": "https://github.com/rust-lang/rust/commit/eb25c42fc86b52863f8f438893c3856ed3fc51bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb25c42fc86b52863f8f438893c3856ed3fc51bc/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3fef9a6493fdd6322ff1b879f050750805a53a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fef9a6493fdd6322ff1b879f050750805a53a2", "html_url": "https://github.com/rust-lang/rust/commit/f3fef9a6493fdd6322ff1b879f050750805a53a2"}], "stats": {"total": 363, "additions": 170, "deletions": 193}, "files": [{"sha": "87b823d884ec13c7a132f942cdc4846808fbac12", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eb25c42fc86b52863f8f438893c3856ed3fc51bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb25c42fc86b52863f8f438893c3856ed3fc51bc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=eb25c42fc86b52863f8f438893c3856ed3fc51bc", "patch": "@@ -4012,30 +4012,18 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n \n         //We only care about the operation here\n         match *split.get(1) {\n-            \"cxchg\" => (1, vec!(ty::mk_imm_rptr(tcx,\n-                                             ty::ReLateBound(it.id, ty::BrAnon(0)),\n-                                             param(ccx, 0)),\n-                        param(ccx, 0),\n-                        param(ccx, 0)), param(ccx, 0)),\n-            \"load\" => (1,\n-               vec!(\n-                  ty::mk_imm_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)),\n-                                  param(ccx, 0))\n-               ),\n-              param(ccx, 0)),\n-            \"store\" => (1,\n-               vec!(\n-                  ty::mk_imm_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)),\n-                                  param(ccx, 0)),\n-                  param(ccx, 0)\n-               ),\n-               ty::mk_nil()),\n+            \"cxchg\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)),\n+                                param(ccx, 0),\n+                                param(ccx, 0)),\n+                        param(ccx, 0)),\n+            \"load\" => (1, vec!(ty::mk_imm_ptr(tcx, param(ccx, 0))),\n+                       param(ccx, 0)),\n+            \"store\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n+                        ty::mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n-                (1, vec!(ty::mk_imm_rptr(tcx,\n-                                      ty::ReLateBound(it.id, ty::BrAnon(0)),\n-                                      param(ccx, 0)), param(ccx, 0) ),\n+                (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n                  param(ccx, 0))\n             }\n             \"fence\" => {"}, {"sha": "95607bd8f79bdbfdadb3eb74126f48404e4d1c36", "filename": "src/libstd/intrinsics.rs", "status": "modified", "additions": 82, "deletions": 79, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/eb25c42fc86b52863f8f438893c3856ed3fc51bc/src%2Flibstd%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb25c42fc86b52863f8f438893c3856ed3fc51bc/src%2Flibstd%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fintrinsics.rs?ref=eb25c42fc86b52863f8f438893c3856ed3fc51bc", "patch": "@@ -250,85 +250,88 @@ extern \"rust-intrinsic\" {\n #[cfg(not(stage0))]\n extern \"rust-intrinsic\" {\n \n-    pub fn atomic_cxchg<T>(dst: &T, old: T, src: T) -> T;\n-    pub fn atomic_cxchg_acq<T>(dst: &T, old: T, src: T) -> T;\n-    pub fn atomic_cxchg_rel<T>(dst: &T, old: T, src: T) -> T;\n-    pub fn atomic_cxchg_acqrel<T>(dst: &T, old: T, src: T) -> T;\n-    pub fn atomic_cxchg_relaxed<T>(dst: &T, old: T, src: T) -> T;\n-\n-    pub fn atomic_load<T>(src: &T) -> T;\n-    pub fn atomic_load_acq<T>(src: &T) -> T;\n-    pub fn atomic_load_relaxed<T>(src: &T) -> T;\n-\n-    pub fn atomic_store<T>(dst: &T, val: T);\n-    pub fn atomic_store_rel<T>(dst: &T, val: T);\n-    pub fn atomic_store_relaxed<T>(dst: &T, val: T);\n-\n-    pub fn atomic_xchg<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xchg_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xchg_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xchg_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xchg_relaxed<T>(dst: &T, src: T) -> T;\n-\n-    pub fn atomic_xadd<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xadd_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xadd_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xadd_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xadd_relaxed<T>(dst: &T, src: T) -> T;\n-\n-    pub fn atomic_xsub<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xsub_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xsub_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xsub_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xsub_relaxed<T>(dst: &T, src: T) -> T;\n-\n-    pub fn atomic_and<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_and_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_and_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_and_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_and_relaxed<T>(dst: &T, src: T) -> T;\n-\n-    pub fn atomic_nand<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_nand_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_nand_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_nand_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_nand_relaxed<T>(dst: &T, src: T) -> T;\n-\n-    pub fn atomic_or<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_or_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_or_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_or_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_or_relaxed<T>(dst: &T, src: T) -> T;\n-\n-    pub fn atomic_xor<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xor_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xor_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xor_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_xor_relaxed<T>(dst: &T, src: T) -> T;\n-\n-    pub fn atomic_max<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_max_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_max_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_max_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_max_relaxed<T>(dst: &T, src: T) -> T;\n-\n-    pub fn atomic_min<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_min_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_min_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_min_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_min_relaxed<T>(dst: &T, src: T) -> T;\n-\n-    pub fn atomic_umin<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_umin_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_umin_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_umin_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_umin_relaxed<T>(dst: &T, src: T) -> T;\n-\n-    pub fn atomic_umax<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_umax_acq<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_umax_rel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_umax_acqrel<T>(dst: &T, src: T) -> T;\n-    pub fn atomic_umax_relaxed<T>(dst: &T, src: T) -> T;\n+    // NB: These intrinsics take unsafe pointers because they mutate aliased\n+    // memory, which is not valid for either `&` or `&mut`.\n+\n+    pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> T;\n+    pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> T;\n+\n+    pub fn atomic_load<T>(src: *T) -> T;\n+    pub fn atomic_load_acq<T>(src: *T) -> T;\n+    pub fn atomic_load_relaxed<T>(src: *T) -> T;\n+\n+    pub fn atomic_store<T>(dst: *mut T, val: T);\n+    pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n+    pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);\n+\n+    pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n+\n+    pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;\n+\n+    pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;\n+\n+    pub fn atomic_and<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;\n+\n+    pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;\n+\n+    pub fn atomic_or<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;\n+\n+    pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;\n+\n+    pub fn atomic_max<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_relaxed<T>(dst: *mut T, src: T) -> T;\n+\n+    pub fn atomic_min<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_relaxed<T>(dst: *mut T, src: T) -> T;\n+\n+    pub fn atomic_umin<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_relaxed<T>(dst: *mut T, src: T) -> T;\n+\n+    pub fn atomic_umax<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acq<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_rel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acqrel<T>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;\n }\n \n extern \"rust-intrinsic\" {"}, {"sha": "bc181d2e3df4780b4e2bb37020740a6ec32c8939", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/eb25c42fc86b52863f8f438893c3856ed3fc51bc/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb25c42fc86b52863f8f438893c3856ed3fc51bc/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=eb25c42fc86b52863f8f438893c3856ed3fc51bc", "patch": "@@ -217,23 +217,23 @@ impl AtomicBool {\n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(&*self.v.get(), order) > 0 }\n+        unsafe { atomic_load(self.v.get() as *uint, order) > 0 }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n+        unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_swap(&mut *self.v.get(), val, order) > 0 }\n+        unsafe { atomic_swap(self.v.get(), val, order) > 0 }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -286,7 +286,7 @@ impl AtomicBool {\n         let old = if old { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) > 0 }\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) > 0 }\n     }\n \n     /// A logical \"and\" operation\n@@ -316,7 +316,7 @@ impl AtomicBool {\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_and(&mut *self.v.get(), val, order) > 0 }\n+        unsafe { atomic_and(self.v.get(), val, order) > 0 }\n     }\n \n     /// A logical \"nand\" operation\n@@ -347,7 +347,7 @@ impl AtomicBool {\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_nand(&mut *self.v.get(), val, order) > 0 }\n+        unsafe { atomic_nand(self.v.get(), val, order) > 0 }\n     }\n \n     /// A logical \"or\" operation\n@@ -377,7 +377,7 @@ impl AtomicBool {\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_or(&mut *self.v.get(), val, order) > 0 }\n+        unsafe { atomic_or(self.v.get(), val, order) > 0 }\n     }\n \n     /// A logical \"xor\" operation\n@@ -407,7 +407,7 @@ impl AtomicBool {\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_xor(&mut *self.v.get(), val, order) > 0 }\n+        unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n     }\n }\n \n@@ -420,19 +420,19 @@ impl AtomicInt {\n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> int {\n-        unsafe { atomic_load(&*self.v.get(), order) }\n+        unsafe { atomic_load(self.v.get() as *int, order) }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&self, val: int, order: Ordering) {\n-        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n+        unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n+        unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -442,7 +442,7 @@ impl AtomicInt {\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n     pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n-        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n     /// Add to the current value, returning the previous\n@@ -458,7 +458,7 @@ impl AtomicInt {\n     /// ```\n     #[inline]\n     pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n+        unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n     /// Subtract from the current value, returning the previous\n@@ -474,7 +474,7 @@ impl AtomicInt {\n     /// ```\n     #[inline]\n     pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n+        unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n }\n \n@@ -489,32 +489,32 @@ impl AtomicU64 {\n \n     #[inline]\n     pub fn load(&self, order: Ordering) -> u64 {\n-        unsafe { atomic_load(&*self.v.get(), order) }\n+        unsafe { atomic_load(self.v.get(), order) }\n     }\n \n     #[inline]\n     pub fn store(&self, val: u64, order: Ordering) {\n-        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n+        unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     #[inline]\n     pub fn swap(&self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n+        unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n     #[inline]\n     pub fn compare_and_swap(&self, old: u64, new: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n     #[inline]\n     pub fn fetch_add(&self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n+        unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n     #[inline]\n     pub fn fetch_sub(&self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n+        unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n }\n \n@@ -527,19 +527,19 @@ impl AtomicUint {\n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> uint {\n-        unsafe { atomic_load(&*self.v.get(), order) }\n+        unsafe { atomic_load(self.v.get() as *uint, order) }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&self, val: uint, order: Ordering) {\n-        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n+        unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n+        unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -549,7 +549,7 @@ impl AtomicUint {\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n     pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n-        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n     /// Add to the current value, returning the previous\n@@ -565,7 +565,7 @@ impl AtomicUint {\n     /// ```\n     #[inline]\n     pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n+        unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n     /// Subtract from the current value, returning the previous\n@@ -581,7 +581,7 @@ impl AtomicUint {\n     /// ```\n     #[inline]\n     pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n+        unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n }\n \n@@ -595,20 +595,20 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_load(&*self.p.get(), order) as *mut T\n+            atomic_load(self.p.get() as **mut T, order) as *mut T\n         }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(&mut *self.p.get(), ptr as uint, order); }\n+        unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n-        unsafe { atomic_swap(&mut *self.p.get(), ptr as uint, order) as *mut T }\n+        unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -619,7 +619,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(&mut *self.p.get(), old as uint,\n+            atomic_compare_and_swap(self.p.get(), old as uint,\n                                     new as uint, order) as *mut T\n         }\n     }\n@@ -640,7 +640,7 @@ impl<T> AtomicOption<T> {\n         unsafe {\n             let val = cast::transmute(val);\n \n-            let p = atomic_swap(&mut *self.p.get(), val, order);\n+            let p = atomic_swap(self.p.get(), val, order);\n             if p as uint == 0 {\n                 None\n             } else {\n@@ -665,7 +665,7 @@ impl<T> AtomicOption<T> {\n         unsafe {\n             let val = cast::transmute(val);\n             let expected = cast::transmute(0);\n-            let oldval = atomic_compare_and_swap(&mut *self.p.get(), expected, val, order);\n+            let oldval = atomic_compare_and_swap(self.p.get(), expected, val, order);\n             if oldval == expected {\n                 None\n             } else {\n@@ -680,7 +680,7 @@ impl<T> AtomicOption<T> {\n     /// result does not get invalidated by another task after this returns.\n     #[inline]\n     pub fn is_empty(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(&*self.p.get(), order) as uint == 0 }\n+        unsafe { atomic_load(self.p.get() as *uint, order) as uint == 0 }\n     }\n }\n \n@@ -692,7 +692,7 @@ impl<T> Drop for AtomicOption<T> {\n }\n \n #[inline]\n-pub unsafe fn atomic_store<T>(dst: &T, val: T, order:Ordering) {\n+pub unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n     match order {\n         Release => intrinsics::atomic_store_rel(dst, val),\n         Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n@@ -701,7 +701,7 @@ pub unsafe fn atomic_store<T>(dst: &T, val: T, order:Ordering) {\n }\n \n #[inline]\n-pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {\n+pub unsafe fn atomic_load<T>(dst: *mut T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n         Relaxed => intrinsics::atomic_load_relaxed(dst),\n@@ -710,7 +710,7 @@ pub unsafe fn atomic_load<T>(dst: &T, order:Ordering) -> T {\n }\n \n #[inline]\n-pub unsafe fn atomic_swap<T>(dst: &T, val: T, order: Ordering) -> T {\n+pub unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n         Release => intrinsics::atomic_xchg_rel(dst, val),\n@@ -722,7 +722,7 @@ pub unsafe fn atomic_swap<T>(dst: &T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_add).\n #[inline]\n-pub unsafe fn atomic_add<T>(dst: &T, val: T, order: Ordering) -> T {\n+pub unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n         Release => intrinsics::atomic_xadd_rel(dst, val),\n@@ -734,7 +734,7 @@ pub unsafe fn atomic_add<T>(dst: &T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_sub).\n #[inline]\n-pub unsafe fn atomic_sub<T>(dst: &T, val: T, order: Ordering) -> T {\n+pub unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n         Release => intrinsics::atomic_xsub_rel(dst, val),\n@@ -745,7 +745,7 @@ pub unsafe fn atomic_sub<T>(dst: &T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-pub unsafe fn atomic_compare_and_swap<T>(dst:&T, old:T, new:T, order: Ordering) -> T {\n+pub unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n         Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n@@ -756,7 +756,7 @@ pub unsafe fn atomic_compare_and_swap<T>(dst:&T, old:T, new:T, order: Ordering)\n }\n \n #[inline]\n-pub unsafe fn atomic_and<T>(dst: &T, val: T, order: Ordering) -> T {\n+pub unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n         Release => intrinsics::atomic_and_rel(dst, val),\n@@ -779,7 +779,7 @@ pub unsafe fn atomic_nand<T>(dst: &T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-pub unsafe fn atomic_or<T>(dst: &T, val: T, order: Ordering) -> T {\n+pub unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n         Release => intrinsics::atomic_or_rel(dst, val),\n@@ -791,7 +791,7 @@ pub unsafe fn atomic_or<T>(dst: &T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-pub unsafe fn atomic_xor<T>(dst: &T, val: T, order: Ordering) -> T {\n+pub unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n         Release => intrinsics::atomic_xor_rel(dst, val),\n@@ -914,16 +914,16 @@ mod test {\n     fn different_sizes() {\n         unsafe {\n             let mut slot = 0u16;\n-            assert_eq!(super::atomic_swap(&slot, 1, SeqCst), 0);\n+            assert_eq!(super::atomic_swap(&mut slot, 1, SeqCst), 0);\n \n             let mut slot = 0u8;\n-            assert_eq!(super::atomic_compare_and_swap(&slot, 1, 2, SeqCst), 0);\n+            assert_eq!(super::atomic_compare_and_swap(&mut slot, 1, 2, SeqCst), 0);\n \n             let mut slot = 0u32;\n             assert_eq!(super::atomic_load(&slot, SeqCst), 0);\n \n             let mut slot = 0u64;\n-            super::atomic_store(&slot, 2, SeqCst);\n+            super::atomic_store(&mut slot, 2, SeqCst);\n         }\n     }\n }"}, {"sha": "35d987480c0786be72ce1ae6884012c07ac58be4", "filename": "src/test/auxiliary/cci_intrinsic.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb25c42fc86b52863f8f438893c3856ed3fc51bc/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb25c42fc86b52863f8f438893c3856ed3fc51bc/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs?ref=eb25c42fc86b52863f8f438893c3856ed3fc51bc", "patch": "@@ -10,26 +10,12 @@\n \n pub mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn atomic_cxchg<T>(dst: &T, old: T, src: T) -> T;\n-        pub fn atomic_cxchg_acq<T>(dst: &T, old: T, src: T) -> T;\n-        pub fn atomic_cxchg_rel<T>(dst: &T, old: T, src: T) -> T;\n-\n-        pub fn atomic_xchg<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xchg_acq<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xchg_rel<T>(dst: &T, src: T) -> T;\n-\n-        pub fn atomic_xadd<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xadd_acq<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xadd_rel<T>(dst: &T, src: T) -> T;\n-\n-        pub fn atomic_xsub<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xsub_acq<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xsub_rel<T>(dst: &T, src: T) -> T;\n+        pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n     }\n }\n \n #[inline(always)]\n-pub fn atomic_xchg(dst: &mut int, src: int) -> int {\n+pub fn atomic_xchg(dst: *mut int, src: int) -> int {\n     unsafe {\n         rusti::atomic_xchg(dst, src)\n     }"}, {"sha": "b663cbfa50974e43088ced20806ca9027bf853d3", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/eb25c42fc86b52863f8f438893c3856ed3fc51bc/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb25c42fc86b52863f8f438893c3856ed3fc51bc/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=eb25c42fc86b52863f8f438893c3856ed3fc51bc", "patch": "@@ -10,69 +10,69 @@\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn atomic_cxchg<T>(dst: &T, old: T, src: T) -> T;\n-        pub fn atomic_cxchg_acq<T>(dst: &T, old: T, src: T) -> T;\n-        pub fn atomic_cxchg_rel<T>(dst: &T, old: T, src: T) -> T;\n+        pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> T;\n+        pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;\n+        pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;\n \n-        pub fn atomic_load<T>(src: &T) -> T;\n-        pub fn atomic_load_acq<T>(src: &T) -> T;\n+        pub fn atomic_load<T>(src: *T) -> T;\n+        pub fn atomic_load_acq<T>(src: *T) -> T;\n \n-        pub fn atomic_store<T>(dst: &T, val: T);\n-        pub fn atomic_store_rel<T>(dst: &T, val: T);\n+        pub fn atomic_store<T>(dst: *mut T, val: T);\n+        pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n \n-        pub fn atomic_xchg<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xchg_acq<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xchg_rel<T>(dst: &T, src: T) -> T;\n+        pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;\n \n-        pub fn atomic_xadd<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xadd_acq<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xadd_rel<T>(dst: &T, src: T) -> T;\n+        pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n \n-        pub fn atomic_xsub<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xsub_acq<T>(dst: &T, src: T) -> T;\n-        pub fn atomic_xsub_rel<T>(dst: &T, src: T) -> T;\n+        pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;\n     }\n }\n \n pub fn main() {\n     unsafe {\n         let mut x = ~1;\n \n-        assert_eq!(rusti::atomic_load(x), 1);\n+        assert_eq!(rusti::atomic_load(&*x), 1);\n         *x = 5;\n-        assert_eq!(rusti::atomic_load_acq(x), 5);\n+        assert_eq!(rusti::atomic_load_acq(&*x), 5);\n \n-        rusti::atomic_store(x,3);\n+        rusti::atomic_store(&mut *x,3);\n         assert_eq!(*x, 3);\n-        rusti::atomic_store_rel(x,1);\n+        rusti::atomic_store_rel(&mut *x,1);\n         assert_eq!(*x, 1);\n \n-        assert_eq!(rusti::atomic_cxchg(x, 1, 2), 1);\n+        assert_eq!(rusti::atomic_cxchg(&mut *x, 1, 2), 1);\n         assert_eq!(*x, 2);\n \n-        assert_eq!(rusti::atomic_cxchg_acq(x, 1, 3), 2);\n+        assert_eq!(rusti::atomic_cxchg_acq(&mut *x, 1, 3), 2);\n         assert_eq!(*x, 2);\n \n-        assert_eq!(rusti::atomic_cxchg_rel(x, 2, 1), 2);\n+        assert_eq!(rusti::atomic_cxchg_rel(&mut *x, 2, 1), 2);\n         assert_eq!(*x, 1);\n \n-        assert_eq!(rusti::atomic_xchg(x, 0), 1);\n+        assert_eq!(rusti::atomic_xchg(&mut *x, 0), 1);\n         assert_eq!(*x, 0);\n \n-        assert_eq!(rusti::atomic_xchg_acq(x, 1), 0);\n+        assert_eq!(rusti::atomic_xchg_acq(&mut *x, 1), 0);\n         assert_eq!(*x, 1);\n \n-        assert_eq!(rusti::atomic_xchg_rel(x, 0), 1);\n+        assert_eq!(rusti::atomic_xchg_rel(&mut *x, 0), 1);\n         assert_eq!(*x, 0);\n \n-        assert_eq!(rusti::atomic_xadd(x, 1), 0);\n-        assert_eq!(rusti::atomic_xadd_acq(x, 1), 1);\n-        assert_eq!(rusti::atomic_xadd_rel(x, 1), 2);\n+        assert_eq!(rusti::atomic_xadd(&mut *x, 1), 0);\n+        assert_eq!(rusti::atomic_xadd_acq(&mut *x, 1), 1);\n+        assert_eq!(rusti::atomic_xadd_rel(&mut *x, 1), 2);\n         assert_eq!(*x, 3);\n \n-        assert_eq!(rusti::atomic_xsub(x, 1), 3);\n-        assert_eq!(rusti::atomic_xsub_acq(x, 1), 2);\n-        assert_eq!(rusti::atomic_xsub_rel(x, 1), 1);\n+        assert_eq!(rusti::atomic_xsub(&mut *x, 1), 3);\n+        assert_eq!(rusti::atomic_xsub_acq(&mut *x, 1), 2);\n+        assert_eq!(rusti::atomic_xsub_rel(&mut *x, 1), 1);\n         assert_eq!(*x, 0);\n     }\n }"}]}