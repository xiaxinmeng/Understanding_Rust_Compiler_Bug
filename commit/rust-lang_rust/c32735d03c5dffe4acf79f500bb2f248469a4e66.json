{"sha": "c32735d03c5dffe4acf79f500bb2f248469a4e66", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMjczNWQwM2M1ZGZmZTRhY2Y3OWY1MDBiYjJmMjQ4NDY5YTRlNjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-06T13:36:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-06T13:36:27Z"}, "message": "Rollup merge of #62459 - timvermeulen:result_sum_internal_iteration, r=scottmcm\n\nUse internal iteration in the Sum and Product impls of Result and Option\n\nThis PR adds internal iteration to the `ResultShunt` iterator type underlying the `Sum` and `Product` impls of `Result`. I had to change `ResultShunt` to hold a mutable reference to an error instead, similar to `itertools::ProcessResults`, in order to be able to pass the `ResultShunt` itself by value (which is necessary for internal iteration).\n\n`ResultShunt::process` can unfortunately no longer be an associated function because that would make it generic over the lifetime of the error reference, which wouldn't work, so I turned it into the free function `process_results`.\n\nI removed the `OptionShunt` type and forwarded the `Sum` and `Product` impls of `Option` to their respective impls of `Result` instead, to avoid having to repeat the internal iteration logic.", "tree": {"sha": "8a7c0a9c1062e6b324daa5bf4656add88c2375ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a7c0a9c1062e6b324daa5bf4656add88c2375ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c32735d03c5dffe4acf79f500bb2f248469a4e66", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdSYJbCRBK7hj4Ov3rIwAAdHIIAKzyR24R5m95V8FDktTyJwGK\naA7OJjHMc107lzZjLkGSUkNTiyxnaBmxJXKG3AfGytFidbGsSZhFXHhoMU4NHUlt\nNUvp2EfyvL2KPysH0I9dT4vYMDWyYGjHMEip0k0c6EZBzYhH5Ik+o8f84IWn5rOu\nQLDb92alHiMOj2XK7TR2szQXcq4GQA2/enaPrYEmyFtm1H2SmqkqW3zZVTYzMfbk\nJnjn4nWSr1yOZTBdoFW9v4pXjynzj9q8E1Xn2ta07IDrYilxMQIW2H/TcyZu7ukj\n/GKwASZmXw3gWfZt+ll8syYohbRezxeW3AVwguTOZkm9CvqiKgiqG9EmIkVaydo=\n=Ro8I\n-----END PGP SIGNATURE-----\n", "payload": "tree 8a7c0a9c1062e6b324daa5bf4656add88c2375ff\nparent 8996328ebf34aa73e83a1db326767c11041f811d\nparent 2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565098587 +0200\ncommitter GitHub <noreply@github.com> 1565098587 +0200\n\nRollup merge of #62459 - timvermeulen:result_sum_internal_iteration, r=scottmcm\n\nUse internal iteration in the Sum and Product impls of Result and Option\n\nThis PR adds internal iteration to the `ResultShunt` iterator type underlying the `Sum` and `Product` impls of `Result`. I had to change `ResultShunt` to hold a mutable reference to an error instead, similar to `itertools::ProcessResults`, in order to be able to pass the `ResultShunt` itself by value (which is necessary for internal iteration).\n\n`ResultShunt::process` can unfortunately no longer be an associated function because that would make it generic over the lifetime of the error reference, which wouldn't work, so I turned it into the free function `process_results`.\n\nI removed the `OptionShunt` type and forwarded the `Sum` and `Product` impls of `Option` to their respective impls of `Result` instead, to avoid having to repeat the internal iteration logic.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c32735d03c5dffe4acf79f500bb2f248469a4e66", "html_url": "https://github.com/rust-lang/rust/commit/c32735d03c5dffe4acf79f500bb2f248469a4e66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c32735d03c5dffe4acf79f500bb2f248469a4e66/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8996328ebf34aa73e83a1db326767c11041f811d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8996328ebf34aa73e83a1db326767c11041f811d", "html_url": "https://github.com/rust-lang/rust/commit/8996328ebf34aa73e83a1db326767c11041f811d"}, {"sha": "2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "html_url": "https://github.com/rust-lang/rust/commit/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0"}], "stats": {"total": 186, "additions": 67, "deletions": 119}, "files": [{"sha": "b2702902956935b86d2f805cfb5582434379a395", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 37, "deletions": 109, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=c32735d03c5dffe4acf79f500bb2f248469a4e66", "patch": "@@ -2180,137 +2180,65 @@ impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n     where F: FnMut(&I::Item) {}\n \n-/// An iterator adapter that produces output as long as the underlying\n-/// iterator produces `Option::Some` values.\n-pub(crate) struct OptionShunt<I> {\n-    iter: I,\n-    exited_early: bool,\n-}\n-\n-impl<I, T> OptionShunt<I>\n-where\n-    I: Iterator<Item = Option<T>>,\n-{\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Option<T>`. Any `None` value will stop the inner iterator and\n-    /// the overall result will be a `None`.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n-    where\n-        F: FnMut(&mut Self) -> U,\n-    {\n-        let mut shunt = OptionShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        OptionShunt {\n-            iter,\n-            exited_early: false,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Option` value.\n-    fn reconstruct<U>(self, val: U) -> Option<U> {\n-        if self.exited_early {\n-            None\n-        } else {\n-            Some(val)\n-        }\n-    }\n-}\n-\n-impl<I, T> Iterator for OptionShunt<I>\n-where\n-    I: Iterator<Item = Option<T>>,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Some(v)) => Some(v),\n-            Some(None) => {\n-                self.exited_early = true;\n-                None\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.exited_early {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper)\n-        }\n-    }\n-}\n-\n /// An iterator adapter that produces output as long as the underlying\n /// iterator produces `Result::Ok` values.\n ///\n /// If an error is encountered, the iterator stops and the error is\n-/// stored. The error may be recovered later via `reconstruct`.\n-pub(crate) struct ResultShunt<I, E> {\n+/// stored.\n+pub(crate) struct ResultShunt<'a, I, E> {\n     iter: I,\n-    error: Option<E>,\n+    error: &'a mut Result<(), E>,\n }\n \n-impl<I, T, E> ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n+/// Process the given iterator as if it yielded a `T` instead of a\n+/// `Result<T, _>`. Any errors will stop the inner iterator and\n+/// the overall result will be an error.\n+pub(crate) fn process_results<I, T, E, F, U>(iter: I, mut f: F) -> Result<U, E>\n+where\n+    I: Iterator<Item = Result<T, E>>,\n+    for<'a> F: FnMut(ResultShunt<'a, I, E>) -> U,\n {\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Result<T, _>`. Any errors will stop the inner iterator and\n-    /// the overall result will be an error.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n-        where F: FnMut(&mut Self) -> U\n-    {\n-        let mut shunt = ResultShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        ResultShunt {\n-            iter,\n-            error: None,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Result` value. This should\n-    /// *always* be called, otherwise any potential error would be\n-    /// lost.\n-    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n-        match self.error {\n-            None => Ok(val),\n-            Some(e) => Err(e),\n-        }\n-    }\n+    let mut error = Ok(());\n+    let shunt = ResultShunt {\n+        iter,\n+        error: &mut error,\n+    };\n+    let value = f(shunt);\n+    error.map(|()| value)\n }\n \n-impl<I, T, E> Iterator for ResultShunt<I, E>\n+impl<I, T, E> Iterator for ResultShunt<'_, I, E>\n     where I: Iterator<Item = Result<T, E>>\n {\n     type Item = T;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Ok(v)) => Some(v),\n-            Some(Err(e)) => {\n-                self.error = Some(e);\n-                None\n-            }\n-            None => None,\n-        }\n+        self.find(|_| true)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.error.is_some() {\n+        if self.error.is_err() {\n             (0, Some(0))\n         } else {\n             let (_, upper) = self.iter.size_hint();\n             (0, upper)\n         }\n     }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let error = &mut *self.error;\n+        self.iter\n+            .try_fold(init, |acc, x| match x {\n+                Ok(x) => LoopState::from_try(f(acc, x)),\n+                Err(e) => {\n+                    *error = Err(e);\n+                    LoopState::Break(Try::from_ok(acc))\n+                }\n+            })\n+            .into_try()\n+    }\n }"}, {"sha": "aba8e84d58be553566165846b39eb2990f2da84b", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=c32735d03c5dffe4acf79f500bb2f248469a4e66", "patch": "@@ -360,7 +360,7 @@ pub use self::adapters::Flatten;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n pub use self::adapters::Copied;\n \n-pub(crate) use self::adapters::{TrustedRandomAccess, OptionShunt, ResultShunt};\n+pub(crate) use self::adapters::{TrustedRandomAccess, process_results};\n \n mod range;\n mod sources;"}, {"sha": "812463e77f9767476c4ae42b474db34a8e88b339", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=c32735d03c5dffe4acf79f500bb2f248469a4e66", "patch": "@@ -1,6 +1,6 @@\n use crate::ops::{Mul, Add};\n use crate::num::Wrapping;\n-use crate::iter::adapters::{OptionShunt, ResultShunt};\n+use crate::iter;\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///\n@@ -139,7 +139,7 @@ impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n     fn sum<I>(iter: I) -> Result<T, E>\n         where I: Iterator<Item = Result<U, E>>,\n     {\n-        ResultShunt::process(iter, |i| i.sum())\n+        iter::process_results(iter, |i| i.sum())\n     }\n }\n \n@@ -153,7 +153,7 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n     fn product<I>(iter: I) -> Result<T, E>\n         where I: Iterator<Item = Result<U, E>>,\n     {\n-        ResultShunt::process(iter, |i| i.product())\n+        iter::process_results(iter, |i| i.product())\n     }\n }\n \n@@ -180,7 +180,7 @@ where\n     where\n         I: Iterator<Item = Option<U>>,\n     {\n-        OptionShunt::process(iter, |i| i.sum())\n+        iter.map(|x| x.ok_or(())).sum::<Result<_, _>>().ok()\n     }\n }\n \n@@ -196,6 +196,6 @@ where\n     where\n         I: Iterator<Item = Option<U>>,\n     {\n-        OptionShunt::process(iter, |i| i.product())\n+        iter.map(|x| x.ok_or(())).product::<Result<_, _>>().ok()\n     }\n }"}, {"sha": "259ed36c5788530d05333c8158a7ff884fc28e31", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c32735d03c5dffe4acf79f500bb2f248469a4e66", "patch": "@@ -135,7 +135,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::iter::{FromIterator, FusedIterator, TrustedLen, OptionShunt};\n+use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n use crate::{convert, fmt, hint, mem, ops::{self, Deref, DerefMut}};\n use crate::pin::Pin;\n \n@@ -1499,7 +1499,10 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        OptionShunt::process(iter.into_iter(), |i| i.collect())\n+        iter.into_iter()\n+            .map(|x| x.ok_or(()))\n+            .collect::<Result<_, _>>()\n+            .ok()\n     }\n }\n "}, {"sha": "8c60a9c1b501d0497aec7faea4154e086f89c16e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c32735d03c5dffe4acf79f500bb2f248469a4e66", "patch": "@@ -231,7 +231,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n-use crate::iter::{FromIterator, FusedIterator, TrustedLen, ResultShunt};\n+use crate::iter::{self, FromIterator, FusedIterator, TrustedLen};\n use crate::ops::{self, Deref, DerefMut};\n \n /// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n@@ -1343,7 +1343,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        ResultShunt::process(iter.into_iter(), |i| i.collect())\n+        iter::process_results(iter.into_iter(), |i| i.collect())\n     }\n }\n "}, {"sha": "3615fab791505553843ca616dc8b7e339b08dd7a", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32735d03c5dffe4acf79f500bb2f248469a4e66/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=c32735d03c5dffe4acf79f500bb2f248469a4e66", "patch": "@@ -1203,6 +1203,23 @@ fn test_iterator_sum_result() {\n     assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Ok(10));\n     let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n     assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Err(()));\n+\n+    #[derive(PartialEq, Debug)]\n+    struct S(Result<i32, ()>);\n+\n+    impl Sum<Result<i32, ()>> for S {\n+        fn sum<I: Iterator<Item = Result<i32, ()>>>(mut iter: I) -> Self {\n+            // takes the sum by repeatedly calling `next` on `iter`,\n+            // thus testing that repeated calls to `ResultShunt::try_fold`\n+            // produce the expected results\n+            Self(iter.by_ref().sum())\n+        }\n+    }\n+\n+    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<S>(), S(Ok(10)));\n+    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<S>(), S(Err(())));\n }\n \n #[test]"}]}