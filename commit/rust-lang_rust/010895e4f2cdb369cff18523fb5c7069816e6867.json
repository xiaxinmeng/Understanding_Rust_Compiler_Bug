{"sha": "010895e4f2cdb369cff18523fb5c7069816e6867", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMDg5NWU0ZjJjZGIzNjljZmYxODUyM2ZiNWM3MDY5ODE2ZTY4Njc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:10:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:10:57Z"}, "message": "rollup merge of #23612: dotdash/closure_bloat\n\nFor the rust-call ABI, the last function argument is a tuple that gets\nuntupled for the actual call. For bare functions using this ABI, the\ncode has access to the tuple, so we need to tuple the arguments again.\nBut closures can't actually access the tuple. Their arguments map to the\nelements in the tuple. So what we currently do is to tuple the arguments\nand then immediately untuple them again, which is pretty useless and we\ncan just omit it.", "tree": {"sha": "ffc1871f366a7c1f7c1c53e66dc43d6e405c3f33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffc1871f366a7c1f7c1c53e66dc43d6e405c3f33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/010895e4f2cdb369cff18523fb5c7069816e6867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/010895e4f2cdb369cff18523fb5c7069816e6867", "html_url": "https://github.com/rust-lang/rust/commit/010895e4f2cdb369cff18523fb5c7069816e6867", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/010895e4f2cdb369cff18523fb5c7069816e6867/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c99970783a30c94ac488d7f3bc28127fb1d32650", "url": "https://api.github.com/repos/rust-lang/rust/commits/c99970783a30c94ac488d7f3bc28127fb1d32650", "html_url": "https://github.com/rust-lang/rust/commit/c99970783a30c94ac488d7f3bc28127fb1d32650"}, {"sha": "cfe7a8db06f8e42c08ac026754d384cca595ed3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfe7a8db06f8e42c08ac026754d384cca595ed3e", "html_url": "https://github.com/rust-lang/rust/commit/cfe7a8db06f8e42c08ac026754d384cca595ed3e"}], "stats": {"total": 80, "additions": 8, "deletions": 72}, "files": [{"sha": "e87c4e4af4a7aa9cfee760c31f24db1ce73aa6c6", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 72, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/010895e4f2cdb369cff18523fb5c7069816e6867/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010895e4f2cdb369cff18523fb5c7069816e6867/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=010895e4f2cdb369cff18523fb5c7069816e6867", "patch": "@@ -1591,55 +1591,6 @@ fn copy_args_to_allocas<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-fn copy_closure_args_to_allocas<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                            arg_scope: cleanup::CustomScopeIndex,\n-                                            args: &[ast::Arg],\n-                                            arg_datums: Vec<RvalueDatum<'tcx>>,\n-                                            monomorphized_arg_types: &[Ty<'tcx>])\n-                                            -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"copy_closure_args_to_allocas\");\n-    let arg_scope_id = cleanup::CustomScope(arg_scope);\n-\n-    assert_eq!(arg_datums.len(), 1);\n-\n-    let arg_datum = arg_datums.into_iter().next().unwrap();\n-\n-    // Untuple the rest of the arguments.\n-    let tuple_datum =\n-        unpack_datum!(bcx,\n-                      arg_datum.to_lvalue_datum_in_scope(bcx,\n-                                                         \"argtuple\",\n-                                                         arg_scope_id));\n-    let untupled_arg_types = match monomorphized_arg_types[0].sty {\n-        ty::ty_tup(ref types) => &types[..],\n-        _ => {\n-            bcx.tcx().sess.span_bug(args[0].pat.span,\n-                                    \"first arg to `rust-call` ABI function \\\n-                                     wasn't a tuple?!\")\n-        }\n-    };\n-    for j in 0..args.len() {\n-        let tuple_element_type = untupled_arg_types[j];\n-        let tuple_element_datum =\n-            tuple_datum.get_element(bcx,\n-                                    tuple_element_type,\n-                                    |llval| GEPi(bcx, llval, &[0, j]));\n-        let tuple_element_datum = tuple_element_datum.to_expr_datum();\n-        let tuple_element_datum =\n-            unpack_datum!(bcx,\n-                          tuple_element_datum.to_rvalue_datum(bcx,\n-                                                              \"arg\"));\n-        bcx = _match::store_arg(bcx,\n-                                &*args[j].pat,\n-                                tuple_element_datum,\n-                                arg_scope_id);\n-\n-        debuginfo::create_argument_metadata(bcx, &args[j]);\n-    }\n-\n-    bcx\n-}\n-\n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n@@ -1797,33 +1748,18 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_closure: function lltype: {}\",\n            bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n \n-    let arg_datums = if abi != RustCall {\n-        create_datums_for_fn_args(&fcx,\n-                                  &monomorphized_arg_types[..])\n-    } else {\n-        create_datums_for_fn_args_under_call_abi(\n-            bcx,\n-            arg_scope,\n-            &monomorphized_arg_types[..])\n-    };\n-\n-    bcx = match closure_env {\n-        closure::ClosureEnv::NotClosure => {\n-            copy_args_to_allocas(bcx,\n-                                 arg_scope,\n-                                 &decl.inputs,\n-                                 arg_datums)\n+    let arg_datums = match closure_env {\n+        closure::ClosureEnv::NotClosure if abi == RustCall => {\n+            create_datums_for_fn_args_under_call_abi(bcx, arg_scope, &monomorphized_arg_types[..])\n         }\n-        closure::ClosureEnv::Closure(_) => {\n-            copy_closure_args_to_allocas(\n-                bcx,\n-                arg_scope,\n-                &decl.inputs,\n-                arg_datums,\n-                &monomorphized_arg_types[..])\n+        _ => {\n+            let arg_tys = untuple_arguments_if_necessary(ccx, &monomorphized_arg_types, abi);\n+            create_datums_for_fn_args(&fcx, &arg_tys)\n         }\n     };\n \n+    bcx = copy_args_to_allocas(bcx, arg_scope, &decl.inputs, arg_datums);\n+\n     bcx = closure_env.load(bcx, cleanup::CustomScope(arg_scope));\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with"}]}