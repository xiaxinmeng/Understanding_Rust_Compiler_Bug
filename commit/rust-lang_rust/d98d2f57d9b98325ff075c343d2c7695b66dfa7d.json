{"sha": "d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5OGQyZjU3ZDliOTgzMjVmZjA3NWMzNDNkMmM3Njk1YjY2ZGZhN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-18T20:54:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-18T20:54:36Z"}, "message": "Auto merge of #80707 - oli-obk:stability_hole_const_intrinsics, r=RalfJung\n\nStability oddity with const intrinsics\n\ncc `@RalfJung`\n\nIn https://github.com/rust-lang/rust/pull/80699#discussion_r551495670 `@usbalbin` realized we accepted some intrinsics as `const` without a `#[rustc_const_(un)stable]` attribute. I did some digging, and that example works because intrinsics inherit their stability from their parents... including `#[rustc_const_(un)stable]` attributes. While we may want to fix that (not sure, wasn't there just a MCPed PR that caused this on purpose?), we definitely want tests for it, thus this PR adding tests and some fun tracing statements.", "tree": {"sha": "88e9284491c7a5856c5135c28839bb1146d88372", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88e9284491c7a5856c5135c28839bb1146d88372"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "html_url": "https://github.com/rust-lang/rust/commit/d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73f233b3ad68b54f854c0aea918fc496a35502cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/73f233b3ad68b54f854c0aea918fc496a35502cf", "html_url": "https://github.com/rust-lang/rust/commit/73f233b3ad68b54f854c0aea918fc496a35502cf"}, {"sha": "5bac1c9229331105bab558f7d3be1685a76d110c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bac1c9229331105bab558f7d3be1685a76d110c", "html_url": "https://github.com/rust-lang/rust/commit/5bac1c9229331105bab558f7d3be1685a76d110c"}], "stats": {"total": 148, "additions": 130, "deletions": 18}, "files": [{"sha": "99ffb0edce9e180a360f4f6c3e65d9868ab9d63f", "filename": "compiler/rustc_mir/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "patch": "@@ -72,7 +72,7 @@ impl NonConstOp for FnCallIndirect {\n \n /// A function call where the callee is not marked as `const`.\n #[derive(Debug)]\n-pub struct FnCallNonConst(pub DefId);\n+pub struct FnCallNonConst;\n impl NonConstOp for FnCallNonConst {\n     fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!("}, {"sha": "08d969b27bea5a74cbc50d80857c44617145145b", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "patch": "@@ -789,10 +789,10 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self))]\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n-        trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n         self.super_terminator(terminator, location);\n \n         match &terminator.kind {\n@@ -816,8 +816,9 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n                 // Attempting to call a trait method?\n                 if let Some(trait_id) = tcx.trait_of_item(callee) {\n+                    trace!(\"attempting to call a trait method\");\n                     if !self.tcx.features().const_trait_impl {\n-                        self.check_op(ops::FnCallNonConst(callee));\n+                        self.check_op(ops::FnCallNonConst);\n                         return;\n                     }\n \n@@ -871,25 +872,26 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                     return;\n                 }\n \n+                let is_intrinsic = tcx.fn_sig(callee).abi() == RustIntrinsic;\n+\n                 // HACK: This is to \"unstabilize\" the `transmute` intrinsic\n                 // within const fns. `transmute` is allowed in all other const contexts.\n                 // This won't really scale to more intrinsics or functions. Let's allow const\n                 // transmutes in const fn before we add more hacks to this.\n-                if tcx.fn_sig(callee).abi() == RustIntrinsic\n-                    && tcx.item_name(callee) == sym::transmute\n-                {\n+                if is_intrinsic && tcx.item_name(callee) == sym::transmute {\n                     self.check_op(ops::Transmute);\n                     return;\n                 }\n \n                 if !tcx.is_const_fn_raw(callee) {\n-                    self.check_op(ops::FnCallNonConst(callee));\n+                    self.check_op(ops::FnCallNonConst);\n                     return;\n                 }\n \n                 // If the `const fn` we are trying to call is not const-stable, ensure that we have\n                 // the proper feature gate enabled.\n                 if let Some(gate) = is_unstable_const_fn(tcx, callee) {\n+                    trace!(?gate, \"calling unstable const fn\");\n                     if self.span.allows_unstable(gate) {\n                         return;\n                     }\n@@ -904,12 +906,14 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                     // If this crate is not using stability attributes, or the caller is not claiming to be a\n                     // stable `const fn`, that is all that is required.\n                     if !self.ccx.is_const_stable_const_fn() {\n+                        trace!(\"crate not using stability attributes or caller not stably const\");\n                         return;\n                     }\n \n                     // Otherwise, we are something const-stable calling a const-unstable fn.\n \n                     if super::rustc_allow_const_fn_unstable(tcx, caller, gate) {\n+                        trace!(\"rustc_allow_const_fn_unstable gate active\");\n                         return;\n                     }\n \n@@ -923,10 +927,16 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 let callee_is_unstable_unmarked = tcx.lookup_const_stability(callee).is_none()\n                     && tcx.lookup_stability(callee).map_or(false, |s| s.level.is_unstable());\n                 if callee_is_unstable_unmarked {\n-                    if self.ccx.is_const_stable_const_fn() {\n+                    trace!(\"callee_is_unstable_unmarked\");\n+                    // We do not use `const` modifiers for intrinsic \"functions\", as intrinsics are\n+                    // `extern` funtions, and these have no way to get marked `const`. So instead we\n+                    // use `rustc_const_(un)stable` attributes to mean that the intrinsic is `const`\n+                    if self.ccx.is_const_stable_const_fn() || is_intrinsic {\n                         self.check_op(ops::FnCallUnstable(callee, None));\n+                        return;\n                     }\n                 }\n+                trace!(\"permitting call\");\n             }\n \n             // Forbid all `Drop` terminators unless the place being dropped is a local with no"}, {"sha": "b70cec25dfb5adf8d960a7ccbbd0b0dcc0a9a2fe", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "patch": "@@ -55,6 +55,21 @@ impl InheritDeprecation {\n     }\n }\n \n+/// Whether to inherit const stability flags for nested items. In most cases, we do not want to\n+/// inherit const stability: just because an enclosing `fn` is const-stable does not mean\n+/// all `extern` imports declared in it should be const-stable! However, trait methods\n+/// inherit const stability attributes from their parent and do not have their own.\n+enum InheritConstStability {\n+    Yes,\n+    No,\n+}\n+\n+impl InheritConstStability {\n+    fn yes(&self) -> bool {\n+        matches!(self, InheritConstStability::Yes)\n+    }\n+}\n+\n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -75,6 +90,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         item_sp: Span,\n         kind: AnnotationKind,\n         inherit_deprecation: InheritDeprecation,\n+        inherit_const_stability: InheritConstStability,\n         visit_children: F,\n     ) where\n         F: FnOnce(&mut Self),\n@@ -140,6 +156,8 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             const_stab\n         });\n \n+        // `impl const Trait for Type` items forward their const stability to their\n+        // immediate children.\n         if const_stab.is_none() {\n             debug!(\"annotate: const_stab not found, parent = {:?}\", self.parent_const_stab);\n             if let Some(parent) = self.parent_const_stab {\n@@ -228,7 +246,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         self.recurse_with_stability_attrs(\n             depr.map(|(d, _)| DeprecationEntry::local(d, hir_id)),\n             stab,\n-            const_stab,\n+            if inherit_const_stability.yes() { const_stab } else { None },\n             visit_children,\n         );\n     }\n@@ -325,6 +343,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx Item<'tcx>) {\n         let orig_in_trait_impl = self.in_trait_impl;\n         let mut kind = AnnotationKind::Required;\n+        let mut const_stab_inherit = InheritConstStability::No;\n         match i.kind {\n             // Inherent impls and foreign modules serve only as containers for other items,\n             // they don't have their own stability. They still can be annotated as unstable\n@@ -338,6 +357,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) => {\n                 self.in_trait_impl = true;\n                 kind = AnnotationKind::DeprecationProhibited;\n+                const_stab_inherit = InheritConstStability::Yes;\n             }\n             hir::ItemKind::Struct(ref sd, _) => {\n                 if let Some(ctor_hir_id) = sd.ctor_hir_id() {\n@@ -347,16 +367,23 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n                         i.span,\n                         AnnotationKind::Required,\n                         InheritDeprecation::Yes,\n+                        InheritConstStability::No,\n                         |_| {},\n                     )\n                 }\n             }\n             _ => {}\n         }\n \n-        self.annotate(i.hir_id, &i.attrs, i.span, kind, InheritDeprecation::Yes, |v| {\n-            intravisit::walk_item(v, i)\n-        });\n+        self.annotate(\n+            i.hir_id,\n+            &i.attrs,\n+            i.span,\n+            kind,\n+            InheritDeprecation::Yes,\n+            const_stab_inherit,\n+            |v| intravisit::walk_item(v, i),\n+        );\n         self.in_trait_impl = orig_in_trait_impl;\n     }\n \n@@ -367,6 +394,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             ti.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n+            InheritConstStability::No,\n             |v| {\n                 intravisit::walk_trait_item(v, ti);\n             },\n@@ -376,9 +404,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let kind =\n             if self.in_trait_impl { AnnotationKind::Prohibited } else { AnnotationKind::Required };\n-        self.annotate(ii.hir_id, &ii.attrs, ii.span, kind, InheritDeprecation::Yes, |v| {\n-            intravisit::walk_impl_item(v, ii);\n-        });\n+        self.annotate(\n+            ii.hir_id,\n+            &ii.attrs,\n+            ii.span,\n+            kind,\n+            InheritDeprecation::Yes,\n+            InheritConstStability::No,\n+            |v| {\n+                intravisit::walk_impl_item(v, ii);\n+            },\n+        );\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n@@ -388,6 +424,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             var.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n+            InheritConstStability::No,\n             |v| {\n                 if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n                     v.annotate(\n@@ -396,6 +433,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n                         var.span,\n                         AnnotationKind::Required,\n                         InheritDeprecation::Yes,\n+                        InheritConstStability::No,\n                         |_| {},\n                     );\n                 }\n@@ -412,6 +450,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             s.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n+            InheritConstStability::No,\n             |v| {\n                 intravisit::walk_struct_field(v, s);\n             },\n@@ -425,6 +464,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             i.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n+            InheritConstStability::No,\n             |v| {\n                 intravisit::walk_foreign_item(v, i);\n             },\n@@ -438,6 +478,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             md.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n+            InheritConstStability::No,\n             |_| {},\n         );\n     }\n@@ -451,9 +492,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             _ => AnnotationKind::Prohibited,\n         };\n \n-        self.annotate(p.hir_id, &p.attrs, p.span, kind, InheritDeprecation::No, |v| {\n-            intravisit::walk_generic_param(v, p);\n-        });\n+        self.annotate(\n+            p.hir_id,\n+            &p.attrs,\n+            p.span,\n+            kind,\n+            InheritDeprecation::No,\n+            InheritConstStability::No,\n+            |v| {\n+                intravisit::walk_generic_param(v, p);\n+            },\n+        );\n     }\n }\n \n@@ -618,6 +667,7 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n             krate.item.span,\n             AnnotationKind::Required,\n             InheritDeprecation::Yes,\n+            InheritConstStability::No,\n             |v| intravisit::walk_crate(v, krate),\n         );\n     }"}, {"sha": "7c1a9b82f99b25aeb2739584089602d08195d633", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "patch": "@@ -1842,6 +1842,7 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n #[inline]\n pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n+        #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n         fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n@@ -1926,6 +1927,7 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n #[inline]\n pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n+        #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n "}, {"sha": "810158a295792194523fc5814ee520816b214b4e", "filename": "src/test/ui/consts/intrinsic_without_const_stab.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.rs?ref=d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "patch": "@@ -0,0 +1,17 @@\n+#![feature(intrinsics, staged_api, const_intrinsic_copy)]\n+#![stable(feature = \"core\", since = \"1.6.0\")]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n+#[inline]\n+pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n+    // Const stability attributes are not inherited from parent items.\n+    extern \"rust-intrinsic\" {\n+        fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+    }\n+\n+    unsafe { copy(src, dst, count) }\n+    //~^ ERROR calls in constant functions are limited to constant functions\n+}\n+\n+fn main() {}"}, {"sha": "5a42823a6052aa05726c72b4a1648267a0e300dc", "filename": "src/test/ui/consts/intrinsic_without_const_stab.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.stderr?ref=d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "patch": "@@ -0,0 +1,9 @@\n+error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/intrinsic_without_const_stab.rs:13:14\n+   |\n+LL |     unsafe { copy(src, dst, count) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "bf2c44169d48b8e70fc722e4f121615f0a295811", "filename": "src/test/ui/consts/intrinsic_without_const_stab_fail.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.rs?ref=d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "patch": "@@ -0,0 +1,15 @@\n+#![feature(intrinsics, staged_api, const_intrinsic_copy)]\n+#![stable(feature = \"core\", since = \"1.6.0\")]\n+\n+extern \"rust-intrinsic\" {\n+    fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n+#[inline]\n+pub const unsafe fn stuff<T>(src: *const T, dst: *mut T, count: usize) {\n+    unsafe { copy(src, dst, count) } //~ ERROR calls in constant functions are limited\n+}\n+\n+fn main() {}"}, {"sha": "d4a2989e785e0c6967cc3eca6a974c64028f8b64", "filename": "src/test/ui/consts/intrinsic_without_const_stab_fail.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d98d2f57d9b98325ff075c343d2c7695b66dfa7d/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.stderr?ref=d98d2f57d9b98325ff075c343d2c7695b66dfa7d", "patch": "@@ -0,0 +1,9 @@\n+error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/intrinsic_without_const_stab_fail.rs:12:14\n+   |\n+LL |     unsafe { copy(src, dst, count) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0015`."}]}