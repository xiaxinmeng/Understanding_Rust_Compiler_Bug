{"sha": "4b50fb3745a2c634de45df9e363a5c3abad52b0a", "node_id": "C_kwDOAAsO6NoAKDRiNTBmYjM3NDVhMmM2MzRkZTQ1ZGY5ZTM2M2E1YzNhYmFkNTJiMGE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-09T13:51:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-09T13:51:22Z"}, "message": "Rollup merge of #103919 - nnethercote:unescaping-cleanups, r=matklad\n\nUnescaping cleanups\n\nSome code improvements, and some error message improvements.\n\nBest reviewed one commit at a time.\n\nr? ````@matklad````", "tree": {"sha": "a9fe8d7cdde1892e242eb97818989c507377416d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9fe8d7cdde1892e242eb97818989c507377416d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b50fb3745a2c634de45df9e363a5c3abad52b0a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJja7BaCRBK7hj4Ov3rIwAAvm8IAGZQIDhv0QYpL7jYC23GVMTk\nEMkH379Klc3u3N7vpv4qR5KFdnjwIMOIZITAvUVoSfBNJIdHNUd/yfol7ucuH3g0\nHkOvQwM3xa1ijqvaxnf2H9IaSTb98ykPpAACivqodTpGebQQbmGkmz6gKyGMBmHq\nJ6s3ziaUIllbT4d9zhUPlj6frf2J3+2QHT3cU96iTGU8J6glrqj4MAoFAg7Ydtr0\nScen9qJ7r+3hLkKECUZ70KbBcY0hlycOJs1hc2r8A5bmWqIUCNk9c/puavpLOTpo\n0w87OL2zq4OEI1pu4hsGzoKn0ngZGumzL5rwqT1RcSLcvLtiBsHZkqMBBf+XAEY=\n=Er3E\n-----END PGP SIGNATURE-----\n", "payload": "tree a9fe8d7cdde1892e242eb97818989c507377416d\nparent b457d707e870413ab5e1879094ed16e5a329d891\nparent d6c97a32b4f5e38c0e85010df4438dc7205c44f4\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1668001882 +0530\ncommitter GitHub <noreply@github.com> 1668001882 +0530\n\nRollup merge of #103919 - nnethercote:unescaping-cleanups, r=matklad\n\nUnescaping cleanups\n\nSome code improvements, and some error message improvements.\n\nBest reviewed one commit at a time.\n\nr? ````@matklad````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b50fb3745a2c634de45df9e363a5c3abad52b0a", "html_url": "https://github.com/rust-lang/rust/commit/4b50fb3745a2c634de45df9e363a5c3abad52b0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b50fb3745a2c634de45df9e363a5c3abad52b0a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b457d707e870413ab5e1879094ed16e5a329d891", "url": "https://api.github.com/repos/rust-lang/rust/commits/b457d707e870413ab5e1879094ed16e5a329d891", "html_url": "https://github.com/rust-lang/rust/commit/b457d707e870413ab5e1879094ed16e5a329d891"}, {"sha": "d6c97a32b4f5e38c0e85010df4438dc7205c44f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c97a32b4f5e38c0e85010df4438dc7205c44f4", "html_url": "https://github.com/rust-lang/rust/commit/d6c97a32b4f5e38c0e85010df4438dc7205c44f4"}], "stats": {"total": 443, "additions": 190, "deletions": 253}, "files": [{"sha": "8f342175f7d37133f67b288b672b1eaa9e3bfaec", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -2,12 +2,9 @@\n \n use crate::ast::{self, Lit, LitKind};\n use crate::token::{self, Token};\n-\n-use rustc_lexer::unescape::{unescape_byte, unescape_char};\n-use rustc_lexer::unescape::{unescape_byte_literal, unescape_literal, Mode};\n+use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n-\n use std::ascii;\n \n pub enum LitError {\n@@ -109,13 +106,11 @@ impl LitKind {\n                 let s = symbol.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n                 let mut error = Ok(());\n-                unescape_byte_literal(&s, Mode::ByteStr, &mut |_, unescaped_byte| {\n-                    match unescaped_byte {\n-                        Ok(c) => buf.push(c),\n-                        Err(err) => {\n-                            if err.is_fatal() {\n-                                error = Err(LitError::LexerError);\n-                            }\n+                unescape_literal(&s, Mode::ByteStr, &mut |_, c| match c {\n+                    Ok(c) => buf.push(byte_from_char(c)),\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n                         }\n                     }\n                 });\n@@ -127,13 +122,11 @@ impl LitKind {\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n                     let mut error = Ok(());\n-                    unescape_byte_literal(&s, Mode::RawByteStr, &mut |_, unescaped_byte| {\n-                        match unescaped_byte {\n-                            Ok(c) => buf.push(c),\n-                            Err(err) => {\n-                                if err.is_fatal() {\n-                                    error = Err(LitError::LexerError);\n-                                }\n+                    unescape_literal(&s, Mode::RawByteStr, &mut |_, c| match c {\n+                        Ok(c) => buf.push(byte_from_char(c)),\n+                        Err(err) => {\n+                            if err.is_fatal() {\n+                                error = Err(LitError::LexerError);\n                             }\n                         }\n                     });"}, {"sha": "d4140cb295f32d6977993329036bdd654319115d", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -205,13 +205,13 @@ pub enum RawStrError {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Base {\n     /// Literal starts with \"0b\".\n-    Binary,\n+    Binary = 2,\n     /// Literal starts with \"0o\".\n-    Octal,\n-    /// Literal starts with \"0x\".\n-    Hexadecimal,\n+    Octal = 8,\n     /// Literal doesn't contain a prefix.\n-    Decimal,\n+    Decimal = 10,\n+    /// Literal starts with \"0x\".\n+    Hexadecimal = 16,\n }\n \n /// `rustc` allows files to have a shebang, e.g. \"#!/usr/bin/rustrun\","}, {"sha": "e405013dcabf83047cb34a88c635e6d4d7ec8a28", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 51, "deletions": 79, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -52,10 +52,8 @@ pub enum EscapeError {\n \n     /// Unicode escape code in byte literal.\n     UnicodeEscapeInByte,\n-    /// Non-ascii character in byte literal.\n+    /// Non-ascii character in byte literal, byte string literal, or raw byte string literal.\n     NonAsciiCharInByte,\n-    /// Non-ascii character in byte string literal.\n-    NonAsciiCharInByteString,\n \n     /// After a line ending with '\\', the next line contains whitespace\n     /// characters that are not skipped.\n@@ -78,54 +76,33 @@ impl EscapeError {\n /// Takes a contents of a literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n /// Values are returned through invoking of the provided callback.\n-pub fn unescape_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+pub fn unescape_literal<F>(src: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n     match mode {\n         Mode::Char | Mode::Byte => {\n-            let mut chars = literal_text.chars();\n-            let result = unescape_char_or_byte(&mut chars, mode);\n-            // The Chars iterator moved forward.\n-            callback(0..(literal_text.len() - chars.as_str().len()), result);\n+            let mut chars = src.chars();\n+            let res = unescape_char_or_byte(&mut chars, mode == Mode::Byte);\n+            callback(0..(src.len() - chars.as_str().len()), res);\n         }\n-        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(literal_text, mode, callback),\n-        // NOTE: Raw strings do not perform any explicit character escaping, here we\n-        // only translate CRLF to LF and produce errors on bare CR.\n+        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(src, mode == Mode::ByteStr, callback),\n         Mode::RawStr | Mode::RawByteStr => {\n-            unescape_raw_str_or_raw_byte_str(literal_text, mode, callback)\n+            unescape_raw_str_or_raw_byte_str(src, mode == Mode::RawByteStr, callback)\n         }\n     }\n }\n \n-/// Takes a contents of a byte, byte string or raw byte string (without quotes)\n-/// and produces a sequence of bytes or errors.\n-/// Values are returned through invoking of the provided callback.\n-pub fn unescape_byte_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n-where\n-    F: FnMut(Range<usize>, Result<u8, EscapeError>),\n-{\n-    debug_assert!(mode.is_bytes());\n-    unescape_literal(literal_text, mode, &mut |range, result| {\n-        callback(range, result.map(byte_from_char));\n-    })\n-}\n-\n /// Takes a contents of a char literal (without quotes), and returns an\n-/// unescaped char or an error\n-pub fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+/// unescaped char or an error.\n+pub fn unescape_char(src: &str) -> Result<char, EscapeError> {\n+    unescape_char_or_byte(&mut src.chars(), false)\n }\n \n /// Takes a contents of a byte literal (without quotes), and returns an\n /// unescaped byte or an error.\n-pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Byte)\n-        .map(byte_from_char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+pub fn unescape_byte(src: &str) -> Result<u8, EscapeError> {\n+    unescape_char_or_byte(&mut src.chars(), true).map(byte_from_char)\n }\n \n /// What kind of literal do we parse.\n@@ -147,20 +124,17 @@ impl Mode {\n         }\n     }\n \n-    pub fn is_bytes(self) -> bool {\n+    pub fn is_byte(self) -> bool {\n         match self {\n             Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n             Mode::Char | Mode::Str | Mode::RawStr => false,\n         }\n     }\n }\n \n-fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n     // Previous character was '\\\\', unescape what follows.\n-\n-    let second_char = chars.next().ok_or(EscapeError::LoneSlash)?;\n-\n-    let res = match second_char {\n+    let res = match chars.next().ok_or(EscapeError::LoneSlash)? {\n         '\"' => '\"',\n         'n' => '\\n',\n         'r' => '\\r',\n@@ -181,7 +155,7 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n             let value = hi * 16 + lo;\n \n             // For a non-byte literal verify that it is within ASCII range.\n-            if !mode.is_bytes() && !is_ascii(value) {\n+            if !is_byte && !is_ascii(value) {\n                 return Err(EscapeError::OutOfRangeHexEscape);\n             }\n             let value = value as u8;\n@@ -217,7 +191,7 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n \n                         // Incorrect syntax has higher priority for error reporting\n                         // than unallowed value for a literal.\n-                        if mode.is_bytes() {\n+                        if is_byte {\n                             return Err(EscapeError::UnicodeEscapeInByte);\n                         }\n \n@@ -249,23 +223,22 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n }\n \n #[inline]\n-fn ascii_check(first_char: char, mode: Mode) -> Result<char, EscapeError> {\n-    if mode.is_bytes() && !first_char.is_ascii() {\n+fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n+    if is_byte && !c.is_ascii() {\n         // Byte literal can't be a non-ascii character.\n         Err(EscapeError::NonAsciiCharInByte)\n     } else {\n-        Ok(first_char)\n+        Ok(c)\n     }\n }\n \n-fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n-    debug_assert!(mode == Mode::Char || mode == Mode::Byte);\n-    let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n-    let res = match first_char {\n-        '\\\\' => scan_escape(chars, mode),\n+fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n+    let c = chars.next().ok_or(EscapeError::ZeroChars)?;\n+    let res = match c {\n+        '\\\\' => scan_escape(chars, is_byte),\n         '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n         '\\r' => Err(EscapeError::BareCarriageReturn),\n-        _ => ascii_check(first_char, mode),\n+        _ => ascii_check(c, is_byte),\n     }?;\n     if chars.next().is_some() {\n         return Err(EscapeError::MoreThanOneChar);\n@@ -275,20 +248,20 @@ fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, Esca\n \n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n-fn unescape_str_or_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n+fn unescape_str_or_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    debug_assert!(mode == Mode::Str || mode == Mode::ByteStr);\n-    let initial_len = src.len();\n     let mut chars = src.chars();\n-    while let Some(first_char) = chars.next() {\n-        let start = initial_len - chars.as_str().len() - first_char.len_utf8();\n \n-        let unescaped_char = match first_char {\n+    // The `start` and `end` computation here is complicated because\n+    // `skip_ascii_whitespace` makes us to skip over chars without counting\n+    // them in the range computation.\n+    while let Some(c) = chars.next() {\n+        let start = src.len() - chars.as_str().len() - c.len_utf8();\n+        let res = match c {\n             '\\\\' => {\n-                let second_char = chars.clone().next();\n-                match second_char {\n+                match chars.clone().next() {\n                     Some('\\n') => {\n                         // Rust language specification requires us to skip whitespaces\n                         // if unescaped '\\' character is followed by '\\n'.\n@@ -297,17 +270,17 @@ where\n                         skip_ascii_whitespace(&mut chars, start, callback);\n                         continue;\n                     }\n-                    _ => scan_escape(&mut chars, mode),\n+                    _ => scan_escape(&mut chars, is_byte),\n                 }\n             }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n             '\"' => Err(EscapeError::EscapeOnlyChar),\n             '\\r' => Err(EscapeError::BareCarriageReturn),\n-            _ => ascii_check(first_char, mode),\n+            _ => ascii_check(c, is_byte),\n         };\n-        let end = initial_len - chars.as_str().len();\n-        callback(start..end, unescaped_char);\n+        let end = src.len() - chars.as_str().len();\n+        callback(start..end, res);\n     }\n \n     fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n@@ -340,30 +313,29 @@ where\n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of characters or errors.\n /// NOTE: Raw strings do not perform any explicit character escaping, here we\n-/// only translate CRLF to LF and produce errors on bare CR.\n-fn unescape_raw_str_or_raw_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+/// only produce errors on bare CR.\n+fn unescape_raw_str_or_raw_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    debug_assert!(mode == Mode::RawStr || mode == Mode::RawByteStr);\n-    let initial_len = literal_text.len();\n-\n-    let mut chars = literal_text.chars();\n-    while let Some(curr) = chars.next() {\n-        let start = initial_len - chars.as_str().len() - curr.len_utf8();\n+    let mut chars = src.chars();\n \n-        let result = match curr {\n+    // The `start` and `end` computation here matches the one in\n+    // `unescape_str_or_byte_str` for consistency, even though this function\n+    // doesn't have to worry about skipping any chars.\n+    while let Some(c) = chars.next() {\n+        let start = src.len() - chars.as_str().len() - c.len_utf8();\n+        let res = match c {\n             '\\r' => Err(EscapeError::BareCarriageReturnInRawString),\n-            c if mode.is_bytes() && !c.is_ascii() => Err(EscapeError::NonAsciiCharInByteString),\n-            c => Ok(c),\n+            _ => ascii_check(c, is_byte),\n         };\n-        let end = initial_len - chars.as_str().len();\n-\n-        callback(start..end, result);\n+        let end = src.len() - chars.as_str().len();\n+        callback(start..end, res);\n     }\n }\n \n-fn byte_from_char(c: char) -> u8 {\n+#[inline]\n+pub fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n     debug_assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n     res as u8"}, {"sha": "c7ca8fd16ae479cf7978913e8a0ea961cde2afc1", "filename": "compiler/rustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -3,8 +3,7 @@ use super::*;\n #[test]\n fn test_unescape_char_bad() {\n     fn check(literal_text: &str, expected_error: EscapeError) {\n-        let actual_result = unescape_char(literal_text).map_err(|(_offset, err)| err);\n-        assert_eq!(actual_result, Err(expected_error));\n+        assert_eq!(unescape_char(literal_text), Err(expected_error));\n     }\n \n     check(\"\", EscapeError::ZeroChars);\n@@ -68,8 +67,7 @@ fn test_unescape_char_bad() {\n #[test]\n fn test_unescape_char_good() {\n     fn check(literal_text: &str, expected_char: char) {\n-        let actual_result = unescape_char(literal_text);\n-        assert_eq!(actual_result, Ok(expected_char));\n+        assert_eq!(unescape_char(literal_text), Ok(expected_char));\n     }\n \n     check(\"a\", 'a');\n@@ -149,8 +147,7 @@ fn test_unescape_str_good() {\n #[test]\n fn test_unescape_byte_bad() {\n     fn check(literal_text: &str, expected_error: EscapeError) {\n-        let actual_result = unescape_byte(literal_text).map_err(|(_offset, err)| err);\n-        assert_eq!(actual_result, Err(expected_error));\n+        assert_eq!(unescape_byte(literal_text), Err(expected_error));\n     }\n \n     check(\"\", EscapeError::ZeroChars);\n@@ -219,8 +216,7 @@ fn test_unescape_byte_bad() {\n #[test]\n fn test_unescape_byte_good() {\n     fn check(literal_text: &str, expected_byte: u8) {\n-        let actual_result = unescape_byte(literal_text);\n-        assert_eq!(actual_result, Ok(expected_byte));\n+        assert_eq!(unescape_byte(literal_text), Ok(expected_byte));\n     }\n \n     check(\"a\", b'a');\n@@ -246,10 +242,10 @@ fn test_unescape_byte_good() {\n fn test_unescape_byte_str_good() {\n     fn check(literal_text: &str, expected: &[u8]) {\n         let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n-        unescape_byte_literal(literal_text, Mode::ByteStr, &mut |range, c| {\n+        unescape_literal(literal_text, Mode::ByteStr, &mut |range, c| {\n             if let Ok(b) = &mut buf {\n                 match c {\n-                    Ok(c) => b.push(c),\n+                    Ok(c) => b.push(byte_from_char(c)),\n                     Err(e) => buf = Err((range, e)),\n                 }\n             }\n@@ -280,18 +276,13 @@ fn test_unescape_raw_str() {\n \n #[test]\n fn test_unescape_raw_byte_str() {\n-    fn check(literal: &str, expected: &[(Range<usize>, Result<u8, EscapeError>)]) {\n+    fn check(literal: &str, expected: &[(Range<usize>, Result<char, EscapeError>)]) {\n         let mut unescaped = Vec::with_capacity(literal.len());\n-        unescape_byte_literal(literal, Mode::RawByteStr, &mut |range, res| {\n-            unescaped.push((range, res))\n-        });\n+        unescape_literal(literal, Mode::RawByteStr, &mut |range, res| unescaped.push((range, res)));\n         assert_eq!(unescaped, expected);\n     }\n \n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n-    check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n-    check(\n-        \"\ud83e\udd80a\",\n-        &[(0..4, Err(EscapeError::NonAsciiCharInByteString)), (4..5, Ok(byte_from_char('a')))],\n-    );\n+    check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByte))]);\n+    check(\"\ud83e\udd80a\", &[(0..4, Err(EscapeError::NonAsciiCharInByte)), (4..5, Ok('a'))]);\n }"}, {"sha": "645262bd2f1d37dcf5d714b618457e94e3a3f81b", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -353,112 +353,115 @@ impl<'a> StringReader<'a> {\n     fn cook_lexer_literal(\n         &self,\n         start: BytePos,\n-        suffix_start: BytePos,\n+        end: BytePos,\n         kind: rustc_lexer::LiteralKind,\n     ) -> (token::LitKind, Symbol) {\n-        // prefix means `\"` or `br\"` or `r###\"`, ...\n-        let (lit_kind, mode, prefix_len, postfix_len) = match kind {\n+        match kind {\n             rustc_lexer::LiteralKind::Char { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start, suffix_start),\n+                        self.mk_sp(start, end),\n                         \"unterminated character literal\",\n                         error_code!(E0762),\n                     )\n                 }\n-                (token::Char, Mode::Char, 1, 1) // ' '\n+                self.cook_quoted(token::Char, Mode::Char, start, end, 1, 1) // ' '\n             }\n             rustc_lexer::LiteralKind::Byte { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start + BytePos(1), suffix_start),\n+                        self.mk_sp(start + BytePos(1), end),\n                         \"unterminated byte constant\",\n                         error_code!(E0763),\n                     )\n                 }\n-                (token::Byte, Mode::Byte, 2, 1) // b' '\n+                self.cook_quoted(token::Byte, Mode::Byte, start, end, 2, 1) // b' '\n             }\n             rustc_lexer::LiteralKind::Str { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start, suffix_start),\n+                        self.mk_sp(start, end),\n                         \"unterminated double quote string\",\n                         error_code!(E0765),\n                     )\n                 }\n-                (token::Str, Mode::Str, 1, 1) // \" \"\n+                self.cook_quoted(token::Str, Mode::Str, start, end, 1, 1) // \" \"\n             }\n             rustc_lexer::LiteralKind::ByteStr { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start + BytePos(1), suffix_start),\n+                        self.mk_sp(start + BytePos(1), end),\n                         \"unterminated double quote byte string\",\n                         error_code!(E0766),\n                     )\n                 }\n-                (token::ByteStr, Mode::ByteStr, 2, 1) // b\" \"\n+                self.cook_quoted(token::ByteStr, Mode::ByteStr, start, end, 2, 1) // b\" \"\n             }\n             rustc_lexer::LiteralKind::RawStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n-                    (token::StrRaw(n_hashes), Mode::RawStr, 2 + n, 1 + n) // r##\" \"##\n+                    let kind = token::StrRaw(n_hashes);\n+                    self.cook_quoted(kind, Mode::RawStr, start, end, 2 + n, 1 + n) // r##\" \"##\n                 } else {\n                     self.report_raw_str_error(start, 1);\n                 }\n             }\n             rustc_lexer::LiteralKind::RawByteStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n-                    (token::ByteStrRaw(n_hashes), Mode::RawByteStr, 3 + n, 1 + n) // br##\" \"##\n+                    let kind = token::ByteStrRaw(n_hashes);\n+                    self.cook_quoted(kind, Mode::RawByteStr, start, end, 3 + n, 1 + n) // br##\" \"##\n                 } else {\n                     self.report_raw_str_error(start, 2);\n                 }\n             }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n-                return if empty_int {\n+                if empty_int {\n                     self.sess\n                         .span_diagnostic\n                         .struct_span_err_with_code(\n-                            self.mk_sp(start, suffix_start),\n+                            self.mk_sp(start, end),\n                             \"no valid digits found for number\",\n                             error_code!(E0768),\n                         )\n                         .emit();\n                     (token::Integer, sym::integer(0))\n                 } else {\n-                    self.validate_int_literal(base, start, suffix_start);\n-                    (token::Integer, self.symbol_from_to(start, suffix_start))\n-                };\n+                    if matches!(base, Base::Binary | Base::Octal) {\n+                        let base = base as u32;\n+                        let s = self.str_from_to(start + BytePos(2), end);\n+                        for (idx, c) in s.char_indices() {\n+                            if c != '_' && c.to_digit(base).is_none() {\n+                                self.err_span_(\n+                                    start + BytePos::from_usize(2 + idx),\n+                                    start + BytePos::from_usize(2 + idx + c.len_utf8()),\n+                                    &format!(\"invalid digit for a base {} literal\", base),\n+                                );\n+                            }\n+                        }\n+                    }\n+                    (token::Integer, self.symbol_from_to(start, end))\n+                }\n             }\n             rustc_lexer::LiteralKind::Float { base, empty_exponent } => {\n                 if empty_exponent {\n                     self.err_span_(start, self.pos, \"expected at least one digit in exponent\");\n                 }\n-\n                 match base {\n-                    Base::Hexadecimal => self.err_span_(\n-                        start,\n-                        suffix_start,\n-                        \"hexadecimal float literal is not supported\",\n-                    ),\n+                    Base::Hexadecimal => {\n+                        self.err_span_(start, end, \"hexadecimal float literal is not supported\")\n+                    }\n                     Base::Octal => {\n-                        self.err_span_(start, suffix_start, \"octal float literal is not supported\")\n+                        self.err_span_(start, end, \"octal float literal is not supported\")\n                     }\n                     Base::Binary => {\n-                        self.err_span_(start, suffix_start, \"binary float literal is not supported\")\n+                        self.err_span_(start, end, \"binary float literal is not supported\")\n                     }\n-                    _ => (),\n+                    _ => {}\n                 }\n-\n-                let id = self.symbol_from_to(start, suffix_start);\n-                return (token::Float, id);\n+                (token::Float, self.symbol_from_to(start, end))\n             }\n-        };\n-        let content_start = start + BytePos(prefix_len);\n-        let content_end = suffix_start - BytePos(postfix_len);\n-        let id = self.symbol_from_to(content_start, content_end);\n-        self.validate_literal_escape(mode, content_start, content_end, prefix_len, postfix_len);\n-        (lit_kind, id)\n+        }\n     }\n \n     #[inline]\n@@ -649,20 +652,22 @@ impl<'a> StringReader<'a> {\n         )\n     }\n \n-    fn validate_literal_escape(\n+    fn cook_quoted(\n         &self,\n+        kind: token::LitKind,\n         mode: Mode,\n-        content_start: BytePos,\n-        content_end: BytePos,\n+        start: BytePos,\n+        end: BytePos,\n         prefix_len: u32,\n         postfix_len: u32,\n-    ) {\n+    ) -> (token::LitKind, Symbol) {\n+        let content_start = start + BytePos(prefix_len);\n+        let content_end = end - BytePos(postfix_len);\n         let lit_content = self.str_from_to(content_start, content_end);\n         unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n             // Here we only check for errors. The actual unescaping is done later.\n             if let Err(err) = result {\n-                let span_with_quotes = self\n-                    .mk_sp(content_start - BytePos(prefix_len), content_end + BytePos(postfix_len));\n+                let span_with_quotes = self.mk_sp(start, end);\n                 let (start, end) = (range.start as u32, range.end as u32);\n                 let lo = content_start + BytePos(start);\n                 let hi = lo + BytePos(end - start);\n@@ -678,23 +683,7 @@ impl<'a> StringReader<'a> {\n                 );\n             }\n         });\n-    }\n-\n-    fn validate_int_literal(&self, base: Base, content_start: BytePos, content_end: BytePos) {\n-        let base = match base {\n-            Base::Binary => 2,\n-            Base::Octal => 8,\n-            _ => return,\n-        };\n-        let s = self.str_from_to(content_start + BytePos(2), content_end);\n-        for (idx, c) in s.char_indices() {\n-            let idx = idx as u32;\n-            if c != '_' && c.to_digit(base).is_none() {\n-                let lo = content_start + BytePos(2 + idx);\n-                let hi = content_start + BytePos(2 + idx + c.len_utf8() as u32);\n-                self.err_span_(lo, hi, &format!(\"invalid digit for a base {} literal\", base));\n-            }\n-        }\n+        (kind, Symbol::intern(lit_content))\n     }\n }\n "}, {"sha": "6373f5b4fd6ff36f32f99b14bd80ec9326663dfc", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -108,7 +108,7 @@ pub(crate) fn emit_unescape_error(\n             }\n \n             if !has_help {\n-                let (prefix, msg) = if mode.is_bytes() {\n+                let (prefix, msg) = if mode.is_byte() {\n                     (\"b\", \"if you meant to write a byte string literal, use double quotes\")\n                 } else {\n                     (\"\", \"if you meant to write a `str` literal, use double quotes\")\n@@ -142,7 +142,7 @@ pub(crate) fn emit_unescape_error(\n         EscapeError::EscapeOnlyChar => {\n             let (c, char_span) = last_char();\n \n-            let msg = if mode.is_bytes() {\n+            let msg = if mode.is_byte() {\n                 \"byte constant must be escaped\"\n             } else {\n                 \"character constant must be escaped\"\n@@ -182,11 +182,11 @@ pub(crate) fn emit_unescape_error(\n             let (c, span) = last_char();\n \n             let label =\n-                if mode.is_bytes() { \"unknown byte escape\" } else { \"unknown character escape\" };\n+                if mode.is_byte() { \"unknown byte escape\" } else { \"unknown character escape\" };\n             let ec = escaped_char(c);\n             let mut diag = handler.struct_span_err(span, &format!(\"{}: `{}`\", label, ec));\n             diag.span_label(span, label);\n-            if c == '{' || c == '}' && !mode.is_bytes() {\n+            if c == '{' || c == '}' && !mode.is_byte() {\n                 diag.help(\n                     \"if used in a formatting string, curly braces are escaped with `{{` and `}}`\",\n                 );\n@@ -196,7 +196,7 @@ pub(crate) fn emit_unescape_error(\n                      version control settings\",\n                 );\n             } else {\n-                if !mode.is_bytes() {\n+                if !mode.is_byte() {\n                     diag.span_suggestion(\n                         span_with_quotes,\n                         \"if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\",\n@@ -231,16 +231,23 @@ pub(crate) fn emit_unescape_error(\n                 .emit();\n         }\n         EscapeError::NonAsciiCharInByte => {\n-            assert!(mode.is_bytes());\n             let (c, span) = last_char();\n-            let mut err = handler.struct_span_err(span, \"non-ASCII character in byte constant\");\n+            let desc = match mode {\n+                Mode::Byte => \"byte literal\",\n+                Mode::ByteStr => \"byte string literal\",\n+                Mode::RawByteStr => \"raw byte string literal\",\n+                _ => panic!(\"non-is_byte literal paired with NonAsciiCharInByte\"),\n+            };\n+            let mut err = handler.struct_span_err(span, format!(\"non-ASCII character in {}\", desc));\n             let postfix = if unicode_width::UnicodeWidthChar::width(c).unwrap_or(1) == 0 {\n                 format!(\" but is {:?}\", c)\n             } else {\n                 String::new()\n             };\n-            err.span_label(span, &format!(\"byte constant must be ASCII{}\", postfix));\n-            if (c as u32) <= 0xFF {\n+            err.span_label(span, &format!(\"must be ASCII{}\", postfix));\n+            // Note: the \\\\xHH suggestions are not given for raw byte string\n+            // literals, because they are araw and so cannot use any escapes.\n+            if (c as u32) <= 0xFF && mode != Mode::RawByteStr {\n                 err.span_suggestion(\n                     span,\n                     &format!(\n@@ -250,9 +257,9 @@ pub(crate) fn emit_unescape_error(\n                     format!(\"\\\\x{:X}\", c as u32),\n                     Applicability::MaybeIncorrect,\n                 );\n-            } else if matches!(mode, Mode::Byte) {\n+            } else if mode == Mode::Byte {\n                 err.span_label(span, \"this multibyte character does not fit into a single byte\");\n-            } else if matches!(mode, Mode::ByteStr) {\n+            } else if mode != Mode::RawByteStr {\n                 let mut utf8 = String::new();\n                 utf8.push(c);\n                 err.span_suggestion(\n@@ -270,19 +277,6 @@ pub(crate) fn emit_unescape_error(\n             }\n             err.emit();\n         }\n-        EscapeError::NonAsciiCharInByteString => {\n-            assert!(mode.is_bytes());\n-            let (c, span) = last_char();\n-            let postfix = if unicode_width::UnicodeWidthChar::width(c).unwrap_or(1) == 0 {\n-                format!(\" but is {:?}\", c)\n-            } else {\n-                String::new()\n-            };\n-            handler\n-                .struct_span_err(span, \"raw byte string must be ASCII\")\n-                .span_label(span, &format!(\"must be ASCII{}\", postfix))\n-                .emit();\n-        }\n         EscapeError::OutOfRangeHexEscape => {\n             handler\n                 .struct_span_err(span, \"out of range hex escape\")"}, {"sha": "e14e2fc05ad39235c7589b830caa423d901621e8", "filename": "src/test/ui/attributes/key-value-non-ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -1,4 +1,4 @@\n #![feature(rustc_attrs)]\n \n-#[rustc_dummy = b\"\ufb03.rs\"] //~ ERROR non-ASCII character in byte constant\n+#[rustc_dummy = b\"\ufb03.rs\"] //~ ERROR non-ASCII character in byte string literal\n fn main() {}"}, {"sha": "23d482de6a868e36c6587c130514b8340a989ef7", "filename": "src/test/ui/attributes/key-value-non-ascii.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.stderr?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -1,8 +1,8 @@\n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/key-value-non-ascii.rs:3:19\n    |\n LL | #[rustc_dummy = b\"\ufb03.rs\"]\n-   |                   ^ byte constant must be ASCII\n+   |                   ^ must be ASCII\n    |\n help: if you meant to use the UTF-8 encoding of '\ufb03', use \\xHH escapes\n    |"}, {"sha": "896dc1a1a5fba5821ef54705062b87d5a6214f03", "filename": "src/test/ui/parser/byte-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -7,6 +7,6 @@ pub fn main() {\n     b'\\x0Z';  //~ ERROR invalid character in numeric character escape: `Z`\n     b'\t';  //~ ERROR byte constant must be escaped\n     b''';  //~ ERROR byte constant must be escaped\n-    b'\u00e9';  //~ ERROR non-ASCII character in byte constant\n+    b'\u00e9';  //~ ERROR non-ASCII character in byte literal\n     b'a  //~ ERROR unterminated byte constant [E0763]\n }"}, {"sha": "efa55ae05bd37b6ac506af989d517eaf4837e57a", "filename": "src/test/ui/parser/byte-literals.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -32,11 +32,11 @@ error: byte constant must be escaped: `'`\n LL |     b''';\n    |       ^ help: escape the character: `\\'`\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte literal\n   --> $DIR/byte-literals.rs:10:7\n    |\n LL |     b'\u00e9';\n-   |       ^ byte constant must be ASCII\n+   |       ^ must be ASCII\n    |\n help: if you meant to use the unicode code point for '\u00e9', use a \\xHH escape\n    |"}, {"sha": "30a4f50c4e40b694cb5152627f0a1987c814dd5f", "filename": "src/test/ui/parser/byte-string-literals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -3,7 +3,7 @@ static FOO: &'static [u8] = b\"\\f\";  //~ ERROR unknown byte escape\n pub fn main() {\n     b\"\\f\";  //~ ERROR unknown byte escape\n     b\"\\x0Z\";  //~ ERROR invalid character in numeric character escape: `Z`\n-    b\"\u00e9\";  //~ ERROR non-ASCII character in byte constant\n-    br##\"\u00e9\"##;  //~ ERROR raw byte string must be ASCII\n+    b\"\u00e9\";  //~ ERROR non-ASCII character in byte string literal\n+    br##\"\u00e9\"##;  //~ ERROR non-ASCII character in raw byte string literal\n     b\"a  //~ ERROR unterminated double quote byte string\n }"}, {"sha": "5b96cc3d18abc37332f5ce9648d3dd9f844513b8", "filename": "src/test/ui/parser/byte-string-literals.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -20,18 +20,18 @@ error: invalid character in numeric character escape: `Z`\n LL |     b\"\\x0Z\";\n    |          ^ invalid character in numeric character escape\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/byte-string-literals.rs:6:7\n    |\n LL |     b\"\u00e9\";\n-   |       ^ byte constant must be ASCII\n+   |       ^ must be ASCII\n    |\n help: if you meant to use the unicode code point for '\u00e9', use a \\xHH escape\n    |\n LL |     b\"\\xE9\";\n    |       ~~~~\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/byte-string-literals.rs:7:10\n    |\n LL |     br##\"\u00e9\"##;"}, {"sha": "1b859fee596adf6934dbbdcec51644c2442daf0a", "filename": "src/test/ui/parser/raw/raw-byte-string-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -2,6 +2,6 @@\n \n pub fn main() {\n     br\"a\r\"; //~ ERROR bare CR not allowed in raw string\n-    br\"\u00e9\";  //~ ERROR raw byte string must be ASCII\n+    br\"\u00e9\";  //~ ERROR non-ASCII character in raw byte string literal\n     br##~\"a\"~##;  //~ ERROR only `#` is allowed in raw string delimitation\n }"}, {"sha": "a2f27d1ed70aee56808edb7302ebad643bcf94f9", "filename": "src/test/ui/parser/raw/raw-byte-string-literals.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -4,7 +4,7 @@ error: bare CR not allowed in raw string\n LL |     br\"a\r\";\n    |         ^\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/raw-byte-string-literals.rs:5:8\n    |\n LL |     br\"\u00e9\";"}, {"sha": "df099bb62ad1ec5103a80ae2a08a64b4d114f544", "filename": "src/test/ui/parser/unicode-control-codepoints.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -14,15 +14,15 @@ fn main() {\n     println!(\"{:?}\", r##\"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only \"##);\n     //~^ ERROR unicode codepoint changing visible direction of text present in literal\n     println!(\"{:?}\", b\"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only \");\n-    //~^ ERROR non-ASCII character in byte constant\n-    //~| ERROR non-ASCII character in byte constant\n-    //~| ERROR non-ASCII character in byte constant\n-    //~| ERROR non-ASCII character in byte constant\n+    //~^ ERROR non-ASCII character in byte string literal\n+    //~| ERROR non-ASCII character in byte string literal\n+    //~| ERROR non-ASCII character in byte string literal\n+    //~| ERROR non-ASCII character in byte string literal\n     println!(\"{:?}\", br##\"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only \"##);\n-    //~^ ERROR raw byte string must be ASCII\n-    //~| ERROR raw byte string must be ASCII\n-    //~| ERROR raw byte string must be ASCII\n-    //~| ERROR raw byte string must be ASCII\n+    //~^ ERROR non-ASCII character in raw byte string literal\n+    //~| ERROR non-ASCII character in raw byte string literal\n+    //~| ERROR non-ASCII character in raw byte string literal\n+    //~| ERROR non-ASCII character in raw byte string literal\n     println!(\"{:?}\", '\u202e');\n     //~^ ERROR unicode codepoint changing visible direction of text present in literal\n }"}, {"sha": "fc071a941914210c110a8c13ec43b053d5a60e1d", "filename": "src/test/ui/parser/unicode-control-codepoints.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.stderr?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -14,69 +14,69 @@ LL |     println!(\"{:?}\", b\"us\\u{202B}e\\u{202A}r\");\n    |\n    = help: unicode escape sequences cannot be used as a byte or in a byte string\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/unicode-control-codepoints.rs:16:26\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n-   |                          ^ byte constant must be ASCII but is '\\u{202e}'\n+   |                          ^ must be ASCII but is '\\u{202e}'\n    |\n help: if you meant to use the UTF-8 encoding of '\\u{202e}', use \\xHH escapes\n    |\n LL |     println!(\"{:?}\", b\"/*\\xE2\\x80\\xAE } if isAdmin  begin admins only \");\n    |                          ~~~~~~~~~~~~\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/unicode-control-codepoints.rs:16:30\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n-   |                             ^ byte constant must be ASCII but is '\\u{2066}'\n+   |                             ^ must be ASCII but is '\\u{2066}'\n    |\n help: if you meant to use the UTF-8 encoding of '\\u{2066}', use \\xHH escapes\n    |\n LL |     println!(\"{:?}\", b\"/* } \\xE2\\x81\\xA6if isAdmin  begin admins only \");\n    |                             ~~~~~~~~~~~~\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/unicode-control-codepoints.rs:16:41\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n-   |                                       ^ byte constant must be ASCII but is '\\u{2069}'\n+   |                                       ^ must be ASCII but is '\\u{2069}'\n    |\n help: if you meant to use the UTF-8 encoding of '\\u{2069}', use \\xHH escapes\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin\\xE2\\x81\\xA9  begin admins only \");\n    |                                       ~~~~~~~~~~~~\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/unicode-control-codepoints.rs:16:43\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n-   |                                        ^ byte constant must be ASCII but is '\\u{2066}'\n+   |                                        ^ must be ASCII but is '\\u{2066}'\n    |\n help: if you meant to use the UTF-8 encoding of '\\u{2066}', use \\xHH escapes\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin \\xE2\\x81\\xA6 begin admins only \");\n    |                                        ~~~~~~~~~~~~\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/unicode-control-codepoints.rs:21:29\n    |\n LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);\n    |                             ^ must be ASCII but is '\\u{202e}'\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/unicode-control-codepoints.rs:21:33\n    |\n LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);\n    |                                ^ must be ASCII but is '\\u{2066}'\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/unicode-control-codepoints.rs:21:44\n    |\n LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);\n    |                                          ^ must be ASCII but is '\\u{2069}'\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/unicode-control-codepoints.rs:21:46\n    |\n LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);"}, {"sha": "c4105186244db3bd170af04d24875401755c386a", "filename": "src/test/ui/suggestions/multibyte-escapes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -2,17 +2,17 @@\n \n fn main() {\n     b'\u00b5';\n-    //~^ ERROR: non-ASCII character in byte constant\n+    //~^ ERROR: non-ASCII character in byte literal\n     //~| HELP: if you meant to use the unicode code point for '\u00b5', use a \\xHH escape\n-    //~| NOTE: byte constant must be ASCII\n+    //~| NOTE: must be ASCII\n \n     b'\u5b57';\n-    //~^ ERROR: non-ASCII character in byte constant\n+    //~^ ERROR: non-ASCII character in byte literal\n     //~| NOTE: this multibyte character does not fit into a single byte\n-    //~| NOTE: byte constant must be ASCII\n+    //~| NOTE: must be ASCII\n \n     b\"\u5b57\";\n-    //~^ ERROR: non-ASCII character in byte constant\n+    //~^ ERROR: non-ASCII character in byte string literal\n     //~| HELP: if you meant to use the UTF-8 encoding of '\u5b57', use \\xHH escapes\n-    //~| NOTE: byte constant must be ASCII\n+    //~| NOTE: must be ASCII\n }"}, {"sha": "1e7c43e6538f697f6820fab8f9eaea5297329604", "filename": "src/test/ui/suggestions/multibyte-escapes.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.stderr?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -1,28 +1,28 @@\n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte literal\n   --> $DIR/multibyte-escapes.rs:4:7\n    |\n LL |     b'\u00b5';\n-   |       ^ byte constant must be ASCII\n+   |       ^ must be ASCII\n    |\n help: if you meant to use the unicode code point for '\u00b5', use a \\xHH escape\n    |\n LL |     b'\\xB5';\n    |       ~~~~\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte literal\n   --> $DIR/multibyte-escapes.rs:9:7\n    |\n LL |     b'\u5b57';\n    |       ^^\n    |       |\n-   |       byte constant must be ASCII\n+   |       must be ASCII\n    |       this multibyte character does not fit into a single byte\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/multibyte-escapes.rs:14:7\n    |\n LL |     b\"\u5b57\";\n-   |       ^^ byte constant must be ASCII\n+   |       ^^ must be ASCII\n    |\n help: if you meant to use the UTF-8 encoding of '\u5b57', use \\xHH escapes\n    |"}, {"sha": "1eea2346451dd42038a9edcb5bdfe3cd368bb20c", "filename": "src/tools/rust-analyzer/crates/syntax/src/validation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b50fb3745a2c634de45df9e363a5c3abad52b0a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fvalidation.rs?ref=4b50fb3745a2c634de45df9e363a5c3abad52b0a", "patch": "@@ -5,9 +5,7 @@\n mod block;\n \n use rowan::Direction;\n-use rustc_lexer::unescape::{\n-    self, unescape_byte, unescape_byte_literal, unescape_char, unescape_literal, Mode,\n-};\n+use rustc_lexer::unescape::{self, unescape_byte, unescape_char, unescape_literal, Mode};\n \n use crate::{\n     algo,\n@@ -143,7 +141,7 @@ fn validate_literal(literal: ast::Literal, acc: &mut Vec<SyntaxError>) {\n         ast::LiteralKind::ByteString(s) => {\n             if !s.is_raw() {\n                 if let Some(without_quotes) = unquote(text, 2, '\"') {\n-                    unescape_byte_literal(without_quotes, Mode::ByteStr, &mut |range, char| {\n+                    unescape_literal(without_quotes, Mode::ByteStr, &mut |range, char| {\n                         if let Err(err) = char {\n                             push_err(2, (range.start, err));\n                         }"}]}