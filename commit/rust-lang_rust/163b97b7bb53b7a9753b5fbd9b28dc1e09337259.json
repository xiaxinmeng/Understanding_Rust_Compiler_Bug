{"sha": "163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2M2I5N2I3YmI1M2I3YTk3NTNiNWZiZDliMjhkYzFlMDkzMzcyNTk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-24T00:29:31Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-24T21:52:21Z"}, "message": "librustc: Make C functions unsafe", "tree": {"sha": "9c91b82c62661d4f1e45638a17cdc93d672dd6be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c91b82c62661d4f1e45638a17cdc93d672dd6be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "html_url": "https://github.com/rust-lang/rust/commit/163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e43cff6657b5ba4245480ede5230e3f00aa52185", "url": "https://api.github.com/repos/rust-lang/rust/commits/e43cff6657b5ba4245480ede5230e3f00aa52185", "html_url": "https://github.com/rust-lang/rust/commit/e43cff6657b5ba4245480ede5230e3f00aa52185"}], "stats": {"total": 1198, "additions": 652, "deletions": 546}, "files": [{"sha": "6c7be8a2ae51ea12e7af3827cba0dc4830be5c85", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -280,17 +280,23 @@ extern mod rusti {\n // I get link errors. This is a bug that needs investigated more.\n #[doc(hidden)]\n pub fn atomic_xchng_rel(dst: &mut int, src: int) -> int {\n-    rusti::atomic_xchg_rel(dst, src)\n+    unsafe {\n+        rusti::atomic_xchg_rel(dst, src)\n+    }\n }\n \n #[doc(hidden)]\n pub fn atomic_add_acq(dst: &mut int, src: int) -> int {\n-    rusti::atomic_xadd_acq(dst, src)\n+    unsafe {\n+        rusti::atomic_xadd_acq(dst, src)\n+    }\n }\n \n #[doc(hidden)]\n pub fn atomic_sub_rel(dst: &mut int, src: int) -> int {\n-    rusti::atomic_xsub_rel(dst, src)\n+    unsafe {\n+        rusti::atomic_xsub_rel(dst, src)\n+    }\n }\n \n #[doc(hidden)]"}, {"sha": "ad27729cc9fa6e629f6855971d85f6c395e2dd03", "filename": "src/libcore/private.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -93,8 +93,10 @@ type rust_port_id = uint;\n type GlobalPtr = *libc::uintptr_t;\n \n fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n-    let old = rusti::atomic_cxchg(address, oldval, newval);\n-    old == oldval\n+    unsafe {\n+        let old = rusti::atomic_cxchg(address, oldval, newval);\n+        old == oldval\n+    }\n }\n \n /**"}, {"sha": "350cdeb1c399c0c4ea7309fb9d07d291e2b4acc7", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -201,10 +201,12 @@ impl ReprVisitor {\n \n     #[inline(always)]\n     fn visit_ptr_inner(ptr: *c_void, inner: *TyDesc) -> bool {\n-        let mut u = ReprVisitor(ptr, self.writer);\n-        let v = reflect::MovePtrAdaptor(move u);\n-        visit_tydesc(inner, (move v) as @TyVisitor);\n-        true\n+        unsafe {\n+            let mut u = ReprVisitor(ptr, self.writer);\n+            let v = reflect::MovePtrAdaptor(move u);\n+            visit_tydesc(inner, (move v) as @TyVisitor);\n+            true\n+        }\n     }\n \n     #[inline(always)]\n@@ -558,11 +560,13 @@ impl ReprVisitor : TyVisitor {\n }\n \n pub fn write_repr<T>(writer: @Writer, object: &T) {\n-    let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n-    let tydesc = intrinsic::get_tydesc::<T>();\n-    let mut u = ReprVisitor(ptr, writer);\n-    let v = reflect::MovePtrAdaptor(move u);\n-    visit_tydesc(tydesc, (move v) as @TyVisitor)\n+    unsafe {\n+        let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n+        let tydesc = intrinsic::get_tydesc::<T>();\n+        let mut u = ReprVisitor(ptr, writer);\n+        let v = reflect::MovePtrAdaptor(move u);\n+        visit_tydesc(tydesc, (move v) as @TyVisitor)\n+    }\n }\n \n #[test]"}, {"sha": "a8de34baf9eea4151078f500e179ca895f73c7e7", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 91, "deletions": 57, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -571,23 +571,29 @@ pub fn try<T:Owned>(f: fn~() -> T) -> Result<T,()> {\n pub fn yield() {\n     //! Yield control to the task scheduler\n \n-    let task_ = rt::rust_get_task();\n-    let killed = rt::rust_task_yield(task_);\n-    if killed && !failing() {\n-        fail ~\"killed\";\n+    unsafe {\n+        let task_ = rt::rust_get_task();\n+        let killed = rt::rust_task_yield(task_);\n+        if killed && !failing() {\n+            fail ~\"killed\";\n+        }\n     }\n }\n \n pub fn failing() -> bool {\n     //! True if the running task has failed\n \n-    rt::rust_task_is_unwinding(rt::rust_get_task())\n+    unsafe {\n+        rt::rust_task_is_unwinding(rt::rust_get_task())\n+    }\n }\n \n pub fn get_task() -> Task {\n     //! Get a handle to the running task\n \n-    TaskHandle(rt::get_task_id())\n+    unsafe {\n+        TaskHandle(rt::get_task_id())\n+    }\n }\n \n /**\n@@ -608,7 +614,11 @@ pub fn get_task() -> Task {\n pub unsafe fn unkillable<U>(f: fn() -> U) -> U {\n     struct AllowFailure {\n         t: *rust_task,\n-        drop { rt::rust_task_allow_kill(self.t); }\n+        drop {\n+            unsafe {\n+                rt::rust_task_allow_kill(self.t);\n+            }\n+        }\n     }\n \n     fn AllowFailure(t: *rust_task) -> AllowFailure{\n@@ -617,17 +627,23 @@ pub unsafe fn unkillable<U>(f: fn() -> U) -> U {\n         }\n     }\n \n-    let t = rt::rust_get_task();\n-    let _allow_failure = AllowFailure(t);\n-    rt::rust_task_inhibit_kill(t);\n-    f()\n+    unsafe {\n+        let t = rt::rust_get_task();\n+        let _allow_failure = AllowFailure(t);\n+        rt::rust_task_inhibit_kill(t);\n+        f()\n+    }\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n pub unsafe fn rekillable<U>(f: fn() -> U) -> U {\n     struct DisallowFailure {\n         t: *rust_task,\n-        drop { rt::rust_task_inhibit_kill(self.t); }\n+        drop {\n+            unsafe {\n+                rt::rust_task_inhibit_kill(self.t);\n+            }\n+        }\n     }\n \n     fn DisallowFailure(t: *rust_task) -> DisallowFailure {\n@@ -636,10 +652,12 @@ pub unsafe fn rekillable<U>(f: fn() -> U) -> U {\n         }\n     }\n \n-    let t = rt::rust_get_task();\n-    let _allow_failure = DisallowFailure(t);\n-    rt::rust_task_allow_kill(t);\n-    f()\n+    unsafe {\n+        let t = rt::rust_get_task();\n+        let _allow_failure = DisallowFailure(t);\n+        rt::rust_task_allow_kill(t);\n+        f()\n+    }\n }\n \n /**\n@@ -650,8 +668,10 @@ pub unsafe fn atomically<U>(f: fn() -> U) -> U {\n     struct DeferInterrupts {\n         t: *rust_task,\n         drop {\n-            rt::rust_task_allow_yield(self.t);\n-            rt::rust_task_allow_kill(self.t);\n+            unsafe {\n+                rt::rust_task_allow_yield(self.t);\n+                rt::rust_task_allow_kill(self.t);\n+            }\n         }\n     }\n \n@@ -661,11 +681,13 @@ pub unsafe fn atomically<U>(f: fn() -> U) -> U {\n         }\n     }\n \n-    let t = rt::rust_get_task();\n-    let _interrupts = DeferInterrupts(t);\n-    rt::rust_task_inhibit_kill(t);\n-    rt::rust_task_inhibit_yield(t);\n-    f()\n+    unsafe {\n+        let t = rt::rust_get_task();\n+        let _interrupts = DeferInterrupts(t);\n+        rt::rust_task_inhibit_kill(t);\n+        rt::rust_task_inhibit_yield(t);\n+        f()\n+    }\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -908,18 +930,22 @@ fn test_spawn_sched() {\n     let ch = oldcomm::Chan(&po);\n \n     fn f(i: int, ch: oldcomm::Chan<()>) {\n-        let parent_sched_id = rt::rust_get_sched_id();\n+        unsafe {\n+            let parent_sched_id = rt::rust_get_sched_id();\n \n-        do spawn_sched(SingleThreaded) {\n-            let child_sched_id = rt::rust_get_sched_id();\n-            assert parent_sched_id != child_sched_id;\n-\n-            if (i == 0) {\n-                oldcomm::send(ch, ());\n-            } else {\n-                f(i - 1, ch);\n-            }\n-        };\n+            do spawn_sched(SingleThreaded) {\n+                unsafe {\n+                    let child_sched_id = rt::rust_get_sched_id();\n+                    assert parent_sched_id != child_sched_id;\n+\n+                    if (i == 0) {\n+                        oldcomm::send(ch, ());\n+                    } else {\n+                        f(i - 1, ch);\n+                    }\n+                }\n+            };\n+        }\n \n     }\n     f(10, ch);\n@@ -932,13 +958,17 @@ fn test_spawn_sched_childs_on_same_sched() {\n     let ch = oldcomm::Chan(&po);\n \n     do spawn_sched(SingleThreaded) {\n-        let parent_sched_id = rt::rust_get_sched_id();\n-        do spawn {\n-            let child_sched_id = rt::rust_get_sched_id();\n-            // This should be on the same scheduler\n-            assert parent_sched_id == child_sched_id;\n-            oldcomm::send(ch, ());\n-        };\n+        unsafe {\n+            let parent_sched_id = rt::rust_get_sched_id();\n+            do spawn {\n+                unsafe {\n+                    let child_sched_id = rt::rust_get_sched_id();\n+                    // This should be on the same scheduler\n+                    assert parent_sched_id == child_sched_id;\n+                    oldcomm::send(ch, ());\n+                }\n+            };\n+        }\n     };\n \n     oldcomm::recv(po);\n@@ -1185,10 +1215,12 @@ fn test_sched_thread_per_core() {\n     let (port, chan) = pipes::stream();\n \n     do spawn_sched(ThreadPerCore) |move chan| {\n-        let cores = rt::rust_num_threads();\n-        let reported_threads = rt::rust_sched_threads();\n-        assert(cores as uint == reported_threads as uint);\n-        chan.send(());\n+        unsafe {\n+            let cores = rt::rust_num_threads();\n+            let reported_threads = rt::rust_sched_threads();\n+            assert(cores as uint == reported_threads as uint);\n+            chan.send(());\n+        }\n     }\n \n     port.recv();\n@@ -1199,22 +1231,24 @@ fn test_spawn_thread_on_demand() {\n     let (port, chan) = pipes::stream();\n \n     do spawn_sched(ManualThreads(2)) |move chan| {\n-        let max_threads = rt::rust_sched_threads();\n-        assert(max_threads as int == 2);\n-        let running_threads = rt::rust_sched_current_nonlazy_threads();\n-        assert(running_threads as int == 1);\n+        unsafe {\n+            let max_threads = rt::rust_sched_threads();\n+            assert(max_threads as int == 2);\n+            let running_threads = rt::rust_sched_current_nonlazy_threads();\n+            assert(running_threads as int == 1);\n \n-        let (port2, chan2) = pipes::stream();\n+            let (port2, chan2) = pipes::stream();\n \n-        do spawn() |move chan2| {\n-            chan2.send(());\n-        }\n+            do spawn() |move chan2| {\n+                chan2.send(());\n+            }\n \n-        let running_threads2 = rt::rust_sched_current_nonlazy_threads();\n-        assert(running_threads2 as int == 2);\n+            let running_threads2 = rt::rust_sched_current_nonlazy_threads();\n+            assert(running_threads2 as int == 2);\n \n-        port2.recv();\n-        chan.send(());\n+            port2.recv();\n+            chan.send(());\n+        }\n     }\n \n     port.recv();"}, {"sha": "15f6bd413e446f808fd02c9e8a036774ab638c65", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 139, "deletions": 127, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -308,25 +308,28 @@ struct TCB {\n     notifier:      Option<AutoNotify>,\n     // Runs on task exit.\n     drop {\n-        // If we are failing, the whole taskgroup needs to die.\n-        if rt::rust_task_is_unwinding(self.me) {\n-            self.notifier.iter(|x| { x.failed = true; });\n-            // Take everybody down with us.\n-            do access_group(&self.tasks) |tg| {\n-                kill_taskgroup(tg, self.me, self.is_main);\n-            }\n-        } else {\n-            // Remove ourselves from the group(s).\n-            do access_group(&self.tasks) |tg| {\n-                leave_taskgroup(tg, self.me, true);\n+        unsafe {\n+            // If we are failing, the whole taskgroup needs to die.\n+            if rt::rust_task_is_unwinding(self.me) {\n+                self.notifier.iter(|x| { x.failed = true; });\n+                // Take everybody down with us.\n+                do access_group(&self.tasks) |tg| {\n+                    kill_taskgroup(tg, self.me, self.is_main);\n+                }\n+            } else {\n+                // Remove ourselves from the group(s).\n+                do access_group(&self.tasks) |tg| {\n+                    leave_taskgroup(tg, self.me, true);\n+                }\n             }\n+            // It doesn't matter whether this happens before or after dealing\n+            // with our own taskgroup, so long as both happen before we die.\n+            // We remove ourself from every ancestor we can, so no cleanup; no\n+            // break.\n+            for each_ancestor(&mut self.ancestors, None) |ancestor_group| {\n+                leave_taskgroup(ancestor_group, self.me, false);\n+            };\n         }\n-        // It doesn't matter whether this happens before or after dealing with\n-        // our own taskgroup, so long as both happen before we die. We need to\n-        // remove ourself from every ancestor we can, so no cleanup; no break.\n-        for each_ancestor(&mut self.ancestors, None) |ancestor_group| {\n-            leave_taskgroup(ancestor_group, self.me, false);\n-        };\n     }\n }\n \n@@ -391,38 +394,41 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n-    // NB: We could do the killing iteration outside of the group arc, by\n-    // having \"let mut newstate\" here, swapping inside, and iterating after.\n-    // But that would let other exiting tasks fall-through and exit while we\n-    // were trying to kill them, causing potential use-after-free. A task's\n-    // presence in the arc guarantees it's alive only while we hold the lock,\n-    // so if we're failing, all concurrently exiting tasks must wait for us.\n-    // To do it differently, we'd have to use the runtime's task refcounting,\n-    // but that could leave task structs around long after their task exited.\n-    let newstate = util::replace(state, None);\n-    // Might already be None, if Somebody is failing simultaneously.\n-    // That's ok; only one task needs to do the dirty work. (Might also\n-    // see 'None' if Somebody already failed and we got a kill signal.)\n-    if newstate.is_some() {\n-        let group = option::unwrap(move newstate);\n-        for taskset_each(&group.members) |sibling| {\n-            // Skip self - killing ourself won't do much good.\n-            if sibling != me {\n-                rt::rust_task_kill_other(sibling);\n+    unsafe {\n+        // NB: We could do the killing iteration outside of the group arc, by\n+        // having \"let mut newstate\" here, swapping inside, and iterating\n+        // after. But that would let other exiting tasks fall-through and exit\n+        // while we were trying to kill them, causing potential\n+        // use-after-free. A task's presence in the arc guarantees it's alive\n+        // only while we hold the lock, so if we're failing, all concurrently\n+        // exiting tasks must wait for us. To do it differently, we'd have to\n+        // use the runtime's task refcounting, but that could leave task\n+        // structs around long after their task exited.\n+        let newstate = util::replace(state, None);\n+        // Might already be None, if Somebody is failing simultaneously.\n+        // That's ok; only one task needs to do the dirty work. (Might also\n+        // see 'None' if Somebody already failed and we got a kill signal.)\n+        if newstate.is_some() {\n+            let group = option::unwrap(move newstate);\n+            for taskset_each(&group.members) |sibling| {\n+                // Skip self - killing ourself won't do much good.\n+                if sibling != me {\n+                    rt::rust_task_kill_other(sibling);\n+                }\n             }\n+            for taskset_each(&group.descendants) |child| {\n+                assert child != me;\n+                rt::rust_task_kill_other(child);\n+            }\n+            // Only one task should ever do this.\n+            if is_main {\n+                rt::rust_task_kill_all(me);\n+            }\n+            // Do NOT restore state to Some(..)! It stays None to indicate\n+            // that the whole taskgroup is failing, to forbid new spawns.\n         }\n-        for taskset_each(&group.descendants) |child| {\n-            assert child != me;\n-            rt::rust_task_kill_other(child);\n-        }\n-        // Only one task should ever do this.\n-        if is_main {\n-            rt::rust_task_kill_all(me);\n-        }\n-        // Do NOT restore state to Some(..)! It stays None to indicate\n-        // that the whole taskgroup is failing, to forbid new spawns.\n+        // (note: multiple tasks may reach this point)\n     }\n-    // (note: multiple tasks may reach this point)\n }\n \n // FIXME (#2912): Work around core-vs-coretest function duplication. Can't use\n@@ -434,68 +440,72 @@ macro_rules! taskgroup_key (\n \n fn gen_child_taskgroup(linked: bool, supervised: bool)\n     -> (TaskGroupArc, AncestorList, bool) {\n-    let spawner = rt::rust_get_task();\n-    /*######################################################################*\n-     * Step 1. Get spawner's taskgroup info.\n-     *######################################################################*/\n-    let spawner_group = match unsafe { local_get(spawner,\n-                                                 taskgroup_key!()) } {\n-        None => {\n-            // Main task, doing first spawn ever. Lazily initialise here.\n-            let mut members = new_taskset();\n-            taskset_insert(&mut members, spawner);\n-            let tasks =\n-                private::exclusive(Some({ mut members:     move members,\n-                                         mut descendants: new_taskset() }));\n-            // Main task/group has no ancestors, no notifier, etc.\n-            let group =\n-                @TCB(spawner, move tasks, AncestorList(None), true, None);\n-            unsafe {\n+    unsafe {\n+        let spawner = rt::rust_get_task();\n+        /*##################################################################*\n+         * Step 1. Get spawner's taskgroup info.\n+         *##################################################################*/\n+        let spawner_group = match local_get(spawner, taskgroup_key!()) {\n+            None => {\n+                // Main task, doing first spawn ever. Lazily initialise here.\n+                let mut members = new_taskset();\n+                taskset_insert(&mut members, spawner);\n+                let tasks =\n+                    private::exclusive(Some({\n+                        mut members:     move members,\n+                        mut descendants: new_taskset()\n+                    }));\n+                // Main task/group has no ancestors, no notifier, etc.\n+                let group =\n+                    @TCB(spawner, move tasks, AncestorList(None), true, None);\n                 local_set(spawner, taskgroup_key!(), group);\n+                group\n             }\n-            group\n-        }\n-        Some(group) => group\n-    };\n-    /*######################################################################*\n-     * Step 2. Process spawn options for child.\n-     *######################################################################*/\n-    return if linked {\n-        // Child is in the same group as spawner.\n-        let g = spawner_group.tasks.clone();\n-        // Child's ancestors are spawner's ancestors.\n-        let a = share_ancestors(&mut spawner_group.ancestors);\n-        // Propagate main-ness.\n-        (move g, move a, spawner_group.is_main)\n-    } else {\n-        // Child is in a separate group from spawner.\n-        let g = private::exclusive(Some({ mut members:     new_taskset(),\n-                                         mut descendants: new_taskset() }));\n-        let a = if supervised {\n-            // Child's ancestors start with the spawner.\n-            let old_ancestors = share_ancestors(&mut spawner_group.ancestors);\n-            // FIXME(#3068) - The generation counter is only used for a debug\n-            // assertion, but initialising it requires locking a mutex. Hence\n-            // it should be enabled only in debug builds.\n-            let new_generation =\n-                match *old_ancestors {\n-                    Some(ref arc) => {\n-                        access_ancestors(arc, |a| a.generation+1)\n-                    }\n-                    None      => 0 // the actual value doesn't really matter.\n-                };\n-            assert new_generation < uint::max_value;\n-            // Build a new node in the ancestor list.\n-            AncestorList(Some(private::exclusive(\n-                { generation:       new_generation,\n-                  mut parent_group: Some(spawner_group.tasks.clone()),\n-                  mut ancestors:    move old_ancestors })))\n+            Some(group) => group\n+        };\n+        /*##################################################################*\n+         * Step 2. Process spawn options for child.\n+         *##################################################################*/\n+        return if linked {\n+            // Child is in the same group as spawner.\n+            let g = spawner_group.tasks.clone();\n+            // Child's ancestors are spawner's ancestors.\n+            let a = share_ancestors(&mut spawner_group.ancestors);\n+            // Propagate main-ness.\n+            (move g, move a, spawner_group.is_main)\n         } else {\n-            // Child has no ancestors.\n-            AncestorList(None)\n+            // Child is in a separate group from spawner.\n+            let g = private::exclusive(Some({\n+                mut members:     new_taskset(),\n+                mut descendants: new_taskset()\n+            }));\n+            let a = if supervised {\n+                // Child's ancestors start with the spawner.\n+                let old_ancestors =\n+                    share_ancestors(&mut spawner_group.ancestors);\n+                // FIXME(#3068) - The generation counter is only used for a\n+                // debug assertion, but initialising it requires locking a\n+                // mutex. Hence it should be enabled only in debug builds.\n+                let new_generation =\n+                    match *old_ancestors {\n+                        Some(ref arc) => {\n+                            access_ancestors(arc, |a| a.generation+1)\n+                        }\n+                        None => 0 // the actual value doesn't really matter.\n+                    };\n+                assert new_generation < uint::max_value;\n+                // Build a new node in the ancestor list.\n+                AncestorList(Some(private::exclusive(\n+                    { generation:       new_generation,\n+                      mut parent_group: Some(spawner_group.tasks.clone()),\n+                      mut ancestors:    move old_ancestors })))\n+            } else {\n+                // Child has no ancestors.\n+                AncestorList(None)\n+            };\n+            (move g, move a, false)\n         };\n-        (move g, move a, false)\n-    };\n+    }\n \n     fn share_ancestors(ancestors: &mut AncestorList) -> AncestorList {\n         // Appease the borrow-checker. Really this wants to be written as:\n@@ -632,31 +642,33 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n     }\n \n     fn new_task_in_new_sched(opts: SchedOpts) -> *rust_task {\n-        if opts.foreign_stack_size != None {\n-            fail ~\"foreign_stack_size scheduler option unimplemented\";\n-        }\n-\n-        let num_threads = match opts.mode {\n-          SingleThreaded => 1u,\n-          ThreadPerCore => rt::rust_num_threads(),\n-          ThreadPerTask => {\n-            fail ~\"ThreadPerTask scheduling mode unimplemented\"\n-          }\n-          ManualThreads(threads) => {\n-            if threads == 0u {\n-                fail ~\"can not create a scheduler with no threads\";\n+        unsafe {\n+            if opts.foreign_stack_size != None {\n+                fail ~\"foreign_stack_size scheduler option unimplemented\";\n             }\n-            threads\n-          }\n-          PlatformThread => 0u /* Won't be used */\n-        };\n \n-        let sched_id = if opts.mode != PlatformThread {\n-            rt::rust_new_sched(num_threads)\n-        } else {\n-            rt::rust_osmain_sched_id()\n-        };\n-        rt::rust_new_task_in_sched(sched_id)\n+            let num_threads = match opts.mode {\n+              SingleThreaded => 1u,\n+              ThreadPerCore => rt::rust_num_threads(),\n+              ThreadPerTask => {\n+                fail ~\"ThreadPerTask scheduling mode unimplemented\"\n+              }\n+              ManualThreads(threads) => {\n+                if threads == 0u {\n+                    fail ~\"can not create a scheduler with no threads\";\n+                }\n+                threads\n+              }\n+              PlatformThread => 0u /* Won't be used */\n+            };\n+\n+            let sched_id = if opts.mode != PlatformThread {\n+                rt::rust_new_sched(num_threads)\n+            } else {\n+                rt::rust_osmain_sched_id()\n+            };\n+            rt::rust_new_task_in_sched(sched_id)\n+        }\n     }\n }\n "}, {"sha": "6657e6fcf0fee4fb6682a0ff2bf1f8d9c3b567c9", "filename": "src/librustc/front/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -19,7 +19,9 @@ mod intrinsic {\n     // FIXME (#3727): remove this when the interface has settled and the\n     // version in sys is no longer present.\n     pub fn get_tydesc<T>() -> *TyDesc {\n-        rusti::get_tydesc::<T>() as *TyDesc\n+        unsafe {\n+            rusti::get_tydesc::<T>() as *TyDesc\n+        }\n     }\n \n     pub enum TyDesc = {"}, {"sha": "68198ae3f3fc9266d155e9a814aab3b5defb3d6e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -56,6 +56,7 @@ use syntax::ast::{type_value_ns, ty_param_bound, unnamed_field};\n use syntax::ast::{variant, view_item, view_item_export, view_item_import};\n use syntax::ast::{view_item_use, view_path_glob, view_path_list};\n use syntax::ast::{view_path_simple, visibility, anonymous, named, not};\n+use syntax::ast::{unsafe_fn};\n use syntax::ast_util::{def_id_of_def, dummy_sp, local_def};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ast_util::{Privacy, Public, Private, visibility_to_privacy};\n@@ -1643,8 +1644,8 @@ impl Resolver {\n                            foreign_item.span);\n \n         match /*bad*/copy foreign_item.node {\n-            foreign_item_fn(_, purity, type_parameters) => {\n-                let def = def_fn(local_def(foreign_item.id), purity);\n+            foreign_item_fn(_, _, type_parameters) => {\n+                let def = def_fn(local_def(foreign_item.id), unsafe_fn);\n                 (*name_bindings).define_value(Public, def, foreign_item.span);\n \n                 do self.with_type_parameter_rib"}, {"sha": "c0c990763fbc506754a8c79d7dbb036ea54ddbf6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -3342,7 +3342,7 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n       }\n     };\n     let fty = ty::mk_fn(tcx, FnTyBase {\n-        meta: FnMeta {purity: ast::impure_fn,\n+        meta: FnMeta {purity: ast::unsafe_fn,\n                       proto: ast::ProtoBare,\n                       onceness: ast::Many,\n                       region: ty::re_static,"}, {"sha": "ba34846ca97ce1bff0e639e9b1e88239a7dbdc39", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -889,9 +889,8 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n fn ty_of_foreign_item(ccx: @crate_ctxt, it: @ast::foreign_item)\n     -> ty::ty_param_bounds_and_ty {\n     match /*bad*/copy it.node {\n-      ast::foreign_item_fn(fn_decl, purity, params) => {\n-        return ty_of_foreign_fn_decl(ccx, fn_decl, purity, params,\n-                                     local_def(it.id));\n+      ast::foreign_item_fn(fn_decl, _, params) => {\n+        return ty_of_foreign_fn_decl(ccx, fn_decl, params, local_def(it.id));\n       }\n       ast::foreign_item_const(t) => {\n         let rb = in_binding_rscope(empty_rscope);\n@@ -962,7 +961,6 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n \n fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n                          decl: ast::fn_decl,\n-                         purity: ast::purity,\n                          +ty_params: ~[ast::ty_param],\n                          def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let bounds = ty_param_bounds(ccx, ty_params);\n@@ -971,7 +969,7 @@ fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n     let t_fn = ty::mk_fn(ccx.tcx, FnTyBase {\n-        meta: FnMeta {purity: purity,\n+        meta: FnMeta {purity: ast::unsafe_fn,\n                       onceness: ast::Many,\n                       proto: ast::ProtoBare,\n                       bounds: @~[],"}, {"sha": "7ac11ecc5cc500b8c123340532d4849614d86284", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -254,9 +254,13 @@ impl &Arena {\n     // The external interface\n     #[inline(always)]\n     fn alloc<T>(op: fn() -> T) -> &self/T {\n-        if !rusti::needs_drop::<T>() {\n-            self.alloc_pod(op)\n-        } else { self.alloc_nonpod(op) }\n+        unsafe {\n+            if !rusti::needs_drop::<T>() {\n+                self.alloc_pod(op)\n+            } else {\n+                self.alloc_nonpod(op)\n+            }\n+        }\n     }\n }\n "}, {"sha": "b016ab5109152006adcf6d5068f75f937247b355", "filename": "src/test/auxiliary/cci_intrinsic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -31,5 +31,7 @@ extern mod rusti {\n \n #[inline(always)]\n fn atomic_xchg(dst: &mut int, src: int) -> int {\n-    rusti::atomic_xchg(dst, src)\n+    unsafe {\n+        rusti::atomic_xchg(dst, src)\n+    }\n }"}, {"sha": "9fda4b133b8c5517496c7993e39a1c3fbcf2c17b", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -21,8 +21,10 @@ extern mod rustrt {\n }\n \n fn fact(n: uint) -> uint {\n-    debug!(\"n = %?\", n);\n-    rustrt::rust_dbg_call(cb, n)\n+    unsafe {\n+        debug!(\"n = %?\", n);\n+        rustrt::rust_dbg_call(cb, n)\n+    }\n }\n \n extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {"}, {"sha": "af321b9959f2b1b4a495d073d037564c6f9d9545", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -30,7 +30,9 @@ pub enum port<T: Owned> {\n \n /// Constructs a port\n pub fn port<T: Owned>() -> port<T> {\n-    port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n+    unsafe {\n+        port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n+    }\n }\n \n struct port_ptr<T:Owned> {\n@@ -75,21 +77,23 @@ pub fn recv<T: Owned>(p: port<T>) -> T { recv_((**p).po) }\n \n /// Receive on a raw port pointer\n pub fn recv_<T: Owned>(p: *rust_port) -> T {\n-    let yield = 0;\n-    let yieldp = ptr::addr_of(&yield);\n-    let mut res;\n-    res = rusti::init::<T>();\n-    rustrt::port_recv(ptr::addr_of(&res) as *uint, p, yieldp);\n-\n-    if yield != 0 {\n-        // Data isn't available yet, so res has not been initialized.\n-        task::yield();\n-    } else {\n-        // In the absense of compiler-generated preemption points\n-        // this is a good place to yield\n-        task::yield();\n+    unsafe {\n+        let yield = 0;\n+        let yieldp = ptr::addr_of(&yield);\n+        let mut res;\n+        res = rusti::init::<T>();\n+        rustrt::port_recv(ptr::addr_of(&res) as *uint, p, yieldp);\n+\n+        if yield != 0 {\n+            // Data isn't available yet, so res has not been initialized.\n+            task::yield();\n+        } else {\n+            // In the absense of compiler-generated preemption points\n+            // this is a good place to yield\n+            task::yield();\n+        }\n+        move res\n     }\n-    move res\n }\n \n "}, {"sha": "9904700948d819e9a79850f92530e2fdcba8e458", "filename": "src/test/run-fail/extern-fail.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-fail.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -27,8 +27,10 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    task::yield();\n-    rustrt::rust_dbg_call(cb, n)\n+    unsafe {\n+        task::yield();\n+        rustrt::rust_dbg_call(cb, n)\n+    }\n }\n \n fn main() {"}, {"sha": "fde7a2da2e9b85b1d3ae0c0785362f8b82aaad0d", "filename": "src/test/run-fail/morestack2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack2.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -26,8 +26,10 @@ fn getbig_call_c_and_fail(i: int) {\n     if i != 0 {\n         getbig_call_c_and_fail(i - 1);\n     } else {\n-        rustrt::last_os_error();\n-        fail;\n+        unsafe {\n+            rustrt::last_os_error();\n+            fail;\n+        }\n     }\n }\n "}, {"sha": "fc624bdd031ae265d428f294ff5e43d907a3a420", "filename": "src/test/run-pass/anon-extern-mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -11,9 +11,11 @@\n #[abi = \"cdecl\"]\n #[link_name = \"rustrt\"]\n extern {\n-  fn last_os_error() -> ~str;\n+    fn last_os_error() -> ~str;\n }\n \n fn main() {\n-  last_os_error();\n+    unsafe {\n+        let _ = last_os_error();\n+    }\n }"}, {"sha": "b54335599a4aeb7ac94a41dad0bc785c7b64ba67", "filename": "src/test/run-pass/c-stack-as-value.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fc-stack-as-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fc-stack-as-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-as-value.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -15,5 +15,7 @@ extern mod rustrt {\n }\n \n fn main() {\n-    let _foo = rustrt::get_task_id;\n+    unsafe {\n+        let _foo = rustrt::get_task_id;\n+    }\n }"}, {"sha": "a0377a513544ab5254e7153b7e5cc70d37a28a50", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -19,15 +19,17 @@ extern mod libc {\n }\n \n fn atol(s: ~str) -> int {\n-    return str::as_buf(s, { |x, _len| libc::atol(x) });\n+    return str::as_buf(s, { |x, _len| unsafe { libc::atol(x) } });\n }\n \n fn atoll(s: ~str) -> i64 {\n-    return str::as_buf(s, { |x, _len| libc::atoll(x) });\n+    return str::as_buf(s, { |x, _len| unsafe { libc::atoll(x) } });\n }\n \n fn main() {\n-    assert atol(~\"1024\") * 10 == atol(~\"10240\");\n-    assert (atoll(~\"11111111111111111\") * 10i64)\n-        == atoll(~\"111111111111111110\");\n+    unsafe {\n+        assert atol(~\"1024\") * 10 == atol(~\"10240\");\n+        assert (atoll(~\"11111111111111111\") * 10i64)\n+            == atoll(~\"111111111111111110\");\n+    }\n }"}, {"sha": "18febc51b3d048d39ec1181eb8bffad7d33765de", "filename": "src/test/run-pass/extern-call-deep.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -23,12 +23,14 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    debug!(\"n = %?\", n);\n-    rustrt::rust_dbg_call(cb, n)\n+    unsafe {\n+        debug!(\"n = %?\", n);\n+        rustrt::rust_dbg_call(cb, n)\n+    }\n }\n \n fn main() {\n     let result = count(1000u);\n     debug!(\"result = %?\", result);\n     assert result == 1000u;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "a0c1d586018cba4262345af4a7228b8f30d7eb64", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -23,8 +23,10 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    debug!(\"n = %?\", n);\n-    rustrt::rust_dbg_call(cb, n)\n+    unsafe {\n+        debug!(\"n = %?\", n);\n+        rustrt::rust_dbg_call(cb, n)\n+    }\n }\n \n fn main() {\n@@ -35,4 +37,4 @@ fn main() {\n         debug!(\"result = %?\", result);\n         assert result == 1000u;\n     };\n-}\n\\ No newline at end of file\n+}"}, {"sha": "407b0d5b028fe4ef58c6bc23a9f610760e9d49a5", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -27,8 +27,10 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    debug!(\"n = %?\", n);\n-    rustrt::rust_dbg_call(cb, n)\n+    unsafe {\n+        debug!(\"n = %?\", n);\n+        rustrt::rust_dbg_call(cb, n)\n+    }\n }\n \n fn main() {\n@@ -39,4 +41,4 @@ fn main() {\n         debug!(\"result = %?\", result);\n         assert result == 2048u;\n     };\n-}\n\\ No newline at end of file\n+}"}, {"sha": "dec8416f2b4cc67975791306cfdd8b9275da80f3", "filename": "src/test/run-pass/extern-call.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -23,12 +23,14 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn fact(n: uint) -> uint {\n-    debug!(\"n = %?\", n);\n-    rustrt::rust_dbg_call(cb, n)\n+    unsafe {\n+        debug!(\"n = %?\", n);\n+        rustrt::rust_dbg_call(cb, n)\n+    }\n }\n \n fn main() {\n     let result = fact(10u);\n     debug!(\"result = %?\", result);\n     assert result == 3628800u;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3ce4aa741ca152edf762fb08ae7e9e6aa22faff7", "filename": "src/test/run-pass/extern-crosscrate.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -14,8 +14,10 @@\n extern mod externcallback(vers = \"0.1\");\n \n fn fact(n: uint) -> uint {\n-    debug!(\"n = %?\", n);\n-    externcallback::rustrt::rust_dbg_call(externcallback::cb, n)\n+    unsafe {\n+        debug!(\"n = %?\", n);\n+        externcallback::rustrt::rust_dbg_call(externcallback::cb, n)\n+    }\n }\n \n fn main() {"}, {"sha": "9b816dc34711eedb053d49d9188448f596a95fd2", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -27,7 +27,9 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    rustrt::rust_dbg_call(cb, n)\n+    unsafe {\n+        rustrt::rust_dbg_call(cb, n)\n+    }\n }\n \n fn main() {"}, {"sha": "9667f5221681a1b027601d52ea3d06df3446e448", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -23,8 +23,10 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    task::yield();\n-    rustrt::rust_dbg_call(cb, n)\n+    unsafe {\n+        task::yield();\n+        rustrt::rust_dbg_call(cb, n)\n+    }\n }\n \n fn main() {"}, {"sha": "a719926ddbe0a724f393dd949d779decf6ab3135", "filename": "src/test/run-pass/foreign-dupe.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -26,6 +26,8 @@ extern mod rustrt2 {\n }\n \n fn main() {\n-    rustrt1::last_os_error();\n-    rustrt2::last_os_error();\n+    unsafe {\n+        rustrt1::last_os_error();\n+        rustrt2::last_os_error();\n+    }\n }"}, {"sha": "a5ac7e4f669b336c0e99151455db29407e0fde74", "filename": "src/test/run-pass/foreign-no-abi.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -16,5 +16,7 @@ extern mod rustrt {\n }\n \n fn main() {\n-    rustrt::get_task_id();\n+    unsafe {\n+        rustrt::get_task_id();\n+    }\n }"}, {"sha": "edc5f2ddbc969db8117988299daea7b13764034d", "filename": "src/test/run-pass/intrinsic-alignment.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -23,22 +23,28 @@ extern mod rusti {\n mod m {\n     #[cfg(target_arch = \"x86\")]\n     pub fn main() {\n-        assert ::rusti::pref_align_of::<u64>() == 8u;\n-        assert ::rusti::min_align_of::<u64>() == 4u;\n+        unsafe {\n+            assert ::rusti::pref_align_of::<u64>() == 8u;\n+            assert ::rusti::min_align_of::<u64>() == 4u;\n+        }\n     }\n \n     #[cfg(target_arch = \"x86_64\")]\n     pub fn main() {\n-        assert ::rusti::pref_align_of::<u64>() == 8u;\n-        assert ::rusti::min_align_of::<u64>() == 8u;\n+        unsafe {\n+            assert ::rusti::pref_align_of::<u64>() == 8u;\n+            assert ::rusti::min_align_of::<u64>() == 8u;\n+        }\n     }\n }\n \n #[cfg(target_os = \"win32\")]\n mod m {\n     #[cfg(target_arch = \"x86\")]\n     pub fn main() {\n-        assert ::rusti::pref_align_of::<u64>() == 8u;\n-        assert ::rusti::min_align_of::<u64>() == 8u;\n+        unsafe {\n+            assert ::rusti::pref_align_of::<u64>() == 8u;\n+            assert ::rusti::min_align_of::<u64>() == 8u;\n+        }\n     }\n }"}, {"sha": "86b120ca273970ae1ca644cd6849e725944854fb", "filename": "src/test/run-pass/intrinsic-atomics-cc.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsic-atomics-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsic-atomics-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics-cc.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -15,7 +15,9 @@ extern mod cci_intrinsic;\n use cci_intrinsic::atomic_xchg;\n \n fn main() {\n-    let mut x = 1;\n-    atomic_xchg(&mut x, 5);\n-    assert x == 5;\n+    unsafe {\n+        let mut x = 1;\n+        atomic_xchg(&mut x, 5);\n+        assert x == 5;\n+    }\n }"}, {"sha": "fa85825282511f2042737770e0eb9a82ab85a600", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -29,33 +29,35 @@ extern mod rusti {\n }\n \n fn main() {\n-    let x = ~mut 1;\n+    unsafe {\n+        let x = ~mut 1;\n \n-    assert rusti::atomic_cxchg(x, 1, 2) == 1;\n-    assert *x == 2;\n+        assert rusti::atomic_cxchg(x, 1, 2) == 1;\n+        assert *x == 2;\n \n-    assert rusti::atomic_cxchg_acq(x, 1, 3) == 2;\n-    assert *x == 2;\n+        assert rusti::atomic_cxchg_acq(x, 1, 3) == 2;\n+        assert *x == 2;\n \n-    assert rusti::atomic_cxchg_rel(x, 2, 1) == 2;\n-    assert *x == 1;\n+        assert rusti::atomic_cxchg_rel(x, 2, 1) == 2;\n+        assert *x == 1;\n \n-    assert rusti::atomic_xchg(x, 0) == 1;\n-    assert *x == 0;\n+        assert rusti::atomic_xchg(x, 0) == 1;\n+        assert *x == 0;\n \n-    assert rusti::atomic_xchg_acq(x, 1) == 0;\n-    assert *x == 1;\n+        assert rusti::atomic_xchg_acq(x, 1) == 0;\n+        assert *x == 1;\n \n-    assert rusti::atomic_xchg_rel(x, 0) == 1;\n-    assert *x == 0;\n+        assert rusti::atomic_xchg_rel(x, 0) == 1;\n+        assert *x == 0;\n \n-    assert rusti::atomic_xadd(x, 1) == 0;\n-    assert rusti::atomic_xadd_acq(x, 1) == 1;\n-    assert rusti::atomic_xadd_rel(x, 1) == 2;\n-    assert *x == 3;\n+        assert rusti::atomic_xadd(x, 1) == 0;\n+        assert rusti::atomic_xadd_acq(x, 1) == 1;\n+        assert rusti::atomic_xadd_rel(x, 1) == 2;\n+        assert *x == 3;\n \n-    assert rusti::atomic_xsub(x, 1) == 3;\n-    assert rusti::atomic_xsub_acq(x, 1) == 2;\n-    assert rusti::atomic_xsub_rel(x, 1) == 1;\n-    assert *x == 0;\n+        assert rusti::atomic_xsub(x, 1) == 3;\n+        assert rusti::atomic_xsub_acq(x, 1) == 2;\n+        assert rusti::atomic_xsub_rel(x, 1) == 1;\n+        assert *x == 0;\n+    }\n }"}, {"sha": "40af377ba9117b4479dd7271fb76339e71b5376b", "filename": "src/test/run-pass/intrinsic-frame-address.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -17,7 +17,9 @@ extern mod rusti {\n }\n \n fn main() {\n-    do rusti::frame_address |addr| {\n-        assert addr.is_not_null();\n+    unsafe {\n+        do rusti::frame_address |addr| {\n+            assert addr.is_not_null();\n+        }\n     }\n }"}, {"sha": "3761d873fe2adfdd6c04bea5f27760946ccb3e84", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -10,14 +10,15 @@\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[legacy_exports];\n-    fn move_val_init<T>(dst: &mut T, -src: T);\n-    fn move_val<T>(dst: &mut T, -src: T);\n+    pub fn move_val_init<T>(dst: &mut T, -src: T);\n+    pub fn move_val<T>(dst: &mut T, -src: T);\n }\n \n fn main() {\n-    let mut x = @1;\n-    let mut y = @2;\n-    rusti::move_val(&mut y, move x);\n-    assert *y == 1;\n-}\n\\ No newline at end of file\n+    unsafe {\n+        let mut x = @1;\n+        let mut y = @2;\n+        rusti::move_val(&mut y, move x);\n+        assert *y == 1;\n+    }\n+}"}, {"sha": "08b976a909634823bcc4ce7a09d11f5ed0d2a8c8", "filename": "src/test/run-pass/intrinsics-integer.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -35,86 +35,86 @@ extern mod rusti {\n }\n \n fn main() {\n-\n-    use rusti::*;\n-\n-    assert(ctpop8(0i8) == 0i8);\n-    assert(ctpop16(0i16) == 0i16);\n-    assert(ctpop32(0i32) == 0i32);\n-    assert(ctpop64(0i64) == 0i64);\n-\n-    assert(ctpop8(1i8) == 1i8);\n-    assert(ctpop16(1i16) == 1i16);\n-    assert(ctpop32(1i32) == 1i32);\n-    assert(ctpop64(1i64) == 1i64);\n-\n-    assert(ctpop8(10i8) == 2i8);\n-    assert(ctpop16(10i16) == 2i16);\n-    assert(ctpop32(10i32) == 2i32);\n-    assert(ctpop64(10i64) == 2i64);\n-\n-    assert(ctpop8(100i8) == 3i8);\n-    assert(ctpop16(100i16) == 3i16);\n-    assert(ctpop32(100i32) == 3i32);\n-    assert(ctpop64(100i64) == 3i64);\n-\n-    assert(ctpop8(-1i8) == 8i8);\n-    assert(ctpop16(-1i16) == 16i16);\n-    assert(ctpop32(-1i32) == 32i32);\n-    assert(ctpop64(-1i64) == 64i64);\n-\n-    assert(ctlz8(0i8) == 8i8);\n-    assert(ctlz16(0i16) == 16i16);\n-    assert(ctlz32(0i32) == 32i32);\n-    assert(ctlz64(0i64) == 64i64);\n-\n-    assert(ctlz8(1i8) == 7i8);\n-    assert(ctlz16(1i16) == 15i16);\n-    assert(ctlz32(1i32) == 31i32);\n-    assert(ctlz64(1i64) == 63i64);\n-\n-    assert(ctlz8(10i8) == 4i8);\n-    assert(ctlz16(10i16) == 12i16);\n-    assert(ctlz32(10i32) == 28i32);\n-    assert(ctlz64(10i64) == 60i64);\n-\n-    assert(ctlz8(100i8) == 1i8);\n-    assert(ctlz16(100i16) == 9i16);\n-    assert(ctlz32(100i32) == 25i32);\n-    assert(ctlz64(100i64) == 57i64);\n-\n-    assert(cttz8(-1i8) == 0i8);\n-    assert(cttz16(-1i16) == 0i16);\n-    assert(cttz32(-1i32) == 0i32);\n-    assert(cttz64(-1i64) == 0i64);\n-    \n-    assert(cttz8(0i8) == 8i8);\n-    assert(cttz16(0i16) == 16i16);\n-    assert(cttz32(0i32) == 32i32);\n-    assert(cttz64(0i64) == 64i64);\n-\n-    assert(cttz8(1i8) == 0i8);\n-    assert(cttz16(1i16) == 0i16);\n-    assert(cttz32(1i32) == 0i32);\n-    assert(cttz64(1i64) == 0i64);\n-\n-    assert(cttz8(10i8) == 1i8);\n-    assert(cttz16(10i16) == 1i16);\n-    assert(cttz32(10i32) == 1i32);\n-    assert(cttz64(10i64) == 1i64);\n-\n-    assert(cttz8(100i8) == 2i8);\n-    assert(cttz16(100i16) == 2i16);\n-    assert(cttz32(100i32) == 2i32);\n-    assert(cttz64(100i64) == 2i64);\n-\n-    assert(cttz8(-1i8) == 0i8);\n-    assert(cttz16(-1i16) == 0i16);\n-    assert(cttz32(-1i32) == 0i32);\n-    assert(cttz64(-1i64) == 0i64);\n-\n-    assert(bswap16(0x0A0Bi16) == 0x0B0Ai16);\n-    assert(bswap32(0x0ABBCC0Di32) == 0x0DCCBB0Ai32);\n-    assert(bswap64(0x0122334455667708i64) == 0x0877665544332201i64);\n-\n+    unsafe {\n+        use rusti::*;\n+\n+        assert(ctpop8(0i8) == 0i8);\n+        assert(ctpop16(0i16) == 0i16);\n+        assert(ctpop32(0i32) == 0i32);\n+        assert(ctpop64(0i64) == 0i64);\n+\n+        assert(ctpop8(1i8) == 1i8);\n+        assert(ctpop16(1i16) == 1i16);\n+        assert(ctpop32(1i32) == 1i32);\n+        assert(ctpop64(1i64) == 1i64);\n+\n+        assert(ctpop8(10i8) == 2i8);\n+        assert(ctpop16(10i16) == 2i16);\n+        assert(ctpop32(10i32) == 2i32);\n+        assert(ctpop64(10i64) == 2i64);\n+\n+        assert(ctpop8(100i8) == 3i8);\n+        assert(ctpop16(100i16) == 3i16);\n+        assert(ctpop32(100i32) == 3i32);\n+        assert(ctpop64(100i64) == 3i64);\n+\n+        assert(ctpop8(-1i8) == 8i8);\n+        assert(ctpop16(-1i16) == 16i16);\n+        assert(ctpop32(-1i32) == 32i32);\n+        assert(ctpop64(-1i64) == 64i64);\n+\n+        assert(ctlz8(0i8) == 8i8);\n+        assert(ctlz16(0i16) == 16i16);\n+        assert(ctlz32(0i32) == 32i32);\n+        assert(ctlz64(0i64) == 64i64);\n+\n+        assert(ctlz8(1i8) == 7i8);\n+        assert(ctlz16(1i16) == 15i16);\n+        assert(ctlz32(1i32) == 31i32);\n+        assert(ctlz64(1i64) == 63i64);\n+\n+        assert(ctlz8(10i8) == 4i8);\n+        assert(ctlz16(10i16) == 12i16);\n+        assert(ctlz32(10i32) == 28i32);\n+        assert(ctlz64(10i64) == 60i64);\n+\n+        assert(ctlz8(100i8) == 1i8);\n+        assert(ctlz16(100i16) == 9i16);\n+        assert(ctlz32(100i32) == 25i32);\n+        assert(ctlz64(100i64) == 57i64);\n+\n+        assert(cttz8(-1i8) == 0i8);\n+        assert(cttz16(-1i16) == 0i16);\n+        assert(cttz32(-1i32) == 0i32);\n+        assert(cttz64(-1i64) == 0i64);\n+        \n+        assert(cttz8(0i8) == 8i8);\n+        assert(cttz16(0i16) == 16i16);\n+        assert(cttz32(0i32) == 32i32);\n+        assert(cttz64(0i64) == 64i64);\n+\n+        assert(cttz8(1i8) == 0i8);\n+        assert(cttz16(1i16) == 0i16);\n+        assert(cttz32(1i32) == 0i32);\n+        assert(cttz64(1i64) == 0i64);\n+\n+        assert(cttz8(10i8) == 1i8);\n+        assert(cttz16(10i16) == 1i16);\n+        assert(cttz32(10i32) == 1i32);\n+        assert(cttz64(10i64) == 1i64);\n+\n+        assert(cttz8(100i8) == 2i8);\n+        assert(cttz16(100i16) == 2i16);\n+        assert(cttz32(100i32) == 2i32);\n+        assert(cttz64(100i64) == 2i64);\n+\n+        assert(cttz8(-1i8) == 0i8);\n+        assert(cttz16(-1i16) == 0i16);\n+        assert(cttz32(-1i32) == 0i32);\n+        assert(cttz64(-1i64) == 0i64);\n+\n+        assert(bswap16(0x0A0Bi16) == 0x0B0Ai16);\n+        assert(bswap32(0x0ABBCC0Di32) == 0x0DCCBB0Ai32);\n+        assert(bswap64(0x0122334455667708i64) == 0x0877665544332201i64);\n+    }\n }"}, {"sha": "61594d19a6dfc942d74d991c9caf7f0066fd5ad8", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -49,56 +49,57 @@ extern mod rusti {\n }\n \n fn main() {\n+    unsafe {\n+        use rusti::*;\n \n-    use rusti::*;\n+        assert(sqrtf32(64f32).fuzzy_eq(&8f32));\n+        assert(sqrtf64(64f64).fuzzy_eq(&8f64));\n \n-    assert(sqrtf32(64f32).fuzzy_eq(&8f32));\n-    assert(sqrtf64(64f64).fuzzy_eq(&8f64));\n+        assert(powif32(25f32, -2i32).fuzzy_eq(&0.0016f32));\n+        assert(powif64(23.2f64, 2i32).fuzzy_eq(&538.24f64));\n \n-    assert(powif32(25f32, -2i32).fuzzy_eq(&0.0016f32));\n-    assert(powif64(23.2f64, 2i32).fuzzy_eq(&538.24f64));\n+        assert(sinf32(0f32).fuzzy_eq(&0f32));\n+        assert(sinf64(f64::consts::pi / 2f64).fuzzy_eq(&1f64));\n \n-    assert(sinf32(0f32).fuzzy_eq(&0f32));\n-    assert(sinf64(f64::consts::pi / 2f64).fuzzy_eq(&1f64));\n+        assert(cosf32(0f32).fuzzy_eq(&1f32));\n+        assert(cosf64(f64::consts::pi * 2f64).fuzzy_eq(&1f64));\n \n-    assert(cosf32(0f32).fuzzy_eq(&1f32));\n-    assert(cosf64(f64::consts::pi * 2f64).fuzzy_eq(&1f64));\n+        assert(powf32(25f32, -2f32).fuzzy_eq(&0.0016f32));\n+        assert(powf64(400f64, 0.5f64).fuzzy_eq(&20f64));\n \n-    assert(powf32(25f32, -2f32).fuzzy_eq(&0.0016f32));\n-    assert(powf64(400f64, 0.5f64).fuzzy_eq(&20f64));\n+        assert(fabsf32(expf32(1f32) - f32::consts::e).fuzzy_eq(&0f32));\n+        assert(expf64(1f64).fuzzy_eq(&f64::consts::e));\n \n-    assert(fabsf32(expf32(1f32) - f32::consts::e).fuzzy_eq(&0f32));\n-    assert(expf64(1f64).fuzzy_eq(&f64::consts::e));\n+        assert(exp2f32(10f32).fuzzy_eq(&1024f32));\n+        assert(exp2f64(50f64).fuzzy_eq(&1125899906842624f64));\n \n-    assert(exp2f32(10f32).fuzzy_eq(&1024f32));\n-    assert(exp2f64(50f64).fuzzy_eq(&1125899906842624f64));\n+        assert(fabsf32(logf32(f32::consts::e) - 1f32).fuzzy_eq(&0f32));\n+        assert(logf64(1f64).fuzzy_eq(&0f64));\n \n-    assert(fabsf32(logf32(f32::consts::e) - 1f32).fuzzy_eq(&0f32));\n-    assert(logf64(1f64).fuzzy_eq(&0f64));\n+        assert(log10f32(10f32).fuzzy_eq(&1f32));\n+        assert(log10f64(f64::consts::e).fuzzy_eq(&f64::consts::log10_e));\n \n-    assert(log10f32(10f32).fuzzy_eq(&1f32));\n-    assert(log10f64(f64::consts::e).fuzzy_eq(&f64::consts::log10_e));\n+        assert(log2f32(8f32).fuzzy_eq(&3f32));\n+        assert(log2f64(f64::consts::e).fuzzy_eq(&f64::consts::log2_e));\n+      \n+        assert(fmaf32(1.0f32, 2.0f32, 5.0f32).fuzzy_eq(&7.0f32));\n+        assert(fmaf64(0.0f64, -2.0f64, f64::consts::e).fuzzy_eq(&f64::consts::e));\n \n-    assert(log2f32(8f32).fuzzy_eq(&3f32));\n-    assert(log2f64(f64::consts::e).fuzzy_eq(&f64::consts::log2_e));\n-  \n-    assert(fmaf32(1.0f32, 2.0f32, 5.0f32).fuzzy_eq(&7.0f32));\n-    assert(fmaf64(0.0f64, -2.0f64, f64::consts::e).fuzzy_eq(&f64::consts::e));\n+        assert(fabsf32(-1.0f32).fuzzy_eq(&1.0f32));\n+        assert(fabsf64(34.2f64).fuzzy_eq(&34.2f64));\n \n-    assert(fabsf32(-1.0f32).fuzzy_eq(&1.0f32));\n-    assert(fabsf64(34.2f64).fuzzy_eq(&34.2f64));\n+        assert(floorf32(3.8f32).fuzzy_eq(&3.0f32));\n+        assert(floorf64(-1.1f64).fuzzy_eq(&-2.0f64));\n \n-    assert(floorf32(3.8f32).fuzzy_eq(&3.0f32));\n-    assert(floorf64(-1.1f64).fuzzy_eq(&-2.0f64));\n-\n-    // Causes linker error\n-    // undefined reference to llvm.ceil.f32/64\n-    //assert(ceilf32(-2.3f32) == -2.0f32);\n-    //assert(ceilf64(3.8f64) == 4.0f64);\n-  \n-    // Causes linker error\n-    // undefined reference to llvm.trunc.f32/64\n-    //assert(truncf32(0.1f32) == 0.0f32);\n-    //assert(truncf64(-0.1f64) == 0.0f64);\n+        // Causes linker error\n+        // undefined reference to llvm.ceil.f32/64\n+        //assert(ceilf32(-2.3f32) == -2.0f32);\n+        //assert(ceilf64(3.8f64) == 4.0f64);\n+      \n+        // Causes linker error\n+        // undefined reference to llvm.trunc.f32/64\n+        //assert(truncf32(0.1f32) == 0.0f32);\n+        //assert(truncf64(-0.1f64) == 0.0f64);\n+    }\n \n }"}, {"sha": "e8d07b4b2ad1324395c51b92b5ba3d00573d2366", "filename": "src/test/run-pass/issue-2214.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -21,7 +21,9 @@ fn to_c_int(v: &mut int) -> &mut c_int {\n }\n \n fn lgamma(n: c_double, value: &mut int) -> c_double {\n-  return m::lgamma(n, to_c_int(value));\n+    unsafe {\n+        return m::lgamma(n, to_c_int(value));\n+    }\n }\n \n #[link_name = \"m\"]"}, {"sha": "9d195c054e1d2bd1695de5c88c7d345ecb3bb0c3", "filename": "src/test/run-pass/issue-506.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e43cff6657b5ba4245480ede5230e3f00aa52185/src%2Ftest%2Frun-pass%2Fissue-506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43cff6657b5ba4245480ede5230e3f00aa52185/src%2Ftest%2Frun-pass%2Fissue-506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-506.rs?ref=e43cff6657b5ba4245480ede5230e3f00aa52185", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-  A reduced test case for Issue #506, provided by Rob Arnold.\n-\n-  Testing spawning foreign functions\n-*/\n-\n-extern mod std;\n-\n-#[abi = \"cdecl\"]\n-extern mod rustrt {\n-    #[legacy_exports];\n-    fn rust_dbg_do_nothing();\n-}\n-\n-fn main() {\n-    task::spawn(rustrt::rust_dbg_do_nothing);\n-}"}, {"sha": "6143f1d34105e1f9a88cac6afb96d8974ae5db0d", "filename": "src/test/run-pass/morestack-address.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fmorestack-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fmorestack-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack-address.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -16,7 +16,9 @@ extern mod rusti {\n }\n \n fn main() {\n-    let addr = rusti::morestack_addr();\n-    assert addr.is_not_null();\n-    error!(\"%?\", addr);\n-}\n\\ No newline at end of file\n+    unsafe {\n+        let addr = rusti::morestack_addr();\n+        assert addr.is_not_null();\n+        error!(\"%?\", addr);\n+    }\n+}"}, {"sha": "a520719562dc4e0ea01119867892e4b40bb979e4", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -23,31 +23,33 @@ extern mod rustrt {\n     fn rust_get_task();\n }\n \n-fn calllink01() { rustrt::rust_get_sched_id(); }\n-fn calllink02() { rustrt::last_os_error(); }\n-fn calllink03() { rustrt::rust_getcwd(); }\n-fn calllink08() { rustrt::get_task_id(); }\n-fn calllink09() { rustrt::rust_sched_threads(); }\n-fn calllink10() { rustrt::rust_get_task(); }\n+fn calllink01() { unsafe { rustrt::rust_get_sched_id(); } }\n+fn calllink02() { unsafe { rustrt::last_os_error(); } }\n+fn calllink03() { unsafe { rustrt::rust_getcwd(); } }\n+fn calllink08() { unsafe { rustrt::get_task_id(); } }\n+fn calllink09() { unsafe { rustrt::rust_sched_threads(); } }\n+fn calllink10() { unsafe { rustrt::rust_get_task(); } }\n \n fn runtest(f: fn~(), frame_backoff: u32) {\n     runtest2(f, frame_backoff, 0 as *u8);\n }\n \n fn runtest2(f: fn~(), frame_backoff: u32, last_stk: *u8) -> u32 {\n-    let curr_stk = rustrt::debug_get_stk_seg();\n-    if (last_stk != curr_stk && last_stk != 0 as *u8) {\n-        // We switched stacks, go back and try to hit the dynamic linker\n-        frame_backoff\n-    } else {\n-        let frame_backoff = runtest2(copy f, frame_backoff, curr_stk);\n-        if frame_backoff > 1u32 {\n-            frame_backoff - 1u32\n-        } else if frame_backoff == 1u32 {\n-            f();\n-            0u32\n+    unsafe {\n+        let curr_stk = rustrt::debug_get_stk_seg();\n+        if (last_stk != curr_stk && last_stk != 0 as *u8) {\n+            // We switched stacks, go back and try to hit the dynamic linker\n+            frame_backoff\n         } else {\n-            0u32\n+            let frame_backoff = runtest2(copy f, frame_backoff, curr_stk);\n+            if frame_backoff > 1u32 {\n+                frame_backoff - 1u32\n+            } else if frame_backoff == 1u32 {\n+                f();\n+                0u32\n+            } else {\n+                0u32\n+            }\n         }\n     }\n }"}, {"sha": "d24b0888c44c9fa2276a1a8ffebadaf25a21db4f", "filename": "src/test/run-pass/rec-align-u32.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u32.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -45,22 +45,23 @@ mod m {\n }\n \n fn main() {\n+    unsafe {\n+        let x = {c8: 22u8, t: {c64: 44u32}};\n \n-    let x = {c8: 22u8, t: {c64: 44u32}};\n+        // Send it through the shape code\n+        let y = fmt!(\"%?\", x);\n \n-    // Send it through the shape code\n-    let y = fmt!(\"%?\", x);\n+        debug!(\"align inner = %?\", rusti::min_align_of::<inner>());\n+        debug!(\"size outer = %?\", sys::size_of::<outer>());\n+        debug!(\"y = %s\", y);\n \n-    debug!(\"align inner = %?\", rusti::min_align_of::<inner>());\n-    debug!(\"size outer = %?\", sys::size_of::<outer>());\n-    debug!(\"y = %s\", y);\n+        // per clang/gcc the alignment of `inner` is 4 on x86.\n+        assert rusti::min_align_of::<inner>() == m::align();\n \n-    // per clang/gcc the alignment of `inner` is 4 on x86.\n-    assert rusti::min_align_of::<inner>() == m::align();\n+        // per clang/gcc the size of `outer` should be 12\n+        // because `inner`s alignment was 4.\n+        assert sys::size_of::<outer>() == m::size();\n \n-    // per clang/gcc the size of `outer` should be 12\n-    // because `inner`s alignment was 4.\n-    assert sys::size_of::<outer>() == m::size();\n-\n-    assert y == ~\"{c8: 22, t: {c64: 44}}\";\n+        assert y == ~\"{c8: 22, t: {c64: 44}}\";\n+    }\n }"}, {"sha": "dc9fa146ef92cec586fffe43734880dcef54bfa8", "filename": "src/test/run-pass/rec-align-u64.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u64.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -62,22 +62,23 @@ mod m {\n }\n \n fn main() {\n+    unsafe {\n+        let x = {c8: 22u8, t: {c64: 44u64}};\n \n-    let x = {c8: 22u8, t: {c64: 44u64}};\n+        // Send it through the shape code\n+        let y = fmt!(\"%?\", x);\n \n-    // Send it through the shape code\n-    let y = fmt!(\"%?\", x);\n+        debug!(\"align inner = %?\", rusti::min_align_of::<inner>());\n+        debug!(\"size outer = %?\", sys::size_of::<outer>());\n+        debug!(\"y = %s\", y);\n \n-    debug!(\"align inner = %?\", rusti::min_align_of::<inner>());\n-    debug!(\"size outer = %?\", sys::size_of::<outer>());\n-    debug!(\"y = %s\", y);\n+        // per clang/gcc the alignment of `inner` is 4 on x86.\n+        assert rusti::min_align_of::<inner>() == m::m::align();\n \n-    // per clang/gcc the alignment of `inner` is 4 on x86.\n-    assert rusti::min_align_of::<inner>() == m::m::align();\n+        // per clang/gcc the size of `outer` should be 12\n+        // because `inner`s alignment was 4.\n+        assert sys::size_of::<outer>() == m::m::size();\n \n-    // per clang/gcc the size of `outer` should be 12\n-    // because `inner`s alignment was 4.\n-    assert sys::size_of::<outer>() == m::m::size();\n-\n-    assert y == ~\"{c8: 22, t: {c64: 44}}\";\n+        assert y == ~\"{c8: 22, t: {c64: 44}}\";\n+    }\n }"}, {"sha": "ff9e133fe153eb27dcc2832422195119d77b3a66", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -483,10 +483,12 @@ impl my_visitor {\n     }\n \n     fn visit_inner(inner: *TyDesc) -> bool {\n-        let u = my_visitor(*self);\n-        let v = ptr_visit_adaptor({inner: u});\n-        visit_tydesc(inner, v as TyVisitor);\n-        true\n+        unsafe {\n+            let u = my_visitor(*self);\n+            let v = ptr_visit_adaptor({inner: u});\n+            visit_tydesc(inner, v as TyVisitor);\n+            true\n+        }\n     }\n }\n \n@@ -621,21 +623,25 @@ fn get_tydesc_for<T>(&&_t: T) -> *TyDesc {\n }\n \n fn main() {\n-    let r = (1,2,3,true,false,{x:5,y:4,z:3});\n-    let p = ptr::addr_of(&r) as *c_void;\n-    let u = my_visitor(@{mut ptr1: p,\n-                         mut ptr2: p,\n-                         mut vals: ~[]});\n-    let v = ptr_visit_adaptor({inner: u});\n-    let td = get_tydesc_for(r);\n-    unsafe { error!(\"tydesc sz: %u, align: %u\",\n-                    (*td).size, (*td).align); }\n-    let v = v as TyVisitor;\n-    visit_tydesc(td, v);\n-\n-    for (copy u.vals).each |s| {\n-        io::println(fmt!(\"val: %s\", *s));\n-    }\n-    error!(\"%?\", copy u.vals);\n-    assert u.vals == ~[~\"1\", ~\"2\", ~\"3\", ~\"true\", ~\"false\", ~\"5\", ~\"4\", ~\"3\"];\n+    unsafe {\n+        let r = (1,2,3,true,false,{x:5,y:4,z:3});\n+        let p = ptr::addr_of(&r) as *c_void;\n+        let u = my_visitor(@{mut ptr1: p,\n+                             mut ptr2: p,\n+                             mut vals: ~[]});\n+        let v = ptr_visit_adaptor({inner: u});\n+        let td = get_tydesc_for(r);\n+        unsafe { error!(\"tydesc sz: %u, align: %u\",\n+                        (*td).size, (*td).align); }\n+        let v = v as TyVisitor;\n+        visit_tydesc(td, v);\n+\n+        for (copy u.vals).each |s| {\n+            io::println(fmt!(\"val: %s\", *s));\n+        }\n+        error!(\"%?\", copy u.vals);\n+        assert u.vals == ~[\n+            ~\"1\", ~\"2\", ~\"3\", ~\"true\", ~\"false\", ~\"5\", ~\"4\", ~\"3\"\n+        ];\n+    }\n  }"}, {"sha": "6c3f7e96c5aabc1e87d57271f17a3ea3dea93576", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -36,11 +36,13 @@ fn main() {\n         let new_task_id = rustrt::rust_new_task_in_sched(new_sched_id);\n         assert !new_task_id.is_null();\n         let f = fn~() {\n-            let child_sched_id = rustrt::rust_get_sched_id();\n-            error!(\"child_sched_id %?\", child_sched_id);\n-            assert child_sched_id != parent_sched_id;\n-            assert child_sched_id == new_sched_id;\n-            oldcomm::send(ch, ());\n+            unsafe {\n+                let child_sched_id = rustrt::rust_get_sched_id();\n+                error!(\"child_sched_id %?\", child_sched_id);\n+                assert child_sched_id != parent_sched_id;\n+                assert child_sched_id == new_sched_id;\n+                oldcomm::send(ch, ());\n+            }\n         };\n         let fptr = cast::reinterpret_cast(&ptr::addr_of(&f));\n         rustrt::start_task(new_task_id, fptr);"}, {"sha": "c4e38a1de2ce2570458e1538e45b992aad02aa7d", "filename": "src/test/run-pass/struct-return.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163b97b7bb53b7a9753b5fbd9b28dc1e09337259/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-return.rs?ref=163b97b7bb53b7a9753b5fbd9b28dc1e09337259", "patch": "@@ -19,33 +19,37 @@ extern mod rustrt {\n }\n \n fn test1() {\n-    let q = { a: 0xaaaa_aaaa_aaaa_aaaa_u64,\n-             b: 0xbbbb_bbbb_bbbb_bbbb_u64,\n-             c: 0xcccc_cccc_cccc_cccc_u64,\n-             d: 0xdddd_dddd_dddd_dddd_u64 };\n-    let qq = rustrt::debug_abi_1(q);\n-    error!(\"a: %x\", qq.a as uint);\n-    error!(\"b: %x\", qq.b as uint);\n-    error!(\"c: %x\", qq.c as uint);\n-    error!(\"d: %x\", qq.d as uint);\n-    assert qq.a == q.c + 1u64;\n-    assert qq.b == q.d - 1u64;\n-    assert qq.c == q.a + 1u64;\n-    assert qq.d == q.b - 1u64;\n+    unsafe {\n+        let q = { a: 0xaaaa_aaaa_aaaa_aaaa_u64,\n+                 b: 0xbbbb_bbbb_bbbb_bbbb_u64,\n+                 c: 0xcccc_cccc_cccc_cccc_u64,\n+                 d: 0xdddd_dddd_dddd_dddd_u64 };\n+        let qq = rustrt::debug_abi_1(q);\n+        error!(\"a: %x\", qq.a as uint);\n+        error!(\"b: %x\", qq.b as uint);\n+        error!(\"c: %x\", qq.c as uint);\n+        error!(\"d: %x\", qq.d as uint);\n+        assert qq.a == q.c + 1u64;\n+        assert qq.b == q.d - 1u64;\n+        assert qq.c == q.a + 1u64;\n+        assert qq.d == q.b - 1u64;\n+    }\n }\n \n #[cfg(target_arch = \"x86_64\")]\n fn test2() {\n-    let f = { a: 1.234567890e-15_f64,\n-             b: 0b_1010_1010_u8,\n-             c: 1.0987654321e-15_f64 };\n-    let ff = rustrt::debug_abi_2(f);\n-    error!(\"a: %f\", ff.a as float);\n-    error!(\"b: %u\", ff.b as uint);\n-    error!(\"c: %f\", ff.c as float);\n-    assert ff.a == f.c + 1.0f64;\n-    assert ff.b == 0xff_u8;\n-    assert ff.c == f.a - 1.0f64;\n+    unsafe {\n+        let f = { a: 1.234567890e-15_f64,\n+                 b: 0b_1010_1010_u8,\n+                 c: 1.0987654321e-15_f64 };\n+        let ff = rustrt::debug_abi_2(f);\n+        error!(\"a: %f\", ff.a as float);\n+        error!(\"b: %u\", ff.b as uint);\n+        error!(\"c: %f\", ff.c as float);\n+        assert ff.a == f.c + 1.0f64;\n+        assert ff.b == 0xff_u8;\n+        assert ff.c == f.a - 1.0f64;\n+    }\n }\n \n #[cfg(target_arch = \"x86\")]\n@@ -55,4 +59,4 @@ fn test2() {\n fn main() {\n     test1();\n     test2();\n-}\n\\ No newline at end of file\n+}"}]}