{"sha": "0e54d71e157693226c3c5f67d9755daf885714e2", "node_id": "C_kwDOAAsO6NoAKDBlNTRkNzFlMTU3NjkzMjI2YzNjNWY2N2Q5NzU1ZGFmODg1NzE0ZTI", "commit": {"author": {"name": "BlackHoleFox", "email": "blackholefoxdev@gmail.com", "date": "2022-07-31T08:10:09Z"}, "committer": {"name": "BlackHoleFox", "email": "blackholefoxdev@gmail.com", "date": "2022-07-31T18:14:18Z"}, "message": "Add validation to const fn CStr creation", "tree": {"sha": "baa9ee2699ad4049dac605e1c7f3456f1ff48a31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baa9ee2699ad4049dac605e1c7f3456f1ff48a31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e54d71e157693226c3c5f67d9755daf885714e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e54d71e157693226c3c5f67d9755daf885714e2", "html_url": "https://github.com/rust-lang/rust/commit/0e54d71e157693226c3c5f67d9755daf885714e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e54d71e157693226c3c5f67d9755daf885714e2/comments", "author": {"login": "BlackHoleFox", "id": 20936452, "node_id": "MDQ6VXNlcjIwOTM2NDUy", "avatar_url": "https://avatars.githubusercontent.com/u/20936452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BlackHoleFox", "html_url": "https://github.com/BlackHoleFox", "followers_url": "https://api.github.com/users/BlackHoleFox/followers", "following_url": "https://api.github.com/users/BlackHoleFox/following{/other_user}", "gists_url": "https://api.github.com/users/BlackHoleFox/gists{/gist_id}", "starred_url": "https://api.github.com/users/BlackHoleFox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BlackHoleFox/subscriptions", "organizations_url": "https://api.github.com/users/BlackHoleFox/orgs", "repos_url": "https://api.github.com/users/BlackHoleFox/repos", "events_url": "https://api.github.com/users/BlackHoleFox/events{/privacy}", "received_events_url": "https://api.github.com/users/BlackHoleFox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BlackHoleFox", "id": 20936452, "node_id": "MDQ6VXNlcjIwOTM2NDUy", "avatar_url": "https://avatars.githubusercontent.com/u/20936452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BlackHoleFox", "html_url": "https://github.com/BlackHoleFox", "followers_url": "https://api.github.com/users/BlackHoleFox/followers", "following_url": "https://api.github.com/users/BlackHoleFox/following{/other_user}", "gists_url": "https://api.github.com/users/BlackHoleFox/gists{/gist_id}", "starred_url": "https://api.github.com/users/BlackHoleFox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BlackHoleFox/subscriptions", "organizations_url": "https://api.github.com/users/BlackHoleFox/orgs", "repos_url": "https://api.github.com/users/BlackHoleFox/repos", "events_url": "https://api.github.com/users/BlackHoleFox/events{/privacy}", "received_events_url": "https://api.github.com/users/BlackHoleFox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2318651d4d2c6280a5047544cbf4180119ba966", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2318651d4d2c6280a5047544cbf4180119ba966", "html_url": "https://github.com/rust-lang/rust/commit/a2318651d4d2c6280a5047544cbf4180119ba966"}], "stats": {"total": 47, "additions": 34, "deletions": 13}, "files": [{"sha": "82e63a7fe1ddb6611cf3dc727136d2d7b235723f", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0e54d71e157693226c3c5f67d9755daf885714e2/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e54d71e157693226c3c5f67d9755daf885714e2/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=0e54d71e157693226c3c5f67d9755daf885714e2", "patch": "@@ -2,6 +2,7 @@ use crate::ascii;\n use crate::cmp::Ordering;\n use crate::ffi::c_char;\n use crate::fmt::{self, Write};\n+use crate::intrinsics;\n use crate::ops;\n use crate::slice;\n use crate::slice::memchr;\n@@ -384,21 +385,41 @@ impl CStr {\n     #[must_use]\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     #[rustc_const_stable(feature = \"const_cstr_unchecked\", since = \"1.59.0\")]\n+    #[rustc_allow_const_fn_unstable(const_eval_select)]\n     pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n-        // We're in a const fn, so this is the best we can do\n-        debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n-        // SAFETY: Calling an inner function with the same prerequisites.\n-        unsafe { Self::_from_bytes_with_nul_unchecked(bytes) }\n-    }\n+        fn rt_impl(bytes: &[u8]) -> &CStr {\n+            // Chance at catching some UB at runtime with debug builds.\n+            debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n \n-    #[inline]\n-    const unsafe fn _from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n-        // SAFETY: Casting to CStr is safe because its internal representation\n-        // is a [u8] too (safe only inside std).\n-        // Dereferencing the obtained pointer is safe because it comes from a\n-        // reference. Making a reference is then safe because its lifetime\n-        // is bound by the lifetime of the given `bytes`.\n-        unsafe { &*(bytes as *const [u8] as *const CStr) }\n+            // SAFETY: Casting to CStr is safe because its internal representation\n+            // is a [u8] too (safe only inside std).\n+            // Dereferencing the obtained pointer is safe because it comes from a\n+            // reference. Making a reference is then safe because its lifetime\n+            // is bound by the lifetime of the given `bytes`.\n+            unsafe { &*(bytes as *const [u8] as *const CStr) }\n+        }\n+\n+        const fn const_impl(bytes: &[u8]) -> &CStr {\n+            // Saturating so that an empty slice panics in the assert with a good\n+            // message, not here due to underflow.\n+            let mut i = bytes.len().saturating_sub(1);\n+            assert!(!bytes.is_empty() && bytes[i] == 0, \"input was not nul-terminated\");\n+\n+            // Ending null byte exists, skip to the rest.\n+            while i != 0 {\n+                i -= 1;\n+                let byte = bytes[i];\n+                assert!(byte != 0, \"input contained interior nul\");\n+            }\n+\n+            // SAFETY: See `rt_impl` cast.\n+            unsafe { &*(bytes as *const [u8] as *const CStr) }\n+        }\n+\n+        // SAFETY: The const and runtime versions have identical behavior\n+        // unless the safety contract of `from_bytes_with_nul_unchecked` is\n+        // violated, which is UB.\n+        unsafe { intrinsics::const_eval_select((bytes,), const_impl, rt_impl) }\n     }\n \n     /// Returns the inner pointer to this C string."}]}