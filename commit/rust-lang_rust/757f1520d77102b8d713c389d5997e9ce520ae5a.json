{"sha": "757f1520d77102b8d713c389d5997e9ce520ae5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1N2YxNTIwZDc3MTAyYjhkNzEzYzM4OWQ1OTk3ZTljZTUyMGFlNWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-20T15:23:45Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-20T15:23:45Z"}, "message": "Change trans.collect_items to use walk, not fold", "tree": {"sha": "8bee41624fac11758705d8018da7444a7ff34513", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bee41624fac11758705d8018da7444a7ff34513"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/757f1520d77102b8d713c389d5997e9ce520ae5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/757f1520d77102b8d713c389d5997e9ce520ae5a", "html_url": "https://github.com/rust-lang/rust/commit/757f1520d77102b8d713c389d5997e9ce520ae5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/757f1520d77102b8d713c389d5997e9ce520ae5a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fe339d5ef6fea488b2216ec060d289a691e7518", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe339d5ef6fea488b2216ec060d289a691e7518", "html_url": "https://github.com/rust-lang/rust/commit/4fe339d5ef6fea488b2216ec060d289a691e7518"}], "stats": {"total": 239, "additions": 112, "deletions": 127}, "files": [{"sha": "bae2d5369ff277dbca73f9914a8243cbd364d3b3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 112, "deletions": 127, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/757f1520d77102b8d713c389d5997e9ce520ae5a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/757f1520d77102b8d713c389d5997e9ce520ae5a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=757f1520d77102b8d713c389d5997e9ce520ae5a", "patch": "@@ -113,7 +113,6 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[@ty.t, TypeRef] lltypes,\n                             @glue_fns glues,\n                             namegen names,\n-                            vec[str] path,\n                             std.sha1.sha1 sha);\n \n type local_ctxt = rec(vec[str] path,\n@@ -182,19 +181,19 @@ fn path_name(vec[str] path) -> str {\n }\n \n \n-fn mangle_name_by_type(@local_ctxt cx, @ty.t t) -> str {\n-    cx.ccx.sha.reset();\n+fn mangle_name_by_type(@crate_ctxt ccx, vec[str] path, @ty.t t) -> str {\n+    ccx.sha.reset();\n     auto f = metadata.def_to_str;\n-    cx.ccx.sha.input_str(metadata.ty_str(t, f));\n+    ccx.sha.input_str(metadata.ty_str(t, f));\n     ret sep() + \"rust\" + sep()\n-        + _str.substr(cx.ccx.sha.result_str(), 0u, 16u) + sep()\n-        + path_name(cx.path);\n+        + _str.substr(ccx.sha.result_str(), 0u, 16u) + sep()\n+        + path_name(path);\n }\n \n-fn mangle_name_by_seq(@local_ctxt cx, str flav) -> str {\n+fn mangle_name_by_seq(@crate_ctxt ccx, vec[str] path, str flav) -> str {\n     ret sep() + \"rust\" + sep()\n-        + cx.ccx.names.next(flav) + sep()\n-        + path_name(cx.path);\n+        + ccx.names.next(flav) + sep()\n+        + path_name(path);\n }\n \n fn res(@block_ctxt bcx, ValueRef val) -> result {\n@@ -1690,9 +1689,9 @@ fn declare_generic_glue(@local_ctxt cx,\n                         TypeRef llfnty,\n                         str name) -> ValueRef {\n     auto gcx = @rec(path=vec(\"glue\", name) with *cx);\n-    auto fn_name = mangle_name_by_type(gcx, t);\n-    fn_name = sanitize(fn_name);\n-    auto llfn = decl_internal_fastcall_fn(cx.ccx.llmod, fn_name, llfnty);\n+    auto fn_nm = mangle_name_by_type(cx.ccx, cx.path + vec(\"glue\", name), t);\n+    fn_nm = sanitize(fn_nm);\n+    auto llfn = decl_internal_fastcall_fn(cx.ccx.llmod, fn_nm, llfnty);\n     ret llfn;\n }\n \n@@ -3422,7 +3421,6 @@ fn trans_for_each(@block_ctxt cx,\n                   @ast.decl decl,\n                   @ast.expr seq,\n                   &ast.block body) -> result {\n-\n     /*\n      * The translation is a little .. complex here. Code like:\n      *\n@@ -3449,12 +3447,13 @@ fn trans_for_each(@block_ctxt cx,\n     // escape. This could be determined upstream, and probably ought\n     // to be so, eventualy. For first cut, skip this. Null env.\n \n+    auto lcx = cx.fcx.lcx;\n     // FIXME: possibly support alias-mode here?\n     auto decl_ty = plain_ty(ty.ty_nil);\n     auto decl_id;\n     alt (decl.node) {\n         case (ast.decl_local(?local)) {\n-            decl_ty = node_ann_type(cx.fcx.lcx.ccx, local.ann);\n+            decl_ty = node_ann_type(lcx.ccx, local.ann);\n             decl_id = local.id;\n         }\n     }\n@@ -3500,7 +3499,7 @@ fn trans_for_each(@block_ctxt cx,\n \n     // Create an environment and populate it with the bindings.\n     auto tydesc_count = _vec.len[ValueRef](cx.fcx.lltydescs);\n-    auto llenvptrty = T_closure_ptr(cx.fcx.lcx.ccx.tn, T_ptr(T_nil()),\n+    auto llenvptrty = T_closure_ptr(lcx.ccx.tn, T_ptr(T_nil()),\n                                     val_ty(llbindingsptr), tydesc_count);\n     auto llenvptr = alloca(cx, llvm.LLVMGetElementType(llenvptrty));\n \n@@ -3526,26 +3525,26 @@ fn trans_for_each(@block_ctxt cx,\n \n     // Step 2: Declare foreach body function.\n \n-    let str s = mangle_name_by_seq(cx.fcx.lcx, \"foreach\");\n+    let str s = mangle_name_by_seq(lcx.ccx, lcx.path, \"foreach\");\n \n     // The 'env' arg entering the body function is a fake env member (as in\n     // the env-part of the normal rust calling convention) that actually\n     // points to a stack allocated env in this frame. We bundle that env\n     // pointer along with the foreach-body-fn pointer into a 'normal' fn pair\n     // and pass it in as a first class fn-arg to the iterator.\n \n-    auto iter_body_llty = type_of_fn_full(cx.fcx.lcx.ccx, ast.proto_fn,\n+    auto iter_body_llty = type_of_fn_full(lcx.ccx, ast.proto_fn,\n                                           none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=decl_ty)),\n                                           plain_ty(ty.ty_nil), 0u);\n \n-    let ValueRef lliterbody = decl_internal_fastcall_fn(cx.fcx.lcx.ccx.llmod,\n+    let ValueRef lliterbody = decl_internal_fastcall_fn(lcx.ccx.llmod,\n                                                        s, iter_body_llty);\n \n     // FIXME: handle ty params properly.\n     let vec[ast.ty_param] ty_params = vec();\n \n-    auto fcx = new_fn_ctxt(cx.fcx.lcx, lliterbody);\n+    auto fcx = new_fn_ctxt(lcx, lliterbody);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n@@ -3603,7 +3602,7 @@ fn trans_for_each(@block_ctxt cx,\n \n         case (ast.expr_call(?f, ?args, ?ann)) {\n \n-            auto pair = alloca(cx, T_fn_pair(cx.fcx.lcx.ccx.tn,\n+            auto pair = alloca(cx, T_fn_pair(lcx.ccx.tn,\n                                              iter_body_llty));\n             auto code_cell = cx.build.GEP(pair,\n                                           vec(C_int(0),\n@@ -3613,10 +3612,10 @@ fn trans_for_each(@block_ctxt cx,\n             auto env_cell = cx.build.GEP(pair, vec(C_int(0),\n                                                    C_int(abi.fn_field_box)));\n             auto llenvblobptr = cx.build.PointerCast(llenvptr,\n-                T_opaque_closure_ptr(cx.fcx.lcx.ccx.tn));\n+                T_opaque_closure_ptr(lcx.ccx.tn));\n             cx.build.Store(llenvblobptr, env_cell);\n \n-            // log \"lliterbody: \" + val_str(cx.fcx.lcx.ccx.tn, lliterbody);\n+            // log \"lliterbody: \" + val_str(lcx.ccx.tn, lliterbody);\n             r = trans_call(cx, f,\n                            some[ValueRef](cx.build.Load(pair)),\n                            args,\n@@ -4227,7 +4226,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n     // Construct a thunk-call with signature incoming_fty, and that copies\n     // args forward into a call to outgoing_fty.\n \n-    let str s = mangle_name_by_seq(cx, \"thunk\");\n+    let str s = mangle_name_by_seq(cx.ccx, cx.path, \"thunk\");\n     let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx.ccx, incoming_fty));\n     let ValueRef llthunk = decl_internal_fastcall_fn(cx.ccx.llmod,\n                                                      s, llthunk_ty);\n@@ -5745,6 +5744,17 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     ret res(bcx, r.val);\n }\n \n+fn new_local_ctxt(@crate_ctxt ccx) -> @local_ctxt {\n+    let vec[str] pth = vec();\n+    let vec[ast.ty_param] obj_typarams = vec();\n+    let vec[ast.obj_field] obj_fields = vec();\n+    ret @rec(path=pth,\n+             module_path=vec(crate_name(ccx, \"main\")),\n+             obj_typarams = obj_typarams,\n+             obj_fields = obj_fields,\n+             ccx = ccx);\n+}\n+\n // NB: must keep 4 fns in sync:\n //\n //  - type_of_fn_full\n@@ -6039,7 +6049,7 @@ fn trans_vtbl(@local_ctxt cx,\n         }\n \n         let @local_ctxt mcx = extend_path(cx, m.node.ident);\n-        let str s = mangle_name_by_seq(mcx, \"method\");\n+        let str s = mangle_name_by_seq(mcx.ccx, mcx.path, \"method\");\n         let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s,\n                                                       llfnty);\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n@@ -6051,7 +6061,7 @@ fn trans_vtbl(@local_ctxt cx,\n         methods += vec(llfn);\n     }\n     auto vtbl = C_struct(methods);\n-    auto vtbl_name = mangle_name_by_seq(cx, \"vtbl\");\n+    auto vtbl_name = mangle_name_by_seq(cx.ccx, cx.path, \"vtbl\");\n     auto gvar = llvm.LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl),\n                                    _str.buf(vtbl_name));\n     llvm.LLVMSetInitializer(gvar, vtbl);\n@@ -6078,7 +6088,7 @@ fn trans_dtor(@local_ctxt cx,\n     }\n \n     let @local_ctxt dcx = extend_path(cx, \"drop\");\n-    let str s = mangle_name_by_seq(dcx, \"drop\");\n+    let str s = mangle_name_by_seq(dcx.ccx, dcx.path, \"drop\");\n     let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n     cx.ccx.item_ids.insert(dtor.node.id, llfn);\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n@@ -6382,15 +6392,15 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n     ret llvm.LLVMGetElementType(pair_tys.(0));\n }\n \n-fn decl_fn_and_pair(@local_ctxt cx,\n+fn decl_fn_and_pair(@crate_ctxt ccx,\n+                    vec[str] path,\n                     str flav,\n                     vec[ast.ty_param] ty_params,\n                     &ast.ann ann,\n                     ast.def_id id) {\n \n     auto llfty;\n     auto llpairty;\n-    auto ccx = cx.ccx;\n     alt (node_ann_type(ccx, ann).struct) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             llfty = type_of_fn(ccx, proto, inputs, output,\n@@ -6404,11 +6414,11 @@ fn decl_fn_and_pair(@local_ctxt cx,\n     }\n \n     // Declare the function itself.\n-    let str s = mangle_name_by_seq(cx, flav);\n+    let str s = mangle_name_by_seq(ccx, path, flav);\n     let ValueRef llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n \n     // Declare the global constant pair that points to it.\n-    let str ps = mangle_name_by_type(cx, node_ann_type(ccx, ann));\n+    let str ps = mangle_name_by_type(ccx, path, node_ann_type(ccx, ann));\n \n     register_fn_pair(ccx, ps, llpairty, llfn, id);\n }\n@@ -6458,28 +6468,28 @@ fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, @ty.t x)\n     fail;\n }\n \n-fn decl_native_fn_and_pair(@local_ctxt cx,\n+fn decl_native_fn_and_pair(@crate_ctxt ccx,\n+                           vec[str] path,\n                            str name,\n                            &ast.ann ann,\n                            ast.def_id id) {\n-    auto num_ty_param = native_fn_ty_param_count(cx.ccx, id);\n-    auto ccx = cx.ccx;\n+    auto num_ty_param = native_fn_ty_param_count(ccx, id);\n \n     // Declare the wrapper.\n     auto t = node_ann_type(ccx, ann);\n     auto wrapper_type = native_fn_wrapper_type(ccx, num_ty_param, t);\n-    let str s = mangle_name_by_seq(cx, \"wrapper\");\n+    let str s = mangle_name_by_seq(ccx, path, \"wrapper\");\n     let ValueRef wrapper_fn = decl_internal_fastcall_fn(ccx.llmod, s,\n                                                         wrapper_type);\n \n     // Declare the global constant pair that points to it.\n     auto wrapper_pair_type = T_fn_pair(ccx.tn, wrapper_type);\n-    let str ps = mangle_name_by_type(cx, node_ann_type(ccx, ann));\n+    let str ps = mangle_name_by_type(ccx, path, node_ann_type(ccx, ann));\n \n     register_fn_pair(ccx, ps, wrapper_pair_type, wrapper_fn, id);\n \n     // Build the wrapper.\n-    auto fcx = new_fn_ctxt(cx, wrapper_fn);\n+    auto fcx = new_fn_ctxt(new_local_ctxt(ccx), wrapper_fn);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n@@ -6575,49 +6585,55 @@ fn decl_native_fn_and_pair(@local_ctxt cx,\n     new_builder(fcx.llallocas).Br(lltop);\n }\n \n-fn collect_native_item(&@local_ctxt cx, @ast.native_item i) -> @local_ctxt {\n-    alt (i.node) {\n-        case (ast.native_item_fn(?name, _, _, _, ?fid, ?ann)) {\n-            cx.ccx.native_items.insert(fid, i);\n-            if (!cx.ccx.obj_methods.contains_key(fid)) {\n-                decl_native_fn_and_pair(cx, name, ann, fid);\n-            }\n+type walk_ctxt = rec(mutable vec[str] path);\n+\n+fn enter_item(@walk_ctxt cx, @ast.item item) {\n+    alt (item.node) {\n+        case (ast.item_fn(?name, _, _, _, _)) {\n+            _vec.push[str](cx.path, name);\n         }\n-        case (ast.native_item_ty(_, ?tid)) {\n-            cx.ccx.native_items.insert(tid, i);\n+        case (ast.item_obj(?name, _, _, _, _)) {\n+            _vec.push[str](cx.path, name);\n+        }\n+        case (ast.item_mod(?name, _, _)) {\n+            _vec.push[str](cx.path, name);\n         }\n+        case (_) { }\n     }\n-    ret cx;\n }\n \n-fn item_name(@ast.item i) -> str {\n-    alt (i.node) {\n-        case (ast.item_mod(?name, _, _)) {\n-            ret name;\n-        }\n-        case (ast.item_tag(?name, _, _, _, _)) {\n-            ret name;\n-        }\n-        case (ast.item_const(?name, _, _, _, _)) {\n-            ret name;\n+fn leave_item(@walk_ctxt cx, @ast.item item) {\n+    alt (item.node) {\n+        case (ast.item_fn(_, _, _, _, _)) {\n+            _vec.pop[str](cx.path);\n         }\n-        case (ast.item_fn(?name, _, _, _, _)) {\n-            ret name;\n+        case (ast.item_obj(_, _, _, _, _)) {\n+            _vec.pop[str](cx.path);\n         }\n-        case (ast.item_native_mod(?name, _, _)) {\n-            ret name;\n+        case (ast.item_mod(_, _, _)) {\n+            _vec.pop[str](cx.path);\n         }\n-        case (ast.item_ty(?name, _, _, _, _)) {\n-            ret name;\n+        case (_) { }\n+    }\n+}\n+\n+fn collect_native_item(@crate_ctxt ccx, @walk_ctxt wcx, @ast.native_item i) {\n+    alt (i.node) {\n+        case (ast.native_item_fn(?name, _, _, _, ?fid, ?ann)) {\n+            ccx.native_items.insert(fid, i);\n+            if (!ccx.obj_methods.contains_key(fid)) {\n+                decl_native_fn_and_pair(ccx, wcx.path, name, ann, fid);\n+            }\n         }\n-        case (ast.item_obj(?name, _, _, _, _)) {\n-            ret name;\n+        case (ast.native_item_ty(_, ?tid)) {\n+            ccx.native_items.insert(tid, i);\n         }\n     }\n }\n \n-fn collect_item(&@local_ctxt cx, @ast.item i) -> @local_ctxt {\n-    auto ccx = cx.ccx;\n+fn collect_item_1(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item i) {\n+    enter_item(wcx, i);\n+\n     alt (i.node) {\n         case (ast.item_const(?name, _, _, ?cid, ?ann)) {\n             auto typ = node_ann_type(ccx, ann);\n@@ -6628,78 +6644,55 @@ fn collect_item(&@local_ctxt cx, @ast.item i) -> @local_ctxt {\n             ccx.items.insert(cid, i);\n             ccx.consts.insert(cid, g);\n         }\n-\n-        case (ast.item_fn(_, _, _, ?did, _)) {\n-            // handled below\n-        }\n-\n         case (ast.item_mod(?name, ?m, ?mid)) {\n             ccx.items.insert(mid, i);\n         }\n-\n-        case (ast.item_native_mod(_, _, _)) {\n-            // empty\n-        }\n-\n         case (ast.item_ty(_, _, _, ?did, _)) {\n             ccx.items.insert(did, i);\n         }\n-\n         case (ast.item_tag(?name, ?variants, ?tps, ?tag_id, _)) {\n             ccx.items.insert(tag_id, i);\n         }\n-\n-        case (ast.item_obj(_, _, _, ?did, _)) {\n-            // handled below\n-        }\n+        case (_) {}\n     }\n-    ret extend_path(cx, item_name(i));\n }\n \n-fn collect_item_pass2(&@local_ctxt cx, @ast.item i) -> @local_ctxt {\n+fn collect_item_2(@crate_ctxt ccx, @walk_ctxt wcx, @ast.item i) {\n+    enter_item(wcx, i);\n+\n     alt (i.node) {\n         case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n-            cx.ccx.items.insert(fid, i);\n-            if (!cx.ccx.obj_methods.contains_key(fid)) {\n-                decl_fn_and_pair(extend_path(cx, name), \"fn\",\n-                                 tps, ann, fid);\n+            ccx.items.insert(fid, i);\n+            if (!ccx.obj_methods.contains_key(fid)) {\n+                decl_fn_and_pair(ccx, wcx.path, \"fn\", tps, ann, fid);\n             }\n         }\n-\n         case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n-            cx.ccx.items.insert(oid.ctor, i);\n-            decl_fn_and_pair(extend_path(cx, name), \"obj_ctor\",\n-                             tps, ann, oid.ctor);\n+            ccx.items.insert(oid.ctor, i);\n+            decl_fn_and_pair(ccx, wcx.path, \"obj_ctor\", tps, ann, oid.ctor);\n             for (@ast.method m in ob.methods) {\n-                cx.ccx.obj_methods.insert(m.node.id, ());\n+                ccx.obj_methods.insert(m.node.id, ());\n             }\n         }\n-\n-        case (_) { /* fall through */ }\n+        case (_) {}\n     }\n-    ret extend_path(cx, item_name(i));\n }\n \n+fn collect_items(@crate_ctxt ccx, @ast.crate crate) {\n+    let vec[str] path = vec();\n+    auto wcx = @rec(mutable path=path);\n \n-fn collect_items(@local_ctxt cx, @ast.crate crate) {\n-\n-    let fold.ast_fold[@local_ctxt] fld =\n-        fold.new_identity_fold[@local_ctxt]();\n-\n-    // FIXME: It might be better to use a worklist for this. An item\n-    // would be added to it if it depends on a not yet seen tag for example.\n-\n-    auto fld1 =\n-        @rec( update_env_for_item = bind collect_item(_,_),\n-              update_env_for_native_item = bind collect_native_item(_,_)\n-              with *fld );\n-\n-    fold.fold_crate[@local_ctxt](cx, fld1, crate);\n-\n-    auto fld2 = @rec( update_env_for_item = bind collect_item_pass2(_,_)\n-                      with *fld );\n-\n-    fold.fold_crate[@local_ctxt](cx, fld2, crate);\n+    auto visitor0 = walk.default_visitor();\n+    auto visitor1 = rec(visit_native_item_pre = \n+                          bind collect_native_item(ccx, wcx, _),\n+                        visit_item_pre = bind collect_item_1(ccx, wcx, _),\n+                        visit_item_post = bind leave_item(wcx, _)\n+                        with visitor0);\n+    auto visitor2 = rec(visit_item_pre = bind collect_item_2(ccx, wcx, _),\n+                        visit_item_post = bind leave_item(wcx, _)\n+                        with visitor0);\n+    walk.walk_crate(visitor1, *crate);\n+    walk.walk_crate(visitor2, *crate);\n }\n \n fn collect_tag_ctor(&@local_ctxt cx, @ast.item i) -> @local_ctxt {\n@@ -6709,7 +6702,7 @@ fn collect_tag_ctor(&@local_ctxt cx, @ast.item i) -> @local_ctxt {\n         case (ast.item_tag(_, ?variants, ?tps, _, _)) {\n             for (ast.variant variant in variants) {\n                 if (_vec.len[ast.variant_arg](variant.node.args) != 0u) {\n-                    decl_fn_and_pair(extend_path(cx, variant.node.name),\n+                    decl_fn_and_pair(cx.ccx, cx.path + vec(variant.node.name),\n                                      \"tag\", tps, variant.node.ann,\n                                      variant.node.id);\n                 }\n@@ -6744,7 +6737,7 @@ fn trans_constant(&@local_ctxt cx, @ast.item it) -> @local_ctxt {\n \n                 auto discrim_val = C_int(i as int);\n \n-                auto s = mangle_name_by_seq(cx,\n+                auto s = mangle_name_by_seq(cx.ccx, cx.path,\n                                             #fmt(\"_rust_tag_discrim_%s_%u\",\n                                                  ident, i));\n                 auto discrim_gvar = llvm.LLVMAddGlobal(cx.ccx.llmod, T_int(),\n@@ -6765,7 +6758,7 @@ fn trans_constant(&@local_ctxt cx, @ast.item it) -> @local_ctxt {\n             // with consts.\n             auto v = C_int(1);\n             cx.ccx.item_ids.insert(cid, v);\n-            auto s = mangle_name_by_type(extend_path(cx, name),\n+            auto s = mangle_name_by_type(cx.ccx, cx.path + vec(name),\n                                          node_ann_type(cx.ccx, ann));\n             cx.ccx.item_symbols.insert(cid, s);\n         }\n@@ -7494,10 +7487,7 @@ fn trans_crate(session.session sess, @ast.crate crate,\n     auto tag_sizes = map.mk_hashmap[@ty.t,uint](hasher, eqer);\n     auto tydescs = map.mk_hashmap[@ty.t,@tydesc_info](hasher, eqer);\n     auto lltypes = map.mk_hashmap[@ty.t,TypeRef](hasher, eqer);\n-    let vec[ast.ty_param] obj_typarams = vec();\n-    let vec[ast.obj_field] obj_fields = vec();\n \n-    let vec[str] pth = vec();\n     auto ccx = @rec(sess = sess,\n                     llmod = llmod,\n                     td = td,\n@@ -7521,17 +7511,12 @@ fn trans_crate(session.session sess, @ast.crate crate,\n                     lltypes = lltypes,\n                     glues = glues,\n                     names = namegen(0),\n-                    path = pth,\n                     sha = std.sha1.mk_sha1());\n-    auto cx = @rec(path=pth,\n-                   module_path=vec(crate_name(ccx, \"main\")),\n-                   obj_typarams = obj_typarams,\n-                   obj_fields = obj_fields,\n-                   ccx = ccx);\n+    auto cx = new_local_ctxt(ccx);\n \n     create_typedefs(ccx);\n \n-    collect_items(cx, crate);\n+    collect_items(ccx, crate);\n     collect_tag_ctors(cx, crate);\n     trans_constants(cx, crate);\n     trans_mod(cx, crate.node.module);"}]}