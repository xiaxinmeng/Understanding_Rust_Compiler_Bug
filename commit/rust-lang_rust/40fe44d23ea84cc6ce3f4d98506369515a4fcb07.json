{"sha": "40fe44d23ea84cc6ce3f4d98506369515a4fcb07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZmU0NGQyM2VhODRjYzZjZTNmNGQ5ODUwNjM2OTUxNWE0ZmNiMDc=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-05-24T01:52:55Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-27T02:42:33Z"}, "message": "\"import module::*;\" now works.", "tree": {"sha": "ee8288126a9a289dc2a884be93787082ae2842bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee8288126a9a289dc2a884be93787082ae2842bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40fe44d23ea84cc6ce3f4d98506369515a4fcb07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40fe44d23ea84cc6ce3f4d98506369515a4fcb07", "html_url": "https://github.com/rust-lang/rust/commit/40fe44d23ea84cc6ce3f4d98506369515a4fcb07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22953f52faa3afb24c7024c0373a4895d9c5859b", "url": "https://api.github.com/repos/rust-lang/rust/commits/22953f52faa3afb24c7024c0373a4895d9c5859b", "html_url": "https://github.com/rust-lang/rust/commit/22953f52faa3afb24c7024c0373a4895d9c5859b"}], "stats": {"total": 232, "additions": 177, "deletions": 55}, "files": [{"sha": "83d6e6bc1fff9d9858d97e0dfc4b4f366201348d", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=40fe44d23ea84cc6ce3f4d98506369515a4fcb07", "patch": "@@ -1,4 +1,3 @@\n-import std::map::hashmap;\n import std::option;\n import std::str;\n import std::vec;"}, {"sha": "e44ea78fc45fec197e1342be21682e6efb48dbbf", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 69, "deletions": 54, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=40fe44d23ea84cc6ce3f4d98506369515a4fcb07", "patch": "@@ -76,17 +76,11 @@ tag mod_index_entry {\n type mod_index = hashmap[ident,list[mod_index_entry]];\n \n type indexed_mod = rec(option::t[ast::_mod] m, \n-                       mod_index index, vec[@i_m] glob_imports);\n+                       mod_index index, vec[def] glob_imports);\n /* native modules can't contain tags, and we don't store their ASTs because we\n    only need to look at them to determine exports, which they can't control.*/\n // It should be safe to use index to memoize lookups of globbed names.\n \n-//FIXME: this only exists because we can't yet write recursive types unless\n-//the recursion passes through a tag.\n-tag i_m {\n-    i_m(indexed_mod);\n-}\n-\n type crate_map = hashmap[uint,ast::crate_num];\n \n type def_map = hashmap[uint,def];\n@@ -144,7 +138,7 @@ fn map_crate(&@env e, &ast::crate c) {\n     // Register the top-level mod\n     e.mod_map.insert(-1, @rec(m=some(c.node.module),\n                               index=index_mod(c.node.module),\n-                              glob_imports=vec::empty[@i_m]()));\n+                              glob_imports=vec::empty[def]()));\n     walk::walk_crate(index_names, c);\n \n     fn index_vi(@env e, @mutable list[scope] sc, &@ast::view_item i) {\n@@ -161,13 +155,13 @@ fn map_crate(&@env e, &ast::crate c) {\n             case (ast::item_mod(_, ?md, ?defid)) {\n                 e.mod_map.insert(defid._1, \n                                  @rec(m=some(md), index=index_mod(md),\n-                                      glob_imports=vec::empty[@i_m]()));\n+                                      glob_imports=vec::empty[def]()));\n             }\n             case (ast::item_native_mod(_, ?nmd, ?defid)) {\n                 e.mod_map.insert(defid._1, \n                                  @rec(m=none[ast::_mod], \n                                       index=index_nmod(nmd),\n-                                      glob_imports=vec::empty[@i_m]()));\n+                                      glob_imports=vec::empty[def]()));\n             }\n             case (_) {}\n         }\n@@ -370,10 +364,8 @@ fn pop_env_for_arm(@mutable list[scope] sc, &ast::arm p) {\n     *sc = std::list::cdr(*sc);\n }\n \n-\n-//HERE\n fn follow_import(&env e, &list[scope] sc, vec[ident] path, &span sp) \n-    -> @i_m {\n+    -> def {\n     auto path_len = vec::len(path);\n     auto dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n     auto i = 1u;\n@@ -385,13 +377,8 @@ fn follow_import(&env e, &list[scope] sc, vec[ident] path, &span sp)\n     }\n \n     alt (dcur) {\n-        case (ast::def_mod(?def_id)) {\n-            //TODO: is this sane?\n-            ret @i_m(*e.mod_map.get(def_id._1));\n-        }\n-        case (ast::def_native_mod(?def_id)) {\n-            ret @i_m(*e.mod_map.get(def_id._1));\n-        }\n+        case (ast::def_mod(?def_id)) { ret dcur; }\n+        case (ast::def_native_mod(?def_id)) { ret dcur; }\n         case (_) {\n             e.sess.span_err(sp, str::connect(path, \"::\") \n                             + \" does not name a module.\");\n@@ -430,9 +417,12 @@ fn resolve_import(&env e, &@ast::view_item it, &list[scope] sc) {\n         while (true) {\n             if (i == n_idents - 1u) {\n                 register(e, defid, it.span, end_id,\n-                         lookup_in_mod(e, dcur, end_id, ns_value, outside),\n-                         lookup_in_mod(e, dcur, end_id, ns_type, outside),\n-                         lookup_in_mod(e, dcur, end_id, ns_module, outside));\n+                         lookup_in_mod(e, dcur, it.span, end_id, ns_value,\n+                                       outside),\n+                         lookup_in_mod(e, dcur, it.span, end_id, ns_type,\n+                                       outside),\n+                         lookup_in_mod(e, dcur, it.span, end_id, ns_module,\n+                                       outside));\n                 break;\n             } else {\n                 dcur = lookup_in_mod_strict(e, dcur, it.span, ids.(i),\n@@ -526,12 +516,12 @@ fn def_is_obj_field(&def d) -> bool {\n \n fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n     -> option::t[def] {\n-    fn in_scope(&env e, &ident id, &scope s, namespace ns)\n+    fn in_scope(&env e, &span sp, &ident id, &scope s, namespace ns)\n         -> option::t[def] {\n         alt (s) {\n             case (scope_crate(?c)) {\n                 auto defid = tup(ast::local_crate, -1);\n-                ret lookup_in_local_mod(e, defid, id, ns, inside);\n+                ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n             }\n             case (scope_item(?it)) {\n                 alt (it.node) {\n@@ -547,10 +537,10 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n                         }\n                     }\n                     case (ast::item_mod(_, _, ?defid)) {\n-                        ret lookup_in_local_mod(e, defid, id, ns, inside);\n+                        ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n                     }\n                     case (ast::item_native_mod(_, ?m, ?defid)) {\n-                        ret lookup_in_local_native_mod(e, defid, id, ns);\n+                        ret lookup_in_local_native_mod(e, defid, sp, id, ns);\n                     }\n                     case (ast::item_ty(_, _, ?ty_params, _, _)) {\n                         if (ns == ns_type) {\n@@ -599,7 +589,7 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n                 ret none[def];\n             }\n             case (cons[scope](?hd, ?tl)) {\n-                auto fnd = in_scope(e, id, hd, ns);\n+                auto fnd = in_scope(e, sp, id, hd, ns);\n                 if (!option::is_none(fnd)) {\n                     auto df = option::get(fnd);\n                     if ((left_fn && def_is_local(df)) ||\n@@ -618,6 +608,7 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n         }\n     }\n     e.sess.bug(\"reached unreachable code in lookup_in_scope\"); // sigh\n+    fail;\n }\n \n fn lookup_in_ty_params(&ident id, &vec[ast::ty_param] ty_params)\n@@ -764,7 +755,7 @@ fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n \n fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id,\n                         namespace ns, dir dr) -> def {\n-    alt (lookup_in_mod(e, m, id, ns, dr)) {\n+    alt (lookup_in_mod(e, m, sp, id, ns, dr)) {\n         case (none[def]) {\n             unresolved(e, sp, id, ns_name(ns));\n             fail;\n@@ -775,10 +766,10 @@ fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id,\n     }\n }\n \n-fn lookup_in_mod(&env e, def m, &ident id, namespace ns, dir dr)\n+fn lookup_in_mod(&env e, def m, &span sp, &ident id, namespace ns, dir dr)\n     -> option::t[def] {\n     auto defid = ast::def_id_of_def(m);\n-    if (defid._0 != ast::local_crate) { // Not in this crate\n+    if (defid._0 != ast::local_crate) { // examining a mod. in an ext. crate\n         auto cached = e.ext_cache.find(tup(defid,id,ns));\n         if (!option::is_none(cached)) { ret cached; }\n         auto path = [id];\n@@ -793,10 +784,10 @@ fn lookup_in_mod(&env e, def m, &ident id, namespace ns, dir dr)\n     }\n     alt (m) {\n         case (ast::def_mod(?defid)) {\n-            ret lookup_in_local_mod(e, defid, id, ns, dr);\n+            ret lookup_in_local_mod(e, defid, sp, id, ns, dr);\n         }\n         case (ast::def_native_mod(?defid)) {\n-            ret lookup_in_local_native_mod(e, defid, id, ns);\n+            ret lookup_in_local_native_mod(e, defid, sp, id, ns);\n         }\n     }\n }\n@@ -811,7 +802,7 @@ fn found_view_item(&env e, @ast::view_item vi, namespace ns)\n             ret lookup_import(e, defid, ns);\n         }\n         case (ast::view_item_import_glob(_, ?defid)) {\n-            ret none[def]; //TODO: think about this. Is it correct?\n+            ret none[def]; //will be handled in the fallback glob pass\n         }\n     }\n }\n@@ -834,29 +825,53 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n     fail;\n }\n \n-fn lookup_in_local_mod(&env e, def_id defid, &ident id, namespace ns,\n-                       dir dr) -> option::t[def] {\n+fn lookup_in_local_mod(&env e, def_id defid, &span sp, &ident id, \n+                       namespace ns, dir dr) -> option::t[def] {\n     auto info = e.mod_map.get(defid._1);\n-    auto found = info.index.find(id);\n-    if (option::is_none(found) || \n-        (dr == outside && !ast::is_exported(id, option::get(info.m)))) {\n+    if (dr == outside && !ast::is_exported(id, option::get(info.m))) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n-        ret none[def];\n+        ret none[def]; // name is not visible\n     }\n-    auto lst = option::get(found);\n-    while (true) {\n-        alt (lst) {\n-            case (nil[mod_index_entry]) {\n-                ret none[def];\n-            }\n-            case (cons[mod_index_entry](?hd, ?tl)) {\n-                auto found = lookup_in_mie(e, hd, ns);\n-                if (!option::is_none(found)) { ret found; }\n-                lst = *tl;\n+    alt(info.index.find(id)) {\n+        case (none[list[mod_index_entry]]) { }\n+        case (some[list[mod_index_entry]](?lst)) {\n+            while (true) {\n+                alt (lst) {\n+                    case (nil[mod_index_entry]) { break; }\n+                    case (cons[mod_index_entry](?hd, ?tl)) {\n+                        auto found = lookup_in_mie(e, hd, ns);\n+                        if (!option::is_none(found)) { ret found; }\n+                        lst = *tl;\n+                    }\n+                }\n             }\n         }\n     }\n-    e.sess.bug(\"reached unreachable code in lookup_in_regular_mod\"); // sigh\n+    // not local or explicitly imported; try globs:\n+    ret lookup_glob_in_mod(e, info, sp, id, ns, dr);\n+}\n+\n+fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id, \n+                      namespace ns, dir dr) -> option::t[def] {\n+    fn l_i_m(&env e, &def d, &span sp, &ident id, namespace ns, dir dr)\n+        -> option::t[def] {\n+        ret lookup_in_mod(e, d, sp, id, ns, dr);\n+    }\n+    auto matches = vec::filter_map\n+        (bind l_i_m(e, _, sp, id, ns, dr), info.glob_imports);\n+    if (vec::len(matches) == 0u) {\n+        ret none[def];\n+    } else if (vec::len(matches) == 1u){\n+        ret some[def](matches.(0));\n+    } else {\n+        for (def d in matches) {\n+            e.sess.span_note(sp, \"'\" + id + \"' is defined at \" + \n+                             util::common::istr(ast::def_id_of_def(d)._1));\n+        }\n+        e.sess.span_err(sp, \"'\" + id + \"' is glob-imported from\" +\n+                        \" multiple different modules.\");\n+        fail;\n+    }\n }\n \n fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns)\n@@ -899,9 +914,9 @@ fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns)\n     ret none[def];\n }\n \n-fn lookup_in_local_native_mod(&env e, def_id defid, &ident id, namespace ns)\n-    -> option::t[def] {\n-    ret lookup_in_local_mod(e, defid, id, ns, inside);\n+fn lookup_in_local_native_mod(&env e, def_id defid, &span sp, &ident id, \n+                              namespace ns) -> option::t[def] {\n+    ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n }\n \n "}, {"sha": "259212f7e1a2ecabe91a528a44f01897ec3a9911", "filename": "src/test/compile-fail/import-glob-0.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs?ref=40fe44d23ea84cc6ce3f4d98506369515a4fcb07", "patch": "@@ -0,0 +1,24 @@\n+mod module_of_many_things {\n+  export f1, f2, f4;\n+  fn f1() {\n+    log \"f1\";\n+  }\n+  fn f2() {\n+    log \"f2\";\n+  }\n+  fn f3() {\n+    log \"f3\";\n+  }\n+  fn f4() {\n+    log \"f4\";\n+  }\n+}\n+\n+import module_of_many_things::*;\n+\n+fn main() {\n+  f1();\n+  f2();\n+  f3();\n+  f4();\n+}\n\\ No newline at end of file"}, {"sha": "d52c24641adaae46c9213b686a3ed7390c77ef2c", "filename": "src/test/run-pass/import-glob-0.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs?ref=40fe44d23ea84cc6ce3f4d98506369515a4fcb07", "patch": "@@ -0,0 +1,49 @@\n+import module_of_many_things::*;\n+import dug::too::greedily::and::too::deep::*;\n+\n+mod module_of_many_things {\n+  export f1;\n+  export f2;\n+  export f4;\n+  fn f1() {\n+    log \"f1\";\n+  }\n+  fn f2() {\n+    log \"f2\";\n+  }\n+  fn f3() {\n+    log \"f3\";\n+  }\n+  fn f4() {\n+    log \"f4\";\n+  }\n+}\n+\n+mod dug {\n+  mod too {\n+    mod greedily {\n+      mod and {\n+        mod too {\n+          mod deep {\n+            fn nameless_fear() {\n+              log \"Boo!\";\n+            }\n+            fn also_redstone() {\n+              log \"Whatever.\";\n+            }\n+            fn f1() {}\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\n+fn main() {\n+  f1();\n+  f2();\n+  f4();\n+  nameless_fear();\n+  also_redstone();\n+}\n\\ No newline at end of file"}, {"sha": "d02ca19f6d5e8752cff32a3a0336d3152c8776d1", "filename": "src/test/run-pass/import-glob-1.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs?ref=40fe44d23ea84cc6ce3f4d98506369515a4fcb07", "patch": "@@ -0,0 +1,26 @@\n+import a1:b1::word_traveler;\n+\n+mod a1 {                    // \n+  mod b1 {                  // \n+    import a2::b1::*;       //         <-\\ \n+  }                         //           |\n+  mod b2 {                  //           |\n+    import a2::b2::*;       // <-\\  -\\   |\n+  }                         //   |   |   |\n+}                           //   |   |   |\n+                            //   |   |   |\n+mod a2 {                    //   |   |   |\n+  native mod b1 {           //   |   |   |\n+    import a1::b2::*;       //   | <-/  -/\n+  }                         //   |\n+  mod b2 {                  //   |\n+    fn word_traveler() {    //   |\n+      log \"ahoy!\";          //  -/\n+    }                       //\n+  }                         //\n+}                           //\n+\n+\n+fn main() {\n+  word_traveler();\n+}\n\\ No newline at end of file"}, {"sha": "8c852f413f5b59137d82d42736bb1d01a5ad222c", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fe44d23ea84cc6ce3f4d98506369515a4fcb07/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=40fe44d23ea84cc6ce3f4d98506369515a4fcb07", "patch": "@@ -0,0 +1,9 @@\n+\n+use std;\n+import std::vec::*;\n+\n+fn main() {\n+  auto v = empty[int]();\n+  v += [4,2];\n+  assert(reversed(v) == [2,4]);\n+}\n\\ No newline at end of file"}]}