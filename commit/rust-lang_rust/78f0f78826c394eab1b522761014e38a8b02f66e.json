{"sha": "78f0f78826c394eab1b522761014e38a8b02f66e", "node_id": "C_kwDOAAsO6NoAKDc4ZjBmNzg4MjZjMzk0ZWFiMWI1MjI3NjEwMTRlMzhhOGIwMmY2NmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-04T23:37:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-04T23:37:00Z"}, "message": "Auto merge of #10445 - samueltardieu:lintcheck-maintenance, r=llogiq\n\nLintcheck maintenance\n\nMake `cargo lintcheck -j 0` use all threads instead of panicking, and cleanup (and shorten) lintcheck's parsing code.\n\nchangelog: none", "tree": {"sha": "875d8fdc327348bcd5c55943098eed2d01b286e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/875d8fdc327348bcd5c55943098eed2d01b286e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78f0f78826c394eab1b522761014e38a8b02f66e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78f0f78826c394eab1b522761014e38a8b02f66e", "html_url": "https://github.com/rust-lang/rust/commit/78f0f78826c394eab1b522761014e38a8b02f66e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78f0f78826c394eab1b522761014e38a8b02f66e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2500f960fc72b19a231334e43ac88a8032dd4528", "url": "https://api.github.com/repos/rust-lang/rust/commits/2500f960fc72b19a231334e43ac88a8032dd4528", "html_url": "https://github.com/rust-lang/rust/commit/2500f960fc72b19a231334e43ac88a8032dd4528"}, {"sha": "79829d8718626b681d26bfbd64182d5d32d2dc57", "url": "https://api.github.com/repos/rust-lang/rust/commits/79829d8718626b681d26bfbd64182d5d32d2dc57", "html_url": "https://github.com/rust-lang/rust/commit/79829d8718626b681d26bfbd64182d5d32d2dc57"}], "stats": {"total": 151, "additions": 45, "deletions": 106}, "files": [{"sha": "dbfeb8dd1d194d5aadfb07423f29deefd7f27796", "filename": "lintcheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78f0f78826c394eab1b522761014e38a8b02f66e/lintcheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78f0f78826c394eab1b522761014e38a8b02f66e/lintcheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FCargo.toml?ref=78f0f78826c394eab1b522761014e38a8b02f66e", "patch": "@@ -11,7 +11,7 @@ publish = false\n \n [dependencies]\n cargo_metadata = \"0.15.3\"\n-clap = \"4.1.4\"\n+clap = { version = \"4.1.8\", features = [\"derive\", \"env\"] }\n crossbeam-channel = \"0.5.6\"\n flate2 = \"1.0\"\n rayon = \"1.5.1\""}, {"sha": "e1836c19aa257f9f3e06904db701c6cf2d3839a5", "filename": "lintcheck/src/config.rs", "status": "modified", "additions": 44, "deletions": 105, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/78f0f78826c394eab1b522761014e38a8b02f66e/lintcheck%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f0f78826c394eab1b522761014e38a8b02f66e/lintcheck%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fconfig.rs?ref=78f0f78826c394eab1b522761014e38a8b02f66e", "patch": "@@ -1,131 +1,70 @@\n-use clap::{Arg, ArgAction, ArgMatches, Command};\n-use std::env;\n+use clap::Parser;\n use std::path::PathBuf;\n \n-fn get_clap_config() -> ArgMatches {\n-    Command::new(\"lintcheck\")\n-        .about(\"run clippy on a set of crates and check output\")\n-        .args([\n-            Arg::new(\"only\")\n-                .action(ArgAction::Set)\n-                .value_name(\"CRATE\")\n-                .long(\"only\")\n-                .help(\"Only process a single crate of the list\"),\n-            Arg::new(\"crates-toml\")\n-                .action(ArgAction::Set)\n-                .value_name(\"CRATES-SOURCES-TOML-PATH\")\n-                .long(\"crates-toml\")\n-                .help(\"Set the path for a crates.toml where lintcheck should read the sources from\"),\n-            Arg::new(\"threads\")\n-                .action(ArgAction::Set)\n-                .value_name(\"N\")\n-                .value_parser(clap::value_parser!(usize))\n-                .short('j')\n-                .long(\"jobs\")\n-                .help(\"Number of threads to use, 0 automatic choice\"),\n-            Arg::new(\"fix\")\n-                .long(\"fix\")\n-                .help(\"Runs cargo clippy --fix and checks if all suggestions apply\"),\n-            Arg::new(\"filter\")\n-                .long(\"filter\")\n-                .action(ArgAction::Append)\n-                .value_name(\"clippy_lint_name\")\n-                .help(\"Apply a filter to only collect specified lints, this also overrides `allow` attributes\"),\n-            Arg::new(\"markdown\")\n-                .long(\"markdown\")\n-                .help(\"Change the reports table to use markdown links\"),\n-            Arg::new(\"recursive\")\n-                .long(\"recursive\")\n-                .help(\"Run clippy on the dependencies of crates specified in crates-toml\")\n-                .conflicts_with(\"threads\")\n-                .conflicts_with(\"fix\"),\n-        ])\n-        .get_matches()\n-}\n-\n-#[derive(Debug, Clone)]\n+#[derive(Clone, Debug, Parser)]\n pub(crate) struct LintcheckConfig {\n-    /// max number of jobs to spawn (default 1)\n+    /// Number of threads to use, 0 automatic choice\n+    #[clap(long = \"jobs\", short = 'j', value_name = \"N\", default_value_t = 1)]\n     pub max_jobs: usize,\n-    /// we read the sources to check from here\n+    /// Set the path for a crates.toml where lintcheck should read the sources from\n+    #[clap(\n+        long = \"crates-toml\",\n+        value_name = \"CRATES-SOURCES-TOML-PATH\",\n+        default_value = \"lintcheck/lintcheck_crates.toml\",\n+        hide_default_value = true,\n+        env = \"LINTCHECK_TOML\",\n+        hide_env = true\n+    )]\n     pub sources_toml_path: PathBuf,\n-    /// we save the clippy lint results here\n-    pub lintcheck_results_path: PathBuf,\n-    /// Check only a specified package\n+    /// File to save the clippy lint results here\n+    #[clap(skip = \"\")]\n+    pub lintcheck_results_path: PathBuf, // Overridden in new()\n+    /// Only process a single crate on the list\n+    #[clap(long, value_name = \"CRATE\")]\n     pub only: Option<String>,\n-    /// whether to just run --fix and not collect all the warnings\n+    /// Runs cargo clippy --fix and checks if all suggestions apply\n+    #[clap(long, conflicts_with(\"max_jobs\"))]\n     pub fix: bool,\n-    /// A list of lints that this lintcheck run should focus on\n+    /// Apply a filter to only collect specified lints, this also overrides `allow` attributes\n+    #[clap(long = \"filter\", value_name = \"clippy_lint_name\", use_value_delimiter = true)]\n     pub lint_filter: Vec<String>,\n-    /// Indicate if the output should support markdown syntax\n+    /// Change the reports table to use markdown links\n+    #[clap(long)]\n     pub markdown: bool,\n-    /// Run clippy on the dependencies of crates\n+    /// Run clippy on the dependencies of crates specified in crates-toml\n+    #[clap(long, conflicts_with(\"max_jobs\"))]\n     pub recursive: bool,\n }\n \n impl LintcheckConfig {\n     pub fn new() -> Self {\n-        let clap_config = get_clap_config();\n-\n-        // first, check if we got anything passed via the LINTCHECK_TOML env var,\n-        // if not, ask clap if we got any value for --crates-toml  <foo>\n-        // if not, use the default \"lintcheck/lintcheck_crates.toml\"\n-        let sources_toml = env::var(\"LINTCHECK_TOML\").unwrap_or_else(|_| {\n-            clap_config\n-                .get_one::<String>(\"crates-toml\")\n-                .map_or(\"lintcheck/lintcheck_crates.toml\", |s| &**s)\n-                .into()\n-        });\n-\n-        let markdown = clap_config.contains_id(\"markdown\");\n-        let sources_toml_path = PathBuf::from(sources_toml);\n+        let mut config = LintcheckConfig::parse();\n \n         // for the path where we save the lint results, get the filename without extension (so for\n         // wasd.toml, use \"wasd\"...)\n-        let filename: PathBuf = sources_toml_path.file_stem().unwrap().into();\n-        let lintcheck_results_path = PathBuf::from(format!(\n+        let filename: PathBuf = config.sources_toml_path.file_stem().unwrap().into();\n+        config.lintcheck_results_path = PathBuf::from(format!(\n             \"lintcheck-logs/{}_logs.{}\",\n             filename.display(),\n-            if markdown { \"md\" } else { \"txt\" }\n+            if config.markdown { \"md\" } else { \"txt\" }\n         ));\n \n-        // look at the --threads arg, if 0 is passed, ask rayon rayon how many threads it would spawn and\n-        // use half of that for the physical core count\n-        // by default use a single thread\n-        let max_jobs = match clap_config.get_one::<usize>(\"threads\") {\n-            Some(&0) => {\n-                // automatic choice\n-                // Rayon seems to return thread count so half that for core count\n-                rayon::current_num_threads() / 2\n-            },\n-            Some(&threads) => threads,\n-            // no -j passed, use a single thread\n-            None => 1,\n+        // look at the --threads arg, if 0 is passed, use the threads count\n+        if config.max_jobs == 0 {\n+            // automatic choice\n+            config.max_jobs = std::thread::available_parallelism().map_or(1, |n| n.get());\n         };\n \n-        let lint_filter: Vec<String> = clap_config\n-            .get_many::<String>(\"filter\")\n-            .map(|iter| {\n-                iter.map(|lint_name| {\n-                    let mut filter = lint_name.replace('_', \"-\");\n-                    if !filter.starts_with(\"clippy::\") {\n-                        filter.insert_str(0, \"clippy::\");\n-                    }\n-                    filter\n-                })\n-                .collect()\n-            })\n-            .unwrap_or_default();\n-\n-        LintcheckConfig {\n-            max_jobs,\n-            sources_toml_path,\n-            lintcheck_results_path,\n-            only: clap_config.get_one::<String>(\"only\").map(String::from),\n-            fix: clap_config.contains_id(\"fix\"),\n-            lint_filter,\n-            markdown,\n-            recursive: clap_config.contains_id(\"recursive\"),\n+        for lint_name in &mut config.lint_filter {\n+            *lint_name = format!(\n+                \"clippy::{}\",\n+                lint_name\n+                    .strip_prefix(\"clippy::\")\n+                    .unwrap_or(lint_name)\n+                    .replace('_', \"-\")\n+            );\n         }\n+\n+        config\n     }\n }"}]}