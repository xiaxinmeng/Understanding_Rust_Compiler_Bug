{"sha": "53c639184cbbdb95d316cb36691a2f9722dfc41a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYzYzOTE4NGNiYmRiOTVkMzE2Y2IzNjY5MWEyZjk3MjJkZmM0MWE=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-27T16:19:04Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-27T16:19:04Z"}, "message": "doc: Main example for TreeMap.", "tree": {"sha": "7d358659b250cb48f50b2c08196b1b5574102bfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d358659b250cb48f50b2c08196b1b5574102bfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53c639184cbbdb95d316cb36691a2f9722dfc41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53c639184cbbdb95d316cb36691a2f9722dfc41a", "html_url": "https://github.com/rust-lang/rust/commit/53c639184cbbdb95d316cb36691a2f9722dfc41a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53c639184cbbdb95d316cb36691a2f9722dfc41a/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c34a97b37a2f546490546c5cac97c9add8a2972", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c34a97b37a2f546490546c5cac97c9add8a2972", "html_url": "https://github.com/rust-lang/rust/commit/8c34a97b37a2f546490546c5cac97c9add8a2972"}], "stats": {"total": 101, "additions": 101, "deletions": 0}, "files": [{"sha": "5a39a34671aa32303cd09baeea7c7c6a1ca4fd84", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/53c639184cbbdb95d316cb36691a2f9722dfc41a/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c639184cbbdb95d316cb36691a2f9722dfc41a/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=53c639184cbbdb95d316cb36691a2f9722dfc41a", "patch": "@@ -47,6 +47,107 @@ use vec::Vec;\n /// a red-black tree where red (horizontal) nodes can only be added\n /// as a right child. The time complexity is the same, and re-balancing\n /// operations are more frequent but also cheaper.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::TreeMap;\n+///\n+/// let mut map = TreeMap::new();\n+///\n+/// map.insert(2i, \"bar\");\n+/// map.insert(1i, \"foo\");\n+/// map.insert(3i, \"quux\");\n+///\n+/// // In ascending order by keys\n+/// for (key, value) in map.iter() {\n+///     println!(\"{}: {}\", key, value);\n+/// }\n+///\n+/// // Print 1, 2, 3\n+/// for key in map.keys() {\n+///     println!(\"{}\", key);\n+/// }\n+///\n+/// // Print `foo`, `bar`, `quux`\n+/// for key in map.values() {\n+///     println!(\"{}\", key);\n+/// }\n+///\n+/// map.remove(&1);\n+/// assert_eq!(map.len(), 2);\n+///\n+/// if !map.contains_key(&1) {\n+///     println!(\"1 is no more\");\n+/// }\n+///\n+/// for key in range(0, 4) {\n+///     match map.find(&key) {\n+///         Some(val) => println!(\"{} has a value: {}\", key, val),\n+///         None => println!(\"{} not in map\", key),\n+///     }\n+/// }\n+///\n+/// map.clear();\n+/// assert!(map.is_empty());\n+/// ```\n+///\n+/// The easiest way to use `TreeMap` with a custom type as keys is to implement `Ord`.\n+/// We must also implement `PartialEq`, `Eq` and `PartialOrd`.\n+///\n+/// ```\n+/// use std::collections::TreeMap;\n+///\n+/// // We need `Eq` and `PartialEq`, these can be derived.\n+/// #[deriving(Eq, PartialEq)]\n+/// struct Troll<'a> {\n+///     name: &'a str,\n+///     level: uint,\n+/// }\n+///\n+/// // Implement `Ord` and sort trolls by level.\n+/// impl<'a> Ord for Troll<'a> {\n+///     fn cmp(&self, other: &Troll) -> Ordering {\n+///         // If we swap `self` and `other`, we get descended ordering.\n+///         self.level.cmp(&other.level)\n+///     }\n+/// }\n+///\n+/// // `PartialOrd` needs to be implemented as well.\n+/// impl<'a> PartialOrd for Troll<'a> {\n+///     fn partial_cmp(&self, other: &Troll) -> Option<Ordering> {\n+///         Some(self.cmp(other))\n+///     }\n+/// }\n+///\n+/// // Use a map to store trolls, sorted by level, and track a list of\n+/// // heroes slain.\n+/// let mut trolls = TreeMap::new();\n+///\n+/// trolls.insert(Troll { name: \"Orgarr\", level: 2 },\n+///               vec![\"King Karl\"]);\n+/// trolls.insert(Troll { name: \"Blargarr\", level: 3 },\n+///               vec![\"Odd\"]);\n+/// trolls.insert(Troll { name: \"Kron the Smelly One\", level: 4 },\n+///               vec![\"Omar the Brave\", \"Peter: Slayer of Trolls\"]);\n+/// trolls.insert(Troll { name: \"Wartilda\", level: 1 },\n+///               vec![]);\n+///\n+/// println!(\"You are facing {} trolls!\", trolls.len());\n+///\n+/// // Print the trolls, ordered by level with smallest level first\n+/// for (troll, heroes) in trolls.iter() {\n+///     let what = if heroes.len() == 1u { \"hero\" }\n+///                else { \"heroes\" };\n+///\n+///     println!(\"level {}: '{}' has slain {} {}\",\n+///              troll.level, troll.name, heroes.len(), what);\n+/// }\n+///\n+/// // Kill all trolls\n+/// trolls.clear();\n+/// assert_eq!(trolls.len(), 0);\n+/// ```\n \n // Future improvements:\n "}]}