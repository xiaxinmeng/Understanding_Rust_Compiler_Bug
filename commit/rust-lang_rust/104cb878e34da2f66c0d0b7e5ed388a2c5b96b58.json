{"sha": "104cb878e34da2f66c0d0b7e5ed388a2c5b96b58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNGNiODc4ZTM0ZGEyZjY2YzBkMGI3ZTVlZDM4OGEyYzViOTZiNTg=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-11T19:42:39Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-27T18:15:46Z"}, "message": "add `PredicateKint`, because who doesn't like bodging", "tree": {"sha": "e0e8a47dd7699ea55d2b68d7871383111b2d0c08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0e8a47dd7699ea55d2b68d7871383111b2d0c08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58", "html_url": "https://github.com/rust-lang/rust/commit/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52d2c7ac948d6abdc18eb9e05a53d03ddcaffd98", "url": "https://api.github.com/repos/rust-lang/rust/commits/52d2c7ac948d6abdc18eb9e05a53d03ddcaffd98", "html_url": "https://github.com/rust-lang/rust/commit/52d2c7ac948d6abdc18eb9e05a53d03ddcaffd98"}], "stats": {"total": 203, "additions": 200, "deletions": 3}, "files": [{"sha": "08620f82536e2cdd1849a1217215d316eb89b673", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=104cb878e34da2f66c0d0b7e5ed388a2c5b96b58", "patch": "@@ -19,7 +19,7 @@ use crate::ty::TyKind::*;\n use crate::ty::{\n     self, query, AdtDef, AdtKind, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n     DefIdTree, ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy,\n-    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n+    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKint,\n     ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar,\n     TyVid, TypeAndMut,\n };\n@@ -79,6 +79,7 @@ pub struct CtxtInterners<'tcx> {\n     region: InternedSet<'tcx, RegionKind>,\n     existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n     predicate: InternedSet<'tcx, PredicateInner<'tcx>>,\n+    predicate_kint: InternedSet<'tcx, PredicateKint<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n@@ -98,11 +99,11 @@ impl<'tcx> CtxtInterners<'tcx> {\n             existential_predicates: Default::default(),\n             canonical_var_infos: Default::default(),\n             predicate: Default::default(),\n+            predicate_kint: Default::default(),\n             predicates: Default::default(),\n             projs: Default::default(),\n             place_elems: Default::default(),\n             const_: Default::default(),\n-\n             chalk_environment_clause_list: Default::default(),\n         }\n     }\n@@ -1616,6 +1617,7 @@ nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n+nop_lift! {predicate_kint; &'a PredicateKint<'a> => &'tcx PredicateKint<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {existential_predicates; ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n@@ -2034,6 +2036,12 @@ impl<'tcx> Borrow<PredicateKind<'tcx>> for Interned<'tcx, PredicateKind<'tcx>> {\n     }\n }\n \n+impl<'tcx> Borrow<PredicateKint<'tcx>> for Interned<'tcx, PredicateKint<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a PredicateKint<'tcx> {\n+        &self.0\n+    }\n+}\n+\n macro_rules! direct_interners {\n     ($($name:ident: $method:ident($ty:ty),)+) => {\n         $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n@@ -2063,6 +2071,7 @@ macro_rules! direct_interners {\n direct_interners! {\n     region: mk_region(RegionKind),\n     const_: mk_const(Const<'tcx>),\n+    predicate_kint: intern_predicate_kint(PredicateKint<'tcx>),\n }\n \n macro_rules! slice_interners {\n@@ -2128,7 +2137,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline]\n-    pub fn mk_ty(&self, st: TyKind<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ty(self, st: TyKind<'tcx>) -> Ty<'tcx> {\n         self.interners.intern_ty(st)\n     }\n "}, {"sha": "36796e94973fa701416f707ba9b03054fe18b8c0", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=104cb878e34da2f66c0d0b7e5ed388a2c5b96b58", "patch": "@@ -1063,6 +1063,113 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n \n         kind.hash_stable(hcx, hasher);\n     }\n+\n+    pub fn kint(self, tcx: TyCtxt<'tcx>) -> &'tcx PredicateKint<'tcx> {\n+        // I am efficient\n+        tcx.intern_predicate_kint(match *self.kind() {\n+            PredicateKind::Trait(binder, data) => {\n+                if let Some(simpl) = binder.no_bound_vars() {\n+                    PredicateKint::Trait(simpl, data)\n+                } else {\n+                    let inner = tcx\n+                        .intern_predicate_kint(PredicateKint::Trait(*binder.skip_binder(), data));\n+                    PredicateKint::ForAll(Binder::bind(inner))\n+                }\n+            }\n+            PredicateKind::RegionOutlives(binder) => {\n+                if let Some(simpl) = binder.no_bound_vars() {\n+                    PredicateKint::RegionOutlives(simpl)\n+                } else {\n+                    let inner = tcx.intern_predicate_kint(PredicateKint::RegionOutlives(\n+                        *binder.skip_binder(),\n+                    ));\n+                    PredicateKint::ForAll(Binder::bind(inner))\n+                }\n+            }\n+            PredicateKind::TypeOutlives(binder) => {\n+                if let Some(simpl) = binder.no_bound_vars() {\n+                    PredicateKint::TypeOutlives(simpl)\n+                } else {\n+                    let inner = tcx\n+                        .intern_predicate_kint(PredicateKint::TypeOutlives(*binder.skip_binder()));\n+                    PredicateKint::ForAll(Binder::bind(inner))\n+                }\n+            }\n+            PredicateKind::Projection(binder) => {\n+                if let Some(simpl) = binder.no_bound_vars() {\n+                    PredicateKint::Projection(simpl)\n+                } else {\n+                    let inner =\n+                        tcx.intern_predicate_kint(PredicateKint::Projection(*binder.skip_binder()));\n+                    PredicateKint::ForAll(Binder::bind(inner))\n+                }\n+            }\n+            PredicateKind::WellFormed(arg) => PredicateKint::WellFormed(arg),\n+            PredicateKind::ObjectSafe(def_id) => PredicateKint::ObjectSafe(def_id),\n+            PredicateKind::ClosureKind(def_id, substs, kind) => {\n+                PredicateKint::ClosureKind(def_id, substs, kind)\n+            }\n+            PredicateKind::Subtype(binder) => {\n+                if let Some(simpl) = binder.no_bound_vars() {\n+                    PredicateKint::Subtype(simpl)\n+                } else {\n+                    let inner =\n+                        tcx.intern_predicate_kint(PredicateKint::Subtype(*binder.skip_binder()));\n+                    PredicateKint::ForAll(Binder::bind(inner))\n+                }\n+            }\n+            PredicateKind::ConstEvaluatable(def, substs) => {\n+                PredicateKint::ConstEvaluatable(def, substs)\n+            }\n+            PredicateKind::ConstEquate(l, r) => PredicateKint::ConstEquate(l, r),\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(TypeFoldable)]\n+pub enum PredicateKint<'tcx> {\n+    /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n+    /// the `Self` type of the trait reference and `A`, `B`, and `C`\n+    /// would be the type parameters.\n+    ///\n+    /// A trait predicate will have `Constness::Const` if it originates\n+    /// from a bound on a `const fn` without the `?const` opt-out (e.g.,\n+    /// `const fn foobar<Foo: Bar>() {}`).\n+    Trait(TraitPredicate<'tcx>, Constness),\n+\n+    /// `where 'a: 'b`\n+    RegionOutlives(RegionOutlivesPredicate<'tcx>),\n+\n+    /// `where T: 'a`\n+    TypeOutlives(TypeOutlivesPredicate<'tcx>),\n+\n+    /// `where <T as TraitRef>::Name == X`, approximately.\n+    /// See the `ProjectionPredicate` struct for details.\n+    Projection(ProjectionPredicate<'tcx>),\n+\n+    /// No syntax: `T` well-formed.\n+    WellFormed(GenericArg<'tcx>),\n+\n+    /// Trait must be object-safe.\n+    ObjectSafe(DefId),\n+\n+    /// No direct syntax. May be thought of as `where T: FnFoo<...>`\n+    /// for some substitutions `...` and `T` being a closure type.\n+    /// Satisfied (or refuted) once we know the closure's kind.\n+    ClosureKind(DefId, SubstsRef<'tcx>, ClosureKind),\n+\n+    /// `T1 <: T2`\n+    Subtype(SubtypePredicate<'tcx>),\n+\n+    /// Constant initializer must evaluate successfully.\n+    ConstEvaluatable(DefId, SubstsRef<'tcx>),\n+\n+    /// Constants must be equal. The first component is the const that is expected.\n+    ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n+\n+    /// `for<'a>: ...`\n+    ForAll(Binder<&'tcx PredicateKint<'tcx>>),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -1349,6 +1456,76 @@ impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n     }\n }\n \n+impl ToPredicate<'tcx> for PredicateKint<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        let (predicate, in_binder) = if let PredicateKint::ForAll(binder) = self {\n+            (*binder.skip_binder(), true)\n+        } else {\n+            (self, false)\n+        };\n+\n+        macro_rules! bind {\n+            ($expr:expr) => {\n+                match $expr {\n+                    expr => {\n+                        if in_binder {\n+                            Binder::bind(expr)\n+                        } else {\n+                            Binder::dummy(expr)\n+                        }\n+                    }\n+                }\n+            };\n+        }\n+\n+        match *predicate {\n+            PredicateKint::ForAll(_) => bug!(\"unexpected PredicateKint: {:?}\", self),\n+            PredicateKint::Trait(data, ct) => PredicateKind::Trait(bind!(data), ct),\n+            PredicateKint::RegionOutlives(data) => PredicateKind::RegionOutlives(bind!(data)),\n+            PredicateKint::TypeOutlives(data) => PredicateKind::TypeOutlives(bind!(data)),\n+            PredicateKint::Projection(data) => PredicateKind::Projection(bind!(data)),\n+            PredicateKint::WellFormed(arg) => {\n+                if in_binder {\n+                    bug!(\"unexpected ForAll: {:?}\", self)\n+                } else {\n+                    PredicateKind::WellFormed(arg)\n+                }\n+            }\n+            PredicateKint::ObjectSafe(def_id) => {\n+                if in_binder {\n+                    bug!(\"unexpected ForAll: {:?}\", self)\n+                } else {\n+                    PredicateKind::ObjectSafe(def_id)\n+                }\n+            }\n+            PredicateKint::ClosureKind(def_id, substs, kind) => {\n+                if in_binder {\n+                    bug!(\"unexpected ForAll: {:?}\", self)\n+                } else {\n+                    PredicateKind::ClosureKind(def_id, substs, kind)\n+                }\n+            }\n+            PredicateKint::Subtype(data) => PredicateKind::Subtype(bind!(data)),\n+            PredicateKint::ConstEvaluatable(def_id, substs) => {\n+                if in_binder {\n+                    bug!(\"unexpected ForAll: {:?}\", self)\n+                } else {\n+                    PredicateKind::ConstEvaluatable(def_id, substs)\n+                }\n+            }\n+            PredicateKint::ConstEquate(l, r) => {\n+                if in_binder {\n+                    bug!(\"unexpected ForAll: {:?}\", self)\n+                } else {\n+                    PredicateKind::ConstEquate(l, r)\n+                }\n+            }\n+        }\n+        .to_predicate(tcx)\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         ty::PredicateKind::Trait("}, {"sha": "31d221288bbd686f38f1bb58d2eb42a660b951e5", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=104cb878e34da2f66c0d0b7e5ed388a2c5b96b58", "patch": "@@ -1028,6 +1028,17 @@ impl<T: TypeVisitor<'tcx>> PredicateVisitor<'tcx> for T {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::PredicateKint<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let new = ty::PredicateKint::super_fold_with(self, folder);\n+        folder.tcx().intern_predicate_kint(new)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        ty::PredicateKint::super_visit_with(self, visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         fold_list(*self, folder, |tcx, v| tcx.intern_predicates(v))"}]}