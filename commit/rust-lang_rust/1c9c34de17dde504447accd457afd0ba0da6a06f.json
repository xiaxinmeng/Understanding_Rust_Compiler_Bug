{"sha": "1c9c34de17dde504447accd457afd0ba0da6a06f", "node_id": "C_kwDOAAsO6NoAKDFjOWMzNGRlMTdkZGU1MDQ0NDdhY2NkNDU3YWZkMGJhMGRhNmEwNmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-18T09:31:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-18T09:31:20Z"}, "message": "Auto merge of #9858 - DesmondWillowbrook:never_loop, r=dswij\n\n`never_loop`: don't emit AlwaysBreaks if it targets a block\n\nref: https://github.com/rust-lang/rust-clippy/pull/9837#issuecomment-1312788194\n\nThe previous fix (#9837) was too simple and ignored all break commands inside a labelled block, regardless of whether their destination was a labelled block or a loop. This fix tracks all the labelled blocks in scope to ensure that only breaks targeting loops are considered.\n\nchangelog: [`never_loop`]: prevent false negatives from `breaks` nested in labelled blocks", "tree": {"sha": "d521c25cf2c1116a60444985820ebb609dfb5043", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d521c25cf2c1116a60444985820ebb609dfb5043"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c9c34de17dde504447accd457afd0ba0da6a06f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c9c34de17dde504447accd457afd0ba0da6a06f", "html_url": "https://github.com/rust-lang/rust/commit/1c9c34de17dde504447accd457afd0ba0da6a06f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c9c34de17dde504447accd457afd0ba0da6a06f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dac600e32fce89cb4b05ae6edb0c47982b99eb48", "url": "https://api.github.com/repos/rust-lang/rust/commits/dac600e32fce89cb4b05ae6edb0c47982b99eb48", "html_url": "https://github.com/rust-lang/rust/commit/dac600e32fce89cb4b05ae6edb0c47982b99eb48"}, {"sha": "bc3cd344a1edefdea8eef7962d75bb35cdeea880", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc3cd344a1edefdea8eef7962d75bb35cdeea880", "html_url": "https://github.com/rust-lang/rust/commit/bc3cd344a1edefdea8eef7962d75bb35cdeea880"}], "stats": {"total": 140, "additions": 94, "deletions": 46}, "files": [{"sha": "14f161f51026526a1cfe63bd0aaae6b6e915c23c", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 71, "deletions": 44, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/1c9c34de17dde504447accd457afd0ba0da6a06f/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c9c34de17dde504447accd457afd0ba0da6a06f/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=1c9c34de17dde504447accd457afd0ba0da6a06f", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, Pat, Stmt, StmtKind};\n+use rustc_hir::{Block, Destination, Expr, ExprKind, HirId, InlineAsmOperand, Pat, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_span::Span;\n use std::iter::{once, Iterator};\n@@ -16,7 +16,7 @@ pub(super) fn check(\n     span: Span,\n     for_loop: Option<&ForLoop<'_>>,\n ) {\n-    match never_loop_block(block, loop_id) {\n+    match never_loop_block(block, &mut Vec::new(), loop_id) {\n         NeverLoopResult::AlwaysBreak => {\n             span_lint_and_then(cx, NEVER_LOOP, span, \"this loop never actually loops\", |diag| {\n                 if let Some(ForLoop {\n@@ -92,35 +92,34 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n     }\n }\n \n-fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n-    let mut iter = block\n+fn never_loop_block(block: &Block<'_>, ignore_ids: &mut Vec<HirId>, main_loop_id: HirId) -> NeverLoopResult {\n+    let iter = block\n         .stmts\n         .iter()\n         .filter_map(stmt_to_expr)\n         .chain(block.expr.map(|expr| (expr, None)));\n-    never_loop_expr_seq(&mut iter, main_loop_id)\n-}\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item = (&'a Expr<'a>, Option<&'a Block<'a>>)>>(\n-    es: &mut T,\n-    main_loop_id: HirId,\n-) -> NeverLoopResult {\n-    es.map(|(e, els)| {\n-        let e = never_loop_expr(e, main_loop_id);\n-        els.map_or(e, |els| combine_branches(e, never_loop_block(els, main_loop_id)))\n+    iter.map(|(e, els)| {\n+        let e = never_loop_expr(e, ignore_ids, main_loop_id);\n+        // els is an else block in a let...else binding\n+        els.map_or(e, |els| {\n+            combine_branches(e, never_loop_block(els, ignore_ids, main_loop_id))\n+        })\n     })\n     .fold(NeverLoopResult::Otherwise, combine_seq)\n }\n \n fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<(&'tcx Expr<'tcx>, Option<&'tcx Block<'tcx>>)> {\n     match stmt.kind {\n-        StmtKind::Semi(e, ..) | StmtKind::Expr(e, ..) => Some((e, None)),\n+        StmtKind::Semi(e) | StmtKind::Expr(e) => Some((e, None)),\n+        // add the let...else expression (if present)\n         StmtKind::Local(local) => local.init.map(|init| (init, local.els)),\n         StmtKind::Item(..) => None,\n     }\n }\n \n-fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n+#[allow(clippy::too_many_lines)]\n+fn never_loop_expr(expr: &Expr<'_>, ignore_ids: &mut Vec<HirId>, main_loop_id: HirId) -> NeverLoopResult {\n     match expr.kind {\n         ExprKind::Box(e)\n         | ExprKind::Unary(_, e)\n@@ -129,48 +128,56 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Field(e, _)\n         | ExprKind::AddrOf(_, _, e)\n         | ExprKind::Repeat(e, _)\n-        | ExprKind::DropTemps(e) => never_loop_expr(e, main_loop_id),\n-        ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, main_loop_id),\n-        ExprKind::Array(es) | ExprKind::Tup(es) => never_loop_expr_all(&mut es.iter(), main_loop_id),\n-        ExprKind::MethodCall(_, receiver, es, _) => {\n-            never_loop_expr_all(&mut std::iter::once(receiver).chain(es.iter()), main_loop_id)\n-        },\n+        | ExprKind::DropTemps(e) => never_loop_expr(e, ignore_ids, main_loop_id),\n+        ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, ignore_ids, main_loop_id),\n+        ExprKind::Array(es) | ExprKind::Tup(es) => never_loop_expr_all(&mut es.iter(), ignore_ids, main_loop_id),\n+        ExprKind::MethodCall(_, receiver, es, _) => never_loop_expr_all(\n+            &mut std::iter::once(receiver).chain(es.iter()),\n+            ignore_ids,\n+            main_loop_id,\n+        ),\n         ExprKind::Struct(_, fields, base) => {\n-            let fields = never_loop_expr_all(&mut fields.iter().map(|f| f.expr), main_loop_id);\n+            let fields = never_loop_expr_all(&mut fields.iter().map(|f| f.expr), ignore_ids, main_loop_id);\n             if let Some(base) = base {\n-                combine_both(fields, never_loop_expr(base, main_loop_id))\n+                combine_both(fields, never_loop_expr(base, ignore_ids, main_loop_id))\n             } else {\n                 fields\n             }\n         },\n-        ExprKind::Call(e, es) => never_loop_expr_all(&mut once(e).chain(es.iter()), main_loop_id),\n+        ExprKind::Call(e, es) => never_loop_expr_all(&mut once(e).chain(es.iter()), ignore_ids, main_loop_id),\n         ExprKind::Binary(_, e1, e2)\n         | ExprKind::Assign(e1, e2, _)\n         | ExprKind::AssignOp(_, e1, e2)\n-        | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().copied(), main_loop_id),\n+        | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().copied(), ignore_ids, main_loop_id),\n         ExprKind::Loop(b, _, _, _) => {\n             // Break can come from the inner loop so remove them.\n-            absorb_break(never_loop_block(b, main_loop_id))\n+            absorb_break(never_loop_block(b, ignore_ids, main_loop_id))\n         },\n         ExprKind::If(e, e2, e3) => {\n-            let e1 = never_loop_expr(e, main_loop_id);\n-            let e2 = never_loop_expr(e2, main_loop_id);\n-            let e3 = e3\n-                .as_ref()\n-                .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n+            let e1 = never_loop_expr(e, ignore_ids, main_loop_id);\n+            let e2 = never_loop_expr(e2, ignore_ids, main_loop_id);\n+            let e3 = e3.as_ref().map_or(NeverLoopResult::Otherwise, |e| {\n+                never_loop_expr(e, ignore_ids, main_loop_id)\n+            });\n             combine_seq(e1, combine_branches(e2, e3))\n         },\n         ExprKind::Match(e, arms, _) => {\n-            let e = never_loop_expr(e, main_loop_id);\n+            let e = never_loop_expr(e, ignore_ids, main_loop_id);\n             if arms.is_empty() {\n                 e\n             } else {\n-                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| a.body), main_loop_id);\n+                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| a.body), ignore_ids, main_loop_id);\n                 combine_seq(e, arms)\n             }\n         },\n-        ExprKind::Block(b, None) => never_loop_block(b, main_loop_id),\n-        ExprKind::Block(b, Some(_label)) => absorb_break(never_loop_block(b, main_loop_id)),\n+        ExprKind::Block(b, l) => {\n+            if l.is_some() {\n+                ignore_ids.push(b.hir_id);\n+            }\n+            let ret = never_loop_block(b, ignore_ids, main_loop_id);\n+            ignore_ids.pop();\n+            ret\n+        },\n         ExprKind::Continue(d) => {\n             let id = d\n                 .target_id\n@@ -181,20 +188,32 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n+        // checks if break targets a block instead of a loop\n+        ExprKind::Break(Destination { target_id: Ok(t), .. }, e) if ignore_ids.contains(&t) => e\n+            .map_or(NeverLoopResult::Otherwise, |e| {\n+                combine_seq(never_loop_expr(e, ignore_ids, main_loop_id), NeverLoopResult::Otherwise)\n+            }),\n         ExprKind::Break(_, e) | ExprKind::Ret(e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n-            combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n+            combine_seq(\n+                never_loop_expr(e, ignore_ids, main_loop_id),\n+                NeverLoopResult::AlwaysBreak,\n+            )\n         }),\n         ExprKind::InlineAsm(asm) => asm\n             .operands\n             .iter()\n             .map(|(o, _)| match o {\n                 InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n-                    never_loop_expr(expr, main_loop_id)\n+                    never_loop_expr(expr, ignore_ids, main_loop_id)\n                 },\n-                InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter().copied(), main_loop_id),\n-                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                    never_loop_expr_all(&mut once(*in_expr).chain(out_expr.iter().copied()), main_loop_id)\n+                InlineAsmOperand::Out { expr, .. } => {\n+                    never_loop_expr_all(&mut expr.iter().copied(), ignore_ids, main_loop_id)\n                 },\n+                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => never_loop_expr_all(\n+                    &mut once(*in_expr).chain(out_expr.iter().copied()),\n+                    ignore_ids,\n+                    main_loop_id,\n+                ),\n                 InlineAsmOperand::Const { .. }\n                 | InlineAsmOperand::SymFn { .. }\n                 | InlineAsmOperand::SymStatic { .. } => NeverLoopResult::Otherwise,\n@@ -209,13 +228,21 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n     }\n }\n \n-fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n-    es.map(|e| never_loop_expr(e, main_loop_id))\n+fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(\n+    es: &mut T,\n+    ignore_ids: &mut Vec<HirId>,\n+    main_loop_id: HirId,\n+) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, ignore_ids, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_both)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n-    e.map(|e| never_loop_expr(e, main_loop_id))\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(\n+    e: &mut T,\n+    ignore_ids: &mut Vec<HirId>,\n+    main_loop_id: HirId,\n+) -> NeverLoopResult {\n+    e.map(|e| never_loop_expr(e, ignore_ids, main_loop_id))\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n "}, {"sha": "28e8f459d4429cae47078cd349795a6509b17045", "filename": "tests/ui/never_loop.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1c9c34de17dde504447accd457afd0ba0da6a06f/tests%2Fui%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c9c34de17dde504447accd457afd0ba0da6a06f/tests%2Fui%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.rs?ref=1c9c34de17dde504447accd457afd0ba0da6a06f", "patch": "@@ -234,13 +234,22 @@ pub fn test19() {\n     fn thing(iter: impl Iterator) {\n         for _ in iter {\n             'b: {\n-                // error goes away if we just have the block's value be ().\n                 break 'b;\n             }\n         }\n     }\n }\n \n+pub fn test20() {\n+    'a: loop {\n+        'b: {\n+            break 'b 'c: {\n+                break 'a;\n+            };\n+        }\n+    }\n+}\n+\n fn main() {\n     test1();\n     test2();"}, {"sha": "b7029bf8bed47578f21e65d6c70a78264eb9bbf5", "filename": "tests/ui/never_loop.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c9c34de17dde504447accd457afd0ba0da6a06f/tests%2Fui%2Fnever_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c9c34de17dde504447accd457afd0ba0da6a06f/tests%2Fui%2Fnever_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.stderr?ref=1c9c34de17dde504447accd457afd0ba0da6a06f", "patch": "@@ -114,5 +114,17 @@ LL | |         break x;\n LL | |     };\n    | |_____^\n \n-error: aborting due to 10 previous errors\n+error: this loop never actually loops\n+  --> $DIR/never_loop.rs:244:5\n+   |\n+LL | /     'a: loop {\n+LL | |         'b: {\n+LL | |             break 'b 'c: {\n+LL | |                 break 'a;\n+LL | |             };\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 11 previous errors\n "}]}