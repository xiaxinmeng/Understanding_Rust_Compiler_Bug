{"sha": "e7f5d48059aa14cc2808473564deadd72d1e818d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZjVkNDgwNTlhYTE0Y2MyODA4NDczNTY0ZGVhZGQ3MmQxZTgxOGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-18T18:14:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-18T18:14:52Z"}, "message": "Auto merge of #54976 - davidtwco:issue-52663-special-case-closures, r=nikomatsakis\n\nNLL lacks various special case handling of closures\n\nPart of #52663.\n\nFirstly, this PR extends existing handling of closures to also support generators.\n\nSecond, this PR adds the note found in the AST when a closure is invoked twice and captures a variable by-value:\n\n```text\nnote: closure cannot be invoked more than once because it moves the variable `dict` out of its environment\n  --> $DIR/issue-42065.rs:16:29\n   |\nLL |         for (key, value) in dict {\n   |                             ^^^^\n```\n\nr? @nikomatsakis\ncc @pnkfelix", "tree": {"sha": "1c4617a4299b50a733a99d3d5c045470aad8f99d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c4617a4299b50a733a99d3d5c045470aad8f99d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7f5d48059aa14cc2808473564deadd72d1e818d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7f5d48059aa14cc2808473564deadd72d1e818d", "html_url": "https://github.com/rust-lang/rust/commit/e7f5d48059aa14cc2808473564deadd72d1e818d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7f5d48059aa14cc2808473564deadd72d1e818d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "121320d5236b255049ef178669b5a279389cd1e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/121320d5236b255049ef178669b5a279389cd1e5", "html_url": "https://github.com/rust-lang/rust/commit/121320d5236b255049ef178669b5a279389cd1e5"}, {"sha": "d088edc5310518f740df973b6f85d078684152f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d088edc5310518f740df973b6f85d078684152f6", "html_url": "https://github.com/rust-lang/rust/commit/d088edc5310518f740df973b6f85d078684152f6"}], "stats": {"total": 545, "additions": 343, "deletions": 202}, "files": [{"sha": "d9b64527700fccf3b232d7df8c401131d9bbd69b", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=e7f5d48059aa14cc2808473564deadd72d1e818d", "patch": "@@ -609,12 +609,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         new_loan.span, &nl, old_loan.span, previous_end_span, Origin::Ast),\n                 (ty::UniqueImmBorrow, _) =>\n                     self.bccx.cannot_uniquely_borrow_by_one_closure(\n-                        new_loan.span, &nl, &new_loan_msg,\n+                        new_loan.span, \"closure\", &nl, &new_loan_msg,\n                         old_loan.span, &ol_pronoun, &old_loan_msg, previous_end_span, Origin::Ast),\n                 (_, ty::UniqueImmBorrow) => {\n                     let new_loan_str = &new_loan.kind.to_user_str();\n                     self.bccx.cannot_reborrow_already_uniquely_borrowed(\n-                        new_loan.span, &nl, &new_loan_msg, new_loan_str,\n+                        new_loan.span, \"closure\", &nl, &new_loan_msg, new_loan_str,\n                         old_loan.span, &old_loan_msg, previous_end_span, Origin::Ast)\n                 }\n                 (..) =>"}, {"sha": "baf9e032270a684e9af3cc3d9471d58b3e897a4f", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 292, "deletions": 115, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=e7f5d48059aa14cc2808473564deadd72d1e818d", "patch": "@@ -15,11 +15,11 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n-    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, Field, Local,\n+    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, Constant, Field, Local,\n     LocalDecl, LocalKind, Location, Operand, Place, PlaceProjection, ProjectionElem,\n     Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n-use rustc::ty;\n+use rustc::ty::{self, DefIdTree};\n use rustc::util::ppaux::with_highlight_region_for_bound_region;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n@@ -103,7 +103,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             use_spans.var_span_label(\n                 &mut err,\n-                format!(\"{} occurs due to use in closure\", desired_action.as_noun()),\n+                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n             );\n \n             err.buffer(&mut self.errors_buffer);\n@@ -131,6 +131,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Origin::Mir,\n             );\n \n+            self.add_closure_invoked_twice_with_moved_variable_suggestion(\n+                context.loc,\n+                used_place,\n+                &mut err,\n+            );\n+\n             let mut is_loop_move = false;\n             for move_site in &move_site_vec {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n@@ -161,13 +167,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     );\n                 } else {\n                     err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n-                    move_spans.var_span_label(&mut err, \"variable moved due to use in closure\");\n+                    move_spans.var_span_label(\n+                        &mut err,\n+                        format!(\"variable moved due to use{}\", move_spans.describe()),\n+                    );\n                 };\n             }\n \n             use_spans.var_span_label(\n                 &mut err,\n-                format!(\"{} occurs due to use in closure\", desired_action.as_noun()),\n+                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n             );\n \n             if !is_loop_move {\n@@ -226,9 +235,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_move_out_while_borrowed(\n         &mut self,\n         context: Context,\n-        (place, _span): (&Place<'tcx>, Span),\n+        (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n+        debug!(\n+            \"report_move_out_while_borrowed: context={:?} place={:?} span={:?} borrow={:?}\",\n+            context, place, span, borrow\n+        );\n         let tcx = self.infcx.tcx;\n         let value_msg = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name),\n@@ -253,9 +266,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n         err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n \n-        borrow_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n+        borrow_spans.var_span_label(\n+            &mut err,\n+            format!(\"borrow occurs due to use{}\", borrow_spans.describe())\n+        );\n \n-        move_spans.var_span_label(&mut err, \"move occurs due to use in closure\");\n+        move_spans.var_span_label(\n+            &mut err,\n+            format!(\"move occurs due to use{}\", move_spans.describe())\n+        );\n \n         self.explain_why_borrow_contains_point(context, borrow, None)\n             .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\");\n@@ -291,7 +310,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let place = &borrow.borrowed_place;\n             let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n \n-            format!(\"borrow occurs due to use of `{}` in closure\", desc_place)\n+            format!(\"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe())\n         });\n \n         self.explain_why_borrow_contains_point(context, borrow, None)\n@@ -312,6 +331,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let borrow_spans = self.borrow_spans(span, context.loc);\n         let span = borrow_spans.args_or_use();\n \n+        let container_name = if issued_spans.for_generator() || borrow_spans.for_generator() {\n+            \"generator\"\n+        } else {\n+            \"closure\"\n+        };\n+\n         let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n         let tcx = self.infcx.tcx;\n \n@@ -392,7 +417,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n                 borrow_spans.var_span_label(\n                     &mut err,\n-                    format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n+                    format!(\n+                        \"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe()\n+                    ),\n                 );\n                 err.buffer(&mut self.errors_buffer);\n \n@@ -403,6 +430,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 first_borrow_desc = \"first \";\n                 tcx.cannot_uniquely_borrow_by_one_closure(\n                     span,\n+                    container_name,\n                     &desc_place,\n                     \"\",\n                     issued_span,\n@@ -417,6 +445,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 first_borrow_desc = \"first \";\n                 tcx.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n+                    container_name,\n                     &desc_place,\n                     \"\",\n                     lft,\n@@ -431,6 +460,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 first_borrow_desc = \"first \";\n                 tcx.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n+                    container_name,\n                     &desc_place,\n                     \"\",\n                     lft,\n@@ -456,24 +486,26 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if issued_spans == borrow_spans {\n             borrow_spans.var_span_label(\n                 &mut err,\n-                format!(\"borrows occur due to use of `{}` in closure\", desc_place),\n+                format!(\"borrows occur due to use of `{}`{}\", desc_place, borrow_spans.describe()),\n             );\n         } else {\n             let borrow_place = &issued_borrow.borrowed_place;\n             let borrow_place_desc = self.describe_place(borrow_place).unwrap_or(\"_\".to_owned());\n             issued_spans.var_span_label(\n                 &mut err,\n                 format!(\n-                    \"first borrow occurs due to use of `{}` in closure\",\n-                    borrow_place_desc\n+                    \"first borrow occurs due to use of `{}`{}\",\n+                    borrow_place_desc,\n+                    issued_spans.describe(),\n                 ),\n             );\n \n             borrow_spans.var_span_label(\n                 &mut err,\n                 format!(\n-                    \"second borrow occurs due to use of `{}` in closure\",\n-                    desc_place\n+                    \"second borrow occurs due to use of `{}`{}\",\n+                    desc_place,\n+                    borrow_spans.describe(),\n                 ),\n             );\n         }\n@@ -643,7 +675,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 format!(\"`{}` dropped here while still borrowed\", name),\n             );\n \n-            borrow_spans.args_span_label(&mut err, \"value captured here\");\n+            let within = if borrow_spans.for_generator() {\n+                \" by generator\"\n+            } else {\n+                \"\"\n+            };\n+\n+            borrow_spans.args_span_label(\n+                &mut err,\n+                format!(\"value captured here{}\", within),\n+            );\n \n             explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\");\n         }\n@@ -774,7 +815,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n         explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\");\n \n-        borrow_spans.args_span_label(&mut err, \"value captured here\");\n+        let within = if borrow_spans.for_generator() {\n+            \" by generator\"\n+        } else {\n+            \"\"\n+        };\n+\n+        borrow_spans.args_span_label(\n+            &mut err,\n+            format!(\"value captured here{}\", within),\n+        );\n \n         err\n     }\n@@ -906,7 +956,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             )\n         };\n \n-        loan_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n+        loan_spans.var_span_label(\n+            &mut err,\n+            format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n+        );\n \n         self.explain_why_borrow_contains_point(context, loan, None)\n             .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\");\n@@ -1009,16 +1062,111 @@ enum StorageDeadOrDrop<'tcx> {\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    // End-user visible description of `place` if one can be found. If the\n-    // place is a temporary for instance, None will be returned.\n+\n+    /// Adds a suggestion when a closure is invoked twice with a moved variable.\n+    ///\n+    /// ```text\n+    /// note: closure cannot be invoked more than once because it moves the variable `dict` out of\n+    ///       its environment\n+    ///   --> $DIR/issue-42065.rs:16:29\n+    ///    |\n+    /// LL |         for (key, value) in dict {\n+    ///    |                             ^^^^\n+    /// ```\n+    pub(super) fn add_closure_invoked_twice_with_moved_variable_suggestion(\n+        &self,\n+        location: Location,\n+        place: &Place<'tcx>,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        let mut target = place.local();\n+        debug!(\n+            \"add_closure_invoked_twice_with_moved_variable_suggestion: location={:?} place={:?} \\\n+             target={:?}\",\n+             location, place, target,\n+        );\n+        for stmt in &self.mir[location.block].statements[location.statement_index..] {\n+            debug!(\n+                \"add_closure_invoked_twice_with_moved_variable_suggestion: stmt={:?} \\\n+                 target={:?}\",\n+                 stmt, target,\n+            );\n+            if let StatementKind::Assign(into, box Rvalue::Use(from)) = &stmt.kind {\n+                debug!(\n+                    \"add_closure_invoked_twice_with_moved_variable_suggestion: into={:?} \\\n+                     from={:?}\",\n+                     into, from,\n+                );\n+                match from {\n+                    Operand::Copy(ref place) |\n+                    Operand::Move(ref place) if target == place.local() =>\n+                        target = into.local(),\n+                    _ => {},\n+                }\n+            }\n+        }\n+\n+\n+        let terminator = self.mir[location.block].terminator();\n+        debug!(\n+            \"add_closure_invoked_twice_with_moved_variable_suggestion: terminator={:?}\",\n+            terminator,\n+        );\n+        if let TerminatorKind::Call {\n+            func: Operand::Constant(box Constant {\n+                literal: ty::Const { ty: &ty::TyS { sty: ty::TyKind::FnDef(id, _), ..  }, ..  },\n+                ..\n+            }),\n+            args,\n+            ..\n+        } = &terminator.kind {\n+            debug!(\"add_closure_invoked_twice_with_moved_variable_suggestion: id={:?}\", id);\n+            if self.infcx.tcx.parent(id) == self.infcx.tcx.lang_items().fn_once_trait() {\n+                let closure = match args.first() {\n+                    Some(Operand::Copy(ref place)) |\n+                    Some(Operand::Move(ref place)) if target == place.local() =>\n+                        place.local().unwrap(),\n+                    _ => return,\n+                };\n+                debug!(\n+                    \"add_closure_invoked_twice_with_moved_variable_suggestion: closure={:?}\",\n+                     closure,\n+                );\n+\n+                if let ty::TyKind::Closure(did, _substs) = self.mir.local_decls[closure].ty.sty {\n+                    let node_id = match self.infcx.tcx.hir.as_local_node_id(did) {\n+                        Some(node_id) => node_id,\n+                        _ => return,\n+                    };\n+                    let hir_id = self.infcx.tcx.hir.node_to_hir_id(node_id);\n+\n+                    if let Some((\n+                        span, name\n+                    )) = self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id) {\n+                        diag.span_note(\n+                            *span,\n+                            &format!(\n+                                \"closure cannot be invoked more than once because it \\\n+                                 moves the variable `{}` out of its environment\",\n+                                 name,\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// End-user visible description of `place` if one can be found. If the\n+    /// place is a temporary for instance, None will be returned.\n     pub(super) fn describe_place(&self, place: &Place<'tcx>) -> Option<String> {\n         self.describe_place_with_options(place, IncludingDowncast(false))\n     }\n \n-    // End-user visible description of `place` if one can be found. If the\n-    // place is a temporary for instance, None will be returned.\n-    // `IncludingDowncast` parameter makes the function return `Err` if `ProjectionElem` is\n-    // `Downcast` and `IncludingDowncast` is true\n+    /// End-user visible description of `place` if one can be found. If the\n+    /// place is a temporary for instance, None will be returned.\n+    /// `IncludingDowncast` parameter makes the function return `Err` if `ProjectionElem` is\n+    /// `Downcast` and `IncludingDowncast` is true\n     pub(super) fn describe_place_with_options(\n         &self,\n         place: &Place<'tcx>,\n@@ -1031,7 +1179,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Appends end-user visible description of `place` to `buf`.\n+    /// Appends end-user visible description of `place` to `buf`.\n     fn append_place_to_string(\n         &self,\n         place: &Place<'tcx>,\n@@ -1166,8 +1314,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    // Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n-    // a name, then `Err` is returned\n+    /// Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n+    /// a name, then `Err` is returned\n     fn append_local_to_string(&self, local_index: Local, buf: &mut String) -> Result<(), ()> {\n         let local = &self.mir.local_decls[local_index];\n         match local.name {\n@@ -1179,7 +1327,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    // End-user visible description of the `field`nth field of `base`\n+    /// End-user visible description of the `field`nth field of `base`\n     fn describe_field(&self, base: &Place, field: Field) -> String {\n         match *base {\n             Place::Local(local) => {\n@@ -1204,7 +1352,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    // End-user visible description of the `field_index`nth field of `ty`\n+    /// End-user visible description of the `field_index`nth field of `ty`\n     fn describe_field_from_ty(&self, ty: &ty::Ty, field: Field) -> String {\n         if ty.is_box() {\n             // If the type is a box, the field is described from the boxed type\n@@ -1247,7 +1395,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Retrieve type of a place for the current MIR representation\n+    /// Retrieve type of a place for the current MIR representation\n     fn retrieve_type_for_place(&self, place: &Place<'tcx>) -> Option<ty::Ty> {\n         match place {\n             Place::Local(local) => {\n@@ -1805,6 +1953,8 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n pub(super) enum UseSpans {\n     // The access is caused by capturing a variable for a closure.\n     ClosureUse {\n+        // This is true if the captured variable was from a generator.\n+        is_generator: bool,\n         // The span of the args of the closure, including the `move` keyword if\n         // it's present.\n         args_span: Span,\n@@ -1845,10 +1995,31 @@ impl UseSpans {\n         }\n     }\n \n-    pub(super) fn for_closure(self) -> bool {\n-        match self {\n-            UseSpans::ClosureUse { .. } => true,\n-            UseSpans::OtherUse(_) => false,\n+    /// Return `false` if this place is not used in a closure.\n+    fn for_closure(&self) -> bool {\n+        match *self {\n+            UseSpans::ClosureUse { is_generator, .. } => !is_generator,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Return `false` if this place is not used in a generator.\n+    fn for_generator(&self) -> bool {\n+        match *self {\n+            UseSpans::ClosureUse { is_generator, .. } => is_generator,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Describe the span associated with a use of a place.\n+    fn describe(&self) -> String {\n+        match *self {\n+            UseSpans::ClosureUse { is_generator, .. } => if is_generator {\n+                \" in generator\".to_string()\n+            } else {\n+                \" in closure\".to_string()\n+            },\n+            _ => \"\".to_string(),\n         }\n     }\n \n@@ -1871,53 +2042,37 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         location: Location,\n     ) -> UseSpans {\n         use self::UseSpans::*;\n-        use rustc::hir::ExprKind::Closure;\n-        use rustc::mir::AggregateKind;\n \n-        let stmt = match self.mir[location.block]\n-            .statements\n-            .get(location.statement_index)\n-        {\n+        let stmt = match self.mir[location.block].statements.get(location.statement_index) {\n             Some(stmt) => stmt,\n             None => return OtherUse(self.mir.source_info(location).span),\n         };\n \n-        if let StatementKind::Assign(_, box Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n-            if let AggregateKind::Closure(def_id, _) = **kind {\n-                debug!(\"find_closure_move_span: found closure {:?}\", places);\n+        debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n+        if let  StatementKind::Assign(\n+            _,\n+            box Rvalue::Aggregate(ref kind, ref places)\n+        ) = stmt.kind {\n+            let (def_id, is_generator) = match kind {\n+                box AggregateKind::Closure(def_id, _) => (def_id, false),\n+                box AggregateKind::Generator(def_id, _, _) => (def_id, true),\n+                _ => return OtherUse(stmt.source_info.span),\n+            };\n \n-                if let Some(node_id) = self.infcx.tcx.hir.as_local_node_id(def_id) {\n-                    if let Closure(_, _, _, args_span, _) =\n-                        self.infcx.tcx.hir.expect_expr(node_id).node\n-                    {\n-                        if let Some(var_span) = self.infcx.tcx.with_freevars(node_id, |freevars| {\n-                            for (v, place) in freevars.iter().zip(places) {\n-                                match place {\n-                                    Operand::Copy(place) | Operand::Move(place)\n-                                        if moved_place == place =>\n-                                    {\n-                                        debug!(\n-                                            \"find_closure_move_span: found captured local {:?}\",\n-                                            place\n-                                        );\n-                                        return Some(v.span);\n-                                    }\n-                                    _ => {}\n-                                }\n-                            }\n-                            None\n-                        }) {\n-                            return ClosureUse {\n-                                args_span,\n-                                var_span,\n-                            };\n-                        }\n-                    }\n-                }\n+            debug!(\n+                \"move_spans: def_id={:?} is_generator={:?} places={:?}\",\n+                def_id, is_generator, places\n+            );\n+            if let Some((args_span, var_span)) = self.closure_span(*def_id, moved_place, places) {\n+                return ClosureUse {\n+                    is_generator,\n+                    args_span,\n+                    var_span,\n+                };\n             }\n         }\n \n-        return OtherUse(stmt.source_info.span);\n+        OtherUse(stmt.source_info.span)\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`)\n@@ -1926,9 +2081,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// and originating from `maybe_closure_span`.\n     pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans {\n         use self::UseSpans::*;\n-        use rustc::hir::ExprKind::Closure;\n+        debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n-        let local = match self.mir[location.block]\n+        let target = match self.mir[location.block]\n             .statements\n             .get(location.statement_index)\n         {\n@@ -1939,54 +2094,35 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => return OtherUse(use_span),\n         };\n \n-        if self.mir.local_kind(local) != LocalKind::Temp {\n+        if self.mir.local_kind(target) != LocalKind::Temp {\n             // operands are always temporaries.\n             return OtherUse(use_span);\n         }\n \n         for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n-            if let StatementKind::Assign(_, box Rvalue::Aggregate(ref kind, ref places)) = stmt.kind\n-            {\n-                if let AggregateKind::Closure(def_id, _) = **kind {\n-                    debug!(\"find_closure_borrow_span: found closure {:?}\", places);\n-\n-                    return if let Some(node_id) = self.infcx.tcx.hir.as_local_node_id(def_id) {\n-                        let args_span = if let Closure(_, _, _, span, _) =\n-                            self.infcx.tcx.hir.expect_expr(node_id).node\n-                        {\n-                            span\n-                        } else {\n-                            return OtherUse(use_span);\n-                        };\n+            if let StatementKind::Assign(\n+                _, box Rvalue::Aggregate(ref kind, ref places)\n+            ) = stmt.kind {\n+                let (def_id, is_generator) = match kind {\n+                    box AggregateKind::Closure(def_id, _) => (def_id, false),\n+                    box AggregateKind::Generator(def_id, _, _) => (def_id, true),\n+                    _ => continue,\n+                };\n \n-                        self.infcx\n-                            .tcx\n-                            .with_freevars(node_id, |freevars| {\n-                                for (v, place) in freevars.iter().zip(places) {\n-                                    match *place {\n-                                        Operand::Copy(Place::Local(l))\n-                                        | Operand::Move(Place::Local(l)) if local == l =>\n-                                        {\n-                                            debug!(\n-                                                \"find_closure_borrow_span: found captured local \\\n-                                                 {:?}\",\n-                                                l\n-                                            );\n-                                            return Some(v.span);\n-                                        }\n-                                        _ => {}\n-                                    }\n-                                }\n-                                None\n-                            })\n-                            .map(|var_span| ClosureUse {\n-                                args_span,\n-                                var_span,\n-                            })\n-                            .unwrap_or(OtherUse(use_span))\n-                    } else {\n-                        OtherUse(use_span)\n+                debug!(\n+                    \"borrow_spans: def_id={:?} is_generator={:?} places={:?}\",\n+                    def_id, is_generator, places\n+                );\n+                if let Some((args_span, var_span)) = self.closure_span(\n+                    *def_id, &Place::Local(target), places\n+                ) {\n+                    return ClosureUse {\n+                        is_generator,\n+                        args_span,\n+                        var_span,\n                     };\n+                } else {\n+                    return OtherUse(use_span);\n                 }\n             }\n \n@@ -1998,6 +2134,47 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         OtherUse(use_span)\n     }\n \n+    /// Finds the span of a captured variable within a closure or generator.\n+    fn closure_span(\n+        &self,\n+        def_id: DefId,\n+        target_place: &Place<'tcx>,\n+        places: &Vec<Operand<'tcx>>,\n+    ) -> Option<(Span, Span)> {\n+        debug!(\n+            \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n+            def_id, target_place, places\n+        );\n+        let node_id = self.infcx.tcx.hir.as_local_node_id(def_id)?;\n+        let expr = &self.infcx.tcx.hir.expect_expr(node_id).node;\n+        debug!(\"closure_span: node_id={:?} expr={:?}\", node_id, expr);\n+        if let hir::ExprKind::Closure(\n+            .., args_span, _\n+        ) = expr {\n+            let var_span = self.infcx.tcx.with_freevars(\n+                node_id,\n+                |freevars| {\n+                    for (v, place) in freevars.iter().zip(places) {\n+                        match place {\n+                            Operand::Copy(place) |\n+                            Operand::Move(place) if target_place == place => {\n+                                debug!(\"closure_span: found captured local {:?}\", place);\n+                                return Some(v.span);\n+                            },\n+                            _ => {}\n+                        }\n+                    }\n+\n+                    None\n+                },\n+            )?;\n+\n+            Some((*args_span, var_span))\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Helper to retrieve span(s) of given borrow from the current MIR\n     /// representation\n     pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData) -> UseSpans {"}, {"sha": "d5c655a3de472dd035f8851dd3ec439e6a6d8e3e", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=e7f5d48059aa14cc2808473564deadd72d1e818d", "patch": "@@ -221,6 +221,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n     fn cannot_uniquely_borrow_by_one_closure(\n         self,\n         new_loan_span: Span,\n+        container_name: &str,\n         desc_new: &str,\n         opt_via: &str,\n         old_loan_span: Span,\n@@ -241,7 +242,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         );\n         err.span_label(\n             new_loan_span,\n-            format!(\"closure construction occurs here{}\", opt_via),\n+            format!(\"{} construction occurs here{}\", container_name, opt_via),\n         );\n         err.span_label(old_loan_span, format!(\"borrow occurs here{}\", old_opt_via));\n         if let Some(previous_end_span) = previous_end_span {\n@@ -253,6 +254,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n     fn cannot_reborrow_already_uniquely_borrowed(\n         self,\n         new_loan_span: Span,\n+        container_name: &str,\n         desc_new: &str,\n         opt_via: &str,\n         kind_new: &str,\n@@ -275,7 +277,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         err.span_label(new_loan_span, format!(\"borrow occurs here{}\", opt_via));\n         err.span_label(\n             old_loan_span,\n-            format!(\"closure construction occurs here{}\", old_opt_via),\n+            format!(\"{} construction occurs here{}\", container_name, old_opt_via),\n         );\n         if let Some(previous_end_span) = previous_end_span {\n             err.span_label(previous_end_span, \"borrow from closure ends here\");"}, {"sha": "bda8a3b85f758dfe39a3efc6aaf9d50c0c1889d1", "filename": "src/test/ui/closure_context/issue-42065.nll.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/121320d5236b255049ef178669b5a279389cd1e5/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/121320d5236b255049ef178669b5a279389cd1e5/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.nll.stderr?ref=121320d5236b255049ef178669b5a279389cd1e5", "patch": "@@ -1,11 +0,0 @@\n-error[E0382]: use of moved value: `debug_dump_dict`\n-  --> $DIR/issue-42065.rs:21:5\n-   |\n-LL |     debug_dump_dict();\n-   |     --------------- value moved here\n-LL |     debug_dump_dict();\n-   |     ^^^^^^^^^^^^^^^ value used here after move\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0382`."}, {"sha": "52b5c9d891bb3459ff4568993fd4493be187d864", "filename": "src/test/ui/generator/borrowing.nll.stderr", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.nll.stderr?ref=e7f5d48059aa14cc2808473564deadd72d1e818d", "patch": "@@ -1,10 +1,11 @@\n error[E0597]: `a` does not live long enough\n-  --> $DIR/borrowing.rs:18:18\n+  --> $DIR/borrowing.rs:18:29\n    |\n LL |         unsafe { (|| yield &a).resume() }\n-   |                  ^^^^^^^^^^^^^\n-   |                  |\n-   |                  borrowed value does not live long enough\n+   |                  -----------^-\n+   |                  ||         |\n+   |                  ||         borrowed value does not live long enough\n+   |                  |value captured here by generator\n    |                  a temporary with access to the borrow is created here ...\n LL |         //~^ ERROR: `a` does not live long enough\n LL |     };\n@@ -15,18 +16,18 @@ LL |     };\n    = note: The temporary is part of an expression at the end of a block. Consider forcing this temporary to be dropped sooner, before the block's local variables are dropped. For example, you could save the expression's value in a new local variable `x` and then make `x` be the expression at the end of the block.\n \n error[E0597]: `a` does not live long enough\n-  --> $DIR/borrowing.rs:24:9\n+  --> $DIR/borrowing.rs:25:20\n    |\n-LL |       let _b = {\n-   |           -- borrow later stored here\n-LL |           let a = 3;\n-LL | /         || {\n-LL | |             yield &a\n-LL | |             //~^ ERROR: `a` does not live long enough\n-LL | |         }\n-   | |_________^ borrowed value does not live long enough\n-LL |       };\n-   |       - `a` dropped here while still borrowed\n+LL |     let _b = {\n+   |         -- borrow later stored here\n+LL |         let a = 3;\n+LL |         || {\n+   |         -- value captured here by generator\n+LL |             yield &a\n+   |                    ^ borrowed value does not live long enough\n+...\n+LL |     };\n+   |     - `a` dropped here while still borrowed\n \n error: aborting due to 2 previous errors\n "}, {"sha": "078aaf6176ab82c0756b9e13fd29fa58c45f5b07", "filename": "src/test/ui/generator/dropck.nll.stderr", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr?ref=e7f5d48059aa14cc2808473564deadd72d1e818d", "patch": "@@ -13,21 +13,19 @@ LL | }\n    = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `ref_` does not live long enough\n-  --> $DIR/dropck.rs:22:11\n+  --> $DIR/dropck.rs:24:18\n    |\n-LL |       gen = || {\n-   |  ___________^\n-LL | |         // but the generator can use it to drop a `Ref<'a, i32>`.\n-LL | |         let _d = ref_.take(); //~ ERROR `ref_` does not live long enough\n-LL | |         yield;\n-LL | |     };\n-   | |_____^ borrowed value does not live long enough\n+LL |     gen = || {\n+   |           -- value captured here by generator\n+LL |         // but the generator can use it to drop a `Ref<'a, i32>`.\n+LL |         let _d = ref_.take(); //~ ERROR `ref_` does not live long enough\n+   |                  ^^^^ borrowed value does not live long enough\n ...\n-LL |   }\n-   |   -\n-   |   |\n-   |   `ref_` dropped here while still borrowed\n-   |   borrow might be used here, when `gen` is dropped and runs the destructor for generator\n+LL | }\n+   | -\n+   | |\n+   | `ref_` dropped here while still borrowed\n+   | borrow might be used here, when `gen` is dropped and runs the destructor for generator\n    |\n    = note: values in a scope are dropped in the opposite order they are defined\n "}, {"sha": "2f0a05898444c836d7ac550cf3e7e56080a5b900", "filename": "src/test/ui/generator/yield-while-iterating.nll.stderr", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.nll.stderr?ref=e7f5d48059aa14cc2808473564deadd72d1e818d", "patch": "@@ -9,17 +9,15 @@ LL |             yield();\n error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n   --> $DIR/yield-while-iterating.rs:67:20\n    |\n-LL |       let mut b = || {\n-   |  _________________-\n-LL | |         for p in &mut x {\n-LL | |             yield p;\n-LL | |         }\n-LL | |     };\n-   | |_____- mutable borrow occurs here\n-LL |       println!(\"{}\", x[0]); //~ ERROR\n-   |                      ^ immutable borrow occurs here\n-LL |       b.resume();\n-   |       - mutable borrow later used here\n+LL |     let mut b = || {\n+   |                 -- mutable borrow occurs here\n+LL |         for p in &mut x {\n+   |                       - first borrow occurs due to use of `x` in generator\n+...\n+LL |     println!(\"{}\", x[0]); //~ ERROR\n+   |                    ^ immutable borrow occurs here\n+LL |     b.resume();\n+   |     - mutable borrow later used here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8dabb3c2505b637d863f0c3a549ebc5b4bb38aca", "filename": "src/test/ui/generator/yield-while-ref-reborrowed.nll.stderr", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7f5d48059aa14cc2808473564deadd72d1e818d/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.nll.stderr?ref=e7f5d48059aa14cc2808473564deadd72d1e818d", "patch": "@@ -1,17 +1,15 @@\n error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n   --> $DIR/yield-while-ref-reborrowed.rs:45:20\n    |\n-LL |       let mut b = || {\n-   |  _________________-\n-LL | |         let a = &mut *x;\n-LL | |         yield();\n-LL | |         println!(\"{}\", a);\n-LL | |     };\n-   | |_____- closure construction occurs here\n-LL |       println!(\"{}\", x); //~ ERROR\n-   |                      ^ borrow occurs here\n-LL |       b.resume();\n-   |       - first borrow later used here\n+LL |     let mut b = || {\n+   |                 -- generator construction occurs here\n+LL |         let a = &mut *x;\n+   |                       - first borrow occurs due to use of `x` in generator\n+...\n+LL |     println!(\"{}\", x); //~ ERROR\n+   |                    ^ borrow occurs here\n+LL |     b.resume();\n+   |     - first borrow later used here\n \n error: aborting due to previous error\n "}, {"sha": "f4756696b6b0667ce52cad5371e681c89e694c26", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnonce-call-twice.nll.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/121320d5236b255049ef178669b5a279389cd1e5/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/121320d5236b255049ef178669b5a279389cd1e5/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.nll.stderr?ref=121320d5236b255049ef178669b5a279389cd1e5", "patch": "@@ -1,11 +0,0 @@\n-error[E0382]: use of moved value: `tick`\n-  --> $DIR/unboxed-closures-infer-fnonce-call-twice.rs:20:5\n-   |\n-LL |     tick();\n-   |     ---- value moved here\n-LL |     tick(); //~ ERROR use of moved value: `tick`\n-   |     ^^^^ value used here after move\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0382`."}, {"sha": "95ed673627877cd6b97631b45647332d982c47da", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnonce-move-call-twice.nll.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/121320d5236b255049ef178669b5a279389cd1e5/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/121320d5236b255049ef178669b5a279389cd1e5/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.nll.stderr?ref=121320d5236b255049ef178669b5a279389cd1e5", "patch": "@@ -1,11 +0,0 @@\n-error[E0382]: use of moved value: `tick`\n-  --> $DIR/unboxed-closures-infer-fnonce-move-call-twice.rs:20:5\n-   |\n-LL |     tick();\n-   |     ---- value moved here\n-LL |     tick(); //~ ERROR use of moved value: `tick`\n-   |     ^^^^ value used here after move\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0382`."}]}