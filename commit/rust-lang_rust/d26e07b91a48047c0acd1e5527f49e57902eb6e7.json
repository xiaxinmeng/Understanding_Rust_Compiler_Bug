{"sha": "d26e07b91a48047c0acd1e5527f49e57902eb6e7", "node_id": "C_kwDOAAsO6NoAKGQyNmUwN2I5MWE0ODA0N2MwYWNkMWU1NTI3ZjQ5ZTU3OTAyZWI2ZTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-18T05:59:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-18T05:59:20Z"}, "message": "Rollup merge of #106747 - yanchen4791:issue-105507-fix, r=estebank\n\nAdd 'static lifetime suggestion when GAT implied 'static requirement from HRTB\n\nFix for issue #105507\n\nThe problem:\nWhen generic associated types (GATs) are from higher-ranked trait bounds (HRTB), they are implied 'static requirement (see\n[Implied 'static requirement from higher-ranked trait bounds](https://blog.rust-lang.org/2022/10/28/gats-stabilization.html#implied-static-requirement-from-higher-ranked-trait-bounds) for more details). If the user did not explicitly specify the `'static` lifetime when using the GAT, the current error message will only point out the type `does not live long enough` where the type is used, but not where the GAT is specified and how to fix the problem.\n\nThe solution:\nAdd notes at the span where the problematic GATs are specified and suggestions of how to fix the problem by adding `'static` lifetime at the right spans.", "tree": {"sha": "921f74cb479669d10caf95b2bd7a1957dc8b60f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/921f74cb479669d10caf95b2bd7a1957dc8b60f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d26e07b91a48047c0acd1e5527f49e57902eb6e7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjx4q4CRBK7hj4Ov3rIwAAFfMIAF/C+aI0o0Rxet6QsTF7B8ic\nwt//l0h/eV+B2lfSAnTDDYwGBaGe2vCf2vfsLqnsrt22uSZt9xLUGwBzsOpUHrDg\nkA6O5LSLey/p2DehwT1MoFf8tkEvwoNq53lQxAwgrk1zLujfrcNb2nDAQwUwcezI\nu+G/ki1YmhDHDOH8zbHoxRjKArx5kFVDFyQX4YSwFXFMwODk9utQLF/PCpaHwv7h\n8+USiXvx0hfTEiw1gjV7VWMbElWAFiHFkj5J/WGaNBnRgf0JtJ7p8i0V1Nbr29vV\nF7BOAJybWl3Yz5BsXBApueMvmOhfVYzz+kfhtt7xSbh7uN5SgOHn9+PcwM8xhyo=\n=DCjL\n-----END PGP SIGNATURE-----\n", "payload": "tree 921f74cb479669d10caf95b2bd7a1957dc8b60f0\nparent 7e6f42e688b4e1713533f369b54df19ea7aca104\nparent aadd58ef7a78c3eabc75c73db6b166debdd7f1d2\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674021560 +0100\ncommitter GitHub <noreply@github.com> 1674021560 +0100\n\nRollup merge of #106747 - yanchen4791:issue-105507-fix, r=estebank\n\nAdd 'static lifetime suggestion when GAT implied 'static requirement from HRTB\n\nFix for issue #105507\n\nThe problem:\nWhen generic associated types (GATs) are from higher-ranked trait bounds (HRTB), they are implied 'static requirement (see\n[Implied 'static requirement from higher-ranked trait bounds](https://blog.rust-lang.org/2022/10/28/gats-stabilization.html#implied-static-requirement-from-higher-ranked-trait-bounds) for more details). If the user did not explicitly specify the `'static` lifetime when using the GAT, the current error message will only point out the type `does not live long enough` where the type is used, but not where the GAT is specified and how to fix the problem.\n\nThe solution:\nAdd notes at the span where the problematic GATs are specified and suggestions of how to fix the problem by adding `'static` lifetime at the right spans.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d26e07b91a48047c0acd1e5527f49e57902eb6e7", "html_url": "https://github.com/rust-lang/rust/commit/d26e07b91a48047c0acd1e5527f49e57902eb6e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d26e07b91a48047c0acd1e5527f49e57902eb6e7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e6f42e688b4e1713533f369b54df19ea7aca104", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e6f42e688b4e1713533f369b54df19ea7aca104", "html_url": "https://github.com/rust-lang/rust/commit/7e6f42e688b4e1713533f369b54df19ea7aca104"}, {"sha": "aadd58ef7a78c3eabc75c73db6b166debdd7f1d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/aadd58ef7a78c3eabc75c73db6b166debdd7f1d2", "html_url": "https://github.com/rust-lang/rust/commit/aadd58ef7a78c3eabc75c73db6b166debdd7f1d2"}], "stats": {"total": 262, "additions": 258, "deletions": 4}, "files": [{"sha": "187861ba127bd93e36af2707722146eee40ff574", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 113, "deletions": 4, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d26e07b91a48047c0acd1e5527f49e57902eb6e7/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26e07b91a48047c0acd1e5527f49e57902eb6e7/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=d26e07b91a48047c0acd1e5527f49e57902eb6e7", "patch": "@@ -5,8 +5,13 @@\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n+use rustc_hir::def::Res::Def;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n+use rustc_hir::GenericBound::Trait;\n+use rustc_hir::QPath::Resolved;\n+use rustc_hir::WherePredicate::BoundPredicate;\n+use rustc_hir::{PolyTraitRef, TyKind, WhereBoundPredicate};\n use rustc_infer::infer::{\n     error_reporting::nice_region_error::{\n         self, find_anon_type, find_param_with_region, suggest_adding_lifetime_params,\n@@ -186,6 +191,101 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         false\n     }\n \n+    // For generic associated types (GATs) which implied 'static requirement\n+    // from higher-ranked trait bounds (HRTB). Try to locate span of the trait\n+    // and the span which bounded to the trait for adding 'static lifetime suggestion\n+    fn suggest_static_lifetime_for_gat_from_hrtb(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        lower_bound: RegionVid,\n+    ) {\n+        let mut suggestions = vec![];\n+        let hir = self.infcx.tcx.hir();\n+\n+        // find generic associated types in the given region 'lower_bound'\n+        let gat_id_and_generics = self\n+            .regioncx\n+            .placeholders_contained_in(lower_bound)\n+            .map(|placeholder| {\n+                if let Some(id) = placeholder.name.get_id()\n+                    && let Some(placeholder_id) = id.as_local()\n+                    && let gat_hir_id = hir.local_def_id_to_hir_id(placeholder_id)\n+                    && let Some(generics_impl) = hir.get_parent(gat_hir_id).generics()\n+                {\n+                    Some((gat_hir_id, generics_impl))\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        debug!(?gat_id_and_generics);\n+\n+        // find higher-ranked trait bounds bounded to the generic associated types\n+        let mut hrtb_bounds = vec![];\n+        gat_id_and_generics.iter().flatten().for_each(|(gat_hir_id, generics)| {\n+            for pred in generics.predicates {\n+                let BoundPredicate(\n+                        WhereBoundPredicate {\n+                            bound_generic_params,\n+                            bounds,\n+                            ..\n+                        }) = pred else { continue; };\n+                if bound_generic_params\n+                    .iter()\n+                    .rfind(|bgp| hir.local_def_id_to_hir_id(bgp.def_id) == *gat_hir_id)\n+                    .is_some()\n+                {\n+                    for bound in *bounds {\n+                        hrtb_bounds.push(bound);\n+                    }\n+                }\n+            }\n+        });\n+        debug!(?hrtb_bounds);\n+\n+        hrtb_bounds.iter().for_each(|bound| {\n+            let Trait(PolyTraitRef { trait_ref, span: trait_span, .. }, _) = bound else { return; };\n+            diag.span_note(\n+                *trait_span,\n+                format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\")\n+            );\n+            let Some(generics_fn) = hir.get_generics(self.body.source.def_id().expect_local()) else { return; };\n+            let Def(_, trait_res_defid) = trait_ref.path.res else { return; };\n+            debug!(?generics_fn);\n+            generics_fn.predicates.iter().for_each(|predicate| {\n+                let BoundPredicate(\n+                    WhereBoundPredicate {\n+                        span: bounded_span,\n+                        bounded_ty,\n+                        bounds,\n+                        ..\n+                    }\n+                ) = predicate else { return; };\n+                bounds.iter().for_each(|bd| {\n+                    if let Trait(PolyTraitRef { trait_ref: tr_ref, .. }, _) = bd\n+                        && let Def(_, res_defid) = tr_ref.path.res\n+                        && res_defid == trait_res_defid // trait id matches\n+                        && let TyKind::Path(Resolved(_, path)) = bounded_ty.kind\n+                        && let Def(_, defid) = path.res\n+                        && generics_fn.params\n+                            .iter()\n+                            .rfind(|param| param.def_id.to_def_id() == defid)\n+                            .is_some() {\n+                            suggestions.push((bounded_span.shrink_to_hi(), format!(\" + 'static\")));\n+                        }\n+                });\n+            });\n+        });\n+        if suggestions.len() > 0 {\n+            suggestions.dedup();\n+            diag.multipart_suggestion_verbose(\n+                format!(\"consider restricting the type parameter to the `'static` lifetime\"),\n+                suggestions,\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+\n     /// Produces nice borrowck error diagnostics for all the errors collected in `nll_errors`.\n     pub(crate) fn report_region_errors(&mut self, nll_errors: RegionErrors<'tcx>) {\n         // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n@@ -223,12 +323,21 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // to report it; we could probably handle it by\n                         // iterating over the universal regions and reporting\n                         // an error that multiple bounds are required.\n-                        self.buffer_error(self.infcx.tcx.sess.create_err(\n-                            GenericDoesNotLiveLongEnough {\n+                        let mut diag =\n+                            self.infcx.tcx.sess.create_err(GenericDoesNotLiveLongEnough {\n                                 kind: type_test.generic_kind.to_string(),\n                                 span: type_test_span,\n-                            },\n-                        ));\n+                            });\n+\n+                        // Add notes and suggestions for the case of 'static lifetime\n+                        // implied but not specified when a generic associated types\n+                        // are from higher-ranked trait bounds\n+                        self.suggest_static_lifetime_for_gat_from_hrtb(\n+                            &mut diag,\n+                            type_test.lower_bound,\n+                        );\n+\n+                        self.buffer_error(diag);\n                     }\n                 }\n "}, {"sha": "238172ea3992f5a08b2cac2f0f00b1659d67ae02", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d26e07b91a48047c0acd1e5527f49e57902eb6e7/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26e07b91a48047c0acd1e5527f49e57902eb6e7/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=d26e07b91a48047c0acd1e5527f49e57902eb6e7", "patch": "@@ -527,6 +527,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_values.region_value_str(scc)\n     }\n \n+    pub(crate) fn placeholders_contained_in<'a>(\n+        &'a self,\n+        r: RegionVid,\n+    ) -> impl Iterator<Item = ty::PlaceholderRegion> + 'a {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        self.scc_values.placeholders_contained_in(scc)\n+    }\n+\n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n         let scc = self.constraint_sccs.scc(r.to_region_vid());"}, {"sha": "032cbb01ffbf59a6681f22d5cf3ed65b11174fc8", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d26e07b91a48047c0acd1e5527f49e57902eb6e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26e07b91a48047c0acd1e5527f49e57902eb6e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d26e07b91a48047c0acd1e5527f49e57902eb6e7", "patch": "@@ -100,6 +100,13 @@ impl BoundRegionKind {\n \n         None\n     }\n+\n+    pub fn get_id(&self) -> Option<DefId> {\n+        match *self {\n+            BoundRegionKind::BrNamed(id, _) => return Some(id),\n+            _ => None,\n+        }\n+    }\n }\n \n pub trait Article {"}, {"sha": "a085096e1f8c569d29e8c3a404a18d9c96b8d581", "filename": "tests/ui/generic-associated-types/collectivity-regression.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d26e07b91a48047c0acd1e5527f49e57902eb6e7/tests%2Fui%2Fgeneric-associated-types%2Fcollectivity-regression.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d26e07b91a48047c0acd1e5527f49e57902eb6e7/tests%2Fui%2Fgeneric-associated-types%2Fcollectivity-regression.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fcollectivity-regression.stderr?ref=d26e07b91a48047c0acd1e5527f49e57902eb6e7", "patch": "@@ -9,6 +9,16 @@ LL | |         // probably should work.\n LL | |         let _x = x;\n LL | |     };\n    | |_____^\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/collectivity-regression.rs:11:16\n+   |\n+LL |     for<'a> T: Get<Value<'a> = ()>,\n+   |                ^^^^^^^^^^^^^^^^^^^\n+help: consider restricting the type parameter to the `'static` lifetime\n+   |\n+LL |     for<'a> T: Get<Value<'a> = ()> + 'static,\n+   |                                    +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "277ce8a77e97423d2841035aa8839ce8cf4165aa", "filename": "tests/ui/lifetimes/issue-105507.fixed", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d26e07b91a48047c0acd1e5527f49e57902eb6e7/tests%2Fui%2Flifetimes%2Fissue-105507.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d26e07b91a48047c0acd1e5527f49e57902eb6e7/tests%2Fui%2Flifetimes%2Fissue-105507.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-105507.fixed?ref=d26e07b91a48047c0acd1e5527f49e57902eb6e7", "patch": "@@ -0,0 +1,43 @@\n+// run-rustfix\n+//\n+#![allow(warnings)]\n+struct Wrapper<'a, T: ?Sized>(&'a T);\n+\n+trait Project {\n+    type Projected<'a> where Self: 'a;\n+    fn project(this: Wrapper<'_, Self>) -> Self::Projected<'_>;\n+}\n+trait MyTrait {}\n+trait ProjectedMyTrait {}\n+\n+impl<T> Project for Option<T> {\n+    type Projected<'a> = Option<Wrapper<'a, T>> where T: 'a;\n+    fn project(this: Wrapper<'_, Self>) -> Self::Projected<'_> {\n+        this.0.as_ref().map(Wrapper)\n+    }\n+}\n+\n+impl<T: MyTrait> MyTrait for Option<Wrapper<'_, T>> {}\n+\n+impl<T: ProjectedMyTrait> MyTrait for Wrapper<'_, T> {}\n+\n+impl<T> ProjectedMyTrait for T\n+    where\n+        T: Project,\n+        for<'a> T::Projected<'a>: MyTrait,\n+        //~^ NOTE due to current limitations in the borrow checker, this implies a `'static` lifetime\n+        //~| NOTE due to current limitations in the borrow checker, this implies a `'static` lifetime\n+{}\n+\n+fn require_trait<T: MyTrait>(_: T) {}\n+\n+fn foo<T : MyTrait + 'static + 'static, U : MyTrait + 'static + 'static>(wrap: Wrapper<'_, Option<T>>, wrap1: Wrapper<'_, Option<U>>) {\n+    //~^ HELP consider restricting the type parameter to the `'static` lifetime\n+    //~| HELP consider restricting the type parameter to the `'static` lifetime\n+    require_trait(wrap);\n+    //~^ ERROR `T` does not live long enough\n+    require_trait(wrap1);\n+    //~^ ERROR `U` does not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "f46c6b6f21e86dda274e6e8f8951115e43c86bb3", "filename": "tests/ui/lifetimes/issue-105507.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d26e07b91a48047c0acd1e5527f49e57902eb6e7/tests%2Fui%2Flifetimes%2Fissue-105507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26e07b91a48047c0acd1e5527f49e57902eb6e7/tests%2Fui%2Flifetimes%2Fissue-105507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-105507.rs?ref=d26e07b91a48047c0acd1e5527f49e57902eb6e7", "patch": "@@ -0,0 +1,43 @@\n+// run-rustfix\n+//\n+#![allow(warnings)]\n+struct Wrapper<'a, T: ?Sized>(&'a T);\n+\n+trait Project {\n+    type Projected<'a> where Self: 'a;\n+    fn project(this: Wrapper<'_, Self>) -> Self::Projected<'_>;\n+}\n+trait MyTrait {}\n+trait ProjectedMyTrait {}\n+\n+impl<T> Project for Option<T> {\n+    type Projected<'a> = Option<Wrapper<'a, T>> where T: 'a;\n+    fn project(this: Wrapper<'_, Self>) -> Self::Projected<'_> {\n+        this.0.as_ref().map(Wrapper)\n+    }\n+}\n+\n+impl<T: MyTrait> MyTrait for Option<Wrapper<'_, T>> {}\n+\n+impl<T: ProjectedMyTrait> MyTrait for Wrapper<'_, T> {}\n+\n+impl<T> ProjectedMyTrait for T\n+    where\n+        T: Project,\n+        for<'a> T::Projected<'a>: MyTrait,\n+        //~^ NOTE due to current limitations in the borrow checker, this implies a `'static` lifetime\n+        //~| NOTE due to current limitations in the borrow checker, this implies a `'static` lifetime\n+{}\n+\n+fn require_trait<T: MyTrait>(_: T) {}\n+\n+fn foo<T : MyTrait, U : MyTrait>(wrap: Wrapper<'_, Option<T>>, wrap1: Wrapper<'_, Option<U>>) {\n+    //~^ HELP consider restricting the type parameter to the `'static` lifetime\n+    //~| HELP consider restricting the type parameter to the `'static` lifetime\n+    require_trait(wrap);\n+    //~^ ERROR `T` does not live long enough\n+    require_trait(wrap1);\n+    //~^ ERROR `U` does not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "44d3a7eb9a42075c316aadf5a57cfc54bd48b217", "filename": "tests/ui/lifetimes/issue-105507.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d26e07b91a48047c0acd1e5527f49e57902eb6e7/tests%2Fui%2Flifetimes%2Fissue-105507.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d26e07b91a48047c0acd1e5527f49e57902eb6e7/tests%2Fui%2Flifetimes%2Fissue-105507.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-105507.stderr?ref=d26e07b91a48047c0acd1e5527f49e57902eb6e7", "patch": "@@ -0,0 +1,34 @@\n+error: `T` does not live long enough\n+  --> $DIR/issue-105507.rs:37:5\n+   |\n+LL |     require_trait(wrap);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/issue-105507.rs:27:35\n+   |\n+LL |         for<'a> T::Projected<'a>: MyTrait,\n+   |                                   ^^^^^^^\n+help: consider restricting the type parameter to the `'static` lifetime\n+   |\n+LL | fn foo<T : MyTrait + 'static, U : MyTrait + 'static>(wrap: Wrapper<'_, Option<T>>, wrap1: Wrapper<'_, Option<U>>) {\n+   |                    +++++++++              +++++++++\n+\n+error: `U` does not live long enough\n+  --> $DIR/issue-105507.rs:39:5\n+   |\n+LL |     require_trait(wrap1);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/issue-105507.rs:27:35\n+   |\n+LL |         for<'a> T::Projected<'a>: MyTrait,\n+   |                                   ^^^^^^^\n+help: consider restricting the type parameter to the `'static` lifetime\n+   |\n+LL | fn foo<T : MyTrait + 'static, U : MyTrait + 'static>(wrap: Wrapper<'_, Option<T>>, wrap1: Wrapper<'_, Option<U>>) {\n+   |                    +++++++++              +++++++++\n+\n+error: aborting due to 2 previous errors\n+"}]}