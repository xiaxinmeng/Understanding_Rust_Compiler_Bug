{"sha": "5b1ed09df0528ec47e9007bfbf53ab3e584b97eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMWVkMDlkZjA1MjhlYzQ3ZTkwMDdiZmJmNTNhYjNlNTg0Yjk3ZWI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-08-07T06:04:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-07T06:04:03Z"}, "message": "Rollup merge of #75079 - jyn514:disambiguator, r=Manishearth\n\nDisallow linking to items with a mismatched disambiguator\n\nCloses https://github.com/rust-lang/rust/issues/74851\n\nr? @Manishearth", "tree": {"sha": "9ecd915f473c2d6df71c2cc20071cc17615d50e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ecd915f473c2d6df71c2cc20071cc17615d50e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfLO7UCRBK7hj4Ov3rIwAAdHIIAEg42CXF5q+mFtegGEycg94V\nWsaNOobxxb/dsyVwpUxvnebBs8CWHQJLflMWZbaVQlAFByc0/YdkHvN0EyDRxbnq\n+0H+NuTmvzS7CWYRM1Gn8YOAY118UVO6p8LS+ifZqFZA2vvV0MOa26TY4PiNT0To\ny62gEt0zWwInBEDL9qG57K5fynqyrl2mHNKvIf60MT9WbqG48vzDZAI6zc3fFBgt\nJPuzem+piWJ9ZQ55H9QS8jDdt/fFM0U2MZzfKLnOCGw6/PdgPGzzBd9lmm1KJC1b\nHhALFiSuNOUaDKK1/ESERqG33a0dll+EtaoCP+/C4gRHvy659jwxyO4Xyt+dnpE=\n=3asm\n-----END PGP SIGNATURE-----\n", "payload": "tree 9ecd915f473c2d6df71c2cc20071cc17615d50e5\nparent 5f331c05853983001a1319d4d2116c44a087e5a4\nparent 9914f73f14fc4edbb7595078e97b3ee1f5d3bd4b\nauthor Manish Goregaokar <manishsmail@gmail.com> 1596780243 -0700\ncommitter GitHub <noreply@github.com> 1596780243 -0700\n\nRollup merge of #75079 - jyn514:disambiguator, r=Manishearth\n\nDisallow linking to items with a mismatched disambiguator\n\nCloses https://github.com/rust-lang/rust/issues/74851\n\nr? @Manishearth\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb", "html_url": "https://github.com/rust-lang/rust/commit/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f331c05853983001a1319d4d2116c44a087e5a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f331c05853983001a1319d4d2116c44a087e5a4", "html_url": "https://github.com/rust-lang/rust/commit/5f331c05853983001a1319d4d2116c44a087e5a4"}, {"sha": "9914f73f14fc4edbb7595078e97b3ee1f5d3bd4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9914f73f14fc4edbb7595078e97b3ee1f5d3bd4b", "html_url": "https://github.com/rust-lang/rust/commit/9914f73f14fc4edbb7595078e97b3ee1f5d3bd4b"}], "stats": {"total": 378, "additions": 329, "deletions": 49}, "files": [{"sha": "618f3e99c3f04a3a38617585c1f33bd51e551f80", "filename": "src/librustc_hir/def.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=5b1ed09df0528ec47e9007bfbf53ab3e584b97eb", "patch": "@@ -150,7 +150,7 @@ impl DefKind {\n         }\n     }\n \n-    pub fn matches_ns(&self, ns: Namespace) -> bool {\n+    pub fn ns(&self) -> Option<Namespace> {\n         match self {\n             DefKind::Mod\n             | DefKind::Struct\n@@ -163,17 +163,17 @@ impl DefKind {\n             | DefKind::ForeignTy\n             | DefKind::TraitAlias\n             | DefKind::AssocTy\n-            | DefKind::TyParam => ns == Namespace::TypeNS,\n+            | DefKind::TyParam => Some(Namespace::TypeNS),\n \n             DefKind::Fn\n             | DefKind::Const\n             | DefKind::ConstParam\n             | DefKind::Static\n             | DefKind::Ctor(..)\n             | DefKind::AssocFn\n-            | DefKind::AssocConst => ns == Namespace::ValueNS,\n+            | DefKind::AssocConst => Some(Namespace::ValueNS),\n \n-            DefKind::Macro(..) => ns == Namespace::MacroNS,\n+            DefKind::Macro(..) => Some(Namespace::MacroNS),\n \n             // Not namespaced.\n             DefKind::AnonConst\n@@ -185,7 +185,7 @@ impl DefKind {\n             | DefKind::Use\n             | DefKind::ForeignMod\n             | DefKind::GlobalAsm\n-            | DefKind::Impl => false,\n+            | DefKind::Impl => None,\n         }\n     }\n }\n@@ -453,7 +453,7 @@ impl<Id> Res<Id> {\n \n     pub fn matches_ns(&self, ns: Namespace) -> bool {\n         match self {\n-            Res::Def(kind, ..) => kind.matches_ns(ns),\n+            Res::Def(kind, ..) => kind.ns() == Some(ns),\n             Res::PrimTy(..) | Res::SelfTy(..) | Res::ToolMod => ns == Namespace::TypeNS,\n             Res::SelfCtor(..) | Res::Local(..) => ns == Namespace::ValueNS,\n             Res::NonMacroAttr(..) => ns == Namespace::MacroNS,"}, {"sha": "069d333de183426c724a2a5302cf960b6d8ab569", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=5b1ed09df0528ec47e9007bfbf53ab3e584b97eb", "patch": "@@ -607,6 +607,9 @@ pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n         Res::Def(DefKind::TyAlias, i) => (i, TypeKind::Typedef),\n         Res::Def(DefKind::Enum, i) => (i, TypeKind::Enum),\n         Res::Def(DefKind::Trait, i) => (i, TypeKind::Trait),\n+        Res::Def(DefKind::AssocTy | DefKind::AssocFn | DefKind::AssocConst, i) => {\n+            (cx.tcx.parent(i).unwrap(), TypeKind::Trait)\n+        }\n         Res::Def(DefKind::Struct, i) => (i, TypeKind::Struct),\n         Res::Def(DefKind::Union, i) => (i, TypeKind::Union),\n         Res::Def(DefKind::Mod, i) => (i, TypeKind::Module),"}, {"sha": "f84486347afcdbeca231eccb782e54ee83eec9a2", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 145, "deletions": 43, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=5b1ed09df0528ec47e9007bfbf53ab3e584b97eb", "patch": "@@ -17,6 +17,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n \n+use std::cell::Cell;\n use std::ops::Range;\n \n use crate::clean::*;\n@@ -62,11 +63,15 @@ struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n     // NOTE: this may not necessarily be a module in the current crate\n     mod_ids: Vec<DefId>,\n+    /// This is used to store the kind of associated items,\n+    /// because `clean` and the disambiguator code expect them to be different.\n+    /// See the code for associated items on inherent impls for details.\n+    kind_side_channel: Cell<Option<DefKind>>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        LinkCollector { cx, mod_ids: Vec::new() }\n+        LinkCollector { cx, mod_ids: Vec::new(), kind_side_channel: Cell::new(None) }\n     }\n \n     fn variant_field(\n@@ -174,7 +179,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn resolve(\n         &self,\n         path_str: &str,\n-        disambiguator: Option<&str>,\n+        disambiguator: Option<Disambiguator>,\n         ns: Namespace,\n         current_item: &Option<String>,\n         parent_id: Option<DefId>,\n@@ -214,7 +219,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     Res::Def(DefKind::Mod, _) => {\n                         // This resolved to a module, but if we were passed `type@`,\n                         // we want primitive types to take precedence instead.\n-                        if disambiguator == Some(\"type\") {\n+                        if disambiguator == Some(Disambiguator::Namespace(Namespace::TypeNS)) {\n                             if let Some(prim) = is_primitive(path_str, ns) {\n                                 if extra_fragment.is_some() {\n                                     return Err(ErrorKind::AnchorFailure(AnchorFailure::Primitive));\n@@ -347,6 +352,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 AnchorFailure::AssocConstant\n                             }))\n                         } else {\n+                            // HACK(jynelson): `clean` expects the type, not the associated item.\n+                            // but the disambiguator logic expects the associated item.\n+                            // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                            self.kind_side_channel.replace(Some(item.kind.as_def_kind()));\n                             Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                         }\n                     } else {\n@@ -415,7 +424,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 AnchorFailure::Method\n                             }))\n                         } else {\n-                            Ok((ty_res, Some(format!(\"{}.{}\", kind, item_name))))\n+                            let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                            Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n                         }\n                     } else {\n                         self.variant_field(path_str, current_item, module_id)\n@@ -574,46 +584,14 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             };\n             let resolved_self;\n             let mut path_str;\n+            let disambiguator;\n             let (res, fragment) = {\n-                let mut kind = None;\n-                let mut disambiguator = None;\n-                path_str = if let Some(prefix) =\n-                    [\"struct@\", \"enum@\", \"type@\", \"trait@\", \"union@\", \"module@\", \"mod@\"]\n-                        .iter()\n-                        .find(|p| link.starts_with(**p))\n-                {\n-                    kind = Some(TypeNS);\n-                    disambiguator = Some(&prefix[..prefix.len() - 1]);\n-                    link.trim_start_matches(prefix)\n-                } else if let Some(prefix) =\n-                    [\"const@\", \"static@\", \"value@\", \"function@\", \"fn@\", \"method@\"]\n-                        .iter()\n-                        .find(|p| link.starts_with(**p))\n-                {\n-                    kind = Some(ValueNS);\n-                    disambiguator = Some(&prefix[..prefix.len() - 1]);\n-                    link.trim_start_matches(prefix)\n-                } else if link.ends_with(\"!()\") {\n-                    kind = Some(MacroNS);\n-                    link.trim_end_matches(\"!()\")\n-                } else if link.ends_with(\"()\") {\n-                    kind = Some(ValueNS);\n-                    disambiguator = Some(\"fn\");\n-                    link.trim_end_matches(\"()\")\n-                } else if link.starts_with(\"macro@\") {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"macro\");\n-                    link.trim_start_matches(\"macro@\")\n-                } else if link.starts_with(\"derive@\") {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"derive\");\n-                    link.trim_start_matches(\"derive@\")\n-                } else if link.ends_with('!') {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"macro\");\n-                    link.trim_end_matches('!')\n+                path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n+                    disambiguator = Some(d);\n+                    path\n                 } else {\n-                    &link[..]\n+                    disambiguator = None;\n+                    &link\n                 }\n                 .trim();\n \n@@ -646,7 +624,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                 }\n \n-                match kind {\n+                match disambiguator.map(Disambiguator::ns) {\n                     Some(ns @ ValueNS) => {\n                         match self.resolve(\n                             path_str,\n@@ -789,6 +767,42 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             } else {\n                 debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n \n+                // Disallow e.g. linking to enums with `struct@`\n+                if let Res::Def(kind, id) = res {\n+                    debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n+                    match (self.kind_side_channel.take().unwrap_or(kind), disambiguator) {\n+                        | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n+                        // NOTE: this allows 'method' to mean both normal functions and associated functions\n+                        // This can't cause ambiguity because both are in the same namespace.\n+                        | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n+                        // These are namespaces; allow anything in the namespace to match\n+                        | (_, Some(Disambiguator::Namespace(_)))\n+                        // If no disambiguator given, allow anything\n+                        | (_, None)\n+                        // All of these are valid, so do nothing\n+                        => {}\n+                        (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n+                        (_, Some(Disambiguator::Kind(expected))) => {\n+                            // The resolved item did not match the disambiguator; give a better error than 'not found'\n+                            let msg = format!(\"incompatible link kind for `{}`\", path_str);\n+                            report_diagnostic(cx, &msg, &item, &dox, link_range, |diag, sp| {\n+                                // HACK(jynelson): by looking at the source I saw the DefId we pass\n+                                // for `expected.descr()` doesn't matter, since it's not a crate\n+                                let note = format!(\"this link resolved to {} {}, which is not {} {}\", kind.article(), kind.descr(id), expected.article(), expected.descr(id));\n+                                let suggestion = Disambiguator::display_for(kind, path_str);\n+                                let help_msg = format!(\"to link to the {}, use its disambiguator\", kind.descr(id));\n+                                diag.note(&note);\n+                                if let Some(sp) = sp {\n+                                    diag.span_suggestion(sp, &help_msg, suggestion, Applicability::MaybeIncorrect);\n+                                } else {\n+                                    diag.help(&format!(\"{}: {}\", help_msg, suggestion));\n+                                }\n+                            });\n+                            continue;\n+                        }\n+                    }\n+                }\n+\n                 // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n                 if let Some((src_id, dst_id)) = res\n                     .opt_def_id()\n@@ -837,6 +851,94 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum Disambiguator {\n+    Kind(DefKind),\n+    Namespace(Namespace),\n+}\n+\n+impl Disambiguator {\n+    /// (disambiguator, path_str)\n+    fn from_str(link: &str) -> Result<(Self, &str), ()> {\n+        use Disambiguator::{Kind, Namespace as NS};\n+\n+        let find_suffix = || {\n+            let suffixes = [\n+                (\"!()\", DefKind::Macro(MacroKind::Bang)),\n+                (\"()\", DefKind::Fn),\n+                (\"!\", DefKind::Macro(MacroKind::Bang)),\n+            ];\n+            for &(suffix, kind) in &suffixes {\n+                if link.ends_with(suffix) {\n+                    return Ok((Kind(kind), link.trim_end_matches(suffix)));\n+                }\n+            }\n+            Err(())\n+        };\n+\n+        if let Some(idx) = link.find('@') {\n+            let (prefix, rest) = link.split_at(idx);\n+            let d = match prefix {\n+                \"struct\" => Kind(DefKind::Struct),\n+                \"enum\" => Kind(DefKind::Enum),\n+                \"trait\" => Kind(DefKind::Trait),\n+                \"union\" => Kind(DefKind::Union),\n+                \"module\" | \"mod\" => Kind(DefKind::Mod),\n+                \"const\" | \"constant\" => Kind(DefKind::Const),\n+                \"static\" => Kind(DefKind::Static),\n+                \"function\" | \"fn\" | \"method\" => Kind(DefKind::Fn),\n+                \"derive\" => Kind(DefKind::Macro(MacroKind::Derive)),\n+                \"type\" => NS(Namespace::TypeNS),\n+                \"value\" => NS(Namespace::ValueNS),\n+                \"macro\" => NS(Namespace::MacroNS),\n+                _ => return find_suffix(),\n+            };\n+            Ok((d, &rest[1..]))\n+        } else {\n+            find_suffix()\n+        }\n+    }\n+\n+    fn display_for(kind: DefKind, path_str: &str) -> String {\n+        if kind == DefKind::Macro(MacroKind::Bang) {\n+            return format!(\"{}!\", path_str);\n+        } else if kind == DefKind::Fn || kind == DefKind::AssocFn {\n+            return format!(\"{}()\", path_str);\n+        }\n+        let prefix = match kind {\n+            DefKind::Struct => \"struct\",\n+            DefKind::Enum => \"enum\",\n+            DefKind::Trait => \"trait\",\n+            DefKind::Union => \"union\",\n+            DefKind::Mod => \"mod\",\n+            DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst => {\n+                \"const\"\n+            }\n+            DefKind::Static => \"static\",\n+            DefKind::Macro(MacroKind::Derive) => \"derive\",\n+            // Now handle things that don't have a specific disambiguator\n+            _ => match kind\n+                .ns()\n+                .expect(\"tried to calculate a disambiguator for a def without a namespace?\")\n+            {\n+                Namespace::TypeNS => \"type\",\n+                Namespace::ValueNS => \"value\",\n+                Namespace::MacroNS => \"macro\",\n+            },\n+        };\n+        format!(\"{}@{}\", prefix, path_str)\n+    }\n+\n+    fn ns(self) -> Namespace {\n+        match self {\n+            Self::Namespace(n) => n,\n+            Self::Kind(k) => {\n+                k.ns().expect(\"only DefKinds with a valid namespace can be disambiguators\")\n+            }\n+        }\n+    }\n+}\n+\n /// Reports a diagnostic for an intra-doc link.\n ///\n /// If no link range is provided, or the source span of the link cannot be determined, the span of"}, {"sha": "1a7a2fce7a3f22afb2718df3b32777a713c1fa21", "filename": "src/test/rustdoc-ui/intra-links-disambiguator-mismatch.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs?ref=5b1ed09df0528ec47e9007bfbf53ab3e584b97eb", "patch": "@@ -0,0 +1,68 @@\n+#![deny(broken_intra_doc_links)]\n+//~^ NOTE lint level is defined\n+pub enum S {}\n+\n+macro_rules! m {\n+    () => {};\n+}\n+\n+static s: usize = 0;\n+const c: usize = 0;\n+\n+trait T {}\n+\n+/// Link to [struct@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [mod@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [union@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [trait@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [struct@T]\n+//~^ ERROR incompatible link kind for `T`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [derive@m]\n+//~^ ERROR incompatible link kind for `m`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [const@s]\n+//~^ ERROR incompatible link kind for `s`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [static@c]\n+//~^ ERROR incompatible link kind for `c`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [fn@c]\n+//~^ ERROR incompatible link kind for `c`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [c()]\n+//~^ ERROR incompatible link kind for `c`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [const@f]\n+//~^ ERROR incompatible link kind for `f`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+pub fn f() {}"}, {"sha": "9edf838f9d88b7d6e62f32e154c82f8b48bb2d55", "filename": "src/test/rustdoc-ui/intra-links-disambiguator-mismatch.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr?ref=5b1ed09df0528ec47e9007bfbf53ab3e584b97eb", "patch": "@@ -0,0 +1,95 @@\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:14:14\n+   |\n+LL | /// Link to [struct@S]\n+   |              ^^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this link resolved to an enum, which is not a struct\n+\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:19:14\n+   |\n+LL | /// Link to [mod@S]\n+   |              ^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+   = note: this link resolved to an enum, which is not a module\n+\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:24:14\n+   |\n+LL | /// Link to [union@S]\n+   |              ^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+   = note: this link resolved to an enum, which is not a union\n+\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:29:14\n+   |\n+LL | /// Link to [trait@S]\n+   |              ^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+   = note: this link resolved to an enum, which is not a trait\n+\n+error: incompatible link kind for `T`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:34:14\n+   |\n+LL | /// Link to [struct@T]\n+   |              ^^^^^^^^ help: to link to the trait, use its disambiguator: `trait@T`\n+   |\n+   = note: this link resolved to a trait, which is not a struct\n+\n+error: incompatible link kind for `m`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:39:14\n+   |\n+LL | /// Link to [derive@m]\n+   |              ^^^^^^^^ help: to link to the macro, use its disambiguator: `m!`\n+   |\n+   = note: this link resolved to a macro, which is not a derive macro\n+\n+error: incompatible link kind for `s`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:44:14\n+   |\n+LL | /// Link to [const@s]\n+   |              ^^^^^^^ help: to link to the static, use its disambiguator: `static@s`\n+   |\n+   = note: this link resolved to a static, which is not a constant\n+\n+error: incompatible link kind for `c`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:49:14\n+   |\n+LL | /// Link to [static@c]\n+   |              ^^^^^^^^ help: to link to the constant, use its disambiguator: `const@c`\n+   |\n+   = note: this link resolved to a constant, which is not a static\n+\n+error: incompatible link kind for `c`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:54:14\n+   |\n+LL | /// Link to [fn@c]\n+   |              ^^^^ help: to link to the constant, use its disambiguator: `const@c`\n+   |\n+   = note: this link resolved to a constant, which is not a function\n+\n+error: incompatible link kind for `c`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:59:14\n+   |\n+LL | /// Link to [c()]\n+   |              ^^^ help: to link to the constant, use its disambiguator: `const@c`\n+   |\n+   = note: this link resolved to a constant, which is not a function\n+\n+error: incompatible link kind for `f`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:64:14\n+   |\n+LL | /// Link to [const@f]\n+   |              ^^^^^^^ help: to link to the function, use its disambiguator: `f()`\n+   |\n+   = note: this link resolved to a function, which is not a constant\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "54270414c9dfe818e9ab51b5fc6c115ca6727ef8", "filename": "src/test/rustdoc/intra-link-trait-item.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Ftest%2Frustdoc%2Fintra-link-trait-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1ed09df0528ec47e9007bfbf53ab3e584b97eb/src%2Ftest%2Frustdoc%2Fintra-link-trait-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-trait-item.rs?ref=5b1ed09df0528ec47e9007bfbf53ab3e584b97eb", "patch": "@@ -0,0 +1,12 @@\n+// ignore-tidy-linelength\n+#![deny(broken_intra_doc_links)]\n+\n+/// Link to [S::assoc_fn()]\n+/// Link to [Default::default()]\n+// @has intra_link_trait_item/struct.S.html '//*[@href=\"../intra_link_trait_item/struct.S.html#method.assoc_fn\"]' 'S::assoc_fn()'\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default\"]' 'Default::default()'\n+pub struct S;\n+\n+impl S {\n+    pub fn assoc_fn() {}\n+}"}]}