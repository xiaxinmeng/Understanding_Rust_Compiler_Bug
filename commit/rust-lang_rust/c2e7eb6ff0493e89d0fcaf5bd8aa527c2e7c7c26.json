{"sha": "c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZTdlYjZmZjA0OTNlODlkMGZjYWY1YmQ4YWE1MjdjMmU3YzdjMjY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-25T07:03:45Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-25T07:03:45Z"}, "message": "split core::ptr module into multiple files", "tree": {"sha": "6c905fea0a7bcde0d826ac2284e125d6812d7b70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c905fea0a7bcde0d826ac2284e125d6812d7b70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26", "html_url": "https://github.com/rust-lang/rust/commit/c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "524580312039e4fa5ccf91e8f7093cd755bc1aad", "url": "https://api.github.com/repos/rust-lang/rust/commits/524580312039e4fa5ccf91e8f7093cd755bc1aad", "html_url": "https://github.com/rust-lang/rust/commit/524580312039e4fa5ccf91e8f7093cd755bc1aad"}], "stats": {"total": 801, "additions": 414, "deletions": 387}, "files": [{"sha": "80ac67d8eb57c6bd88612c5516bf554b6630a15d", "filename": "src/libcore/ptr/mod.rs", "status": "renamed", "additions": 8, "deletions": 387, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Manually manage memory through raw pointers.\n //!\n //! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n@@ -65,14 +63,10 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::convert::From;\n use crate::intrinsics;\n-use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::fmt;\n use crate::hash;\n-use crate::marker::{PhantomData, Unsize};\n use crate::mem::{self, MaybeUninit};\n-\n use crate::cmp::Ordering::{self, Less, Equal, Greater};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -84,6 +78,14 @@ pub use crate::intrinsics::copy;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::intrinsics::write_bytes;\n \n+mod non_null;\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+pub use non_null::NonNull;\n+\n+mod unique;\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+pub use unique::Unique;\n+\n /// Executes the destructor (if any) of the pointed-to value.\n ///\n /// This is semantically equivalent to calling [`ptr::read`] and discarding\n@@ -2742,384 +2744,3 @@ impl<T: ?Sized> PartialOrd for *mut T {\n     #[inline]\n     fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n }\n-\n-/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n-/// of this wrapper owns the referent. Useful for building abstractions like\n-/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n-///\n-/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n-/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n-/// the kind of strong aliasing guarantees an instance of `T` can expect:\n-/// the referent of the pointer should not be modified without a unique path to\n-/// its owning Unique.\n-///\n-/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n-/// consider using `NonNull`, which has weaker semantics.\n-///\n-/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n-/// is never dereferenced. This is so that enums may use this forbidden value\n-/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n-/// However the pointer may still dangle if it isn't dereferenced.\n-///\n-/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n-/// for any type which upholds Unique's aliasing requirements.\n-#[unstable(feature = \"ptr_internals\", issue = \"0\",\n-           reason = \"use NonNull instead and consider PhantomData<T> \\\n-                     (if you also use #[may_dangle]), Send, and/or Sync\")]\n-#[doc(hidden)]\n-#[repr(transparent)]\n-#[rustc_layout_scalar_valid_range_start(1)]\n-pub struct Unique<T: ?Sized> {\n-    pointer: *const T,\n-    // NOTE: this marker has no consequences for variance, but is necessary\n-    // for dropck to understand that we logically own a `T`.\n-    //\n-    // For details, see:\n-    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data\n-    _marker: PhantomData<T>,\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> fmt::Debug for Unique<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Pointer::fmt(&self.as_ptr(), f)\n-    }\n-}\n-\n-/// `Unique` pointers are `Send` if `T` is `Send` because the data they\n-/// reference is unaliased. Note that this aliasing invariant is\n-/// unenforced by the type system; the abstraction using the\n-/// `Unique` must enforce it.\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n-\n-/// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n-/// reference is unaliased. Note that this aliasing invariant is\n-/// unenforced by the type system; the abstraction using the\n-/// `Unique` must enforce it.\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: Sized> Unique<T> {\n-    /// Creates a new `Unique` that is dangling, but well-aligned.\n-    ///\n-    /// This is useful for initializing types which lazily allocate, like\n-    /// `Vec::new` does.\n-    ///\n-    /// Note that the pointer value may potentially represent a valid pointer to\n-    /// a `T`, which means this must not be used as a \"not yet initialized\"\n-    /// sentinel value. Types that lazily allocate must track initialization by\n-    /// some other means.\n-    // FIXME: rename to dangling() to match NonNull?\n-    pub const fn empty() -> Self {\n-        unsafe {\n-            Unique::new_unchecked(mem::align_of::<T>() as *mut T)\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> Unique<T> {\n-    /// Creates a new `Unique`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// `ptr` must be non-null.\n-    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        Unique { pointer: ptr as _, _marker: PhantomData }\n-    }\n-\n-    /// Creates a new `Unique` if `ptr` is non-null.\n-    pub fn new(ptr: *mut T) -> Option<Self> {\n-        if !ptr.is_null() {\n-            Some(unsafe { Unique { pointer: ptr as _, _marker: PhantomData } })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Acquires the underlying `*mut` pointer.\n-    pub const fn as_ptr(self) -> *mut T {\n-        self.pointer as *mut T\n-    }\n-\n-    /// Dereferences the content.\n-    ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n-    pub unsafe fn as_ref(&self) -> &T {\n-        &*self.as_ptr()\n-    }\n-\n-    /// Mutably dereferences the content.\n-    ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n-    pub unsafe fn as_mut(&mut self) -> &mut T {\n-        &mut *self.as_ptr()\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> Clone for Unique<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> Copy for Unique<T> { }\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> { }\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> fmt::Pointer for Unique<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Pointer::fmt(&self.as_ptr(), f)\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> From<&mut T> for Unique<T> {\n-    fn from(reference: &mut T) -> Self {\n-        unsafe { Unique { pointer: reference as *mut T, _marker: PhantomData } }\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> From<&T> for Unique<T> {\n-    fn from(reference: &T) -> Self {\n-        unsafe { Unique { pointer: reference as *const T, _marker: PhantomData } }\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n-    fn from(p: NonNull<T>) -> Self {\n-        unsafe { Unique { pointer: p.pointer, _marker: PhantomData } }\n-    }\n-}\n-\n-/// `*mut T` but non-zero and covariant.\n-///\n-/// This is often the correct thing to use when building data structures using\n-/// raw pointers, but is ultimately more dangerous to use because of its additional\n-/// properties. If you're not sure if you should use `NonNull<T>`, just use `*mut T`!\n-///\n-/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n-/// is never dereferenced. This is so that enums may use this forbidden value\n-/// as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`.\n-/// However the pointer may still dangle if it isn't dereferenced.\n-///\n-/// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n-/// for your use case, you should include some [`PhantomData`] in your type to\n-/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n-/// Usually this won't be necessary; covariance is correct for most safe abstractions,\n-/// such as `Box`, `Rc`, `Arc`, `Vec`, and `LinkedList`. This is the case because they\n-/// provide a public API that follows the normal shared XOR mutable rules of Rust.\n-///\n-/// Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does\n-/// not change the fact that mutating through a (pointer derived from a) shared\n-/// reference is undefined behavior unless the mutation happens inside an\n-/// [`UnsafeCell<T>`]. The same goes for creating a mutable reference from a shared\n-/// reference. When using this `From` instance without an `UnsafeCell<T>`,\n-/// it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n-/// is never used for mutation.\n-///\n-/// [`PhantomData`]: ../marker/struct.PhantomData.html\n-/// [`UnsafeCell<T>`]: ../cell/struct.UnsafeCell.html\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-#[repr(transparent)]\n-#[rustc_layout_scalar_valid_range_start(1)]\n-#[cfg_attr(not(stage0), rustc_nonnull_optimization_guaranteed)]\n-pub struct NonNull<T: ?Sized> {\n-    pointer: *const T,\n-}\n-\n-/// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n-// N.B., this impl is unnecessary, but should provide better error messages.\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> !Send for NonNull<T> { }\n-\n-/// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n-// N.B., this impl is unnecessary, but should provide better error messages.\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> !Sync for NonNull<T> { }\n-\n-impl<T: Sized> NonNull<T> {\n-    /// Creates a new `NonNull` that is dangling, but well-aligned.\n-    ///\n-    /// This is useful for initializing types which lazily allocate, like\n-    /// `Vec::new` does.\n-    ///\n-    /// Note that the pointer value may potentially represent a valid pointer to\n-    /// a `T`, which means this must not be used as a \"not yet initialized\"\n-    /// sentinel value. Types that lazily allocate must track initialization by\n-    /// some other means.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub const fn dangling() -> Self {\n-        unsafe {\n-            let ptr = mem::align_of::<T>() as *mut T;\n-            NonNull::new_unchecked(ptr)\n-        }\n-    }\n-}\n-\n-impl<T: ?Sized> NonNull<T> {\n-    /// Creates a new `NonNull`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// `ptr` must be non-null.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        NonNull { pointer: ptr as _ }\n-    }\n-\n-    /// Creates a new `NonNull` if `ptr` is non-null.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub fn new(ptr: *mut T) -> Option<Self> {\n-        if !ptr.is_null() {\n-            Some(unsafe { Self::new_unchecked(ptr) })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Acquires the underlying `*mut` pointer.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub const fn as_ptr(self) -> *mut T {\n-        self.pointer as *mut T\n-    }\n-\n-    /// Dereferences the content.\n-    ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub unsafe fn as_ref(&self) -> &T {\n-        &*self.as_ptr()\n-    }\n-\n-    /// Mutably dereferences the content.\n-    ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n-    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-    #[inline]\n-    pub unsafe fn as_mut(&mut self) -> &mut T {\n-        &mut *self.as_ptr()\n-    }\n-\n-    /// Cast to a pointer of another type\n-    #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n-    #[inline]\n-    pub const fn cast<U>(self) -> NonNull<U> {\n-        unsafe {\n-            NonNull::new_unchecked(self.as_ptr() as *mut U)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Clone for NonNull<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Copy for NonNull<T> { }\n-\n-#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n-\n-#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> fmt::Debug for NonNull<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Pointer::fmt(&self.as_ptr(), f)\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> fmt::Pointer for NonNull<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Pointer::fmt(&self.as_ptr(), f)\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Eq for NonNull<T> {}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> PartialEq for NonNull<T> {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.as_ptr() == other.as_ptr()\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Ord for NonNull<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.as_ptr().cmp(&other.as_ptr())\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> PartialOrd for NonNull<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.as_ptr().partial_cmp(&other.as_ptr())\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> hash::Hash for NonNull<T> {\n-    #[inline]\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        self.as_ptr().hash(state)\n-    }\n-}\n-\n-#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n-    #[inline]\n-    fn from(unique: Unique<T>) -> Self {\n-        unsafe { NonNull { pointer: unique.pointer } }\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> From<&mut T> for NonNull<T> {\n-    #[inline]\n-    fn from(reference: &mut T) -> Self {\n-        unsafe { NonNull { pointer: reference as *mut T } }\n-    }\n-}\n-\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> From<&T> for NonNull<T> {\n-    #[inline]\n-    fn from(reference: &T) -> Self {\n-        unsafe { NonNull { pointer: reference as *const T } }\n-    }\n-}", "previous_filename": "src/libcore/ptr.rs"}, {"sha": "0a6985e334cd05b9adf783ed6f3b4390061e21c7", "filename": "src/libcore/ptr/non_null.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26", "patch": "@@ -0,0 +1,226 @@\n+use crate::convert::From;\n+use crate::ops::{CoerceUnsized, DispatchFromDyn};\n+use crate::fmt;\n+use crate::hash;\n+use crate::marker::Unsize;\n+use crate::mem;\n+use crate::ptr::Unique;\n+use crate::cmp::Ordering;\n+\n+/// `*mut T` but non-zero and covariant.\n+///\n+/// This is often the correct thing to use when building data structures using\n+/// raw pointers, but is ultimately more dangerous to use because of its additional\n+/// properties. If you're not sure if you should use `NonNull<T>`, just use `*mut T`!\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n+/// for your use case, you should include some [`PhantomData`] in your type to\n+/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n+/// Usually this won't be necessary; covariance is correct for most safe abstractions,\n+/// such as `Box`, `Rc`, `Arc`, `Vec`, and `LinkedList`. This is the case because they\n+/// provide a public API that follows the normal shared XOR mutable rules of Rust.\n+///\n+/// Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does\n+/// not change the fact that mutating through a (pointer derived from a) shared\n+/// reference is undefined behavior unless the mutation happens inside an\n+/// [`UnsafeCell<T>`]. The same goes for creating a mutable reference from a shared\n+/// reference. When using this `From` instance without an `UnsafeCell<T>`,\n+/// it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n+/// is never used for mutation.\n+///\n+/// [`PhantomData`]: ../marker/struct.PhantomData.html\n+/// [`UnsafeCell<T>`]: ../cell/struct.UnsafeCell.html\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[cfg_attr(not(stage0), rustc_nonnull_optimization_guaranteed)]\n+pub struct NonNull<T: ?Sized> {\n+    pointer: *const T,\n+}\n+\n+/// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n+// N.B., this impl is unnecessary, but should provide better error messages.\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> !Send for NonNull<T> { }\n+\n+/// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n+// N.B., this impl is unnecessary, but should provide better error messages.\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> !Sync for NonNull<T> { }\n+\n+impl<T: Sized> NonNull<T> {\n+    /// Creates a new `NonNull` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    ///\n+    /// Note that the pointer value may potentially represent a valid pointer to\n+    /// a `T`, which means this must not be used as a \"not yet initialized\"\n+    /// sentinel value. Types that lazily allocate must track initialization by\n+    /// some other means.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub const fn dangling() -> Self {\n+        unsafe {\n+            let ptr = mem::align_of::<T>() as *mut T;\n+            NonNull::new_unchecked(ptr)\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized> NonNull<T> {\n+    /// Creates a new `NonNull`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `ptr` must be non-null.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n+        NonNull { pointer: ptr as _ }\n+    }\n+\n+    /// Creates a new `NonNull` if `ptr` is non-null.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub fn new(ptr: *mut T) -> Option<Self> {\n+        if !ptr.is_null() {\n+            Some(unsafe { Self::new_unchecked(ptr) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Acquires the underlying `*mut` pointer.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub const fn as_ptr(self) -> *mut T {\n+        self.pointer as *mut T\n+    }\n+\n+    /// Dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n+    }\n+\n+    /// Mutably dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n+    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+    #[inline]\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n+    }\n+\n+    /// Cast to a pointer of another type\n+    #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n+    #[inline]\n+    pub const fn cast<U>(self) -> NonNull<U> {\n+        unsafe {\n+            NonNull::new_unchecked(self.as_ptr() as *mut U)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> Clone for NonNull<T> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> Copy for NonNull<T> { }\n+\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> fmt::Debug for NonNull<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> fmt::Pointer for NonNull<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> Eq for NonNull<T> {}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> PartialEq for NonNull<T> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.as_ptr() == other.as_ptr()\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> Ord for NonNull<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.as_ptr().cmp(&other.as_ptr())\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> PartialOrd for NonNull<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.as_ptr().partial_cmp(&other.as_ptr())\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> hash::Hash for NonNull<T> {\n+    #[inline]\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.as_ptr().hash(state)\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n+    #[inline]\n+    fn from(unique: Unique<T>) -> Self {\n+        unsafe { NonNull::new_unchecked(unique.as_ptr()) }\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> From<&mut T> for NonNull<T> {\n+    #[inline]\n+    fn from(reference: &mut T) -> Self {\n+        unsafe { NonNull { pointer: reference as *mut T } }\n+    }\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: ?Sized> From<&T> for NonNull<T> {\n+    #[inline]\n+    fn from(reference: &T) -> Self {\n+        unsafe { NonNull { pointer: reference as *const T } }\n+    }\n+}"}, {"sha": "5911518919e6da4ade3b029651849abcf3a00b62", "filename": "src/libcore/ptr/unique.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=c2e7eb6ff0493e89d0fcaf5bd8aa527c2e7c7c26", "patch": "@@ -0,0 +1,180 @@\n+use crate::convert::From;\n+use crate::ops::{CoerceUnsized, DispatchFromDyn};\n+use crate::fmt;\n+use crate::marker::{PhantomData, Unsize};\n+use crate::mem;\n+use crate::ptr::NonNull;\n+\n+/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n+/// of this wrapper owns the referent. Useful for building abstractions like\n+/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n+///\n+/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n+/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n+/// the kind of strong aliasing guarantees an instance of `T` can expect:\n+/// the referent of the pointer should not be modified without a unique path to\n+/// its owning Unique.\n+///\n+/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n+/// consider using `NonNull`, which has weaker semantics.\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n+/// for any type which upholds Unique's aliasing requirements.\n+#[unstable(feature = \"ptr_internals\", issue = \"0\",\n+           reason = \"use NonNull instead and consider PhantomData<T> \\\n+                     (if you also use #[may_dangle]), Send, and/or Sync\")]\n+#[doc(hidden)]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(1)]\n+pub struct Unique<T: ?Sized> {\n+    pointer: *const T,\n+    // NOTE: this marker has no consequences for variance, but is necessary\n+    // for dropck to understand that we logically own a `T`.\n+    //\n+    // For details, see:\n+    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data\n+    _marker: PhantomData<T>,\n+}\n+\n+/// `Unique` pointers are `Send` if `T` is `Send` because the data they\n+/// reference is unaliased. Note that this aliasing invariant is\n+/// unenforced by the type system; the abstraction using the\n+/// `Unique` must enforce it.\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n+\n+/// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n+/// reference is unaliased. Note that this aliasing invariant is\n+/// unenforced by the type system; the abstraction using the\n+/// `Unique` must enforce it.\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: Sized> Unique<T> {\n+    /// Creates a new `Unique` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    ///\n+    /// Note that the pointer value may potentially represent a valid pointer to\n+    /// a `T`, which means this must not be used as a \"not yet initialized\"\n+    /// sentinel value. Types that lazily allocate must track initialization by\n+    /// some other means.\n+    // FIXME: rename to dangling() to match NonNull?\n+    #[inline]\n+    pub const fn empty() -> Self {\n+        unsafe {\n+            Unique::new_unchecked(mem::align_of::<T>() as *mut T)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> Unique<T> {\n+    /// Creates a new `Unique`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `ptr` must be non-null.\n+    #[inline]\n+    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n+        Unique { pointer: ptr as _, _marker: PhantomData }\n+    }\n+\n+    /// Creates a new `Unique` if `ptr` is non-null.\n+    #[inline]\n+    pub fn new(ptr: *mut T) -> Option<Self> {\n+        if !ptr.is_null() {\n+            Some(unsafe { Unique { pointer: ptr as _, _marker: PhantomData } })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Acquires the underlying `*mut` pointer.\n+    #[inline]\n+    pub const fn as_ptr(self) -> *mut T {\n+        self.pointer as *mut T\n+    }\n+\n+    /// Dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n+    #[inline]\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n+    }\n+\n+    /// Mutably dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n+    #[inline]\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> Clone for Unique<T> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> Copy for Unique<T> { }\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> fmt::Debug for Unique<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> fmt::Pointer for Unique<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> From<&mut T> for Unique<T> {\n+    #[inline]\n+    fn from(reference: &mut T) -> Self {\n+        unsafe { Unique { pointer: reference as *mut T, _marker: PhantomData } }\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> From<&T> for Unique<T> {\n+    #[inline]\n+    fn from(reference: &T) -> Self {\n+        unsafe { Unique { pointer: reference as *const T, _marker: PhantomData } }\n+    }\n+}\n+\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n+    #[inline]\n+    fn from(p: NonNull<T>) -> Self {\n+        unsafe { Unique::new_unchecked(p.as_ptr()) }\n+    }\n+}"}]}