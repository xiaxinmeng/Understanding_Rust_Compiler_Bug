{"sha": "52efe55d0425d963ee949be96e36d584a603a455", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyZWZlNTVkMDQyNWQ5NjNlZTk0OWJlOTZlMzZkNTg0YTYwM2E0NTU=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2015-05-11T07:55:21Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2015-05-11T08:16:09Z"}, "message": "Handle overflow properly in core::slice\n\ncore::slice was originally written to tolerate overflow (notably, with\nslices of zero-sized elements), but it was never updated to use wrapping\narithmetic when overflow traps were added.\n\nAlso correctly handle the case of calling .nth() on an Iter with a\nzero-sized element type. The iterator was assuming that the pointer\nvalue of the returned reference was meaningful, but that's not true for\nzero-sized elements.\n\nFixes #25016.", "tree": {"sha": "f3cef7424da5bcd5a48c7eecaafdcce593c5ebd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3cef7424da5bcd5a48c7eecaafdcce593c5ebd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52efe55d0425d963ee949be96e36d584a603a455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52efe55d0425d963ee949be96e36d584a603a455", "html_url": "https://github.com/rust-lang/rust/commit/52efe55d0425d963ee949be96e36d584a603a455", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52efe55d0425d963ee949be96e36d584a603a455/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73345185793cca8a0b4c77aa87973a2634a0c492", "url": "https://api.github.com/repos/rust-lang/rust/commits/73345185793cca8a0b4c77aa87973a2634a0c492", "html_url": "https://github.com/rust-lang/rust/commit/73345185793cca8a0b4c77aa87973a2634a0c492"}], "stats": {"total": 85, "additions": 46, "deletions": 39}, "files": [{"sha": "f9aa83d241a75cc690d3930dcc72c94e32a59633", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 12, "deletions": 39, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/52efe55d0425d963ee949be96e36d584a603a455/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52efe55d0425d963ee949be96e36d584a603a455/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=52efe55d0425d963ee949be96e36d584a603a455", "patch": "@@ -140,7 +140,7 @@ impl<T> SliceExt for [T] {\n             assume(!p.is_null());\n             if mem::size_of::<T>() == 0 {\n                 Iter {ptr: p,\n-                      end: (p as usize + self.len()) as *const T,\n+                      end: ((p as usize).wrapping_add(self.len())) as *const T,\n                       _marker: marker::PhantomData}\n             } else {\n                 Iter {ptr: p,\n@@ -277,7 +277,7 @@ impl<T> SliceExt for [T] {\n             assume(!p.is_null());\n             if mem::size_of::<T>() == 0 {\n                 IterMut {ptr: p,\n-                         end: (p as usize + self.len()) as *mut T,\n+                         end: ((p as usize).wrapping_add(self.len())) as *mut T,\n                          _marker: marker::PhantomData}\n             } else {\n                 IterMut {ptr: p,\n@@ -632,35 +632,17 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n \n \n // Use macros to be generic over const/mut\n-//\n-// They require non-negative `$by` because otherwise the expression\n-// `(ptr as usize + $by)` would interpret `-1` as `usize::MAX` (and\n-// thus trigger a panic when overflow checks are on).\n-\n-// Use this to do `$ptr + $by`, where `$by` is non-negative.\n-macro_rules! slice_add_offset {\n+macro_rules! slice_offset {\n     ($ptr:expr, $by:expr) => {{\n         let ptr = $ptr;\n         if size_from_ptr(ptr) == 0 {\n-            transmute(ptr as usize + $by)\n+            transmute((ptr as isize).wrapping_add($by))\n         } else {\n             ptr.offset($by)\n         }\n     }};\n }\n \n-// Use this to do `$ptr - $by`, where `$by` is non-negative.\n-macro_rules! slice_sub_offset {\n-    ($ptr:expr, $by:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            transmute(ptr as usize - $by)\n-        } else {\n-            ptr.offset(-$by)\n-        }\n-    }};\n-}\n-\n macro_rules! slice_ref {\n     ($ptr:expr) => {{\n         let ptr = $ptr;\n@@ -684,21 +666,19 @@ macro_rules! iterator {\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n-                    ::intrinsics::assume(!self.ptr.is_null());\n-                    ::intrinsics::assume(!self.end.is_null());\n                     if self.ptr == self.end {\n                         None\n                     } else {\n                         let old = self.ptr;\n-                        self.ptr = slice_add_offset!(self.ptr, 1);\n+                        self.ptr = slice_offset!(self.ptr, 1);\n                         Some(slice_ref!(old))\n                     }\n                 }\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (usize, Option<usize>) {\n-                let diff = (self.end as usize) - (self.ptr as usize);\n+                let diff = (self.end as usize).wrapping_sub(self.ptr as usize);\n                 let size = mem::size_of::<T>();\n                 let exact = diff / (if size == 0 {1} else {size});\n                 (exact, Some(exact))\n@@ -727,12 +707,10 @@ macro_rules! iterator {\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n-                    ::intrinsics::assume(!self.ptr.is_null());\n-                    ::intrinsics::assume(!self.end.is_null());\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        self.end = slice_sub_offset!(self.end, 1);\n+                        self.end = slice_offset!(self.end, -1);\n                         Some(slice_ref!(self.end))\n                     }\n                 }\n@@ -743,7 +721,7 @@ macro_rules! iterator {\n \n macro_rules! make_slice {\n     ($t: ty => $result: ty: $start: expr, $end: expr) => {{\n-        let diff = $end as usize - $start as usize;\n+        let diff = ($end as usize).wrapping_sub($start as usize);\n         let len = if mem::size_of::<T>() == 0 {\n             diff\n         } else {\n@@ -757,7 +735,7 @@ macro_rules! make_slice {\n \n macro_rules! make_mut_slice {\n     ($t: ty => $result: ty: $start: expr, $end: expr) => {{\n-        let diff = $end as usize - $start as usize;\n+        let diff = ($end as usize).wrapping_sub($start as usize);\n         let len = if mem::size_of::<T>() == 0 {\n             diff\n         } else {\n@@ -794,7 +772,7 @@ impl<'a, T> Iter<'a, T> {\n     fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n         match self.as_slice().get(n) {\n             Some(elem_ref) => unsafe {\n-                self.ptr = slice_add_offset!(elem_ref as *const _, 1);\n+                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n                 Some(slice_ref!(elem_ref))\n             },\n             None => {\n@@ -827,12 +805,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     fn idx(&mut self, index: usize) -> Option<&'a T> {\n         unsafe {\n             if index < self.indexable() {\n-                if mem::size_of::<T>() == 0 {\n-                    // Use a non-null pointer value\n-                    Some(&mut *(1 as *mut _))\n-                } else {\n-                    Some(transmute(self.ptr.offset(index as isize)))\n-                }\n+                Some(slice_ref!(self.ptr.offset(index as isize)))\n             } else {\n                 None\n             }\n@@ -867,7 +840,7 @@ impl<'a, T> IterMut<'a, T> {\n     fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n         match make_mut_slice!(T => &'a mut [T]: self.ptr, self.end).get_mut(n) {\n             Some(elem_ref) => unsafe {\n-                self.ptr = slice_add_offset!(elem_ref as *mut _, 1);\n+                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n                 Some(slice_ref!(elem_ref))\n             },\n             None => {"}, {"sha": "98b668031a894633f366faa87d02198c331cd32f", "filename": "src/test/run-pass/slice-of-zero-size-elements.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/52efe55d0425d963ee949be96e36d584a603a455/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52efe55d0425d963ee949be96e36d584a603a455/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs?ref=52efe55d0425d963ee949be96e36d584a603a455", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C debug-assertions\n+\n+use std::slice;\n+\n+pub fn main() {\n+    // In a slice of zero-size elements the pointer is meaningless.\n+    // Ensure iteration still works even if the pointer is at the end of the address space.\n+    let slice: &[()] = unsafe { slice::from_raw_parts(-5isize as *const (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter().count(), 10);\n+\n+    // .nth() on the iterator should also behave correctly\n+    let mut it = slice.iter();\n+    assert!(it.nth(5).is_some());\n+    assert_eq!(it.count(), 4);\n+\n+    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(-5isize as *mut (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter_mut().count(), 10);\n+\n+    let mut it = slice.iter_mut();\n+    assert!(it.nth(5).is_some());\n+    assert_eq!(it.count(), 4);\n+}"}]}