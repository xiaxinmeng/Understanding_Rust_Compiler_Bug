{"sha": "2c7a19a10df23f132dfa96bea49bc3a6a16cc231", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjN2ExOWExMGRmMjNmMTMyZGZhOTZiZWE0OWJjM2E2YTE2Y2MyMzE=", "commit": {"author": {"name": "Vincent Esche", "email": "regexident@gmail.com", "date": "2016-01-22T16:13:17Z"}, "committer": {"name": "Vincent Esche", "email": "regexident@gmail.com", "date": "2016-01-22T16:13:17Z"}, "message": "Adjusted PR to better match project's coding style.", "tree": {"sha": "6a2979f075cd9dd20d060e43c0922588d2226624", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a2979f075cd9dd20d060e43c0922588d2226624"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c7a19a10df23f132dfa96bea49bc3a6a16cc231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c7a19a10df23f132dfa96bea49bc3a6a16cc231", "html_url": "https://github.com/rust-lang/rust/commit/2c7a19a10df23f132dfa96bea49bc3a6a16cc231", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c7a19a10df23f132dfa96bea49bc3a6a16cc231/comments", "author": {"login": "regexident", "id": 138017, "node_id": "MDQ6VXNlcjEzODAxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/138017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/regexident", "html_url": "https://github.com/regexident", "followers_url": "https://api.github.com/users/regexident/followers", "following_url": "https://api.github.com/users/regexident/following{/other_user}", "gists_url": "https://api.github.com/users/regexident/gists{/gist_id}", "starred_url": "https://api.github.com/users/regexident/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/regexident/subscriptions", "organizations_url": "https://api.github.com/users/regexident/orgs", "repos_url": "https://api.github.com/users/regexident/repos", "events_url": "https://api.github.com/users/regexident/events{/privacy}", "received_events_url": "https://api.github.com/users/regexident/received_events", "type": "User", "site_admin": false}, "committer": {"login": "regexident", "id": 138017, "node_id": "MDQ6VXNlcjEzODAxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/138017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/regexident", "html_url": "https://github.com/regexident", "followers_url": "https://api.github.com/users/regexident/followers", "following_url": "https://api.github.com/users/regexident/following{/other_user}", "gists_url": "https://api.github.com/users/regexident/gists{/gist_id}", "starred_url": "https://api.github.com/users/regexident/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/regexident/subscriptions", "organizations_url": "https://api.github.com/users/regexident/orgs", "repos_url": "https://api.github.com/users/regexident/repos", "events_url": "https://api.github.com/users/regexident/events{/privacy}", "received_events_url": "https://api.github.com/users/regexident/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70692ce27953c91800549d6929b24e32b003c4f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/70692ce27953c91800549d6929b24e32b003c4f0", "html_url": "https://github.com/rust-lang/rust/commit/70692ce27953c91800549d6929b24e32b003c4f0"}], "stats": {"total": 78, "additions": 38, "deletions": 40}, "files": [{"sha": "192c512044be9756493aea9467ce92245605a34b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2c7a19a10df23f132dfa96bea49bc3a6a16cc231/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7a19a10df23f132dfa96bea49bc3a6a16cc231/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=2c7a19a10df23f132dfa96bea49bc3a6a16cc231", "patch": "@@ -616,7 +616,8 @@ fn missing_constructors(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n         .collect();\n     all_constructors(cx, left_ty, max_slice_length)\n         .into_iter()\n-        .filter(|c| !used_constructors.contains(c)).collect()\n+        .filter(|c| !used_constructors.contains(c))\n+        .collect()\n }\n \n /// This determines the set of all possible constructors of a pattern matching\n@@ -695,47 +696,44 @@ fn is_useful(cx: &MatchCheckCtxt,\n \n     let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n     if constructors.is_empty() {\n-        match &missing_constructors(cx, matrix, left_ty, max_slice_length)[..] {\n-            [] => {\n-                all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n-                    match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n-                        UsefulWithWitness(pats) => UsefulWithWitness({\n-                            let arity = constructor_arity(cx, &c, left_ty);\n-                            let mut result = {\n-                                let pat_slice = &pats[..];\n-                                let subpats: Vec<_> = (0..arity).map(|i| {\n-                                    pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n-                                }).collect();\n-                                vec![construct_witness(cx, &c, subpats, left_ty)]\n-                            };\n-                            result.extend(pats.into_iter().skip(arity));\n-                            result\n-                        }),\n-                        result => result\n-                    }\n-                }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n-            },\n-\n-            [constructors..] => {\n-                let matrix = rows.iter().filter_map(|r| {\n-                    if pat_is_binding_or_wild(&cx.tcx.def_map.borrow(), raw_pat(r[0])) {\n-                        Some(r[1..].to_vec())\n-                    } else {\n-                        None\n-                    }\n-                }).collect();\n-                match is_useful(cx, &matrix, &v[1..], witness) {\n-                    UsefulWithWitness(pats) => {\n-                        let mut new_pats: Vec<_> = constructors.into_iter().map(|constructor| {\n-                            let arity = constructor_arity(cx, &constructor, left_ty);\n-                            let wild_pats = vec![DUMMY_WILD_PAT; arity];\n-                            construct_witness(cx, &constructor, wild_pats, left_ty)\n-                        }).collect();\n-                        new_pats.extend(pats);\n-                        UsefulWithWitness(new_pats)\n-                    },\n+        let constructors = missing_constructors(cx, matrix, left_ty, max_slice_length);\n+        if constructors.is_empty() {\n+            all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n+                match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n+                    UsefulWithWitness(pats) => UsefulWithWitness({\n+                        let arity = constructor_arity(cx, &c, left_ty);\n+                        let mut result = {\n+                            let pat_slice = &pats[..];\n+                            let subpats: Vec<_> = (0..arity).map(|i| {\n+                                pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n+                            }).collect();\n+                            vec![construct_witness(cx, &c, subpats, left_ty)]\n+                        };\n+                        result.extend(pats.into_iter().skip(arity));\n+                        result\n+                    }),\n                     result => result\n                 }\n+            }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+        } else {\n+            let matrix = rows.iter().filter_map(|r| {\n+                if pat_is_binding_or_wild(&cx.tcx.def_map.borrow(), raw_pat(r[0])) {\n+                    Some(r[1..].to_vec())\n+                } else {\n+                    None\n+                }\n+            }).collect();\n+            match is_useful(cx, &matrix, &v[1..], witness) {\n+                UsefulWithWitness(pats) => {\n+                    let mut new_pats: Vec<_> = constructors.into_iter().map(|constructor| {\n+                        let arity = constructor_arity(cx, &constructor, left_ty);\n+                        let wild_pats = vec![DUMMY_WILD_PAT; arity];\n+                        construct_witness(cx, &constructor, wild_pats, left_ty)\n+                    }).collect();\n+                    new_pats.extend(pats);\n+                    UsefulWithWitness(new_pats)\n+                },\n+                result => result\n             }\n         }\n     } else {"}]}