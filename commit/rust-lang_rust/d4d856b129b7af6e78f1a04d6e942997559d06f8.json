{"sha": "d4d856b129b7af6e78f1a04d6e942997559d06f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZDg1NmIxMjliN2FmNmU3OGYxYTA0ZDZlOTQyOTk3NTU5ZDA2Zjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-21T08:01:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-21T08:01:47Z"}, "message": "auto merge of #8582 : thestinger/rust/container, r=thestinger\n\n5f3a637 r=huonw\r\n934a5eb r=thestinger\r\n0f6e90a r=cmr", "tree": {"sha": "7954e22e4749955282aef9f81696a6ffaabb1cca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7954e22e4749955282aef9f81696a6ffaabb1cca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4d856b129b7af6e78f1a04d6e942997559d06f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d856b129b7af6e78f1a04d6e942997559d06f8", "html_url": "https://github.com/rust-lang/rust/commit/d4d856b129b7af6e78f1a04d6e942997559d06f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4d856b129b7af6e78f1a04d6e942997559d06f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48dded95c68b61df02b4c7b175c3219e6d7f4e4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/48dded95c68b61df02b4c7b175c3219e6d7f4e4d", "html_url": "https://github.com/rust-lang/rust/commit/48dded95c68b61df02b4c7b175c3219e6d7f4e4d"}, {"sha": "0f6e90a5fd7a19382e3d3028bfcc36eb57135515", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f6e90a5fd7a19382e3d3028bfcc36eb57135515", "html_url": "https://github.com/rust-lang/rust/commit/0f6e90a5fd7a19382e3d3028bfcc36eb57135515"}], "stats": {"total": 603, "additions": 284, "deletions": 319}, "files": [{"sha": "f070ae37dda8da2807a11f092f0e4cf27def15af", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/configure", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -739,6 +739,7 @@ do\n     make_dir $h/test/doc-tutorial-ffi\n     make_dir $h/test/doc-tutorial-macros\n     make_dir $h/test/doc-tutorial-borrowed-ptr\n+    make_dir $h/test/doc-tutorial-container\n     make_dir $h/test/doc-tutorial-tasks\n     make_dir $h/test/doc-tutorial-conditions\n     make_dir $h/test/doc-rust"}, {"sha": "4cd9dc3a1162d445865bc87eb311a82984b619d7", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -2864,17 +2864,16 @@ the vtable pointer for the `T` implementation of `R`, and the pointer value of `\n An example of an object type:\n \n ~~~~~~~~\n-# use std::int;\n trait Printable {\n-  fn to_str(&self) -> ~str;\n+  fn to_string(&self) -> ~str;\n }\n \n impl Printable for int {\n-  fn to_str(&self) -> ~str { int::to_str(*self) }\n+  fn to_string(&self) -> ~str { self.to_str() }\n }\n \n fn print(a: @Printable) {\n-   println(a.to_str());\n+   println(a.to_string());\n }\n \n fn main() {"}, {"sha": "37ca561f74a9ba9e396a8711039636c1fdc3b79f", "filename": "doc/tutorial-container.md", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -163,7 +163,7 @@ assert_eq!(sum, 57);\n The `for` keyword can be used as sugar for iterating through any iterator:\n \n ~~~\n-let xs = [2, 3, 5, 7, 11, 13, 17];\n+let xs = [2u, 3, 5, 7, 11, 13, 17];\n \n // print out all the elements in the vector\n for x in xs.iter() {\n@@ -219,7 +219,7 @@ Containers can provide conversion from iterators through `collect` by\n implementing the `FromIterator` trait. For example, the implementation for\n vectors is as follows:\n \n-~~~\n+~~~ {.xfail-test}\n impl<A> FromIterator<A> for ~[A] {\n     pub fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();\n@@ -237,7 +237,7 @@ impl<A> FromIterator<A> for ~[A] {\n The `Iterator` trait provides a `size_hint` default method, returning a lower\n bound and optionally on upper bound on the length of the iterator:\n \n-~~~\n+~~~ {.xfail-test}\n fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n ~~~\n \n@@ -319,6 +319,16 @@ for x in it.invert() {\n }\n ~~~\n \n+The `reverse_` method is also available for any double-ended iterator yielding\n+mutable references. It can be used to reverse a container in-place. Note that\n+the trailing underscore is a workaround for issue #5898 and will be removed.\n+\n+~~~\n+let mut ys = [1, 2, 3, 4, 5];\n+ys.mut_iter().reverse_();\n+assert_eq!(ys, [5, 4, 3, 2, 1]);\n+~~~\n+\n ## Random-access iterators\n \n The `RandomAccessIterator` trait represents an iterator offering random access"}, {"sha": "958c15737615a3bbed9117d2a0a492a65709aaef", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -555,12 +555,11 @@ while cake_amount > 0 {\n `loop` denotes an infinite loop, and is the preferred way of writing `while true`:\n \n ~~~~\n-use std::int;\n-let mut x = 5;\n+let mut x = 5u;\n loop {\n     x += x - 3;\n     if x % 5 == 0 { break; }\n-    println(int::to_str(x));\n+    println(x.to_str());\n }\n ~~~~\n "}, {"sha": "02fcf61412f5afda7e3724fc0de985871eca0033", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -20,7 +20,7 @@ TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n # Markdown files under doc/ that should have their code extracted and run\n DOC_TEST_NAMES = tutorial tutorial-ffi tutorial-macros tutorial-borrowed-ptr \\\n-                 tutorial-tasks tutorial-conditions rust\n+                 tutorial-tasks tutorial-conditions tutorial-container rust\n \n ######################################################################\n # Environment configuration"}, {"sha": "d2d6b540cff4cf50bc6b10f67974776823e02d28", "filename": "src/libextra/crypto/digest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::uint;\n use std::vec;\n \n \n@@ -71,7 +70,7 @@ pub trait Digest {\n fn to_hex(rr: &[u8]) -> ~str {\n     let mut s = ~\"\";\n     for b in rr.iter() {\n-        let hex = uint::to_str_radix(*b as uint, 16u);\n+        let hex = (*b as uint).to_str_radix(16u);\n         if hex.len() == 1 {\n             s.push_char('0');\n         }"}, {"sha": "caf2c41d31d6595dd380d5bacd986731a4276a7f", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -55,7 +55,6 @@ pub mod flatpipes;\n \n pub mod container;\n pub mod bitv;\n-pub mod fun_treemap;\n pub mod list;\n pub mod ringbuf;\n pub mod priority_queue;"}, {"sha": "edbe323ec2d0bde3c07755bc45d5f03a5c488e06", "filename": "src/libextra/fun_treemap.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/48dded95c68b61df02b4c7b175c3219e6d7f4e4d/src%2Flibextra%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dded95c68b61df02b4c7b175c3219e6d7f4e4d/src%2Flibextra%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffun_treemap.rs?ref=48dded95c68b61df02b4c7b175c3219e6d7f4e4d", "patch": "@@ -1,84 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * A functional key,value store that works on anything.\n- *\n- * This works using a binary search tree. In the first version, it's a\n- * very naive algorithm, but it will probably be updated to be a\n- * red-black tree or something else.\n- *\n- * This is copied and modified from treemap right now. It's missing a lot\n- * of features.\n- */\n-\n-\n-use std::cmp::{Eq, Ord};\n-use std::option::{Some, None};\n-\n-pub type Treemap<K, V> = @TreeNode<K, V>;\n-\n-enum TreeNode<K, V> {\n-    Empty,\n-    Node(@K, @V, @TreeNode<K, V>, @TreeNode<K, V>)\n-}\n-\n-/// Create a treemap\n-pub fn init<K: 'static, V: 'static>() -> Treemap<K, V> {\n-    @Empty\n-}\n-\n-/// Insert a value into the map\n-pub fn insert<K:Eq + Ord + 'static,\n-              V:'static>(\n-              m: Treemap<K, V>,\n-              k: K,\n-              v: V)\n-              -> Treemap<K, V> {\n-    @match m {\n-        @Empty => Node(@k, @v, @Empty, @Empty),\n-        @Node(kk, vv, left, right) => cond!(\n-            (k <  *kk) { Node(kk, vv, insert(left, k, v), right) }\n-            (k == *kk) { Node(kk, @v, left, right)               }\n-            _          { Node(kk, vv, left, insert(right, k, v)) }\n-        )\n-    }\n-}\n-\n-/// Find a value based on the key\n-pub fn find<K:Eq + Ord + 'static,\n-            V:Clone + 'static>(\n-            m: Treemap<K, V>,\n-            k: K)\n-            -> Option<V> {\n-    match *m {\n-        Empty => None,\n-        Node(kk, v, left, right) => cond!(\n-            (k == *kk) { Some((*v).clone()) }\n-            (k <  *kk) { find(left, k)  }\n-            _          { find(right, k) }\n-        )\n-    }\n-}\n-\n-/// Visit all pairs in the map in order.\n-pub fn traverse<K, V>(m: Treemap<K, V>, f: &fn(&K, &V)) {\n-    match *m {\n-        Empty => (),\n-        // Previously, this had what looked like redundant\n-        // matches to me, so I changed it. but that may be a\n-        // de-optimization -- tjc\n-        Node(@ref k, @ref v, left, right) => {\n-            traverse(left, |k,v| f(k,v));\n-            f(k, v);\n-            traverse(right, |k,v| f(k,v));\n-        }\n-    }\n-}"}, {"sha": "abce22f98c6bf712c591f53177760533b8be639e", "filename": "src/libextra/md4.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n \n-use std::uint;\n use std::vec;\n \n struct Quad {\n@@ -121,7 +120,7 @@ pub fn md4_str(msg: &[u8]) -> ~str {\n             if byte <= 16u8 {\n                 result.push_char('0')\n             }\n-            result.push_str(uint::to_str_radix(byte as uint, 16u));\n+            result.push_str((byte as uint).to_str_radix(16u));\n             i += 1u32;\n         }\n     }"}, {"sha": "c86c4dd07ed2f2034da4c13ddcf2ea4d7aa78b27", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -525,7 +525,7 @@ impl ToStrRadix for BigUint {\n             if v.is_empty() { return ~\"0\" }\n             let mut s = str::with_capacity(v.len() * l);\n             for n in v.rev_iter() {\n-                let ss = uint::to_str_radix(*n as uint, radix);\n+                let ss = (*n as uint).to_str_radix(radix);\n                 s.push_str(\"0\".repeat(l - ss.len()));\n                 s.push_str(ss);\n             }"}, {"sha": "257d941e4afff6d3db6c579555179e265013e8b3", "filename": "src/libextra/time.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -10,8 +10,6 @@\n \n #[allow(missing_doc)];\n \n-\n-use std::int;\n use std::io;\n use std::num;\n use std::str;\n@@ -824,7 +822,7 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n           //'U' {}\n           'u' => {\n             let i = tm.tm_wday as int;\n-            int::to_str(if i == 0 { 7 } else { i })\n+            (if i == 0 { 7 } else { i }).to_str()\n           }\n           //'V' {}\n           'v' => {\n@@ -834,10 +832,10 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n                 parse_type('Y', tm))\n           }\n           //'W' {}\n-          'w' => int::to_str(tm.tm_wday as int),\n+          'w' => (tm.tm_wday as int).to_str(),\n           //'X' {}\n           //'x' {}\n-          'Y' => int::to_str(tm.tm_year as int + 1900),\n+          'Y' => (tm.tm_year as int + 1900).to_str(),\n           'y' => fmt!(\"%02d\", (tm.tm_year as int + 1900) % 100),\n           'Z' => tm.tm_zone.clone(),\n           'z' => {"}, {"sha": "1ddebbb428010d3cbc8baf906ada3db835ad6b29", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -26,7 +26,6 @@ use util::common::time;\n use util::ppaux;\n \n use std::hashmap::{HashMap,HashSet};\n-use std::int;\n use std::io;\n use std::os;\n use std::vec;\n@@ -454,21 +453,21 @@ pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n         match node {\n           pprust::node_item(s, item) => {\n             pp::space(s.s);\n-            pprust::synth_comment(s, int::to_str(item.id));\n+            pprust::synth_comment(s, item.id.to_str());\n           }\n           pprust::node_block(s, ref blk) => {\n             pp::space(s.s);\n             pprust::synth_comment(\n-                s, ~\"block \" + int::to_str(blk.id));\n+                s, ~\"block \" + blk.id.to_str());\n           }\n           pprust::node_expr(s, expr) => {\n             pp::space(s.s);\n-            pprust::synth_comment(s, int::to_str(expr.id));\n+            pprust::synth_comment(s, expr.id.to_str());\n             pprust::pclose(s);\n           }\n           pprust::node_pat(s, pat) => {\n             pp::space(s.s);\n-            pprust::synth_comment(s, ~\"pat \" + int::to_str(pat.id));\n+            pprust::synth_comment(s, ~\"pat \" + pat.id.to_str());\n           }\n         }\n     }"}, {"sha": "eba01c8d399e86d5ee46a23c8ba0b60d6f82cb93", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -25,7 +25,6 @@ use std::hash::HashUtil;\n use std::hashmap::{HashMap, HashSet};\n use std::io;\n use std::str;\n-use std::uint;\n use std::vec;\n use extra::flate;\n use extra::serialize::Encodable;\n@@ -303,7 +302,7 @@ fn encode_disr_val(_: &EncodeContext,\n                    ebml_w: &mut writer::Encoder,\n                    disr_val: uint) {\n     ebml_w.start_tag(tag_disr_val);\n-    let s = uint::to_str(disr_val);\n+    let s = disr_val.to_str();\n     ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }"}, {"sha": "5611808cc6d982225d6a7357f667633ea266b104", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -17,7 +17,6 @@ use middle::ty;\n use std::hashmap::HashMap;\n use std::io::WriterUtil;\n use std::io;\n-use std::uint;\n use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::*;\n@@ -324,7 +323,7 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n         w.write_char('p');\n         w.write_str((cx.ds)(did));\n         w.write_char('|');\n-        w.write_str(uint::to_str(id));\n+        w.write_str(id.to_str());\n       }\n       ty::ty_self(did) => {\n         w.write_char('s');"}, {"sha": "50b5140505ef35ed8114a3fc1efc84a283c81035", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -71,7 +71,6 @@ use std::hash;\n use std::hashmap::HashMap;\n use std::io;\n use std::libc::c_uint;\n-use std::uint;\n use std::vec;\n use std::local_data;\n use extra::time;\n@@ -719,7 +718,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n                   for variant in (*variants).iter() {\n                       let variant_cx =\n                           sub_block(cx, ~\"enum-iter-variant-\" +\n-                                    uint::to_str(variant.disr_val));\n+                                    variant.disr_val.to_str());\n                       let variant_cx =\n                           iter_variant(variant_cx, repr, av, *variant,\n                                        substs.tps, |x,y,z| f(x,y,z));"}, {"sha": "96d12dbc3ac0e71f42330d5a77109b82a8e7a944", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -33,7 +33,6 @@ use std::ops;\n use std::ptr::to_unsafe_ptr;\n use std::to_bytes;\n use std::to_str::ToStr;\n-use std::u32;\n use std::vec;\n use syntax::ast::*;\n use syntax::ast_util::is_local;\n@@ -1944,7 +1943,7 @@ impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n \n impl ToStr for TypeContents {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"TypeContents(%s)\", u32::to_str_radix(self.bits, 2))\n+        fmt!(\"TypeContents(%s)\", self.bits.to_str_radix(2))\n     }\n }\n "}, {"sha": "e2d6d588baed0e02e05099e5a5bc9f7cb7be8b4f", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -17,7 +17,6 @@ use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::unify::{Redirect, Root, VarValue};\n use util::ppaux::{mt_to_str, ty_to_str, trait_ref_to_str};\n \n-use std::uint;\n use syntax::ast;\n \n pub trait InferStr {\n@@ -72,7 +71,7 @@ impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n         match *self {\n           Redirect(ref vid) => fmt!(\"Redirect(%s)\", vid.to_str()),\n           Root(ref pt, rk) => fmt!(\"Root(%s, %s)\", pt.inf_str(cx),\n-                               uint::to_str_radix(rk, 10u))\n+                               rk.to_str_radix(10u))\n         }\n     }\n }"}, {"sha": "c91a53f966388dd4590530949e48d0f4190a54ce", "filename": "src/libstd/container.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -38,6 +38,7 @@ pub trait Map<K, V>: Container {\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V>;\n \n     /// Return true if the map contains a value for the specified key\n+    #[inline]\n     fn contains_key(&self, key: &K) -> bool {\n         self.find(key).is_some()\n     }"}, {"sha": "21b7ee321e8db2a1aa63d7d7b56c74879b1dc445", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -27,8 +27,8 @@ use option::{Some, None};\n use rt::io::Writer;\n use str::OwnedStr;\n use to_bytes::IterBytes;\n-use uint;\n use vec::ImmutableVector;\n+use num::ToStrRadix;\n \n // Alias `SipState` to `State`.\n pub use State = hash::SipState;\n@@ -386,7 +386,7 @@ impl Streaming for SipState {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n         for b in r.iter() {\n-            s.push_str(uint::to_str_radix(*b as uint, 16u));\n+            s.push_str((*b as uint).to_str_radix(16u));\n         }\n         s\n     }\n@@ -407,8 +407,6 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n-    use uint;\n-\n     // Hash just the bytes of the slice, without length prefix\n     struct Bytes<'self>(&'self [u8]);\n     impl<'self> IterBytes for Bytes<'self> {\n@@ -496,7 +494,7 @@ mod tests {\n         fn to_hex_str(r: &[u8, ..8]) -> ~str {\n             let mut s = ~\"\";\n             for b in r.iter() {\n-                s.push_str(uint::to_str_radix(*b as uint, 16u));\n+                s.push_str((*b as uint).to_str_radix(16u));\n             }\n             s\n         }"}, {"sha": "36e62856464aab12e3137baa39dc68dc573c9db4", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -24,6 +24,7 @@ use ops::{Add, Mul, Sub};\n use cmp::Ord;\n use clone::Clone;\n use uint;\n+use util;\n \n /// Conversion from an `Iterator`\n pub trait FromIterator<A> {\n@@ -583,6 +584,26 @@ pub trait DoubleEndedIterator<A>: Iterator<A> {\n     }\n }\n \n+/// A double-ended iterator yielding mutable references\n+pub trait MutableDoubleEndedIterator {\n+    // FIXME: #5898: should be called `reverse`\n+    /// Use an iterator to reverse a container in-place\n+    fn reverse_(&mut self);\n+}\n+\n+impl<'self, A, T: DoubleEndedIterator<&'self mut A>> MutableDoubleEndedIterator for T {\n+    // FIXME: #5898: should be called `reverse`\n+    /// Use an iterator to reverse a container in-place\n+    fn reverse_(&mut self) {\n+        loop {\n+            match (self.next(), self.next_back()) {\n+                (Some(x), Some(y)) => util::swap(x, y),\n+                _ => break\n+            }\n+        }\n+    }\n+}\n+\n /// An object implementing random access indexing by `uint`\n ///\n /// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n@@ -1522,6 +1543,52 @@ impl<A: Sub<A, A> + Integer + Ord + Clone> DoubleEndedIterator<A> for Range<A> {\n     }\n }\n \n+/// A range of numbers from [0, N]\n+#[deriving(Clone, DeepClone)]\n+pub struct RangeInclusive<A> {\n+    priv range: Range<A>,\n+    priv done: bool\n+}\n+\n+/// Return an iterator over the range [start, stop]\n+#[inline]\n+pub fn range_inclusive<A: Add<A, A> + Ord + Clone + One>(start: A, stop: A) -> RangeInclusive<A> {\n+    RangeInclusive{range: range(start, stop), done: false}\n+}\n+\n+impl<A: Add<A, A> + Ord + Clone> Iterator<A> for RangeInclusive<A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        match self.range.next() {\n+            Some(x) => Some(x),\n+            None => {\n+                if self.done {\n+                    None\n+                } else {\n+                    self.done = true;\n+                    Some(self.range.stop.clone())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<A: Sub<A, A> + Integer + Ord + Clone> DoubleEndedIterator<A> for RangeInclusive<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        if self.range.stop > self.range.state {\n+            let result = self.range.stop.clone();\n+            self.range.stop = self.range.stop - self.range.one;\n+            Some(result)\n+        } else if self.done {\n+            None\n+        } else {\n+            self.done = true;\n+            Some(self.range.stop.clone())\n+        }\n+    }\n+}\n+\n impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -2286,4 +2353,17 @@ mod tests {\n             fail!(\"unreachable\");\n         }\n     }\n+\n+    #[test]\n+    fn test_range_inclusive() {\n+        assert_eq!(range_inclusive(0i, 5).collect::<~[int]>(), ~[0i, 1, 2, 3, 4, 5]);\n+        assert_eq!(range_inclusive(0i, 5).invert().collect::<~[int]>(), ~[5i, 4, 3, 2, 1, 0]);\n+    }\n+\n+    #[test]\n+    fn test_reverse() {\n+        let mut ys = [1, 2, 3, 4, 5];\n+        ys.mut_iter().reverse_();\n+        assert_eq!(ys, [5, 4, 3, 2, 1]);\n+    }\n }"}, {"sha": "a493dba467e46426f8ba191a0578818ed515bb6b", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -740,29 +740,6 @@ pub fn to_str_hex(num: f32) -> ~str {\n     r\n }\n \n-///\n-/// Converts a float to a string in a given radix\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * radix - The base to use\n-///\n-/// # Failure\n-///\n-/// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n-/// possible misinterpretation of the result at higher bases. If those values\n-/// are expected, use `to_str_radix_special()` instead.\n-///\n-#[inline]\n-pub fn to_str_radix(num: f32, rdx: uint) -> ~str {\n-    let (r, special) = strconv::float_to_str_common(\n-        num, rdx, true, strconv::SignNeg, strconv::DigAll);\n-    if special { fail!(\"number has a special value, \\\n-                      try to_str_radix_special() if those are expected\") }\n-    r\n-}\n-\n ///\n /// Converts a float to a string in a given radix, and a flag indicating\n /// whether it's a special value\n@@ -816,9 +793,25 @@ impl to_str::ToStr for f32 {\n }\n \n impl num::ToStrRadix for f32 {\n+    /// Converts a float to a string in a given radix\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * num - The float value\n+    /// * radix - The base to use\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+    /// possible misinterpretation of the result at higher bases. If those values\n+    /// are expected, use `to_str_radix_special()` instead.\n     #[inline]\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n-        to_str_radix(*self, rdx)\n+        let (r, special) = strconv::float_to_str_common(\n+            *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n+        if special { fail!(\"number has a special value, \\\n+                          try to_str_radix_special() if those are expected\") }\n+        r\n     }\n }\n "}, {"sha": "52e74d969eb71901e2405e4065539a87d354bb29", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -787,29 +787,6 @@ pub fn to_str_hex(num: f64) -> ~str {\n     r\n }\n \n-///\n-/// Converts a float to a string in a given radix\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * radix - The base to use\n-///\n-/// # Failure\n-///\n-/// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n-/// possible misinterpretation of the result at higher bases. If those values\n-/// are expected, use `to_str_radix_special()` instead.\n-///\n-#[inline]\n-pub fn to_str_radix(num: f64, rdx: uint) -> ~str {\n-    let (r, special) = strconv::float_to_str_common(\n-        num, rdx, true, strconv::SignNeg, strconv::DigAll);\n-    if special { fail!(\"number has a special value, \\\n-                      try to_str_radix_special() if those are expected\") }\n-    r\n-}\n-\n ///\n /// Converts a float to a string in a given radix, and a flag indicating\n /// whether it's a special value\n@@ -863,9 +840,25 @@ impl to_str::ToStr for f64 {\n }\n \n impl num::ToStrRadix for f64 {\n+    /// Converts a float to a string in a given radix\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * num - The float value\n+    /// * radix - The base to use\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+    /// possible misinterpretation of the result at higher bases. If those values\n+    /// are expected, use `to_str_radix_special()` instead.\n     #[inline]\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n-        to_str_radix(*self, rdx)\n+        let (r, special) = strconv::float_to_str_common(\n+            *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n+        if special { fail!(\"number has a special value, \\\n+                          try to_str_radix_special() if those are expected\") }\n+        r\n     }\n }\n "}, {"sha": "20c7adbd62c47887900510e5012a1b9a3547e830", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -111,29 +111,6 @@ pub fn to_str_hex(num: float) -> ~str {\n     r\n }\n \n-///\n-/// Converts a float to a string in a given radix\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * radix - The base to use\n-///\n-/// # Failure\n-///\n-/// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n-/// possible misinterpretation of the result at higher bases. If those values\n-/// are expected, use `to_str_radix_special()` instead.\n-///\n-#[inline]\n-pub fn to_str_radix(num: float, radix: uint) -> ~str {\n-    let (r, special) = strconv::float_to_str_common(\n-        num, radix, true, strconv::SignNeg, strconv::DigAll);\n-    if special { fail!(\"number has a special value, \\\n-                         try to_str_radix_special() if those are expected\") }\n-    r\n-}\n-\n ///\n /// Converts a float to a string in a given radix, and a flag indicating\n /// whether it's a special value\n@@ -187,9 +164,25 @@ impl to_str::ToStr for float {\n }\n \n impl num::ToStrRadix for float {\n+    /// Converts a float to a string in a given radix\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * num - The float value\n+    /// * radix - The base to use\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+    /// possible misinterpretation of the result at higher bases. If those values\n+    /// are expected, use `to_str_radix_special()` instead.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        to_str_radix(*self, radix)\n+        let (r, special) = strconv::float_to_str_common(\n+            *self, radix, true, strconv::SignNeg, strconv::DigAll);\n+        if special { fail!(\"number has a special value, \\\n+                             try to_str_radix_special() if those are expected\") }\n+        r\n     }\n }\n \n@@ -1342,8 +1335,8 @@ mod tests {\n \n     #[test]\n     pub fn test_to_str_radix() {\n-        assert_eq!(to_str_radix(36., 36u), ~\"10\");\n-        assert_eq!(to_str_radix(8.125, 2u), ~\"1000.001\");\n+        assert_eq!(36.0f.to_str_radix(36u), ~\"10\");\n+        assert_eq!(8.125f.to_str_radix(2u), ~\"1000.001\");\n     }\n \n     #[test]"}, {"sha": "4a7a5e32b32b2809cb2c7a4bc3ab4055dc7cfbbb", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -525,35 +525,25 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     f(buf.slice(0, cur))\n }\n \n-/// Convert to a string in base 10.\n-#[inline]\n-pub fn to_str(num: $T) -> ~str {\n-    to_str_radix(num, 10u)\n-}\n-\n-/// Convert to a string in a given base.\n-#[inline]\n-pub fn to_str_radix(num: $T, radix: uint) -> ~str {\n-    let mut buf: ~[u8] = ~[];\n-    do strconv::int_to_str_bytes_common(num, radix, strconv::SignNeg) |i| {\n-        buf.push(i);\n-    }\n-    // We know we generated valid utf-8, so we don't need to go through that\n-    // check.\n-    unsafe { str::raw::from_bytes_owned(buf) }\n-}\n-\n impl ToStr for $T {\n+    /// Convert to a string in base 10.\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        to_str(*self)\n+        self.to_str_radix(10)\n     }\n }\n \n impl ToStrRadix for $T {\n+    /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        to_str_radix(*self, radix)\n+        let mut buf: ~[u8] = ~[];\n+        do strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg) |i| {\n+            buf.push(i);\n+        }\n+        // We know we generated valid utf-8, so we don't need to go through that\n+        // check.\n+        unsafe { str::raw::from_bytes_owned(buf) }\n     }\n }\n \n@@ -813,39 +803,39 @@ mod tests {\n \n     #[test]\n     fn test_to_str() {\n-        assert_eq!(to_str_radix(0 as $T, 10u), ~\"0\");\n-        assert_eq!(to_str_radix(1 as $T, 10u), ~\"1\");\n-        assert_eq!(to_str_radix(-1 as $T, 10u), ~\"-1\");\n-        assert_eq!(to_str_radix(127 as $T, 16u), ~\"7f\");\n-        assert_eq!(to_str_radix(100 as $T, 10u), ~\"100\");\n+        assert_eq!((0 as $T).to_str_radix(10u), ~\"0\");\n+        assert_eq!((1 as $T).to_str_radix(10u), ~\"1\");\n+        assert_eq!((-1 as $T).to_str_radix(10u), ~\"-1\");\n+        assert_eq!((127 as $T).to_str_radix(16u), ~\"7f\");\n+        assert_eq!((100 as $T).to_str_radix(10u), ~\"100\");\n \n     }\n \n     #[test]\n     fn test_int_to_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8::to_str(i8_val), ~\"127\");\n+        assert_eq!(i8_val.to_str(), ~\"127\");\n \n         i8_val += 1 as i8;\n-        assert_eq!(i8::to_str(i8_val), ~\"-128\");\n+        assert_eq!(i8_val.to_str(), ~\"-128\");\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16::to_str(i16_val), ~\"32767\");\n+        assert_eq!(i16_val.to_str(), ~\"32767\");\n \n         i16_val += 1 as i16;\n-        assert_eq!(i16::to_str(i16_val), ~\"-32768\");\n+        assert_eq!(i16_val.to_str(), ~\"-32768\");\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32::to_str(i32_val), ~\"2147483647\");\n+        assert_eq!(i32_val.to_str(), ~\"2147483647\");\n \n         i32_val += 1 as i32;\n-        assert_eq!(i32::to_str(i32_val), ~\"-2147483648\");\n+        assert_eq!(i32_val.to_str(), ~\"-2147483648\");\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64::to_str(i64_val), ~\"9223372036854775807\");\n+        assert_eq!(i64_val.to_str(), ~\"9223372036854775807\");\n \n         i64_val += 1 as i64;\n-        assert_eq!(i64::to_str(i64_val), ~\"-9223372036854775808\");\n+        assert_eq!(i64_val.to_str(), ~\"-9223372036854775808\");\n     }\n \n     #[test]"}, {"sha": "6fba8a6dd137d2e6e8446c60a88c4fee525524ef", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -708,14 +708,14 @@ mod test {\n mod bench {\n     use extra::test::BenchHarness;\n     use rand::{XorShiftRng,RngUtil};\n-    use uint;\n     use float;\n+    use to_str::ToStr;\n \n     #[bench]\n     fn uint_to_str_rand(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();\n         do bh.iter {\n-            uint::to_str(rng.gen());\n+            rng.gen::<uint>().to_str();\n         }\n     }\n "}, {"sha": "2bf41f4103d808455528bb361d5c9d084a07dd3a", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -380,35 +380,25 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     f(buf.slice(0, cur))\n }\n \n-/// Convert to a string in base 10.\n-#[inline]\n-pub fn to_str(num: $T) -> ~str {\n-    to_str_radix(num, 10u)\n-}\n-\n-/// Convert to a string in a given base.\n-#[inline]\n-pub fn to_str_radix(num: $T, radix: uint) -> ~str {\n-    let mut buf = ~[];\n-    do strconv::int_to_str_bytes_common(num, radix, strconv::SignNone) |i| {\n-        buf.push(i);\n-    }\n-    // We know we generated valid utf-8, so we don't need to go through that\n-    // check.\n-    unsafe { str::raw::from_bytes_owned(buf) }\n-}\n-\n impl ToStr for $T {\n+    /// Convert to a string in base 10.\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        to_str(*self)\n+        self.to_str_radix(10u)\n     }\n }\n \n impl ToStrRadix for $T {\n+    /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        to_str_radix(*self, radix)\n+        let mut buf = ~[];\n+        do strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone) |i| {\n+            buf.push(i);\n+        }\n+        // We know we generated valid utf-8, so we don't need to go through that\n+        // check.\n+        unsafe { str::raw::from_bytes_owned(buf) }\n     }\n }\n \n@@ -451,7 +441,6 @@ mod tests {\n     use u32;\n     use u64;\n     use u8;\n-    use uint;\n \n     #[test]\n     fn test_num() {\n@@ -536,13 +525,13 @@ mod tests {\n \n     #[test]\n     pub fn test_to_str() {\n-        assert_eq!(to_str_radix(0 as $T, 10u), ~\"0\");\n-        assert_eq!(to_str_radix(1 as $T, 10u), ~\"1\");\n-        assert_eq!(to_str_radix(2 as $T, 10u), ~\"2\");\n-        assert_eq!(to_str_radix(11 as $T, 10u), ~\"11\");\n-        assert_eq!(to_str_radix(11 as $T, 16u), ~\"b\");\n-        assert_eq!(to_str_radix(255 as $T, 16u), ~\"ff\");\n-        assert_eq!(to_str_radix(0xff as $T, 10u), ~\"255\");\n+        assert_eq!((0 as $T).to_str_radix(10u), ~\"0\");\n+        assert_eq!((1 as $T).to_str_radix(10u), ~\"1\");\n+        assert_eq!((2 as $T).to_str_radix(10u), ~\"2\");\n+        assert_eq!((11 as $T).to_str_radix(10u), ~\"11\");\n+        assert_eq!((11 as $T).to_str_radix(16u), ~\"b\");\n+        assert_eq!((255 as $T).to_str_radix(16u), ~\"ff\");\n+        assert_eq!((0xff as $T).to_str_radix(10u), ~\"255\");\n     }\n \n     #[test]\n@@ -575,28 +564,28 @@ mod tests {\n     #[test]\n     fn test_uint_to_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert_eq!(u8::to_str(u8_val), ~\"255\");\n+        assert_eq!(u8_val.to_str(), ~\"255\");\n \n         u8_val += 1 as u8;\n-        assert_eq!(u8::to_str(u8_val), ~\"0\");\n+        assert_eq!(u8_val.to_str(), ~\"0\");\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(u16::to_str(u16_val), ~\"65535\");\n+        assert_eq!(u16_val.to_str(), ~\"65535\");\n \n         u16_val += 1 as u16;\n-        assert_eq!(u16::to_str(u16_val), ~\"0\");\n+        assert_eq!(u16_val.to_str(), ~\"0\");\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(u32::to_str(u32_val), ~\"4294967295\");\n+        assert_eq!(u32_val.to_str(), ~\"4294967295\");\n \n         u32_val += 1 as u32;\n-        assert_eq!(u32::to_str(u32_val), ~\"0\");\n+        assert_eq!(u32_val.to_str(), ~\"0\");\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(u64::to_str(u64_val), ~\"18446744073709551615\");\n+        assert_eq!(u64_val.to_str(), ~\"18446744073709551615\");\n \n         u64_val += 1 as u64;\n-        assert_eq!(u64::to_str(u64_val), ~\"0\");\n+        assert_eq!(u64_val.to_str(), ~\"0\");\n     }\n \n     #[test]\n@@ -638,14 +627,14 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     pub fn to_str_radix1() {\n-        uint::to_str_radix(100u, 1u);\n+        100u.to_str_radix(1u);\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     pub fn to_str_radix37() {\n-        uint::to_str_radix(100u, 37u);\n+        100u.to_str_radix(37u);\n     }\n \n     #[test]"}, {"sha": "7faa98c243347414e1895902620053dee41a3c6d", "filename": "src/libstd/option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -388,6 +388,7 @@ impl<T> Zero for Option<T> {\n }\n \n /// An iterator that yields either one or zero elements\n+#[deriving(Clone, DeepClone)]\n pub struct OptionIterator<A> {\n     priv opt: Option<A>\n }"}, {"sha": "e91c78e8223d1cb330de076ef6c83a8013e19dbd", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -50,15 +50,15 @@ pub use char::Char;\n pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use hash::Hash;\n pub use iter::Times;\n-pub use iterator::Extendable;\n-pub use iterator::{Iterator, DoubleEndedIterator};\n-pub use iterator::{ClonableIterator, OrdIterator};\n+pub use iterator::{FromIterator, Extendable};\n+pub use iterator::{Iterator, DoubleEndedIterator, RandomAccessIterator, ClonableIterator};\n+pub use iterator::{OrdIterator, MutableDoubleEndedIterator};\n pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n pub use num::{Integer, Fractional, Real, RealExt};\n pub use num::{Bitwise, BitCount, Bounded};\n-pub use num::{Primitive, Int, Float};\n+pub use num::{Primitive, Int, Float, ToStrRadix};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}, {"sha": "83c12f0af5e1b92d7fbff75dc37107404ff585aa", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -480,7 +480,6 @@ pub mod rt {\n     use str;\n     use sys;\n     use num;\n-    use uint;\n     use vec;\n     use option::{Some, None, Option};\n \n@@ -593,7 +592,7 @@ pub mod rt {\n         return if prec == 0u && num == 0u {\n                 ~\"\"\n             } else {\n-                let s = uint::to_str_radix(num, radix);\n+                let s = num.to_str_radix(radix);\n                 let len = s.char_len();\n                 if len < prec {\n                     let diff = prec - len;"}, {"sha": "0427eec2b058b57cd8ef24e0c51980e2398d5b13", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -1161,6 +1161,7 @@ pub trait OwnedVector<T> {\n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n     fn capacity(&self) -> uint;\n+    fn shrink_to_fit(&mut self);\n \n     fn push(&mut self, t: T);\n     unsafe fn push_fast(&mut self, t: T);\n@@ -1254,6 +1255,7 @@ impl<T> OwnedVector<T> for ~[T] {\n      *\n      * * n - The number of elements to reserve space for\n      */\n+    #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n         self.reserve(uint::next_power_of_two(n));\n     }\n@@ -1272,6 +1274,17 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n+    /// Shrink the capacity of the vector to match the length\n+    fn shrink_to_fit(&mut self) {\n+        unsafe {\n+            let ptr: *mut *mut Vec<()> = cast::transmute(self);\n+            let alloc = (**ptr).fill;\n+            let size = alloc + sys::size_of::<Vec<()>>();\n+            *ptr = realloc_raw(*ptr as *mut c_void, size) as *mut Vec<()>;\n+            (**ptr).alloc = alloc;\n+        }\n+    }\n+\n     /// Append an element to a vector\n     #[inline]\n     fn push(&mut self, t: T) {\n@@ -2327,6 +2340,7 @@ mod tests {\n     use sys;\n     use vec::*;\n     use cmp::*;\n+    use prelude::*;\n \n     fn square(n: uint) -> uint { n * n }\n \n@@ -3600,6 +3614,18 @@ mod tests {\n         }\n         assert!(cnt == 3);\n     }\n+\n+    #[test]\n+    fn test_shrink_to_fit() {\n+        let mut xs = ~[0, 1, 2, 3];\n+        for i in range(4, 100) {\n+            xs.push(i)\n+        }\n+        assert_eq!(xs.capacity(), 128);\n+        xs.shrink_to_fit();\n+        assert_eq!(xs.capacity(), 100);\n+        assert_eq!(xs, range(0, 100).to_owned_vec());\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "3bad1ed93842d5d41b997805fa5ce92114fef8a8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -28,7 +28,6 @@ use print::pp;\n use print::pprust;\n \n use std::io;\n-use std::u64;\n \n // The @ps is stored here to prevent recursive type.\n pub enum ann_node<'self> {\n@@ -2035,24 +2034,24 @@ pub fn print_literal(s: @ps, lit: &ast::lit) {\n       ast::lit_int(i, t) => {\n         if i < 0_i64 {\n             word(s.s,\n-                 ~\"-\" + u64::to_str_radix(-i as u64, 10u)\n+                 ~\"-\" + (-i as u64).to_str_radix(10u)\n                  + ast_util::int_ty_to_str(t));\n         } else {\n             word(s.s,\n-                 u64::to_str_radix(i as u64, 10u)\n+                 (i as u64).to_str_radix(10u)\n                  + ast_util::int_ty_to_str(t));\n         }\n       }\n       ast::lit_uint(u, t) => {\n         word(s.s,\n-             u64::to_str_radix(u, 10u)\n+             u.to_str_radix(10u)\n              + ast_util::uint_ty_to_str(t));\n       }\n       ast::lit_int_unsuffixed(i) => {\n         if i < 0_i64 {\n-            word(s.s, ~\"-\" + u64::to_str_radix(-i as u64, 10u));\n+            word(s.s, ~\"-\" + (-i as u64).to_str_radix(10u));\n         } else {\n-            word(s.s, u64::to_str_radix(i as u64, 10u));\n+            word(s.s, (i as u64).to_str_radix(10u));\n         }\n       }\n       ast::lit_float(f, t) => {"}, {"sha": "22622c1cac33afa2ae24ab7f657fc9b74c69a9ed", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -89,13 +89,11 @@ impl Results {\n             let mut set = f();\n             do timed(&mut self.sequential_strings) {\n                 for i in range(0u, num_keys) {\n-                    let s = uint::to_str(i);\n-                    set.insert(s);\n+                    set.insert(i.to_str());\n                 }\n \n                 for i in range(0u, num_keys) {\n-                    let s = uint::to_str(i);\n-                    assert!(set.contains(&s));\n+                    assert!(set.contains(&i.to_str()));\n                 }\n             }\n         }\n@@ -104,7 +102,7 @@ impl Results {\n             let mut set = f();\n             do timed(&mut self.random_strings) {\n                 for _ in range(0, num_keys) {\n-                    let s = uint::to_str(rng.next() as uint);\n+                    let s = (rng.next() as uint).to_str();\n                     set.insert(s);\n                 }\n             }\n@@ -113,11 +111,11 @@ impl Results {\n         {\n             let mut set = f();\n             for i in range(0u, num_keys) {\n-                set.insert(uint::to_str(i));\n+                set.insert(i.to_str());\n             }\n             do timed(&mut self.delete_strings) {\n                 for i in range(0u, num_keys) {\n-                    assert!(set.remove(&uint::to_str(i)));\n+                    assert!(set.remove(&i.to_str()));\n                 }\n             }\n         }"}, {"sha": "4869c486e5ea9c6b13d0f8b6ae9e145b224cdc8f", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     let n = uint::from_str(args[1]).unwrap();\n \n     for i in range(0u, n) {\n-        let x = uint::to_str(i);\n+        let x = i.to_str();\n         info!(x);\n     }\n }"}, {"sha": "6565fc36dd289f9e380633c862e16a151ad3bbca", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -25,7 +25,7 @@ fn random_gradient<R:Rng>(r: &mut R) -> Vec2 {\n \n fn gradient(orig: Vec2, grad: Vec2, p: Vec2) -> f32 {\n     let sp = Vec2 {x: p.x - orig.x, y: p.y - orig.y};\n-    grad.x * sp.x + grad.y + sp.y\n+    grad.x * sp.x + grad.y * sp.y\n }\n \n struct Noise2DContext {"}, {"sha": "b2491e305b254a6c3bf1d93a69228759ec9355f0", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -125,7 +125,7 @@ fn main() {\n                 let elapsed = stop - start;\n \n                 out.write_line(fmt!(\"%d\\t%d\\t%s\", n, fibn,\n-                                    u64::to_str(elapsed)));\n+                                    elapsed.to_str()));\n             }\n         }\n     }"}, {"sha": "7dc859e559efa53a9e2868bdb141d3f7caf63669", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -40,7 +40,7 @@ impl<A> option_monad<A> for Option<A> {\n }\n \n fn transform(x: Option<int>) -> Option<~str> {\n-    x.bind(|n| Some(*n + 1) ).bind(|n| Some(int::to_str(*n)) )\n+    x.bind(|n| Some(*n + 1) ).bind(|n| Some(n.to_str()) )\n }\n \n pub fn main() {"}, {"sha": "72bdc2ee0a63e2873ee976b879b4d44d75fc6444", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -529,7 +529,7 @@ impl TyVisitor for my_visitor {\n     }\n     fn visit_int(&self) -> bool {\n         do self.get::<int>() |i| {\n-            self.vals.push(int::to_str(i));\n+            self.vals.push(i.to_str());\n         };\n         true\n     }"}, {"sha": "520b3583195ae75b6548e3b7f96634be6186380c", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -32,7 +32,7 @@ trait uint_utils {\n }\n \n impl uint_utils for uint {\n-    fn str(&self) -> ~str { uint::to_str(*self) }\n+    fn str(&self) -> ~str { self.to_str() }\n     fn multi(&self, f: &fn(uint)) {\n         let mut c = 0u;\n         while c < *self { f(c); c += 1u; }"}, {"sha": "6916db28e11ea611b08b7b99aef3ed7589ce3ab8", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -13,16 +13,16 @@\n use std::int;\n \n trait to_str {\n-    fn to_str(&self) -> ~str;\n+    fn to_string(&self) -> ~str;\n }\n impl to_str for int {\n-    fn to_str(&self) -> ~str { int::to_str(*self) }\n+    fn to_string(&self) -> ~str { self.to_str() }\n }\n impl to_str for ~str {\n-    fn to_str(&self) -> ~str { self.clone() }\n+    fn to_string(&self) -> ~str { self.clone() }\n }\n impl to_str for () {\n-    fn to_str(&self) -> ~str { ~\"()\" }\n+    fn to_string(&self) -> ~str { ~\"()\" }\n }\n \n trait map<T> {\n@@ -43,7 +43,7 @@ fn foo<U, T: map<U>>(x: T) -> ~[~str] {\n     x.map(|_e| ~\"hi\" )\n }\n fn bar<U:to_str,T:map<U>>(x: T) -> ~[~str] {\n-    x.map(|_e| _e.to_str() )\n+    x.map(|_e| _e.to_string() )\n }\n \n pub fn main() {"}, {"sha": "8ecad8d4fe163e05a7db9ab15d90f59f259b17af", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d856b129b7af6e78f1a04d6e942997559d06f8/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=d4d856b129b7af6e78f1a04d6e942997559d06f8", "patch": "@@ -10,35 +10,26 @@\n \n // xfail-fast\n \n-#[no_std];\n-\n-extern mod std;\n-\n-use std::str::StrVector;\n-use std::vec::ImmutableVector;\n-use std::iterator::Iterator;\n-use std::int;\n-\n trait to_str {\n-    fn to_str(&self) -> ~str;\n+    fn to_string(&self) -> ~str;\n }\n \n impl to_str for int {\n-    fn to_str(&self) -> ~str { int::to_str(*self) }\n+    fn to_string(&self) -> ~str { self.to_str() }\n }\n \n impl<T:to_str> to_str for ~[T] {\n-    fn to_str(&self) -> ~str {\n-        fmt!(\"[%s]\", self.iter().map(|e| e.to_str()).collect::<~[~str]>().connect(\", \"))\n+    fn to_string(&self) -> ~str {\n+        fmt!(\"[%s]\", self.iter().map(|e| e.to_string()).collect::<~[~str]>().connect(\", \"))\n     }\n }\n \n pub fn main() {\n-    assert!(1.to_str() == ~\"1\");\n-    assert!((~[2, 3, 4]).to_str() == ~\"[2, 3, 4]\");\n+    assert!(1.to_string() == ~\"1\");\n+    assert!((~[2, 3, 4]).to_string() == ~\"[2, 3, 4]\");\n \n     fn indirect<T:to_str>(x: T) -> ~str {\n-        x.to_str() + \"!\"\n+        x.to_string() + \"!\"\n     }\n     assert!(indirect(~[10, 20]) == ~\"[10, 20]!\");\n "}]}