{"sha": "bfa854dbe539808efbde25751fdfac8a3e01accf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYTg1NGRiZTUzOTgwOGVmYmRlMjU3NTFmZGZhYzhhM2UwMWFjY2Y=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-29T02:14:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-29T02:14:15Z"}, "message": "Rollup merge of #79363 - ssomers:btree_cleanup_comments, r=Mark-Simulacrum\n\nBTreeMap: try to enhance various comments\n\nAll in internal documentation, propagating the \"key-value pair\" notation from public documentation.\n\nr? ``@Mark-Simulacrum``", "tree": {"sha": "66dbb3d16673abf0adf52509c8abaac5f93498d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66dbb3d16673abf0adf52509c8abaac5f93498d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfa854dbe539808efbde25751fdfac8a3e01accf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfwwP4CRBK7hj4Ov3rIwAAdHIIAKRmlO2dMJRM1MIEkQhUcOZZ\npdvb0M/BZnIH8EP6WM13yprF79yvwPU+vLe5rh3DwSMaupPtiIkyw8ca4UIOHMek\ne/QE1WPmAgmJoevWHIxIF+irB1TZ9ijFSiKxBecxSJK8O7FaW89f0slFp+Uiz6M+\nHqmzRskYHKmZUkZ8Pv9Bj+mtHl0kdf7/CduHBhcVbG/U0w78XFoDPs/ldcV82nRW\n0Ut21Bk63FlBF0wVs9kmz4tDeTfGb7dYrlhsW7dEx7GRTdGtPhXZcie5u5nnO3um\nzKGmwqRM3zf6bbgijs61P/cUqGtygAoMsK0LiSXuanLep0cuBG3aPr2Kpz300ag=\n=2aGk\n-----END PGP SIGNATURE-----\n", "payload": "tree 66dbb3d16673abf0adf52509c8abaac5f93498d7\nparent 858b44a4338b403cdc9bf5669af768738e0d85f3\nparent d1a2c0f99c079479009b879fd904859438b72f1e\nauthor Dylan DPC <dylan.dpc@gmail.com> 1606616055 +0100\ncommitter GitHub <noreply@github.com> 1606616055 +0100\n\nRollup merge of #79363 - ssomers:btree_cleanup_comments, r=Mark-Simulacrum\n\nBTreeMap: try to enhance various comments\n\nAll in internal documentation, propagating the \"key-value pair\" notation from public documentation.\n\nr? ``@Mark-Simulacrum``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa854dbe539808efbde25751fdfac8a3e01accf", "html_url": "https://github.com/rust-lang/rust/commit/bfa854dbe539808efbde25751fdfac8a3e01accf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfa854dbe539808efbde25751fdfac8a3e01accf/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "858b44a4338b403cdc9bf5669af768738e0d85f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/858b44a4338b403cdc9bf5669af768738e0d85f3", "html_url": "https://github.com/rust-lang/rust/commit/858b44a4338b403cdc9bf5669af768738e0d85f3"}, {"sha": "d1a2c0f99c079479009b879fd904859438b72f1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1a2c0f99c079479009b879fd904859438b72f1e", "html_url": "https://github.com/rust-lang/rust/commit/d1a2c0f99c079479009b879fd904859438b72f1e"}], "stats": {"total": 207, "additions": 118, "deletions": 89}, "files": [{"sha": "c92888cb8973ce3c6187924c700e6d94c08b06ef", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=bfa854dbe539808efbde25751fdfac8a3e01accf", "patch": "@@ -459,7 +459,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         self.remove_kv().1\n     }\n \n-    // Body of `remove_entry`, separate to keep the above implementations short.\n+    // Body of `remove_entry`, probably separate because the name reflects the returned pair.\n     pub(super) fn remove_kv(self) -> (K, V) {\n         let mut emptied_internal_root = false;\n         let (old_kv, _) = self.handle.remove_kv_tracking(|| emptied_internal_root = true);"}, {"sha": "cce8b21a2bc416454d61d0a44d1b92018831f279", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=bfa854dbe539808efbde25751fdfac8a3e01accf", "patch": "@@ -9,6 +9,9 @@ use super::search::{self, SearchResult};\n use super::unwrap_unchecked;\n \n /// Finds the leaf edges delimiting a specified range in or underneath a node.\n+///\n+/// The result is meaningful only if the tree is ordered by key, like the tree\n+/// in a `BTreeMap` is.\n fn range_search<BorrowType, K, V, Q, R>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n@@ -122,6 +125,9 @@ fn full_range<BorrowType, K, V>(\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n     /// Creates a pair of leaf edges delimiting a specified range in or underneath a node.\n+    ///\n+    /// The result is meaningful only if the tree is ordered by key, like the tree\n+    /// in a `BTreeMap` is.\n     pub fn range_search<Q, R>(\n         self,\n         range: R,\n@@ -152,6 +158,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::ValMut<'a>, K, V, marker::LeafOrInternal>\n     /// Splits a unique reference into a pair of leaf edges delimiting a specified range.\n     /// The result are non-unique references allowing (some) mutation, which must be used\n     /// carefully.\n+    ///\n+    /// The result is meaningful only if the tree is ordered by key, like the tree\n+    /// in a `BTreeMap` is.\n     pub fn range_search<Q, R>(\n         self,\n         range: R,"}, {"sha": "78be070a9838218281329009371912c9588a9dd2", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 91, "deletions": 77, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=bfa854dbe539808efbde25751fdfac8a3e01accf", "patch": "@@ -27,6 +27,9 @@\n //   given node has exactly the same length.\n // - A node of length `n` has `n` keys, `n` values, and `n + 1` edges.\n //   This implies that even an empty node has at least one edge.\n+//   For a leaf node, \"having an edge\" only means we can identify a position in the node,\n+//   since leaf edges are empty and need no data representation. In an internal node,\n+//   an edge both identifies a position and contains a pointer to a child node.\n \n use core::cmp::Ordering;\n use core::marker::PhantomData;\n@@ -215,6 +218,8 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n ///      although insert methods allow a mutable pointer to a value to coexist.\n ///    - When this is `Owned`, the `NodeRef` acts roughly like `Box<Node>`,\n ///      but does not have a destructor, and must be cleaned up manually.\n+///   Since any `NodeRef` allows navigating through the tree, `BorrowType`\n+///   effectively applies to the entire tree, not just the node itself.\n /// - `K` and `V`: These are the types of keys and values stored in the nodes.\n /// - `Type`: This can be `Leaf`, `Internal`, or `LeafOrInternal`. When this is\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n@@ -227,9 +232,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n /// such restrictions:\n /// - For each type parameter, we can only define a method either generically\n ///   or for one particular type. For example, we cannot define a method like\n-///   `key_at` generically for all `BorrowType`, because we want to return\n+///   `key_at` generically for all `BorrowType`, because we want it to return\n ///   `&'a K` for most choices of `BorrowType`, but plain `K` for `Owned`.\n-///   We cannot define `key_at` once for all types that have a lifetime.\n+///   We cannot define `key_at` once for all types that carry a lifetime.\n ///   Therefore, we define it only for the least powerful type `Immut<'a>`.\n /// - We cannot get implicit coercion from say `Mut<'a>` to `Immut<'a>`.\n ///   Therefore, we have to explicitly call `reborrow` on a more powerfull\n@@ -240,16 +245,17 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n ///   That is irrelevant when `BorrowType` is `Immut<'a>`, but the rule does\n ///   no harm because we make those `NodeRef` implicitly `Copy`.\n ///   The rule also avoids implicitly returning the lifetime of `&self`,\n-///   instead of the lifetime contained in `BorrowType`.\n+///   instead of the lifetime carried by `BorrowType`.\n ///   An exception to this rule are the insert functions.\n /// - Given the above, we need a `reborrow_mut` to explicitly copy a `Mut<'a>`\n ///   `NodeRef` whenever we want to invoke a method returning an extra reference\n ///   somewhere in the tree.\n pub struct NodeRef<BorrowType, K, V, Type> {\n-    /// The number of levels below the node, a property of the node that cannot be\n-    /// entirely described by `Type` and that the node does not store itself either.\n-    /// Unconstrained if `Type` is `LeafOrInternal`, must be zero if `Type` is `Leaf`,\n-    /// and must be non-zero if `Type` is `Internal`.\n+    /// The number of levels that the node and the level of leaves are apart, a\n+    /// constant of the node that cannot be entirely described by `Type`, and that\n+    /// the node itself does not store. We only need to store the height of the root\n+    /// node, and derive every other node's height from it.\n+    /// Must be zero if `Type` is `Leaf` and non-zero if `Type` is `Internal`.\n     height: usize,\n     /// The pointer to the leaf or internal node. The definition of `InternalNode`\n     /// ensures that the pointer is valid either way.\n@@ -317,8 +323,11 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         unsafe { usize::from((*Self::as_leaf_ptr(self)).len) }\n     }\n \n-    /// Returns the height of this node with respect to the leaf level. Zero height means the\n-    /// node is a leaf itself.\n+    /// Returns the number of levels that the node and leaves are apart. Zero\n+    /// height means the node is a leaf itself. If you picture trees with the\n+    /// root on top, the number says at which elevation the node appears.\n+    /// If you picture trees with leaves on top, the number says how high\n+    /// the tree extends above the node.\n     pub fn height(&self) -> usize {\n         self.height\n     }\n@@ -376,6 +385,8 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// that points to the current node. Returns `Err(self)` if the current node has\n     /// no parent, giving back the original `NodeRef`.\n     ///\n+    /// The method name assumes you picture trees with the root node on top.\n+    ///\n     /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n     /// both, upon success, do nothing.\n     pub fn ascend(\n@@ -576,7 +587,6 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n impl<'a, K, V, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n     /// # Safety\n     /// - The node has more than `idx` initialized elements.\n-    /// - The keys and values of the node must be initialized up to its current length.\n     unsafe fn into_key_val_mut_at(mut self, idx: usize) -> (&'a K, &'a mut V) {\n         // We only create a reference to the one element we are interested in,\n         // to avoid aliasing with outstanding references to other elements,\n@@ -609,7 +619,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         unsafe { (*leaf).parent_idx.write(parent_idx as u16) };\n     }\n \n-    /// Clear the node's link to its parent edge, freeing it from its tree.\n+    /// Clear the node's link to its parent edge.\n     /// This only makes sense when there are no other references to the node.\n     fn clear_parent_link(&mut self) {\n         let leaf = Self::as_leaf_mut(self);\n@@ -618,7 +628,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n-    /// Adds a key/value pair to the end of the node.\n+    /// Adds a key-value pair to the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         let len = unsafe { self.reborrow_mut().into_len_mut() };\n         let idx = usize::from(*len);\n@@ -630,7 +640,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         }\n     }\n \n-    /// Adds a key/value pair to the beginning of the node.\n+    /// Adds a key-value pair to the beginning of the node.\n     fn push_front(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n \n@@ -659,7 +669,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Adds a key/value pair, and an edge to go to the right of that pair,\n+    /// Adds a key-value pair, and an edge to go to the right of that pair,\n     /// to the end of the node.\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n@@ -676,7 +686,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         }\n     }\n \n-    /// Adds a key/value pair, and an edge to go to the left of that pair,\n+    /// Adds a key-value pair, and an edge to go to the left of that pair,\n     /// to the beginning of the node.\n     fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n@@ -694,7 +704,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n-    /// Removes a key/value pair from the end of the node and returns the pair.\n+    /// Removes a key-value pair from the end of the node and returns the pair.\n     /// Also removes the edge that was to the right of that pair and, if the node\n     /// is internal, returns the orphaned subtree that this edge owned.\n     fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n@@ -722,7 +732,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// Removes a key/value pair from the beginning of the node and returns the pair.\n+    /// Removes a key-value pair from the beginning of the node and returns the pair.\n     /// Also removes the edge that was to the left of that pair and, if the node is\n     /// internal, returns the orphaned subtree that this edge owned.\n     fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n@@ -786,12 +796,12 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     }\n }\n \n-/// A reference to a specific key/value pair or edge within a node. The `Node` parameter\n-/// must be a `NodeRef`, while the `Type` can either be `KV` (signifying a handle on a key/value\n+/// A reference to a specific key-value pair or edge within a node. The `Node` parameter\n+/// must be a `NodeRef`, while the `Type` can either be `KV` (signifying a handle on a key-value\n /// pair) or `Edge` (signifying a handle on an edge).\n ///\n /// Note that even `Leaf` nodes can have `Edge` handles. Instead of representing a pointer to\n-/// a child node, these represent the spaces where child pointers would go between the key/value\n+/// a child node, these represent the spaces where child pointers would go between the key-value\n /// pairs. For example, in a node with length 2, there would be 3 possible edge locations - one\n /// to the left of the node, one between the two pairs, and one at the right of the node.\n pub struct Handle<Node, Type> {\n@@ -810,7 +820,7 @@ impl<Node: Copy, Type> Clone for Handle<Node, Type> {\n }\n \n impl<Node, Type> Handle<Node, Type> {\n-    /// Retrieves the node that contains the edge or key/value pair this handle points to.\n+    /// Retrieves the node that contains the edge or key-value pair this handle points to.\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n@@ -822,7 +832,7 @@ impl<Node, Type> Handle<Node, Type> {\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n-    /// Creates a new handle to a key/value pair in `node`.\n+    /// Creates a new handle to a key-value pair in `node`.\n     /// Unsafe because the caller must ensure that `idx < node.len()`.\n     pub unsafe fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         debug_assert!(idx < node.len());\n@@ -842,7 +852,7 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n impl<BorrowType, K, V, NodeType> NodeRef<BorrowType, K, V, NodeType> {\n     /// Could be a public implementation of PartialEq, but only used in this module.\n     fn eq(&self, other: &Self) -> bool {\n-        let Self { node, height, _marker: _ } = self;\n+        let Self { node, height, _marker } = self;\n         if node.eq(&other.node) {\n             debug_assert_eq!(*height, other.height);\n             true\n@@ -856,7 +866,7 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n     for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {\n     fn eq(&self, other: &Self) -> bool {\n-        let Self { node, idx, _marker: _ } = self;\n+        let Self { node, idx, _marker } = self;\n         node.eq(&other.node) && *idx == other.idx\n     }\n }\n@@ -865,7 +875,7 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialOrd\n     for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        let Self { node, idx, _marker: _ } = self;\n+        let Self { node, idx, _marker } = self;\n         if node.eq(&other.node) { Some(idx.cmp(&other.idx)) } else { None }\n     }\n }\n@@ -950,7 +960,7 @@ fn splitpoint(edge_idx: usize) -> (usize, LeftOrRight<usize>) {\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n-    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// Inserts a new key-value pair between the key-value pairs to the right and left of\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n     ///\n@@ -969,7 +979,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n-    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// Inserts a new key-value pair between the key-value pairs to the right and left of\n     /// this edge. This method splits the node if there isn't enough room.\n     ///\n     /// The returned pointer points to the inserted value.\n@@ -997,8 +1007,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n-    /// Fixes the parent pointer and index in the child node below this edge. This is useful\n-    /// when the ordering of edges has been changed, such as in the various `insert` methods.\n+    /// Fixes the parent pointer and index in the child node that this edge\n+    /// links to. This is useful when the ordering of edges has been changed,\n     fn correct_parent_link(self) {\n         // Create backpointer without invalidating other references to the node.\n         let ptr = unsafe { NonNull::new_unchecked(NodeRef::as_internal_ptr(&self.node)) };\n@@ -1009,8 +1019,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n-    /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n-    /// between this edge and the key/value pair to the right of this edge. This method assumes\n+    /// Inserts a new key-value pair and an edge that will go to the right of that new pair\n+    /// between this edge and the key-value pair to the right of this edge. This method assumes\n     /// that there is enough space in the node for the new pair to fit.\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n         debug_assert!(self.node.len() < CAPACITY);\n@@ -1026,8 +1036,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         }\n     }\n \n-    /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n-    /// between this edge and the key/value pair to the right of this edge. This method splits\n+    /// Inserts a new key-value pair and an edge that will go to the right of that new pair\n+    /// between this edge and the key-value pair to the right of this edge. This method splits\n     /// the node if there isn't enough room.\n     fn insert(\n         mut self,\n@@ -1060,7 +1070,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n-    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// Inserts a new key-value pair between the key-value pairs to the right and left of\n     /// this edge. This method splits the node if there isn't enough room, and tries to\n     /// insert the split off portion into the parent node recursively, until the root is reached.\n     ///\n@@ -1098,6 +1108,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n     /// Finds the node pointed to by this edge.\n     ///\n+    /// The method name assumes you picture trees with the root node on top.\n+    ///\n     /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n     /// both, upon success, do nothing.\n     pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n@@ -1186,10 +1198,10 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n     /// Splits the underlying node into three parts:\n     ///\n-    /// - The node is truncated to only contain the key/value pairs to the left of\n+    /// - The node is truncated to only contain the key-value pairs to the left of\n     ///   this handle.\n     /// - The key and value pointed to by this handle are extracted.\n-    /// - All the key/value pairs to the right of this handle are put into a newly\n+    /// - All the key-value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n     pub fn split(mut self) -> SplitResult<'a, K, V, marker::Leaf> {\n         unsafe {\n@@ -1202,8 +1214,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         }\n     }\n \n-    /// Removes the key/value pair pointed to by this handle and returns it, along with the edge\n-    /// that the key/value pair collapsed into.\n+    /// Removes the key-value pair pointed to by this handle and returns it, along with the edge\n+    /// that the key-value pair collapsed into.\n     pub fn remove(\n         mut self,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n@@ -1219,10 +1231,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n     /// Splits the underlying node into three parts:\n     ///\n-    /// - The node is truncated to only contain the edges and key/value pairs to the\n+    /// - The node is truncated to only contain the edges and key-value pairs to the\n     ///   left of this handle.\n     /// - The key and value pointed to by this handle are extracted.\n-    /// - All the edges and key/value pairs to the right of this handle are put into\n+    /// - All the edges and key-value pairs to the right of this handle are put into\n     ///   a newly allocated node.\n     pub fn split(mut self) -> SplitResult<'a, K, V, marker::Internal> {\n         unsafe {\n@@ -1247,7 +1259,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n }\n \n /// Represents a session for evaluating and performing a balancing operation\n-/// around an internal key/value pair.\n+/// around an internal key-value pair.\n pub struct BalancingContext<'a, K, V> {\n     parent: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV>,\n     left_child: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n@@ -1320,14 +1332,14 @@ impl<'a, K, V> BalancingContext<'a, K, V> {\n \n     /// Returns `true` if it is valid to call `.merge()` in the balancing context,\n     /// i.e., whether there is enough room in a node to hold the combination of\n-    /// both adjacent child nodes, along with the key/value pair in the parent.\n+    /// both adjacent child nodes, along with the key-value pair in the parent.\n     pub fn can_merge(&self) -> bool {\n         self.left_child.len() + 1 + self.right_child.len() <= CAPACITY\n     }\n }\n \n impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n-    /// Merges the parent's key/value pair and both adjacent child nodes into\n+    /// Merges the parent's key-value pair and both adjacent child nodes into\n     /// the left node and returns an edge handle in that expanded left node.\n     /// If `track_edge_idx` is given some value, the returned edge corresponds\n     /// to where the edge in that child node ended up,\n@@ -1409,8 +1421,8 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n         }\n     }\n \n-    /// Removes a key/value pair from the left child and places it in the key/value storage\n-    /// of the parent, while pushing the old parent key/value pair into the right child.\n+    /// Removes a key-value pair from the left child and places it in the key-value storage\n+    /// of the parent, while pushing the old parent key-value pair into the right child.\n     /// Returns a handle to the edge in the right child corresponding to where the original\n     /// edge specified by `track_right_edge_idx` ended up.\n     pub fn steal_left(\n@@ -1432,8 +1444,8 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n         }\n     }\n \n-    /// Removes a key/value pair from the right child and places it in the key/value storage\n-    /// of the parent, while pushing the old parent key/value pair onto the left child.\n+    /// Removes a key-value pair from the right child and places it in the key-value storage\n+    /// of the parent, while pushing the old parent key-value pair onto the left child.\n     /// Returns a handle to the edge in the left child specified by `track_left_edge_idx`,\n     /// which didn't move.\n     pub fn steal_right(\n@@ -1459,17 +1471,17 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n     pub fn bulk_steal_left(&mut self, count: usize) {\n         unsafe {\n             let left_node = &mut self.left_child;\n-            let left_len = left_node.len();\n+            let old_left_len = left_node.len();\n             let right_node = &mut self.right_child;\n-            let right_len = right_node.len();\n+            let old_right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n-            assert!(right_len + count <= CAPACITY);\n-            assert!(left_len >= count);\n+            assert!(old_right_len + count <= CAPACITY);\n+            assert!(old_left_len >= count);\n \n-            let new_left_len = left_len - count;\n+            let new_left_len = old_left_len - count;\n \n-            // Move data.\n+            // Move leaf data.\n             {\n                 let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n                 let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n@@ -1479,13 +1491,13 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 };\n \n                 // Make room for stolen elements in the right child.\n-                ptr::copy(right_kv.0, right_kv.0.add(count), right_len);\n-                ptr::copy(right_kv.1, right_kv.1.add(count), right_len);\n+                ptr::copy(right_kv.0, right_kv.0.add(count), old_right_len);\n+                ptr::copy(right_kv.1, right_kv.1.add(count), old_right_len);\n \n                 // Move elements from the left child to the right one.\n                 move_kv(left_kv, new_left_len + 1, right_kv, 0, count - 1);\n \n-                // Move parent's key/value pair to the right child.\n+                // Move parent's key-value pair to the right child.\n                 move_kv(parent_kv, 0, right_kv, count - 1, 1);\n \n                 // Move the left-most stolen pair to the parent.\n@@ -1500,9 +1512,10 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                     // Make room for stolen edges.\n                     let left = left.reborrow();\n                     let right_edges = right.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n-                    ptr::copy(right_edges, right_edges.add(count), right_len + 1);\n-                    right.correct_childrens_parent_links(count..count + right_len + 1);\n+                    ptr::copy(right_edges, right_edges.add(count), old_right_len + 1);\n+                    right.correct_childrens_parent_links(count..count + old_right_len + 1);\n \n+                    // Steal edges.\n                     move_edges(left, new_left_len + 1, right, 0, count);\n                 }\n                 (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n@@ -1515,17 +1528,17 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n     pub fn bulk_steal_right(&mut self, count: usize) {\n         unsafe {\n             let left_node = &mut self.left_child;\n-            let left_len = left_node.len();\n+            let old_left_len = left_node.len();\n             let right_node = &mut self.right_child;\n-            let right_len = right_node.len();\n+            let old_right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n-            assert!(left_len + count <= CAPACITY);\n-            assert!(right_len >= count);\n+            assert!(old_left_len + count <= CAPACITY);\n+            assert!(old_right_len >= count);\n \n-            let new_right_len = right_len - count;\n+            let new_right_len = old_right_len - count;\n \n-            // Move data.\n+            // Move leaf data.\n             {\n                 let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n                 let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n@@ -1534,16 +1547,16 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                     (kv.0 as *mut K, kv.1 as *mut V)\n                 };\n \n-                // Move parent's key/value pair to the left child.\n-                move_kv(parent_kv, 0, left_kv, left_len, 1);\n+                // Move parent's key-value pair to the left child.\n+                move_kv(parent_kv, 0, left_kv, old_left_len, 1);\n \n                 // Move elements from the right child to the left one.\n-                move_kv(right_kv, 0, left_kv, left_len + 1, count - 1);\n+                move_kv(right_kv, 0, left_kv, old_left_len + 1, count - 1);\n \n                 // Move the right-most stolen pair to the parent.\n                 move_kv(right_kv, count - 1, parent_kv, 0, 1);\n \n-                // Fix right indexing\n+                // Fill gap where stolen elements used to be.\n                 ptr::copy(right_kv.0.add(count), right_kv.0, new_right_len);\n                 ptr::copy(right_kv.1.add(count), right_kv.1, new_right_len);\n             }\n@@ -1553,9 +1566,10 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n \n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n-                    move_edges(right.reborrow(), 0, left, left_len + 1, count);\n+                    // Steal edges.\n+                    move_edges(right.reborrow(), 0, left, old_left_len + 1, count);\n \n-                    // Fix right indexing.\n+                    // Fill gap where stolen edges used to be.\n                     let right_edges = right.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n                     ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n                     right.correct_childrens_parent_links(0..=new_right_len);\n@@ -1671,28 +1685,28 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n         right: &mut NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n     ) {\n         unsafe {\n-            let left_new_len = self.idx;\n+            let new_left_len = self.idx;\n             let mut left_node = self.reborrow_mut().into_node();\n \n-            let right_new_len = left_node.len() - left_new_len;\n+            let new_right_len = left_node.len() - new_left_len;\n             let mut right_node = right.reborrow_mut();\n \n             assert!(right_node.len() == 0);\n             assert!(left_node.height == right_node.height);\n \n-            if right_new_len > 0 {\n+            if new_right_len > 0 {\n                 let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n                 let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n \n-                move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n+                move_kv(left_kv, new_left_len, right_kv, 0, new_right_len);\n \n-                *left_node.reborrow_mut().into_len_mut() = left_new_len as u16;\n-                *right_node.reborrow_mut().into_len_mut() = right_new_len as u16;\n+                *left_node.reborrow_mut().into_len_mut() = new_left_len as u16;\n+                *right_node.reborrow_mut().into_len_mut() = new_right_len as u16;\n \n                 match (left_node.force(), right_node.force()) {\n                     (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n                         let left = left.reborrow();\n-                        move_edges(left, left_new_len + 1, right, 1, right_new_len);\n+                        move_edges(left, new_left_len + 1, right, 1, new_right_len);\n                     }\n                     (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n                     _ => unreachable!(),"}, {"sha": "5ae1c1fcab8031ad85758e6d850814ff8d63e0e6", "filename": "library/alloc/src/collections/btree/remove.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs?ref=bfa854dbe539808efbde25751fdfac8a3e01accf", "patch": "@@ -4,7 +4,7 @@ use super::unwrap_unchecked;\n use core::mem;\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    /// Removes a key/value-pair from the tree, and returns that pair, as well as\n+    /// Removes a key-value pair from the tree, and returns that pair, as well as\n     /// the leaf edge corresponding to that former pair. It's possible this empties\n     /// a root node that is internal, which the caller should pop from the map\n     /// holding the tree. The caller should also decrement the map's length."}, {"sha": "ed7f95fe632faa209124137b22828e483cd20765", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=bfa854dbe539808efbde25751fdfac8a3e01accf", "patch": "@@ -14,6 +14,9 @@ pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n /// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n /// returns a `GoDown` with the handle of the possible leaf edge where the key\n /// belongs.\n+///\n+/// The result is meaningful only if the tree is ordered by key, like the tree\n+/// in a `BTreeMap` is.\n pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n     mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     key: &Q,\n@@ -38,8 +41,11 @@ where\n \n /// Looks up a given key in a given node, without recursion.\n /// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n-/// returns a `GoDown` with the handle of the edge where the key might be found.\n-/// If the node is a leaf, a `GoDown` edge is not an actual edge but a possible edge.\n+/// returns a `GoDown` with the handle of the edge where the key might be found\n+/// (if the node is internal) or where the key can be inserted.\n+///\n+/// The result is meaningful only if the tree is ordered by key, like the tree\n+/// in a `BTreeMap` is.\n pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     node: NodeRef<BorrowType, K, V, Type>,\n     key: &Q,\n@@ -54,11 +60,11 @@ where\n     }\n }\n \n-/// Returns the index in the node at which the key (or an equivalent) exists\n-/// or could exist, and whether it exists in the node itself. If it doesn't\n-/// exist in the node itself, it may exist in the subtree with that index\n-/// (if the node has subtrees). If the key doesn't exist in node or subtree,\n-/// the returned index is the position or subtree where the key belongs.\n+/// Returns either the KV index in the node at which the key (or an equivalent)\n+/// exists and `true`, or the edge index where the key belongs and `false`.\n+///\n+/// The result is meaningful only if the tree is ordered by key, like the tree\n+/// in a `BTreeMap` is.\n fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n     key: &Q,"}, {"sha": "d8ce47ed77d1fb269f0eff8b3d43adc7d530e4ed", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=bfa854dbe539808efbde25751fdfac8a3e01accf", "patch": "@@ -214,7 +214,7 @@ impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n // This constant is used by functions that compare two sets.\n // It estimates the relative size at which searching performs better\n // than iterating, based on the benchmarks in\n-// https://github.com/ssomers/rust_bench_btreeset_intersection;\n+// https://github.com/ssomers/rust_bench_btreeset_intersection.\n // It's used to divide rather than multiply sizes, to rule out overflow,\n // and it's a power of two to make that division cheap.\n const ITER_PERFORMANCE_TIPPING_SIZE_DIFF: usize = 16;"}, {"sha": "6108c139bb3a62d3cfde162dedbb0849308c2d02", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa854dbe539808efbde25751fdfac8a3e01accf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=bfa854dbe539808efbde25751fdfac8a3e01accf", "patch": "@@ -23,8 +23,8 @@ impl<K, V> Root<K, V> {\n             loop {\n                 let mut split_edge = match search_node(left_node, key) {\n                     // key is going to the right tree\n-                    Found(handle) => handle.left_edge(),\n-                    GoDown(handle) => handle,\n+                    Found(kv) => kv.left_edge(),\n+                    GoDown(edge) => edge,\n                 };\n \n                 split_edge.move_suffix(&mut right_node);"}]}