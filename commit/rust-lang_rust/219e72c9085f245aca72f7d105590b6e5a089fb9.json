{"sha": "219e72c9085f245aca72f7d105590b6e5a089fb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOWU3MmM5MDg1ZjI0NWFjYTcyZjdkMTA1NTkwYjZlNWEwODlmYjk=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-01-03T08:57:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-01-03T08:57:57Z"}, "message": "Rollup merge of #47113 - sdroege:chunks-size-field, r=dtolnay\n\nMinor cleanup for slice::Chunks and ChunksMut\n\nThis only renames the `size` field to `chunk_size` in one of them for consistency, and changes an assertion to check for != 0 instead of > 0.", "tree": {"sha": "e2497e3e2ecb8337deb4a833197131a2184bcdcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2497e3e2ecb8337deb4a833197131a2184bcdcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/219e72c9085f245aca72f7d105590b6e5a089fb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/219e72c9085f245aca72f7d105590b6e5a089fb9", "html_url": "https://github.com/rust-lang/rust/commit/219e72c9085f245aca72f7d105590b6e5a089fb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/219e72c9085f245aca72f7d105590b6e5a089fb9/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd0b70e3fe80d6c48b6522dda6fe8809cea0405a", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd0b70e3fe80d6c48b6522dda6fe8809cea0405a", "html_url": "https://github.com/rust-lang/rust/commit/dd0b70e3fe80d6c48b6522dda6fe8809cea0405a"}, {"sha": "c096b3a451b38a84d3168bd2f4ce10a37d61e1ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/c096b3a451b38a84d3168bd2f4ce10a37d61e1ab", "html_url": "https://github.com/rust-lang/rust/commit/c096b3a451b38a84d3168bd2f4ce10a37d61e1ab"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "b880616833a4e1e43a5414f082da77ef89846e42", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/219e72c9085f245aca72f7d105590b6e5a089fb9/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219e72c9085f245aca72f7d105590b6e5a089fb9/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=219e72c9085f245aca72f7d105590b6e5a089fb9", "patch": "@@ -606,14 +606,14 @@ impl<T> [T] {\n         core_slice::SliceExt::windows(self, size)\n     }\n \n-    /// Returns an iterator over `size` elements of the slice at a\n-    /// time. The chunks are slices and do not overlap. If `size` does\n+    /// Returns an iterator over `chunk_size` elements of the slice at a\n+    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last chunk will\n-    /// not have length `size`.\n+    /// not have length `chunk_size`.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `size` is 0.\n+    /// Panics if `chunk_size` is 0.\n     ///\n     /// # Examples\n     ///\n@@ -627,8 +627,8 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn chunks(&self, size: usize) -> Chunks<T> {\n-        core_slice::SliceExt::chunks(self, size)\n+    pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n+        core_slice::SliceExt::chunks(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time."}, {"sha": "6b6ec7147b3064d96ad590cd9595bd12123744c9", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/219e72c9085f245aca72f7d105590b6e5a089fb9/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219e72c9085f245aca72f7d105590b6e5a089fb9/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=219e72c9085f245aca72f7d105590b6e5a089fb9", "patch": "@@ -348,9 +348,9 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn chunks(&self, size: usize) -> Chunks<T> {\n-        assert!(size != 0);\n-        Chunks { v: self, size: size }\n+    fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n+        assert!(chunk_size != 0);\n+        Chunks { v: self, chunk_size: chunk_size }\n     }\n \n     #[inline]\n@@ -532,7 +532,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n-        assert!(chunk_size > 0);\n+        assert!(chunk_size != 0);\n         ChunksMut { v: self, chunk_size: chunk_size }\n     }\n \n@@ -2117,7 +2117,7 @@ impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for Windows<'a, T> {}\n \n-/// An iterator over a slice in (non-overlapping) chunks (`size` elements at a\n+/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n /// time).\n ///\n /// When the slice len is not evenly divided by the chunk size, the last slice\n@@ -2131,7 +2131,7 @@ impl<'a, T> FusedIterator for Windows<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chunks<'a, T:'a> {\n     v: &'a [T],\n-    size: usize\n+    chunk_size: usize\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n@@ -2140,7 +2140,7 @@ impl<'a, T> Clone for Chunks<'a, T> {\n     fn clone(&self) -> Chunks<'a, T> {\n         Chunks {\n             v: self.v,\n-            size: self.size,\n+            chunk_size: self.chunk_size,\n         }\n     }\n }\n@@ -2154,7 +2154,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n         if self.v.is_empty() {\n             None\n         } else {\n-            let chunksz = cmp::min(self.v.len(), self.size);\n+            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n             let (fst, snd) = self.v.split_at(chunksz);\n             self.v = snd;\n             Some(fst)\n@@ -2166,8 +2166,8 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n         if self.v.is_empty() {\n             (0, Some(0))\n         } else {\n-            let n = self.v.len() / self.size;\n-            let rem = self.v.len() % self.size;\n+            let n = self.v.len() / self.chunk_size;\n+            let rem = self.v.len() % self.chunk_size;\n             let n = if rem > 0 { n+1 } else { n };\n             (n, Some(n))\n         }\n@@ -2180,12 +2180,12 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        let (start, overflow) = n.overflowing_mul(self.size);\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n         if start >= self.v.len() || overflow {\n             self.v = &[];\n             None\n         } else {\n-            let end = match start.checked_add(self.size) {\n+            let end = match start.checked_add(self.chunk_size) {\n                 Some(sum) => cmp::min(self.v.len(), sum),\n                 None => self.v.len(),\n             };\n@@ -2200,7 +2200,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n         if self.v.is_empty() {\n             None\n         } else {\n-            let start = (self.v.len() - 1) / self.size * self.size;\n+            let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n             Some(&self.v[start..])\n         }\n     }\n@@ -2213,8 +2213,8 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n         if self.v.is_empty() {\n             None\n         } else {\n-            let remainder = self.v.len() % self.size;\n-            let chunksz = if remainder != 0 { remainder } else { self.size };\n+            let remainder = self.v.len() % self.chunk_size;\n+            let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n             let (fst, snd) = self.v.split_at(self.v.len() - chunksz);\n             self.v = fst;\n             Some(snd)\n@@ -2228,7 +2228,7 @@ impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for Chunks<'a, T> {}\n \n-/// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n ///"}]}