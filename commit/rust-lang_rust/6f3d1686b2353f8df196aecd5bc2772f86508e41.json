{"sha": "6f3d1686b2353f8df196aecd5bc2772f86508e41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmM2QxNjg2YjIzNTNmOGRmMTk2YWVjZDViYzI3NzJmODY1MDhlNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-20T22:30:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-20T22:30:50Z"}, "message": "auto merge of #5447 : erickt/rust/incoming, r=graydon\n\nThis normalizes the how we call reverse iteration functions. It also adds a char_len method, and a method to iterate backwards over a string.", "tree": {"sha": "d8496c6f75b3e4958b3b1cf3c16dd7aa25e29a66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8496c6f75b3e4958b3b1cf3c16dd7aa25e29a66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f3d1686b2353f8df196aecd5bc2772f86508e41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f3d1686b2353f8df196aecd5bc2772f86508e41", "html_url": "https://github.com/rust-lang/rust/commit/6f3d1686b2353f8df196aecd5bc2772f86508e41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f3d1686b2353f8df196aecd5bc2772f86508e41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51da7d4bc7a100f5343bc727fb2fb87b05e35c84", "url": "https://api.github.com/repos/rust-lang/rust/commits/51da7d4bc7a100f5343bc727fb2fb87b05e35c84", "html_url": "https://github.com/rust-lang/rust/commit/51da7d4bc7a100f5343bc727fb2fb87b05e35c84"}, {"sha": "cefecd86017da9dabc998369bdbe73ef17b8b2c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cefecd86017da9dabc998369bdbe73ef17b8b2c7", "html_url": "https://github.com/rust-lang/rust/commit/cefecd86017da9dabc998369bdbe73ef17b8b2c7"}], "stats": {"total": 402, "additions": 297, "deletions": 105}, "files": [{"sha": "fcdd8fdd571b7aa5dc391e1384f5c1b4e0279448", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=6f3d1686b2353f8df196aecd5bc2772f86508e41", "patch": "@@ -218,7 +218,7 @@ pub impl ReprVisitor {\n \n     fn write_escaped_slice(&self, slice: &str) {\n         self.writer.write_char('\"');\n-        for str::chars_each(slice) |ch| {\n+        for slice.each_char |ch| {\n             self.writer.write_escaped_char(ch);\n         }\n         self.writer.write_char('\"');"}, {"sha": "748cea50e90d4c7e5d384e8a48fad37e67915ce4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 253, "deletions": 78, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=6f3d1686b2353f8df196aecd5bc2772f86508e41", "patch": "@@ -596,20 +596,20 @@ pub pure fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n /// Levenshtein Distance between two strings\n pub fn levdistance(s: &str, t: &str) -> uint {\n \n-    let slen = str::len(s);\n-    let tlen = str::len(t);\n+    let slen = s.len();\n+    let tlen = s.len();\n \n     if slen == 0 { return tlen; }\n     if tlen == 0 { return slen; }\n \n     let mut dcol = vec::from_fn(tlen + 1, |x| x);\n \n-    for str::each_chari(s) |i, sc| {\n+    for s.each_chari |i, sc| {\n \n         let mut current = i;\n         dcol[0] = current + 1;\n \n-        for str::each_chari(t) |j, tc| {\n+        for s.each_chari |j, tc| {\n \n             let mut next = dcol[j + 1];\n \n@@ -933,37 +933,44 @@ pub pure fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n         reserve(&mut result, len(ss));\n-        for chars_each(ss) |cc| {\n+        for ss.each_char |cc| {\n             str::push_char(&mut result, ff(cc));\n         }\n     }\n     result\n }\n \n /// Iterate over the bytes in a string\n-pub pure fn bytes_each(ss: &str, it: &fn(u8) -> bool) {\n-    let mut pos = 0u;\n-    let len = len(ss);\n+#[inline(always)]\n+pub pure fn each(s: &str, it: &fn(u8) -> bool) {\n+    eachi(s, |_i, b| it(b))\n+}\n+\n+/// Iterate over the bytes in a string, with indices\n+#[inline(always)]\n+pub pure fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n+    let mut pos = 0;\n+    let len = s.len();\n \n-    while (pos < len) {\n-        if !it(ss[pos]) { return; }\n-        pos += 1u;\n+    while pos < len {\n+        if !it(pos, s[pos]) { break; }\n+        pos += 1;\n     }\n }\n \n-/// Iterate over the bytes in a string\n+/// Iterate over the bytes in a string in reverse\n #[inline(always)]\n-pub pure fn each(s: &str, it: &fn(u8) -> bool) {\n-    eachi(s, |_i, b| it(b) )\n+pub pure fn each_reverse(s: &str, it: &fn(u8) -> bool) {\n+    eachi_reverse(s, |_i, b| it(b) )\n }\n \n-/// Iterate over the bytes in a string, with indices\n+/// Iterate over the bytes in a string in reverse, with indices\n #[inline(always)]\n-pub pure fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n-    let mut i = 0u, l = len(s);\n-    while (i < l) {\n-        if !it(i, s[i]) { break; }\n-        i += 1u;\n+pub pure fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n+    let mut pos = s.len();\n+    while pos > 0 {\n+        pos -= 1;\n+        if !it(pos, s[pos]) { break; }\n     }\n }\n \n@@ -976,8 +983,9 @@ pub pure fn each_char(s: &str, it: &fn(char) -> bool) {\n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n pub pure fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n-    let mut pos = 0u, ch_pos = 0u;\n-    let len = len(s);\n+    let mut pos = 0;\n+    let mut ch_pos = 0u;\n+    let len = s.len();\n     while pos < len {\n         let CharRange {ch, next} = char_range_at(s, pos);\n         pos = next;\n@@ -986,14 +994,25 @@ pub pure fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n     }\n }\n \n-/// Iterate over the characters in a string\n-pub pure fn chars_each(s: &str, it: &fn(char) -> bool) {\n-    let mut pos = 0u;\n-    let len = len(s);\n-    while (pos < len) {\n-        let CharRange {ch, next} = char_range_at(s, pos);\n+/// Iterates over the chars in a string in reverse\n+#[inline(always)]\n+pub pure fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n+    let mut pos = 0;\n+    let len = s.char_len();\n+    while pos > 0 {\n+        let CharRange {ch, next} = char_range_at_reverse(s, pos);\n         pos = next;\n-        if !it(ch) { return; }\n+        if !it(ch) { break; }\n+    }\n+}\n+\n+// Iterates over the chars in a string in reverse, with indices\n+#[inline(always)]\n+pub pure fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n+    let mut ch_pos = s.char_len();\n+    for s.each_char_reverse |ch| {\n+        ch_pos -= 1;\n+        if !it(ch_pos, ch) { break; }\n     }\n }\n \n@@ -1573,9 +1592,9 @@ pub pure fn is_utf16(v: &[u16]) -> bool {\n /// Converts to a vector of `u16` encoded as UTF-16\n pub pure fn to_utf16(s: &str) -> ~[u16] {\n     let mut u = ~[];\n-    for chars_each(s) |cch| {\n+    for s.each_char |ch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n-        let mut ch = cch as u32;\n+        let mut ch = ch as u32;\n \n         unsafe {\n             if (ch & 0xFFFF_u32) == ch {\n@@ -1769,7 +1788,7 @@ pub pure fn char_range_at(s: &str, i: uint) -> CharRange {\n     return CharRange {ch: val as char, next: i};\n }\n \n-/// Pluck a character out of a string\n+/// Plucks the `n`th character from the beginning of a string\n pub pure fn char_at(s: &str, i: uint) -> char {\n     return char_range_at(s, i).ch;\n }\n@@ -1799,6 +1818,11 @@ pure fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n     return CharRange {ch:ch, next:prev};\n }\n \n+/// Plucks the `n`th character from the end of a string\n+pub pure fn char_at_reverse(s: &str, i: uint) -> char {\n+    char_range_at_reverse(s, i).ch\n+}\n+\n /**\n  * Loop through a substring, char by char\n  *\n@@ -2022,7 +2046,7 @@ pub pure fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n-        for chars_each(s) |c| {\n+        for s.each_char |c| {\n             push_str(&mut out, char::escape_default(c));\n         }\n     }\n@@ -2034,7 +2058,7 @@ pub pure fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n-        for chars_each(s) |c| {\n+        for s.each_char |c| {\n             push_str(&mut out, char::escape_unicode(c));\n         }\n     }\n@@ -2251,13 +2275,18 @@ pub trait StrSlice {\n     pure fn contains_char(&self, needle: char) -> bool;\n     pure fn each(&self, it: &fn(u8) -> bool);\n     pure fn eachi(&self, it: &fn(uint, u8) -> bool);\n+    pure fn each_reverse(&self, it: &fn(u8) -> bool);\n+    pure fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n     pure fn each_char(&self, it: &fn(char) -> bool);\n     pure fn each_chari(&self, it: &fn(uint, char) -> bool);\n+    pure fn each_char_reverse(&self, it: &fn(char) -> bool);\n+    pure fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n     pure fn ends_with(&self, needle: &str) -> bool;\n     pure fn is_empty(&self) -> bool;\n     pure fn is_whitespace(&self) -> bool;\n     pure fn is_alphanumeric(&self) -> bool;\n     pure fn len(&self) -> uint;\n+    pure fn char_len(&self) -> uint;\n     pure fn slice(&self, begin: uint, end: uint) -> ~str;\n     pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n     pure fn split_char(&self, sep: char) -> ~[~str];\n@@ -2274,6 +2303,7 @@ pub trait StrSlice {\n     pure fn to_owned(&self) -> ~str;\n     pure fn to_managed(&self) -> @str;\n     pure fn char_at(&self, i: uint) -> char;\n+    pure fn char_at_reverse(&self, i: uint) -> char;\n     fn to_bytes(&self) -> ~[u8];\n }\n \n@@ -2307,6 +2337,16 @@ impl StrSlice for &'self str {\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n     pure fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n+    /// Iterate over the bytes in a string\n+    #[inline]\n+    pure fn each_reverse(&self, it: &fn(u8) -> bool) {\n+        each_reverse(*self, it)\n+    }\n+    /// Iterate over the bytes in a string, with indices\n+    #[inline]\n+    pure fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) {\n+        eachi_reverse(*self, it)\n+    }\n     /// Iterate over the chars in a string\n     #[inline]\n     pure fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n@@ -2315,6 +2355,17 @@ impl StrSlice for &'self str {\n     pure fn each_chari(&self, it: &fn(uint, char) -> bool) {\n         each_chari(*self, it)\n     }\n+    /// Iterate over the chars in a string in reverse\n+    #[inline]\n+    pure fn each_char_reverse(&self, it: &fn(char) -> bool) {\n+        each_char_reverse(*self, it)\n+    }\n+    /// Iterate over the chars in a string in reverse, with indices from the\n+    /// end\n+    #[inline]\n+    pure fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) {\n+        each_chari_reverse(*self, it)\n+    }\n     /// Returns true if one string ends with another\n     #[inline]\n     pure fn ends_with(&self, needle: &str) -> bool {\n@@ -2337,9 +2388,12 @@ impl StrSlice for &'self str {\n      */\n     #[inline]\n     pure fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n-    #[inline]\n     /// Returns the size in bytes not counting the null terminator\n+    #[inline]\n     pure fn len(&self) -> uint { len(*self) }\n+    /// Returns the number of characters that a string holds\n+    #[inline]\n+    pure fn char_len(&self) -> uint { char_len(*self) }\n     /**\n      * Returns a slice of the given string from the byte range\n      * [`begin`..`end`)\n@@ -2419,6 +2473,11 @@ impl StrSlice for &'self str {\n     #[inline]\n     pure fn char_at(&self, i: uint) -> char { char_at(*self, i) }\n \n+    #[inline]\n+    pure fn char_at_reverse(&self, i: uint) -> char {\n+        char_at_reverse(*self, i)\n+    }\n+\n     fn to_bytes(&self) -> ~[u8] { to_bytes(*self) }\n }\n \n@@ -3234,41 +3293,6 @@ mod tests {\n         fail_unless!(!contains_char(~\"\", 'a'));\n     }\n \n-    #[test]\n-    fn test_chars_each() {\n-        let mut i = 0;\n-        for chars_each(~\"x\\u03c0y\") |ch| {\n-            match i {\n-              0 => fail_unless!(ch == 'x'),\n-              1 => fail_unless!(ch == '\\u03c0'),\n-              2 => fail_unless!(ch == 'y'),\n-              _ => fail!(~\"test_chars_each failed\")\n-            }\n-            i += 1;\n-        }\n-\n-        chars_each(~\"\", |_ch| fail!() ); // should not fail\n-    }\n-\n-    #[test]\n-    fn test_bytes_each() {\n-        let mut i = 0;\n-\n-        for bytes_each(~\"xyz\") |bb| {\n-            match i {\n-              0 => fail_unless!(bb == 'x' as u8),\n-              1 => fail_unless!(bb == 'y' as u8),\n-              2 => fail_unless!(bb == 'z' as u8),\n-              _ => fail!(~\"test_bytes_each failed\")\n-            }\n-            i += 1;\n-        }\n-\n-        for bytes_each(~\"\") |bb| {\n-            fail_unless!(bb == 0u8);\n-        }\n-    }\n-\n     #[test]\n     fn test_split_char_each() {\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n@@ -3426,17 +3450,168 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_char_at() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let mut pos = 0;\n+        for v.each |ch| {\n+            fail_unless!(s.char_at(pos) == *ch);\n+            pos += from_char(*ch).len();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_char_at_reverse() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let mut pos = s.len();\n+        for v.each_reverse |ch| {\n+            fail_unless!(s.char_at_reverse(pos) == *ch);\n+            pos -= from_char(*ch).len();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = 0;\n+\n+        for s.each |b| {\n+            fail_unless!(b == v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_empty() {\n+        for \"\".each |b| {\n+            fail_unless!(b == 0u8);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_eachi() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = 0;\n+\n+        for s.eachi |i, b| {\n+            fail_unless!(pos == i);\n+            fail_unless!(b == v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_eachi_empty() {\n+        for \"\".eachi |i, b| {\n+            fail_unless!(i == 0);\n+            fail_unless!(b == 0);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_reverse() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = v.len();\n+\n+        for s.each_reverse |b| {\n+            pos -= 1;\n+            fail_unless!(b == v[pos]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_empty_reverse() {\n+        for \"\".each_reverse |b| {\n+            fail_unless!(b == 0u8);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_eachi_reverse() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = v.len();\n+\n+        for s.eachi_reverse |i, b| {\n+            pos -= 1;\n+            fail_unless!(pos == i);\n+            fail_unless!(b == v[pos]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_eachi_reverse_empty() {\n+        for \"\".eachi_reverse |i, b| {\n+            fail_unless!(i == 0);\n+            fail_unless!(b == 0);\n+        }\n+    }\n+\n     #[test]\n     fn test_each_char() {\n-        let s = ~\"abc\";\n-        let mut found_b = false;\n-        for each_char(s) |ch| {\n-            if ch == 'b' {\n-                found_b = true;\n-                break;\n-            }\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let mut pos = 0;\n+        for s.each_char |ch| {\n+            fail_unless!(ch == v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_chari() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let mut pos = 0;\n+        for s.each_chari |i, ch| {\n+            fail_unless!(pos == i);\n+            fail_unless!(ch == v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_char_reverse() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let mut pos = 0;\n+        for s.each_char_reverse |ch| {\n+            fail_unless!(ch == v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_each_chari_reverse() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let mut pos = v.len();\n+        for s.each_chari_reverse |i, ch| {\n+            pos -= 1;\n+            fail_unless!(pos == i);\n+            fail_unless!(ch == v[pos]);\n         }\n-        fail_unless!(found_b);\n     }\n \n     #[test]"}, {"sha": "e41aefc94e5f7d89da47acf5f1457296f9a6dc92", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=6f3d1686b2353f8df196aecd5bc2772f86508e41", "patch": "@@ -1005,7 +1005,7 @@ pub pure fn foldl<T, U>(z: T, v: &[U], p: &fn(t: T, u: &U) -> T) -> T {\n  */\n pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: &fn(t: &T, u: U) -> U) -> U {\n     let mut accum = z;\n-    for rev_each(v) |elt| {\n+    for v.each_reverse |elt| {\n         accum = p(elt, accum);\n     }\n     accum\n@@ -1411,8 +1411,8 @@ pub pure fn eachi<T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn rev_each<T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n-    rev_eachi(v, |_i, v| blk(v))\n+pub pure fn each_reverse<T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n+    eachi_reverse(v, |_i, v| blk(v))\n }\n \n /**\n@@ -1421,7 +1421,7 @@ pub pure fn rev_each<T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn rev_eachi<T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n+pub pure fn eachi_reverse<T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n     let mut i = v.len();\n     while i > 0 {\n         i -= 1;\n@@ -1736,6 +1736,8 @@ pub trait ImmutableVector<T> {\n     pure fn initn(&self, n: uint) -> &'self [T];\n     pure fn last(&self) -> &'self T;\n     pure fn last_opt(&self) -> Option<&'self T>;\n+    pure fn each_reverse(&self, blk: &fn(&T) -> bool);\n+    pure fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n     pure fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n     pure fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n     pure fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n@@ -1785,6 +1787,18 @@ impl<T> ImmutableVector<T> for &'self [T] {\n     #[inline]\n     pure fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n \n+    /// Iterates over a vector's elements in reverse.\n+    #[inline]\n+    pure fn each_reverse(&self, blk: &fn(&T) -> bool) {\n+        each_reverse(*self, blk)\n+    }\n+\n+    /// Iterates over a vector's elements and indices in reverse.\n+    #[inline]\n+    pure fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n+        eachi_reverse(*self, blk)\n+    }\n+\n     /// Reduce a vector from right to left\n     #[inline]\n     pure fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n@@ -3131,33 +3145,42 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reach_empty() {\n-        for rev_each::<int>(~[]) |_v| {\n+    fn test_each_reverse_empty() {\n+        let v: ~[int] = ~[];\n+        for v.each_reverse |_v| {\n             fail!(); // should never execute\n         }\n     }\n \n     #[test]\n-    fn test_reach_nonempty() {\n+    fn test_each_reverse_nonempty() {\n         let mut i = 0;\n-        for rev_each(~[1, 2, 3]) |v| {\n+        for each_reverse(~[1, 2, 3]) |v| {\n             if i == 0 { fail_unless!(*v == 3); }\n             i += *v\n         }\n         fail_unless!(i == 6);\n     }\n \n     #[test]\n-    fn test_reachi() {\n+    fn test_eachi_reverse() {\n         let mut i = 0;\n-        for rev_eachi(~[0, 1, 2]) |j, v| {\n+        for eachi_reverse(~[0, 1, 2]) |j, v| {\n             if i == 0 { fail_unless!(*v == 2); }\n             fail_unless!(j == *v as uint);\n             i += *v;\n         }\n         fail_unless!(i == 3);\n     }\n \n+    #[test]\n+    fn test_eachi_reverse_empty() {\n+        let v: ~[int] = ~[];\n+        for v.eachi_reverse |_i, _v| {\n+            fail!(); // should never execute\n+        }\n+    }\n+\n     #[test]\n     fn test_each_permutation() {\n         let mut results: ~[~[int]];"}, {"sha": "d953c3bd033faf48e80e387c718d222bd2b9f595", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=6f3d1686b2353f8df196aecd5bc2772f86508e41", "patch": "@@ -656,7 +656,7 @@ pub fn get_symbol_hash(ccx: @CrateContext, t: ty::t) -> @str {\n // gas doesn't!\n pub fn sanitize(s: &str) -> ~str {\n     let mut result = ~\"\";\n-    for str::chars_each(s) |c| {\n+    for str::each_char(s) |c| {\n         match c {\n           '@' => result += ~\"_sbox_\",\n           '~' => result += ~\"_ubox_\","}, {"sha": "9346872f949002c8dea59ae8e2fad22f247c0679", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6f3d1686b2353f8df196aecd5bc2772f86508e41", "patch": "@@ -1264,7 +1264,7 @@ pub fn trans_block_cleanups_(bcx: block,\n         bcx.ccx().sess.opts.debugging_opts & session::no_landing_pads != 0;\n     if bcx.unreachable && !no_lpads { return bcx; }\n     let mut bcx = bcx;\n-    for vec::rev_each(cleanups) |cu| {\n+    for cleanups.each_reverse |cu| {\n         match *cu {\n             clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during"}, {"sha": "cdc65de49871e6e4d00a9c6936027bb4dd8fdeea", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=6f3d1686b2353f8df196aecd5bc2772f86508e41", "patch": "@@ -324,7 +324,7 @@ pub impl BigUint {\n         if s_len < o_len { return -1; }\n         if s_len > o_len { return  1;  }\n \n-        for vec::rev_eachi(self.data) |i, elm| {\n+        for self.data.eachi_reverse |i, elm| {\n             match (*elm, other.data[i]) {\n                 (l, r) if l < r => return -1,\n                 (l, r) if l > r => return  1,\n@@ -387,7 +387,7 @@ pub impl BigUint {\n             let bn = *b.data.last();\n             let mut d = ~[];\n             let mut carry = 0;\n-            for vec::rev_each(an) |elt| {\n+            for an.each_reverse |elt| {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n                 fail_unless!(di < BigDigit::base);\n@@ -499,7 +499,7 @@ pub impl BigUint {\n \n         let mut borrow = 0;\n         let mut shifted = ~[];\n-        for vec::rev_each(self.data) |elem| {\n+        for self.data.each_reverse |elem| {\n             shifted = ~[(*elem >> n_bits) | borrow] + shifted;\n             borrow = *elem << (uint::bits - n_bits);\n         }"}, {"sha": "7503f28e8486bda19e40c25f38d876f96e6b8535", "filename": "src/libstd/json.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f3d1686b2353f8df196aecd5bc2772f86508e41/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=6f3d1686b2353f8df196aecd5bc2772f86508e41", "patch": "@@ -14,20 +14,14 @@\n \n //! json serialization\n \n+use core::prelude::*;\n+use core::io::{WriterUtil, ReaderUtil};\n+use core::hashmap::linear::LinearMap;\n+\n use serialize::Encodable;\n use serialize;\n use sort::Sort;\n \n-use core::char;\n-use core::cmp::{Eq, Ord};\n-use core::float;\n-use core::io::{WriterUtil, ReaderUtil};\n-use core::io;\n-use core::prelude::*;\n-use core::hashmap::linear::LinearMap;\n-use core::str;\n-use core::to_str;\n-\n /// Represents a json value\n pub enum Json {\n     Number(float),\n@@ -49,7 +43,7 @@ pub struct Error {\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n-    for str::chars_each(s) |c| {\n+    for str::each_char(s) |c| {\n         match c {\n           '\"' => escaped += ~\"\\\\\\\"\",\n           '\\\\' => escaped += ~\"\\\\\\\\\","}]}