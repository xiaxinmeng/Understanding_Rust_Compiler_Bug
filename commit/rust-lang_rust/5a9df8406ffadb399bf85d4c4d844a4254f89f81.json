{"sha": "5a9df8406ffadb399bf85d4c4d844a4254f89f81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhOWRmODQwNmZmYWRiMzk5YmY4NWQ0YzRkODQ0YTQyNTRmODlmODE=", "commit": {"author": {"name": "Hanif Bin Ariffin", "email": "hanif.ariffin.4326@gmail.com", "date": "2020-06-13T23:02:26Z"}, "committer": {"name": "Hanif Bin Ariffin", "email": "hanif.ariffin.4326@gmail.com", "date": "2020-06-16T20:19:49Z"}, "message": "Added some more documentations to unsafety blocks in slice/sort.rs", "tree": {"sha": "cecd2181d47ad5358287e90e55d854ec965632d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cecd2181d47ad5358287e90e55d854ec965632d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a9df8406ffadb399bf85d4c4d844a4254f89f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a9df8406ffadb399bf85d4c4d844a4254f89f81", "html_url": "https://github.com/rust-lang/rust/commit/5a9df8406ffadb399bf85d4c4d844a4254f89f81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a9df8406ffadb399bf85d4c4d844a4254f89f81/comments", "author": {"login": "hbina", "id": 6733660, "node_id": "MDQ6VXNlcjY3MzM2NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/6733660?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hbina", "html_url": "https://github.com/hbina", "followers_url": "https://api.github.com/users/hbina/followers", "following_url": "https://api.github.com/users/hbina/following{/other_user}", "gists_url": "https://api.github.com/users/hbina/gists{/gist_id}", "starred_url": "https://api.github.com/users/hbina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hbina/subscriptions", "organizations_url": "https://api.github.com/users/hbina/orgs", "repos_url": "https://api.github.com/users/hbina/repos", "events_url": "https://api.github.com/users/hbina/events{/privacy}", "received_events_url": "https://api.github.com/users/hbina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hbina", "id": 6733660, "node_id": "MDQ6VXNlcjY3MzM2NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/6733660?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hbina", "html_url": "https://github.com/hbina", "followers_url": "https://api.github.com/users/hbina/followers", "following_url": "https://api.github.com/users/hbina/following{/other_user}", "gists_url": "https://api.github.com/users/hbina/gists{/gist_id}", "starred_url": "https://api.github.com/users/hbina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hbina/subscriptions", "organizations_url": "https://api.github.com/users/hbina/orgs", "repos_url": "https://api.github.com/users/hbina/repos", "events_url": "https://api.github.com/users/hbina/events{/privacy}", "received_events_url": "https://api.github.com/users/hbina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c710461b02660cef1d077420d5b486b1d8f1f28b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c710461b02660cef1d077420d5b486b1d8f1f28b", "html_url": "https://github.com/rust-lang/rust/commit/c710461b02660cef1d077420d5b486b1d8f1f28b"}], "stats": {"total": 50, "additions": 39, "deletions": 11}, "files": [{"sha": "8b2ac294764ff5aa49fc17796b45a1a8f651910d", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5a9df8406ffadb399bf85d4c4d844a4254f89f81/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a9df8406ffadb399bf85d4c4d844a4254f89f81/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=5a9df8406ffadb399bf85d4c4d844a4254f89f81", "patch": "@@ -20,6 +20,9 @@ struct CopyOnDrop<T> {\n \n impl<T> Drop for CopyOnDrop<T> {\n     fn drop(&mut self) {\n+        // SAFETY:  This is a helper class.\n+        //          Please refer to its usage for correctness.\n+        //          Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n         unsafe {\n             ptr::copy_nonoverlapping(self.src, self.dest, 1);\n         }\n@@ -43,7 +46,8 @@ where\n     //  1. We are obtaining pointers to references which are guaranteed to be valid.\n     //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n     //     Namely, `i` and `i-1`.\n-    //  3. FIXME: Guarantees that the elements are properly aligned?\n+    //  3. If the slice is properly aligned, the elements are properly aligned.\n+    //     It is the caller's responsibility to make sure the slice is properly aligned.\n     //\n     // See comments below for further detail.\n     unsafe {\n@@ -76,18 +80,19 @@ where\n     F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n-    // SAFETY: As with shift_head, the unsafe operations below involves indexing without a bound check (`get_unchecked` and `get_unchecked_mut`)\n+    // SAFETY: The unsafe operations below involves indexing without a bound check (`get_unchecked` and `get_unchecked_mut`)\n     // and copying memory (`ptr::copy_nonoverlapping`).\n     //\n     // a. Indexing:\n-    //  1. We checked the size of the array to >=2.\n-    //  2. All the indexing that we will do is always between {0 <= index < len-1} at most.\n+    //  1. We checked the size of the array to >= 2.\n+    //  2. All the indexing that we will do is always between `0 <= index < len-1` at most.\n     //\n     // b. Memory copying\n     //  1. We are obtaining pointers to references which are guaranteed to be valid.\n     //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n     //     Namely, `i` and `i+1`.\n-    //  3. FIXME: Guarantees that the elements are properly aligned?\n+    //  3. If the slice is properly aligned, the elements are properly aligned.\n+    //     It is the caller's responsibility to make sure the slice is properly aligned.\n     //\n     // See comments below for further detail.\n     unsafe {\n@@ -131,8 +136,8 @@ where\n     let mut i = 1;\n \n     for _ in 0..MAX_STEPS {\n-        // SAFETY: We already explicitly done the bound checking with `i<len`\n-        // All our indexing following that is only in the range {0 <= index < len}\n+        // SAFETY: We already explicitly did the bound checking with `i < len`.\n+        // All our subsequent indexing is only in the range `0 <= index < len`\n         unsafe {\n             // Find the next pair of adjacent out-of-order elements.\n             while i < len && !is_less(v.get_unchecked(i), v.get_unchecked(i - 1)) {\n@@ -299,6 +304,16 @@ where\n             let mut elem = l;\n \n             for i in 0..block_l {\n+                // SAFETY: The unsafety operations below involve the usage of the `offset`.\n+                //         According to the conditions required by the function, we satisfy them because:\n+                //         1. `offsets_l` is stack-allocated, and thus considered separate allocated object.\n+                //         2. The function `is_less` returns a `bool`.\n+                //            Casting a `bool` will never overflow `isize`.\n+                //         3. We have guaranteed that `block_l` will be `<= BLOCK`.\n+                //            Plus, `end_l` was initially set to the begin pointer of `offsets_` which was declared on the stack.\n+                //            Thus, we know that even in the worst case (all invocations of `is_less` returns false) we will only be at most 1 byte pass the end.\n+                //        Another unsafety operation here is dereferencing `elem`.\n+                //        However, `elem` was initially the begin pointer to the slice which is always valid.\n                 unsafe {\n                     // Branchless comparison.\n                     *end_l = i as u8;\n@@ -315,6 +330,17 @@ where\n             let mut elem = r;\n \n             for i in 0..block_r {\n+                // SAFETY: The unsafety operations below involve the usage of the `offset`.\n+                //         According to the conditions required by the function, we satisfy them because:\n+                //         1. `offsets_r` is stack-allocated, and thus considered separate allocated object.\n+                //         2. The function `is_less` returns a `bool`.\n+                //            Casting a `bool` will never overflow `isize`.\n+                //         3. We have guaranteed that `block_r` will be `<= BLOCK`.\n+                //            Plus, `end_r` was initially set to the begin pointer of `offsets_` which was declared on the stack.\n+                //            Thus, we know that even in the worst case (all invocations of `is_less` returns true) we will only be at most 1 byte pass the end.\n+                //        Another unsafety operation here is dereferencing `elem`.\n+                //        However, `elem` was initially `1 * sizeof(T)` past the end and we decrement it by `1 * sizeof(T)` before accessing it.\n+                //        Plus, `block_r` was asserted to be less than `BLOCK` and `elem` will therefore at most be pointing to the beginning of the slice.\n                 unsafe {\n                     // Branchless comparison.\n                     elem = elem.offset(-1);\n@@ -437,8 +463,9 @@ where\n         let mut r = v.len();\n \n         // SAFETY: The unsafety below involves indexing an array.\n-        // For the first one: we already do the bound checking here with `l<r`.\n-        // For the secondn one: the minimum value for `l` is 0 and the maximum value for `r` is `v.len().`\n+        // For the first one: We already do the bounds checking here with `l < r`.\n+        // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.\n+        //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.\n         unsafe {\n             // Find the first element greater than or equal to the pivot.\n             while l < r && is_less(v.get_unchecked(l), pivot) {\n@@ -489,8 +516,9 @@ where\n     let mut r = v.len();\n     loop {\n         // SAFETY: The unsafety below involves indexing an array.\n-        // For the first one: we already do the bound checking here with `l<r`.\n-        // For the second one: the minimum value for `l` is 0 and the maximum value for `r` is `v.len().`\n+        // For the first one: We already do the bounds checking here with `l < r`.\n+        // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.\n+        //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.\n         unsafe {\n             // Find the first element greater than the pivot.\n             while l < r && !is_less(pivot, v.get_unchecked(l)) {"}]}