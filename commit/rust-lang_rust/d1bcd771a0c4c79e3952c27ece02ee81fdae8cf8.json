{"sha": "d1bcd771a0c4c79e3952c27ece02ee81fdae8cf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxYmNkNzcxYTBjNGM3OWUzOTUyYzI3ZWNlMDJlZTgxZmRhZThjZjg=", "commit": {"author": {"name": "nham", "email": "hamann.nick@gmail.com", "date": "2014-09-02T05:57:23Z"}, "committer": {"name": "nham", "email": "hamann.nick@gmail.com", "date": "2014-09-02T05:57:23Z"}, "message": "Add many comments to TwoWaySearcher.", "tree": {"sha": "825a0cde82b744c1ff3db7df3e48394b04591217", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/825a0cde82b744c1ff3db7df3e48394b04591217"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1bcd771a0c4c79e3952c27ece02ee81fdae8cf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1bcd771a0c4c79e3952c27ece02ee81fdae8cf8", "html_url": "https://github.com/rust-lang/rust/commit/d1bcd771a0c4c79e3952c27ece02ee81fdae8cf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1bcd771a0c4c79e3952c27ece02ee81fdae8cf8/comments", "author": {"login": "nham", "id": 546409, "node_id": "MDQ6VXNlcjU0NjQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/546409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nham", "html_url": "https://github.com/nham", "followers_url": "https://api.github.com/users/nham/followers", "following_url": "https://api.github.com/users/nham/following{/other_user}", "gists_url": "https://api.github.com/users/nham/gists{/gist_id}", "starred_url": "https://api.github.com/users/nham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nham/subscriptions", "organizations_url": "https://api.github.com/users/nham/orgs", "repos_url": "https://api.github.com/users/nham/repos", "events_url": "https://api.github.com/users/nham/events{/privacy}", "received_events_url": "https://api.github.com/users/nham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nham", "id": 546409, "node_id": "MDQ6VXNlcjU0NjQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/546409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nham", "html_url": "https://github.com/nham", "followers_url": "https://api.github.com/users/nham/followers", "following_url": "https://api.github.com/users/nham/following{/other_user}", "gists_url": "https://api.github.com/users/nham/gists{/gist_id}", "starred_url": "https://api.github.com/users/nham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nham/subscriptions", "organizations_url": "https://api.github.com/users/nham/orgs", "repos_url": "https://api.github.com/users/nham/repos", "events_url": "https://api.github.com/users/nham/events{/privacy}", "received_events_url": "https://api.github.com/users/nham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9db8adebb9fe9c7f65266127fca926ff736b740", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9db8adebb9fe9c7f65266127fca926ff736b740", "html_url": "https://github.com/rust-lang/rust/commit/e9db8adebb9fe9c7f65266127fca926ff736b740"}], "stats": {"total": 97, "additions": 87, "deletions": 10}, "files": [{"sha": "855ed9adf9f4f0b9ed52fe1e6009beefc258f12b", "filename": "src/libcore/str.rs", "status": "modified", "additions": 87, "deletions": 10, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d1bcd771a0c4c79e3952c27ece02ee81fdae8cf8/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1bcd771a0c4c79e3952c27ece02ee81fdae8cf8/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d1bcd771a0c4c79e3952c27ece02ee81fdae8cf8", "patch": "@@ -419,8 +419,76 @@ struct TwoWaySearcher {\n     memory: uint\n }\n \n-// This is the Two-Way search algorithm, which was introduced in the paper:\n-// Crochemore, M., Perrin, D., 1991, Two-way string-matching, Journal of the ACM 38(3):651-675.\n+/*\n+    This is the Two-Way search algorithm, which was introduced in the paper:\n+    Crochemore, M., Perrin, D., 1991, Two-way string-matching, Journal of the ACM 38(3):651-675.\n+\n+    Here's some background information.\n+\n+    A *word* is a string of symbols. The *length* of a word should be a familiar\n+    notion, and here we denote it for any word x by |x|.\n+    (We also allow for the possibility of the *empty word*, a word of length zero).\n+\n+    If x is any non-empty word, then an integer p with 0 < p <= |x| is said to be a\n+    *period* for x iff for all i with 0 <= i <= |x| - p - 1, we have x[i] == x[i+p].\n+    For example, both 1 and 2 are periods for the string \"aa\". As another example,\n+    the only period of the string \"abcd\" is 4.\n+\n+    We denote by period(x) the *smallest* period of x (provided that x is non-empty).\n+    This is always well-defined since every non-empty word x has at least one period,\n+    |x|. We sometimes call this *the period* of x.\n+\n+    If u, v and x are words such that x = uv, where uv is the concatenation of u and\n+    v, then we say that (u, v) is a *factorization* of x.\n+\n+    Let (u, v) be a factorization for a word x. Then if w is a non-empty word such\n+    that both of the following hold\n+\n+      - either w is a suffix of u or u is a suffix of w\n+      - either w is a prefix of v or v is a prefix of w\n+\n+    then w is said to be a *repetition* for the factorization (u, v).\n+\n+    Just to unpack this, there are four possibilities here. Let w = \"abc\". Then we\n+    might have:\n+\n+      - w is a suffix of u and w is a prefix of v. ex: (\"lolabc\", \"abcde\")\n+      - w is a suffix of u and v is a prefix of w. ex: (\"lolabc\", \"ab\")\n+      - u is a suffix of w and w is a prefix of v. ex: (\"bc\", \"abchi\")\n+      - u is a suffix of w and v is a prefix of w. ex: (\"bc\", \"a\")\n+\n+    Note that the word vu is a repetition for any factorization (u,v) of x = uv,\n+    so every factorization has at least one repetition.\n+\n+    If x is a string and (u, v) is a factorization for x, then a *local period* for\n+    (u, v) is an integer r such that there is some word w such that |w| = r and w is\n+    a repetition for (u, v).\n+\n+    We denote by local_period(u, v) the smallest local period of (u, v). We sometimes\n+    call this *the local period* of (u, v). Provided that x = uv is non-empty, this\n+    is well-defined (because each non-empty word has at least one factorization, as\n+    noted above).\n+\n+    It can be proven that the following is an equivalent definition of a local period\n+    for a factorization (u, v): any positive integer r such that x[i] == x[i+r] for\n+    all i such that |u| - r <= i <= |u| - 1 and such that both x[i] and x[i+r] are\n+    defined. (i.e. i > 0 and i + r < |x|).\n+\n+    Using the above reformulation, it is easy to prove that\n+\n+        1 <= local_period(u, v) <= period(uv)\n+\n+    A factorization (u, v) of x such that local_period(u,v) = period(x) is called a\n+    *critical factorization*.\n+\n+    The algorithm hinges on the following theorem, which is stated without proof:\n+\n+    **Critical Factorization Theorem** Any word x has at least one critical\n+    factorization (u, v) such that |u| < period(x).\n+\n+    The purpose of maximal_suffix is to find such a critical factorization.\n+\n+*/\n impl TwoWaySearcher {\n     fn new(needle: &[u8]) -> TwoWaySearcher {\n         let (crit_pos1, period1) = TwoWaySearcher::maximal_suffix(needle, false);\n@@ -436,15 +504,19 @@ impl TwoWaySearcher {\n             period = period2;\n         }\n \n+        // This isn't in the original algorithm, as far as I'm aware.\n         let byteset = needle.iter()\n                             .fold(0, |a, &b| (1 << ((b & 0x3f) as uint)) | a);\n \n-        // The logic here (calculating crit_pos and period, the final if statement to see which\n-        // period to use for the TwoWaySearcher) is essentially an implementation of the\n-        // \"small-period\" function from the paper (p. 670)\n+        // A particularly readable explanation of what's going on here can be found\n+        // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n+        // see the code for \"Algorithm CP\" on p. 323.\n         //\n-        // In the paper they check whether `needle.slice_to(crit_pos)` is a suffix of\n-        // `needle.slice(crit_pos, crit_pos + period)`, which is precisely what this does\n+        // What's going on is we have some critical factorization (u, v) of the\n+        // needle, and we want to determine whether u is a suffix of\n+        // v.slice_to(period). If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // \"Algorithm CP2\", which is optimized for when the period of the needle\n+        // is large.\n         if needle.slice_to(crit_pos) == needle.slice(period, period + crit_pos) {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n@@ -466,6 +538,11 @@ impl TwoWaySearcher {\n         }\n     }\n \n+    // One of the main ideas of Two-Way is that we factorize the needle into\n+    // two halves, (u, v), and begin trying to find v in the haystack by scanning\n+    // left to right. If v matches, we try to match u by scanning right to left.\n+    // How far we can jump when we encounter a mismatch is all based on the fact\n+    // that (u, v) is a critical factorization for the needle.\n     #[inline]\n     fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> Option<(uint, uint)> {\n         'search: loop {\n@@ -520,9 +597,9 @@ impl TwoWaySearcher {\n         }\n     }\n \n-    // returns (i, p) where i is the \"critical position\", the starting index of\n-    // of maximal suffix, and p is the period of the suffix\n-    // see p. 668 of the paper\n+    // Computes a critical factorization (u, v) of `arr`.\n+    // Specifically, returns (i, p), where i is the starting index of v in some\n+    // critical factorization (u, v) and p = period(v)\n     #[inline]\n     fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) {\n         let mut left = -1; // Corresponds to i in the paper"}]}