{"sha": "68627522b0d34ee8712bcfb05edfe7ff157ec035", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NjI3NTIyYjBkMzRlZTg3MTJiY2ZiMDVlZGZlN2ZmMTU3ZWMwMzU=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-08-16T20:59:03Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-08-16T20:59:03Z"}, "message": "Merge pull request #174 from marcusklaas/format-paths\n\nFormat paths", "tree": {"sha": "f3aa2bd2357772460166aebde44155454aaab3a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3aa2bd2357772460166aebde44155454aaab3a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68627522b0d34ee8712bcfb05edfe7ff157ec035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68627522b0d34ee8712bcfb05edfe7ff157ec035", "html_url": "https://github.com/rust-lang/rust/commit/68627522b0d34ee8712bcfb05edfe7ff157ec035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68627522b0d34ee8712bcfb05edfe7ff157ec035/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78b38c84c620a3019473463a5ff9120941604ec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/78b38c84c620a3019473463a5ff9120941604ec2", "html_url": "https://github.com/rust-lang/rust/commit/78b38c84c620a3019473463a5ff9120941604ec2"}, {"sha": "41bca58100260323e54ff83e5bc74dd920beabcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/41bca58100260323e54ff83e5bc74dd920beabcd", "html_url": "https://github.com/rust-lang/rust/commit/41bca58100260323e54ff83e5bc74dd920beabcd"}], "stats": {"total": 613, "additions": 507, "deletions": 106}, "files": [{"sha": "4cfa5a0b879164eba7ab7a6e05feef03835b41d6", "filename": "src/expr.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -12,14 +12,14 @@ use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n use string::{StringFormat, rewrite_string};\n use StructLitStyle;\n-use utils::{span_after, make_indent};\n+use utils::{span_after, make_indent, extra_offset};\n use visitor::FmtVisitor;\n use config::BlockIndentStyle;\n use comment::{FindUncommented, rewrite_comment};\n+use types::rewrite_path;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{Pos, Span, BytePos, mk_sp};\n-use syntax::print::pprust;\n use syntax::visit::Visitor;\n \n impl Rewrite for ast::Expr {\n@@ -99,6 +99,9 @@ impl Rewrite for ast::Expr {\n                               width,\n                               offset)\n             }\n+            ast::Expr_::ExprPath(ref qself, ref path) => {\n+                rewrite_path(context, qself.as_ref(), path, width, offset)\n+            }\n             _ => context.codemap.span_to_snippet(self.span).ok()\n         }\n     }\n@@ -320,11 +323,7 @@ fn rewrite_pat_expr(context: &RewriteContext,\n     };\n \n     // Consider only the last line of the pat string.\n-    let extra_offset = match result.rfind('\\n') {\n-        // 1 for newline character\n-        Some(idx) => result.len() - idx - 1 - offset,\n-        None => result.len()\n-    };\n+    let extra_offset = extra_offset(&result, offset);\n \n     // The expression may (partionally) fit on the current line.\n     if width > extra_offset + 1 {\n@@ -391,16 +390,19 @@ fn rewrite_call(context: &RewriteContext,\n     debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n \n     // TODO using byte lens instead of char lens (and probably all over the place too)\n-    let callee_str = try_opt!(callee.rewrite(context, width, offset));\n+    // 2 is for parens\n+    let max_callee_width = try_opt!(width.checked_sub(2));\n+    let callee_str = try_opt!(callee.rewrite(context, max_callee_width, offset));\n     debug!(\"rewrite_call, callee_str: `{}`\", callee_str);\n \n     if args.len() == 0 {\n         return Some(format!(\"{}()\", callee_str));\n     }\n \n+    let extra_offset = extra_offset(&callee_str, offset);\n     // 2 is for parens.\n-    let remaining_width = try_opt!(width.checked_sub(callee_str.len() + 2));\n-    let offset = callee_str.len() + 1 + offset;\n+    let remaining_width = try_opt!(width.checked_sub(extra_offset + 2));\n+    let offset = offset + extra_offset + 1;\n     let block_indent = expr_block_indent(context, offset);\n     let inner_context = &RewriteContext { block_indent: block_indent, ..*context };\n \n@@ -425,7 +427,7 @@ fn rewrite_call(context: &RewriteContext,\n         indent: offset,\n         h_width: remaining_width,\n         v_width: remaining_width,\n-        ends_with_newline: true,\n+        ends_with_newline: false,\n     };\n \n     Some(format!(\"{}({})\", callee_str, write_list(&items, &fmt)))\n@@ -468,7 +470,9 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         Base(&'a ast::Expr),\n     }\n \n-    let path_str = pprust::path_to_string(path);\n+    // 2 = \" {\".len()\n+    let path_str = try_opt!(path.rewrite(context, width - 2, offset));\n+\n     // Foo { a: Foo } - indent is +3, width is -5.\n     let h_budget = width.checked_sub(path_str.len() + 5).unwrap_or(0);\n     let (indent, v_budget) = match context.config.struct_lit_style {\n@@ -537,7 +541,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         indent: indent,\n         h_width: h_budget,\n         v_width: v_budget,\n-        ends_with_newline: true,\n+        ends_with_newline: false,\n     };\n     let fields_str = write_list(&items, &fmt);\n \n@@ -601,7 +605,7 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n         indent: indent,\n         h_width: width - 2,\n         v_width: width - 2,\n-        ends_with_newline: true,\n+        ends_with_newline: false,\n     };\n \n     Some(format!(\"({})\", write_list(&items, &fmt)))"}, {"sha": "e3629410c6cd3cc9a03417bcf8cb841430382bea", "filename": "src/imports.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -11,11 +11,9 @@\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n use utils::span_after;\n use rewrite::{Rewrite, RewriteContext};\n-use config::Config;\n \n use syntax::ast;\n-use syntax::print::pprust;\n-use syntax::codemap::{CodeMap, Span};\n+use syntax::codemap::Span;\n \n // TODO (some day) remove unused imports, expand globs, compress many single imports into a list import\n \n@@ -29,20 +27,21 @@ impl Rewrite for ast::ViewPath {\n                                       path,\n                                       path_list,\n                                       self.span,\n-                                      context.codemap,\n-                                      context.config).unwrap_or(\"\".to_owned()))\n+                                      context).unwrap_or(\"\".to_owned()))\n             }\n             ast::ViewPath_::ViewPathGlob(_) => {\n                 // FIXME convert to list?\n                 None\n             }\n             ast::ViewPath_::ViewPathSimple(ident, ref path) => {\n-                let path_str = pprust::path_to_string(path);\n+                let ident_str = ident.to_string();\n+                // 4 = \" as \".len()\n+                let path_str = try_opt!(path.rewrite(context, width - ident_str.len() - 4, offset));\n \n                 Some(if path.segments.last().unwrap().identifier == ident {\n                          path_str\n                      } else {\n-                         format!(\"{} as {}\", path_str, ident)\n+                         format!(\"{} as {}\", path_str, ident_str)\n                      })\n             }\n         }\n@@ -74,10 +73,10 @@ pub fn rewrite_use_list(width: usize,\n                         path: &ast::Path,\n                         path_list: &[ast::PathListItem],\n                         span: Span,\n-                        codemap: &CodeMap,\n-                        config: &Config)\n+                        context: &RewriteContext)\n                         -> Option<String> {\n-    let path_str = pprust::path_to_string(path);\n+    // 1 = {}\n+    let path_str = try_opt!(path.rewrite(context, width - 1, offset));\n \n     match path_list.len() {\n         0 => return None,\n@@ -106,10 +105,10 @@ pub fn rewrite_use_list(width: usize,\n         // available\n         // (loose 1 column (\";\"))\n         v_width: remaining_width,\n-        ends_with_newline: true,\n+        ends_with_newline: false,\n     };\n \n-    let mut items = itemize_list(codemap,\n+    let mut items = itemize_list(context.codemap,\n                                  vec![ListItem::from_str(\"\")], /* Dummy value, explanation\n                                                                 * below */\n                                  path_list.iter(),\n@@ -125,7 +124,7 @@ pub fn rewrite_use_list(width: usize,\n                                          \"self\".to_owned()\n                                      }\n                                  },\n-                                 span_after(span, \"{\", codemap),\n+                                 span_after(span, \"{\", context.codemap),\n                                  span.hi);\n \n     // We prefixed the item list with a dummy value so that we can\n@@ -140,7 +139,7 @@ pub fn rewrite_use_list(width: usize,\n         1\n     };\n \n-    if config.reorder_imports {\n+    if context.config.reorder_imports {\n         items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n     }\n "}, {"sha": "bbe80bf1231ad2c24cca027c0495600b33353952", "filename": "src/items.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -16,6 +16,8 @@ use utils::{format_mutability, format_visibility, make_indent, contains_skip, sp\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n use comment::FindUncommented;\n use visitor::FmtVisitor;\n+use rewrite::Rewrite;\n+use config::Config;\n \n use syntax::{ast, abi};\n use syntax::codemap::{self, Span, BytePos};\n@@ -215,6 +217,7 @@ impl<'a> FmtVisitor<'a> {\n \n         // Where clause.\n         result.push_str(&self.rewrite_where_clause(where_clause,\n+                                                   self.config,\n                                                    indent,\n                                                    span.hi));\n \n@@ -281,7 +284,7 @@ impl<'a> FmtVisitor<'a> {\n             indent: arg_indent,\n             h_width: one_line_budget,\n             v_width: multi_line_budget,\n-            ends_with_newline: true,\n+            ends_with_newline: false,\n         };\n \n         write_list(&arg_items, &fmt)\n@@ -429,7 +432,7 @@ impl<'a> FmtVisitor<'a> {\n                         indent: indent,\n                         h_width: budget,\n                         v_width: budget,\n-                        ends_with_newline: false,\n+                        ends_with_newline: true,\n                     };\n                     result.push_str(&write_list(&items, &fmt));\n                     result.push(')');\n@@ -557,7 +560,7 @@ impl<'a> FmtVisitor<'a> {\n             indent: offset + self.config.tab_spaces,\n             h_width: self.config.max_width,\n             v_width: budget,\n-            ends_with_newline: false,\n+            ends_with_newline: true,\n         };\n \n         result.push_str(&write_list(&items, &fmt));\n@@ -608,6 +611,7 @@ impl<'a> FmtVisitor<'a> {\n \n         if generics.where_clause.predicates.len() > 0 || result.contains('\\n') {\n             result.push_str(&self.rewrite_where_clause(&generics.where_clause,\n+                                                       self.config,\n                                                        self.block_indent,\n                                                        span.hi));\n             result.push_str(&make_indent(self.block_indent));\n@@ -664,8 +668,15 @@ impl<'a> FmtVisitor<'a> {\n         result.push('<');\n \n         // Strings for the generics.\n-        let lt_strs = lifetimes.iter().map(|l| self.rewrite_lifetime_def(l));\n-        let ty_strs = tys.iter().map(|ty| self.rewrite_ty_param(ty));\n+        // 1 = <\n+        let context = self.get_context();\n+        // FIXME: don't unwrap\n+        let lt_strs = lifetimes.iter().map(|lt| {\n+            lt.rewrite(&context, budget, offset + 1).unwrap()\n+        });\n+        let ty_strs = tys.iter().map(|ty_param| {\n+            ty_param.rewrite(&context, budget, offset + 1).unwrap()\n+        });\n \n         // Extract comments between generics.\n         let lt_spans = lifetimes.iter().map(|l| {\n@@ -700,7 +711,7 @@ impl<'a> FmtVisitor<'a> {\n             indent: offset + 1,\n             h_width: budget,\n             v_width: budget,\n-            ends_with_newline: true,\n+            ends_with_newline: false,\n         };\n         result.push_str(&write_list(&items, &fmt));\n \n@@ -711,6 +722,7 @@ impl<'a> FmtVisitor<'a> {\n \n     fn rewrite_where_clause(&self,\n                             where_clause: &ast::WhereClause,\n+                            config: &Config,\n                             indent: usize,\n                             span_end: BytePos)\n                             -> String {\n@@ -720,9 +732,13 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         result.push('\\n');\n-        result.push_str(&make_indent(indent + 4));\n+        result.push_str(&make_indent(indent + config.tab_spaces));\n         result.push_str(\"where \");\n \n+        let context = self.get_context();\n+        // 6 = \"where \".len()\n+        let offset = indent + config.tab_spaces + 6;\n+        let budget = self.config.ideal_width + self.config.leeway - offset;\n         let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n         let items = itemize_list(self.codemap,\n                                  Vec::new(),\n@@ -731,19 +747,21 @@ impl<'a> FmtVisitor<'a> {\n                                  \"{\",\n                                  |pred| span_for_where_pred(pred).lo,\n                                  |pred| span_for_where_pred(pred).hi,\n-                                 |pred| self.rewrite_pred(pred),\n+                                 // FIXME: we should handle failure better\n+                                 // this will be taken care of when write_list\n+                                 // takes Rewrite object: see issue #133\n+                                 |pred| pred.rewrite(&context, budget, offset).unwrap(),\n                                  span_start,\n                                  span_end);\n \n-        let budget = self.config.ideal_width + self.config.leeway - indent - 10;\n         let fmt = ListFormatting {\n             tactic: ListTactic::Vertical,\n             separator: \",\",\n             trailing_separator: SeparatorTactic::Never,\n-            indent: indent + 10,\n+            indent: offset,\n             h_width: budget,\n             v_width: budget,\n-            ends_with_newline: true,\n+            ends_with_newline: false,\n         };\n         result.push_str(&write_list(&items, &fmt));\n "}, {"sha": "6398c19c9ea47d8753ba24e003b51a4dcd0a9f1b", "filename": "src/lists.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -211,7 +211,7 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> St\n             let offset = formatting.indent + item_width + 1;\n             let comment = item.post_comment.as_ref().unwrap();\n             // Use block-style only for the last item or multiline comments.\n-            let block_style = formatting.ends_with_newline && last ||\n+            let block_style = !formatting.ends_with_newline && last ||\n                               comment.trim().contains('\\n') || comment.trim().len() > width;\n \n             let formatted_comment = rewrite_comment(comment, block_style, width, offset);"}, {"sha": "4917d6ac3c92375cef5de752cecf044050fa31e6", "filename": "src/types.rs", "status": "modified", "additions": 350, "deletions": 46, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -8,99 +8,403 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use visitor::FmtVisitor;\n+use std::fmt;\n \n use syntax::ast;\n use syntax::print::pprust;\n+use syntax::codemap::{self, Span, BytePos, CodeMap};\n \n-impl<'a> FmtVisitor<'a> {\n-    pub fn rewrite_pred(&self, predicate: &ast::WherePredicate) -> String {\n-        // TODO dead spans\n+use lists::{itemize_list, write_list, ListTactic, SeparatorTactic, ListFormatting};\n+use rewrite::{Rewrite, RewriteContext};\n+use utils::{extra_offset, span_after};\n+\n+impl Rewrite for ast::Path {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        rewrite_path(context, None, self, width, offset)\n+    }\n+}\n+\n+// Does not wrap on simple segments.\n+pub fn rewrite_path(context: &RewriteContext,\n+                    qself: Option<&ast::QSelf>,\n+                    path: &ast::Path,\n+                    width: usize,\n+                    offset: usize)\n+                    -> Option<String> {\n+    let skip_count = qself.map(|x| x.position).unwrap_or(0);\n+\n+    let mut result = if path.global {\n+        \"::\".to_owned()\n+    } else {\n+        String::new()\n+    };\n+\n+    let mut span_lo = path.span.lo;\n+\n+    if let Some(ref qself) = qself {\n+        result.push('<');\n+        result.push_str(&pprust::ty_to_string(&qself.ty));\n+        result.push_str(\" as \");\n+\n+        let extra_offset = extra_offset(&result, offset);\n+        // 3 = \">::\".len()\n+        let budget = try_opt!(width.checked_sub(extra_offset)) - 3;\n+\n+        result = try_opt!(rewrite_path_segments(result,\n+                                                path.segments.iter().take(skip_count),\n+                                                span_lo,\n+                                                path.span.hi,\n+                                                context,\n+                                                budget,\n+                                                offset + extra_offset));\n+\n+        result.push_str(\">::\");\n+        span_lo = qself.ty.span.hi + BytePos(1);\n+    }\n+\n+    let extra_offset = extra_offset(&result, offset);\n+    let budget = try_opt!(width.checked_sub(extra_offset));\n+    rewrite_path_segments(result,\n+                          path.segments.iter().skip(skip_count),\n+                          span_lo,\n+                          path.span.hi,\n+                          context,\n+                          budget,\n+                          offset + extra_offset)\n+}\n+\n+fn rewrite_path_segments<'a, I>(mut buffer: String,\n+                                iter: I,\n+                                mut span_lo: BytePos,\n+                                span_hi: BytePos,\n+                                context: &RewriteContext,\n+                                width: usize,\n+                                offset: usize)\n+                                -> Option<String>\n+    where I: Iterator<Item = &'a ast::PathSegment>\n+{\n+    let mut first = true;\n+\n+    for segment in iter {\n+        let extra_offset = extra_offset(&buffer, offset);\n+        let remaining_width = try_opt!(width.checked_sub(extra_offset));\n+        let new_offset = offset + extra_offset;\n+        let segment_string = try_opt!(rewrite_segment(segment,\n+                                                      &mut span_lo,\n+                                                      span_hi,\n+                                                      context,\n+                                                      remaining_width,\n+                                                      new_offset));\n+\n+        if first {\n+            first = false;\n+        } else {\n+            buffer.push_str(\"::\");\n+        }\n+\n+        buffer.push_str(&segment_string);\n+    }\n+\n+    Some(buffer)\n+}\n+\n+enum SegmentParam<'a> {\n+    LifeTime(&'a ast::Lifetime),\n+    Type(&'a ast::Ty),\n+    Binding(&'a ast::TypeBinding),\n+}\n+\n+impl<'a> SegmentParam<'a> {\n+    fn get_span(&self) -> Span {\n+        match *self {\n+            SegmentParam::LifeTime(ref lt) => lt.span,\n+            SegmentParam::Type(ref ty) => ty.span,\n+            SegmentParam::Binding(ref binding) => binding.span,\n+        }\n+    }\n+}\n+\n+impl<'a> fmt::Display for SegmentParam<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            SegmentParam::LifeTime(ref lt) => {\n+                write!(f, \"{}\", pprust::lifetime_to_string(lt))\n+            }\n+            SegmentParam::Type(ref ty) => {\n+                write!(f, \"{}\", pprust::ty_to_string(ty))\n+            }\n+            SegmentParam::Binding(ref binding) => {\n+                write!(f, \"{} = {}\", binding.ident, pprust::ty_to_string(&*binding.ty))\n+            }\n+        }\n+    }\n+}\n+\n+// This is a dirty hack to determine if we're in an expression or not. Generic\n+// parameters are passed differently in expressions and items. We'd declare\n+// a struct with Foo<A, B>, but call its functions with Foo::<A, B>::f().\n+// We'd really rather not do this, but there doesn't seem to be an alternative\n+// at this point.\n+// FIXME: fails with spans containing comments with the characters < or :\n+fn get_path_separator(codemap: &CodeMap,\n+                      path_start: BytePos,\n+                      segment_start: BytePos)\n+                      -> &'static str {\n+    let span = codemap::mk_sp(path_start, segment_start);\n+    let snippet = codemap.span_to_snippet(span).unwrap();\n+\n+    for c in snippet.chars().rev() {\n+        if c == ':' {\n+            return \"::\"\n+        } else if c.is_whitespace() || c == '<' {\n+            continue;\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    unreachable!();\n+}\n+\n+// Formats a path segment. There are some hacks involved to correctly determine\n+// the segment's associated span since it's not part of the AST.\n+//\n+// The span_lo is assumed to be greater than the end of any previous segment's\n+// parameters and lesser or equal than the start of current segment.\n+//\n+// span_hi is assumed equal to the end of the entire path.\n+//\n+// When the segment contains a positive number of parameters, we update span_lo\n+// so that invariants described above will hold for the next segment.\n+fn rewrite_segment(segment: &ast::PathSegment,\n+                   span_lo: &mut BytePos,\n+                   span_hi: BytePos,\n+                   context: &RewriteContext,\n+                   width: usize,\n+                   offset: usize)\n+                   -> Option<String> {\n+    let ident_len = segment.identifier.to_string().len();\n+    let width = try_opt!(width.checked_sub(ident_len));\n+    let offset = offset + ident_len;\n+\n+    let params = match segment.parameters {\n+        ast::PathParameters::AngleBracketedParameters(ref data) if data.lifetimes.len() > 0 ||\n+                                                                   data.types.len() > 0 ||\n+                                                                   data.bindings.len() > 0 => {\n+            let param_list = data.lifetimes.iter()\n+                                           .map(SegmentParam::LifeTime)\n+                                           .chain(data.types.iter()\n+                                                      .map(|x| SegmentParam::Type(&*x)))\n+                                           .chain(data.bindings.iter()\n+                                                      .map(|x| SegmentParam::Binding(&*x)))\n+                                           .collect::<Vec<_>>();\n+\n+            let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n+            let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi), \"<\", context.codemap);\n+            let separator = get_path_separator(context.codemap, *span_lo, list_lo);\n+\n+            let items = itemize_list(context.codemap,\n+                                     Vec::new(),\n+                                     param_list.into_iter(),\n+                                     \",\",\n+                                     \">\",\n+                                     |param| param.get_span().lo,\n+                                     |param| param.get_span().hi,\n+                                     ToString::to_string,\n+                                     list_lo,\n+                                     span_hi);\n+\n+            // 1 for <\n+            let extra_offset = 1 + separator.len();\n+            // 1 for >\n+            let list_width = try_opt!(width.checked_sub(extra_offset + 1));\n+\n+            let fmt = ListFormatting {\n+                tactic: ListTactic::HorizontalVertical,\n+                separator: \",\",\n+                trailing_separator: SeparatorTactic::Never,\n+                indent: offset + extra_offset,\n+                h_width: list_width,\n+                v_width: list_width,\n+                ends_with_newline: false,\n+            };\n+\n+            // update pos\n+            *span_lo = next_span_lo;\n+\n+            format!(\"{}<{}>\", separator, write_list(&items, &fmt))\n+        }\n+        ast::PathParameters::ParenthesizedParameters(ref data) => {\n+            let output = match data.output {\n+                Some(ref ty) => format!(\" -> {}\", pprust::ty_to_string(&*ty)),\n+                None => String::new()\n+            };\n+\n+            let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi), \"(\", context.codemap);\n+            let items = itemize_list(context.codemap,\n+                                     Vec::new(),\n+                                     data.inputs.iter(),\n+                                     \",\",\n+                                     \")\",\n+                                     |ty| ty.span.lo,\n+                                     |ty| ty.span.hi,\n+                                     |ty| pprust::ty_to_string(ty),\n+                                     list_lo,\n+                                     span_hi);\n+\n+            // 2 for ()\n+            let budget = try_opt!(width.checked_sub(output.len() + 2));\n+\n+            let fmt = ListFormatting {\n+                tactic: ListTactic::HorizontalVertical,\n+                separator: \",\",\n+                trailing_separator: SeparatorTactic::Never,\n+                // 1 for (\n+                indent: offset + 1,\n+                h_width: budget,\n+                v_width: budget,\n+                ends_with_newline: false,\n+            };\n+\n+            // update pos\n+            *span_lo = data.inputs.last().unwrap().span.hi + BytePos(1);\n+\n+            format!(\"({}){}\", write_list(&items, &fmt), output)\n+        }\n+        _ => String::new()\n+    };\n+\n+    Some(format!(\"{}{}\", segment.identifier, params))\n+}\n+\n+impl Rewrite for ast::WherePredicate {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        // TODO dead spans?\n         // TODO assumes we'll always fit on one line...\n-        match predicate {\n+        Some(match self {\n             &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n                                                                           ref bounded_ty,\n                                                                           ref bounds,\n                                                                           ..}) => {\n                 if bound_lifetimes.len() > 0 {\n-                    format!(\"for<{}> {}: {}\",\n-                            bound_lifetimes.iter().map(|l| self.rewrite_lifetime_def(l))\n-                                .collect::<Vec<_>>().join(\", \"),\n-                            pprust::ty_to_string(bounded_ty),\n-                            bounds.iter().map(|b| self.rewrite_ty_bound(b))\n-                                .collect::<Vec<_>>().join(\" + \"))\n+                    let lifetime_str = bound_lifetimes.iter().map(|lt| {\n+                                           lt.rewrite(context, width, offset).unwrap()\n+                                       }).collect::<Vec<_>>().join(\", \");\n+                    let type_str = pprust::ty_to_string(bounded_ty);\n+                    // 8 = \"for<> : \".len()\n+                    let used_width = lifetime_str.len() + type_str.len() + 8;\n+                    let bounds_str = bounds.iter().map(|ty_bound| {\n+                                         ty_bound.rewrite(context,\n+                                                          width - used_width,\n+                                                          offset + used_width)\n+                                                 .unwrap()\n+                                     }).collect::<Vec<_>>().join(\" + \");\n \n+                    format!(\"for<{}> {}: {}\", lifetime_str, type_str, bounds_str)\n                 } else {\n-                    format!(\"{}: {}\",\n-                            pprust::ty_to_string(bounded_ty),\n-                            bounds.iter().map(|b| self.rewrite_ty_bound(b))\n-                                .collect::<Vec<_>>().join(\" + \"))\n+                    let type_str = pprust::ty_to_string(bounded_ty);\n+                    // 2 = \": \".len()\n+                    let used_width = type_str.len() + 2;\n+                    let bounds_str = bounds.iter().map(|ty_bound| {\n+                                         ty_bound.rewrite(context,\n+                                                          width - used_width,\n+                                                          offset + used_width)\n+                                                 .unwrap()\n+                                     }).collect::<Vec<_>>().join(\" + \");\n+\n+                    format!(\"{}: {}\", type_str, bounds_str)\n                 }\n             }\n             &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n                                                                             ref bounds,\n                                                                             ..}) => {\n                 format!(\"{}: {}\",\n                         pprust::lifetime_to_string(lifetime),\n-                        bounds.iter().map(|l| pprust::lifetime_to_string(l))\n-                            .collect::<Vec<_>>().join(\" + \"))\n+                        bounds.iter().map(pprust::lifetime_to_string)\n+                              .collect::<Vec<_>>().join(\" + \"))\n             }\n             &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                format!(\"{} = {}\", pprust::path_to_string(path), pprust::ty_to_string(ty))\n+                let ty_str = pprust::ty_to_string(ty);\n+                // 3 = \" = \".len()\n+                let used_width = 3 + ty_str.len();\n+                let path_str = try_opt!(path.rewrite(context,\n+                                                     width - used_width,\n+                                                     offset + used_width));\n+                format!(\"{} = {}\", path_str, ty_str)\n             }\n-        }\n+        })\n     }\n+}\n \n-    pub fn rewrite_lifetime_def(&self, lifetime: &ast::LifetimeDef) -> String {\n-        if lifetime.bounds.len() == 0 {\n-            return pprust::lifetime_to_string(&lifetime.lifetime);\n+impl Rewrite for ast::LifetimeDef {\n+    fn rewrite(&self, _: &RewriteContext, _: usize, _: usize) -> Option<String> {\n+        if self.bounds.len() == 0 {\n+            Some(pprust::lifetime_to_string(&self.lifetime))\n+        } else {\n+            Some(format!(\"{}: {}\",\n+                         pprust::lifetime_to_string(&self.lifetime),\n+                         self.bounds.iter().map(pprust::lifetime_to_string)\n+                                    .collect::<Vec<_>>().join(\" + \")))\n         }\n-\n-        format!(\"{}: {}\",\n-                pprust::lifetime_to_string(&lifetime.lifetime),\n-                lifetime.bounds.iter().map(|l| pprust::lifetime_to_string(l))\n-                    .collect::<Vec<_>>().join(\" + \"))\n     }\n+}\n \n-    pub fn rewrite_ty_bound(&self, bound: &ast::TyParamBound) -> String {\n-        match *bound {\n+impl Rewrite for ast::TyParamBound {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        match *self {\n             ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::None) => {\n-                self.rewrite_poly_trait_ref(tref)\n+                tref.rewrite(context, width, offset)\n             }\n             ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::Maybe) => {\n-                format!(\"?{}\", self.rewrite_poly_trait_ref(tref))\n+                Some(format!(\"?{}\", try_opt!(tref.rewrite(context, width - 1, offset + 1))))\n             }\n             ast::TyParamBound::RegionTyParamBound(ref l) => {\n-                pprust::lifetime_to_string(l)\n+                Some(pprust::lifetime_to_string(l))\n             }\n         }\n     }\n+}\n \n-    pub fn rewrite_ty_param(&self, ty_param: &ast::TyParam) -> String {\n+// FIXME: this assumes everything will fit on one line\n+impl Rewrite for ast::TyParam {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         let mut result = String::with_capacity(128);\n-        result.push_str(&ty_param.ident.to_string());\n-        if ty_param.bounds.len() > 0 {\n+        result.push_str(&self.ident.to_string());\n+        if self.bounds.len() > 0 {\n             result.push_str(\": \");\n-            result.push_str(&ty_param.bounds.iter().map(|b| self.rewrite_ty_bound(b))\n-                                .collect::<Vec<_>>().join(\" + \"));\n+\n+            let bounds = self.bounds.iter().map(|ty_bound| {\n+                ty_bound.rewrite(context, width, offset).unwrap()\n+            }).collect::<Vec<_>>().join(\" + \");\n+\n+            result.push_str(&bounds);\n         }\n-        if let Some(ref def) = ty_param.default {\n+        if let Some(ref def) = self.default {\n             result.push_str(\" = \");\n             result.push_str(&pprust::ty_to_string(&def));\n         }\n \n-        result\n+        Some(result)\n     }\n+}\n \n-    fn rewrite_poly_trait_ref(&self, t: &ast::PolyTraitRef) -> String {\n-        if t.bound_lifetimes.len() > 0 {\n-            format!(\"for<{}> {}\",\n-                    t.bound_lifetimes.iter().map(|l| self.rewrite_lifetime_def(l))\n-                        .collect::<Vec<_>>().join(\", \"),\n-                    pprust::path_to_string(&t.trait_ref.path))\n+// FIXME: this assumes everything will fit on one line\n+impl Rewrite for ast::PolyTraitRef {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        if self.bound_lifetimes.len() > 0 {\n+            let lifetime_str = self.bound_lifetimes.iter().map(|lt| {\n+                lt.rewrite(context, width, offset).unwrap()\n+            }).collect::<Vec<_>>().join(\", \");\n+            // 6 is \"for<> \".len()\n+            let extra_offset = lifetime_str.len() + 6;\n+            let max_path_width = try_opt!(width.checked_sub(extra_offset));\n+            let path_str = try_opt!(self.trait_ref.path.rewrite(context,\n+                                                                max_path_width,\n+                                                                offset + extra_offset));\n \n+            Some(format!(\"for<{}> {}\", lifetime_str, path_str))\n         } else {\n-            pprust::path_to_string(&t.trait_ref.path)\n+            self.trait_ref.path.rewrite(context, width, offset)\n         }\n     }\n }"}, {"sha": "59f85b3ad2724e757684dba8f1475465c7bbe156", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -15,6 +15,16 @@ use comment::FindUncommented;\n \n use SKIP_ANNOTATION;\n \n+// Computes the length of a string's last line, minus offset.\n+#[inline]\n+pub fn extra_offset(text: &str, offset: usize) -> usize {\n+    match text.rfind('\\n') {\n+        // 1 for newline character\n+        Some(idx) => text.len() - idx - 1 - offset,\n+        None => text.len()\n+    }\n+}\n+\n #[inline]\n pub fn span_after(original: Span, needle: &str, codemap: &CodeMap) -> BytePos {\n     let snippet = codemap.span_to_snippet(original).unwrap();"}, {"sha": "e107a32abf846573e072de0f460ca15f9ce4d4ff", "filename": "src/visitor.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -33,13 +33,9 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                self.codemap.lookup_char_pos(ex.span.lo),\n                self.codemap.lookup_char_pos(ex.span.hi));\n         self.format_missing(ex.span.lo);\n+\n         let offset = self.buffer.cur_offset();\n-        let context = RewriteContext {\n-            codemap: self.codemap,\n-            config: self.config,\n-            block_indent: self.block_indent,\n-        };\n-        let rewrite = ex.rewrite(&context, self.config.max_width - offset, offset);\n+        let rewrite = ex.rewrite(&self.get_context(), self.config.max_width - offset, offset);\n \n         if let Some(new_str) = rewrite {\n             self.buffer.push_str(&new_str);\n@@ -372,4 +368,12 @@ impl<'a> FmtVisitor<'a> {\n             }\n         }\n     }\n+\n+    pub fn get_context(&self) -> RewriteContext {\n+        RewriteContext {\n+            codemap: self.codemap,\n+            config: self.config,\n+            block_indent: self.block_indent,\n+        }\n+    }\n }"}, {"sha": "b5682d36cfa70d81b35ae54f3b3daffe4c8f266d", "filename": "tests/source/fn-simple.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Fsource%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Fsource%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ffn-simple.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -9,3 +9,11 @@ y: World\n ) {\n         simple(/* does this preserve comments now? */ 42, NoWay)\n }\n+\n+fn generic<T>(arg: T) -> &SomeType\n+    where T: Fn(// First arg\n+        A,\n+        // Second argument\n+        B, C, D, /* pre comment */ E /* last comment */) -> &SomeType {\n+    arg(a, b, c, d, e)    \n+}"}, {"sha": "4225aa9dab340d23fd0956e2d5293d6fba79f3a4", "filename": "tests/source/paths.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Fsource%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Fsource%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpaths.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -0,0 +1,22 @@\n+\n+fn main() {\n+    // FIXME(#133): the list rewrite should fail and force a different format\n+   let constellation_chan = Constellation::<layout::layout_task::LayoutTask,  script::script_task::ScriptTask> ::start(\n+     compositor_proxy,\n+     resource_task,\n+     image_cache_task,font_cache_task,\n+     time_profiler_chan,\n+     mem_profiler_chan,\n+     devtools_chan,\n+     storage_task,\n+     supports_clipboard\n+    );\n+\n+     Quux::<ParamOne,   // Comment 1\n+            ParamTwo,   // Comment 2\n+                    >::some_func();\n+\n+     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA::BBBBBBBBBBBBBBBBBBBBBBBBBBBB::CCCCCCCCCCCCCCCCCCCCCC::quux();\n+}\n+\n+fn op(foo: Bar, key : &[u8], upd : Fn(Option<&memcache::Item> , Baz  ) -> Result) -> MapResult {}"}, {"sha": "225d3a1698506bef96754667d0d3e5279c8e45a5", "filename": "tests/source/struct_lits.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Fsource%2Fstruct_lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Fsource%2Fstruct_lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstruct_lits.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -48,3 +48,8 @@ fn matcher() {\n     },\n     };\n }\n+\n+fn issue177() {\n+    struct Foo<T> { memb: T }\n+    let foo = Foo::<i64> { memb: 10 };\n+}"}, {"sha": "dbb4f82924a0d37c27bed01c4b7d024898b81001", "filename": "tests/target/fn-simple.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Ftarget%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Ftarget%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn-simple.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -14,3 +14,16 @@ fn weird_comment(// /*/ double level */ comment\n            42,\n            NoWay)\n }\n+\n+fn generic<T>(arg: T) -> &SomeType\n+    where T: Fn(// First arg\n+                A,\n+                // Second argument\n+                B,\n+                C,\n+                D,\n+                // pre comment\n+                E /* last comment */) -> &SomeType\n+{\n+    arg(a, b, c, d, e)\n+}"}, {"sha": "bc05efa53513f7655df2462a309918d8df3d0359", "filename": "tests/target/fn.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Ftarget%2Ffn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Ftarget%2Ffn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -79,17 +79,3 @@ fn main() {\n     let _ = function(move || 5);\n     let _ = move || 42;\n }\n-\n-fn servo() {\n-    let constellation_chan = Constellation::<layout::layout_task::LayoutTask,\n-    script::script_task::ScriptTask>::start(\n-        compositor_proxy,\n-        resource_task,\n-        image_cache_task,\n-        font_cache_task,\n-        time_profiler_chan,\n-        mem_profiler_chan,\n-        devtools_chan,\n-        storage_task,\n-        supports_clipboard);\n-}"}, {"sha": "c358104e1fa76b9cbbca349e0cd3148cf7c6f55b", "filename": "tests/target/paths.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Ftarget%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Ftarget%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpaths.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -0,0 +1,21 @@\n+\n+fn main() {\n+    // FIXME(#133): the list rewrite should fail and force a different format\n+    let constellation_chan = Constellation::<layout::layout_task::LayoutTask,\n+                                             script::script_task::ScriptTask>::start(compositor_proxy,\n+                                                                                     resource_task,\n+                                                                                     image_cache_task,\n+                                                                                     font_cache_task,\n+                                                                                     time_profiler_chan,\n+                                                                                     mem_profiler_chan,\n+                                                                                     devtools_chan,\n+                                                                                     storage_task,\n+                                                                                     supports_clipboard);\n+\n+    Quux::<ParamOne /* Comment 1 */, ParamTwo /* Comment 2 */>::some_func();\n+\n+    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA::BBBBBBBBBBBBBBBBBBBBBBBBBBBB::CCCCCCCCCCCCCCCCCCCCCC::quux();\n+}\n+\n+fn op(foo: Bar, key: &[u8], upd: Fn(Option<&memcache::Item>, Baz) -> Result) -> MapResult {\n+}"}, {"sha": "cc2887fc51ff360184bb7b1c0675d296cea330a2", "filename": "tests/target/struct_lits.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Ftarget%2Fstruct_lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68627522b0d34ee8712bcfb05edfe7ff157ec035/tests%2Ftarget%2Fstruct_lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstruct_lits.rs?ref=68627522b0d34ee8712bcfb05edfe7ff157ec035", "patch": "@@ -64,3 +64,10 @@ fn matcher() {\n         },\n     };\n }\n+\n+fn issue177() {\n+    struct Foo<T> {\n+        memb: T,\n+    }\n+    let foo = Foo::<i64> { memb: 10 };\n+}"}]}