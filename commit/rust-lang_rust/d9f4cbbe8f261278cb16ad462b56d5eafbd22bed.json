{"sha": "d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "node_id": "C_kwDOAAsO6NoAKGQ5ZjRjYmJlOGYyNjEyNzhjYjE2YWQ0NjJiNTZkNWVhZmJkMjJiZWQ", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-03T10:44:47Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-03T10:44:47Z"}, "message": "Emit function bodies in expanding builtin derives", "tree": {"sha": "ed3a391bfef85cdea564280690012dac5b6e72ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed3a391bfef85cdea564280690012dac5b6e72ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "html_url": "https://github.com/rust-lang/rust/commit/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9811a3af5fb90834f42f4b35b4f531746af934ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/9811a3af5fb90834f42f4b35b4f531746af934ca", "html_url": "https://github.com/rust-lang/rust/commit/9811a3af5fb90834f42f4b35b4f531746af934ca"}], "stats": {"total": 1000, "additions": 962, "deletions": 38}, "files": [{"sha": "9ea688a8c1adc5ce3513ab3b898479b7290cfabf", "filename": "crates/hir-def/src/macro_expansion_tests/builtin_derive_macro.rs", "status": "modified", "additions": 288, "deletions": 4, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs?ref=d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "patch": "@@ -84,13 +84,33 @@ fn test_clone_expand() {\n         r#\"\n //- minicore: derive, clone\n #[derive(Clone)]\n-struct Foo<A, B>;\n+enum Command<A, B> {\n+    Move { x: A, y: B },\n+    Do(&'static str),\n+    Jump,\n+}\n \"#,\n         expect![[r#\"\n #[derive(Clone)]\n-struct Foo<A, B>;\n+enum Command<A, B> {\n+    Move { x: A, y: B },\n+    Do(&'static str),\n+    Jump,\n+}\n \n-impl <A: core::clone::Clone, B: core::clone::Clone, > core::clone::Clone for Foo<A, B, > where {}\"#]],\n+impl <A: core::clone::Clone, B: core::clone::Clone, > core::clone::Clone for Command<A, B, > where {\n+    fn clone(&self ) -> Self {\n+        match self {\n+            Command::Move {\n+                x: x, y: y,\n+            }\n+            =>Command::Move {\n+                x: x.clone(), y: y.clone(),\n+            }\n+            , Command::Do(f0, )=>Command::Do(f0.clone(), ), Command::Jump=>Command::Jump,\n+        }\n+    }\n+}\"#]],\n     );\n }\n \n@@ -106,6 +126,270 @@ struct Foo<const X: usize, T>(u32);\n #[derive(Clone)]\n struct Foo<const X: usize, T>(u32);\n \n-impl <const X: usize, T: core::clone::Clone, > core::clone::Clone for Foo<X, T, > where {}\"#]],\n+impl <const X: usize, T: core::clone::Clone, > core::clone::Clone for Foo<X, T, > where {\n+    fn clone(&self ) -> Self {\n+        match self {\n+            Foo(f0, )=>Foo(f0.clone(), ),\n+        }\n+    }\n+}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_default_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, default\n+#[derive(Default)]\n+struct Foo {\n+    field1: i32,\n+    field2: (),\n+}\n+#[derive(Default)]\n+enum Bar {\n+    Foo(u8),\n+    #[default]\n+    Bar,\n+}\n+\"#,\n+        expect![[r#\"\n+#[derive(Default)]\n+struct Foo {\n+    field1: i32,\n+    field2: (),\n+}\n+#[derive(Default)]\n+enum Bar {\n+    Foo(u8),\n+    #[default]\n+    Bar,\n+}\n+\n+impl < > core::default::Default for Foo< > where {\n+    fn default() -> Self {\n+        Foo {\n+            field1: core::default::Default::default(), field2: core::default::Default::default(),\n+        }\n+    }\n+}\n+impl < > core::default::Default for Bar< > where {\n+    fn default() -> Self {\n+        Bar::Bar\n+    }\n+}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_partial_eq_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, eq\n+#[derive(PartialEq, Eq)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\"#,\n+        expect![[r#\"\n+#[derive(PartialEq, Eq)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\n+impl < > core::cmp::PartialEq for Command< > where {\n+    fn eq(&self , other: &Self ) -> bool {\n+        match (self , other) {\n+            (Command::Move {\n+                x: x_self, y: y_self,\n+            }\n+            , Command::Move {\n+                x: x_other, y: y_other,\n+            }\n+            )=>x_self.eq(x_other) && y_self.eq(y_other), (Command::Do(f0_self, ), Command::Do(f0_other, ))=>f0_self.eq(f0_other), (Command::Jump, Command::Jump)=>true , _unused=>false\n+        }\n+    }\n+}\n+impl < > core::cmp::Eq for Command< > where {}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_partial_ord_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, ord\n+#[derive(PartialOrd, Ord)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\"#,\n+        expect![[r#\"\n+#[derive(PartialOrd, Ord)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\n+impl < > core::cmp::PartialOrd for Command< > where {\n+    fn partial_cmp(&self , other: &Self ) -> core::option::Option::Option<core::cmp::Ordering> {\n+        match core::intrinsics::discriminant_value(self ).partial_cmp(&core::intrinsics::discriminant_value(other)) {\n+            core::option::Option::Some(core::cmp::Ordering::Equal)=> {\n+                match (self , other) {\n+                    (Command::Move {\n+                        x: x_self, y: y_self,\n+                    }\n+                    , Command::Move {\n+                        x: x_other, y: y_other,\n+                    }\n+                    )=>match x_self.partial_cmp(&x_other) {\n+                        core::option::Option::Some(core::cmp::Ordering::Equal)=> {\n+                            match y_self.partial_cmp(&y_other) {\n+                                core::option::Option::Some(core::cmp::Ordering::Equal)=> {\n+                                    core::option::Option::Some(core::cmp::Ordering::Equal)\n+                                }\n+                                c=>return c,\n+                            }\n+                        }\n+                        c=>return c,\n+                    }\n+                    , (Command::Do(f0_self, ), Command::Do(f0_other, ))=>match f0_self.partial_cmp(&f0_other) {\n+                        core::option::Option::Some(core::cmp::Ordering::Equal)=> {\n+                            core::option::Option::Some(core::cmp::Ordering::Equal)\n+                        }\n+                        c=>return c,\n+                    }\n+                    , (Command::Jump, Command::Jump)=>core::option::Option::Some(core::cmp::Ordering::Equal), _unused=>core::option::Option::Some(core::cmp::Ordering::Equal)\n+                }\n+            }\n+            c=>return c,\n+        }\n+    }\n+}\n+impl < > core::cmp::Ord for Command< > where {\n+    fn cmp(&self , other: &Self ) -> core::cmp::Ordering {\n+        match core::intrinsics::discriminant_value(self ).cmp(&core::intrinsics::discriminant_value(other)) {\n+            core::cmp::Ordering::Equal=> {\n+                match (self , other) {\n+                    (Command::Move {\n+                        x: x_self, y: y_self,\n+                    }\n+                    , Command::Move {\n+                        x: x_other, y: y_other,\n+                    }\n+                    )=>match x_self.cmp(&x_other) {\n+                        core::cmp::Ordering::Equal=> {\n+                            match y_self.cmp(&y_other) {\n+                                core::cmp::Ordering::Equal=> {\n+                                    core::cmp::Ordering::Equal\n+                                }\n+                                c=>return c,\n+                            }\n+                        }\n+                        c=>return c,\n+                    }\n+                    , (Command::Do(f0_self, ), Command::Do(f0_other, ))=>match f0_self.cmp(&f0_other) {\n+                        core::cmp::Ordering::Equal=> {\n+                            core::cmp::Ordering::Equal\n+                        }\n+                        c=>return c,\n+                    }\n+                    , (Command::Jump, Command::Jump)=>core::cmp::Ordering::Equal, _unused=>core::cmp::Ordering::Equal\n+                }\n+            }\n+            c=>return c,\n+        }\n+    }\n+}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_hash_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, hash\n+use core::hash::Hash;\n+\n+#[derive(Hash)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\"#,\n+        expect![[r#\"\n+use core::hash::Hash;\n+\n+#[derive(Hash)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\n+impl < > core::hash::Hash for Command< > where {\n+    fn hash<H: core::hash::Hasher>(&self , state: &mut H) {\n+        core::mem::discriminant(self ).hash(state);\n+        match self {\n+            Command::Move {\n+                x: x, y: y,\n+            }\n+            => {\n+                x.hash(state);\n+                y.hash(state);\n+            }\n+            , Command::Do(f0, )=> {\n+                f0.hash(state);\n+            }\n+            , Command::Jump=> {}\n+            ,\n+        }\n+    }\n+}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_debug_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, fmt\n+use core::fmt::Debug;\n+\n+#[derive(Debug)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\"#,\n+        expect![[r#\"\n+use core::fmt::Debug;\n+\n+#[derive(Debug)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\n+impl < > core::fmt::Debug for Command< > where {\n+    fn fmt(&self , f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        match self {\n+            Command::Move {\n+                x: x, y: y,\n+            }\n+            =>f.debug_struct(\"Move\").field(\"x\", x).field(\"y\", y).finish(), Command::Do(f0, )=>f.debug_tuple(\"Do\").field(f0).finish(), Command::Jump=>f.write_str(\"Jump\"),\n+        }\n+    }\n+}\"#]],\n     );\n }"}, {"sha": "4ce71e9774b0d743bf7622a8e655ceb631d46408", "filename": "crates/hir-expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 532, "deletions": 22, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "patch": "@@ -1,12 +1,19 @@\n //! Builtin derives.\n \n+use ::tt::Ident;\n use base_db::{CrateOrigin, LangCrateOrigin};\n+use itertools::izip;\n+use mbe::TokenMap;\n use std::collections::HashSet;\n+use stdx::never;\n use tracing::debug;\n \n use crate::tt::{self, TokenId};\n use syntax::{\n-    ast::{self, AstNode, HasGenericParams, HasModuleItem, HasName, HasTypeBounds, PathType},\n+    ast::{\n+        self, AstNode, FieldList, HasAttrs, HasGenericParams, HasModuleItem, HasName,\n+        HasTypeBounds, PathType,\n+    },\n     match_ast,\n };\n \n@@ -59,8 +66,124 @@ pub fn find_builtin_derive(ident: &name::Name) -> Option<BuiltinDeriveExpander>\n     BuiltinDeriveExpander::find_by_name(ident)\n }\n \n+enum VariantShape {\n+    Struct(Vec<tt::Ident>),\n+    Tuple(usize),\n+    Unit,\n+}\n+\n+fn tuple_field_iterator(n: usize) -> impl Iterator<Item = tt::Ident> {\n+    (0..n).map(|x| Ident::new(format!(\"f{x}\"), tt::TokenId::unspecified()))\n+}\n+\n+impl VariantShape {\n+    fn as_pattern(&self, path: tt::Subtree) -> tt::Subtree {\n+        self.as_pattern_map(path, |x| quote!(#x))\n+    }\n+\n+    fn field_names(&self) -> Vec<tt::Ident> {\n+        match self {\n+            VariantShape::Struct(s) => s.clone(),\n+            VariantShape::Tuple(n) => tuple_field_iterator(*n).collect(),\n+            VariantShape::Unit => vec![],\n+        }\n+    }\n+\n+    fn as_pattern_map(\n+        &self,\n+        path: tt::Subtree,\n+        field_map: impl Fn(&tt::Ident) -> tt::Subtree,\n+    ) -> tt::Subtree {\n+        match self {\n+            VariantShape::Struct(fields) => {\n+                let fields = fields.iter().map(|x| {\n+                    let mapped = field_map(x);\n+                    quote! { #x : #mapped , }\n+                });\n+                quote! {\n+                    #path { ##fields }\n+                }\n+            }\n+            &VariantShape::Tuple(n) => {\n+                let fields = tuple_field_iterator(n).map(|x| {\n+                    let mapped = field_map(&x);\n+                    quote! {\n+                        #mapped ,\n+                    }\n+                });\n+                quote! {\n+                    #path ( ##fields )\n+                }\n+            }\n+            VariantShape::Unit => path,\n+        }\n+    }\n+\n+    fn from(value: Option<FieldList>, token_map: &TokenMap) -> Result<Self, ExpandError> {\n+        let r = match value {\n+            None => VariantShape::Unit,\n+            Some(FieldList::RecordFieldList(x)) => VariantShape::Struct(\n+                x.fields()\n+                    .map(|x| x.name())\n+                    .map(|x| name_to_token(token_map, x))\n+                    .collect::<Result<_, _>>()?,\n+            ),\n+            Some(FieldList::TupleFieldList(x)) => VariantShape::Tuple(x.fields().count()),\n+        };\n+        Ok(r)\n+    }\n+}\n+\n+enum AdtShape {\n+    Struct(VariantShape),\n+    Enum { variants: Vec<(tt::Ident, VariantShape)>, default_variant: Option<usize> },\n+    Union,\n+}\n+\n+impl AdtShape {\n+    fn as_pattern(&self, name: &tt::Ident) -> Vec<tt::Subtree> {\n+        self.as_pattern_map(name, |x| quote!(#x))\n+    }\n+\n+    fn field_names(&self) -> Vec<Vec<tt::Ident>> {\n+        match self {\n+            AdtShape::Struct(s) => {\n+                vec![s.field_names()]\n+            }\n+            AdtShape::Enum { variants, .. } => {\n+                variants.iter().map(|(_, fields)| fields.field_names()).collect()\n+            }\n+            AdtShape::Union => {\n+                never!(\"using fields of union in derive is always wrong\");\n+                vec![]\n+            }\n+        }\n+    }\n+\n+    fn as_pattern_map(\n+        &self,\n+        name: &tt::Ident,\n+        field_map: impl Fn(&tt::Ident) -> tt::Subtree,\n+    ) -> Vec<tt::Subtree> {\n+        match self {\n+            AdtShape::Struct(s) => {\n+                vec![s.as_pattern_map(quote! { #name }, field_map)]\n+            }\n+            AdtShape::Enum { variants, .. } => variants\n+                .iter()\n+                .map(|(v, fields)| fields.as_pattern_map(quote! { #name :: #v }, &field_map))\n+                .collect(),\n+            AdtShape::Union => {\n+                never!(\"pattern matching on union is always wrong\");\n+                vec![quote! { un }]\n+            }\n+        }\n+    }\n+}\n+\n struct BasicAdtInfo {\n     name: tt::Ident,\n+    shape: AdtShape,\n     /// first field is the name, and\n     /// second field is `Some(ty)` if it's a const param of type `ty`, `None` if it's a type param.\n     /// third fields is where bounds, if any\n@@ -79,11 +202,24 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n         ExpandError::Other(\"no item found\".into())\n     })?;\n     let node = item.syntax();\n-    let (name, params) = match_ast! {\n+    let (name, params, shape) = match_ast! {\n         match node {\n-            ast::Struct(it) => (it.name(), it.generic_param_list()),\n-            ast::Enum(it) => (it.name(), it.generic_param_list()),\n-            ast::Union(it) => (it.name(), it.generic_param_list()),\n+            ast::Struct(it) => (it.name(), it.generic_param_list(), AdtShape::Struct(VariantShape::from(it.field_list(), &token_map)?)),\n+            ast::Enum(it) => {\n+                let default_variant = it.variant_list().into_iter().flat_map(|x| x.variants()).position(|x| x.attrs().any(|x| x.simple_name() == Some(\"default\".into())));\n+                (\n+                    it.name(),\n+                    it.generic_param_list(),\n+                    AdtShape::Enum {\n+                        default_variant,\n+                        variants: it.variant_list()\n+                            .into_iter()\n+                            .flat_map(|x| x.variants())\n+                            .map(|x| Ok((name_to_token(&token_map,x.name())?, VariantShape::from(x.field_list(), &token_map)?))).collect::<Result<_, ExpandError>>()?\n+                    }\n+                )\n+            },\n+            ast::Union(it) => (it.name(), it.generic_param_list(), AdtShape::Union),\n             _ => {\n                 debug!(\"unexpected node is {:?}\", node);\n                 return Err(ExpandError::Other(\"expected struct, enum or union\".into()))\n@@ -154,14 +290,19 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n         .filter(is_associated_type)\n         .map(|x| mbe::syntax_node_to_token_tree(x.syntax()).0)\n         .collect::<Vec<_>>();\n+    let name_token = name_to_token(&token_map, name)?;\n+    Ok(BasicAdtInfo { name: name_token, shape, param_types, associated_types })\n+}\n+\n+fn name_to_token(token_map: &TokenMap, name: Option<ast::Name>) -> Result<tt::Ident, ExpandError> {\n     let name = name.ok_or_else(|| {\n         debug!(\"parsed item has no name\");\n         ExpandError::Other(\"missing name\".into())\n     })?;\n     let name_token_id =\n         token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n     let name_token = tt::Ident { span: name_token_id, text: name.text().into() };\n-    Ok(BasicAdtInfo { name: name_token, param_types, associated_types })\n+    Ok(name_token)\n }\n \n /// Given that we are deriving a trait `DerivedTrait` for a type like:\n@@ -195,11 +336,16 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n ///\n /// where B1, ..., BN are the bounds given by `bounds_paths`.'. Z is a phantom type, and\n /// therefore does not get bound by the derived trait.\n-fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResult<tt::Subtree> {\n+fn expand_simple_derive(\n+    tt: &tt::Subtree,\n+    trait_path: tt::Subtree,\n+    trait_body: impl FnOnce(&BasicAdtInfo) -> tt::Subtree,\n+) -> ExpandResult<tt::Subtree> {\n     let info = match parse_adt(tt) {\n         Ok(info) => info,\n         Err(e) => return ExpandResult::new(tt::Subtree::empty(), e),\n     };\n+    let trait_body = trait_body(&info);\n     let mut where_block = vec![];\n     let (params, args): (Vec<_>, Vec<_>) = info\n         .param_types\n@@ -227,7 +373,7 @@ fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResu\n \n     let name = info.name;\n     let expanded = quote! {\n-        impl < ##params > #trait_path for #name < ##args > where ##where_block {}\n+        impl < ##params > #trait_path for #name < ##args > where ##where_block { #trait_body }\n     };\n     ExpandResult::ok(expanded)\n }\n@@ -254,7 +400,7 @@ fn copy_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::marker::Copy })\n+    expand_simple_derive(tt, quote! { #krate::marker::Copy }, |_| quote! {})\n }\n \n fn clone_expand(\n@@ -263,34 +409,230 @@ fn clone_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::clone::Clone })\n+    expand_simple_derive(tt, quote! { #krate::clone::Clone }, |adt| {\n+        if matches!(adt.shape, AdtShape::Union) {\n+            let star = tt::Punct {\n+                char: '*',\n+                spacing: ::tt::Spacing::Alone,\n+                span: tt::TokenId::unspecified(),\n+            };\n+            return quote! {\n+                fn clone(&self) -> Self {\n+                    #star self\n+                }\n+            };\n+        }\n+        if matches!(&adt.shape, AdtShape::Enum { variants, .. } if variants.is_empty()) {\n+            let star = tt::Punct {\n+                char: '*',\n+                spacing: ::tt::Spacing::Alone,\n+                span: tt::TokenId::unspecified(),\n+            };\n+            return quote! {\n+                fn clone(&self) -> Self {\n+                    match #star self {}\n+                }\n+            };\n+        }\n+        let name = &adt.name;\n+        let patterns = adt.shape.as_pattern(name);\n+        let exprs = adt.shape.as_pattern_map(name, |x| quote! { #x .clone() });\n+        let arms = patterns.into_iter().zip(exprs.into_iter()).map(|(pat, expr)| {\n+            let fat_arrow = fat_arrow();\n+            quote! {\n+                #pat #fat_arrow #expr,\n+            }\n+        });\n+\n+        quote! {\n+            fn clone(&self) -> Self {\n+                match self {\n+                    ##arms\n+                }\n+            }\n+        }\n+    })\n+}\n+\n+/// This function exists since `quote! { => }` doesn't work.\n+fn fat_arrow() -> ::tt::Subtree<TokenId> {\n+    let eq =\n+        tt::Punct { char: '=', spacing: ::tt::Spacing::Joint, span: tt::TokenId::unspecified() };\n+    quote! { #eq> }\n+}\n+\n+/// This function exists since `quote! { && }` doesn't work.\n+fn and_and() -> ::tt::Subtree<TokenId> {\n+    let and =\n+        tt::Punct { char: '&', spacing: ::tt::Spacing::Joint, span: tt::TokenId::unspecified() };\n+    quote! { #and& }\n }\n \n fn default_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::default::Default })\n+    let krate = &find_builtin_crate(db, id);\n+    expand_simple_derive(tt, quote! { #krate::default::Default }, |adt| {\n+        let body = match &adt.shape {\n+            AdtShape::Struct(fields) => {\n+                let name = &adt.name;\n+                fields\n+                    .as_pattern_map(quote!(#name), |_| quote!(#krate::default::Default::default()))\n+            }\n+            AdtShape::Enum { default_variant, variants } => {\n+                if let Some(d) = default_variant {\n+                    let (name, fields) = &variants[*d];\n+                    let adt_name = &adt.name;\n+                    fields.as_pattern_map(\n+                        quote!(#adt_name :: #name),\n+                        |_| quote!(#krate::default::Default::default()),\n+                    )\n+                } else {\n+                    // FIXME: Return expand error here\n+                    quote!()\n+                }\n+            }\n+            AdtShape::Union => {\n+                // FIXME: Return expand error here\n+                quote!()\n+            }\n+        };\n+        quote! {\n+            fn default() -> Self {\n+                #body\n+            }\n+        }\n+    })\n }\n \n fn debug_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::fmt::Debug })\n+    let krate = &find_builtin_crate(db, id);\n+    expand_simple_derive(tt, quote! { #krate::fmt::Debug }, |adt| {\n+        let for_variant = |name: String, v: &VariantShape| match v {\n+            VariantShape::Struct(fields) => {\n+                let for_fields = fields.iter().map(|x| {\n+                    let x_string = x.to_string();\n+                    quote! {\n+                        .field(#x_string, #x)\n+                    }\n+                });\n+                quote! {\n+                    f.debug_struct(#name) ##for_fields .finish()\n+                }\n+            }\n+            VariantShape::Tuple(n) => {\n+                let for_fields = tuple_field_iterator(*n).map(|x| {\n+                    quote! {\n+                        .field(#x)\n+                    }\n+                });\n+                quote! {\n+                    f.debug_tuple(#name) ##for_fields .finish()\n+                }\n+            }\n+            VariantShape::Unit => quote! {\n+                f.write_str(#name)\n+            },\n+        };\n+        if matches!(&adt.shape, AdtShape::Enum { variants, .. } if variants.is_empty()) {\n+            let star = tt::Punct {\n+                char: '*',\n+                spacing: ::tt::Spacing::Alone,\n+                span: tt::TokenId::unspecified(),\n+            };\n+            return quote! {\n+                fn fmt(&self, f: &mut #krate::fmt::Formatter) -> #krate::fmt::Result {\n+                    match #star self {}\n+                }\n+            };\n+        }\n+        let arms = match &adt.shape {\n+            AdtShape::Struct(fields) => {\n+                let fat_arrow = fat_arrow();\n+                let name = &adt.name;\n+                let pat = fields.as_pattern(quote!(#name));\n+                let expr = for_variant(name.to_string(), fields);\n+                vec![quote! { #pat #fat_arrow #expr }]\n+            }\n+            AdtShape::Enum { variants, .. } => variants\n+                .iter()\n+                .map(|(name, v)| {\n+                    let fat_arrow = fat_arrow();\n+                    let adt_name = &adt.name;\n+                    let pat = v.as_pattern(quote!(#adt_name :: #name));\n+                    let expr = for_variant(name.to_string(), v);\n+                    quote! {\n+                        #pat #fat_arrow #expr ,\n+                    }\n+                })\n+                .collect(),\n+            AdtShape::Union => {\n+                // FIXME: Return expand error here\n+                vec![]\n+            }\n+        };\n+        quote! {\n+            fn fmt(&self, f: &mut #krate::fmt::Formatter) -> #krate::fmt::Result {\n+                match self {\n+                    ##arms\n+                }\n+            }\n+        }\n+    })\n }\n \n fn hash_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::hash::Hash })\n+    let krate = &find_builtin_crate(db, id);\n+    expand_simple_derive(tt, quote! { #krate::hash::Hash }, |adt| {\n+        if matches!(adt.shape, AdtShape::Union) {\n+            // FIXME: Return expand error here\n+            return quote! {};\n+        }\n+        if matches!(&adt.shape, AdtShape::Enum { variants, .. } if variants.is_empty()) {\n+            let star = tt::Punct {\n+                char: '*',\n+                spacing: ::tt::Spacing::Alone,\n+                span: tt::TokenId::unspecified(),\n+            };\n+            return quote! {\n+                fn hash<H: #krate::hash::Hasher>(&self, state: &mut H) {\n+                    match #star self {}\n+                }\n+            };\n+        }\n+        let arms = adt.shape.as_pattern(&adt.name).into_iter().zip(adt.shape.field_names()).map(\n+            |(pat, names)| {\n+                let expr = {\n+                    let it = names.iter().map(|x| quote! { #x . hash(state); });\n+                    quote! { {\n+                        ##it\n+                    } }\n+                };\n+                let fat_arrow = fat_arrow();\n+                quote! {\n+                    #pat #fat_arrow #expr ,\n+                }\n+            },\n+        );\n+        quote! {\n+            fn hash<H: #krate::hash::Hasher>(&self, state: &mut H) {\n+                #krate::mem::discriminant(self).hash(state);\n+                match self {\n+                    ##arms\n+                }\n+            }\n+        }\n+    })\n }\n \n fn eq_expand(\n@@ -299,7 +641,7 @@ fn eq_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::cmp::Eq })\n+    expand_simple_derive(tt, quote! { #krate::cmp::Eq }, |_| quote! {})\n }\n \n fn partial_eq_expand(\n@@ -308,23 +650,191 @@ fn partial_eq_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::cmp::PartialEq })\n+    expand_simple_derive(tt, quote! { #krate::cmp::PartialEq }, |adt| {\n+        if matches!(adt.shape, AdtShape::Union) {\n+            // FIXME: Return expand error here\n+            return quote! {};\n+        }\n+        let name = &adt.name;\n+\n+        let (self_patterns, other_patterns) = self_and_other_patterns(adt, name);\n+        let arms = izip!(self_patterns, other_patterns, adt.shape.field_names()).map(\n+            |(pat1, pat2, names)| {\n+                let fat_arrow = fat_arrow();\n+                let body = match &*names {\n+                    [] => {\n+                        quote!(true)\n+                    }\n+                    [first, rest @ ..] => {\n+                        let rest = rest.iter().map(|x| {\n+                            let t1 = Ident::new(format!(\"{}_self\", x.text), x.span);\n+                            let t2 = Ident::new(format!(\"{}_other\", x.text), x.span);\n+                            let and_and = and_and();\n+                            quote!(#and_and #t1 .eq( #t2 ))\n+                        });\n+                        let first = {\n+                            let t1 = Ident::new(format!(\"{}_self\", first.text), first.span);\n+                            let t2 = Ident::new(format!(\"{}_other\", first.text), first.span);\n+                            quote!(#t1 .eq( #t2 ))\n+                        };\n+                        quote!(#first ##rest)\n+                    }\n+                };\n+                quote! { ( #pat1 , #pat2 ) #fat_arrow #body , }\n+            },\n+        );\n+\n+        let fat_arrow = fat_arrow();\n+        quote! {\n+            fn eq(&self, other: &Self) -> bool {\n+                match (self, other) {\n+                    ##arms\n+                    _unused #fat_arrow false\n+                }\n+            }\n+        }\n+    })\n+}\n+\n+fn self_and_other_patterns(\n+    adt: &BasicAdtInfo,\n+    name: &tt::Ident,\n+) -> (Vec<tt::Subtree>, Vec<tt::Subtree>) {\n+    let self_patterns = adt.shape.as_pattern_map(name, |x| {\n+        let t = Ident::new(format!(\"{}_self\", x.text), x.span);\n+        quote!(#t)\n+    });\n+    let other_patterns = adt.shape.as_pattern_map(name, |x| {\n+        let t = Ident::new(format!(\"{}_other\", x.text), x.span);\n+        quote!(#t)\n+    });\n+    (self_patterns, other_patterns)\n }\n \n fn ord_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::cmp::Ord })\n+    let krate = &find_builtin_crate(db, id);\n+    expand_simple_derive(tt, quote! { #krate::cmp::Ord }, |adt| {\n+        fn compare(\n+            krate: &tt::TokenTree,\n+            left: tt::Subtree,\n+            right: tt::Subtree,\n+            rest: tt::Subtree,\n+        ) -> tt::Subtree {\n+            let fat_arrow1 = fat_arrow();\n+            let fat_arrow2 = fat_arrow();\n+            quote! {\n+                match #left.cmp(&#right) {\n+                    #krate::cmp::Ordering::Equal #fat_arrow1 {\n+                        #rest\n+                    }\n+                    c #fat_arrow2 return c,\n+                }\n+            }\n+        }\n+        if matches!(adt.shape, AdtShape::Union) {\n+            // FIXME: Return expand error here\n+            return quote!();\n+        }\n+        let left = quote!(#krate::intrinsics::discriminant_value(self));\n+        let right = quote!(#krate::intrinsics::discriminant_value(other));\n+\n+        let (self_patterns, other_patterns) = self_and_other_patterns(adt, &adt.name);\n+        let arms = izip!(self_patterns, other_patterns, adt.shape.field_names()).map(\n+            |(pat1, pat2, fields)| {\n+                let mut body = quote!(#krate::cmp::Ordering::Equal);\n+                for f in fields.into_iter().rev() {\n+                    let t1 = Ident::new(format!(\"{}_self\", f.text), f.span);\n+                    let t2 = Ident::new(format!(\"{}_other\", f.text), f.span);\n+                    body = compare(krate, quote!(#t1), quote!(#t2), body);\n+                }\n+                let fat_arrow = fat_arrow();\n+                quote! { ( #pat1 , #pat2 ) #fat_arrow #body , }\n+            },\n+        );\n+        let fat_arrow = fat_arrow();\n+        let body = compare(\n+            krate,\n+            left,\n+            right,\n+            quote! {\n+                match (self, other) {\n+                    ##arms\n+                    _unused #fat_arrow #krate::cmp::Ordering::Equal\n+                }\n+            },\n+        );\n+        quote! {\n+            fn cmp(&self, other: &Self) -> #krate::cmp::Ordering {\n+                #body\n+            }\n+        }\n+    })\n }\n \n fn partial_ord_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::cmp::PartialOrd })\n+    let krate = &find_builtin_crate(db, id);\n+    expand_simple_derive(tt, quote! { #krate::cmp::PartialOrd }, |adt| {\n+        fn compare(\n+            krate: &tt::TokenTree,\n+            left: tt::Subtree,\n+            right: tt::Subtree,\n+            rest: tt::Subtree,\n+        ) -> tt::Subtree {\n+            let fat_arrow1 = fat_arrow();\n+            let fat_arrow2 = fat_arrow();\n+            quote! {\n+                match #left.partial_cmp(&#right) {\n+                    #krate::option::Option::Some(#krate::cmp::Ordering::Equal) #fat_arrow1 {\n+                        #rest\n+                    }\n+                    c #fat_arrow2 return c,\n+                }\n+            }\n+        }\n+        if matches!(adt.shape, AdtShape::Union) {\n+            // FIXME: Return expand error here\n+            return quote!();\n+        }\n+        let left = quote!(#krate::intrinsics::discriminant_value(self));\n+        let right = quote!(#krate::intrinsics::discriminant_value(other));\n+\n+        let (self_patterns, other_patterns) = self_and_other_patterns(adt, &adt.name);\n+        let arms = izip!(self_patterns, other_patterns, adt.shape.field_names()).map(\n+            |(pat1, pat2, fields)| {\n+                let mut body = quote!(#krate::option::Option::Some(#krate::cmp::Ordering::Equal));\n+                for f in fields.into_iter().rev() {\n+                    let t1 = Ident::new(format!(\"{}_self\", f.text), f.span);\n+                    let t2 = Ident::new(format!(\"{}_other\", f.text), f.span);\n+                    body = compare(krate, quote!(#t1), quote!(#t2), body);\n+                }\n+                let fat_arrow = fat_arrow();\n+                quote! { ( #pat1 , #pat2 ) #fat_arrow #body , }\n+            },\n+        );\n+        let fat_arrow = fat_arrow();\n+        let body = compare(\n+            krate,\n+            left,\n+            right,\n+            quote! {\n+                match (self, other) {\n+                    ##arms\n+                    _unused #fat_arrow #krate::option::Option::Some(#krate::cmp::Ordering::Equal)\n+                }\n+            },\n+        );\n+        quote! {\n+            fn partial_cmp(&self, other: &Self) -> #krate::option::Option::Option<#krate::cmp::Ordering> {\n+                #body\n+            }\n+        }\n+    })\n }"}, {"sha": "ab3809abc7a26a390eb73a8a81eccec124abe312", "filename": "crates/hir-expand/src/quote.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Fhir-expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Fhir-expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fquote.rs?ref=d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "patch": "@@ -162,6 +162,12 @@ impl ToTokenTree for crate::tt::TokenTree {\n     }\n }\n \n+impl ToTokenTree for &crate::tt::TokenTree {\n+    fn to_token(self) -> crate::tt::TokenTree {\n+        self.clone()\n+    }\n+}\n+\n impl ToTokenTree for crate::tt::Subtree {\n     fn to_token(self) -> crate::tt::TokenTree {\n         self.into()"}, {"sha": "12b15065ddf9135c6c548e3d09cf1db0c10f4d61", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "patch": "@@ -1227,6 +1227,53 @@ fn from_trait() {\n     );\n }\n \n+#[test]\n+fn builtin_derive_macro() {\n+    check_number(\n+        r#\"\n+    //- minicore: clone, derive, builtin_impls\n+    #[derive(Clone)]\n+    enum Z {\n+        Foo(Y),\n+        Bar,\n+    }\n+    #[derive(Clone)]\n+    struct X(i32, Z, i64)\n+    #[derive(Clone)]\n+    struct Y {\n+        field1: i32,\n+        field2: u8,\n+    }\n+\n+    const GOAL: u8 = {\n+        let x = X(2, Z::Foo(Y { field1: 4, field2: 5 }), 8);\n+        let x = x.clone();\n+        let Z::Foo(t) = x.1;\n+        t.field2\n+    };\n+    \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: default, derive, builtin_impls\n+    #[derive(Default)]\n+    struct X(i32, Y, i64)\n+    #[derive(Default)]\n+    struct Y {\n+        field1: i32,\n+        field2: u8,\n+    }\n+\n+    const GOAL: u8 = {\n+        let x = X::default();\n+        x.1.field2\n+    };\n+    \"#,\n+        0,\n+    );\n+}\n+\n #[test]\n fn try_operator() {\n     check_number("}, {"sha": "8c03d197e1c770e2b5bf1f36ac27ab257919053f", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "patch": "@@ -151,9 +151,11 @@ fn _format(\n     _db: &RootDatabase,\n     _kind: SyntaxKind,\n     _file_id: FileId,\n-    _expansion: &str,\n+    expansion: &str,\n ) -> Option<String> {\n-    None\n+    // remove trailing spaces for test\n+    use itertools::Itertools;\n+    Some(expansion.lines().map(|x| x.trim_end()).join(\"\\n\"))\n }\n \n #[cfg(not(any(test, target_arch = \"wasm32\", target_os = \"emscripten\")))]\n@@ -276,8 +278,7 @@ f$0oo!();\n \"#,\n             expect![[r#\"\n                 foo!\n-                fn b(){}\n-            \"#]],\n+                fn b(){}\"#]],\n         );\n     }\n \n@@ -471,8 +472,17 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Clone\n-                impl < >core::clone::Clone for Foo< >where{}\n-            \"#]],\n+                impl < >core::clone::Clone for Foo< >where {\n+                  fn clone(&self) -> Self {\n+                    match self {\n+                      Foo{}\n+                       => Foo{}\n+                      ,\n+\n+                      }\n+                  }\n+\n+                  }\"#]],\n         );\n     }\n \n@@ -488,8 +498,7 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Copy\n-                impl < >core::marker::Copy for Foo< >where{}\n-            \"#]],\n+                impl < >core::marker::Copy for Foo< >where{}\"#]],\n         );\n     }\n \n@@ -504,8 +513,7 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Copy\n-                impl < >core::marker::Copy for Foo< >where{}\n-            \"#]],\n+                impl < >core::marker::Copy for Foo< >where{}\"#]],\n         );\n         check(\n             r#\"\n@@ -516,8 +524,17 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Clone\n-                impl < >core::clone::Clone for Foo< >where{}\n-            \"#]],\n+                impl < >core::clone::Clone for Foo< >where {\n+                  fn clone(&self) -> Self {\n+                    match self {\n+                      Foo{}\n+                       => Foo{}\n+                      ,\n+\n+                      }\n+                  }\n+\n+                  }\"#]],\n         );\n     }\n }"}, {"sha": "c693235f3446c23d81eb2cd40dabc859397f75a6", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "patch": "@@ -11,6 +11,7 @@\n //!     add:\n //!     as_ref: sized\n //!     bool_impl: option, fn\n+//!     builtin_impls:\n //!     cell: copy, drop\n //!     clone: sized\n //!     coerce_unsized: unsize\n@@ -127,6 +128,27 @@ pub mod default {\n     #[rustc_builtin_macro(Default, attributes(default))]\n     pub macro Default($item:item) {}\n     // endregion:derive\n+\n+    // region:builtin_impls\n+    macro_rules! impl_default {\n+        ($v:literal; $($t:ty)*) => {\n+            $(\n+                impl const Default for $t {\n+                    fn default() -> Self {\n+                        $v\n+                    }\n+                }\n+            )*\n+        }\n+    }\n+\n+    impl_default! {\n+        0; usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128\n+    }\n+    impl_default! {\n+        0.0; f32 f64\n+    }\n+    // endregion:builtin_impls\n }\n // endregion:default\n \n@@ -137,6 +159,11 @@ pub mod hash {\n     pub trait Hash {\n         fn hash<H: Hasher>(&self, state: &mut H);\n     }\n+\n+    // region:derive\n+    #[rustc_builtin_macro]\n+    pub macro Hash($item:item) {}\n+    // endregion:derive\n }\n // endregion:hash\n \n@@ -198,6 +225,28 @@ pub mod clone {\n             *self\n         }\n     }\n+\n+    // region:builtin_impls\n+    macro_rules! impl_clone {\n+        ($($t:ty)*) => {\n+            $(\n+                impl const Clone for $t {\n+                    fn clone(&self) -> Self {\n+                        *self\n+                    }\n+                }\n+            )*\n+        }\n+    }\n+\n+    impl_clone! {\n+        usize u8 u16 u32 u64 u128\n+        isize i8 i16 i32 i64 i128\n+        f32 f64\n+        bool char\n+    }\n+    // endregion:builtin_impls\n+\n     // region:derive\n     #[rustc_builtin_macro]\n     pub macro Clone($item:item) {}\n@@ -723,6 +772,11 @@ pub mod fmt {\n     pub trait Display {\n         fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n     }\n+\n+    // region:derive\n+    #[rustc_builtin_macro]\n+    pub macro Debug($item:item) {}\n+    // endregion:derive\n }\n // endregion:fmt\n "}, {"sha": "c2ebf03746a87223cfcb14ab0e947c07be0ee562", "filename": "crates/tt/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Ftt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f4cbbe8f261278cb16ad462b56d5eafbd22bed/crates%2Ftt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftt%2Fsrc%2Flib.rs?ref=d9f4cbbe8f261278cb16ad462b56d5eafbd22bed", "patch": "@@ -153,6 +153,12 @@ pub struct Ident<Span> {\n     pub span: Span,\n }\n \n+impl<S> Ident<S> {\n+    pub fn new(text: impl Into<SmolStr>, span: S) -> Self {\n+        Ident { text: text.into(), span }\n+    }\n+}\n+\n fn print_debug_subtree<Span: fmt::Debug>(\n     f: &mut fmt::Formatter<'_>,\n     subtree: &Subtree<Span>,"}]}