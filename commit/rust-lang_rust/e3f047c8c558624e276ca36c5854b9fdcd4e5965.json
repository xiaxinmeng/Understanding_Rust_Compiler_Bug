{"sha": "e3f047c8c558624e276ca36c5854b9fdcd4e5965", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZjA0N2M4YzU1ODYyNGUyNzZjYTM2YzU4NTRiOWZkY2Q0ZTU5NjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T23:29:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T23:29:18Z"}, "message": "rollup merge of #20653: alexcrichton/entry-unstable\n\nThere's been some debate over the precise form that these APIs should take, and\nthey've undergone some changes recently, so these APIs are going to be left\nunstable for now to be fleshed out during the next release cycle.", "tree": {"sha": "77e9e15864dd4466a9592fe6e26b6494e7e26c62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77e9e15864dd4466a9592fe6e26b6494e7e26c62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3f047c8c558624e276ca36c5854b9fdcd4e5965", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3f047c8c558624e276ca36c5854b9fdcd4e5965", "html_url": "https://github.com/rust-lang/rust/commit/e3f047c8c558624e276ca36c5854b9fdcd4e5965", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3f047c8c558624e276ca36c5854b9fdcd4e5965/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed61bd869300df56e52338ba1ee36038159ad196", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed61bd869300df56e52338ba1ee36038159ad196", "html_url": "https://github.com/rust-lang/rust/commit/ed61bd869300df56e52338ba1ee36038159ad196"}, {"sha": "169fbed25179f223b730e1db5739e4a5a408ef31", "url": "https://api.github.com/repos/rust-lang/rust/commits/169fbed25179f223b730e1db5739e4a5a408ef31", "html_url": "https://github.com/rust-lang/rust/commit/169fbed25179f223b730e1db5739e4a5a408ef31"}], "stats": {"total": 167, "additions": 77, "deletions": 90}, "files": [{"sha": "0a6551bf41a5f317dc6ea6bb854b949f7acb2a6a", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -19,7 +19,7 @@ pub use self::Entry::*;\n \n use core::prelude::*;\n \n-use core::borrow::{BorrowFrom, ToOwned};\n+use core::borrow::BorrowFrom;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Show;\n@@ -128,24 +128,24 @@ pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n-#[stable]\n /// A view into a single entry in a map, which may either be vacant or occupied.\n-pub enum Entry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n+#[unstable = \"precise API still under development\"]\n+pub enum Entry<'a, K:'a, V:'a> {\n     /// A vacant Entry\n-    Vacant(VacantEntry<'a, Q, K, V>),\n+    Vacant(VacantEntry<'a, K, V>),\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n }\n \n-#[stable]\n /// A vacant Entry.\n-pub struct VacantEntry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n-    key: &'a Q,\n+#[unstable = \"precise API still under development\"]\n+pub struct VacantEntry<'a, K:'a, V:'a> {\n+    key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n-#[stable]\n /// An occupied Entry.\n+#[unstable = \"precise API still under development\"]\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n@@ -1111,55 +1111,55 @@ impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n #[stable]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n-impl<'a, Q: ?Sized, K: Ord, V> Entry<'a, Q, K, V> {\n+impl<'a, K: Ord, V> Entry<'a, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n-    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n+    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n             Occupied(entry) => Ok(entry.into_mut()),\n             Vacant(entry) => Err(entry),\n         }\n     }\n }\n \n-impl<'a, Q: ?Sized + ToOwned<K>, K: Ord, V> VacantEntry<'a, Q, K, V> {\n-    #[stable]\n+impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn insert(self, value: V) -> &'a mut V {\n-        self.stack.insert(self.key.to_owned(), value)\n+        self.stack.insert(self.key, value)\n     }\n }\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n-    #[stable]\n     /// Gets a reference to the value in the entry.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn get(&self) -> &V {\n         self.stack.peek()\n     }\n \n-    #[stable]\n     /// Gets a mutable reference to the value in the entry.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.stack.peek_mut()\n     }\n \n-    #[stable]\n     /// Converts the entry into a mutable reference to its value.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn into_mut(self) -> &'a mut V {\n         self.stack.into_top()\n     }\n \n-    #[stable]\n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, mut value: V) -> V {\n         mem::swap(self.stack.peek_mut(), &mut value);\n         value\n     }\n \n-    #[stable]\n     /// Takes the value of the entry out of the map, and returns it.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn remove(self) -> V {\n         self.stack.remove()\n     }\n@@ -1361,15 +1361,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3u);\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n-    #[stable]\n-    pub fn entry<'a, Q: ?Sized>(&'a mut self, mut key: &'a Q) -> Entry<'a, Q, K, V>\n-        where Q: Ord + ToOwned<K>\n-    {\n+    #[unstable = \"precise API still under development\"]\n+    pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n             let result = stack.with(move |pusher, node| {\n-                return match Node::search(node, key) {\n+                return match Node::search(node, &key) {\n                     Found(handle) => {\n                         // Perfect match\n                         Finished(Occupied(OccupiedEntry {\n@@ -1412,7 +1410,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use std::borrow::{ToOwned, BorrowFrom};\n+    use std::borrow::BorrowFrom;\n \n     use super::{BTreeMap, Occupied, Vacant};\n \n@@ -1562,7 +1560,7 @@ mod test {\n         let mut map: BTreeMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         // Existing key (insert)\n-        match map.entry(&1) {\n+        match map.entry(1) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 assert_eq!(view.get(), &10);\n@@ -1574,7 +1572,7 @@ mod test {\n \n \n         // Existing key (update)\n-        match map.entry(&2) {\n+        match map.entry(2) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 let v = view.get_mut();\n@@ -1585,7 +1583,7 @@ mod test {\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n-        match map.entry(&3) {\n+        match map.entry(3) {\n             Vacant(_) => unreachable!(),\n             Occupied(view) => {\n                 assert_eq!(view.remove(), 30);\n@@ -1596,7 +1594,7 @@ mod test {\n \n \n         // Inexistent key (insert)\n-        match map.entry(&10) {\n+        match map.entry(10) {\n             Occupied(_) => unreachable!(),\n             Vacant(view) => {\n                 assert_eq!(*view.insert(1000), 1000);"}, {"sha": "0adf46cae071a666ebb482ae9274ec31b4ce2bda", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -1328,7 +1328,7 @@ impl UnusedMut {\n                 let ident = path1.node;\n                 if let ast::BindByValue(ast::MutMutable) = mode {\n                     if !token::get_ident(ident).get().starts_with(\"_\") {\n-                        match mutables.entry(&ident.name.uint()) {\n+                        match mutables.entry(ident.name.uint()) {\n                             Vacant(entry) => { entry.insert(vec![id]); },\n                             Occupied(mut entry) => { entry.get_mut().push(id); },\n                         }"}, {"sha": "0fa9472287caa05440fc6dff03f1ba5ee73bbe69", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -400,7 +400,7 @@ impl<'a> Context<'a> {\n             info!(\"lib candidate: {}\", path.display());\n \n             let hash_str = hash.to_string();\n-            let slot = candidates.entry(&hash_str).get().unwrap_or_else(\n+            let slot = candidates.entry(hash_str).get().unwrap_or_else(\n                 |vacant_entry| vacant_entry.insert((HashSet::new(), HashSet::new())));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             if rlib {"}, {"sha": "e726993bd48402cfa27c835dec2e81a408091cac", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -311,7 +311,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n \n         ast::ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow()[callee.id].clone();\n-            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(&expr.id) {\n+            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n                entry.insert(def);\n             }\n             let path = match def {"}, {"sha": "02c52f82967613316bc9be19fd016e07c4941e65", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n             None => { }\n         }\n \n-        match self.freshen_map.entry(&key) {\n+        match self.freshen_map.entry(key) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 let index = self.freshen_count;"}, {"sha": "29feaf358e2e259795cef71f9505b386b5e92fe4", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n         let mut node_ids = FnvHashMap::new();\n         {\n             let mut add_node = |&mut : node| {\n-                if let Vacant(e) = node_ids.entry(&node) {\n+                if let Vacant(e) = node_ids.entry(node) {\n                     e.insert(i);\n                     i += 1;\n                 }"}, {"sha": "71a3ad64faf9ba965bd0d02fdbbae8604fc8a4c9", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -437,11 +437,9 @@ fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"register_region_obligation({})\",\n            region_obligation.repr(tcx));\n \n-    let body_id = region_obligation.cause.body_id;\n-    match region_obligations.entry(&body_id) {\n+    match region_obligations.entry(region_obligation.cause.body_id) {\n         Vacant(entry) => { entry.insert(vec![region_obligation]); },\n         Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n     }\n \n }\n-"}, {"sha": "c624c995e22971d3010b50e8e6e6f2bd0c4f3a2e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -5616,7 +5616,7 @@ pub fn lookup_field_type<'tcx>(tcx: &ctxt<'tcx>,\n         node_id_to_type(tcx, id.node)\n     } else {\n         let mut tcache = tcx.tcache.borrow_mut();\n-        let pty = tcache.entry(&id).get().unwrap_or_else(\n+        let pty = tcache.entry(id).get().unwrap_or_else(\n             |vacant_entry| vacant_entry.insert(csearch::get_field_type(tcx, struct_id, id)));\n         pty.ty\n     };\n@@ -6755,7 +6755,7 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n         debug!(\"region={}\", region.repr(tcx));\n         match region {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n-                * map.entry(&br).get().unwrap_or_else(\n+                * map.entry(br).get().unwrap_or_else(\n                       |vacant_entry| vacant_entry.insert(mapf(br, debruijn)))\n             }\n             _ => {"}, {"sha": "4968066f7b696b01ba5807cb4902746e3189dd95", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -1115,7 +1115,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             None => early_error(\"--extern value must be of the format `foo=bar`\"),\n         };\n \n-        match externs.entry(&name.to_string()) {\n+        match externs.entry(name.to_string()) {\n             Vacant(entry) => { entry.insert(vec![location.to_string()]); },\n             Occupied(mut entry) => { entry.get_mut().push(location.to_string()); },\n         }"}, {"sha": "93ad69e03b17f1af3eb84dd1850b74a14e52a266", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -1688,7 +1688,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let is_public = import_directive.is_public;\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.entry(&name).get().unwrap_or_else(\n+        let dest_import_resolution = import_resolutions.entry(name).get().unwrap_or_else(\n             |vacant_entry| {\n                 // Create a new import resolution from this child.\n                 vacant_entry.insert(ImportResolution::new(id, is_public))\n@@ -2626,14 +2626,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             def = DefUpvar(node_id, function_id, last_proc_body_id);\n \n                             let mut seen = self.freevars_seen.borrow_mut();\n-                            let seen = match seen.entry(&function_id) {\n+                            let seen = match seen.entry(function_id) {\n                                 Occupied(v) => v.into_mut(),\n                                 Vacant(v) => v.insert(NodeSet::new()),\n                             };\n                             if seen.contains(&node_id) {\n                                 continue;\n                             }\n-                            match self.freevars.borrow_mut().entry(&function_id) {\n+                            match self.freevars.borrow_mut().entry(function_id) {\n                                 Occupied(v) => v.into_mut(),\n                                 Vacant(v) => v.insert(vec![]),\n                             }.push(Freevar { def: prev_def, span: span });\n@@ -4710,7 +4710,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 \"Import should only be used for `use` directives\");\n         self.last_private.insert(node_id, lp);\n \n-        match self.def_map.borrow_mut().entry(&node_id) {\n+        match self.def_map.borrow_mut().entry(node_id) {\n             // Resolve appears to \"resolve\" the same ID multiple\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis"}, {"sha": "47ab42d413e8acc92744e0ae7656c09bcc185a05", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -604,7 +604,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     // Typecheck each field.\n     for &Spanned { node: ref field, span } in fields.iter() {\n-        let field_type = match used_fields.entry(&field.ident.name) {\n+        let field_type = match used_fields.entry(field.ident.name) {\n             Occupied(occupied) => {\n                 span_err!(tcx.sess, span, E0025,\n                     \"field `{}` bound multiple times in the pattern\","}, {"sha": "08abdc2af18dc24c435e58f76b29f44be90cae57", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -821,7 +821,7 @@ impl DocFolder for Cache {\n         if let clean::ImplItem(ref i) = item.inner {\n             match i.trait_ {\n                 Some(clean::ResolvedPath{ did, .. }) => {\n-                    let v = self.implementors.entry(&did).get().unwrap_or_else(\n+                    let v = self.implementors.entry(did).get().unwrap_or_else(\n                         |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n                     v.push(Implementor {\n                         def_id: item.def_id,\n@@ -1011,7 +1011,7 @@ impl DocFolder for Cache {\n                         };\n \n                         if let Some(did) = did {\n-                            let v = self.impls.entry(&did).get().unwrap_or_else(\n+                            let v = self.impls.entry(did).get().unwrap_or_else(\n                                 |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n                             v.push(Impl {\n                                 impl_: i,\n@@ -1260,7 +1260,7 @@ impl Context {\n                 Some(ref s) => s.to_string(),\n             };\n             let short = short.to_string();\n-            let v = map.entry(&short).get().unwrap_or_else(\n+            let v = map.entry(short).get().unwrap_or_else(\n                 |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n             v.push(myname);\n         }"}, {"sha": "e0c778af045fee5299a1fb754160d15200c2e2ea", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -317,7 +317,7 @@ fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n             }\n         };\n         let name = name.to_string();\n-        let locs = externs.entry(&name).get().unwrap_or_else(\n+        let locs = externs.entry(name).get().unwrap_or_else(\n             |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n         locs.push(location.to_string());\n     }"}, {"sha": "fdffdaacabac20d6180a89f5ef9c3b74e4cebde7", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -14,7 +14,7 @@ use self::Entry::*;\n use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n-use borrow::{BorrowFrom, ToOwned};\n+use borrow::BorrowFrom;\n use clone::Clone;\n use cmp::{max, Eq, PartialEq};\n use default::Default;\n@@ -920,16 +920,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    #[stable]\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    /// Regardless of whether or not `to_owned()` has been called, the key must hash the same way.\n-    pub fn entry<'a, Q: ?Sized>(&'a mut self, key: &'a Q) -> Entry<'a, Q, K, V>\n-        where Q: Eq + Hash<S> + ToOwned<K>\n+    #[unstable = \"precise API still being fleshed out\"]\n+    pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>\n     {\n         // Gotta resize now.\n         self.reserve(1);\n \n-        let hash = self.make_hash(key);\n+        let hash = self.make_hash(&key);\n         search_entry_hashed(&mut self.table, hash, key)\n     }\n \n@@ -1142,9 +1140,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-fn search_entry_hashed<'a, K, V, Q: ?Sized>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: &'a Q)\n-        -> Entry<'a, Q, K, V>\n-    where Q: Eq + ToOwned<K>\n+fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n+        -> Entry<'a, K, V>\n {\n     // Worst case, we'll find one empty bucket among `size + 1` buckets.\n     let size = table.size();\n@@ -1167,7 +1164,7 @@ fn search_entry_hashed<'a, K, V, Q: ?Sized>(table: &'a mut RawTable<K,V>, hash:\n         // hash matches?\n         if bucket.hash() == hash {\n             // key matches?\n-            if *k == *BorrowFrom::borrow_from(bucket.read().0) {\n+            if k == *bucket.read().0 {\n                 return Occupied(OccupiedEntry{\n                     elem: bucket,\n                 });\n@@ -1323,27 +1320,27 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n     >\n }\n \n-#[stable]\n /// A view into a single occupied location in a HashMap\n+#[unstable = \"precise API still being fleshed out\"]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n-#[stable]\n /// A view into a single empty location in a HashMap\n-pub struct VacantEntry<'a, Q: ?Sized + 'a, K: 'a, V: 'a> {\n+#[unstable = \"precise API still being fleshed out\"]\n+pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n-    key: &'a Q,\n+    key: K,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n-#[stable]\n /// A view into a single location in a map, which may be vacant or occupied\n-pub enum Entry<'a, Q: ?Sized + 'a, K: 'a, V: 'a> {\n+#[unstable = \"precise API still being fleshed out\"]\n+pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n     /// A vacant Entry\n-    Vacant(VacantEntry<'a, Q, K, V>),\n+    Vacant(VacantEntry<'a, K, V>),\n }\n \n /// Possible states of a VacantEntry\n@@ -1409,63 +1406,59 @@ impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> {\n     }\n }\n \n-impl<'a, Q: ?Sized, K, V> Entry<'a, Q, K, V> {\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+impl<'a, K, V> Entry<'a, K, V> {\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n-    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n+    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n             Occupied(entry) => Ok(entry.into_mut()),\n             Vacant(entry) => Err(entry),\n         }\n     }\n }\n \n+#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n-    #[stable]\n     /// Gets a reference to the value in the entry\n     pub fn get(&self) -> &V {\n         self.elem.read().1\n     }\n \n-    #[stable]\n     /// Gets a mutable reference to the value in the entry\n     pub fn get_mut(&mut self) -> &mut V {\n         self.elem.read_mut().1\n     }\n \n-    #[stable]\n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself\n     pub fn into_mut(self) -> &'a mut V {\n         self.elem.into_mut_refs().1\n     }\n \n-    #[stable]\n     /// Sets the value of the entry, and returns the entry's old value\n     pub fn insert(&mut self, mut value: V) -> V {\n         let old_value = self.get_mut();\n         mem::swap(&mut value, old_value);\n         value\n     }\n \n-    #[stable]\n     /// Takes the value out of the entry, and returns it\n     pub fn remove(self) -> V {\n         pop_internal(self.elem).1\n     }\n }\n \n-impl<'a, Q: ?Sized + 'a + ToOwned<K>, K: 'a, V: 'a> VacantEntry<'a, Q, K, V> {\n-    #[stable]\n+#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n             NeqElem(bucket, ib) => {\n-                robin_hood(bucket, ib, self.hash, self.key.to_owned(), value)\n+                robin_hood(bucket, ib, self.hash, self.key, value)\n             }\n             NoElem(bucket) => {\n-                bucket.put(self.hash, self.key.to_owned(), value).into_mut_refs().1\n+                bucket.put(self.hash, self.key, value).into_mut_refs().1\n             }\n         }\n     }\n@@ -1497,8 +1490,6 @@ mod test_map {\n     use super::HashMap;\n     use super::Entry::{Occupied, Vacant};\n     use iter::{range_inclusive, range_step_inclusive, repeat};\n-    use borrow::ToOwned;\n-    use hash;\n     use cell::RefCell;\n     use rand::{weak_rng, Rng};\n \n@@ -2092,7 +2083,7 @@ mod test_map {\n         let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         // Existing key (insert)\n-        match map.entry(&1) {\n+        match map.entry(1) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 assert_eq!(view.get(), &10);\n@@ -2104,7 +2095,7 @@ mod test_map {\n \n \n         // Existing key (update)\n-        match map.entry(&2) {\n+        match map.entry(2) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 let v = view.get_mut();\n@@ -2116,7 +2107,7 @@ mod test_map {\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n-        match map.entry(&3) {\n+        match map.entry(3) {\n             Vacant(_) => unreachable!(),\n             Occupied(view) => {\n                 assert_eq!(view.remove(), 30);\n@@ -2127,7 +2118,7 @@ mod test_map {\n \n \n         // Inexistent key (insert)\n-        match map.entry(&10) {\n+        match map.entry(10) {\n             Occupied(_) => unreachable!(),\n             Vacant(view) => {\n                 assert_eq!(*view.insert(1000), 1000);\n@@ -2158,7 +2149,7 @@ mod test_map {\n \n         for i in range(0u, 1000) {\n             let x = rng.gen_range(-10, 10);\n-            match m.entry(&x) {\n+            match m.entry(x) {\n                 Vacant(_) => {},\n                 Occupied(e) => {\n                     println!(\"{}: remove {}\", i, x);"}, {"sha": "9b2a4926bcb925cc985dcb1cdacaacb7d6c61bdf", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -255,7 +255,7 @@\n //! let message = \"she sells sea shells by the sea shore\";\n //!\n //! for c in message.chars() {\n-//!     match count.entry(&c) {\n+//!     match count.entry(c) {\n //!         Vacant(entry) => { entry.insert(1u); },\n //!         Occupied(mut entry) => *entry.get_mut() += 1,\n //!     }\n@@ -290,7 +290,7 @@\n //! for id in orders.into_iter() {\n //!     // If this is the first time we've seen this customer, initialize them\n //!     // with no blood alcohol. Otherwise, just retrieve them.\n-//!     let person = match blood_alcohol.entry(&id) {\n+//!     let person = match blood_alcohol.entry(id) {\n //!         Vacant(entry) => entry.insert(Person{id: id, blood_alcohol: 0.0}),\n //!         Occupied(entry) => entry.into_mut(),\n //!     };"}, {"sha": "bebd803ac4f862e55681bb542dc512a3055a1619", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -66,7 +66,7 @@ pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n /// Extend a syntax context with a given mark and sctable (explicit memoization)\n fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, m);\n-    * table.mark_memo.borrow_mut().entry(&key).get().unwrap_or_else(\n+    * table.mark_memo.borrow_mut().entry(key).get().unwrap_or_else(\n           |vacant_entry|\n               vacant_entry.insert(idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt))))\n }\n@@ -84,7 +84,7 @@ fn apply_rename_internal(id: Ident,\n                        table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, id, to);\n \n-    * table.rename_memo.borrow_mut().entry(&key).get().unwrap_or_else(\n+    * table.rename_memo.borrow_mut().entry(key).get().unwrap_or_else(\n           |vacant_entry|\n               vacant_entry.insert(idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt))))\n }"}, {"sha": "0f9d613cf135f3c930d9b3539e7b1a69a138f84f", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -219,7 +219,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                 }\n             }\n             &TtToken(sp, MatchNt(bind_name, _, _, _)) => {\n-                match ret_val.entry(&bind_name) {\n+                match ret_val.entry(bind_name) {\n                     Vacant(spot) => {\n                         spot.insert(res[*idx].clone());\n                         *idx += 1;"}, {"sha": "1abb52459e493d1941f6104aac7d0240ce4d2257", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f047c8c558624e276ca36c5854b9fdcd4e5965/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=e3f047c8c558624e276ca36c5854b9fdcd4e5965", "patch": "@@ -444,7 +444,7 @@ pub fn freq_count<T, U>(mut iter: T) -> hash_map::HashMap<U, uint>\n {\n     let mut map: hash_map::HashMap<U,uint> = hash_map::HashMap::new();\n     for elem in iter {\n-        match map.entry(&elem) {\n+        match map.entry(elem) {\n             Occupied(mut entry) => { *entry.get_mut() += 1; },\n             Vacant(entry) => { entry.insert(1); },\n         }"}]}