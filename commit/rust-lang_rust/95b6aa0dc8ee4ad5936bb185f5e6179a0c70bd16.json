{"sha": "95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1YjZhYTBkYzhlZTRhZDU5MzZiYjE4NWY1ZTYxNzlhMGM3MGJkMTY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-08-19T20:20:43Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-08-19T20:20:43Z"}, "message": "Merge pull request #189 from nrc/match\n\nmatch expressions", "tree": {"sha": "65d3192294aa293259e1a7de3c307c20690cc5cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65d3192294aa293259e1a7de3c307c20690cc5cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "html_url": "https://github.com/rust-lang/rust/commit/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dbe2133fb342c0db21a583d10c2882a42f2e869", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dbe2133fb342c0db21a583d10c2882a42f2e869", "html_url": "https://github.com/rust-lang/rust/commit/8dbe2133fb342c0db21a583d10c2882a42f2e869"}, {"sha": "43ad7ad7a0f6139c25606435828d835c26091fdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/43ad7ad7a0f6139c25606435828d835c26091fdf", "html_url": "https://github.com/rust-lang/rust/commit/43ad7ad7a0f6139c25606435828d835c26091fdf"}], "stats": {"total": 645, "additions": 521, "deletions": 124}, "files": [{"sha": "14ca718e31840339303a27e536307a728367a17e", "filename": "src/comment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -127,8 +127,8 @@ impl FindUncommented for str {\n                     if b != c {\n                         needle_iter = pat.chars();\n                     }\n-                },\n-                None => return Some(i - pat.len())\n+                }\n+                None => return Some(i - pat.len()),\n             }\n \n             if possible_comment && (b == '/' || b == '*') {\n@@ -145,7 +145,7 @@ impl FindUncommented for str {\n         // Handle case where the pattern is a suffix of the search string\n         match needle_iter.next() {\n             Some(_) => None,\n-            None => Some(self.len() - pat.len())\n+            None => Some(self.len() - pat.len()),\n         }\n     }\n }"}, {"sha": "0cdaf060714dd5d233f3b198d44bb375244cc7ac", "filename": "src/expr.rs", "status": "modified", "additions": 314, "deletions": 36, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -12,7 +12,7 @@ use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n use string::{StringFormat, rewrite_string};\n use StructLitStyle;\n-use utils::{span_after, make_indent, extra_offset};\n+use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width};\n use visitor::FmtVisitor;\n use config::BlockIndentStyle;\n use comment::{FindUncommented, rewrite_comment};\n@@ -30,7 +30,7 @@ impl Rewrite for ast::Expr {\n                     ast::Lit_::LitStr(ref is, _) => {\n                         rewrite_string_lit(context, &is, l.span, width, offset)\n                     }\n-                    _ => context.codemap.span_to_snippet(self.span).ok()\n+                    _ => context.codemap.span_to_snippet(self.span).ok(),\n                 }\n             }\n             ast::Expr_::ExprCall(ref callee, ref args) => {\n@@ -99,16 +99,34 @@ impl Rewrite for ast::Expr {\n                               width,\n                               offset)\n             }\n+            ast::Expr_::ExprMatch(ref cond, ref arms, _) => {\n+                rewrite_match(context, cond, arms, width, offset)\n+            }\n             ast::Expr_::ExprPath(ref qself, ref path) => {\n                 rewrite_path(context, qself.as_ref(), path, width, offset)\n             }\n-            _ => context.codemap.span_to_snippet(self.span).ok()\n+            // FIXME #184 Note that this formatting is broken due to a bad span\n+            // from the parser.\n+            // `continue`\n+            ast::Expr_::ExprAgain(ref opt_ident) => {\n+                let id_str = match *opt_ident {\n+                    Some(ident) => format!(\" {}\", ident),\n+                    None => String::new(),\n+                };\n+                Some(format!(\"continue{}\", id_str))\n+            }\n+            _ => context.codemap.span_to_snippet(self.span).ok(),\n         }\n     }\n }\n \n impl Rewrite for ast::Block {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        let user_str = context.codemap.span_to_snippet(self.span).unwrap();\n+        if user_str == \"{}\" && width >= 2 {\n+            return Some(user_str);\n+        }\n+\n         let mut visitor = FmtVisitor::from_codemap(context.codemap, context.config);\n         visitor.block_indent = context.block_indent;\n \n@@ -147,7 +165,7 @@ impl Rewrite for ast::Block {\n     }\n }\n \n-// TODO(#18): implement pattern formatting\n+// FIXME(#18): implement pattern formatting\n impl Rewrite for ast::Pat {\n     fn rewrite(&self, context: &RewriteContext, _: usize, _: usize) -> Option<String> {\n         context.codemap.span_to_snippet(self.span).ok()\n@@ -191,7 +209,7 @@ impl<'a> Loop<'a> {\n             keyword: \"while \",\n             matcher: match pat {\n                 Some(..) => \"let \",\n-                None => \"\"\n+                None => \"\",\n             },\n             connector: \" =\",\n         }\n@@ -229,7 +247,7 @@ impl<'a> Rewrite for Loop<'a> {\n                                                     self.connector,\n                                                     inner_width,\n                                                     inner_offset)),\n-            None => String::new()\n+            None => String::new(),\n         };\n \n         // FIXME: this drops any comment between \"loop\" and the block.\n@@ -242,7 +260,7 @@ impl<'a> Rewrite for Loop<'a> {\n fn rewrite_label(label: Option<ast::Ident>) -> String {\n     match label {\n         Some(ident) => format!(\"{}: \", ident),\n-        None => \"\".to_owned()\n+        None => \"\".to_owned(),\n     }\n }\n \n@@ -254,9 +272,8 @@ fn rewrite_range(context: &RewriteContext,\n                  offset: usize)\n                  -> Option<String> {\n     let left_string = match left {\n-        // 2 = ..\n         Some(expr) => try_opt!(expr.rewrite(context, width - 2, offset)),\n-        None => String::new()\n+        None => String::new(),\n     };\n \n     let right_string = match right {\n@@ -265,7 +282,7 @@ fn rewrite_range(context: &RewriteContext,\n             let max_width = (width - 2).checked_sub(left_string.len()).unwrap_or(0);\n             try_opt!(expr.rewrite(context, max_width, offset + 2 + left_string.len()))\n         }\n-        None => String::new()\n+        None => String::new(),\n     };\n \n     Some(format!(\"{}..{}\", left_string, right_string))\n@@ -303,6 +320,251 @@ fn rewrite_if_else(context: &RewriteContext,\n     Some(result)\n }\n \n+fn rewrite_match(context: &RewriteContext,\n+                 cond: &ast::Expr,\n+                 arms: &[ast::Arm],\n+                 width: usize,\n+                 offset: usize)\n+                 -> Option<String> {\n+    if arms.len() == 0 {\n+        return None;\n+    }\n+\n+    // `match `cond` {`\n+    let cond_str = try_opt!(cond.rewrite(context, width - 8, offset + 6));\n+    let mut result = format!(\"match {} {{\", cond_str);\n+\n+    let block_indent = context.block_indent;\n+    let nested_context = context.nested_context();\n+    let arm_indent_str = make_indent(nested_context.block_indent);\n+\n+    let open_brace_pos = span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])),\n+                                    \"{\",\n+                                    context.codemap);\n+\n+    for (i, arm) in arms.iter().enumerate() {\n+        // Make sure we get the stuff between arms.\n+        let missed_str = if i == 0 {\n+            context.codemap.span_to_snippet(mk_sp(open_brace_pos + BytePos(1),\n+                                                  arm_start_pos(arm))).unwrap()\n+        } else {\n+            context.codemap.span_to_snippet(mk_sp(arm_end_pos(&arms[i-1]),\n+                                                  arm_start_pos(arm))).unwrap()\n+        };\n+        let missed_str = match missed_str.find_uncommented(\",\") {\n+            Some(n) => &missed_str[n+1..],\n+            None => &missed_str[..],\n+        };\n+        // first = first non-whitespace byte index.\n+        let first = missed_str.find(|c: char| !c.is_whitespace()).unwrap_or(missed_str.len());\n+        if missed_str[..first].chars().filter(|c| c == &'\\n').count() >= 2 {\n+            // There were multiple line breaks which got trimmed to nothing\n+            // that means there should be some vertical white space. Lets\n+            // replace that with just one blank line.\n+            result.push('\\n');\n+        }\n+        let missed_str = missed_str.trim();\n+        if missed_str.len() > 0 {\n+            result.push('\\n');\n+            result.push_str(&arm_indent_str);\n+            result.push_str(missed_str);\n+        }\n+        result.push('\\n');\n+        result.push_str(&arm_indent_str);\n+\n+        let arm_str = arm.rewrite(&nested_context,\n+                                  context.config.max_width -\n+                                      nested_context.block_indent,\n+                                  nested_context.block_indent);\n+        if let Some(ref arm_str) = arm_str {\n+            result.push_str(arm_str);\n+        } else {\n+            // We couldn't format the arm, just reproduce the source.\n+            let snippet = context.codemap.span_to_snippet(mk_sp(arm_start_pos(arm),\n+                                                                arm_end_pos(arm))).unwrap();\n+            result.push_str(&snippet);\n+        }\n+    }\n+\n+    // We'll miss any comments etc. between the last arm and the end of the\n+    // match expression, but meh.\n+\n+    result.push('\\n');\n+    result.push_str(&make_indent(block_indent));\n+    result.push('}');\n+    Some(result)\n+}\n+\n+fn arm_start_pos(arm: &ast::Arm) -> BytePos {\n+    let &ast::Arm { ref attrs, ref pats, .. } = arm;\n+    if attrs.len() > 0 {\n+        return attrs[0].span.lo\n+    }\n+\n+    pats[0].span.lo\n+}\n+\n+fn arm_end_pos(arm: &ast::Arm) -> BytePos {\n+    arm.body.span.hi\n+}\n+\n+// Match arms.\n+impl Rewrite for ast::Arm {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        let &ast::Arm { ref attrs, ref pats, ref guard, ref body } = self;\n+        let indent_str = make_indent(offset);\n+\n+        // FIXME this is all a bit grotty, would be nice to abstract out the\n+        // treatment of attributes.\n+        let attr_str = if attrs.len() > 0 {\n+            // We only use this visitor for the attributes, should we use it for\n+            // more?\n+            let mut attr_visitor = FmtVisitor::from_codemap(context.codemap, context.config);\n+            attr_visitor.block_indent = context.block_indent;\n+            attr_visitor.last_pos = attrs[0].span.lo;\n+            if attr_visitor.visit_attrs(attrs) {\n+                // Attributes included a skip instruction.\n+                let snippet = context.codemap.span_to_snippet(mk_sp(attrs[0].span.lo,\n+                                                                    body.span.hi)).unwrap();\n+                return Some(snippet);\n+            }\n+            attr_visitor.format_missing(pats[0].span.lo);\n+            attr_visitor.buffer.to_string()\n+        } else {\n+            String::new()\n+        };\n+\n+        // Patterns\n+        let pat_strs = try_opt!(pats.iter().map(|p| p.rewrite(context,\n+                                                     // 5 = ` => {`\n+                                                     width - 5,\n+                                                     offset + context.config.tab_spaces))\n+                                           .collect::<Option<Vec<_>>>());\n+\n+        let mut total_width = pat_strs.iter().fold(0, |a, p| a + p.len());\n+        // Add ` | `.len().\n+        total_width += (pat_strs.len() - 1) * 3;\n+\n+        let mut vertical = total_width > width - 5 || pat_strs.iter().any(|p| p.contains('\\n'));\n+        if !vertical {\n+            // If the patterns were previously stacked, keep them stacked.\n+            // FIXME should be an option.\n+            let pat_span = mk_sp(pats[0].span.lo, pats[pats.len() - 1].span.hi);\n+            let pat_str = context.codemap.span_to_snippet(pat_span).unwrap();\n+            vertical = pat_str.find('\\n').is_some();\n+        }\n+\n+\n+        let pats_width = if vertical {\n+            pat_strs[pat_strs.len() - 1].len()\n+        } else {\n+            total_width\n+        };\n+\n+        let mut pats_str = String::new();\n+        for p in pat_strs {\n+            if pats_str.len() > 0 {\n+                if vertical {\n+                    pats_str.push_str(\" |\\n\");\n+                    pats_str.push_str(&indent_str);\n+                } else {\n+                    pats_str.push_str(\" | \");\n+                }\n+            }\n+            pats_str.push_str(&p);\n+        }\n+\n+        let guard_str = try_opt!(rewrite_guard(context, guard, width, offset, pats_width));\n+\n+        let pats_str = format!(\"{}{}\", pats_str, guard_str);\n+        // Where the next text can start.\n+        let mut line_start = last_line_width(&pats_str);\n+        if pats_str.find('\\n').is_none() {\n+            line_start += offset;\n+        }\n+\n+        let comma = if let ast::ExprBlock(_) = body.node {\n+            \"\"\n+        } else {\n+            \",\"\n+        };\n+        let nested_indent = context.block_indent + context.config.tab_spaces;\n+\n+        // Let's try and get the arm body on the same line as the condition.\n+        // 4 = ` => `.len()\n+        if context.config.max_width > line_start + comma.len() + 4 {\n+            let budget = context.config.max_width - line_start - comma.len() - 4;\n+            if let Some(ref body_str) = body.rewrite(context,\n+                                                     budget,\n+                                                     nested_indent) {\n+                if first_line_width(body_str) <= budget {\n+                    return Some(format!(\"{}{} => {}{}\",\n+                                        attr_str.trim_left(),\n+                                        pats_str,\n+                                        body_str,\n+                                        comma));\n+                }\n+            }\n+        }\n+\n+        // We have to push the body to the next line.\n+        if comma.len() == 0 {\n+            // We're trying to fit a block in, but it still failed, give up.\n+            return None;\n+        }\n+\n+        let body_str = try_opt!(body.rewrite(context,\n+                                             width - context.config.tab_spaces,\n+                                             nested_indent));\n+        Some(format!(\"{}{} =>\\n{}{},\",\n+                     attr_str.trim_left(),\n+                     pats_str,\n+                     make_indent(offset + context.config.tab_spaces),\n+                     body_str))\n+    }\n+}\n+\n+// The `if ...` guard on a match arm.\n+fn rewrite_guard(context: &RewriteContext,\n+                 guard: &Option<ptr::P<ast::Expr>>,\n+                 width: usize,\n+                 offset: usize,\n+                 // The amount of space used up on this line for the pattern in\n+                 // the arm (excludes offset).\n+                 pattern_width: usize)\n+                 -> Option<String> {\n+    if let &Some(ref guard) = guard {\n+        // First try to fit the guard string on the same line as the pattern.\n+        // 4 = ` if `, 5 = ` => {`\n+        let overhead = pattern_width + 4 + 5;\n+        if overhead < width {\n+            let cond_str = guard.rewrite(context,\n+                                         width - overhead,\n+                                         offset + pattern_width + 4);\n+            if let Some(cond_str) = cond_str {\n+                return Some(format!(\" if {}\", cond_str));\n+            }\n+        }\n+\n+        // Not enough space to put the guard after the pattern, try a newline.\n+        let overhead = context.config.tab_spaces + 4 + 5;\n+        if overhead < width {\n+            let cond_str = guard.rewrite(context,\n+                                         width - overhead,\n+                                         offset + context.config.tab_spaces);\n+            if let Some(cond_str) = cond_str {\n+                return Some(format!(\"\\n{}if {}\",\n+                                    make_indent(offset + context.config.tab_spaces),\n+                                    cond_str));\n+            }\n+        }\n+\n+        None\n+    } else {\n+        Some(String::new())\n+    }\n+}\n+\n fn rewrite_pat_expr(context: &RewriteContext,\n                     pat: Option<&ast::Pat>,\n                     expr: &ast::Expr,\n@@ -319,7 +581,7 @@ fn rewrite_pat_expr(context: &RewriteContext,\n                                                   pat_offset));\n             format!(\"{}{}{}\", matcher, pat_string, connector)\n         }\n-        None => String::new()\n+        None => String::new(),\n     };\n \n     // Consider only the last line of the pat string.\n@@ -389,7 +651,7 @@ fn rewrite_call(context: &RewriteContext,\n                 -> Option<String> {\n     debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n \n-    // TODO using byte lens instead of char lens (and probably all over the place too)\n+    // FIXME using byte lens instead of char lens (and probably all over the place too)\n     // 2 is for parens\n     let max_callee_width = try_opt!(width.checked_sub(2));\n     let callee_str = try_opt!(callee.rewrite(context, max_callee_width, offset));\n@@ -446,7 +708,7 @@ fn rewrite_paren(context: &RewriteContext,\n                  -> Option<String> {\n     debug!(\"rewrite_paren, width: {}, offset: {}\", width, offset);\n     // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n-    // paren on the same line as the subexpr\n+    // paren on the same line as the subexpr.\n     let subexpr_str = subexpr.rewrite(context, width-2, offset+1);\n     debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n     subexpr_str.map(|s| format!(\"({})\", s))\n@@ -616,36 +878,52 @@ fn rewrite_binary_op(context: &RewriteContext,\n \n     let operator_str = context.codemap.span_to_snippet(op.span).unwrap();\n \n-    // 1 = space between lhs expr and operator\n-    let max_width = try_opt!(context.config.max_width.checked_sub(operator_str.len() + offset + 1));\n-    let mut result = try_opt!(lhs.rewrite(context, max_width, offset));\n-\n-    result.push(' ');\n-    result.push_str(&operator_str);\n-\n-    // 1 = space between operator and rhs\n-    let used_width = result.len() + 1;\n-    let remaining_width = match result.rfind('\\n') {\n-        Some(idx) => (offset + width + idx).checked_sub(used_width).unwrap_or(0),\n-        None => width.checked_sub(used_width).unwrap_or(0)\n-    };\n-\n     // Get \"full width\" rhs and see if it fits on the current line. This\n     // usually works fairly well since it tends to place operands of\n     // operations with high precendence close together.\n     let rhs_result = try_opt!(rhs.rewrite(context, width, offset));\n \n     // Second condition is needed in case of line break not caused by a\n     // shortage of space, but by end-of-line comments, for example.\n-    if rhs_result.len() > remaining_width || rhs_result.contains('\\n') {\n-        result.push('\\n');\n-        result.push_str(&make_indent(offset));\n-    } else {\n-        result.push(' ');\n-    };\n+    // Note that this is non-conservative, but its just to see if it's even\n+    // worth trying to put everything on one line.\n+    if rhs_result.len() + 2 + operator_str.len() < width && !rhs_result.contains('\\n') {\n+        // 1 = space between lhs expr and operator\n+        if let Some(mut result) = lhs.rewrite(context,\n+                                              width - 1 - operator_str.len(),\n+                                              offset) {\n \n-    result.push_str(&rhs_result);\n-    Some(result)\n+            result.push(' ');\n+            result.push_str(&operator_str);\n+            result.push(' ');\n+\n+            let remaining_width = width.checked_sub(last_line_width(&result)).unwrap_or(0);\n+\n+            if rhs_result.len() <= remaining_width {\n+                result.push_str(&rhs_result);\n+                return Some(result);\n+            }\n+\n+            if let Some(rhs_result) = rhs.rewrite(context,\n+                                                  remaining_width,\n+                                                  offset + result.len()) {\n+                if rhs_result.len() <= remaining_width {\n+                    result.push_str(&rhs_result);\n+                    return Some(result);\n+                }\n+            }\n+        }\n+    }\n+\n+    // We have to use multiple lines.\n+\n+    // Re-evaluate the lhs because we have more space now:\n+    let budget = try_opt!(context.config.max_width.checked_sub(offset + 1 + operator_str.len()));\n+    Some(format!(\"{} {}\\n{}{}\",\n+                 try_opt!(lhs.rewrite(context, budget, offset)),\n+                 operator_str,\n+                 make_indent(offset),\n+                 rhs_result))\n }\n \n fn rewrite_unary_op(context: &RewriteContext,\n@@ -659,7 +937,7 @@ fn rewrite_unary_op(context: &RewriteContext,\n         ast::UnOp::UnUniq => \"box \",\n         ast::UnOp::UnDeref => \"*\",\n         ast::UnOp::UnNot => \"!\",\n-        ast::UnOp::UnNeg => \"-\"\n+        ast::UnOp::UnNeg => \"-\",\n     };\n \n     let subexpr = try_opt!(expr.rewrite(context, width - operator_str.len(), offset));"}, {"sha": "8bb5a7285bb541a152939612c63f58f8d1e17337", "filename": "src/filemap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -58,18 +58,18 @@ fn write_file(text: &StringBuffer,\n         where T: Write\n     {\n         match config.newline_style {\n-                NewlineStyle::Unix => write!(writer, \"{}\", text),\n-                NewlineStyle::Windows => {\n-                    for (c, _) in text.chars() {\n-                        match c {\n-                            '\\n' => try!(write!(writer, \"\\r\\n\")),\n-                            '\\r' => continue,\n-                            c => try!(write!(writer, \"{}\", c)),\n-                        }\n+            NewlineStyle::Unix => write!(writer, \"{}\", text),\n+            NewlineStyle::Windows => {\n+                for (c, _) in text.chars() {\n+                    match c {\n+                        '\\n' => try!(write!(writer, \"\\r\\n\")),\n+                        '\\r' => continue,\n+                        c => try!(write!(writer, \"{}\", c)),\n                     }\n-                    Ok(())\n-                },\n+                }\n+                Ok(())\n             }\n+        }\n     }\n \n     match mode {"}, {"sha": "7d7300fb562aeb8171e3d901b1fc6d3edeef0f01", "filename": "src/imports.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -15,7 +15,8 @@ use rewrite::{Rewrite, RewriteContext};\n use syntax::ast;\n use syntax::codemap::Span;\n \n-// TODO (some day) remove unused imports, expand globs, compress many single imports into a list import\n+// TODO (some day) remove unused imports, expand globs, compress many single\n+// imports into a list import.\n \n impl Rewrite for ast::ViewPath {\n     // Returns an empty string when the ViewPath is empty (like foo::bar::{})\n@@ -39,10 +40,10 @@ impl Rewrite for ast::ViewPath {\n                 let path_str = try_opt!(path.rewrite(context, width - ident_str.len() - 4, offset));\n \n                 Some(if path.segments.last().unwrap().identifier == ident {\n-                         path_str\n-                     } else {\n-                         format!(\"{} as {}\", path_str, ident_str)\n-                     })\n+                        path_str\n+                    } else {\n+                        format!(\"{} as {}\", path_str, ident_str)\n+                    })\n             }\n         }\n     }\n@@ -81,7 +82,7 @@ pub fn rewrite_use_list(width: usize,\n     match path_list.len() {\n         0 => return None,\n         1 => return Some(rewrite_single_use_list(path_str, path_list[0])),\n-        _ => ()\n+        _ => (),\n     }\n \n     // 2 = ::\n@@ -161,7 +162,7 @@ fn move_self_to_front(items: &mut Vec<ListItem>) -> bool {\n         Some(pos) => {\n             items[0] = items.remove(pos);\n             true\n-        },\n-        None => false\n+        }\n+        None => false,\n     }\n }"}, {"sha": "e9f8255cc91a72fd3fd1f054a78d41621a2b0ffa", "filename": "src/issues.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -29,7 +29,7 @@ impl ReportTactic {\n         match *self {\n             ReportTactic::Always => true,\n             ReportTactic::Unnumbered => true,\n-            ReportTactic::Never => false\n+            ReportTactic::Never => false,\n         }\n     }\n }\n@@ -113,7 +113,7 @@ impl BadIssueSeeker {\n         match self.state {\n             Seeking::Issue { todo_idx, fixme_idx } => {\n                 self.state = self.inspect_issue(c, todo_idx, fixme_idx);\n-            },\n+            }\n             Seeking::Number { issue, part } => {\n                 let result = self.inspect_number(c, issue, part);\n \n@@ -198,19 +198,19 @@ impl BadIssueSeeker {\n                 } else {\n                     part = NumberPart::Pound;\n                 }\n-            },\n+            }\n             NumberPart::Pound => {\n                 if c == '#' {\n                     part = NumberPart::Number;\n                 }\n-            },\n+            }\n             NumberPart::Number => {\n                 if c >= '0' && c <= '9' {\n                     part = NumberPart::CloseParen;\n                 } else {\n                     return IssueClassification::Bad(issue);\n                 }\n-            },\n+            }\n             NumberPart::CloseParen => {}\n         }\n "}, {"sha": "79d374f85ecc1d053389f4c24c526fb0464707e2", "filename": "src/items.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -411,10 +411,8 @@ impl<'a> FmtVisitor<'a> {\n \n                     result.push('(');\n \n-                    let indent = self.block_indent\n-                                 + vis.len()\n-                                 + field.node.name.to_string().len()\n-                                 + 1; // Open paren\n+                    let indent = self.block_indent + vis.len() + field.node.name.to_string().len() +\n+                                 1; // Open paren\n \n                     let comma_cost = if self.config.enum_trailing_comma {\n                         1\n@@ -449,7 +447,7 @@ impl<'a> FmtVisitor<'a> {\n                 }\n \n                 result\n-            },\n+            }\n             ast::VariantKind::StructVariantKind(ref struct_def) => {\n                 // TODO Should limit the width, as we have a trailing comma\n                 self.format_struct(\"\",\n@@ -491,7 +489,7 @@ impl<'a> FmtVisitor<'a> {\n \n         let is_tuple = match struct_def.fields[0].node.kind {\n             ast::StructFieldKind::NamedField(..) => false,\n-            ast::StructFieldKind::UnnamedField(..) => true\n+            ast::StructFieldKind::UnnamedField(..) => true,\n         };\n \n         let (opener, terminator) = if is_tuple {\n@@ -506,7 +504,7 @@ impl<'a> FmtVisitor<'a> {\n                                             offset + header_str.len(),\n                                             codemap::mk_sp(span.lo,\n                                                            struct_def.fields[0].span.lo)),\n-            None => opener.to_owned()\n+            None => opener.to_owned(),\n         };\n         result.push_str(&generics_str);\n \n@@ -632,7 +630,7 @@ impl<'a> FmtVisitor<'a> {\n         };\n         let vis = match field.node.kind {\n             ast::StructFieldKind::NamedField(_, vis) |\n-            ast::StructFieldKind::UnnamedField(vis) => format_visibility(vis)\n+            ast::StructFieldKind::UnnamedField(vis) => format_visibility(vis),\n         };\n         let typ = pprust::ty_to_string(&field.node.ty);\n \n@@ -645,7 +643,7 @@ impl<'a> FmtVisitor<'a> {\n \n         match name {\n             Some(name) => format!(\"{}{}{}: {}\", attr_str, vis, name, typ),\n-            None => format!(\"{}{}{}\", attr_str, vis, typ)\n+            None => format!(\"{}{}{}\", attr_str, vis, typ),\n         }\n     }\n \n@@ -799,8 +797,7 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf, args: &[ast::Arg]) -\n \n             // this hacky solution caused by absence of `Mutability` in `SelfValue`.\n             let mut_str = {\n-                if let ast::Pat_::PatIdent(ast::BindingMode::BindByValue(mutability), _, _)\n-                        = args[0].pat.node {\n+                if let ast::Pat_::PatIdent(ast::BindingMode::BindByValue(mutability), _, _) = args[0].pat.node {\n                     format_mutability(mutability)\n                 } else {\n                     panic!(\"there is a bug or change in structure of AST, aborting.\");\n@@ -809,7 +806,7 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf, args: &[ast::Arg]) -\n \n             Some(format!(\"{}self\", mut_str))\n         }\n-        _ => None\n+        _ => None,\n     }\n }\n "}, {"sha": "4efd919649a5bd3b5a8b5f2edc7d4df0e860ff8a", "filename": "src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -11,7 +11,8 @@\n #![feature(rustc_private)]\n #![feature(str_escape)]\n #![feature(str_char)]\n-\n+#![feature(custom_attribute)]\n+#![allow(unused_attributes)]\n \n // TODO we're going to allocate a whole bunch of temp Strings, is it worth\n // keeping some scratch mem for this and running our own StrPool?\n@@ -92,7 +93,7 @@ impl FromStr for WriteMode {\n             \"replace\" => Ok(WriteMode::Replace),\n             \"display\" => Ok(WriteMode::Display),\n             \"overwrite\" => Ok(WriteMode::Overwrite),\n-            _ => Err(())\n+            _ => Err(()),\n         }\n     }\n }\n@@ -227,6 +228,8 @@ fn fmt_ast(krate: &ast::Crate, codemap: &CodeMap, config: &Config) -> FileMap {\n // Formatting done on a char by char or line by line basis.\n // TODO warn on bad license\n // TODO other stuff for parity with make tidy\n+// FIXME skipping due to `continue`, #184.\n+#[rustfmt_skip]\n fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n     let mut truncate_todo = Vec::new();\n     let mut report = FormatReport { file_error_map: HashMap::new() };"}, {"sha": "eadefe2e0fb3eac9b973abc8d387115532d091a5", "filename": "src/lists.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -213,7 +213,8 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> St\n             let comment = item.post_comment.as_ref().unwrap();\n             // Use block-style only for the last item or multiline comments.\n             let block_style = !formatting.ends_with_newline && last ||\n-                              comment.trim().contains('\\n') || comment.trim().len() > width;\n+                              comment.trim().contains('\\n') ||\n+                              comment.trim().len() > width;\n \n             let formatted_comment = rewrite_comment(comment, block_style, width, offset);\n \n@@ -381,7 +382,7 @@ fn comment_len(comment: &Option<String>) -> usize {\n             } else {\n                 text_len\n             }\n-        },\n-        &None => 0\n+        }\n+        &None => 0,\n     }\n }"}, {"sha": "681bb1c8ade55eb8ecb7031cc888855264826541", "filename": "src/modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -67,6 +67,6 @@ fn module_file(id: ast::Ident,\n \n     match parser::Parser::default_submod_path(id, &dir_path, codemap).result {\n         Ok(parser::ModulePathSuccess { path, .. }) => path,\n-        Err(_) => panic!(\"Couldn't find module {}\", id)\n+        Err(_) => panic!(\"Couldn't find module {}\", id),\n     }\n }"}, {"sha": "d30d81a4885c3336d44edc7ef87fc8cbd7fb230d", "filename": "src/rewrite.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -30,3 +30,13 @@ pub struct RewriteContext<'a> {\n     pub config: &'a Config,\n     pub block_indent: usize,\n }\n+\n+impl<'a> RewriteContext<'a> {\n+    pub fn nested_context(&self) -> RewriteContext<'a> {\n+        RewriteContext {\n+            codemap: self.codemap,\n+            config: self.config,\n+            block_indent: self.block_indent + self.config.tab_spaces,\n+        }\n+    }\n+}"}, {"sha": "3bdb08cc0d282dcc29994317853a81ca15f28be3", "filename": "src/types.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -146,6 +146,8 @@ impl<'a> fmt::Display for SegmentParam<'a> {\n // We'd really rather not do this, but there doesn't seem to be an alternative\n // at this point.\n // FIXME: fails with spans containing comments with the characters < or :\n+// FIXME #184 skip due to continue.\n+#[rustfmt_skip]\n fn get_path_separator(codemap: &CodeMap,\n                       path_start: BytePos,\n                       segment_start: BytePos)\n@@ -155,7 +157,7 @@ fn get_path_separator(codemap: &CodeMap,\n \n     for c in snippet.chars().rev() {\n         if c == ':' {\n-            return \"::\"\n+            return \"::\";\n         } else if c.is_whitespace() || c == '<' {\n             continue;\n         } else {\n@@ -235,7 +237,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n         ast::PathParameters::ParenthesizedParameters(ref data) => {\n             let output = match data.output {\n                 Some(ref ty) => format!(\" -> {}\", pprust::ty_to_string(&*ty)),\n-                None => String::new()\n+                None => String::new(),\n             };\n \n             let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi), \"(\", context.codemap);\n@@ -267,7 +269,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n \n             format!(\"({}){}\", write_list(&items.collect::<Vec<_>>(), &fmt), output)\n         }\n-        _ => String::new()\n+        _ => String::new(),\n     };\n \n     Some(format!(\"{}{}\", segment.identifier, params))\n@@ -278,57 +280,57 @@ impl Rewrite for ast::WherePredicate {\n         // TODO dead spans?\n         // TODO assumes we'll always fit on one line...\n         Some(match self {\n-            &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n+                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n                                                                           ref bounded_ty,\n                                                                           ref bounds,\n                                                                           ..}) => {\n-                if bound_lifetimes.len() > 0 {\n-                    let lifetime_str = bound_lifetimes.iter().map(|lt| {\n+                    if bound_lifetimes.len() > 0 {\n+                        let lifetime_str = bound_lifetimes.iter().map(|lt| {\n                                            lt.rewrite(context, width, offset).unwrap()\n                                        }).collect::<Vec<_>>().join(\", \");\n-                    let type_str = pprust::ty_to_string(bounded_ty);\n+                        let type_str = pprust::ty_to_string(bounded_ty);\n                     // 8 = \"for<> : \".len()\n-                    let used_width = lifetime_str.len() + type_str.len() + 8;\n-                    let bounds_str = bounds.iter().map(|ty_bound| {\n+                        let used_width = lifetime_str.len() + type_str.len() + 8;\n+                        let bounds_str = bounds.iter().map(|ty_bound| {\n                                          ty_bound.rewrite(context,\n                                                           width - used_width,\n                                                           offset + used_width)\n                                                  .unwrap()\n                                      }).collect::<Vec<_>>().join(\" + \");\n \n-                    format!(\"for<{}> {}: {}\", lifetime_str, type_str, bounds_str)\n-                } else {\n-                    let type_str = pprust::ty_to_string(bounded_ty);\n+                        format!(\"for<{}> {}: {}\", lifetime_str, type_str, bounds_str)\n+                    } else {\n+                        let type_str = pprust::ty_to_string(bounded_ty);\n                     // 2 = \": \".len()\n-                    let used_width = type_str.len() + 2;\n-                    let bounds_str = bounds.iter().map(|ty_bound| {\n+                        let used_width = type_str.len() + 2;\n+                        let bounds_str = bounds.iter().map(|ty_bound| {\n                                          ty_bound.rewrite(context,\n                                                           width - used_width,\n                                                           offset + used_width)\n                                                  .unwrap()\n                                      }).collect::<Vec<_>>().join(\" + \");\n \n-                    format!(\"{}: {}\", type_str, bounds_str)\n+                        format!(\"{}: {}\", type_str, bounds_str)\n+                    }\n                 }\n-            }\n-            &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+                &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n                                                                             ref bounds,\n                                                                             ..}) => {\n-                format!(\"{}: {}\",\n+                    format!(\"{}: {}\",\n                         pprust::lifetime_to_string(lifetime),\n                         bounds.iter().map(pprust::lifetime_to_string)\n                               .collect::<Vec<_>>().join(\" + \"))\n-            }\n-            &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                let ty_str = pprust::ty_to_string(ty);\n+                }\n+                &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n+                    let ty_str = pprust::ty_to_string(ty);\n                 // 3 = \" = \".len()\n-                let used_width = 3 + ty_str.len();\n-                let path_str = try_opt!(path.rewrite(context,\n+                    let used_width = 3 + ty_str.len();\n+                    let path_str = try_opt!(path.rewrite(context,\n                                                      width - used_width,\n                                                      offset + used_width));\n-                format!(\"{} = {}\", path_str, ty_str)\n-            }\n-        })\n+                    format!(\"{} = {}\", path_str, ty_str)\n+                }\n+            })\n     }\n }\n "}, {"sha": "00e18c3a65b47e397a507231128951698522be30", "filename": "src/utils.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -21,7 +21,7 @@ pub fn extra_offset(text: &str, offset: usize) -> usize {\n     match text.rfind('\\n') {\n         // 1 for newline character\n         Some(idx) => text.len() - idx - 1 - offset,\n-        None => text.len()\n+        None => text.len(),\n     }\n }\n \n@@ -70,18 +70,37 @@ pub fn make_indent(width: usize) -> String {\n pub fn format_visibility(vis: Visibility) -> &'static str {\n     match vis {\n         Visibility::Public => \"pub \",\n-        Visibility::Inherited => \"\"\n+        Visibility::Inherited => \"\",\n     }\n }\n \n #[inline]\n pub fn format_mutability(mutability: ast::Mutability) -> &'static str {\n     match mutability {\n         ast::Mutability::MutMutable => \"mut \",\n-        ast::Mutability::MutImmutable => \"\"\n+        ast::Mutability::MutImmutable => \"\",\n     }\n }\n \n+// The width of the first line in s.\n+#[inline]\n+pub fn first_line_width(s: &str) -> usize {\n+    match s.find('\\n') {\n+        Some(n) => n,\n+        None => s.len(),\n+    }\n+}\n+\n+// The width of the last line in s.\n+#[inline]\n+pub fn last_line_width(s: &str) -> usize {\n+    match s.rfind('\\n') {\n+        Some(n) => s.len() - n - 1,\n+        None => s.len(),\n+    }\n+}\n+\n+#[inline]\n fn is_skip(meta_item: &MetaItem) -> bool {\n     match meta_item.node {\n         MetaItem_::MetaWord(ref s) => *s == SKIP_ANNOTATION,\n@@ -95,6 +114,7 @@ pub fn contains_skip(attrs: &[Attribute]) -> bool {\n }\n \n // Find the end of a TyParam\n+#[inline]\n pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n     typaram.bounds.last().map(|bound| match *bound {\n         ast::RegionTyParamBound(ref lt) => lt.span,"}, {"sha": "86b1197822b454872e20e41554b234461807ede5", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -351,7 +351,7 @@ impl<'a> FmtVisitor<'a> {\n                 let prev_span = codemap::mk_sp(self.last_pos, span.lo);\n                 let span_end = match self.snippet(prev_span).rfind('\\n') {\n                     Some(offset) => self.last_pos + BytePos(offset as u32),\n-                    None => span.lo\n+                    None => span.lo,\n                 };\n                 self.format_missing(span_end);\n                 self.last_pos = span.hi;"}, {"sha": "6b3b3daf0a96e5ea1e2350508d7cef85b467996d", "filename": "tests/source/expr.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/tests%2Fsource%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/tests%2Fsource%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -91,3 +91,16 @@ fn baz() {\n         // Regular unsafe block\n     }\n }\n+\n+// Test some empty blocks.\n+fn qux() {\n+    {}\n+    // FIXME this one could be done better.\n+    { /* a block with a comment */ }\n+    {\n+\n+    }\n+    {\n+        // A block with a comment.\n+    }\n+}"}, {"sha": "c7f7da71831be088d022f2297afb3d81ff8300dc", "filename": "tests/source/loop.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/tests%2Fsource%2Floop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/tests%2Fsource%2Floop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Floop.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -21,5 +21,8 @@ let x = loop { do_forever(); };\n     while let  Some(i) =     x.find('s')\n     {\n         x.update();\n+        // FIXME #184\n+        // continue;\n+        // continue 'foo;\n     }\n }"}, {"sha": "dfbf0032011216426d02f8916667dc7ea78c43e0", "filename": "tests/target/expr.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -5,8 +5,8 @@ fn foo() -> bool {\n     let referenced = &5;\n \n     let very_long_variable_name = (a + first + simple + test);\n-    let very_long_variable_name = (a + first + simple + test + AAAAAAAAAAAAA + BBBBBBBBBBBBBBBBB +\n-                                   b + c);\n+    let very_long_variable_name = (a + first + simple + test + AAAAAAAAAAAAA +\n+                                   BBBBBBBBBBBBBBBBB + b + c);\n \n     //FIXME this exceeds width limit. Needs assignments reformatting\n     let is_internalxxxx = self.codemap.span_to_filename(s) == self.codemap.span_to_filename(m.inner);\n@@ -15,22 +15,22 @@ fn foo() -> bool {\n                    (bbbbbb - function_call(x, *very_long_pointer, y)) + 1000;\n \n     some_ridiculously_loooooooooooooooooooooong_function(10000 * 30000000000 +\n-                                                         40000 / 1002200000000 - 50000 * sqrt(-1),\n+                                                         40000 / 1002200000000 -\n+                                                         50000 * sqrt(-1),\n                                                          trivial_value);\n     (((((((((aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n-             a + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n+             a +\n+             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n              aaaaa)))))))));\n \n     {\n-        for _ in 0..10 {\n-        }\n+        for _ in 0..10 {}\n     }\n \n     {\n         {\n             {\n-                {\n-                }\n+                {}\n             }\n         }\n     }\n@@ -47,17 +47,15 @@ fn foo() -> bool {\n     }\n \n     if let Some(x) = (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n-                      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\n-    }\n+                      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n \n     if let (some_very_large,\n             tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple) = 1 + 2 + 3 {\n     }\n \n     if let (some_very_large,\n             tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple) = 1111 +\n-                                                                                         2222 {\n-    }\n+                                                                                         2222 {}\n \n     if let (some_very_large, tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple) =\n            1 + 2 + 3 {\n@@ -121,3 +119,17 @@ fn baz() {\n         // Regular unsafe block\n     }\n }\n+\n+// Test some empty blocks.\n+fn qux() {\n+    {}\n+    // FIXME this one could be done better.\n+    { /* a block with a comment */\n+    }\n+    {\n+\n+    }\n+    {\n+        // A block with a comment.\n+    }\n+}"}, {"sha": "648fe826e8f4aa7567a87e71da13703308f9c1be", "filename": "tests/target/loop.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/tests%2Ftarget%2Floop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/tests%2Ftarget%2Floop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Floop.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -13,8 +13,7 @@ fn main() {\n     }\n \n     'a: while loooooooooooooooooooooooooooooooooong_variable_name + another_value >\n-              some_other_value {\n-    }\n+              some_other_value {}\n \n     while aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa > bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb {\n     }\n@@ -26,5 +25,8 @@ fn main() {\n \n     while let Some(i) = x.find('s') {\n         x.update();\n+        // FIXME #184\n+        // continue;\n+        // continue 'foo;\n     }\n }"}, {"sha": "e5f1fad967a92ae4e850e3984769918e44609861", "filename": "tests/target/match.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "patch": "@@ -0,0 +1,55 @@\n+// Match expressions.\n+\n+fn foo() {\n+    // A match expression.\n+    match x {\n+        // Some comment.\n+        a => foo(),\n+        b if 0 < 42 => foo(),\n+        c => { // Another comment.\n+            // Comment.\n+            an_expression;\n+            foo()\n+        }\n+        // Perhaps this should introduce braces?\n+        Foo(ref bar) =>\n+            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        Pattern1 | Pattern2 | Pattern3 => false,\n+        Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn |\n+        Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => {\n+            blah\n+        }\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn => meh,\n+\n+        Patternnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnn if looooooooooooooooooong_guard => meh,\n+\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn |\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn if looooooooooooooooooooooooooooooooooooooooong_guard =>\n+            meh,\n+\n+        // Test that earlier patterns can take the guard space\n+        (aaaa, bbbbb, ccccccc, aaaaa, bbbbbbbb, cccccc, aaaa, bbbbbbbb, cccccc, dddddd) |\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn if loooooooooooooooooooooooooooooooooooooooooong_guard => {}\n+\n+        _ => {}\n+        ast::PathParameters::AngleBracketedParameters(ref data) if data.lifetimes.len() > 0 ||\n+                                                                   data.types.len() > 0 ||\n+                                                                   data.bindings.len() > 0 => {\n+        }\n+    }\n+\n+    let whatever = match something {\n+        /// DOC COMMENT!\n+        Some(_) => 42,\n+        // Comment on an attribute.\n+        #[an_attribute]\n+        // Comment after an attribute.\n+        None => 0,\n+        #[rustfmt_skip]\n+        Blurb     =>     {                  }\n+    };\n+}"}]}