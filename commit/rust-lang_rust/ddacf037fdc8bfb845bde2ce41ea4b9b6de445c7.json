{"sha": "ddacf037fdc8bfb845bde2ce41ea4b9b6de445c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYWNmMDM3ZmRjOGJmYjg0NWJkZTJjZTQxZWE0YjliNmRlNDQ1Yzc=", "commit": {"author": {"name": "C Jones", "email": "code@calebjones.net", "date": "2018-05-01T20:37:07Z"}, "committer": {"name": "C Jones", "email": "code@calebjones.net", "date": "2018-05-08T02:14:34Z"}, "message": "Make into_key_slice avoid taking out-of-bounds pointers", "tree": {"sha": "a6da5b437ea3737b737169f425e0a485ee8a7883", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6da5b437ea3737b737169f425e0a485ee8a7883"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddacf037fdc8bfb845bde2ce41ea4b9b6de445c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddacf037fdc8bfb845bde2ce41ea4b9b6de445c7", "html_url": "https://github.com/rust-lang/rust/commit/ddacf037fdc8bfb845bde2ce41ea4b9b6de445c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddacf037fdc8bfb845bde2ce41ea4b9b6de445c7/comments", "author": {"login": "porglezomp", "id": 1690225, "node_id": "MDQ6VXNlcjE2OTAyMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1690225?v=4", "gravatar_id": "", "url": "https://api.github.com/users/porglezomp", "html_url": "https://github.com/porglezomp", "followers_url": "https://api.github.com/users/porglezomp/followers", "following_url": "https://api.github.com/users/porglezomp/following{/other_user}", "gists_url": "https://api.github.com/users/porglezomp/gists{/gist_id}", "starred_url": "https://api.github.com/users/porglezomp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/porglezomp/subscriptions", "organizations_url": "https://api.github.com/users/porglezomp/orgs", "repos_url": "https://api.github.com/users/porglezomp/repos", "events_url": "https://api.github.com/users/porglezomp/events{/privacy}", "received_events_url": "https://api.github.com/users/porglezomp/received_events", "type": "User", "site_admin": false}, "committer": {"login": "porglezomp", "id": 1690225, "node_id": "MDQ6VXNlcjE2OTAyMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1690225?v=4", "gravatar_id": "", "url": "https://api.github.com/users/porglezomp", "html_url": "https://github.com/porglezomp", "followers_url": "https://api.github.com/users/porglezomp/followers", "following_url": "https://api.github.com/users/porglezomp/following{/other_user}", "gists_url": "https://api.github.com/users/porglezomp/gists{/gist_id}", "starred_url": "https://api.github.com/users/porglezomp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/porglezomp/subscriptions", "organizations_url": "https://api.github.com/users/porglezomp/orgs", "repos_url": "https://api.github.com/users/porglezomp/repos", "events_url": "https://api.github.com/users/porglezomp/events{/privacy}", "received_events_url": "https://api.github.com/users/porglezomp/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b94e9f053c3fecb0e29c89e453ecaf07d97218c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b94e9f053c3fecb0e29c89e453ecaf07d97218c", "html_url": "https://github.com/rust-lang/rust/commit/5b94e9f053c3fecb0e29c89e453ecaf07d97218c"}], "stats": {"total": 48, "additions": 34, "deletions": 14}, "files": [{"sha": "ce770d384f8d58363ea01cf956e8e534e6ed53e2", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ddacf037fdc8bfb845bde2ce41ea4b9b6de445c7/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddacf037fdc8bfb845bde2ce41ea4b9b6de445c7/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=ddacf037fdc8bfb845bde2ce41ea4b9b6de445c7", "patch": "@@ -107,10 +107,12 @@ impl<K, V> LeafNode<K, V> {\n     }\n }\n \n-// We need to implement Sync here in order to make a static instance\n+// We need to implement Sync here in order to make a static instance.\n unsafe impl Sync for LeafNode<(), ()> {}\n \n-// An empty node used as a placeholder for the root node, to avoid allocations\n+// An empty node used as a placeholder for the root node, to avoid allocations.\n+// We use () in order to save space, since no operation on an empty tree will\n+// ever take a pointer past the first key.\n static EMPTY_ROOT_NODE: LeafNode<(), ()> = LeafNode {\n     parent: ptr::null(),\n     parent_idx: 0,\n@@ -539,26 +541,39 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    pub fn keys_mut(&mut self) -> &mut [K] {\n+    fn keys_mut(&mut self) -> &mut [K] {\n         unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n \n-    pub fn vals_mut(&mut self) -> &mut [V] {\n+    fn vals_mut(&mut self) -> &mut [V] {\n         unsafe { self.reborrow_mut().into_val_slice_mut() }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn into_key_slice(self) -> &'a [K] {\n-        unsafe {\n-            slice::from_raw_parts(\n-                self.as_leaf().keys.as_ptr(),\n-                self.len()\n-            )\n+        // When taking a pointer to the keys, if our key has a stricter\n+        // alignment requirement than the shared root does, then the pointer\n+        // would be out of bounds, which LLVM assumes will not happen. If the\n+        // alignment is more strict, we need to make an empty slice that doesn't\n+        // use an out of bounds pointer.\n+        if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n+            &[]\n+        } else {\n+            // Here either it's not the root, or the alignment is less strict,\n+            // in which case the keys pointer will point \"one-past-the-end\" of\n+            // the node, which is allowed by LLVM.\n+            unsafe {\n+                slice::from_raw_parts(\n+                    self.as_leaf().keys.as_ptr(),\n+                    self.len()\n+                )\n+            }\n         }\n     }\n \n     fn into_val_slice(self) -> &'a [V] {\n+        debug_assert!(!self.is_shared_root());\n         unsafe {\n             slice::from_raw_parts(\n                 self.as_leaf().vals.as_ptr(),\n@@ -583,15 +598,20 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     }\n \n     fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                &mut self.as_leaf_mut().keys as *mut [K] as *mut K,\n-                self.len()\n-            )\n+        if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n+            &mut []\n+        } else {\n+            unsafe {\n+                slice::from_raw_parts_mut(\n+                    &mut self.as_leaf_mut().keys as *mut [K] as *mut K,\n+                    self.len()\n+                )\n+            }\n         }\n     }\n \n     fn into_val_slice_mut(mut self) -> &'a mut [V] {\n+        debug_assert!(!self.is_shared_root());\n         unsafe {\n             slice::from_raw_parts_mut(\n                 &mut self.as_leaf_mut().vals as *mut [V] as *mut V,"}]}