{"sha": "6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYmI2ZmRiZWU3ZjBkMjUwZTUwZTRkODRkOWFlZGUyOTNjZjNiYjM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-12-04T01:18:11Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-12-28T09:21:45Z"}, "message": "hir: lower `ImplicitSelf` to resolved `Self` TyQPath's.", "tree": {"sha": "f40bc78586832c7af3feca2507fbc1a2b8b2316b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f40bc78586832c7af3feca2507fbc1a2b8b2316b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "html_url": "https://github.com/rust-lang/rust/commit/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0807104c8fa90b084748940f7a7980b5a765264e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0807104c8fa90b084748940f7a7980b5a765264e", "html_url": "https://github.com/rust-lang/rust/commit/0807104c8fa90b084748940f7a7980b5a765264e"}], "stats": {"total": 289, "additions": 106, "deletions": 183}, "files": [{"sha": "d1fe19364b4097cbd19ba78311b5c77e7e3a6e15", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "patch": "@@ -259,7 +259,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::Ty {\n             id: t.id,\n             node: match t.node {\n-                TyKind::Infer | TyKind::ImplicitSelf => hir::TyInfer,\n+                TyKind::Infer => hir::TyInfer,\n                 TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty)),\n                 TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n                 TyKind::Rptr(ref region, ref mt) => {\n@@ -283,6 +283,16 @@ impl<'a> LoweringContext<'a> {\n                 TyKind::Path(ref qself, ref path) => {\n                     hir::TyPath(self.lower_qpath(t.id, qself, path, ParamMode::Explicit))\n                 }\n+                TyKind::ImplicitSelf => {\n+                    hir::TyPath(hir::QPath::Resolved(None, P(hir::Path {\n+                        def: self.expect_full_def(t.id),\n+                        segments: hir_vec![hir::PathSegment {\n+                            name: keywords::SelfType.name(),\n+                            parameters: hir::PathParameters::none()\n+                        }],\n+                        span: t.span,\n+                    })))\n+                }\n                 TyKind::ObjectSum(ref ty, ref bounds) => {\n                     hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n                 }\n@@ -976,7 +986,7 @@ impl<'a> LoweringContext<'a> {\n                 ImplItemKind::Const(..) => hir::AssociatedItemKind::Const,\n                 ImplItemKind::Type(..) => hir::AssociatedItemKind::Type,\n                 ImplItemKind::Method(ref sig, _) => hir::AssociatedItemKind::Method {\n-                    has_self: sig.decl.get_self().is_some(),\n+                    has_self: sig.decl.has_self(),\n                 },\n                 ImplItemKind::Macro(..) => unimplemented!(),\n             },\n@@ -1051,24 +1061,13 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_method_sig(&mut self, sig: &MethodSig) -> hir::MethodSig {\n-        let hir_sig = hir::MethodSig {\n+        hir::MethodSig {\n             generics: self.lower_generics(&sig.generics),\n             abi: sig.abi,\n             unsafety: self.lower_unsafety(sig.unsafety),\n             constness: self.lower_constness(sig.constness),\n             decl: self.lower_fn_decl(&sig.decl),\n-        };\n-        // Check for `self: _` and `self: &_`\n-        if let Some(SelfKind::Explicit(..)) = sig.decl.get_self().map(|eself| eself.node) {\n-            match hir_sig.decl.get_self().map(|eself| eself.node) {\n-                Some(hir::SelfKind::Value(..)) | Some(hir::SelfKind::Region(..)) => {\n-                    self.diagnostic().span_err(sig.decl.inputs[0].ty.span,\n-                        \"the type placeholder `_` is not allowed within types on item signatures\");\n-                }\n-                _ => {}\n-            }\n         }\n-        hir_sig\n     }\n \n     fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {"}, {"sha": "d135762ae8204e15a204492f02d008cfb6a44cf5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "patch": "@@ -35,8 +35,8 @@ use hir::def_id::DefId;\n use util::nodemap::{NodeMap, FxHashSet};\n use rustc_data_structures::fnv::FnvHashMap;\n \n-use syntax_pos::{mk_sp, Span, ExpnId, DUMMY_SP};\n-use syntax::codemap::{self, respan, Spanned};\n+use syntax_pos::{Span, ExpnId, DUMMY_SP};\n+use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n@@ -1234,37 +1234,8 @@ pub struct Arg {\n     pub id: NodeId,\n }\n \n-/// Alternative representation for `Arg`s describing `self` parameter of methods.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum SelfKind {\n-    /// `self`, `mut self`\n-    Value(Mutability),\n-    /// `&'lt self`, `&'lt mut self`\n-    Region(Option<Lifetime>, Mutability),\n-    /// `self: TYPE`, `mut self: TYPE`\n-    Explicit(P<Ty>, Mutability),\n-}\n-\n-pub type ExplicitSelf = Spanned<SelfKind>;\n-\n impl Arg {\n-    pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Binding(BindByValue(mutbl), _, name, _) = self.pat.node {\n-            if name.node == keywords::SelfValue.name() {\n-                return match self.ty.node {\n-                    TyInfer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n-                    TyRptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyInfer => {\n-                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n-                    }\n-                    _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n-                                     SelfKind::Explicit(self.ty.clone(), mutbl)))\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n-    pub fn is_self(&self) -> bool {\n+    fn is_self(&self) -> bool {\n         if let PatKind::Binding(_, _, name, _) = self.pat.node {\n             name.node == keywords::SelfValue.name()\n         } else {\n@@ -1282,9 +1253,6 @@ pub struct FnDecl {\n }\n \n impl FnDecl {\n-    pub fn get_self(&self) -> Option<ExplicitSelf> {\n-        self.inputs.get(0).and_then(Arg::to_self)\n-    }\n     pub fn has_self(&self) -> bool {\n         self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n     }"}, {"sha": "eaed62e4dce9154173b7247fb4df57348c5d28ae", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "patch": "@@ -25,7 +25,7 @@ use syntax_pos::{self, BytePos};\n use errors;\n \n use hir;\n-use hir::{Crate, PatKind, RegionTyParamBound, SelfKind, TraitTyParamBound, TraitBoundModifier};\n+use hir::{Crate, PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n \n use std::io::{self, Write, Read};\n \n@@ -1954,27 +1954,6 @@ impl<'a> State<'a> {\n         self.end() // close enclosing cbox\n     }\n \n-    fn print_explicit_self(&mut self, explicit_self: &hir::ExplicitSelf) -> io::Result<()> {\n-        match explicit_self.node {\n-            SelfKind::Value(m) => {\n-                self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")\n-            }\n-            SelfKind::Region(ref lt, m) => {\n-                word(&mut self.s, \"&\")?;\n-                self.print_opt_lifetime(lt)?;\n-                self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")\n-            }\n-            SelfKind::Explicit(ref typ, m) => {\n-                self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")?;\n-                self.word_space(\":\")?;\n-                self.print_type(&typ)\n-            }\n-        }\n-    }\n-\n     pub fn print_fn(&mut self,\n                     decl: &hir::FnDecl,\n                     unsafety: hir::Unsafety,\n@@ -2185,21 +2164,17 @@ impl<'a> State<'a> {\n         match input.ty.node {\n             hir::TyInfer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n-                if let Some(eself) = input.to_self() {\n-                    self.print_explicit_self(&eself)?;\n+                let invalid = if let PatKind::Binding(_, _, name, _) = input.pat.node {\n+                    name.node == keywords::Invalid.name()\n                 } else {\n-                    let invalid = if let PatKind::Binding(_, _, name, _) = input.pat.node {\n-                        name.node == keywords::Invalid.name()\n-                    } else {\n-                        false\n-                    };\n-                    if !invalid {\n-                        self.print_pat(&input.pat)?;\n-                        word(&mut self.s, \":\")?;\n-                        space(&mut self.s)?;\n-                    }\n-                    self.print_type(&input.ty)?;\n+                    false\n+                };\n+                if !invalid {\n+                    self.print_pat(&input.pat)?;\n+                    word(&mut self.s, \":\")?;\n+                    space(&mut self.s)?;\n                 }\n+                self.print_type(&input.ty)?;\n             }\n         }\n         self.end()"}, {"sha": "180141d674aa74d0956b2650b8a7b5e680dab8b7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "patch": "@@ -2127,7 +2127,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let (kind, has_self, has_value) = match trait_item.node {\n             hir::MethodTraitItem(ref sig, ref body) => {\n-                (AssociatedKind::Method, sig.decl.get_self().is_some(),\n+                (AssociatedKind::Method, sig.decl.has_self(),\n                  body.is_some())\n             }\n             hir::ConstTraitItem(_, ref value) => {"}, {"sha": "63bcbfeb23d8a8e356de42a893ae4a51e9b745fb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "patch": "@@ -571,6 +571,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n         if let TyKind::Path(ref qself, ref path) = ty.node {\n             self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n+        } else if let TyKind::ImplicitSelf = ty.node {\n+            let self_ty = keywords::SelfType.ident();\n+            let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.span))\n+                          .map_or(Def::Err, |d| d.def());\n+            self.record_def(ty.id, PathResolution::new(def));\n         }\n         visit::walk_ty(self, ty);\n     }\n@@ -741,6 +746,13 @@ impl<'a> LexicalScopeBinding<'a> {\n             _ => None,\n         }\n     }\n+\n+    fn def(self) -> Def {\n+        match self {\n+            LexicalScopeBinding::Item(binding) => binding.def(),\n+            LexicalScopeBinding::Def(def) => def,\n+        }\n+    }\n }\n \n #[derive(Clone)]"}, {"sha": "7ccb0fffb7d952a13d2d94ba12a66867ce535b91", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 23, "deletions": 50, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "patch": "@@ -50,7 +50,7 @@\n \n use rustc_const_eval::eval_length;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use hir::{self, SelfKind};\n+use hir;\n use hir::def::Def;\n use hir::def_id::DefId;\n use hir::print as pprust;\n@@ -1743,36 +1743,33 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // declaration are bound to that function type.\n         let rb = MaybeWithAnonTypes::new(BindingRscope::new(), arg_anon_scope);\n \n-        // `implied_output_region` is the region that will be assumed for any\n-        // region parameters in the return type. In accordance with the rules for\n-        // lifetime elision, we can determine it in two ways. First (determined\n-        // here), if self is by-reference, then the implied output region is the\n-        // region of the self parameter.\n-        let (self_ty, explicit_self) = match (opt_untransformed_self_ty, decl.get_self()) {\n-            (Some(untransformed_self_ty), Some(explicit_self)) => {\n-                let self_type = self.determine_self_type(&rb, untransformed_self_ty,\n-                                                         &explicit_self);\n-                (Some(self_type), Some(ExplicitSelf::determine(untransformed_self_ty, self_type)))\n-            }\n-            _ => (None, None),\n-        };\n+        let input_tys: Vec<Ty> =\n+            decl.inputs.iter().map(|a| self.ty_of_arg(&rb, a, None)).collect();\n \n-        // HACK(eddyb) replace the fake self type in the AST with the actual type.\n-        let arg_params = if self_ty.is_some() {\n-            &decl.inputs[1..]\n-        } else {\n-            &decl.inputs[..]\n+        let has_self = decl.has_self();\n+        let explicit_self = match (opt_untransformed_self_ty, has_self) {\n+            (Some(untransformed_self_ty), true) => {\n+                Some(ExplicitSelf::determine(untransformed_self_ty, input_tys[0]))\n+            }\n+            _ => None\n         };\n-        let arg_tys: Vec<Ty> =\n-            arg_params.iter().map(|a| self.ty_of_arg(&rb, a, None)).collect();\n \n-        // Second, if there was exactly one lifetime (either a substitution or a\n-        // reference) in the arguments, then any anonymous regions in the output\n-        // have that lifetime.\n         let implied_output_region = match explicit_self {\n+            // `implied_output_region` is the region that will be assumed for any\n+            // region parameters in the return type. In accordance with the rules for\n+            // lifetime elision, we can determine it in two ways. First (determined\n+            // here), if self is by-reference, then the implied output region is the\n+            // region of the self parameter.\n             Some(ExplicitSelf::ByReference(region, _)) => Ok(*region),\n+\n+            // Second, if there was exactly one lifetime (either a substitution or a\n+            // reference) in the arguments, then any anonymous regions in the output\n+            // have that lifetime.\n             _ => {\n-                self.find_implied_output_region(&arg_tys,\n+                let arg_params = &decl.inputs[has_self as usize..];\n+                let arg_tys = &input_tys[has_self as usize..];\n+\n+                self.find_implied_output_region(arg_tys,\n                                                 arg_params.iter()\n                                                     .map(|a| pprust::pat_to_string(&a.pat)))\n \n@@ -1793,37 +1790,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             unsafety: unsafety,\n             abi: abi,\n             sig: ty::Binder(self.tcx().mk_fn_sig(\n-                self_ty.into_iter().chain(arg_tys),\n+                input_tys.into_iter(),\n                 output_ty,\n                 decl.variadic\n             )),\n         })\n     }\n \n-    fn determine_self_type<'a>(&self,\n-                               rscope: &RegionScope,\n-                               untransformed_self_ty: Ty<'tcx>,\n-                               explicit_self: &hir::ExplicitSelf)\n-                               -> Ty<'tcx>\n-    {\n-        match explicit_self.node {\n-            SelfKind::Value(..) => untransformed_self_ty,\n-            SelfKind::Region(ref lifetime, mutability) => {\n-                let region =\n-                    self.opt_ast_region_to_region(\n-                                             rscope,\n-                                             explicit_self.span,\n-                                             lifetime);\n-                self.tcx().mk_ref(region,\n-                    ty::TypeAndMut {\n-                        ty: untransformed_self_ty,\n-                        mutbl: mutability\n-                    })\n-            }\n-            SelfKind::Explicit(ref ast_type, _) => self.ast_ty_to_ty(rscope, &ast_type)\n-        }\n-    }\n-\n     pub fn ty_of_closure(&self,\n         unsafety: hir::Unsafety,\n         decl: &hir::FnDecl,"}, {"sha": "1536aa6def7eb7bbfd82729c6b2633955e27771e", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir;\n+use rustc::hir::{self, ImplItemKind, TraitItem_};\n use rustc::infer::{self, InferOk};\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::ty;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::hir::{ImplItemKind, TraitItem_, Ty_};\n use rustc::util::common::ErrorReported;\n \n use syntax::ast;\n@@ -456,31 +455,18 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                     _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n                 };\n \n-                impl_m_iter.zip(trait_m_iter)\n-                           .find(|&(ref impl_arg, ref trait_arg)| {\n-                               match (&impl_arg.ty.node, &trait_arg.ty.node) {\n-                                   (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n-                                   (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) => {\n-                                       impl_mt.mutbl != trait_mt.mutbl\n-                                   }\n-                                   _ => false,\n-                               }\n-                           })\n-                           .map(|(ref impl_arg, ref trait_arg)| {\n-                               match (impl_arg.to_self(), trait_arg.to_self()) {\n-                                   (Some(impl_self), Some(trait_self)) => {\n-                                       (impl_self.span, Some(trait_self.span))\n-                                   }\n-                                   (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n-                                   _ => {\n-                                       bug!(\"impl and trait fns have different first args, impl: \\\n-                                             {:?}, trait: {:?}\",\n-                                            impl_arg,\n-                                            trait_arg)\n-                                   }\n-                               }\n-                           })\n-                           .unwrap_or((cause.span, tcx.map.span_if_local(trait_m.def_id)))\n+                impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n+                    match (&impl_arg.ty.node, &trait_arg.ty.node) {\n+                        (&hir::TyRptr(_, ref impl_mt), &hir::TyRptr(_, ref trait_mt)) |\n+                        (&hir::TyPtr(ref impl_mt), &hir::TyPtr(ref trait_mt)) => {\n+                            impl_mt.mutbl != trait_mt.mutbl\n+                        }\n+                        _ => false,\n+                    }\n+                }).map(|(ref impl_arg, ref trait_arg)| {\n+                    (impl_arg.ty.span, Some(trait_arg.ty.span))\n+                })\n+                .unwrap_or_else(|| (cause.span, tcx.map.span_if_local(trait_m.def_id)))\n             } else {\n                 (cause.span, tcx.map.span_if_local(trait_m.def_id))\n             }"}, {"sha": "a0071fe25cb1f6227df850f4419dcf4fcb84af03", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "patch": "@@ -1184,16 +1184,17 @@ pub enum SelfTy {\n \n impl Argument {\n     pub fn to_self(&self) -> Option<SelfTy> {\n-        if self.name == \"self\" {\n-            match self.type_ {\n-                Infer => Some(SelfValue),\n-                BorrowedRef{ref lifetime, mutability, ref type_} if **type_ == Infer => {\n-                    Some(SelfBorrowed(lifetime.clone(), mutability))\n-                }\n-                _ => Some(SelfExplicit(self.type_.clone()))\n+        if self.name != \"self\" {\n+            return None;\n+        }\n+        if self.type_.is_self_type() {\n+            return Some(SelfValue);\n+        }\n+        match self.type_ {\n+            BorrowedRef{ref lifetime, mutability, ref type_} if type_.is_self_type() => {\n+                Some(SelfBorrowed(lifetime.clone(), mutability))\n             }\n-        } else {\n-            None\n+            _ => Some(SelfExplicit(self.type_.clone()))\n         }\n     }\n }\n@@ -1353,11 +1354,13 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     };\n                     let self_arg_ty = *fty.sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n-                        decl.inputs.values[0].type_ = Infer;\n+                        decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n                     } else if let ty::TyRef(_, mt) = self_arg_ty.sty {\n                         if mt.ty == self_ty {\n                             match decl.inputs.values[0].type_ {\n-                                BorrowedRef{ref mut type_, ..} => **type_ = Infer,\n+                                BorrowedRef{ref mut type_, ..} => {\n+                                    **type_ = Generic(String::from(\"Self\"))\n+                                }\n                                 _ => unreachable!(),\n                             }\n                         }\n@@ -1568,6 +1571,13 @@ impl Type {\n             _ => false,\n         }\n     }\n+\n+    pub fn is_self_type(&self) -> bool {\n+        match *self {\n+            Generic(ref name) => name == \"Self\",\n+            _ => false\n+        }\n+    }\n }\n \n impl GetDefId for Type {"}, {"sha": "f72985fd91a3ea1702e42221ccb864433522fc49", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "patch": "@@ -1471,12 +1471,13 @@ impl Arg {\n     }\n \n     pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -> Arg {\n+        let span = mk_sp(eself.span.lo, eself_ident.span.hi);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n             node: TyKind::ImplicitSelf,\n-            span: DUMMY_SP,\n+            span: span,\n         });\n-        let arg = |mutbl, ty, span| Arg {\n+        let arg = |mutbl, ty| Arg {\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n                 node: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n@@ -1486,15 +1487,13 @@ impl Arg {\n             id: DUMMY_NODE_ID,\n         };\n         match eself.node {\n-            SelfKind::Explicit(ty, mutbl) => {\n-                arg(mutbl, ty, mk_sp(eself.span.lo, eself_ident.span.hi))\n-            }\n-            SelfKind::Value(mutbl) => arg(mutbl, infer_ty, eself.span),\n+            SelfKind::Explicit(ty, mutbl) => arg(mutbl, ty),\n+            SelfKind::Value(mutbl) => arg(mutbl, infer_ty),\n             SelfKind::Region(lt, mutbl) => arg(Mutability::Immutable, P(Ty {\n                 id: DUMMY_NODE_ID,\n                 node: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl: mutbl }),\n-                span: DUMMY_SP,\n-            }), eself.span),\n+                span: span,\n+            })),\n         }\n     }\n }"}, {"sha": "fae134986872e06cac70ff4f8d22f1fb05e6bb01", "filename": "src/test/run-make/pretty-print-path-suffix/foo_method.pp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp", "raw_url": "https://github.com/rust-lang/rust/raw/6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp?ref=6ebb6fdbee7f0d250e50e4d84d9aede293cf3bb3", "patch": "@@ -12,5 +12,6 @@\n \n \n \n-fn foo_method(&self) -> &'static str { return \"i am very similar to foo.\"; }\n-/* nest::{{impl}}::foo_method */\n+fn foo_method(self: &Self)\n+ -> &'static str { return \"i am very similar to foo.\"; } /*\n+nest::{{impl}}::foo_method */"}]}