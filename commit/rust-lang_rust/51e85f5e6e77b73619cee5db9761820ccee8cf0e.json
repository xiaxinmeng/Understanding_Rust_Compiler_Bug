{"sha": "51e85f5e6e77b73619cee5db9761820ccee8cf0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZTg1ZjVlNmU3N2I3MzYxOWNlZTVkYjk3NjE4MjBjY2VlOGNmMGU=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-06-08T00:01:30Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-06-08T01:24:47Z"}, "message": "Avoid unnecessary heap allocations in the metadata ty decoder", "tree": {"sha": "0435375adeb667794d5ff08c9aa901ef08984bf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0435375adeb667794d5ff08c9aa901ef08984bf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51e85f5e6e77b73619cee5db9761820ccee8cf0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51e85f5e6e77b73619cee5db9761820ccee8cf0e", "html_url": "https://github.com/rust-lang/rust/commit/51e85f5e6e77b73619cee5db9761820ccee8cf0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51e85f5e6e77b73619cee5db9761820ccee8cf0e/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b87047789723ac140f471c56cebf3faa27e0c06f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b87047789723ac140f471c56cebf3faa27e0c06f", "html_url": "https://github.com/rust-lang/rust/commit/b87047789723ac140f471c56cebf3faa27e0c06f"}], "stats": {"total": 89, "additions": 43, "deletions": 46}, "files": [{"sha": "16b57493adfa2b52d7f63ed7fc45761732ec4818", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/51e85f5e6e77b73619cee5db9761820ccee8cf0e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e85f5e6e77b73619cee5db9761820ccee8cf0e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=51e85f5e6e77b73619cee5db9761820ccee8cf0e", "patch": "@@ -62,17 +62,17 @@ pub struct PState {\n     tcx: ty::ctxt\n }\n \n-fn peek(st: @mut PState) -> char {\n+fn peek(st: &PState) -> char {\n     st.data[st.pos] as char\n }\n \n-fn next(st: @mut PState) -> char {\n+fn next(st: &mut PState) -> char {\n     let ch = st.data[st.pos] as char;\n     st.pos = st.pos + 1u;\n     return ch;\n }\n \n-fn next_byte(st: @mut PState) -> u8 {\n+fn next_byte(st: &mut PState) -> u8 {\n     let b = st.data[st.pos];\n     st.pos = st.pos + 1u;\n     return b;\n@@ -92,20 +92,20 @@ fn scan<R>(st: &mut PState, is_last: &fn(char) -> bool,\n     return op(st.data.slice(start_pos, end_pos));\n }\n \n-pub fn parse_ident(st: @mut PState, last: char) -> ast::ident {\n+pub fn parse_ident(st: &mut PState, last: char) -> ast::ident {\n     fn is_last(b: char, c: char) -> bool { return c == b; }\n     return parse_ident_(st, |a| is_last(last, a) );\n }\n \n-fn parse_ident_(st: @mut PState, is_last: @fn(char) -> bool) ->\n+fn parse_ident_(st: &mut PState, is_last: @fn(char) -> bool) ->\n    ast::ident {\n     let rslt = scan(st, is_last, str::from_bytes);\n     return st.tcx.sess.ident_of(rslt);\n }\n \n pub fn parse_state_from_data(data: @~[u8], crate_num: int,\n-                             pos: uint, tcx: ty::ctxt) -> @mut PState {\n-    @mut PState {\n+                             pos: uint, tcx: ty::ctxt) -> PState {\n+    PState {\n         data: data,\n         crate: crate_num,\n         pos: pos,\n@@ -115,23 +115,23 @@ pub fn parse_state_from_data(data: @~[u8], crate_num: int,\n \n pub fn parse_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                      conv: conv_did) -> ty::t {\n-    let st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_ty(st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_ty(&mut st, conv)\n }\n \n pub fn parse_bare_fn_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                              conv: conv_did) -> ty::BareFnTy {\n-    let st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_bare_fn_ty(st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_bare_fn_ty(&mut st, conv)\n }\n \n pub fn parse_trait_ref_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                             conv: conv_did) -> ty::TraitRef {\n-    let st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_trait_ref(st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n+    parse_trait_ref(&mut st, conv)\n }\n \n-fn parse_path(st: @mut PState) -> @ast::Path {\n+fn parse_path(st: &mut PState) -> @ast::Path {\n     let mut idents: ~[ast::ident] = ~[];\n     fn is_last(c: char) -> bool { return c == '(' || c == ':'; }\n     idents.push(parse_ident_(st, is_last));\n@@ -151,7 +151,7 @@ fn parse_path(st: @mut PState) -> @ast::Path {\n     };\n }\n \n-fn parse_sigil(st: @mut PState) -> ast::Sigil {\n+fn parse_sigil(st: &mut PState) -> ast::Sigil {\n     match next(st) {\n         '@' => ast::ManagedSigil,\n         '~' => ast::OwnedSigil,\n@@ -160,7 +160,7 @@ fn parse_sigil(st: @mut PState) -> ast::Sigil {\n     }\n }\n \n-fn parse_vstore(st: @mut PState) -> ty::vstore {\n+fn parse_vstore(st: &mut PState) -> ty::vstore {\n     assert_eq!(next(st), '/');\n \n     let c = peek(st);\n@@ -178,7 +178,7 @@ fn parse_vstore(st: @mut PState) -> ty::vstore {\n     }\n }\n \n-fn parse_trait_store(st: @mut PState) -> ty::TraitStore {\n+fn parse_trait_store(st: &mut PState) -> ty::TraitStore {\n     match next(st) {\n         '~' => ty::UniqTraitStore,\n         '@' => ty::BoxTraitStore,\n@@ -187,10 +187,10 @@ fn parse_trait_store(st: @mut PState) -> ty::TraitStore {\n     }\n }\n \n-fn parse_substs(st: @mut PState, conv: conv_did) -> ty::substs {\n-    let self_r = parse_opt(st, || parse_region(st) );\n+fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n+    let self_r = parse_opt(st, |st| parse_region(st) );\n \n-    let self_ty = parse_opt(st, || parse_ty(st, conv) );\n+    let self_ty = parse_opt(st, |st| parse_ty(st, conv) );\n \n     assert_eq!(next(st), '[');\n     let mut params: ~[ty::t] = ~[];\n@@ -204,7 +204,7 @@ fn parse_substs(st: @mut PState, conv: conv_did) -> ty::substs {\n     };\n }\n \n-fn parse_bound_region(st: @mut PState) -> ty::bound_region {\n+fn parse_bound_region(st: &mut PState) -> ty::bound_region {\n     match next(st) {\n       's' => ty::br_self,\n       'a' => {\n@@ -222,7 +222,7 @@ fn parse_bound_region(st: @mut PState) -> ty::bound_region {\n     }\n }\n \n-fn parse_region(st: @mut PState) -> ty::Region {\n+fn parse_region(st: &mut PState) -> ty::Region {\n     match next(st) {\n       'b' => {\n         ty::re_bound(parse_bound_region(st))\n@@ -251,15 +251,15 @@ fn parse_region(st: @mut PState) -> ty::Region {\n     }\n }\n \n-fn parse_opt<T>(st: @mut PState, f: &fn() -> T) -> Option<T> {\n+fn parse_opt<T>(st: &mut PState, f: &fn(&mut PState) -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n-      's' => Some(f()),\n+      's' => Some(f(st)),\n       _ => fail!(\"parse_opt: bad input\")\n     }\n }\n \n-fn parse_str(st: @mut PState, term: char) -> ~str {\n+fn parse_str(st: &mut PState, term: char) -> ~str {\n     let mut result = ~\"\";\n     while peek(st) != term {\n         result += str::from_byte(next_byte(st));\n@@ -268,13 +268,13 @@ fn parse_str(st: @mut PState, term: char) -> ~str {\n     return result;\n }\n \n-fn parse_trait_ref(st: @mut PState, conv: conv_did) -> ty::TraitRef {\n+fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n     let def = parse_def(st, NominalType, conv);\n     let substs = parse_substs(st, conv);\n     ty::TraitRef {def_id: def, substs: substs}\n }\n \n-fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n+fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n     match next(st) {\n       'n' => return ty::mk_nil(),\n       'z' => return ty::mk_bot(),\n@@ -370,8 +370,8 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n         match st.tcx.rcache.find(&key) {\n           Some(&tt) => return tt,\n           None => {\n-            let ps = @mut PState {pos: pos ,.. copy *st};\n-            let tt = parse_ty(ps, conv);\n+            let mut ps = PState {pos: pos ,.. copy *st};\n+            let tt = parse_ty(&mut ps, conv);\n             st.tcx.rcache.insert(key, tt);\n             return tt;\n           }\n@@ -394,28 +394,25 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n     }\n }\n \n-fn parse_mutability(st: @mut PState) -> ast::mutability {\n+fn parse_mutability(st: &mut PState) -> ast::mutability {\n     match peek(st) {\n       'm' => { next(st); ast::m_mutbl }\n       '?' => { next(st); ast::m_const }\n       _ => { ast::m_imm }\n     }\n }\n \n-fn parse_mt(st: @mut PState, conv: conv_did) -> ty::mt {\n+fn parse_mt(st: &mut PState, conv: conv_did) -> ty::mt {\n     let m = parse_mutability(st);\n     ty::mt { ty: parse_ty(st, conv), mutbl: m }\n }\n \n-fn parse_def(st: @mut PState, source: DefIdSource,\n+fn parse_def(st: &mut PState, source: DefIdSource,\n              conv: conv_did) -> ast::def_id {\n-    let mut def = ~[];\n-    while peek(st) != '|' { def.push(next_byte(st)); }\n-    st.pos = st.pos + 1u;\n-    return conv(source, parse_def_id(def));\n+    return conv(source, scan(st, |c| { c == '|' }, parse_def_id));\n }\n \n-fn parse_uint(st: @mut PState) -> uint {\n+fn parse_uint(st: &mut PState) -> uint {\n     let mut n = 0;\n     loop {\n         let cur = peek(st);\n@@ -426,7 +423,7 @@ fn parse_uint(st: @mut PState) -> uint {\n     };\n }\n \n-fn parse_hex(st: @mut PState) -> uint {\n+fn parse_hex(st: &mut PState) -> uint {\n     let mut n = 0u;\n     loop {\n         let cur = peek(st);\n@@ -449,7 +446,7 @@ fn parse_purity(c: char) -> purity {\n     }\n }\n \n-fn parse_abi_set(st: @mut PState) -> AbiSet {\n+fn parse_abi_set(st: &mut PState) -> AbiSet {\n     assert_eq!(next(st), '[');\n     let mut abis = AbiSet::empty();\n     while peek(st) != ']' {\n@@ -470,7 +467,7 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     }\n }\n \n-fn parse_closure_ty(st: @mut PState, conv: conv_did) -> ty::ClosureTy {\n+fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     let sigil = parse_sigil(st);\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n@@ -487,7 +484,7 @@ fn parse_closure_ty(st: @mut PState, conv: conv_did) -> ty::ClosureTy {\n     }\n }\n \n-fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n+fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n     let purity = parse_purity(next(st));\n     let abi = parse_abi_set(st);\n     let sig = parse_sig(st, conv);\n@@ -498,7 +495,7 @@ fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n     }\n }\n \n-fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n+fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n     let mut inputs = ~[];\n     while peek(st) != ']' {\n@@ -541,16 +538,16 @@ pub fn parse_type_param_def_data(data: @~[u8], start: uint,\n                                  crate_num: int, tcx: ty::ctxt,\n                                  conv: conv_did) -> ty::TypeParameterDef\n {\n-    let st = parse_state_from_data(data, crate_num, start, tcx);\n-    parse_type_param_def(st, conv)\n+    let mut st = parse_state_from_data(data, crate_num, start, tcx);\n+    parse_type_param_def(&mut st, conv)\n }\n \n-fn parse_type_param_def(st: @mut PState, conv: conv_did) -> ty::TypeParameterDef {\n+fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef {\n     ty::TypeParameterDef {def_id: parse_def(st, NominalType, conv),\n                           bounds: @parse_bounds(st, conv)}\n }\n \n-fn parse_bounds(st: @mut PState, conv: conv_did) -> ty::ParamBounds {\n+fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n     let mut param_bounds = ty::ParamBounds {\n         builtin_bounds: ty::EmptyBuiltinBounds(),\n         trait_bounds: ~[]"}]}