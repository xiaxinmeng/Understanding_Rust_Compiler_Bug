{"sha": "e81347c3685dfc818fca2d502819ee0d1b692621", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MTM0N2MzNjg1ZGZjODE4ZmNhMmQ1MDI4MTllZTBkMWI2OTI2MjE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T16:34:42Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T16:34:42Z"}, "message": "parser: split into {item,module}.rs", "tree": {"sha": "6535fd2cc6bc3626b10f90b87e70114dbe5500c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6535fd2cc6bc3626b10f90b87e70114dbe5500c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e81347c3685dfc818fca2d502819ee0d1b692621", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e81347c3685dfc818fca2d502819ee0d1b692621", "html_url": "https://github.com/rust-lang/rust/commit/e81347c3685dfc818fca2d502819ee0d1b692621", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e81347c3685dfc818fca2d502819ee0d1b692621/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e742de2569f6222b26671171c1f32fcd02b80f67", "url": "https://api.github.com/repos/rust-lang/rust/commits/e742de2569f6222b26671171c1f32fcd02b80f67", "html_url": "https://github.com/rust-lang/rust/commit/e742de2569f6222b26671171c1f32fcd02b80f67"}], "stats": {"total": 4507, "additions": 2270, "deletions": 2237}, "files": [{"sha": "6537f59395f4ea640f9a654a5aaf4d2715e3e99f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 39, "deletions": 2237, "changes": 2276, "blob_url": "https://github.com/rust-lang/rust/blob/e81347c3685dfc818fca2d502819ee0d1b692621/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81347c3685dfc818fca2d502819ee0d1b692621/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e81347c3685dfc818fca2d502819ee0d1b692621", "patch": "@@ -2,44 +2,34 @@\n \n mod expr;\n use expr::LhsExpr;\n-\n mod pat;\n-\n-use crate::ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n-use crate::ast::{GenericBound, TraitBoundModifier};\n-use crate::ast::Unsafety;\n-use crate::ast::{Mod, AnonConst, Arg, Attribute, BindingMode, TraitItemKind};\n-use crate::ast::{Block, BlockCheckMode};\n-use crate::ast::{Constness, Crate};\n-use crate::ast::Defaultness;\n-use crate::ast::EnumDef;\n-use crate::ast::{Expr, ExprKind};\n-use crate::ast::{FnDecl, FnHeader};\n-use crate::ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n-use crate::ast::{GenericParam, GenericParamKind};\n-use crate::ast::GenericArg;\n-use crate::ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind, Local, Lifetime};\n-use crate::ast::{MacStmtStyle, Mac, Mac_, MacDelimiter};\n+mod item;\n+pub use item::AliasKind;\n+mod module;\n+pub use module::{ModulePath, ModulePathSuccess};\n+\n+use crate::ast::{self, AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n+use crate::ast::{AnonConst, Arg, Attribute, BindingMode};\n+use crate::ast::{Block, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind};\n+use crate::ast::{FnDecl, FunctionRetTy};\n+use crate::ast::{Ident, IsAsync, Local, Lifetime};\n+use crate::ast::{MacStmtStyle, Mac_, MacDelimiter};\n use crate::ast::{MutTy, Mutability};\n-use crate::ast::{PathSegment};\n-use crate::ast::{PolyTraitRef, QSelf};\n-use crate::ast::{Stmt, StmtKind};\n-use crate::ast::{VariantData, StructField};\n+use crate::ast::{PolyTraitRef, QSelf, PathSegment};\n use crate::ast::StrStyle;\n use crate::ast::SelfKind;\n-use crate::ast::{TraitItem, TraitRef, TraitObjectSyntax};\n+use crate::ast::{GenericBound, TraitBoundModifier, TraitObjectSyntax};\n+use crate::ast::{GenericParam, GenericParamKind, GenericArg, WhereClause};\n use crate::ast::{Ty, TyKind, AssocTyConstraint, AssocTyConstraintKind, GenericBounds};\n-use crate::ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n-use crate::ast::{UseTree, UseTreeKind};\n-use crate::{ast, attr};\n+use crate::ast::{Visibility, VisibilityKind, Unsafety, CrateSugar};\n use crate::ext::base::DummyResult;\n use crate::ext::hygiene::SyntaxContext;\n-use crate::source_map::{self, SourceMap, Spanned, respan};\n+use crate::source_map::{self, respan};\n use crate::parse::{SeqSep, classify, literal, token};\n use crate::parse::lexer::UnmatchedBrace;\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::token::{Token, TokenKind, DelimToken};\n-use crate::parse::{new_sub_parser_from_file, ParseSess, Directory, DirectoryOwnership};\n+use crate::parse::{ParseSess, Directory, DirectoryOwnership};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::parse::PResult;\n@@ -48,25 +38,14 @@ use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n use crate::symbol::{kw, sym, Symbol};\n use crate::parse::diagnostics::{Error, dummy_arg};\n \n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n+use errors::{Applicability, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{Span, BytePos, DUMMY_SP, FileName};\n use log::debug;\n \n use std::borrow::Cow;\n-use std::cmp;\n-use std::mem;\n-use std::path::{self, Path, PathBuf};\n-use std::slice;\n-\n-#[derive(Debug)]\n-/// Whether the type alias or associated type is a concrete type or an opaque type\n-pub enum AliasKind {\n-    /// Just a new name for the same type\n-    Weak(P<Ty>),\n-    /// Only trait impls of the type will be usable, not the actual type itself\n-    OpaqueTy(GenericBounds),\n-}\n+use std::{cmp, mem, slice};\n+use std::path::PathBuf;\n \n bitflags::bitflags! {\n     struct Restrictions: u8 {\n@@ -75,8 +54,6 @@ bitflags::bitflags! {\n     }\n }\n \n-type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute>>);\n-\n /// Specifies how to parse a path.\n #[derive(Copy, Clone, PartialEq)]\n pub enum PathStyle {\n@@ -390,19 +367,6 @@ fn can_continue_type_after_non_fn_ident(t: &Token) -> bool {\n     t == &token::BinOp(token::Shl)\n }\n \n-/// Information about the path to a module.\n-pub struct ModulePath {\n-    name: String,\n-    path_exists: bool,\n-    pub result: Result<ModulePathSuccess, Error>,\n-}\n-\n-pub struct ModulePathSuccess {\n-    pub path: PathBuf,\n-    pub directory_ownership: DirectoryOwnership,\n-    warn: bool,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n crate enum TokenExpectType {\n     Expect,\n@@ -1077,120 +1041,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses the items in a trait declaration.\n-    pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> {\n-        maybe_whole!(self, NtTraitItem, |x| x);\n-        let attrs = self.parse_outer_attributes()?;\n-        let mut unclosed_delims = vec![];\n-        let (mut item, tokens) = self.collect_tokens(|this| {\n-            let item = this.parse_trait_item_(at_end, attrs);\n-            unclosed_delims.append(&mut this.unclosed_delims);\n-            item\n-        })?;\n-        self.unclosed_delims.append(&mut unclosed_delims);\n-        // See `parse_item` for why this clause is here.\n-        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n-            item.tokens = Some(tokens);\n-        }\n-        Ok(item)\n-    }\n-\n-    fn parse_trait_item_(&mut self,\n-                         at_end: &mut bool,\n-                         mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n-        let lo = self.token.span;\n-        self.eat_bad_pub();\n-        let (name, node, generics) = if self.eat_keyword(kw::Type) {\n-            self.parse_trait_item_assoc_ty()?\n-        } else if self.is_const_item() {\n-            self.expect_keyword(kw::Const)?;\n-            let ident = self.parse_ident()?;\n-            self.expect(&token::Colon)?;\n-            let ty = self.parse_ty()?;\n-            let default = if self.eat(&token::Eq) {\n-                let expr = self.parse_expr()?;\n-                self.expect(&token::Semi)?;\n-                Some(expr)\n-            } else {\n-                self.expect(&token::Semi)?;\n-                None\n-            };\n-            (ident, TraitItemKind::Const(ty, default), ast::Generics::default())\n-        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"trait\", None, &mut false)? {\n-            // trait item macro.\n-            (Ident::invalid(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n-        } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n-\n-            let ident = self.parse_ident()?;\n-            let mut generics = self.parse_generics()?;\n-\n-            let decl = self.parse_fn_decl_with_self(|p: &mut Parser<'a>| {\n-                // This is somewhat dubious; We don't want to allow\n-                // argument names to be left off if there is a\n-                // definition...\n-\n-                // We don't allow argument names to be left off in edition 2018.\n-                let is_name_required = p.token.span.rust_2018();\n-                p.parse_arg_general(true, false, |_| is_name_required)\n-            })?;\n-            generics.where_clause = self.parse_where_clause()?;\n-\n-            let sig = ast::MethodSig {\n-                header: FnHeader {\n-                    unsafety,\n-                    constness,\n-                    abi,\n-                    asyncness,\n-                },\n-                decl,\n-            };\n-\n-            let body = match self.token.kind {\n-                token::Semi => {\n-                    self.bump();\n-                    *at_end = true;\n-                    debug!(\"parse_trait_methods(): parsing required method\");\n-                    None\n-                }\n-                token::OpenDelim(token::Brace) => {\n-                    debug!(\"parse_trait_methods(): parsing provided method\");\n-                    *at_end = true;\n-                    let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                    attrs.extend(inner_attrs.iter().cloned());\n-                    Some(body)\n-                }\n-                token::Interpolated(ref nt) => {\n-                    match **nt {\n-                        token::NtBlock(..) => {\n-                            *at_end = true;\n-                            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                            attrs.extend(inner_attrs.iter().cloned());\n-                            Some(body)\n-                        }\n-                        _ => {\n-                            return self.expected_semi_or_open_brace();\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    return self.expected_semi_or_open_brace();\n-                }\n-            };\n-            (ident, ast::TraitItemKind::Method(sig, body), generics)\n-        };\n-\n-        Ok(TraitItem {\n-            id: ast::DUMMY_NODE_ID,\n-            ident: name,\n-            attrs,\n-            generics,\n-            node,\n-            span: lo.to(self.prev_span),\n-            tokens: None,\n-        })\n-    }\n-\n     /// Parses an optional return type `[ -> TY ]` in a function declaration.\n     fn parse_ret_ty(&mut self, allow_plus: bool) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n@@ -1992,39 +1842,6 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// Parses a structure field.\n-    fn parse_name_and_ty(&mut self,\n-                         lo: Span,\n-                         vis: Visibility,\n-                         attrs: Vec<Attribute>)\n-                         -> PResult<'a, StructField> {\n-        let name = self.parse_ident()?;\n-        self.expect(&token::Colon)?;\n-        let ty = self.parse_ty()?;\n-        Ok(StructField {\n-            span: lo.to(self.prev_span),\n-            ident: Some(name),\n-            vis,\n-            id: ast::DUMMY_NODE_ID,\n-            ty,\n-            attrs,\n-        })\n-    }\n-\n-    /// Emits an expected-item-after-attributes error.\n-    fn expected_item_err(&mut self, attrs: &[Attribute]) -> PResult<'a,  ()> {\n-        let message = match attrs.last() {\n-            Some(&Attribute { is_sugared_doc: true, .. }) => \"expected item after doc comment\",\n-            _ => \"expected item after attributes\",\n-        };\n-\n-        let mut err = self.diagnostic().struct_span_err(self.prev_span, message);\n-        if attrs.last().unwrap().is_sugared_doc {\n-            err.span_label(self.prev_span, \"this doc comment doesn't document anything\");\n-        }\n-        Err(err)\n-    }\n-\n     /// Parse a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n     pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n@@ -2044,11 +1861,6 @@ impl<'a> Parser<'a> {\n             self.is_keyword_ahead(1, &[kw::Fn])\n     }\n \n-    fn is_union_item(&self) -> bool {\n-        self.token.is_keyword(kw::Union) &&\n-        self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n-    }\n-\n     fn is_crate_vis(&self) -> bool {\n         self.token.is_keyword(kw::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n     }\n@@ -2063,58 +1875,6 @@ impl<'a> Parser<'a> {\n          self.is_keyword_ahead(2, &[kw::Trait]))\n     }\n \n-    fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility, lo: Span)\n-                     -> PResult<'a, Option<P<Item>>> {\n-        let token_lo = self.token.span;\n-        let (ident, def) = if self.eat_keyword(kw::Macro) {\n-            let ident = self.parse_ident()?;\n-            let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n-                match self.parse_token_tree() {\n-                    TokenTree::Delimited(_, _, tts) => tts,\n-                    _ => unreachable!(),\n-                }\n-            } else if self.check(&token::OpenDelim(token::Paren)) {\n-                let args = self.parse_token_tree();\n-                let body = if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.parse_token_tree()\n-                } else {\n-                    self.unexpected()?;\n-                    unreachable!()\n-                };\n-                TokenStream::new(vec![\n-                    args.into(),\n-                    TokenTree::token(token::FatArrow, token_lo.to(self.prev_span)).into(),\n-                    body.into(),\n-                ])\n-            } else {\n-                self.unexpected()?;\n-                unreachable!()\n-            };\n-\n-            (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n-        } else if self.check_keyword(sym::macro_rules) &&\n-                  self.look_ahead(1, |t| *t == token::Not) &&\n-                  self.look_ahead(2, |t| t.is_ident()) {\n-            let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&vis.node, prev_span);\n-            self.bump();\n-            self.bump();\n-\n-            let ident = self.parse_ident()?;\n-            let (delim, tokens) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n-                self.report_invalid_macro_expansion_item();\n-            }\n-\n-            (ident, ast::MacroDef { tokens, legacy: true })\n-        } else {\n-            return Ok(None);\n-        };\n-\n-        let span = lo.to(self.prev_span);\n-        Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n-    }\n-\n     fn parse_stmt_without_recovery(\n         &mut self,\n         macro_legacy_warnings: bool,\n@@ -2613,32 +2373,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Parses the following grammar:\n-    ///\n-    ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n-    fn parse_trait_item_assoc_ty(&mut self)\n-        -> PResult<'a, (Ident, TraitItemKind, ast::Generics)> {\n-        let ident = self.parse_ident()?;\n-        let mut generics = self.parse_generics()?;\n-\n-        // Parse optional colon and param bounds.\n-        let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds(None)?\n-        } else {\n-            Vec::new()\n-        };\n-        generics.where_clause = self.parse_where_clause()?;\n-\n-        let default = if self.eat(&token::Eq) {\n-            Some(self.parse_ty()?)\n-        } else {\n-            None\n-        };\n-        self.expect(&token::Semi)?;\n-\n-        Ok((ident, TraitItemKind::Type(bounds, default), generics))\n-    }\n-\n     fn parse_const_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, GenericParam> {\n         self.expect_keyword(kw::Const)?;\n         let ident = self.parse_ident()?;\n@@ -3134,18 +2868,6 @@ impl<'a> Parser<'a> {\n         Ok((args, c_variadic))\n     }\n \n-    /// Parses the argument list and result type of a function declaration.\n-    fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n-        let (args, c_variadic) = self.parse_fn_args(true, allow_c_variadic)?;\n-        let ret_ty = self.parse_ret_ty(true)?;\n-\n-        Ok(P(FnDecl {\n-            inputs: args,\n-            output: ret_ty,\n-            c_variadic,\n-        }))\n-    }\n-\n     /// Returns the parsed optional self argument and whether a self shortcut was used.\n     ///\n     /// See `parse_self_arg_with_attrs` to collect attributes.\n@@ -3340,301 +3062,6 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// Parses the name and optional generic types of a function header.\n-    fn parse_fn_header(&mut self) -> PResult<'a, (Ident, ast::Generics)> {\n-        let id = self.parse_ident()?;\n-        let generics = self.parse_generics()?;\n-        Ok((id, generics))\n-    }\n-\n-    fn mk_item(&self, span: Span, ident: Ident, node: ItemKind, vis: Visibility,\n-               attrs: Vec<Attribute>) -> P<Item> {\n-        P(Item {\n-            ident,\n-            attrs,\n-            id: ast::DUMMY_NODE_ID,\n-            node,\n-            vis,\n-            span,\n-            tokens: None,\n-        })\n-    }\n-\n-    /// Parses an item-position function declaration.\n-    fn parse_item_fn(&mut self,\n-                     unsafety: Unsafety,\n-                     asyncness: Spanned<IsAsync>,\n-                     constness: Spanned<Constness>,\n-                     abi: Abi)\n-                     -> PResult<'a, ItemInfo> {\n-        let (ident, mut generics) = self.parse_fn_header()?;\n-        let allow_c_variadic = abi == Abi::C && unsafety == Unsafety::Unsafe;\n-        let decl = self.parse_fn_decl(allow_c_variadic)?;\n-        generics.where_clause = self.parse_where_clause()?;\n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        let header = FnHeader { unsafety, asyncness, constness, abi };\n-        Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n-    }\n-\n-    /// Returns `true` if we are looking at `const ID`\n-    /// (returns `false` for things like `const fn`, etc.).\n-    fn is_const_item(&self) -> bool {\n-        self.token.is_keyword(kw::Const) &&\n-            !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n-    }\n-\n-    /// Parses all the \"front matter\" for a `fn` declaration, up to\n-    /// and including the `fn` keyword:\n-    ///\n-    /// - `const fn`\n-    /// - `unsafe fn`\n-    /// - `const unsafe fn`\n-    /// - `extern fn`\n-    /// - etc.\n-    fn parse_fn_front_matter(&mut self)\n-        -> PResult<'a, (\n-            Spanned<Constness>,\n-            Unsafety,\n-            Spanned<IsAsync>,\n-            Abi\n-        )>\n-    {\n-        let is_const_fn = self.eat_keyword(kw::Const);\n-        let const_span = self.prev_span;\n-        let asyncness = self.parse_asyncness();\n-        if let IsAsync::Async { .. } = asyncness {\n-            self.ban_async_in_2015(self.prev_span);\n-        }\n-        let asyncness = respan(self.prev_span, asyncness);\n-        let unsafety = self.parse_unsafety();\n-        let (constness, unsafety, abi) = if is_const_fn {\n-            (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n-        } else {\n-            let abi = if self.eat_keyword(kw::Extern) {\n-                self.parse_opt_abi()?.unwrap_or(Abi::C)\n-            } else {\n-                Abi::Rust\n-            };\n-            (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n-        };\n-        if !self.eat_keyword(kw::Fn) {\n-            // It is possible for `expect_one_of` to recover given the contents of\n-            // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n-            // account for this.\n-            if !self.expect_one_of(&[], &[])? { unreachable!() }\n-        }\n-        Ok((constness, unsafety, asyncness, abi))\n-    }\n-\n-    /// Parses an impl item.\n-    pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> {\n-        maybe_whole!(self, NtImplItem, |x| x);\n-        let attrs = self.parse_outer_attributes()?;\n-        let mut unclosed_delims = vec![];\n-        let (mut item, tokens) = self.collect_tokens(|this| {\n-            let item = this.parse_impl_item_(at_end, attrs);\n-            unclosed_delims.append(&mut this.unclosed_delims);\n-            item\n-        })?;\n-        self.unclosed_delims.append(&mut unclosed_delims);\n-\n-        // See `parse_item` for why this clause is here.\n-        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n-            item.tokens = Some(tokens);\n-        }\n-        Ok(item)\n-    }\n-\n-    fn parse_impl_item_(&mut self,\n-                        at_end: &mut bool,\n-                        mut attrs: Vec<Attribute>) -> PResult<'a, ImplItem> {\n-        let lo = self.token.span;\n-        let vis = self.parse_visibility(false)?;\n-        let defaultness = self.parse_defaultness();\n-        let (name, node, generics) = if let Some(type_) = self.eat_type() {\n-            let (name, alias, generics) = type_?;\n-            let kind = match alias {\n-                AliasKind::Weak(typ) => ast::ImplItemKind::TyAlias(typ),\n-                AliasKind::OpaqueTy(bounds) => ast::ImplItemKind::OpaqueTy(bounds),\n-            };\n-            (name, kind, generics)\n-        } else if self.is_const_item() {\n-            // This parses the grammar:\n-            //     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n-            self.expect_keyword(kw::Const)?;\n-            let name = self.parse_ident()?;\n-            self.expect(&token::Colon)?;\n-            let typ = self.parse_ty()?;\n-            self.expect(&token::Eq)?;\n-            let expr = self.parse_expr()?;\n-            self.expect(&token::Semi)?;\n-            (name, ast::ImplItemKind::Const(typ, expr), ast::Generics::default())\n-        } else {\n-            let (name, inner_attrs, generics, node) = self.parse_impl_method(&vis, at_end)?;\n-            attrs.extend(inner_attrs);\n-            (name, node, generics)\n-        };\n-\n-        Ok(ImplItem {\n-            id: ast::DUMMY_NODE_ID,\n-            span: lo.to(self.prev_span),\n-            ident: name,\n-            vis,\n-            defaultness,\n-            attrs,\n-            generics,\n-            node,\n-            tokens: None,\n-        })\n-    }\n-\n-    fn complain_if_pub_macro(&self, vis: &VisibilityKind, sp: Span) {\n-        match *vis {\n-            VisibilityKind::Inherited => {}\n-            _ => {\n-                let mut err = if self.token.is_keyword(sym::macro_rules) {\n-                    let mut err = self.diagnostic()\n-                        .struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n-                    err.span_suggestion(\n-                        sp,\n-                        \"try exporting the macro\",\n-                        \"#[macro_export]\".to_owned(),\n-                        Applicability::MaybeIncorrect // speculative\n-                    );\n-                    err\n-                } else {\n-                    let mut err = self.diagnostic()\n-                        .struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n-                    err.help(\"try adjusting the macro to put `pub` inside the invocation\");\n-                    err\n-                };\n-                err.emit();\n-            }\n-        }\n-    }\n-\n-    fn missing_assoc_item_kind_err(&self, item_type: &str, prev_span: Span)\n-                                   -> DiagnosticBuilder<'a>\n-    {\n-        let expected_kinds = if item_type == \"extern\" {\n-            \"missing `fn`, `type`, or `static`\"\n-        } else {\n-            \"missing `fn`, `type`, or `const`\"\n-        };\n-\n-        // Given this code `path(`, it seems like this is not\n-        // setting the visibility of a macro invocation, but rather\n-        // a mistyped method declaration.\n-        // Create a diagnostic pointing out that `fn` is missing.\n-        //\n-        // x |     pub path(&self) {\n-        //   |        ^ missing `fn`, `type`, or `const`\n-        //     pub  path(\n-        //        ^^ `sp` below will point to this\n-        let sp = prev_span.between(self.prev_span);\n-        let mut err = self.diagnostic().struct_span_err(\n-            sp,\n-            &format!(\"{} for {}-item declaration\",\n-                     expected_kinds, item_type));\n-        err.span_label(sp, expected_kinds);\n-        err\n-    }\n-\n-    /// Parse a method or a macro invocation in a trait impl.\n-    fn parse_impl_method(&mut self, vis: &Visibility, at_end: &mut bool)\n-                         -> PResult<'a, (Ident, Vec<Attribute>, ast::Generics,\n-                             ast::ImplItemKind)> {\n-        // code copied from parse_macro_use_or_failure... abstraction!\n-        if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n-            // method macro\n-            Ok((Ident::invalid(), vec![], ast::Generics::default(),\n-                ast::ImplItemKind::Macro(mac)))\n-        } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n-            let ident = self.parse_ident()?;\n-            let mut generics = self.parse_generics()?;\n-            let decl = self.parse_fn_decl_with_self(|p| {\n-                p.parse_arg_general(true, false, |_| true)\n-            })?;\n-            generics.where_clause = self.parse_where_clause()?;\n-            *at_end = true;\n-            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-            let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n-            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(\n-                ast::MethodSig { header, decl },\n-                body\n-            )))\n-        }\n-    }\n-\n-    /// Parses `trait Foo { ... }` or `trait Foo = Bar;`.\n-    fn parse_item_trait(&mut self, is_auto: IsAuto, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n-        let ident = self.parse_ident()?;\n-        let mut tps = self.parse_generics()?;\n-\n-        // Parse optional colon and supertrait bounds.\n-        let bounds = if self.eat(&token::Colon) {\n-            self.parse_generic_bounds(Some(self.prev_span))?\n-        } else {\n-            Vec::new()\n-        };\n-\n-        if self.eat(&token::Eq) {\n-            // it's a trait alias\n-            let bounds = self.parse_generic_bounds(None)?;\n-            tps.where_clause = self.parse_where_clause()?;\n-            self.expect(&token::Semi)?;\n-            if is_auto == IsAuto::Yes {\n-                let msg = \"trait aliases cannot be `auto`\";\n-                self.struct_span_err(self.prev_span, msg)\n-                    .span_label(self.prev_span, msg)\n-                    .emit();\n-            }\n-            if unsafety != Unsafety::Normal {\n-                let msg = \"trait aliases cannot be `unsafe`\";\n-                self.struct_span_err(self.prev_span, msg)\n-                    .span_label(self.prev_span, msg)\n-                    .emit();\n-            }\n-            Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n-        } else {\n-            // it's a normal trait\n-            tps.where_clause = self.parse_where_clause()?;\n-            self.expect(&token::OpenDelim(token::Brace))?;\n-            let mut trait_items = vec![];\n-            while !self.eat(&token::CloseDelim(token::Brace)) {\n-                if let token::DocComment(_) = self.token.kind {\n-                    if self.look_ahead(1,\n-                    |tok| tok == &token::CloseDelim(token::Brace)) {\n-                        self.diagnostic().struct_span_err_with_code(\n-                            self.token.span,\n-                            \"found a documentation comment that doesn't document anything\",\n-                            DiagnosticId::Error(\"E0584\".into()),\n-                        )\n-                        .help(\n-                            \"doc comments must come before what they document, maybe a \\\n-                            comment was intended with `//`?\",\n-                        )\n-                        .emit();\n-                        self.bump();\n-                        continue;\n-                    }\n-                }\n-                let mut at_end = false;\n-                match self.parse_trait_item(&mut at_end) {\n-                    Ok(item) => trait_items.push(item),\n-                    Err(mut e) => {\n-                        e.emit();\n-                        if !at_end {\n-                            self.recover_stmt_(SemiColonMode::Break, BlockMode::Break);\n-                        }\n-                    }\n-                }\n-            }\n-            Ok((ident, ItemKind::Trait(is_auto, unsafety, tps, bounds, trait_items), None))\n-        }\n-    }\n-\n     fn choose_generics_over_qpath(&self) -> bool {\n         // There's an ambiguity between generic parameters and qualified paths in impls.\n         // If we see `<` it may start both, so we have to inspect some following tokens.\n@@ -3660,118 +3087,6 @@ impl<'a> Parser<'a> {\n             self.is_keyword_ahead(1, &[kw::Const]))\n     }\n \n-    fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {\n-        self.expect(&token::OpenDelim(token::Brace))?;\n-        let attrs = self.parse_inner_attributes()?;\n-\n-        let mut impl_items = Vec::new();\n-        while !self.eat(&token::CloseDelim(token::Brace)) {\n-            let mut at_end = false;\n-            match self.parse_impl_item(&mut at_end) {\n-                Ok(impl_item) => impl_items.push(impl_item),\n-                Err(mut err) => {\n-                    err.emit();\n-                    if !at_end {\n-                        self.recover_stmt_(SemiColonMode::Break, BlockMode::Break);\n-                    }\n-                }\n-            }\n-        }\n-        Ok((impl_items, attrs))\n-    }\n-\n-    /// Parses an implementation item, `impl` keyword is already parsed.\n-    ///\n-    ///    impl<'a, T> TYPE { /* impl items */ }\n-    ///    impl<'a, T> TRAIT for TYPE { /* impl items */ }\n-    ///    impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n-    ///\n-    /// We actually parse slightly more relaxed grammar for better error reporting and recovery.\n-    ///     `impl` GENERICS `!`? TYPE `for`? (TYPE | `..`) (`where` PREDICATES)? `{` BODY `}`\n-    ///     `impl` GENERICS `!`? TYPE (`where` PREDICATES)? `{` BODY `}`\n-    fn parse_item_impl(&mut self, unsafety: Unsafety, defaultness: Defaultness)\n-                       -> PResult<'a, ItemInfo> {\n-        // First, parse generic parameters if necessary.\n-        let mut generics = if self.choose_generics_over_qpath() {\n-            self.parse_generics()?\n-        } else {\n-            ast::Generics::default()\n-        };\n-\n-        // Disambiguate `impl !Trait for Type { ... }` and `impl ! { ... }` for the never type.\n-        let polarity = if self.check(&token::Not) && self.look_ahead(1, |t| t.can_begin_type()) {\n-            self.bump(); // `!`\n-            ast::ImplPolarity::Negative\n-        } else {\n-            ast::ImplPolarity::Positive\n-        };\n-\n-        // Parse both types and traits as a type, then reinterpret if necessary.\n-        let err_path = |span| ast::Path::from_ident(Ident::new(kw::Invalid, span));\n-        let ty_first = if self.token.is_keyword(kw::For) &&\n-                          self.look_ahead(1, |t| t != &token::Lt) {\n-            let span = self.prev_span.between(self.token.span);\n-            self.struct_span_err(span, \"missing trait in a trait impl\").emit();\n-            P(Ty { node: TyKind::Path(None, err_path(span)), span, id: ast::DUMMY_NODE_ID })\n-        } else {\n-            self.parse_ty()?\n-        };\n-\n-        // If `for` is missing we try to recover.\n-        let has_for = self.eat_keyword(kw::For);\n-        let missing_for_span = self.prev_span.between(self.token.span);\n-\n-        let ty_second = if self.token == token::DotDot {\n-            // We need to report this error after `cfg` expansion for compatibility reasons\n-            self.bump(); // `..`, do not add it to expected tokens\n-            Some(DummyResult::raw_ty(self.prev_span, true))\n-        } else if has_for || self.token.can_begin_type() {\n-            Some(self.parse_ty()?)\n-        } else {\n-            None\n-        };\n-\n-        generics.where_clause = self.parse_where_clause()?;\n-\n-        let (impl_items, attrs) = self.parse_impl_body()?;\n-\n-        let item_kind = match ty_second {\n-            Some(ty_second) => {\n-                // impl Trait for Type\n-                if !has_for {\n-                    self.struct_span_err(missing_for_span, \"missing `for` in a trait impl\")\n-                        .span_suggestion_short(\n-                            missing_for_span,\n-                            \"add `for` here\",\n-                            \" for \".to_string(),\n-                            Applicability::MachineApplicable,\n-                        ).emit();\n-                }\n-\n-                let ty_first = ty_first.into_inner();\n-                let path = match ty_first.node {\n-                    // This notably includes paths passed through `ty` macro fragments (#46438).\n-                    TyKind::Path(None, path) => path,\n-                    _ => {\n-                        self.span_err(ty_first.span, \"expected a trait, found type\");\n-                        err_path(ty_first.span)\n-                    }\n-                };\n-                let trait_ref = TraitRef { path, ref_id: ty_first.id };\n-\n-                ItemKind::Impl(unsafety, polarity, defaultness,\n-                               generics, Some(trait_ref), ty_second, impl_items)\n-            }\n-            None => {\n-                // impl Type\n-                ItemKind::Impl(unsafety, polarity, defaultness,\n-                               generics, None, ty_first, impl_items)\n-            }\n-        };\n-\n-        Ok((Ident::invalid(), item_kind, Some(attrs)))\n-    }\n-\n     fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n         if self.eat_keyword(kw::For) {\n             self.expect_lt()?;\n@@ -3785,227 +3100,27 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses `struct Foo { ... }`.\n-    fn parse_item_struct(&mut self) -> PResult<'a, ItemInfo> {\n-        let class_name = self.parse_ident()?;\n-\n-        let mut generics = self.parse_generics()?;\n+    /// Parses `pub`, `pub(crate)` and `pub(in path)` plus shortcuts `crate` for `pub(crate)`,\n+    /// `pub(self)` for `pub(in self)` and `pub(super)` for `pub(in super)`.\n+    /// If the following element can't be a tuple (i.e., it's a function definition), then\n+    /// it's not a tuple struct field), and the contents within the parentheses isn't valid,\n+    /// so emit a proper diagnostic.\n+    pub fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n+        maybe_whole!(self, NtVis, |x| x);\n \n-        // There is a special case worth noting here, as reported in issue #17904.\n-        // If we are parsing a tuple struct it is the case that the where clause\n-        // should follow the field list. Like so:\n-        //\n-        // struct Foo<T>(T) where T: Copy;\n-        //\n-        // If we are parsing a normal record-style struct it is the case\n-        // that the where clause comes before the body, and after the generics.\n-        // So if we look ahead and see a brace or a where-clause we begin\n-        // parsing a record style struct.\n-        //\n-        // Otherwise if we look ahead and see a paren we parse a tuple-style\n-        // struct.\n-\n-        let vdata = if self.token.is_keyword(kw::Where) {\n-            generics.where_clause = self.parse_where_clause()?;\n-            if self.eat(&token::Semi) {\n-                // If we see a: `struct Foo<T> where T: Copy;` style decl.\n-                VariantData::Unit(ast::DUMMY_NODE_ID)\n-            } else {\n-                // If we see: `struct Foo<T> where T: Copy { ... }`\n-                let (fields, recovered) = self.parse_record_struct_body()?;\n-                VariantData::Struct(fields, recovered)\n-            }\n-        // No `where` so: `struct Foo<T>;`\n-        } else if self.eat(&token::Semi) {\n-            VariantData::Unit(ast::DUMMY_NODE_ID)\n-        // Record-style struct definition\n-        } else if self.token == token::OpenDelim(token::Brace) {\n-            let (fields, recovered) = self.parse_record_struct_body()?;\n-            VariantData::Struct(fields, recovered)\n-        // Tuple-style struct definition with optional where-clause.\n-        } else if self.token == token::OpenDelim(token::Paren) {\n-            let body = VariantData::Tuple(self.parse_tuple_struct_body()?, ast::DUMMY_NODE_ID);\n-            generics.where_clause = self.parse_where_clause()?;\n-            self.expect(&token::Semi)?;\n-            body\n-        } else {\n-            let token_str = self.this_token_descr();\n-            let mut err = self.fatal(&format!(\n-                \"expected `where`, `{{`, `(`, or `;` after struct name, found {}\",\n-                token_str\n-            ));\n-            err.span_label(self.token.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n-            return Err(err);\n-        };\n+        self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n+        if self.is_crate_vis() {\n+            self.bump(); // `crate`\n+            return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n+        }\n \n-        Ok((class_name, ItemKind::Struct(vdata, generics), None))\n-    }\n-\n-    /// Parses `union Foo { ... }`.\n-    fn parse_item_union(&mut self) -> PResult<'a, ItemInfo> {\n-        let class_name = self.parse_ident()?;\n-\n-        let mut generics = self.parse_generics()?;\n-\n-        let vdata = if self.token.is_keyword(kw::Where) {\n-            generics.where_clause = self.parse_where_clause()?;\n-            let (fields, recovered) = self.parse_record_struct_body()?;\n-            VariantData::Struct(fields, recovered)\n-        } else if self.token == token::OpenDelim(token::Brace) {\n-            let (fields, recovered) = self.parse_record_struct_body()?;\n-            VariantData::Struct(fields, recovered)\n-        } else {\n-            let token_str = self.this_token_descr();\n-            let mut err = self.fatal(&format!(\n-                \"expected `where` or `{{` after union name, found {}\", token_str));\n-            err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n-            return Err(err);\n-        };\n-\n-        Ok((class_name, ItemKind::Union(vdata, generics), None))\n-    }\n-\n-    fn parse_record_struct_body(\n-        &mut self,\n-    ) -> PResult<'a, (Vec<StructField>, /* recovered */ bool)> {\n-        let mut fields = Vec::new();\n-        let mut recovered = false;\n-        if self.eat(&token::OpenDelim(token::Brace)) {\n-            while self.token != token::CloseDelim(token::Brace) {\n-                let field = self.parse_struct_decl_field().map_err(|e| {\n-                    self.recover_stmt();\n-                    recovered = true;\n-                    e\n-                });\n-                match field {\n-                    Ok(field) => fields.push(field),\n-                    Err(mut err) => {\n-                        err.emit();\n-                    }\n-                }\n-            }\n-            self.eat(&token::CloseDelim(token::Brace));\n-        } else {\n-            let token_str = self.this_token_descr();\n-            let mut err = self.fatal(&format!(\n-                    \"expected `where`, or `{{` after struct name, found {}\", token_str));\n-            err.span_label(self.token.span, \"expected `where`, or `{` after struct name\");\n-            return Err(err);\n-        }\n-\n-        Ok((fields, recovered))\n-    }\n-\n-    fn parse_tuple_struct_body(&mut self) -> PResult<'a, Vec<StructField>> {\n-        // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n-        // Unit like structs are handled in parse_item_struct function\n-        self.parse_paren_comma_seq(|p| {\n-            let attrs = p.parse_outer_attributes()?;\n-            let lo = p.token.span;\n-            let vis = p.parse_visibility(true)?;\n-            let ty = p.parse_ty()?;\n-            Ok(StructField {\n-                span: lo.to(ty.span),\n-                vis,\n-                ident: None,\n-                id: ast::DUMMY_NODE_ID,\n-                ty,\n-                attrs,\n-            })\n-        }).map(|(r, _)| r)\n-    }\n-\n-    /// Parses a structure field declaration.\n-    fn parse_single_struct_field(&mut self,\n-                                     lo: Span,\n-                                     vis: Visibility,\n-                                     attrs: Vec<Attribute> )\n-                                     -> PResult<'a, StructField> {\n-        let mut seen_comma: bool = false;\n-        let a_var = self.parse_name_and_ty(lo, vis, attrs)?;\n-        if self.token == token::Comma {\n-            seen_comma = true;\n-        }\n-        match self.token.kind {\n-            token::Comma => {\n-                self.bump();\n-            }\n-            token::CloseDelim(token::Brace) => {}\n-            token::DocComment(_) => {\n-                let previous_span = self.prev_span;\n-                let mut err = self.span_fatal_err(self.token.span, Error::UselessDocComment);\n-                self.bump(); // consume the doc comment\n-                let comma_after_doc_seen = self.eat(&token::Comma);\n-                // `seen_comma` is always false, because we are inside doc block\n-                // condition is here to make code more readable\n-                if seen_comma == false && comma_after_doc_seen == true {\n-                    seen_comma = true;\n-                }\n-                if comma_after_doc_seen || self.token == token::CloseDelim(token::Brace) {\n-                    err.emit();\n-                } else {\n-                    if seen_comma == false {\n-                        let sp = self.sess.source_map().next_point(previous_span);\n-                        err.span_suggestion(\n-                            sp,\n-                            \"missing comma here\",\n-                            \",\".into(),\n-                            Applicability::MachineApplicable\n-                        );\n-                    }\n-                    return Err(err);\n-                }\n-            }\n-            _ => {\n-                let sp = self.sess.source_map().next_point(self.prev_span);\n-                let mut err = self.struct_span_err(sp, &format!(\"expected `,`, or `}}`, found {}\",\n-                                                                self.this_token_descr()));\n-                if self.token.is_ident() {\n-                    // This is likely another field; emit the diagnostic and keep going\n-                    err.span_suggestion(\n-                        sp,\n-                        \"try adding a comma\",\n-                        \",\".into(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n-                } else {\n-                    return Err(err)\n-                }\n-            }\n-        }\n-        Ok(a_var)\n-    }\n-\n-    /// Parses an element of a struct declaration.\n-    fn parse_struct_decl_field(&mut self) -> PResult<'a, StructField> {\n-        let attrs = self.parse_outer_attributes()?;\n-        let lo = self.token.span;\n-        let vis = self.parse_visibility(false)?;\n-        self.parse_single_struct_field(lo, vis, attrs)\n-    }\n-\n-    /// Parses `pub`, `pub(crate)` and `pub(in path)` plus shortcuts `crate` for `pub(crate)`,\n-    /// `pub(self)` for `pub(in self)` and `pub(super)` for `pub(in super)`.\n-    /// If the following element can't be a tuple (i.e., it's a function definition), then\n-    /// it's not a tuple struct field), and the contents within the parentheses isn't valid,\n-    /// so emit a proper diagnostic.\n-    pub fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n-        maybe_whole!(self, NtVis, |x| x);\n-\n-        self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n-        if self.is_crate_vis() {\n-            self.bump(); // `crate`\n-            return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n-        }\n-\n-        if !self.eat_keyword(kw::Pub) {\n-            // We need a span for our `Spanned<VisibilityKind>`, but there's inherently no\n-            // keyword to grab a span from for inherited visibility; an empty span at the\n-            // beginning of the current token would seem to be the \"Schelling span\".\n-            return Ok(respan(self.token.span.shrink_to_lo(), VisibilityKind::Inherited))\n-        }\n-        let lo = self.prev_span;\n+        if !self.eat_keyword(kw::Pub) {\n+            // We need a span for our `Spanned<VisibilityKind>`, but there's inherently no\n+            // keyword to grab a span from for inherited visibility; an empty span at the\n+            // beginning of the current token would seem to be the \"Schelling span\".\n+            return Ok(respan(self.token.span.shrink_to_lo(), VisibilityKind::Inherited))\n+        }\n+        let lo = self.prev_span;\n \n         if self.check(&token::OpenDelim(token::Paren)) {\n             // We don't `self.bump()` the `(` yet because this might be a struct definition where\n@@ -4074,606 +3189,6 @@ impl<'a> Parser<'a> {\n         Ok(respan(lo, VisibilityKind::Public))\n     }\n \n-    /// Parses defaultness (i.e., `default` or nothing).\n-    fn parse_defaultness(&mut self) -> Defaultness {\n-        // `pub` is included for better error messages\n-        if self.check_keyword(kw::Default) &&\n-            self.is_keyword_ahead(1, &[\n-                kw::Impl,\n-                kw::Const,\n-                kw::Fn,\n-                kw::Unsafe,\n-                kw::Extern,\n-                kw::Type,\n-                kw::Pub,\n-            ])\n-        {\n-            self.bump(); // `default`\n-            Defaultness::Default\n-        } else {\n-            Defaultness::Final\n-        }\n-    }\n-\n-    /// Given a termination token, parses all of the items in a module.\n-    fn parse_mod_items(&mut self, term: &TokenKind, inner_lo: Span) -> PResult<'a, Mod> {\n-        let mut items = vec![];\n-        while let Some(item) = self.parse_item()? {\n-            items.push(item);\n-            self.maybe_consume_incorrect_semicolon(&items);\n-        }\n-\n-        if !self.eat(term) {\n-            let token_str = self.this_token_descr();\n-            if !self.maybe_consume_incorrect_semicolon(&items) {\n-                let mut err = self.fatal(&format!(\"expected item, found {}\", token_str));\n-                err.span_label(self.token.span, \"expected item\");\n-                return Err(err);\n-            }\n-        }\n-\n-        let hi = if self.token.span.is_dummy() {\n-            inner_lo\n-        } else {\n-            self.prev_span\n-        };\n-\n-        Ok(ast::Mod {\n-            inner: inner_lo.to(hi),\n-            items,\n-            inline: true\n-        })\n-    }\n-\n-    fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n-        let id = if m.is_none() { self.parse_ident_or_underscore() } else { self.parse_ident() }?;\n-        self.expect(&token::Colon)?;\n-        let ty = self.parse_ty()?;\n-        self.expect(&token::Eq)?;\n-        let e = self.parse_expr()?;\n-        self.expect(&token::Semi)?;\n-        let item = match m {\n-            Some(m) => ItemKind::Static(ty, m, e),\n-            None => ItemKind::Const(ty, e),\n-        };\n-        Ok((id, item, None))\n-    }\n-\n-    /// Parse a `mod <foo> { ... }` or `mod <foo>;` item\n-    fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> {\n-        let (in_cfg, outer_attrs) = {\n-            let mut strip_unconfigured = crate::config::StripUnconfigured {\n-                sess: self.sess,\n-                features: None, // don't perform gated feature checking\n-            };\n-            let mut outer_attrs = outer_attrs.to_owned();\n-            strip_unconfigured.process_cfg_attrs(&mut outer_attrs);\n-            (!self.cfg_mods || strip_unconfigured.in_cfg(&outer_attrs), outer_attrs)\n-        };\n-\n-        let id_span = self.token.span;\n-        let id = self.parse_ident()?;\n-        if self.eat(&token::Semi) {\n-            if in_cfg && self.recurse_into_file_modules {\n-                // This mod is in an external file. Let's go get it!\n-                let ModulePathSuccess { path, directory_ownership, warn } =\n-                    self.submod_path(id, &outer_attrs, id_span)?;\n-                let (module, mut attrs) =\n-                    self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n-                // Record that we fetched the mod from an external file\n-                if warn {\n-                    let attr = attr::mk_attr_outer(\n-                        attr::mk_word_item(Ident::with_empty_ctxt(sym::warn_directory_ownership)));\n-                    attr::mark_known(&attr);\n-                    attrs.push(attr);\n-                }\n-                Ok((id, ItemKind::Mod(module), Some(attrs)))\n-            } else {\n-                let placeholder = ast::Mod {\n-                    inner: DUMMY_SP,\n-                    items: Vec::new(),\n-                    inline: false\n-                };\n-                Ok((id, ItemKind::Mod(placeholder), None))\n-            }\n-        } else {\n-            let old_directory = self.directory.clone();\n-            self.push_directory(id, &outer_attrs);\n-\n-            self.expect(&token::OpenDelim(token::Brace))?;\n-            let mod_inner_lo = self.token.span;\n-            let attrs = self.parse_inner_attributes()?;\n-            let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n-\n-            self.directory = old_directory;\n-            Ok((id, ItemKind::Mod(module), Some(attrs)))\n-        }\n-    }\n-\n-    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n-        if let Some(path) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n-            self.directory.path.to_mut().push(&path.as_str());\n-            self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n-        } else {\n-            // We have to push on the current module name in the case of relative\n-            // paths in order to ensure that any additional module paths from inline\n-            // `mod x { ... }` come after the relative extension.\n-            //\n-            // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n-            // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n-            if let DirectoryOwnership::Owned { relative } = &mut self.directory.ownership {\n-                if let Some(ident) = relative.take() { // remove the relative offset\n-                    self.directory.path.to_mut().push(ident.as_str());\n-                }\n-            }\n-            self.directory.path.to_mut().push(&id.as_str());\n-        }\n-    }\n-\n-    pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n-        if let Some(s) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n-            let s = s.as_str();\n-\n-            // On windows, the base path might have the form\n-            // `\\\\?\\foo\\bar` in which case it does not tolerate\n-            // mixed `/` and `\\` separators, so canonicalize\n-            // `/` to `\\`.\n-            #[cfg(windows)]\n-            let s = s.replace(\"/\", \"\\\\\");\n-            Some(dir_path.join(s))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns a path to a module.\n-    pub fn default_submod_path(\n-        id: ast::Ident,\n-        relative: Option<ast::Ident>,\n-        dir_path: &Path,\n-        source_map: &SourceMap) -> ModulePath\n-    {\n-        // If we're in a foo.rs file instead of a mod.rs file,\n-        // we need to look for submodules in\n-        // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n-        // `./<id>.rs` and `./<id>/mod.rs`.\n-        let relative_prefix_string;\n-        let relative_prefix = if let Some(ident) = relative {\n-            relative_prefix_string = format!(\"{}{}\", ident.as_str(), path::MAIN_SEPARATOR);\n-            &relative_prefix_string\n-        } else {\n-            \"\"\n-        };\n-\n-        let mod_name = id.to_string();\n-        let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n-        let secondary_path_str = format!(\"{}{}{}mod.rs\",\n-                                         relative_prefix, mod_name, path::MAIN_SEPARATOR);\n-        let default_path = dir_path.join(&default_path_str);\n-        let secondary_path = dir_path.join(&secondary_path_str);\n-        let default_exists = source_map.file_exists(&default_path);\n-        let secondary_exists = source_map.file_exists(&secondary_path);\n-\n-        let result = match (default_exists, secondary_exists) {\n-            (true, false) => Ok(ModulePathSuccess {\n-                path: default_path,\n-                directory_ownership: DirectoryOwnership::Owned {\n-                    relative: Some(id),\n-                },\n-                warn: false,\n-            }),\n-            (false, true) => Ok(ModulePathSuccess {\n-                path: secondary_path,\n-                directory_ownership: DirectoryOwnership::Owned {\n-                    relative: None,\n-                },\n-                warn: false,\n-            }),\n-            (false, false) => Err(Error::FileNotFoundForModule {\n-                mod_name: mod_name.clone(),\n-                default_path: default_path_str,\n-                secondary_path: secondary_path_str,\n-                dir_path: dir_path.display().to_string(),\n-            }),\n-            (true, true) => Err(Error::DuplicatePaths {\n-                mod_name: mod_name.clone(),\n-                default_path: default_path_str,\n-                secondary_path: secondary_path_str,\n-            }),\n-        };\n-\n-        ModulePath {\n-            name: mod_name,\n-            path_exists: default_exists || secondary_exists,\n-            result,\n-        }\n-    }\n-\n-    fn submod_path(&mut self,\n-                   id: ast::Ident,\n-                   outer_attrs: &[Attribute],\n-                   id_sp: Span)\n-                   -> PResult<'a, ModulePathSuccess> {\n-        if let Some(path) = Parser::submod_path_from_attr(outer_attrs, &self.directory.path) {\n-            return Ok(ModulePathSuccess {\n-                directory_ownership: match path.file_name().and_then(|s| s.to_str()) {\n-                    // All `#[path]` files are treated as though they are a `mod.rs` file.\n-                    // This means that `mod foo;` declarations inside `#[path]`-included\n-                    // files are siblings,\n-                    //\n-                    // Note that this will produce weirdness when a file named `foo.rs` is\n-                    // `#[path]` included and contains a `mod foo;` declaration.\n-                    // If you encounter this, it's your own darn fault :P\n-                    Some(_) => DirectoryOwnership::Owned { relative: None },\n-                    _ => DirectoryOwnership::UnownedViaMod(true),\n-                },\n-                path,\n-                warn: false,\n-            });\n-        }\n-\n-        let relative = match self.directory.ownership {\n-            DirectoryOwnership::Owned { relative } => relative,\n-            DirectoryOwnership::UnownedViaBlock |\n-            DirectoryOwnership::UnownedViaMod(_) => None,\n-        };\n-        let paths = Parser::default_submod_path(\n-                        id, relative, &self.directory.path, self.sess.source_map());\n-\n-        match self.directory.ownership {\n-            DirectoryOwnership::Owned { .. } => {\n-                paths.result.map_err(|err| self.span_fatal_err(id_sp, err))\n-            },\n-            DirectoryOwnership::UnownedViaBlock => {\n-                let msg =\n-                    \"Cannot declare a non-inline module inside a block \\\n-                    unless it has a path attribute\";\n-                let mut err = self.diagnostic().struct_span_err(id_sp, msg);\n-                if paths.path_exists {\n-                    let msg = format!(\"Maybe `use` the module `{}` instead of redeclaring it\",\n-                                      paths.name);\n-                    err.span_note(id_sp, &msg);\n-                }\n-                Err(err)\n-            }\n-            DirectoryOwnership::UnownedViaMod(warn) => {\n-                if warn {\n-                    if let Ok(result) = paths.result {\n-                        return Ok(ModulePathSuccess { warn: true, ..result });\n-                    }\n-                }\n-                let mut err = self.diagnostic().struct_span_err(id_sp,\n-                    \"cannot declare a new module at this location\");\n-                if !id_sp.is_dummy() {\n-                    let src_path = self.sess.source_map().span_to_filename(id_sp);\n-                    if let FileName::Real(src_path) = src_path {\n-                        if let Some(stem) = src_path.file_stem() {\n-                            let mut dest_path = src_path.clone();\n-                            dest_path.set_file_name(stem);\n-                            dest_path.push(\"mod.rs\");\n-                            err.span_note(id_sp,\n-                                    &format!(\"maybe move this module `{}` to its own \\\n-                                                directory via `{}`\", src_path.display(),\n-                                            dest_path.display()));\n-                        }\n-                    }\n-                }\n-                if paths.path_exists {\n-                    err.span_note(id_sp,\n-                                  &format!(\"... or maybe `use` the module `{}` instead \\\n-                                            of possibly redeclaring it\",\n-                                           paths.name));\n-                }\n-                Err(err)\n-            }\n-        }\n-    }\n-\n-    /// Reads a module from a source file.\n-    fn eval_src_mod(\n-        &mut self,\n-        path: PathBuf,\n-        directory_ownership: DirectoryOwnership,\n-        name: String,\n-        id_sp: Span,\n-    ) -> PResult<'a, (ast::Mod, Vec<Attribute>)> {\n-        let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n-        if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n-            let mut err = String::from(\"circular modules: \");\n-            let len = included_mod_stack.len();\n-            for p in &included_mod_stack[i.. len] {\n-                err.push_str(&p.to_string_lossy());\n-                err.push_str(\" -> \");\n-            }\n-            err.push_str(&path.to_string_lossy());\n-            return Err(self.span_fatal(id_sp, &err[..]));\n-        }\n-        included_mod_stack.push(path.clone());\n-        drop(included_mod_stack);\n-\n-        let mut p0 =\n-            new_sub_parser_from_file(self.sess, &path, directory_ownership, Some(name), id_sp);\n-        p0.cfg_mods = self.cfg_mods;\n-        let mod_inner_lo = p0.token.span;\n-        let mod_attrs = p0.parse_inner_attributes()?;\n-        let mut m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n-        m0.inline = false;\n-        self.sess.included_mod_stack.borrow_mut().pop();\n-        Ok((m0, mod_attrs))\n-    }\n-\n-    /// Parses a function declaration from a foreign module.\n-    fn parse_item_foreign_fn(\n-        &mut self,\n-        vis: ast::Visibility,\n-        lo: Span,\n-        attrs: Vec<Attribute>,\n-        extern_sp: Span,\n-    ) -> PResult<'a, ForeignItem> {\n-        self.expect_keyword(kw::Fn)?;\n-\n-        let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl(true)?;\n-        generics.where_clause = self.parse_where_clause()?;\n-        let hi = self.token.span;\n-        self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n-        Ok(ast::ForeignItem {\n-            ident,\n-            attrs,\n-            node: ForeignItemKind::Fn(decl, generics),\n-            id: ast::DUMMY_NODE_ID,\n-            span: lo.to(hi),\n-            vis,\n-        })\n-    }\n-\n-    /// Parses a static item from a foreign module.\n-    /// Assumes that the `static` keyword is already parsed.\n-    fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n-                                 -> PResult<'a, ForeignItem> {\n-        let mutbl = self.parse_mutability();\n-        let ident = self.parse_ident()?;\n-        self.expect(&token::Colon)?;\n-        let ty = self.parse_ty()?;\n-        let hi = self.token.span;\n-        self.expect(&token::Semi)?;\n-        Ok(ForeignItem {\n-            ident,\n-            attrs,\n-            node: ForeignItemKind::Static(ty, mutbl),\n-            id: ast::DUMMY_NODE_ID,\n-            span: lo.to(hi),\n-            vis,\n-        })\n-    }\n-\n-    /// Parses a type from a foreign module.\n-    fn parse_item_foreign_type(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n-                             -> PResult<'a, ForeignItem> {\n-        self.expect_keyword(kw::Type)?;\n-\n-        let ident = self.parse_ident()?;\n-        let hi = self.token.span;\n-        self.expect(&token::Semi)?;\n-        Ok(ast::ForeignItem {\n-            ident,\n-            attrs,\n-            node: ForeignItemKind::Ty,\n-            id: ast::DUMMY_NODE_ID,\n-            span: lo.to(hi),\n-            vis\n-        })\n-    }\n-\n-    fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, ast::Ident> {\n-        let error_msg = \"crate name using dashes are not valid in `extern crate` statements\";\n-        let suggestion_msg = \"if the original crate name uses dashes you need to use underscores \\\n-                              in the code\";\n-        let mut ident = if self.token.is_keyword(kw::SelfLower) {\n-            self.parse_path_segment_ident()\n-        } else {\n-            self.parse_ident()\n-        }?;\n-        let mut idents = vec![];\n-        let mut replacement = vec![];\n-        let mut fixed_crate_name = false;\n-        // Accept `extern crate name-like-this` for better diagnostics\n-        let dash = token::BinOp(token::BinOpToken::Minus);\n-        if self.token == dash {  // Do not include `-` as part of the expected tokens list\n-            while self.eat(&dash) {\n-                fixed_crate_name = true;\n-                replacement.push((self.prev_span, \"_\".to_string()));\n-                idents.push(self.parse_ident()?);\n-            }\n-        }\n-        if fixed_crate_name {\n-            let fixed_name_sp = ident.span.to(idents.last().unwrap().span);\n-            let mut fixed_name = format!(\"{}\", ident.name);\n-            for part in idents {\n-                fixed_name.push_str(&format!(\"_{}\", part.name));\n-            }\n-            ident = Ident::from_str(&fixed_name).with_span_pos(fixed_name_sp);\n-\n-            self.struct_span_err(fixed_name_sp, error_msg)\n-                .span_label(fixed_name_sp, \"dash-separated idents are not valid\")\n-                .multipart_suggestion(suggestion_msg, replacement, Applicability::MachineApplicable)\n-                .emit();\n-        }\n-        Ok(ident)\n-    }\n-\n-    /// Parses `extern crate` links.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// extern crate foo;\n-    /// extern crate bar as foo;\n-    /// ```\n-    fn parse_item_extern_crate(&mut self,\n-                               lo: Span,\n-                               visibility: Visibility,\n-                               attrs: Vec<Attribute>)\n-                               -> PResult<'a, P<Item>> {\n-        // Accept `extern crate name-like-this` for better diagnostics\n-        let orig_name = self.parse_crate_name_with_dashes()?;\n-        let (item_name, orig_name) = if let Some(rename) = self.parse_rename()? {\n-            (rename, Some(orig_name.name))\n-        } else {\n-            (orig_name, None)\n-        };\n-        self.expect(&token::Semi)?;\n-\n-        let span = lo.to(self.prev_span);\n-        Ok(self.mk_item(span, item_name, ItemKind::ExternCrate(orig_name), visibility, attrs))\n-    }\n-\n-    /// Parses `extern` for foreign ABIs modules.\n-    ///\n-    /// `extern` is expected to have been\n-    /// consumed before calling this method.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore (only-for-syntax-highlight)\n-    /// extern \"C\" {}\n-    /// extern {}\n-    /// ```\n-    fn parse_item_foreign_mod(\n-        &mut self,\n-        lo: Span,\n-        opt_abi: Option<Abi>,\n-        visibility: Visibility,\n-        mut attrs: Vec<Attribute>,\n-        extern_sp: Span,\n-    ) -> PResult<'a, P<Item>> {\n-        self.expect(&token::OpenDelim(token::Brace))?;\n-\n-        let abi = opt_abi.unwrap_or(Abi::C);\n-\n-        attrs.extend(self.parse_inner_attributes()?);\n-\n-        let mut foreign_items = vec![];\n-        while !self.eat(&token::CloseDelim(token::Brace)) {\n-            foreign_items.push(self.parse_foreign_item(extern_sp)?);\n-        }\n-\n-        let prev_span = self.prev_span;\n-        let m = ast::ForeignMod {\n-            abi,\n-            items: foreign_items\n-        };\n-        let invalid = Ident::invalid();\n-        Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n-    }\n-\n-    /// Parses `type Foo = Bar;` or returns `None`\n-    /// without modifying the parser state.\n-    fn eat_type(&mut self) -> Option<PResult<'a, (Ident, AliasKind, ast::Generics)>> {\n-        // This parses the grammar:\n-        //     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n-        if self.eat_keyword(kw::Type) {\n-            Some(self.parse_type_alias())\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Parses a type alias or opaque type.\n-    fn parse_type_alias(&mut self) -> PResult<'a, (Ident, AliasKind, ast::Generics)> {\n-        let ident = self.parse_ident()?;\n-        let mut tps = self.parse_generics()?;\n-        tps.where_clause = self.parse_where_clause()?;\n-        self.expect(&token::Eq)?;\n-        let alias = if self.check_keyword(kw::Impl) {\n-            self.bump();\n-            let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n-            AliasKind::OpaqueTy(bounds)\n-        } else {\n-            let ty = self.parse_ty()?;\n-            AliasKind::Weak(ty)\n-        };\n-        self.expect(&token::Semi)?;\n-        Ok((ident, alias, tps))\n-    }\n-\n-    /// Parses the part of an enum declaration following the `{`.\n-    fn parse_enum_def(&mut self, _generics: &ast::Generics) -> PResult<'a, EnumDef> {\n-        let mut variants = Vec::new();\n-        while self.token != token::CloseDelim(token::Brace) {\n-            let variant_attrs = self.parse_outer_attributes()?;\n-            let vlo = self.token.span;\n-\n-            self.eat_bad_pub();\n-            let ident = self.parse_ident()?;\n-\n-            let struct_def = if self.check(&token::OpenDelim(token::Brace)) {\n-                // Parse a struct variant.\n-                let (fields, recovered) = self.parse_record_struct_body()?;\n-                VariantData::Struct(fields, recovered)\n-            } else if self.check(&token::OpenDelim(token::Paren)) {\n-                VariantData::Tuple(\n-                    self.parse_tuple_struct_body()?,\n-                    ast::DUMMY_NODE_ID,\n-                )\n-            } else {\n-                VariantData::Unit(ast::DUMMY_NODE_ID)\n-            };\n-\n-            let disr_expr = if self.eat(&token::Eq) {\n-                Some(AnonConst {\n-                    id: ast::DUMMY_NODE_ID,\n-                    value: self.parse_expr()?,\n-                })\n-            } else {\n-                None\n-            };\n-\n-            let vr = ast::Variant_ {\n-                ident,\n-                id: ast::DUMMY_NODE_ID,\n-                attrs: variant_attrs,\n-                data: struct_def,\n-                disr_expr,\n-            };\n-            variants.push(respan(vlo.to(self.prev_span), vr));\n-\n-            if !self.eat(&token::Comma) {\n-                if self.token.is_ident() && !self.token.is_reserved_ident() {\n-                    let sp = self.sess.source_map().next_point(self.prev_span);\n-                    self.struct_span_err(sp, \"missing comma\")\n-                        .span_suggestion_short(\n-                            sp,\n-                            \"missing comma\",\n-                            \",\".to_owned(),\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n-                } else {\n-                    break;\n-                }\n-            }\n-        }\n-        self.expect(&token::CloseDelim(token::Brace))?;\n-\n-        Ok(ast::EnumDef { variants })\n-    }\n-\n-    /// Parses an enum declaration.\n-    fn parse_item_enum(&mut self) -> PResult<'a, ItemInfo> {\n-        let id = self.parse_ident()?;\n-        let mut generics = self.parse_generics()?;\n-        generics.where_clause = self.parse_where_clause()?;\n-        self.expect(&token::OpenDelim(token::Brace))?;\n-\n-        let enum_definition = self.parse_enum_def(&generics).map_err(|e| {\n-            self.recover_stmt();\n-            self.eat(&token::CloseDelim(token::Brace));\n-            e\n-        })?;\n-        Ok((id, ItemKind::Enum(enum_definition, generics), None))\n-    }\n-\n     /// Parses a string as an ABI spec on an extern type or module. Consumes\n     /// the `extern` keyword, if one is found.\n     fn parse_opt_abi(&mut self) -> PResult<'a, Option<Abi>> {\n@@ -4706,489 +3221,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_static_global(&mut self) -> bool {\n-        if self.check_keyword(kw::Static) {\n-            // Check if this could be a closure\n-            !self.look_ahead(1, |token| {\n-                if token.is_keyword(kw::Move) {\n-                    return true;\n-                }\n-                match token.kind {\n-                    token::BinOp(token::Or) | token::OrOr => true,\n-                    _ => false,\n-                }\n-            })\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn parse_item_(\n-        &mut self,\n-        attrs: Vec<Attribute>,\n-        macros_allowed: bool,\n-        attributes_allowed: bool,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        let mut unclosed_delims = vec![];\n-        let (ret, tokens) = self.collect_tokens(|this| {\n-            let item = this.parse_item_implementation(attrs, macros_allowed, attributes_allowed);\n-            unclosed_delims.append(&mut this.unclosed_delims);\n-            item\n-        })?;\n-        self.unclosed_delims.append(&mut unclosed_delims);\n-\n-        // Once we've parsed an item and recorded the tokens we got while\n-        // parsing we may want to store `tokens` into the item we're about to\n-        // return. Note, though, that we specifically didn't capture tokens\n-        // related to outer attributes. The `tokens` field here may later be\n-        // used with procedural macros to convert this item back into a token\n-        // stream, but during expansion we may be removing attributes as we go\n-        // along.\n-        //\n-        // If we've got inner attributes then the `tokens` we've got above holds\n-        // these inner attributes. If an inner attribute is expanded we won't\n-        // actually remove it from the token stream, so we'll just keep yielding\n-        // it (bad!). To work around this case for now we just avoid recording\n-        // `tokens` if we detect any inner attributes. This should help keep\n-        // expansion correct, but we should fix this bug one day!\n-        Ok(ret.map(|item| {\n-            item.map(|mut i| {\n-                if !i.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n-                    i.tokens = Some(tokens);\n-                }\n-                i\n-            })\n-        }))\n-    }\n-\n-    /// Parses one of the items allowed by the flags.\n-    fn parse_item_implementation(\n-        &mut self,\n-        attrs: Vec<Attribute>,\n-        macros_allowed: bool,\n-        attributes_allowed: bool,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        maybe_whole!(self, NtItem, |item| {\n-            let mut item = item.into_inner();\n-            let mut attrs = attrs;\n-            mem::swap(&mut item.attrs, &mut attrs);\n-            item.attrs.extend(attrs);\n-            Some(P(item))\n-        });\n-\n-        let lo = self.token.span;\n-\n-        let visibility = self.parse_visibility(false)?;\n-\n-        if self.eat_keyword(kw::Use) {\n-            // USE ITEM\n-            let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n-            self.expect(&token::Semi)?;\n-\n-            let span = lo.to(self.prev_span);\n-            let item =\n-                self.mk_item(span, Ident::invalid(), item_, visibility, attrs);\n-            return Ok(Some(item));\n-        }\n-\n-        if self.eat_keyword(kw::Extern) {\n-            let extern_sp = self.prev_span;\n-            if self.eat_keyword(kw::Crate) {\n-                return Ok(Some(self.parse_item_extern_crate(lo, visibility, attrs)?));\n-            }\n-\n-            let opt_abi = self.parse_opt_abi()?;\n-\n-            if self.eat_keyword(kw::Fn) {\n-                // EXTERN FUNCTION ITEM\n-                let fn_span = self.prev_span;\n-                let abi = opt_abi.unwrap_or(Abi::C);\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(Unsafety::Normal,\n-                                       respan(fn_span, IsAsync::NotAsync),\n-                                       respan(fn_span, Constness::NotConst),\n-                                       abi)?;\n-                let prev_span = self.prev_span;\n-                let item = self.mk_item(lo.to(prev_span),\n-                                        ident,\n-                                        item_,\n-                                        visibility,\n-                                        maybe_append(attrs, extra_attrs));\n-                return Ok(Some(item));\n-            } else if self.check(&token::OpenDelim(token::Brace)) {\n-                return Ok(Some(\n-                    self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs, extern_sp)?,\n-                ));\n-            }\n-\n-            self.unexpected()?;\n-        }\n-\n-        if self.is_static_global() {\n-            self.bump();\n-            // STATIC ITEM\n-            let m = if self.eat_keyword(kw::Mut) {\n-                Mutability::Mutable\n-            } else {\n-                Mutability::Immutable\n-            };\n-            let (ident, item_, extra_attrs) = self.parse_item_const(Some(m))?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-        if self.eat_keyword(kw::Const) {\n-            let const_span = self.prev_span;\n-            if self.check_keyword(kw::Fn)\n-                || (self.check_keyword(kw::Unsafe)\n-                    && self.is_keyword_ahead(1, &[kw::Fn])) {\n-                // CONST FUNCTION ITEM\n-                let unsafety = self.parse_unsafety();\n-                self.bump();\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(unsafety,\n-                                       respan(const_span, IsAsync::NotAsync),\n-                                       respan(const_span, Constness::Const),\n-                                       Abi::Rust)?;\n-                let prev_span = self.prev_span;\n-                let item = self.mk_item(lo.to(prev_span),\n-                                        ident,\n-                                        item_,\n-                                        visibility,\n-                                        maybe_append(attrs, extra_attrs));\n-                return Ok(Some(item));\n-            }\n-\n-            // CONST ITEM\n-            if self.eat_keyword(kw::Mut) {\n-                let prev_span = self.prev_span;\n-                self.struct_span_err(prev_span, \"const globals cannot be mutable\")\n-                    .span_label(prev_span, \"cannot be mutable\")\n-                    .span_suggestion(\n-                        const_span,\n-                        \"you might want to declare a static instead\",\n-                        \"static\".to_owned(),\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                    .emit();\n-            }\n-            let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-\n-        // Parse `async unsafe? fn`.\n-        if self.check_keyword(kw::Async) {\n-            let async_span = self.token.span;\n-            if self.is_keyword_ahead(1, &[kw::Fn])\n-                || self.is_keyword_ahead(2, &[kw::Fn])\n-            {\n-                // ASYNC FUNCTION ITEM\n-                self.bump(); // `async`\n-                let unsafety = self.parse_unsafety(); // `unsafe`?\n-                self.expect_keyword(kw::Fn)?; // `fn`\n-                let fn_span = self.prev_span;\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(unsafety,\n-                                    respan(async_span, IsAsync::Async {\n-                                        closure_id: ast::DUMMY_NODE_ID,\n-                                        return_impl_trait_id: ast::DUMMY_NODE_ID,\n-                                    }),\n-                                    respan(fn_span, Constness::NotConst),\n-                                    Abi::Rust)?;\n-                let prev_span = self.prev_span;\n-                let item = self.mk_item(lo.to(prev_span),\n-                                        ident,\n-                                        item_,\n-                                        visibility,\n-                                        maybe_append(attrs, extra_attrs));\n-                self.ban_async_in_2015(async_span);\n-                return Ok(Some(item));\n-            }\n-        }\n-        if self.check_keyword(kw::Unsafe) &&\n-            self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n-        {\n-            // UNSAFE TRAIT ITEM\n-            self.bump(); // `unsafe`\n-            let is_auto = if self.eat_keyword(kw::Trait) {\n-                IsAuto::No\n-            } else {\n-                self.expect_keyword(kw::Auto)?;\n-                self.expect_keyword(kw::Trait)?;\n-                IsAuto::Yes\n-            };\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_trait(is_auto, Unsafety::Unsafe)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-        if self.check_keyword(kw::Impl) ||\n-           self.check_keyword(kw::Unsafe) &&\n-                self.is_keyword_ahead(1, &[kw::Impl]) ||\n-           self.check_keyword(kw::Default) &&\n-                self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe]) {\n-            // IMPL ITEM\n-            let defaultness = self.parse_defaultness();\n-            let unsafety = self.parse_unsafety();\n-            self.expect_keyword(kw::Impl)?;\n-            let (ident, item, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n-            let span = lo.to(self.prev_span);\n-            return Ok(Some(self.mk_item(span, ident, item, visibility,\n-                                        maybe_append(attrs, extra_attrs))));\n-        }\n-        if self.check_keyword(kw::Fn) {\n-            // FUNCTION ITEM\n-            self.bump();\n-            let fn_span = self.prev_span;\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(Unsafety::Normal,\n-                                   respan(fn_span, IsAsync::NotAsync),\n-                                   respan(fn_span, Constness::NotConst),\n-                                   Abi::Rust)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-        if self.check_keyword(kw::Unsafe)\n-            && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n-            // UNSAFE FUNCTION ITEM\n-            self.bump(); // `unsafe`\n-            // `{` is also expected after `unsafe`, in case of error, include it in the diagnostic\n-            self.check(&token::OpenDelim(token::Brace));\n-            let abi = if self.eat_keyword(kw::Extern) {\n-                self.parse_opt_abi()?.unwrap_or(Abi::C)\n-            } else {\n-                Abi::Rust\n-            };\n-            self.expect_keyword(kw::Fn)?;\n-            let fn_span = self.prev_span;\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(Unsafety::Unsafe,\n-                                   respan(fn_span, IsAsync::NotAsync),\n-                                   respan(fn_span, Constness::NotConst),\n-                                   abi)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-        if self.eat_keyword(kw::Mod) {\n-            // MODULE ITEM\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_mod(&attrs[..])?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-        if let Some(type_) = self.eat_type() {\n-            let (ident, alias, generics) = type_?;\n-            // TYPE ITEM\n-            let item_ = match alias {\n-                AliasKind::Weak(ty) => ItemKind::TyAlias(ty, generics),\n-                AliasKind::OpaqueTy(bounds) => ItemKind::OpaqueTy(bounds, generics),\n-            };\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    attrs);\n-            return Ok(Some(item));\n-        }\n-        if self.eat_keyword(kw::Enum) {\n-            // ENUM ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-        if self.check_keyword(kw::Trait)\n-            || (self.check_keyword(kw::Auto)\n-                && self.is_keyword_ahead(1, &[kw::Trait]))\n-        {\n-            let is_auto = if self.eat_keyword(kw::Trait) {\n-                IsAuto::No\n-            } else {\n-                self.expect_keyword(kw::Auto)?;\n-                self.expect_keyword(kw::Trait)?;\n-                IsAuto::Yes\n-            };\n-            // TRAIT ITEM\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_trait(is_auto, Unsafety::Normal)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-        if self.eat_keyword(kw::Struct) {\n-            // STRUCT ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-        if self.is_union_item() {\n-            // UNION ITEM\n-            self.bump();\n-            let (ident, item_, extra_attrs) = self.parse_item_union()?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-        if let Some(macro_def) = self.eat_macro_def(&attrs, &visibility, lo)? {\n-            return Ok(Some(macro_def));\n-        }\n-\n-        // Verify whether we have encountered a struct or method definition where the user forgot to\n-        // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n-        if visibility.node.is_pub() &&\n-            self.check_ident() &&\n-            self.look_ahead(1, |t| *t != token::Not)\n-        {\n-            // Space between `pub` keyword and the identifier\n-            //\n-            //     pub   S {}\n-            //        ^^^ `sp` points here\n-            let sp = self.prev_span.between(self.token.span);\n-            let full_sp = self.prev_span.to(self.token.span);\n-            let ident_sp = self.token.span;\n-            if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n-                // possible public struct definition where `struct` was forgotten\n-                let ident = self.parse_ident().unwrap();\n-                let msg = format!(\"add `struct` here to parse `{}` as a public struct\",\n-                                  ident);\n-                let mut err = self.diagnostic()\n-                    .struct_span_err(sp, \"missing `struct` for struct definition\");\n-                err.span_suggestion_short(\n-                    sp, &msg, \" struct \".into(), Applicability::MaybeIncorrect // speculative\n-                );\n-                return Err(err);\n-            } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n-                let ident = self.parse_ident().unwrap();\n-                self.bump();  // `(`\n-                let kw_name = if let Ok(Some(_)) = self.parse_self_arg_with_attrs()\n-                    .map_err(|mut e| e.cancel())\n-                {\n-                    \"method\"\n-                } else {\n-                    \"function\"\n-                };\n-                self.consume_block(token::Paren);\n-                let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n-                    self.eat_to_tokens(&[&token::OpenDelim(token::Brace)]);\n-                    self.bump();  // `{`\n-                    (\"fn\", kw_name, false)\n-                } else if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.bump();  // `{`\n-                    (\"fn\", kw_name, false)\n-                } else if self.check(&token::Colon) {\n-                    let kw = \"struct\";\n-                    (kw, kw, false)\n-                } else {\n-                    (\"fn` or `struct\", \"function or struct\", true)\n-                };\n-\n-                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n-                if !ambiguous {\n-                    self.consume_block(token::Brace);\n-                    let suggestion = format!(\"add `{}` here to parse `{}` as a public {}\",\n-                                             kw,\n-                                             ident,\n-                                             kw_name);\n-                    err.span_suggestion_short(\n-                        sp, &suggestion, format!(\" {} \", kw), Applicability::MachineApplicable\n-                    );\n-                } else {\n-                    if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n-                        err.span_suggestion(\n-                            full_sp,\n-                            \"if you meant to call a macro, try\",\n-                            format!(\"{}!\", snippet),\n-                            // this is the `ambiguous` conditional branch\n-                            Applicability::MaybeIncorrect\n-                        );\n-                    } else {\n-                        err.help(\"if you meant to call a macro, remove the `pub` \\\n-                                  and add a trailing `!` after the identifier\");\n-                    }\n-                }\n-                return Err(err);\n-            } else if self.look_ahead(1, |t| *t == token::Lt) {\n-                let ident = self.parse_ident().unwrap();\n-                self.eat_to_tokens(&[&token::Gt]);\n-                self.bump();  // `>`\n-                let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n-                    if let Ok(Some(_)) = self.parse_self_arg_with_attrs()\n-                        .map_err(|mut e| e.cancel())\n-                    {\n-                        (\"fn\", \"method\", false)\n-                    } else {\n-                        (\"fn\", \"function\", false)\n-                    }\n-                } else if self.check(&token::OpenDelim(token::Brace)) {\n-                    (\"struct\", \"struct\", false)\n-                } else {\n-                    (\"fn` or `struct\", \"function or struct\", true)\n-                };\n-                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n-                if !ambiguous {\n-                    err.span_suggestion_short(\n-                        sp,\n-                        &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n-                        format!(\" {} \", kw),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                return Err(err);\n-            }\n-        }\n-        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, visibility)\n-    }\n-\n     /// We are parsing `async fn`. If we are on Rust 2015, emit an error.\n     fn ban_async_in_2015(&self, async_span: Span) {\n         if async_span.rust_2015() {\n@@ -5202,155 +3234,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses a foreign item.\n-    crate fn parse_foreign_item(&mut self, extern_sp: Span) -> PResult<'a, ForeignItem> {\n-        maybe_whole!(self, NtForeignItem, |ni| ni);\n-\n-        let attrs = self.parse_outer_attributes()?;\n-        let lo = self.token.span;\n-        let visibility = self.parse_visibility(false)?;\n-\n-        // FOREIGN STATIC ITEM\n-        // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n-        if self.check_keyword(kw::Static) || self.token.is_keyword(kw::Const) {\n-            if self.token.is_keyword(kw::Const) {\n-                self.diagnostic()\n-                    .struct_span_err(self.token.span, \"extern items cannot be `const`\")\n-                    .span_suggestion(\n-                        self.token.span,\n-                        \"try using a static value\",\n-                        \"static\".to_owned(),\n-                        Applicability::MachineApplicable\n-                    ).emit();\n-            }\n-            self.bump(); // `static` or `const`\n-            return Ok(self.parse_item_foreign_static(visibility, lo, attrs)?);\n-        }\n-        // FOREIGN FUNCTION ITEM\n-        if self.check_keyword(kw::Fn) {\n-            return Ok(self.parse_item_foreign_fn(visibility, lo, attrs, extern_sp)?);\n-        }\n-        // FOREIGN TYPE ITEM\n-        if self.check_keyword(kw::Type) {\n-            return Ok(self.parse_item_foreign_type(visibility, lo, attrs)?);\n-        }\n-\n-        match self.parse_assoc_macro_invoc(\"extern\", Some(&visibility), &mut false)? {\n-            Some(mac) => {\n-                Ok(\n-                    ForeignItem {\n-                        ident: Ident::invalid(),\n-                        span: lo.to(self.prev_span),\n-                        id: ast::DUMMY_NODE_ID,\n-                        attrs,\n-                        vis: visibility,\n-                        node: ForeignItemKind::Macro(mac),\n-                    }\n-                )\n-            }\n-            None => {\n-                if !attrs.is_empty()  {\n-                    self.expected_item_err(&attrs)?;\n-                }\n-\n-                self.unexpected()\n-            }\n-        }\n-    }\n-\n-    /// This is the fall-through for parsing items.\n-    fn parse_macro_use_or_failure(\n-        &mut self,\n-        attrs: Vec<Attribute> ,\n-        macros_allowed: bool,\n-        attributes_allowed: bool,\n-        lo: Span,\n-        visibility: Visibility\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        if macros_allowed && self.token.is_path_start() &&\n-                !(self.is_async_fn() && self.token.span.rust_2015()) {\n-            // MACRO INVOCATION ITEM\n-\n-            let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&visibility.node, prev_span);\n-\n-            let mac_lo = self.token.span;\n-\n-            // item macro.\n-            let path = self.parse_path(PathStyle::Mod)?;\n-            self.expect(&token::Not)?;\n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n-                self.report_invalid_macro_expansion_item();\n-            }\n-\n-            let hi = self.prev_span;\n-            let mac = respan(mac_lo.to(hi), Mac_ {\n-                path,\n-                tts,\n-                delim,\n-                prior_type_ascription: self.last_type_ascription,\n-            });\n-            let item =\n-                self.mk_item(lo.to(hi), Ident::invalid(), ItemKind::Mac(mac), visibility, attrs);\n-            return Ok(Some(item));\n-        }\n-\n-        // FAILURE TO PARSE ITEM\n-        match visibility.node {\n-            VisibilityKind::Inherited => {}\n-            _ => {\n-                return Err(self.span_fatal(self.prev_span, \"unmatched visibility `pub`\"));\n-            }\n-        }\n-\n-        if !attributes_allowed && !attrs.is_empty() {\n-            self.expected_item_err(&attrs)?;\n-        }\n-        Ok(None)\n-    }\n-\n-    /// Parses a macro invocation inside a `trait`, `impl` or `extern` block.\n-    fn parse_assoc_macro_invoc(&mut self, item_kind: &str, vis: Option<&Visibility>,\n-                               at_end: &mut bool) -> PResult<'a, Option<Mac>>\n-    {\n-        if self.token.is_path_start() &&\n-                !(self.is_async_fn() && self.token.span.rust_2015()) {\n-            let prev_span = self.prev_span;\n-            let lo = self.token.span;\n-            let path = self.parse_path(PathStyle::Mod)?;\n-\n-            if path.segments.len() == 1 {\n-                if !self.eat(&token::Not) {\n-                    return Err(self.missing_assoc_item_kind_err(item_kind, prev_span));\n-                }\n-            } else {\n-                self.expect(&token::Not)?;\n-            }\n-\n-            if let Some(vis) = vis {\n-                self.complain_if_pub_macro(&vis.node, prev_span);\n-            }\n-\n-            *at_end = true;\n-\n-            // eat a matched-delimiter token tree:\n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace {\n-                self.expect(&token::Semi)?;\n-            }\n-\n-            Ok(Some(respan(lo.to(self.prev_span), Mac_ {\n-                path,\n-                tts,\n-                delim,\n-                prior_type_ascription: self.last_type_ascription,\n-            })))\n-        } else {\n-            Ok(None)\n-        }\n-    }\n-\n     fn collect_tokens<F, R>(&mut self, f: F) -> PResult<'a, (R, TokenStream)>\n         where F: FnOnce(&mut Self) -> PResult<'a, R>\n     {\n@@ -5420,94 +3303,13 @@ impl<'a> Parser<'a> {\n         Ok((ret?, TokenStream::new(collected_tokens)))\n     }\n \n-    pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n-        let attrs = self.parse_outer_attributes()?;\n-        self.parse_item_(attrs, true, false)\n-    }\n-\n     /// `::{` or `::*`\n     fn is_import_coupler(&mut self) -> bool {\n         self.check(&token::ModSep) &&\n             self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace) ||\n                                    *t == token::BinOp(token::Star))\n     }\n \n-    /// Parses a `UseTree`.\n-    ///\n-    /// ```\n-    /// USE_TREE = [`::`] `*` |\n-    ///            [`::`] `{` USE_TREE_LIST `}` |\n-    ///            PATH `::` `*` |\n-    ///            PATH `::` `{` USE_TREE_LIST `}` |\n-    ///            PATH [`as` IDENT]\n-    /// ```\n-    fn parse_use_tree(&mut self) -> PResult<'a, UseTree> {\n-        let lo = self.token.span;\n-\n-        let mut prefix = ast::Path { segments: Vec::new(), span: lo.shrink_to_lo() };\n-        let kind = if self.check(&token::OpenDelim(token::Brace)) ||\n-                      self.check(&token::BinOp(token::Star)) ||\n-                      self.is_import_coupler() {\n-            // `use *;` or `use ::*;` or `use {...};` or `use ::{...};`\n-            let mod_sep_ctxt = self.token.span.ctxt();\n-            if self.eat(&token::ModSep) {\n-                prefix.segments.push(\n-                    PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt))\n-                );\n-            }\n-\n-            if self.eat(&token::BinOp(token::Star)) {\n-                UseTreeKind::Glob\n-            } else {\n-                UseTreeKind::Nested(self.parse_use_tree_list()?)\n-            }\n-        } else {\n-            // `use path::*;` or `use path::{...};` or `use path;` or `use path as bar;`\n-            prefix = self.parse_path(PathStyle::Mod)?;\n-\n-            if self.eat(&token::ModSep) {\n-                if self.eat(&token::BinOp(token::Star)) {\n-                    UseTreeKind::Glob\n-                } else {\n-                    UseTreeKind::Nested(self.parse_use_tree_list()?)\n-                }\n-            } else {\n-                UseTreeKind::Simple(self.parse_rename()?, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID)\n-            }\n-        };\n-\n-        Ok(UseTree { prefix, kind, span: lo.to(self.prev_span) })\n-    }\n-\n-    /// Parses a `UseTreeKind::Nested(list)`.\n-    ///\n-    /// ```\n-    /// USE_TREE_LIST = \u00d8 | (USE_TREE `,`)* USE_TREE [`,`]\n-    /// ```\n-    fn parse_use_tree_list(&mut self) -> PResult<'a, Vec<(UseTree, ast::NodeId)>> {\n-        self.parse_delim_comma_seq(token::Brace, |p| Ok((p.parse_use_tree()?, ast::DUMMY_NODE_ID)))\n-            .map(|(r, _)| r)\n-    }\n-\n-    fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {\n-        if self.eat_keyword(kw::As) {\n-            self.parse_ident_or_underscore().map(Some)\n-        } else {\n-            Ok(None)\n-        }\n-    }\n-\n-    /// Parses a source module as a crate. This is the main entry point for the parser.\n-    pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n-        let lo = self.token.span;\n-        let krate = Ok(ast::Crate {\n-            attrs: self.parse_inner_attributes()?,\n-            module: self.parse_mod_items(&token::Eof, lo)?,\n-            span: lo.to(self.token.span),\n-        });\n-        krate\n-    }\n-\n     pub fn parse_optional_str(&mut self) -> Option<(Symbol, ast::StrStyle, Option<ast::Name>)> {\n         let ret = match self.token.kind {\n             token::Literal(token::Lit { kind: token::Str, symbol, suffix }) =>"}, {"sha": "5e264a0ca775341f2c8a8a75d718b6171eda0e1a", "filename": "src/libsyntax/parse/parser/item.rs", "status": "added", "additions": 1899, "deletions": 0, "changes": 1899, "blob_url": "https://github.com/rust-lang/rust/blob/e81347c3685dfc818fca2d502819ee0d1b692621/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81347c3685dfc818fca2d502819ee0d1b692621/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=e81347c3685dfc818fca2d502819ee0d1b692621", "patch": "@@ -0,0 +1,1899 @@\n+use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode};\n+\n+use crate::maybe_whole;\n+use crate::ptr::P;\n+use crate::ast::{self, Ident, Attribute, AttrStyle};\n+use crate::ast::{Item, ItemKind, ImplItem, TraitItem, TraitItemKind};\n+use crate::ast::{UseTree, UseTreeKind, PathSegment};\n+use crate::ast::{IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n+use crate::ast::{Visibility, VisibilityKind, Mutability, FnDecl, FnHeader};\n+use crate::ast::{ForeignItem, ForeignItemKind};\n+use crate::ast::{Ty, TyKind, GenericBounds, TraitRef};\n+use crate::ast::{EnumDef, VariantData, StructField, AnonConst};\n+use crate::ast::{Mac, Mac_, MacDelimiter};\n+use crate::ext::base::DummyResult;\n+use crate::parse::token;\n+use crate::parse::parser::maybe_append;\n+use crate::parse::diagnostics::{Error};\n+use crate::tokenstream::{TokenTree, TokenStream};\n+use crate::source_map::{respan, Span, Spanned};\n+use crate::symbol::{kw, sym};\n+\n+use std::mem;\n+use log::debug;\n+use rustc_target::spec::abi::{Abi};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+\n+/// Whether the type alias or associated type is a concrete type or an opaque type\n+#[derive(Debug)]\n+pub enum AliasKind {\n+    /// Just a new name for the same type\n+    Weak(P<Ty>),\n+    /// Only trait impls of the type will be usable, not the actual type itself\n+    OpaqueTy(GenericBounds),\n+}\n+\n+pub(super) type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute>>);\n+\n+impl<'a> Parser<'a> {\n+    pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n+        let attrs = self.parse_outer_attributes()?;\n+        self.parse_item_(attrs, true, false)\n+    }\n+\n+    pub(super) fn parse_item_(\n+        &mut self,\n+        attrs: Vec<Attribute>,\n+        macros_allowed: bool,\n+        attributes_allowed: bool,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let mut unclosed_delims = vec![];\n+        let (ret, tokens) = self.collect_tokens(|this| {\n+            let item = this.parse_item_implementation(attrs, macros_allowed, attributes_allowed);\n+            unclosed_delims.append(&mut this.unclosed_delims);\n+            item\n+        })?;\n+        self.unclosed_delims.append(&mut unclosed_delims);\n+\n+        // Once we've parsed an item and recorded the tokens we got while\n+        // parsing we may want to store `tokens` into the item we're about to\n+        // return. Note, though, that we specifically didn't capture tokens\n+        // related to outer attributes. The `tokens` field here may later be\n+        // used with procedural macros to convert this item back into a token\n+        // stream, but during expansion we may be removing attributes as we go\n+        // along.\n+        //\n+        // If we've got inner attributes then the `tokens` we've got above holds\n+        // these inner attributes. If an inner attribute is expanded we won't\n+        // actually remove it from the token stream, so we'll just keep yielding\n+        // it (bad!). To work around this case for now we just avoid recording\n+        // `tokens` if we detect any inner attributes. This should help keep\n+        // expansion correct, but we should fix this bug one day!\n+        Ok(ret.map(|item| {\n+            item.map(|mut i| {\n+                if !i.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+                    i.tokens = Some(tokens);\n+                }\n+                i\n+            })\n+        }))\n+    }\n+\n+    /// Parses one of the items allowed by the flags.\n+    fn parse_item_implementation(\n+        &mut self,\n+        attrs: Vec<Attribute>,\n+        macros_allowed: bool,\n+        attributes_allowed: bool,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        maybe_whole!(self, NtItem, |item| {\n+            let mut item = item.into_inner();\n+            let mut attrs = attrs;\n+            mem::swap(&mut item.attrs, &mut attrs);\n+            item.attrs.extend(attrs);\n+            Some(P(item))\n+        });\n+\n+        let lo = self.token.span;\n+\n+        let visibility = self.parse_visibility(false)?;\n+\n+        if self.eat_keyword(kw::Use) {\n+            // USE ITEM\n+            let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n+            self.expect(&token::Semi)?;\n+\n+            let span = lo.to(self.prev_span);\n+            let item =\n+                self.mk_item(span, Ident::invalid(), item_, visibility, attrs);\n+            return Ok(Some(item));\n+        }\n+\n+        if self.eat_keyword(kw::Extern) {\n+            let extern_sp = self.prev_span;\n+            if self.eat_keyword(kw::Crate) {\n+                return Ok(Some(self.parse_item_extern_crate(lo, visibility, attrs)?));\n+            }\n+\n+            let opt_abi = self.parse_opt_abi()?;\n+\n+            if self.eat_keyword(kw::Fn) {\n+                // EXTERN FUNCTION ITEM\n+                let fn_span = self.prev_span;\n+                let abi = opt_abi.unwrap_or(Abi::C);\n+                let (ident, item_, extra_attrs) =\n+                    self.parse_item_fn(Unsafety::Normal,\n+                                       respan(fn_span, IsAsync::NotAsync),\n+                                       respan(fn_span, Constness::NotConst),\n+                                       abi)?;\n+                let prev_span = self.prev_span;\n+                let item = self.mk_item(lo.to(prev_span),\n+                                        ident,\n+                                        item_,\n+                                        visibility,\n+                                        maybe_append(attrs, extra_attrs));\n+                return Ok(Some(item));\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n+                return Ok(Some(\n+                    self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs, extern_sp)?,\n+                ));\n+            }\n+\n+            self.unexpected()?;\n+        }\n+\n+        if self.is_static_global() {\n+            self.bump();\n+            // STATIC ITEM\n+            let m = self.parse_mutability();\n+            let (ident, item_, extra_attrs) = self.parse_item_const(Some(m))?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.eat_keyword(kw::Const) {\n+            let const_span = self.prev_span;\n+            if self.check_keyword(kw::Fn)\n+                || (self.check_keyword(kw::Unsafe)\n+                    && self.is_keyword_ahead(1, &[kw::Fn])) {\n+                // CONST FUNCTION ITEM\n+                let unsafety = self.parse_unsafety();\n+                self.bump();\n+                let (ident, item_, extra_attrs) =\n+                    self.parse_item_fn(unsafety,\n+                                       respan(const_span, IsAsync::NotAsync),\n+                                       respan(const_span, Constness::Const),\n+                                       Abi::Rust)?;\n+                let prev_span = self.prev_span;\n+                let item = self.mk_item(lo.to(prev_span),\n+                                        ident,\n+                                        item_,\n+                                        visibility,\n+                                        maybe_append(attrs, extra_attrs));\n+                return Ok(Some(item));\n+            }\n+\n+            // CONST ITEM\n+            if self.eat_keyword(kw::Mut) {\n+                let prev_span = self.prev_span;\n+                self.struct_span_err(prev_span, \"const globals cannot be mutable\")\n+                    .span_label(prev_span, \"cannot be mutable\")\n+                    .span_suggestion(\n+                        const_span,\n+                        \"you might want to declare a static instead\",\n+                        \"static\".to_owned(),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n+            }\n+            let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+\n+        // Parse `async unsafe? fn`.\n+        if self.check_keyword(kw::Async) {\n+            let async_span = self.token.span;\n+            if self.is_keyword_ahead(1, &[kw::Fn])\n+                || self.is_keyword_ahead(2, &[kw::Fn])\n+            {\n+                // ASYNC FUNCTION ITEM\n+                self.bump(); // `async`\n+                let unsafety = self.parse_unsafety(); // `unsafe`?\n+                self.expect_keyword(kw::Fn)?; // `fn`\n+                let fn_span = self.prev_span;\n+                let (ident, item_, extra_attrs) =\n+                    self.parse_item_fn(unsafety,\n+                                    respan(async_span, IsAsync::Async {\n+                                        closure_id: ast::DUMMY_NODE_ID,\n+                                        return_impl_trait_id: ast::DUMMY_NODE_ID,\n+                                    }),\n+                                    respan(fn_span, Constness::NotConst),\n+                                    Abi::Rust)?;\n+                let prev_span = self.prev_span;\n+                let item = self.mk_item(lo.to(prev_span),\n+                                        ident,\n+                                        item_,\n+                                        visibility,\n+                                        maybe_append(attrs, extra_attrs));\n+                self.ban_async_in_2015(async_span);\n+                return Ok(Some(item));\n+            }\n+        }\n+        if self.check_keyword(kw::Unsafe) &&\n+            self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n+        {\n+            // UNSAFE TRAIT ITEM\n+            self.bump(); // `unsafe`\n+            let is_auto = if self.eat_keyword(kw::Trait) {\n+                IsAuto::No\n+            } else {\n+                self.expect_keyword(kw::Auto)?;\n+                self.expect_keyword(kw::Trait)?;\n+                IsAuto::Yes\n+            };\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_trait(is_auto, Unsafety::Unsafe)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.check_keyword(kw::Impl) ||\n+           self.check_keyword(kw::Unsafe) &&\n+                self.is_keyword_ahead(1, &[kw::Impl]) ||\n+           self.check_keyword(kw::Default) &&\n+                self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe]) {\n+            // IMPL ITEM\n+            let defaultness = self.parse_defaultness();\n+            let unsafety = self.parse_unsafety();\n+            self.expect_keyword(kw::Impl)?;\n+            let (ident, item, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n+            let span = lo.to(self.prev_span);\n+            return Ok(Some(self.mk_item(span, ident, item, visibility,\n+                                        maybe_append(attrs, extra_attrs))));\n+        }\n+        if self.check_keyword(kw::Fn) {\n+            // FUNCTION ITEM\n+            self.bump();\n+            let fn_span = self.prev_span;\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_fn(Unsafety::Normal,\n+                                   respan(fn_span, IsAsync::NotAsync),\n+                                   respan(fn_span, Constness::NotConst),\n+                                   Abi::Rust)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.check_keyword(kw::Unsafe)\n+            && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n+            // UNSAFE FUNCTION ITEM\n+            self.bump(); // `unsafe`\n+            // `{` is also expected after `unsafe`, in case of error, include it in the diagnostic\n+            self.check(&token::OpenDelim(token::Brace));\n+            let abi = if self.eat_keyword(kw::Extern) {\n+                self.parse_opt_abi()?.unwrap_or(Abi::C)\n+            } else {\n+                Abi::Rust\n+            };\n+            self.expect_keyword(kw::Fn)?;\n+            let fn_span = self.prev_span;\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_fn(Unsafety::Unsafe,\n+                                   respan(fn_span, IsAsync::NotAsync),\n+                                   respan(fn_span, Constness::NotConst),\n+                                   abi)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.eat_keyword(kw::Mod) {\n+            // MODULE ITEM\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_mod(&attrs[..])?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if let Some(type_) = self.eat_type() {\n+            let (ident, alias, generics) = type_?;\n+            // TYPE ITEM\n+            let item_ = match alias {\n+                AliasKind::Weak(ty) => ItemKind::TyAlias(ty, generics),\n+                AliasKind::OpaqueTy(bounds) => ItemKind::OpaqueTy(bounds, generics),\n+            };\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    attrs);\n+            return Ok(Some(item));\n+        }\n+        if self.eat_keyword(kw::Enum) {\n+            // ENUM ITEM\n+            let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.check_keyword(kw::Trait)\n+            || (self.check_keyword(kw::Auto)\n+                && self.is_keyword_ahead(1, &[kw::Trait]))\n+        {\n+            let is_auto = if self.eat_keyword(kw::Trait) {\n+                IsAuto::No\n+            } else {\n+                self.expect_keyword(kw::Auto)?;\n+                self.expect_keyword(kw::Trait)?;\n+                IsAuto::Yes\n+            };\n+            // TRAIT ITEM\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_trait(is_auto, Unsafety::Normal)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.eat_keyword(kw::Struct) {\n+            // STRUCT ITEM\n+            let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if self.is_union_item() {\n+            // UNION ITEM\n+            self.bump();\n+            let (ident, item_, extra_attrs) = self.parse_item_union()?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n+        if let Some(macro_def) = self.eat_macro_def(&attrs, &visibility, lo)? {\n+            return Ok(Some(macro_def));\n+        }\n+\n+        // Verify whether we have encountered a struct or method definition where the user forgot to\n+        // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n+        if visibility.node.is_pub() &&\n+            self.check_ident() &&\n+            self.look_ahead(1, |t| *t != token::Not)\n+        {\n+            // Space between `pub` keyword and the identifier\n+            //\n+            //     pub   S {}\n+            //        ^^^ `sp` points here\n+            let sp = self.prev_span.between(self.token.span);\n+            let full_sp = self.prev_span.to(self.token.span);\n+            let ident_sp = self.token.span;\n+            if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n+                // possible public struct definition where `struct` was forgotten\n+                let ident = self.parse_ident().unwrap();\n+                let msg = format!(\"add `struct` here to parse `{}` as a public struct\",\n+                                  ident);\n+                let mut err = self.diagnostic()\n+                    .struct_span_err(sp, \"missing `struct` for struct definition\");\n+                err.span_suggestion_short(\n+                    sp, &msg, \" struct \".into(), Applicability::MaybeIncorrect // speculative\n+                );\n+                return Err(err);\n+            } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n+                let ident = self.parse_ident().unwrap();\n+                self.bump();  // `(`\n+                let kw_name = if let Ok(Some(_)) = self.parse_self_arg_with_attrs()\n+                    .map_err(|mut e| e.cancel())\n+                {\n+                    \"method\"\n+                } else {\n+                    \"function\"\n+                };\n+                self.consume_block(token::Paren);\n+                let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n+                    self.eat_to_tokens(&[&token::OpenDelim(token::Brace)]);\n+                    self.bump();  // `{`\n+                    (\"fn\", kw_name, false)\n+                } else if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.bump();  // `{`\n+                    (\"fn\", kw_name, false)\n+                } else if self.check(&token::Colon) {\n+                    let kw = \"struct\";\n+                    (kw, kw, false)\n+                } else {\n+                    (\"fn` or `struct\", \"function or struct\", true)\n+                };\n+\n+                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n+                if !ambiguous {\n+                    self.consume_block(token::Brace);\n+                    let suggestion = format!(\"add `{}` here to parse `{}` as a public {}\",\n+                                             kw,\n+                                             ident,\n+                                             kw_name);\n+                    err.span_suggestion_short(\n+                        sp, &suggestion, format!(\" {} \", kw), Applicability::MachineApplicable\n+                    );\n+                } else {\n+                    if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n+                        err.span_suggestion(\n+                            full_sp,\n+                            \"if you meant to call a macro, try\",\n+                            format!(\"{}!\", snippet),\n+                            // this is the `ambiguous` conditional branch\n+                            Applicability::MaybeIncorrect\n+                        );\n+                    } else {\n+                        err.help(\"if you meant to call a macro, remove the `pub` \\\n+                                  and add a trailing `!` after the identifier\");\n+                    }\n+                }\n+                return Err(err);\n+            } else if self.look_ahead(1, |t| *t == token::Lt) {\n+                let ident = self.parse_ident().unwrap();\n+                self.eat_to_tokens(&[&token::Gt]);\n+                self.bump();  // `>`\n+                let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n+                    if let Ok(Some(_)) = self.parse_self_arg_with_attrs()\n+                        .map_err(|mut e| e.cancel())\n+                    {\n+                        (\"fn\", \"method\", false)\n+                    } else {\n+                        (\"fn\", \"function\", false)\n+                    }\n+                } else if self.check(&token::OpenDelim(token::Brace)) {\n+                    (\"struct\", \"struct\", false)\n+                } else {\n+                    (\"fn` or `struct\", \"function or struct\", true)\n+                };\n+                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n+                if !ambiguous {\n+                    err.span_suggestion_short(\n+                        sp,\n+                        &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n+                        format!(\" {} \", kw),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                return Err(err);\n+            }\n+        }\n+        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, visibility)\n+    }\n+\n+    /// This is the fall-through for parsing items.\n+    fn parse_macro_use_or_failure(\n+        &mut self,\n+        attrs: Vec<Attribute> ,\n+        macros_allowed: bool,\n+        attributes_allowed: bool,\n+        lo: Span,\n+        visibility: Visibility\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        if macros_allowed && self.token.is_path_start() &&\n+                !(self.is_async_fn() && self.token.span.rust_2015()) {\n+            // MACRO INVOCATION ITEM\n+\n+            let prev_span = self.prev_span;\n+            self.complain_if_pub_macro(&visibility.node, prev_span);\n+\n+            let mac_lo = self.token.span;\n+\n+            // item macro.\n+            let path = self.parse_path(PathStyle::Mod)?;\n+            self.expect(&token::Not)?;\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n+            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+                self.report_invalid_macro_expansion_item();\n+            }\n+\n+            let hi = self.prev_span;\n+            let mac = respan(mac_lo.to(hi), Mac_ {\n+                path,\n+                tts,\n+                delim,\n+                prior_type_ascription: self.last_type_ascription,\n+            });\n+            let item =\n+                self.mk_item(lo.to(hi), Ident::invalid(), ItemKind::Mac(mac), visibility, attrs);\n+            return Ok(Some(item));\n+        }\n+\n+        // FAILURE TO PARSE ITEM\n+        match visibility.node {\n+            VisibilityKind::Inherited => {}\n+            _ => {\n+                return Err(self.span_fatal(self.prev_span, \"unmatched visibility `pub`\"));\n+            }\n+        }\n+\n+        if !attributes_allowed && !attrs.is_empty() {\n+            self.expected_item_err(&attrs)?;\n+        }\n+        Ok(None)\n+    }\n+\n+    /// Emits an expected-item-after-attributes error.\n+    fn expected_item_err(&mut self, attrs: &[Attribute]) -> PResult<'a,  ()> {\n+        let message = match attrs.last() {\n+            Some(&Attribute { is_sugared_doc: true, .. }) => \"expected item after doc comment\",\n+            _ => \"expected item after attributes\",\n+        };\n+\n+        let mut err = self.diagnostic().struct_span_err(self.prev_span, message);\n+        if attrs.last().unwrap().is_sugared_doc {\n+            err.span_label(self.prev_span, \"this doc comment doesn't document anything\");\n+        }\n+        Err(err)\n+    }\n+\n+    /// Parses a macro invocation inside a `trait`, `impl` or `extern` block.\n+    fn parse_assoc_macro_invoc(&mut self, item_kind: &str, vis: Option<&Visibility>,\n+                               at_end: &mut bool) -> PResult<'a, Option<Mac>>\n+    {\n+        if self.token.is_path_start() &&\n+                !(self.is_async_fn() && self.token.span.rust_2015()) {\n+            let prev_span = self.prev_span;\n+            let lo = self.token.span;\n+            let path = self.parse_path(PathStyle::Mod)?;\n+\n+            if path.segments.len() == 1 {\n+                if !self.eat(&token::Not) {\n+                    return Err(self.missing_assoc_item_kind_err(item_kind, prev_span));\n+                }\n+            } else {\n+                self.expect(&token::Not)?;\n+            }\n+\n+            if let Some(vis) = vis {\n+                self.complain_if_pub_macro(&vis.node, prev_span);\n+            }\n+\n+            *at_end = true;\n+\n+            // eat a matched-delimiter token tree:\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n+            if delim != MacDelimiter::Brace {\n+                self.expect(&token::Semi)?;\n+            }\n+\n+            Ok(Some(respan(lo.to(self.prev_span), Mac_ {\n+                path,\n+                tts,\n+                delim,\n+                prior_type_ascription: self.last_type_ascription,\n+            })))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    fn missing_assoc_item_kind_err(&self, item_type: &str, prev_span: Span)\n+                                   -> DiagnosticBuilder<'a>\n+    {\n+        let expected_kinds = if item_type == \"extern\" {\n+            \"missing `fn`, `type`, or `static`\"\n+        } else {\n+            \"missing `fn`, `type`, or `const`\"\n+        };\n+\n+        // Given this code `path(`, it seems like this is not\n+        // setting the visibility of a macro invocation, but rather\n+        // a mistyped method declaration.\n+        // Create a diagnostic pointing out that `fn` is missing.\n+        //\n+        // x |     pub path(&self) {\n+        //   |        ^ missing `fn`, `type`, or `const`\n+        //     pub  path(\n+        //        ^^ `sp` below will point to this\n+        let sp = prev_span.between(self.prev_span);\n+        let mut err = self.diagnostic().struct_span_err(\n+            sp,\n+            &format!(\"{} for {}-item declaration\",\n+                     expected_kinds, item_type));\n+        err.span_label(sp, expected_kinds);\n+        err\n+    }\n+\n+    /// Parses an implementation item, `impl` keyword is already parsed.\n+    ///\n+    ///    impl<'a, T> TYPE { /* impl items */ }\n+    ///    impl<'a, T> TRAIT for TYPE { /* impl items */ }\n+    ///    impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n+    ///\n+    /// We actually parse slightly more relaxed grammar for better error reporting and recovery.\n+    ///     `impl` GENERICS `!`? TYPE `for`? (TYPE | `..`) (`where` PREDICATES)? `{` BODY `}`\n+    ///     `impl` GENERICS `!`? TYPE (`where` PREDICATES)? `{` BODY `}`\n+    fn parse_item_impl(&mut self, unsafety: Unsafety, defaultness: Defaultness)\n+                       -> PResult<'a, ItemInfo> {\n+        // First, parse generic parameters if necessary.\n+        let mut generics = if self.choose_generics_over_qpath() {\n+            self.parse_generics()?\n+        } else {\n+            ast::Generics::default()\n+        };\n+\n+        // Disambiguate `impl !Trait for Type { ... }` and `impl ! { ... }` for the never type.\n+        let polarity = if self.check(&token::Not) && self.look_ahead(1, |t| t.can_begin_type()) {\n+            self.bump(); // `!`\n+            ast::ImplPolarity::Negative\n+        } else {\n+            ast::ImplPolarity::Positive\n+        };\n+\n+        // Parse both types and traits as a type, then reinterpret if necessary.\n+        let err_path = |span| ast::Path::from_ident(Ident::new(kw::Invalid, span));\n+        let ty_first = if self.token.is_keyword(kw::For) &&\n+                          self.look_ahead(1, |t| t != &token::Lt) {\n+            let span = self.prev_span.between(self.token.span);\n+            self.struct_span_err(span, \"missing trait in a trait impl\").emit();\n+            P(Ty { node: TyKind::Path(None, err_path(span)), span, id: ast::DUMMY_NODE_ID })\n+        } else {\n+            self.parse_ty()?\n+        };\n+\n+        // If `for` is missing we try to recover.\n+        let has_for = self.eat_keyword(kw::For);\n+        let missing_for_span = self.prev_span.between(self.token.span);\n+\n+        let ty_second = if self.token == token::DotDot {\n+            // We need to report this error after `cfg` expansion for compatibility reasons\n+            self.bump(); // `..`, do not add it to expected tokens\n+            Some(DummyResult::raw_ty(self.prev_span, true))\n+        } else if has_for || self.token.can_begin_type() {\n+            Some(self.parse_ty()?)\n+        } else {\n+            None\n+        };\n+\n+        generics.where_clause = self.parse_where_clause()?;\n+\n+        let (impl_items, attrs) = self.parse_impl_body()?;\n+\n+        let item_kind = match ty_second {\n+            Some(ty_second) => {\n+                // impl Trait for Type\n+                if !has_for {\n+                    self.struct_span_err(missing_for_span, \"missing `for` in a trait impl\")\n+                        .span_suggestion_short(\n+                            missing_for_span,\n+                            \"add `for` here\",\n+                            \" for \".to_string(),\n+                            Applicability::MachineApplicable,\n+                        ).emit();\n+                }\n+\n+                let ty_first = ty_first.into_inner();\n+                let path = match ty_first.node {\n+                    // This notably includes paths passed through `ty` macro fragments (#46438).\n+                    TyKind::Path(None, path) => path,\n+                    _ => {\n+                        self.span_err(ty_first.span, \"expected a trait, found type\");\n+                        err_path(ty_first.span)\n+                    }\n+                };\n+                let trait_ref = TraitRef { path, ref_id: ty_first.id };\n+\n+                ItemKind::Impl(unsafety, polarity, defaultness,\n+                               generics, Some(trait_ref), ty_second, impl_items)\n+            }\n+            None => {\n+                // impl Type\n+                ItemKind::Impl(unsafety, polarity, defaultness,\n+                               generics, None, ty_first, impl_items)\n+            }\n+        };\n+\n+        Ok((Ident::invalid(), item_kind, Some(attrs)))\n+    }\n+\n+    fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+        let attrs = self.parse_inner_attributes()?;\n+\n+        let mut impl_items = Vec::new();\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n+            let mut at_end = false;\n+            match self.parse_impl_item(&mut at_end) {\n+                Ok(impl_item) => impl_items.push(impl_item),\n+                Err(mut err) => {\n+                    err.emit();\n+                    if !at_end {\n+                        self.recover_stmt_(SemiColonMode::Break, BlockMode::Break);\n+                    }\n+                }\n+            }\n+        }\n+        Ok((impl_items, attrs))\n+    }\n+\n+    /// Parses an impl item.\n+    pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> {\n+        maybe_whole!(self, NtImplItem, |x| x);\n+        let attrs = self.parse_outer_attributes()?;\n+        let mut unclosed_delims = vec![];\n+        let (mut item, tokens) = self.collect_tokens(|this| {\n+            let item = this.parse_impl_item_(at_end, attrs);\n+            unclosed_delims.append(&mut this.unclosed_delims);\n+            item\n+        })?;\n+        self.unclosed_delims.append(&mut unclosed_delims);\n+\n+        // See `parse_item` for why this clause is here.\n+        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+            item.tokens = Some(tokens);\n+        }\n+        Ok(item)\n+    }\n+\n+    fn parse_impl_item_(&mut self,\n+                        at_end: &mut bool,\n+                        mut attrs: Vec<Attribute>) -> PResult<'a, ImplItem> {\n+        let lo = self.token.span;\n+        let vis = self.parse_visibility(false)?;\n+        let defaultness = self.parse_defaultness();\n+        let (name, node, generics) = if let Some(type_) = self.eat_type() {\n+            let (name, alias, generics) = type_?;\n+            let kind = match alias {\n+                AliasKind::Weak(typ) => ast::ImplItemKind::TyAlias(typ),\n+                AliasKind::OpaqueTy(bounds) => ast::ImplItemKind::OpaqueTy(bounds),\n+            };\n+            (name, kind, generics)\n+        } else if self.is_const_item() {\n+            // This parses the grammar:\n+            //     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n+            self.expect_keyword(kw::Const)?;\n+            let name = self.parse_ident()?;\n+            self.expect(&token::Colon)?;\n+            let typ = self.parse_ty()?;\n+            self.expect(&token::Eq)?;\n+            let expr = self.parse_expr()?;\n+            self.expect(&token::Semi)?;\n+            (name, ast::ImplItemKind::Const(typ, expr), ast::Generics::default())\n+        } else {\n+            let (name, inner_attrs, generics, node) = self.parse_impl_method(&vis, at_end)?;\n+            attrs.extend(inner_attrs);\n+            (name, node, generics)\n+        };\n+\n+        Ok(ImplItem {\n+            id: ast::DUMMY_NODE_ID,\n+            span: lo.to(self.prev_span),\n+            ident: name,\n+            vis,\n+            defaultness,\n+            attrs,\n+            generics,\n+            node,\n+            tokens: None,\n+        })\n+    }\n+\n+    /// Parses defaultness (i.e., `default` or nothing).\n+    fn parse_defaultness(&mut self) -> Defaultness {\n+        // `pub` is included for better error messages\n+        if self.check_keyword(kw::Default) &&\n+            self.is_keyword_ahead(1, &[\n+                kw::Impl,\n+                kw::Const,\n+                kw::Fn,\n+                kw::Unsafe,\n+                kw::Extern,\n+                kw::Type,\n+                kw::Pub,\n+            ])\n+        {\n+            self.bump(); // `default`\n+            Defaultness::Default\n+        } else {\n+            Defaultness::Final\n+        }\n+    }\n+\n+    /// Returns `true` if we are looking at `const ID`\n+    /// (returns `false` for things like `const fn`, etc.).\n+    fn is_const_item(&self) -> bool {\n+        self.token.is_keyword(kw::Const) &&\n+            !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n+    }\n+\n+    /// Parse a method or a macro invocation in a trait impl.\n+    fn parse_impl_method(&mut self, vis: &Visibility, at_end: &mut bool)\n+                         -> PResult<'a, (Ident, Vec<Attribute>, ast::Generics,\n+                             ast::ImplItemKind)> {\n+        // code copied from parse_macro_use_or_failure... abstraction!\n+        if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n+            // method macro\n+            Ok((Ident::invalid(), vec![], ast::Generics::default(),\n+                ast::ImplItemKind::Macro(mac)))\n+        } else {\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n+            let ident = self.parse_ident()?;\n+            let mut generics = self.parse_generics()?;\n+            let decl = self.parse_fn_decl_with_self(|p| {\n+                p.parse_arg_general(true, false, |_| true)\n+            })?;\n+            generics.where_clause = self.parse_where_clause()?;\n+            *at_end = true;\n+            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+            let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n+            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(\n+                ast::MethodSig { header, decl },\n+                body\n+            )))\n+        }\n+    }\n+\n+    /// Parses all the \"front matter\" for a `fn` declaration, up to\n+    /// and including the `fn` keyword:\n+    ///\n+    /// - `const fn`\n+    /// - `unsafe fn`\n+    /// - `const unsafe fn`\n+    /// - `extern fn`\n+    /// - etc.\n+    fn parse_fn_front_matter(&mut self)\n+        -> PResult<'a, (\n+            Spanned<Constness>,\n+            Unsafety,\n+            Spanned<IsAsync>,\n+            Abi\n+        )>\n+    {\n+        let is_const_fn = self.eat_keyword(kw::Const);\n+        let const_span = self.prev_span;\n+        let asyncness = self.parse_asyncness();\n+        if let IsAsync::Async { .. } = asyncness {\n+            self.ban_async_in_2015(self.prev_span);\n+        }\n+        let asyncness = respan(self.prev_span, asyncness);\n+        let unsafety = self.parse_unsafety();\n+        let (constness, unsafety, abi) = if is_const_fn {\n+            (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n+        } else {\n+            let abi = if self.eat_keyword(kw::Extern) {\n+                self.parse_opt_abi()?.unwrap_or(Abi::C)\n+            } else {\n+                Abi::Rust\n+            };\n+            (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n+        };\n+        if !self.eat_keyword(kw::Fn) {\n+            // It is possible for `expect_one_of` to recover given the contents of\n+            // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n+            // account for this.\n+            if !self.expect_one_of(&[], &[])? { unreachable!() }\n+        }\n+        Ok((constness, unsafety, asyncness, abi))\n+    }\n+\n+    /// Parses `trait Foo { ... }` or `trait Foo = Bar;`.\n+    fn parse_item_trait(&mut self, is_auto: IsAuto, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n+        let ident = self.parse_ident()?;\n+        let mut tps = self.parse_generics()?;\n+\n+        // Parse optional colon and supertrait bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_generic_bounds(Some(self.prev_span))?\n+        } else {\n+            Vec::new()\n+        };\n+\n+        if self.eat(&token::Eq) {\n+            // it's a trait alias\n+            let bounds = self.parse_generic_bounds(None)?;\n+            tps.where_clause = self.parse_where_clause()?;\n+            self.expect(&token::Semi)?;\n+            if is_auto == IsAuto::Yes {\n+                let msg = \"trait aliases cannot be `auto`\";\n+                self.struct_span_err(self.prev_span, msg)\n+                    .span_label(self.prev_span, msg)\n+                    .emit();\n+            }\n+            if unsafety != Unsafety::Normal {\n+                let msg = \"trait aliases cannot be `unsafe`\";\n+                self.struct_span_err(self.prev_span, msg)\n+                    .span_label(self.prev_span, msg)\n+                    .emit();\n+            }\n+            Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n+        } else {\n+            // it's a normal trait\n+            tps.where_clause = self.parse_where_clause()?;\n+            self.expect(&token::OpenDelim(token::Brace))?;\n+            let mut trait_items = vec![];\n+            while !self.eat(&token::CloseDelim(token::Brace)) {\n+                if let token::DocComment(_) = self.token.kind {\n+                    if self.look_ahead(1,\n+                    |tok| tok == &token::CloseDelim(token::Brace)) {\n+                        self.diagnostic().struct_span_err_with_code(\n+                            self.token.span,\n+                            \"found a documentation comment that doesn't document anything\",\n+                            DiagnosticId::Error(\"E0584\".into()),\n+                        )\n+                        .help(\n+                            \"doc comments must come before what they document, maybe a \\\n+                            comment was intended with `//`?\",\n+                        )\n+                        .emit();\n+                        self.bump();\n+                        continue;\n+                    }\n+                }\n+                let mut at_end = false;\n+                match self.parse_trait_item(&mut at_end) {\n+                    Ok(item) => trait_items.push(item),\n+                    Err(mut e) => {\n+                        e.emit();\n+                        if !at_end {\n+                            self.recover_stmt_(SemiColonMode::Break, BlockMode::Break);\n+                        }\n+                    }\n+                }\n+            }\n+            Ok((ident, ItemKind::Trait(is_auto, unsafety, tps, bounds, trait_items), None))\n+        }\n+    }\n+\n+    /// Parses the items in a trait declaration.\n+    pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> {\n+        maybe_whole!(self, NtTraitItem, |x| x);\n+        let attrs = self.parse_outer_attributes()?;\n+        let mut unclosed_delims = vec![];\n+        let (mut item, tokens) = self.collect_tokens(|this| {\n+            let item = this.parse_trait_item_(at_end, attrs);\n+            unclosed_delims.append(&mut this.unclosed_delims);\n+            item\n+        })?;\n+        self.unclosed_delims.append(&mut unclosed_delims);\n+        // See `parse_item` for why this clause is here.\n+        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+            item.tokens = Some(tokens);\n+        }\n+        Ok(item)\n+    }\n+\n+    fn parse_trait_item_(&mut self,\n+                         at_end: &mut bool,\n+                         mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n+        let lo = self.token.span;\n+        self.eat_bad_pub();\n+        let (name, node, generics) = if self.eat_keyword(kw::Type) {\n+            self.parse_trait_item_assoc_ty()?\n+        } else if self.is_const_item() {\n+            self.expect_keyword(kw::Const)?;\n+            let ident = self.parse_ident()?;\n+            self.expect(&token::Colon)?;\n+            let ty = self.parse_ty()?;\n+            let default = if self.eat(&token::Eq) {\n+                let expr = self.parse_expr()?;\n+                self.expect(&token::Semi)?;\n+                Some(expr)\n+            } else {\n+                self.expect(&token::Semi)?;\n+                None\n+            };\n+            (ident, TraitItemKind::Const(ty, default), ast::Generics::default())\n+        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"trait\", None, &mut false)? {\n+            // trait item macro.\n+            (Ident::invalid(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n+        } else {\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n+\n+            let ident = self.parse_ident()?;\n+            let mut generics = self.parse_generics()?;\n+\n+            let decl = self.parse_fn_decl_with_self(|p: &mut Parser<'a>| {\n+                // This is somewhat dubious; We don't want to allow\n+                // argument names to be left off if there is a\n+                // definition...\n+\n+                // We don't allow argument names to be left off in edition 2018.\n+                let is_name_required = p.token.span.rust_2018();\n+                p.parse_arg_general(true, false, |_| is_name_required)\n+            })?;\n+            generics.where_clause = self.parse_where_clause()?;\n+\n+            let sig = ast::MethodSig {\n+                header: FnHeader {\n+                    unsafety,\n+                    constness,\n+                    abi,\n+                    asyncness,\n+                },\n+                decl,\n+            };\n+\n+            let body = match self.token.kind {\n+                token::Semi => {\n+                    self.bump();\n+                    *at_end = true;\n+                    debug!(\"parse_trait_methods(): parsing required method\");\n+                    None\n+                }\n+                token::OpenDelim(token::Brace) => {\n+                    debug!(\"parse_trait_methods(): parsing provided method\");\n+                    *at_end = true;\n+                    let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                    attrs.extend(inner_attrs.iter().cloned());\n+                    Some(body)\n+                }\n+                token::Interpolated(ref nt) => {\n+                    match **nt {\n+                        token::NtBlock(..) => {\n+                            *at_end = true;\n+                            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                            attrs.extend(inner_attrs.iter().cloned());\n+                            Some(body)\n+                        }\n+                        _ => {\n+                            return self.expected_semi_or_open_brace();\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    return self.expected_semi_or_open_brace();\n+                }\n+            };\n+            (ident, ast::TraitItemKind::Method(sig, body), generics)\n+        };\n+\n+        Ok(TraitItem {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: name,\n+            attrs,\n+            generics,\n+            node,\n+            span: lo.to(self.prev_span),\n+            tokens: None,\n+        })\n+    }\n+\n+    /// Parses the following grammar:\n+    ///\n+    ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n+    fn parse_trait_item_assoc_ty(&mut self)\n+        -> PResult<'a, (Ident, TraitItemKind, ast::Generics)> {\n+        let ident = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+\n+        // Parse optional colon and param bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_generic_bounds(None)?\n+        } else {\n+            Vec::new()\n+        };\n+        generics.where_clause = self.parse_where_clause()?;\n+\n+        let default = if self.eat(&token::Eq) {\n+            Some(self.parse_ty()?)\n+        } else {\n+            None\n+        };\n+        self.expect(&token::Semi)?;\n+\n+        Ok((ident, TraitItemKind::Type(bounds, default), generics))\n+    }\n+\n+    /// Parses a `UseTree`.\n+    ///\n+    /// ```\n+    /// USE_TREE = [`::`] `*` |\n+    ///            [`::`] `{` USE_TREE_LIST `}` |\n+    ///            PATH `::` `*` |\n+    ///            PATH `::` `{` USE_TREE_LIST `}` |\n+    ///            PATH [`as` IDENT]\n+    /// ```\n+    fn parse_use_tree(&mut self) -> PResult<'a, UseTree> {\n+        let lo = self.token.span;\n+\n+        let mut prefix = ast::Path { segments: Vec::new(), span: lo.shrink_to_lo() };\n+        let kind = if self.check(&token::OpenDelim(token::Brace)) ||\n+                      self.check(&token::BinOp(token::Star)) ||\n+                      self.is_import_coupler() {\n+            // `use *;` or `use ::*;` or `use {...};` or `use ::{...};`\n+            let mod_sep_ctxt = self.token.span.ctxt();\n+            if self.eat(&token::ModSep) {\n+                prefix.segments.push(\n+                    PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt))\n+                );\n+            }\n+\n+            if self.eat(&token::BinOp(token::Star)) {\n+                UseTreeKind::Glob\n+            } else {\n+                UseTreeKind::Nested(self.parse_use_tree_list()?)\n+            }\n+        } else {\n+            // `use path::*;` or `use path::{...};` or `use path;` or `use path as bar;`\n+            prefix = self.parse_path(PathStyle::Mod)?;\n+\n+            if self.eat(&token::ModSep) {\n+                if self.eat(&token::BinOp(token::Star)) {\n+                    UseTreeKind::Glob\n+                } else {\n+                    UseTreeKind::Nested(self.parse_use_tree_list()?)\n+                }\n+            } else {\n+                UseTreeKind::Simple(self.parse_rename()?, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID)\n+            }\n+        };\n+\n+        Ok(UseTree { prefix, kind, span: lo.to(self.prev_span) })\n+    }\n+\n+    /// Parses a `UseTreeKind::Nested(list)`.\n+    ///\n+    /// ```\n+    /// USE_TREE_LIST = \u00d8 | (USE_TREE `,`)* USE_TREE [`,`]\n+    /// ```\n+    fn parse_use_tree_list(&mut self) -> PResult<'a, Vec<(UseTree, ast::NodeId)>> {\n+        self.parse_delim_comma_seq(token::Brace, |p| Ok((p.parse_use_tree()?, ast::DUMMY_NODE_ID)))\n+            .map(|(r, _)| r)\n+    }\n+\n+    fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {\n+        if self.eat_keyword(kw::As) {\n+            self.parse_ident_or_underscore().map(Some)\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    /// Parses `extern crate` links.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// extern crate foo;\n+    /// extern crate bar as foo;\n+    /// ```\n+    fn parse_item_extern_crate(\n+        &mut self,\n+        lo: Span,\n+        visibility: Visibility,\n+        attrs: Vec<Attribute>\n+    ) -> PResult<'a, P<Item>> {\n+        // Accept `extern crate name-like-this` for better diagnostics\n+        let orig_name = self.parse_crate_name_with_dashes()?;\n+        let (item_name, orig_name) = if let Some(rename) = self.parse_rename()? {\n+            (rename, Some(orig_name.name))\n+        } else {\n+            (orig_name, None)\n+        };\n+        self.expect(&token::Semi)?;\n+\n+        let span = lo.to(self.prev_span);\n+        Ok(self.mk_item(span, item_name, ItemKind::ExternCrate(orig_name), visibility, attrs))\n+    }\n+\n+    fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, ast::Ident> {\n+        let error_msg = \"crate name using dashes are not valid in `extern crate` statements\";\n+        let suggestion_msg = \"if the original crate name uses dashes you need to use underscores \\\n+                              in the code\";\n+        let mut ident = if self.token.is_keyword(kw::SelfLower) {\n+            self.parse_path_segment_ident()\n+        } else {\n+            self.parse_ident()\n+        }?;\n+        let mut idents = vec![];\n+        let mut replacement = vec![];\n+        let mut fixed_crate_name = false;\n+        // Accept `extern crate name-like-this` for better diagnostics\n+        let dash = token::BinOp(token::BinOpToken::Minus);\n+        if self.token == dash {  // Do not include `-` as part of the expected tokens list\n+            while self.eat(&dash) {\n+                fixed_crate_name = true;\n+                replacement.push((self.prev_span, \"_\".to_string()));\n+                idents.push(self.parse_ident()?);\n+            }\n+        }\n+        if fixed_crate_name {\n+            let fixed_name_sp = ident.span.to(idents.last().unwrap().span);\n+            let mut fixed_name = format!(\"{}\", ident.name);\n+            for part in idents {\n+                fixed_name.push_str(&format!(\"_{}\", part.name));\n+            }\n+            ident = Ident::from_str(&fixed_name).with_span_pos(fixed_name_sp);\n+\n+            self.struct_span_err(fixed_name_sp, error_msg)\n+                .span_label(fixed_name_sp, \"dash-separated idents are not valid\")\n+                .multipart_suggestion(suggestion_msg, replacement, Applicability::MachineApplicable)\n+                .emit();\n+        }\n+        Ok(ident)\n+    }\n+\n+    /// Parses an item-position function declaration.\n+    fn parse_item_fn(\n+        &mut self,\n+        unsafety: Unsafety,\n+        asyncness: Spanned<IsAsync>,\n+        constness: Spanned<Constness>,\n+        abi: Abi\n+    ) -> PResult<'a, ItemInfo> {\n+        let (ident, mut generics) = self.parse_fn_header()?;\n+        let allow_c_variadic = abi == Abi::C && unsafety == Unsafety::Unsafe;\n+        let decl = self.parse_fn_decl(allow_c_variadic)?;\n+        generics.where_clause = self.parse_where_clause()?;\n+        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        let header = FnHeader { unsafety, asyncness, constness, abi };\n+        Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n+    }\n+\n+    /// Parses the name and optional generic types of a function header.\n+    fn parse_fn_header(&mut self) -> PResult<'a, (Ident, ast::Generics)> {\n+        let id = self.parse_ident()?;\n+        let generics = self.parse_generics()?;\n+        Ok((id, generics))\n+    }\n+\n+    /// Parses the argument list and result type of a function declaration.\n+    fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n+        let (args, c_variadic) = self.parse_fn_args(true, allow_c_variadic)?;\n+        let ret_ty = self.parse_ret_ty(true)?;\n+\n+        Ok(P(FnDecl {\n+            inputs: args,\n+            output: ret_ty,\n+            c_variadic,\n+        }))\n+    }\n+\n+    /// Parses `extern` for foreign ABIs modules.\n+    ///\n+    /// `extern` is expected to have been\n+    /// consumed before calling this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore (only-for-syntax-highlight)\n+    /// extern \"C\" {}\n+    /// extern {}\n+    /// ```\n+    fn parse_item_foreign_mod(\n+        &mut self,\n+        lo: Span,\n+        opt_abi: Option<Abi>,\n+        visibility: Visibility,\n+        mut attrs: Vec<Attribute>,\n+        extern_sp: Span,\n+    ) -> PResult<'a, P<Item>> {\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+\n+        let abi = opt_abi.unwrap_or(Abi::C);\n+\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        let mut foreign_items = vec![];\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n+            foreign_items.push(self.parse_foreign_item(extern_sp)?);\n+        }\n+\n+        let prev_span = self.prev_span;\n+        let m = ast::ForeignMod {\n+            abi,\n+            items: foreign_items\n+        };\n+        let invalid = Ident::invalid();\n+        Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n+    }\n+\n+    /// Parses a foreign item.\n+    crate fn parse_foreign_item(&mut self, extern_sp: Span) -> PResult<'a, ForeignItem> {\n+        maybe_whole!(self, NtForeignItem, |ni| ni);\n+\n+        let attrs = self.parse_outer_attributes()?;\n+        let lo = self.token.span;\n+        let visibility = self.parse_visibility(false)?;\n+\n+        // FOREIGN STATIC ITEM\n+        // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n+        if self.check_keyword(kw::Static) || self.token.is_keyword(kw::Const) {\n+            if self.token.is_keyword(kw::Const) {\n+                self.diagnostic()\n+                    .struct_span_err(self.token.span, \"extern items cannot be `const`\")\n+                    .span_suggestion(\n+                        self.token.span,\n+                        \"try using a static value\",\n+                        \"static\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    ).emit();\n+            }\n+            self.bump(); // `static` or `const`\n+            return Ok(self.parse_item_foreign_static(visibility, lo, attrs)?);\n+        }\n+        // FOREIGN FUNCTION ITEM\n+        if self.check_keyword(kw::Fn) {\n+            return Ok(self.parse_item_foreign_fn(visibility, lo, attrs, extern_sp)?);\n+        }\n+        // FOREIGN TYPE ITEM\n+        if self.check_keyword(kw::Type) {\n+            return Ok(self.parse_item_foreign_type(visibility, lo, attrs)?);\n+        }\n+\n+        match self.parse_assoc_macro_invoc(\"extern\", Some(&visibility), &mut false)? {\n+            Some(mac) => {\n+                Ok(\n+                    ForeignItem {\n+                        ident: Ident::invalid(),\n+                        span: lo.to(self.prev_span),\n+                        id: ast::DUMMY_NODE_ID,\n+                        attrs,\n+                        vis: visibility,\n+                        node: ForeignItemKind::Macro(mac),\n+                    }\n+                )\n+            }\n+            None => {\n+                if !attrs.is_empty()  {\n+                    self.expected_item_err(&attrs)?;\n+                }\n+\n+                self.unexpected()\n+            }\n+        }\n+    }\n+\n+    /// Parses a function declaration from a foreign module.\n+    fn parse_item_foreign_fn(\n+        &mut self,\n+        vis: ast::Visibility,\n+        lo: Span,\n+        attrs: Vec<Attribute>,\n+        extern_sp: Span,\n+    ) -> PResult<'a, ForeignItem> {\n+        self.expect_keyword(kw::Fn)?;\n+\n+        let (ident, mut generics) = self.parse_fn_header()?;\n+        let decl = self.parse_fn_decl(true)?;\n+        generics.where_clause = self.parse_where_clause()?;\n+        let hi = self.token.span;\n+        self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n+        Ok(ast::ForeignItem {\n+            ident,\n+            attrs,\n+            node: ForeignItemKind::Fn(decl, generics),\n+            id: ast::DUMMY_NODE_ID,\n+            span: lo.to(hi),\n+            vis,\n+        })\n+    }\n+\n+    /// Parses a static item from a foreign module.\n+    /// Assumes that the `static` keyword is already parsed.\n+    fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n+                                 -> PResult<'a, ForeignItem> {\n+        let mutbl = self.parse_mutability();\n+        let ident = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+        let hi = self.token.span;\n+        self.expect(&token::Semi)?;\n+        Ok(ForeignItem {\n+            ident,\n+            attrs,\n+            node: ForeignItemKind::Static(ty, mutbl),\n+            id: ast::DUMMY_NODE_ID,\n+            span: lo.to(hi),\n+            vis,\n+        })\n+    }\n+\n+    /// Parses a type from a foreign module.\n+    fn parse_item_foreign_type(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n+                             -> PResult<'a, ForeignItem> {\n+        self.expect_keyword(kw::Type)?;\n+\n+        let ident = self.parse_ident()?;\n+        let hi = self.token.span;\n+        self.expect(&token::Semi)?;\n+        Ok(ast::ForeignItem {\n+            ident,\n+            attrs,\n+            node: ForeignItemKind::Ty,\n+            id: ast::DUMMY_NODE_ID,\n+            span: lo.to(hi),\n+            vis\n+        })\n+    }\n+\n+    fn is_static_global(&mut self) -> bool {\n+        if self.check_keyword(kw::Static) {\n+            // Check if this could be a closure\n+            !self.look_ahead(1, |token| {\n+                if token.is_keyword(kw::Move) {\n+                    return true;\n+                }\n+                match token.kind {\n+                    token::BinOp(token::Or) | token::OrOr => true,\n+                    _ => false,\n+                }\n+            })\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n+        let id = if m.is_none() { self.parse_ident_or_underscore() } else { self.parse_ident() }?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+        self.expect(&token::Eq)?;\n+        let e = self.parse_expr()?;\n+        self.expect(&token::Semi)?;\n+        let item = match m {\n+            Some(m) => ItemKind::Static(ty, m, e),\n+            None => ItemKind::Const(ty, e),\n+        };\n+        Ok((id, item, None))\n+    }\n+\n+    /// Parses `type Foo = Bar;` or returns `None`\n+    /// without modifying the parser state.\n+    fn eat_type(&mut self) -> Option<PResult<'a, (Ident, AliasKind, ast::Generics)>> {\n+        // This parses the grammar:\n+        //     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n+        if self.eat_keyword(kw::Type) {\n+            Some(self.parse_type_alias())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Parses a type alias or opaque type.\n+    fn parse_type_alias(&mut self) -> PResult<'a, (Ident, AliasKind, ast::Generics)> {\n+        let ident = self.parse_ident()?;\n+        let mut tps = self.parse_generics()?;\n+        tps.where_clause = self.parse_where_clause()?;\n+        self.expect(&token::Eq)?;\n+        let alias = if self.check_keyword(kw::Impl) {\n+            self.bump();\n+            let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n+            AliasKind::OpaqueTy(bounds)\n+        } else {\n+            let ty = self.parse_ty()?;\n+            AliasKind::Weak(ty)\n+        };\n+        self.expect(&token::Semi)?;\n+        Ok((ident, alias, tps))\n+    }\n+\n+    /// Parses an enum declaration.\n+    fn parse_item_enum(&mut self) -> PResult<'a, ItemInfo> {\n+        let id = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+        generics.where_clause = self.parse_where_clause()?;\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+\n+        let enum_definition = self.parse_enum_def(&generics).map_err(|e| {\n+            self.recover_stmt();\n+            self.eat(&token::CloseDelim(token::Brace));\n+            e\n+        })?;\n+        Ok((id, ItemKind::Enum(enum_definition, generics), None))\n+    }\n+\n+    /// Parses the part of an enum declaration following the `{`.\n+    fn parse_enum_def(&mut self, _generics: &ast::Generics) -> PResult<'a, EnumDef> {\n+        let mut variants = Vec::new();\n+        while self.token != token::CloseDelim(token::Brace) {\n+            let variant_attrs = self.parse_outer_attributes()?;\n+            let vlo = self.token.span;\n+\n+            self.eat_bad_pub();\n+            let ident = self.parse_ident()?;\n+\n+            let struct_def = if self.check(&token::OpenDelim(token::Brace)) {\n+                // Parse a struct variant.\n+                let (fields, recovered) = self.parse_record_struct_body()?;\n+                VariantData::Struct(fields, recovered)\n+            } else if self.check(&token::OpenDelim(token::Paren)) {\n+                VariantData::Tuple(\n+                    self.parse_tuple_struct_body()?,\n+                    ast::DUMMY_NODE_ID,\n+                )\n+            } else {\n+                VariantData::Unit(ast::DUMMY_NODE_ID)\n+            };\n+\n+            let disr_expr = if self.eat(&token::Eq) {\n+                Some(AnonConst {\n+                    id: ast::DUMMY_NODE_ID,\n+                    value: self.parse_expr()?,\n+                })\n+            } else {\n+                None\n+            };\n+\n+            let vr = ast::Variant_ {\n+                ident,\n+                id: ast::DUMMY_NODE_ID,\n+                attrs: variant_attrs,\n+                data: struct_def,\n+                disr_expr,\n+            };\n+            variants.push(respan(vlo.to(self.prev_span), vr));\n+\n+            if !self.eat(&token::Comma) {\n+                if self.token.is_ident() && !self.token.is_reserved_ident() {\n+                    let sp = self.sess.source_map().next_point(self.prev_span);\n+                    self.struct_span_err(sp, \"missing comma\")\n+                        .span_suggestion_short(\n+                            sp,\n+                            \"missing comma\",\n+                            \",\".to_owned(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        self.expect(&token::CloseDelim(token::Brace))?;\n+\n+        Ok(ast::EnumDef { variants })\n+    }\n+\n+    /// Parses `struct Foo { ... }`.\n+    fn parse_item_struct(&mut self) -> PResult<'a, ItemInfo> {\n+        let class_name = self.parse_ident()?;\n+\n+        let mut generics = self.parse_generics()?;\n+\n+        // There is a special case worth noting here, as reported in issue #17904.\n+        // If we are parsing a tuple struct it is the case that the where clause\n+        // should follow the field list. Like so:\n+        //\n+        // struct Foo<T>(T) where T: Copy;\n+        //\n+        // If we are parsing a normal record-style struct it is the case\n+        // that the where clause comes before the body, and after the generics.\n+        // So if we look ahead and see a brace or a where-clause we begin\n+        // parsing a record style struct.\n+        //\n+        // Otherwise if we look ahead and see a paren we parse a tuple-style\n+        // struct.\n+\n+        let vdata = if self.token.is_keyword(kw::Where) {\n+            generics.where_clause = self.parse_where_clause()?;\n+            if self.eat(&token::Semi) {\n+                // If we see a: `struct Foo<T> where T: Copy;` style decl.\n+                VariantData::Unit(ast::DUMMY_NODE_ID)\n+            } else {\n+                // If we see: `struct Foo<T> where T: Copy { ... }`\n+                let (fields, recovered) = self.parse_record_struct_body()?;\n+                VariantData::Struct(fields, recovered)\n+            }\n+        // No `where` so: `struct Foo<T>;`\n+        } else if self.eat(&token::Semi) {\n+            VariantData::Unit(ast::DUMMY_NODE_ID)\n+        // Record-style struct definition\n+        } else if self.token == token::OpenDelim(token::Brace) {\n+            let (fields, recovered) = self.parse_record_struct_body()?;\n+            VariantData::Struct(fields, recovered)\n+        // Tuple-style struct definition with optional where-clause.\n+        } else if self.token == token::OpenDelim(token::Paren) {\n+            let body = VariantData::Tuple(self.parse_tuple_struct_body()?, ast::DUMMY_NODE_ID);\n+            generics.where_clause = self.parse_where_clause()?;\n+            self.expect(&token::Semi)?;\n+            body\n+        } else {\n+            let token_str = self.this_token_descr();\n+            let mut err = self.fatal(&format!(\n+                \"expected `where`, `{{`, `(`, or `;` after struct name, found {}\",\n+                token_str\n+            ));\n+            err.span_label(self.token.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n+            return Err(err);\n+        };\n+\n+        Ok((class_name, ItemKind::Struct(vdata, generics), None))\n+    }\n+\n+    /// Parses `union Foo { ... }`.\n+    fn parse_item_union(&mut self) -> PResult<'a, ItemInfo> {\n+        let class_name = self.parse_ident()?;\n+\n+        let mut generics = self.parse_generics()?;\n+\n+        let vdata = if self.token.is_keyword(kw::Where) {\n+            generics.where_clause = self.parse_where_clause()?;\n+            let (fields, recovered) = self.parse_record_struct_body()?;\n+            VariantData::Struct(fields, recovered)\n+        } else if self.token == token::OpenDelim(token::Brace) {\n+            let (fields, recovered) = self.parse_record_struct_body()?;\n+            VariantData::Struct(fields, recovered)\n+        } else {\n+            let token_str = self.this_token_descr();\n+            let mut err = self.fatal(&format!(\n+                \"expected `where` or `{{` after union name, found {}\", token_str));\n+            err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n+            return Err(err);\n+        };\n+\n+        Ok((class_name, ItemKind::Union(vdata, generics), None))\n+    }\n+\n+    pub(super) fn is_union_item(&self) -> bool {\n+        self.token.is_keyword(kw::Union) &&\n+        self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n+    }\n+\n+    fn parse_record_struct_body(\n+        &mut self,\n+    ) -> PResult<'a, (Vec<StructField>, /* recovered */ bool)> {\n+        let mut fields = Vec::new();\n+        let mut recovered = false;\n+        if self.eat(&token::OpenDelim(token::Brace)) {\n+            while self.token != token::CloseDelim(token::Brace) {\n+                let field = self.parse_struct_decl_field().map_err(|e| {\n+                    self.recover_stmt();\n+                    recovered = true;\n+                    e\n+                });\n+                match field {\n+                    Ok(field) => fields.push(field),\n+                    Err(mut err) => {\n+                        err.emit();\n+                    }\n+                }\n+            }\n+            self.eat(&token::CloseDelim(token::Brace));\n+        } else {\n+            let token_str = self.this_token_descr();\n+            let mut err = self.fatal(&format!(\n+                    \"expected `where`, or `{{` after struct name, found {}\", token_str));\n+            err.span_label(self.token.span, \"expected `where`, or `{` after struct name\");\n+            return Err(err);\n+        }\n+\n+        Ok((fields, recovered))\n+    }\n+\n+    fn parse_tuple_struct_body(&mut self) -> PResult<'a, Vec<StructField>> {\n+        // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n+        // Unit like structs are handled in parse_item_struct function\n+        self.parse_paren_comma_seq(|p| {\n+            let attrs = p.parse_outer_attributes()?;\n+            let lo = p.token.span;\n+            let vis = p.parse_visibility(true)?;\n+            let ty = p.parse_ty()?;\n+            Ok(StructField {\n+                span: lo.to(ty.span),\n+                vis,\n+                ident: None,\n+                id: ast::DUMMY_NODE_ID,\n+                ty,\n+                attrs,\n+            })\n+        }).map(|(r, _)| r)\n+    }\n+\n+    /// Parses an element of a struct declaration.\n+    fn parse_struct_decl_field(&mut self) -> PResult<'a, StructField> {\n+        let attrs = self.parse_outer_attributes()?;\n+        let lo = self.token.span;\n+        let vis = self.parse_visibility(false)?;\n+        self.parse_single_struct_field(lo, vis, attrs)\n+    }\n+\n+    /// Parses a structure field declaration.\n+    fn parse_single_struct_field(&mut self,\n+                                     lo: Span,\n+                                     vis: Visibility,\n+                                     attrs: Vec<Attribute> )\n+                                     -> PResult<'a, StructField> {\n+        let mut seen_comma: bool = false;\n+        let a_var = self.parse_name_and_ty(lo, vis, attrs)?;\n+        if self.token == token::Comma {\n+            seen_comma = true;\n+        }\n+        match self.token.kind {\n+            token::Comma => {\n+                self.bump();\n+            }\n+            token::CloseDelim(token::Brace) => {}\n+            token::DocComment(_) => {\n+                let previous_span = self.prev_span;\n+                let mut err = self.span_fatal_err(self.token.span, Error::UselessDocComment);\n+                self.bump(); // consume the doc comment\n+                let comma_after_doc_seen = self.eat(&token::Comma);\n+                // `seen_comma` is always false, because we are inside doc block\n+                // condition is here to make code more readable\n+                if seen_comma == false && comma_after_doc_seen == true {\n+                    seen_comma = true;\n+                }\n+                if comma_after_doc_seen || self.token == token::CloseDelim(token::Brace) {\n+                    err.emit();\n+                } else {\n+                    if seen_comma == false {\n+                        let sp = self.sess.source_map().next_point(previous_span);\n+                        err.span_suggestion(\n+                            sp,\n+                            \"missing comma here\",\n+                            \",\".into(),\n+                            Applicability::MachineApplicable\n+                        );\n+                    }\n+                    return Err(err);\n+                }\n+            }\n+            _ => {\n+                let sp = self.sess.source_map().next_point(self.prev_span);\n+                let mut err = self.struct_span_err(sp, &format!(\"expected `,`, or `}}`, found {}\",\n+                                                                self.this_token_descr()));\n+                if self.token.is_ident() {\n+                    // This is likely another field; emit the diagnostic and keep going\n+                    err.span_suggestion(\n+                        sp,\n+                        \"try adding a comma\",\n+                        \",\".into(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    err.emit();\n+                } else {\n+                    return Err(err)\n+                }\n+            }\n+        }\n+        Ok(a_var)\n+    }\n+\n+    /// Parses a structure field.\n+    fn parse_name_and_ty(\n+        &mut self,\n+        lo: Span,\n+        vis: Visibility,\n+        attrs: Vec<Attribute>\n+    ) -> PResult<'a, StructField> {\n+        let name = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+        Ok(StructField {\n+            span: lo.to(self.prev_span),\n+            ident: Some(name),\n+            vis,\n+            id: ast::DUMMY_NODE_ID,\n+            ty,\n+            attrs,\n+        })\n+    }\n+\n+    pub(super) fn eat_macro_def(\n+        &mut self,\n+        attrs: &[Attribute],\n+        vis: &Visibility,\n+        lo: Span\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let token_lo = self.token.span;\n+        let (ident, def) = if self.eat_keyword(kw::Macro) {\n+            let ident = self.parse_ident()?;\n+            let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n+                match self.parse_token_tree() {\n+                    TokenTree::Delimited(_, _, tts) => tts,\n+                    _ => unreachable!(),\n+                }\n+            } else if self.check(&token::OpenDelim(token::Paren)) {\n+                let args = self.parse_token_tree();\n+                let body = if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.parse_token_tree()\n+                } else {\n+                    self.unexpected()?;\n+                    unreachable!()\n+                };\n+                TokenStream::new(vec![\n+                    args.into(),\n+                    TokenTree::token(token::FatArrow, token_lo.to(self.prev_span)).into(),\n+                    body.into(),\n+                ])\n+            } else {\n+                self.unexpected()?;\n+                unreachable!()\n+            };\n+\n+            (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n+        } else if self.check_keyword(sym::macro_rules) &&\n+                  self.look_ahead(1, |t| *t == token::Not) &&\n+                  self.look_ahead(2, |t| t.is_ident()) {\n+            let prev_span = self.prev_span;\n+            self.complain_if_pub_macro(&vis.node, prev_span);\n+            self.bump();\n+            self.bump();\n+\n+            let ident = self.parse_ident()?;\n+            let (delim, tokens) = self.expect_delimited_token_tree()?;\n+            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+                self.report_invalid_macro_expansion_item();\n+            }\n+\n+            (ident, ast::MacroDef { tokens, legacy: true })\n+        } else {\n+            return Ok(None);\n+        };\n+\n+        let span = lo.to(self.prev_span);\n+        Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n+    }\n+\n+    fn complain_if_pub_macro(&self, vis: &VisibilityKind, sp: Span) {\n+        match *vis {\n+            VisibilityKind::Inherited => {}\n+            _ => {\n+                let mut err = if self.token.is_keyword(sym::macro_rules) {\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n+                    err.span_suggestion(\n+                        sp,\n+                        \"try exporting the macro\",\n+                        \"#[macro_export]\".to_owned(),\n+                        Applicability::MaybeIncorrect // speculative\n+                    );\n+                    err\n+                } else {\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n+                    err.help(\"try adjusting the macro to put `pub` inside the invocation\");\n+                    err\n+                };\n+                err.emit();\n+            }\n+        }\n+    }\n+\n+    fn mk_item(&self, span: Span, ident: Ident, node: ItemKind, vis: Visibility,\n+               attrs: Vec<Attribute>) -> P<Item> {\n+        P(Item {\n+            ident,\n+            attrs,\n+            id: ast::DUMMY_NODE_ID,\n+            node,\n+            vis,\n+            span,\n+            tokens: None,\n+        })\n+    }\n+}"}, {"sha": "58a7ffba948b3a0f81377e5067f751824f2243e6", "filename": "src/libsyntax/parse/parser/module.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/e81347c3685dfc818fca2d502819ee0d1b692621/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81347c3685dfc818fca2d502819ee0d1b692621/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs?ref=e81347c3685dfc818fca2d502819ee0d1b692621", "patch": "@@ -0,0 +1,332 @@\n+use super::{Parser, PResult};\n+use super::item::ItemInfo;\n+\n+use crate::attr;\n+use crate::ast::{self, Ident, Attribute, ItemKind, Mod, Crate};\n+use crate::parse::{new_sub_parser_from_file, DirectoryOwnership};\n+use crate::parse::token::{self, TokenKind};\n+use crate::parse::diagnostics::{Error};\n+use crate::source_map::{SourceMap, Span, DUMMY_SP, FileName};\n+use crate::symbol::sym;\n+\n+use std::path::{self, Path, PathBuf};\n+\n+/// Information about the path to a module.\n+pub struct ModulePath {\n+    name: String,\n+    path_exists: bool,\n+    pub result: Result<ModulePathSuccess, Error>,\n+}\n+\n+pub struct ModulePathSuccess {\n+    pub path: PathBuf,\n+    pub directory_ownership: DirectoryOwnership,\n+    warn: bool,\n+}\n+\n+impl<'a> Parser<'a> {\n+    /// Parses a source module as a crate. This is the main entry point for the parser.\n+    pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n+        let lo = self.token.span;\n+        let krate = Ok(ast::Crate {\n+            attrs: self.parse_inner_attributes()?,\n+            module: self.parse_mod_items(&token::Eof, lo)?,\n+            span: lo.to(self.token.span),\n+        });\n+        krate\n+    }\n+\n+    /// Parse a `mod <foo> { ... }` or `mod <foo>;` item\n+    pub(super) fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> {\n+        let (in_cfg, outer_attrs) = {\n+            let mut strip_unconfigured = crate::config::StripUnconfigured {\n+                sess: self.sess,\n+                features: None, // don't perform gated feature checking\n+            };\n+            let mut outer_attrs = outer_attrs.to_owned();\n+            strip_unconfigured.process_cfg_attrs(&mut outer_attrs);\n+            (!self.cfg_mods || strip_unconfigured.in_cfg(&outer_attrs), outer_attrs)\n+        };\n+\n+        let id_span = self.token.span;\n+        let id = self.parse_ident()?;\n+        if self.eat(&token::Semi) {\n+            if in_cfg && self.recurse_into_file_modules {\n+                // This mod is in an external file. Let's go get it!\n+                let ModulePathSuccess { path, directory_ownership, warn } =\n+                    self.submod_path(id, &outer_attrs, id_span)?;\n+                let (module, mut attrs) =\n+                    self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n+                // Record that we fetched the mod from an external file\n+                if warn {\n+                    let attr = attr::mk_attr_outer(\n+                        attr::mk_word_item(Ident::with_empty_ctxt(sym::warn_directory_ownership)));\n+                    attr::mark_known(&attr);\n+                    attrs.push(attr);\n+                }\n+                Ok((id, ItemKind::Mod(module), Some(attrs)))\n+            } else {\n+                let placeholder = ast::Mod {\n+                    inner: DUMMY_SP,\n+                    items: Vec::new(),\n+                    inline: false\n+                };\n+                Ok((id, ItemKind::Mod(placeholder), None))\n+            }\n+        } else {\n+            let old_directory = self.directory.clone();\n+            self.push_directory(id, &outer_attrs);\n+\n+            self.expect(&token::OpenDelim(token::Brace))?;\n+            let mod_inner_lo = self.token.span;\n+            let attrs = self.parse_inner_attributes()?;\n+            let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n+\n+            self.directory = old_directory;\n+            Ok((id, ItemKind::Mod(module), Some(attrs)))\n+        }\n+    }\n+\n+    /// Given a termination token, parses all of the items in a module.\n+    fn parse_mod_items(&mut self, term: &TokenKind, inner_lo: Span) -> PResult<'a, Mod> {\n+        let mut items = vec![];\n+        while let Some(item) = self.parse_item()? {\n+            items.push(item);\n+            self.maybe_consume_incorrect_semicolon(&items);\n+        }\n+\n+        if !self.eat(term) {\n+            let token_str = self.this_token_descr();\n+            if !self.maybe_consume_incorrect_semicolon(&items) {\n+                let mut err = self.fatal(&format!(\"expected item, found {}\", token_str));\n+                err.span_label(self.token.span, \"expected item\");\n+                return Err(err);\n+            }\n+        }\n+\n+        let hi = if self.token.span.is_dummy() {\n+            inner_lo\n+        } else {\n+            self.prev_span\n+        };\n+\n+        Ok(Mod {\n+            inner: inner_lo.to(hi),\n+            items,\n+            inline: true\n+        })\n+    }\n+\n+    fn submod_path(\n+        &mut self,\n+        id: ast::Ident,\n+        outer_attrs: &[Attribute],\n+        id_sp: Span\n+    ) -> PResult<'a, ModulePathSuccess> {\n+        if let Some(path) = Parser::submod_path_from_attr(outer_attrs, &self.directory.path) {\n+            return Ok(ModulePathSuccess {\n+                directory_ownership: match path.file_name().and_then(|s| s.to_str()) {\n+                    // All `#[path]` files are treated as though they are a `mod.rs` file.\n+                    // This means that `mod foo;` declarations inside `#[path]`-included\n+                    // files are siblings,\n+                    //\n+                    // Note that this will produce weirdness when a file named `foo.rs` is\n+                    // `#[path]` included and contains a `mod foo;` declaration.\n+                    // If you encounter this, it's your own darn fault :P\n+                    Some(_) => DirectoryOwnership::Owned { relative: None },\n+                    _ => DirectoryOwnership::UnownedViaMod(true),\n+                },\n+                path,\n+                warn: false,\n+            });\n+        }\n+\n+        let relative = match self.directory.ownership {\n+            DirectoryOwnership::Owned { relative } => relative,\n+            DirectoryOwnership::UnownedViaBlock |\n+            DirectoryOwnership::UnownedViaMod(_) => None,\n+        };\n+        let paths = Parser::default_submod_path(\n+                        id, relative, &self.directory.path, self.sess.source_map());\n+\n+        match self.directory.ownership {\n+            DirectoryOwnership::Owned { .. } => {\n+                paths.result.map_err(|err| self.span_fatal_err(id_sp, err))\n+            },\n+            DirectoryOwnership::UnownedViaBlock => {\n+                let msg =\n+                    \"Cannot declare a non-inline module inside a block \\\n+                    unless it has a path attribute\";\n+                let mut err = self.diagnostic().struct_span_err(id_sp, msg);\n+                if paths.path_exists {\n+                    let msg = format!(\"Maybe `use` the module `{}` instead of redeclaring it\",\n+                                      paths.name);\n+                    err.span_note(id_sp, &msg);\n+                }\n+                Err(err)\n+            }\n+            DirectoryOwnership::UnownedViaMod(warn) => {\n+                if warn {\n+                    if let Ok(result) = paths.result {\n+                        return Ok(ModulePathSuccess { warn: true, ..result });\n+                    }\n+                }\n+                let mut err = self.diagnostic().struct_span_err(id_sp,\n+                    \"cannot declare a new module at this location\");\n+                if !id_sp.is_dummy() {\n+                    let src_path = self.sess.source_map().span_to_filename(id_sp);\n+                    if let FileName::Real(src_path) = src_path {\n+                        if let Some(stem) = src_path.file_stem() {\n+                            let mut dest_path = src_path.clone();\n+                            dest_path.set_file_name(stem);\n+                            dest_path.push(\"mod.rs\");\n+                            err.span_note(id_sp,\n+                                    &format!(\"maybe move this module `{}` to its own \\\n+                                                directory via `{}`\", src_path.display(),\n+                                            dest_path.display()));\n+                        }\n+                    }\n+                }\n+                if paths.path_exists {\n+                    err.span_note(id_sp,\n+                                  &format!(\"... or maybe `use` the module `{}` instead \\\n+                                            of possibly redeclaring it\",\n+                                           paths.name));\n+                }\n+                Err(err)\n+            }\n+        }\n+    }\n+\n+    pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n+        if let Some(s) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n+            let s = s.as_str();\n+\n+            // On windows, the base path might have the form\n+            // `\\\\?\\foo\\bar` in which case it does not tolerate\n+            // mixed `/` and `\\` separators, so canonicalize\n+            // `/` to `\\`.\n+            #[cfg(windows)]\n+            let s = s.replace(\"/\", \"\\\\\");\n+            Some(dir_path.join(s))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns a path to a module.\n+    pub fn default_submod_path(\n+        id: ast::Ident,\n+        relative: Option<ast::Ident>,\n+        dir_path: &Path,\n+        source_map: &SourceMap) -> ModulePath\n+    {\n+        // If we're in a foo.rs file instead of a mod.rs file,\n+        // we need to look for submodules in\n+        // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n+        // `./<id>.rs` and `./<id>/mod.rs`.\n+        let relative_prefix_string;\n+        let relative_prefix = if let Some(ident) = relative {\n+            relative_prefix_string = format!(\"{}{}\", ident.as_str(), path::MAIN_SEPARATOR);\n+            &relative_prefix_string\n+        } else {\n+            \"\"\n+        };\n+\n+        let mod_name = id.to_string();\n+        let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n+        let secondary_path_str = format!(\"{}{}{}mod.rs\",\n+                                         relative_prefix, mod_name, path::MAIN_SEPARATOR);\n+        let default_path = dir_path.join(&default_path_str);\n+        let secondary_path = dir_path.join(&secondary_path_str);\n+        let default_exists = source_map.file_exists(&default_path);\n+        let secondary_exists = source_map.file_exists(&secondary_path);\n+\n+        let result = match (default_exists, secondary_exists) {\n+            (true, false) => Ok(ModulePathSuccess {\n+                path: default_path,\n+                directory_ownership: DirectoryOwnership::Owned {\n+                    relative: Some(id),\n+                },\n+                warn: false,\n+            }),\n+            (false, true) => Ok(ModulePathSuccess {\n+                path: secondary_path,\n+                directory_ownership: DirectoryOwnership::Owned {\n+                    relative: None,\n+                },\n+                warn: false,\n+            }),\n+            (false, false) => Err(Error::FileNotFoundForModule {\n+                mod_name: mod_name.clone(),\n+                default_path: default_path_str,\n+                secondary_path: secondary_path_str,\n+                dir_path: dir_path.display().to_string(),\n+            }),\n+            (true, true) => Err(Error::DuplicatePaths {\n+                mod_name: mod_name.clone(),\n+                default_path: default_path_str,\n+                secondary_path: secondary_path_str,\n+            }),\n+        };\n+\n+        ModulePath {\n+            name: mod_name,\n+            path_exists: default_exists || secondary_exists,\n+            result,\n+        }\n+    }\n+\n+    /// Reads a module from a source file.\n+    fn eval_src_mod(\n+        &mut self,\n+        path: PathBuf,\n+        directory_ownership: DirectoryOwnership,\n+        name: String,\n+        id_sp: Span,\n+    ) -> PResult<'a, (Mod, Vec<Attribute>)> {\n+        let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n+        if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n+            let mut err = String::from(\"circular modules: \");\n+            let len = included_mod_stack.len();\n+            for p in &included_mod_stack[i.. len] {\n+                err.push_str(&p.to_string_lossy());\n+                err.push_str(\" -> \");\n+            }\n+            err.push_str(&path.to_string_lossy());\n+            return Err(self.span_fatal(id_sp, &err[..]));\n+        }\n+        included_mod_stack.push(path.clone());\n+        drop(included_mod_stack);\n+\n+        let mut p0 =\n+            new_sub_parser_from_file(self.sess, &path, directory_ownership, Some(name), id_sp);\n+        p0.cfg_mods = self.cfg_mods;\n+        let mod_inner_lo = p0.token.span;\n+        let mod_attrs = p0.parse_inner_attributes()?;\n+        let mut m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n+        m0.inline = false;\n+        self.sess.included_mod_stack.borrow_mut().pop();\n+        Ok((m0, mod_attrs))\n+    }\n+\n+    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n+        if let Some(path) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n+            self.directory.path.to_mut().push(&path.as_str());\n+            self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n+        } else {\n+            // We have to push on the current module name in the case of relative\n+            // paths in order to ensure that any additional module paths from inline\n+            // `mod x { ... }` come after the relative extension.\n+            //\n+            // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n+            // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n+            if let DirectoryOwnership::Owned { relative } = &mut self.directory.ownership {\n+                if let Some(ident) = relative.take() { // remove the relative offset\n+                    self.directory.path.to_mut().push(ident.as_str());\n+                }\n+            }\n+            self.directory.path.to_mut().push(&id.as_str());\n+        }\n+    }\n+}"}]}