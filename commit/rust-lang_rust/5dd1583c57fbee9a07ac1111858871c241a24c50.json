{"sha": "5dd1583c57fbee9a07ac1111858871c241a24c50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZDE1ODNjNTdmYmVlOWEwN2FjMTExMTg1ODg3MWMyNDFhMjRjNTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-22T22:09:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-28T20:14:42Z"}, "message": "Make some more rt components public\n\nPrimarily this makes the Scheduler and all of its related interfaces public. The\nreason for doing this is that currently any extern event loops had no access to\nthe scheduler at all. This allows third-party event loops to manipulate the\nscheduler, along with allowing the uv event loop to live inside of its own\ncrate.", "tree": {"sha": "93532b8b4189fe0e2f090dc8fcd0a9537a0d9191", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93532b8b4189fe0e2f090dc8fcd0a9537a0d9191"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dd1583c57fbee9a07ac1111858871c241a24c50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd1583c57fbee9a07ac1111858871c241a24c50", "html_url": "https://github.com/rust-lang/rust/commit/5dd1583c57fbee9a07ac1111858871c241a24c50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dd1583c57fbee9a07ac1111858871c241a24c50/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ab4a6fab046769ddad48de557f64b0a97f86ce3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ab4a6fab046769ddad48de557f64b0a97f86ce3", "html_url": "https://github.com/rust-lang/rust/commit/2ab4a6fab046769ddad48de557f64b0a97f86ce3"}], "stats": {"total": 58, "additions": 28, "deletions": 30}, "files": [{"sha": "21fdf0e50a1128e52fc871056511b8cbcc0c3754", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=5dd1583c57fbee9a07ac1111858871c241a24c50", "patch": "@@ -87,15 +87,13 @@ pub use self::util::set_exit_status;\n // method...\n pub use self::util::default_sched_threads;\n \n+// Re-export of the functionality in the kill module\n+pub use self::kill::{KillHandle, BlockedTask};\n+\n // XXX: these probably shouldn't be public...\n #[doc(hidden)]\n pub mod shouldnt_be_public {\n-    pub use super::sched::Scheduler;\n-    pub use super::kill::KillHandle;\n-    pub use super::thread::Thread;\n-    pub use super::work_queue::WorkQueue;\n     pub use super::select::SelectInner;\n-    pub use super::rtio::EventLoop;\n     pub use super::select::{SelectInner, SelectPortInner};\n     pub use super::local_ptr::maybe_tls_key;\n }\n@@ -116,13 +114,13 @@ pub mod task;\n mod kill;\n \n /// The coroutine task scheduler, built on the `io` event loop.\n-mod sched;\n+pub mod sched;\n \n /// Synchronous I/O.\n pub mod io;\n \n /// The EventLoop and internal synchronous I/O interface.\n-mod rtio;\n+pub mod rtio;\n \n /// libuv and default rtio implementation.\n pub mod uv;\n@@ -132,10 +130,10 @@ pub mod uv;\n pub mod local;\n \n /// A parallel work-stealing deque.\n-mod work_queue;\n+pub mod work_queue;\n \n /// A parallel queue.\n-mod message_queue;\n+pub mod message_queue;\n \n /// A mostly lock-free multi-producer, single consumer queue.\n mod mpsc_queue;\n@@ -144,7 +142,7 @@ mod mpsc_queue;\n mod mpmc_bounded_queue;\n \n /// A parallel data structure for tracking sleeping schedulers.\n-mod sleeper_list;\n+pub mod sleeper_list;\n \n /// Stack segments and caching.\n pub mod stack;\n@@ -153,7 +151,7 @@ pub mod stack;\n mod context;\n \n /// Bindings to system threading libraries.\n-mod thread;\n+pub mod thread;\n \n /// The runtime configuration, read from environment variables.\n pub mod env;\n@@ -327,7 +325,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         // waking up schedulers for work stealing; since this is a\n         // non-work-stealing scheduler it should not be adding itself\n         // to the list.\n-        main_handle.send_shutdown();\n+        main_handle.send(Shutdown);\n         Some(main_sched)\n     } else {\n         None"}, {"sha": "3ee822ced2dd4e3e60f42a4456494899409fac33", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=5dd1583c57fbee9a07ac1111858871c241a24c50", "patch": "@@ -542,7 +542,7 @@ impl Scheduler {\n \n         match this.sleeper_list.casual_pop() {\n             Some(handle) => {\n-                        let mut handle = handle;\n+                let mut handle = handle;\n                 handle.send(Wake)\n             }\n             None => { (/* pass */) }\n@@ -818,12 +818,6 @@ impl SchedHandle {\n         self.queue.push(msg);\n         self.remote.fire();\n     }\n-    pub fn send_task_from_friend(&mut self, friend: ~Task) {\n-        self.send(TaskFromFriend(friend));\n-    }\n-    pub fn send_shutdown(&mut self) {\n-        self.send(Shutdown);\n-    }\n }\n \n struct CleanupJob {\n@@ -1266,15 +1260,15 @@ mod test {\n         use comm::{GenericPort, GenericChan};\n \n         do run_in_mt_newsched_task {\n-                let (end_port, end_chan) = oneshot();\n+            let (end_port, end_chan) = oneshot();\n \n             let n_tasks = 10;\n             let token = 2000;\n \n-                let (p, ch1) = stream();\n+            let (p, ch1) = stream();\n             let mut p = p;\n-                ch1.send((token, end_chan));\n-                let mut i = 2;\n+            ch1.send((token, end_chan));\n+            let mut i = 2;\n             while i <= n_tasks {\n                 let (next_p, ch) = stream();\n                 let imm_i = i;"}, {"sha": "f5dc98c57b65187bb712ddb716161930f495787e", "filename": "src/libstd/select.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=5dd1583c57fbee9a07ac1111858871c241a24c50", "patch": "@@ -18,7 +18,9 @@ use option::*;\n // use either::{Either, Left, Right};\n // use rt::kill::BlockedTask;\n use rt::local::Local;\n-use rt::shouldnt_be_public::{EventLoop, Scheduler, SelectInner, SelectPortInner};\n+use rt::rtio::EventLoop;\n+use rt::sched::Scheduler;\n+use rt::shouldnt_be_public::{SelectInner, SelectPortInner};\n use task;\n use unstable::finally::Finally;\n use vec::{OwnedVector, MutableVector};"}, {"sha": "023ba6f7108a23a16ffd8f90e7eb2bc72e45fc5f", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=5dd1583c57fbee9a07ac1111858871c241a24c50", "patch": "@@ -578,7 +578,7 @@ pub fn deschedule() {\n     //! Yield control to the task scheduler\n \n     use rt::local::Local;\n-    use rt::shouldnt_be_public::Scheduler;\n+    use rt::sched::Scheduler;\n \n     // FIXME(#7544): Optimize this, since we know we won't block.\n     let sched: ~Scheduler = Local::take();\n@@ -1094,7 +1094,7 @@ fn test_try_fail() {\n \n #[cfg(test)]\n fn get_sched_id() -> int {\n-    do Local::borrow |sched: &mut ::rt::shouldnt_be_public::Scheduler| {\n+    do Local::borrow |sched: &mut ::rt::sched::Scheduler| {\n         sched.sched_id() as int\n     }\n }"}, {"sha": "2cda38f8a30baf18e18b83106e9c0642965e9f96", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=5dd1583c57fbee9a07ac1111858871c241a24c50", "patch": "@@ -82,7 +82,11 @@ use hashmap::{HashSet, HashSetMoveIterator};\n use local_data;\n use rt::in_green_task_context;\n use rt::local::Local;\n-use rt::shouldnt_be_public::{Scheduler, KillHandle, WorkQueue, Thread, EventLoop};\n+use rt::sched::Scheduler;\n+use rt::KillHandle;\n+use rt::work_queue::WorkQueue;\n+use rt::rtio::EventLoop;\n+use rt::thread::Thread;\n use rt::task::{Task, Sched};\n use rt::task::{UnwindReasonLinked, UnwindReasonStr};\n use rt::task::{UnwindResult, Success, Failure};\n@@ -627,7 +631,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n             let mut new_sched_handle = new_sched.make_handle();\n \n             // Allow the scheduler to exit when the pinned task exits\n-            new_sched_handle.send_shutdown();\n+            new_sched_handle.send(Shutdown);\n \n             // Pin the new task to the new scheduler\n             let new_task = if opts.watched {\n@@ -665,7 +669,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n                 debug!(\"enqueing join_task\");\n                 // Now tell the original scheduler to join with this thread\n                 // by scheduling a thread-joining task on the original scheduler\n-                orig_sched_handle.send_task_from_friend(join_task);\n+                orig_sched_handle.send(TaskFromFriend(join_task));\n \n                 // NB: We can't simply send a message from here to another task\n                 // because this code isn't running in a task and message passing doesn't"}, {"sha": "484ddde6d3ccd226b6dcebee2b6ec900f2e6cc8d", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd1583c57fbee9a07ac1111858871c241a24c50/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=5dd1583c57fbee9a07ac1111858871c241a24c50", "patch": "@@ -37,7 +37,7 @@ a normal large stack.\n */\n pub fn run_in_bare_thread(f: ~fn()) {\n     use cell::Cell;\n-    use rt::shouldnt_be_public::Thread;\n+    use rt::thread::Thread;\n \n     let f_cell = Cell::new(f);\n     let (port, chan) = comm::stream();"}]}