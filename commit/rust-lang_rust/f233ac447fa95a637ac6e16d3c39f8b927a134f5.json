{"sha": "f233ac447fa95a637ac6e16d3c39f8b927a134f5", "node_id": "C_kwDOAAsO6NoAKGYyMzNhYzQ0N2ZhOTVhNjM3YWM2ZTE2ZDNjMzlmOGI5MjdhMTM0ZjU", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-10-26T08:21:08Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-10-27T10:18:57Z"}, "message": "Lower generic arguments for associated types in paths", "tree": {"sha": "508312039378a0f5701ce82374e0efc44c1ed194", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/508312039378a0f5701ce82374e0efc44c1ed194"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f233ac447fa95a637ac6e16d3c39f8b927a134f5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmNaWxEACgkQ4laYqTBY\nYXGfDQ//efXg74VZVYtioK+z8Cq7LJh4pAH/BDIqc0jXfk8/cVtiIPQ25CfEkCPc\n8kTpYJPPOIpnExf/LBZo74FbPdCWTpu8CmYsf42gIJi7qbJX3c12gA86SgTKvIPr\njl/BnHLv3zulHR3Y9Fkit+bW+s5BPHegSjX+KQGldWnrandm0OEyBsfaBpAfKwDL\nqLzRIdNdzg3BBcdlQR037DJV37V7yRN+AdRbVpSdOycsMFHqS0TuQ9L0zASf49r8\nMAGBi7byek2mWE03lh2LbJaEZwIxVFPZ82NLCVwpPbB9hZqximAfVlo/Bp/R/Ppu\n2h/Jx+80vNLYXh3ybKYOqnvD9hPmRePVdisA4HoIY4GJhb2Y/sNECeRhy5AhDDm7\nLJDUwkcnRcA4f8gAVuoy/AvN3SN7ZGDqH3/E5WNGsLn/iOnN0ZQRi76gAmrfxvlQ\nt5WkV2LzAt44R7IZ74Mc/NjEGZcssBc/DxPslSAZ3H7AXd487QprgyfMr1Y0l5Sh\nfvfLu6mFNyDHPdyc5U+MHjAtjmGnme24ICPmtdRoOex/V5+gpoUOUfOGxk5/xTvx\nQK59AgyZG/y/tGoutijnEl+LFD9nz+1i1MlNC0VtYzufA4e6BKacm9M0wcdW2r1W\nmBHNT874TbvqACJ/6J0batyfeCYqQNAY5e+MBxNY0pjpDxBSKgw=\n=5N4v\n-----END PGP SIGNATURE-----", "payload": "tree 508312039378a0f5701ce82374e0efc44c1ed194\nparent 4dd694371a57e22d56724a22a32535f4a2b886de\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1666772468 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1666865937 +0900\n\nLower generic arguments for associated types in paths\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f233ac447fa95a637ac6e16d3c39f8b927a134f5", "html_url": "https://github.com/rust-lang/rust/commit/f233ac447fa95a637ac6e16d3c39f8b927a134f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f233ac447fa95a637ac6e16d3c39f8b927a134f5/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dd694371a57e22d56724a22a32535f4a2b886de", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dd694371a57e22d56724a22a32535f4a2b886de", "html_url": "https://github.com/rust-lang/rust/commit/4dd694371a57e22d56724a22a32535f4a2b886de"}], "stats": {"total": 232, "additions": 193, "deletions": 39}, "files": [{"sha": "996b42f5bd83c03bb906bddf466d5eaa2c863973", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f233ac447fa95a637ac6e16d3c39f8b927a134f5/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f233ac447fa95a637ac6e16d3c39f8b927a134f5/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=f233ac447fa95a637ac6e16d3c39f8b927a134f5", "patch": "@@ -11,9 +11,9 @@ use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n-    from_placeholder_idx, to_chalk_trait_id, AdtId, AliasEq, AliasTy, Binders, CallableDefId,\n-    CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy, QuantifiedWhereClause,\n-    Substitution, TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n+    from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n+    CallableDefId, CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n+    QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n };\n \n pub trait TyExt {\n@@ -338,10 +338,13 @@ pub trait ProjectionTyExt {\n \n impl ProjectionTyExt for ProjectionTy {\n     fn trait_ref(&self, db: &dyn HirDatabase) -> TraitRef {\n-        TraitRef {\n-            trait_id: to_chalk_trait_id(self.trait_(db)),\n-            substitution: self.substitution.clone(),\n-        }\n+        // FIXME: something like `Split` trait from chalk-solve might be nice.\n+        let generics = generics(db.upcast(), from_assoc_type_id(self.associated_ty_id).into());\n+        let substitution = Substitution::from_iter(\n+            Interner,\n+            self.substitution.iter(Interner).skip(generics.len_self()),\n+        );\n+        TraitRef { trait_id: to_chalk_trait_id(self.trait_(db)), substitution }\n     }\n \n     fn trait_(&self, db: &dyn HirDatabase) -> TraitId {"}, {"sha": "ebe9d6fb5e0146d6c687f17a925c1c1e74a88a2e", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f233ac447fa95a637ac6e16d3c39f8b927a134f5/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f233ac447fa95a637ac6e16d3c39f8b927a134f5/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=f233ac447fa95a637ac6e16d3c39f8b927a134f5", "patch": "@@ -157,7 +157,7 @@ impl<'a> InferenceContext<'a> {\n                     remaining_segments_for_ty,\n                     true,\n                 );\n-                if let TyKind::Error = ty.kind(Interner) {\n+                if ty.is_unknown() {\n                     return None;\n                 }\n "}, {"sha": "4447927451896036edb4eb5a294c081df10748be", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 62, "deletions": 31, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f233ac447fa95a637ac6e16d3c39f8b927a134f5/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f233ac447fa95a637ac6e16d3c39f8b927a134f5/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=f233ac447fa95a637ac6e16d3c39f8b927a134f5", "patch": "@@ -447,12 +447,31 @@ impl<'a> TyLoweringContext<'a> {\n                             .db\n                             .trait_data(trait_ref.hir_trait_id())\n                             .associated_type_by_name(segment.name);\n+\n                         match found {\n                             Some(associated_ty) => {\n-                                // FIXME handle type parameters on the segment\n+                                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                                // that method to optionally take parent `Substitution` as we already know them at\n+                                // this point (`trait_ref.substitution`).\n+                                let substitution = self.substs_from_path_segment(\n+                                    segment,\n+                                    Some(associated_ty.into()),\n+                                    false,\n+                                    None,\n+                                );\n+                                let len_self =\n+                                    generics(self.db.upcast(), associated_ty.into()).len_self();\n+                                let substitution = Substitution::from_iter(\n+                                    Interner,\n+                                    substitution\n+                                        .iter(Interner)\n+                                        .take(len_self)\n+                                        .chain(trait_ref.substitution.iter(Interner)),\n+                                );\n                                 TyKind::Alias(AliasTy::Projection(ProjectionTy {\n                                     associated_ty_id: to_assoc_type_id(associated_ty),\n-                                    substitution: trait_ref.substitution,\n+                                    substitution,\n                                 }))\n                                 .intern(Interner)\n                             }\n@@ -590,36 +609,48 @@ impl<'a> TyLoweringContext<'a> {\n             res,\n             Some(segment.name.clone()),\n             move |name, t, associated_ty| {\n-                if name == segment.name {\n-                    let substs = match self.type_param_mode {\n-                        ParamLoweringMode::Placeholder => {\n-                            // if we're lowering to placeholders, we have to put\n-                            // them in now\n-                            let generics = generics(\n-                                self.db.upcast(),\n-                                self.resolver\n-                                    .generic_def()\n-                                    .expect(\"there should be generics if there's a generic param\"),\n-                            );\n-                            let s = generics.placeholder_subst(self.db);\n-                            s.apply(t.substitution.clone(), Interner)\n-                        }\n-                        ParamLoweringMode::Variable => t.substitution.clone(),\n-                    };\n-                    // We need to shift in the bound vars, since\n-                    // associated_type_shorthand_candidates does not do that\n-                    let substs = substs.shifted_in_from(Interner, self.in_binders);\n-                    // FIXME handle type parameters on the segment\n-                    Some(\n-                        TyKind::Alias(AliasTy::Projection(ProjectionTy {\n-                            associated_ty_id: to_assoc_type_id(associated_ty),\n-                            substitution: substs,\n-                        }))\n-                        .intern(Interner),\n-                    )\n-                } else {\n-                    None\n+                if name != segment.name {\n+                    return None;\n                 }\n+\n+                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                // that method to optionally take parent `Substitution` as we already know them at\n+                // this point (`t.substitution`).\n+                let substs = self.substs_from_path_segment(\n+                    segment.clone(),\n+                    Some(associated_ty.into()),\n+                    false,\n+                    None,\n+                );\n+\n+                let len_self = generics(self.db.upcast(), associated_ty.into()).len_self();\n+\n+                let substs = Substitution::from_iter(\n+                    Interner,\n+                    substs.iter(Interner).take(len_self).chain(t.substitution.iter(Interner)),\n+                );\n+\n+                let substs = match self.type_param_mode {\n+                    ParamLoweringMode::Placeholder => {\n+                        // if we're lowering to placeholders, we have to put\n+                        // them in now\n+                        let generics = generics(self.db.upcast(), def);\n+                        let s = generics.placeholder_subst(self.db);\n+                        s.apply(substs, Interner)\n+                    }\n+                    ParamLoweringMode::Variable => substs,\n+                };\n+                // We need to shift in the bound vars, since\n+                // associated_type_shorthand_candidates does not do that\n+                let substs = substs.shifted_in_from(Interner, self.in_binders);\n+                Some(\n+                    TyKind::Alias(AliasTy::Projection(ProjectionTy {\n+                        associated_ty_id: to_assoc_type_id(associated_ty),\n+                        substitution: substs,\n+                    }))\n+                    .intern(Interner),\n+                )\n             },\n         );\n "}, {"sha": "2b8468e85a17264119bbc71023a7b447156d0785", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f233ac447fa95a637ac6e16d3c39f8b927a134f5/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f233ac447fa95a637ac6e16d3c39f8b927a134f5/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=f233ac447fa95a637ac6e16d3c39f8b927a134f5", "patch": "@@ -3963,3 +3963,123 @@ fn g(t: &(dyn T + Send)) {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn gats_in_path() {\n+    check_infer_with_mismatches(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+trait PointerFamily {\n+    type Pointer<T>: Deref<Target = T>;\n+}\n+\n+fn f<P: PointerFamily>(p: P::Pointer<i32>) {\n+    let a = *p;\n+}\n+fn g<P: PointerFamily>(p: <P as PointerFamily>::Pointer<i32>) {\n+    let a = *p;\n+}\n+        \"#,\n+        expect![[r#\"\n+            110..111 'p': PointerFamily::Pointer<i32, P>\n+            130..149 '{     ... *p; }': ()\n+            140..141 'a': i32\n+            144..146 '*p': i32\n+            145..146 'p': PointerFamily::Pointer<i32, P>\n+            173..174 'p': PointerFamily::Pointer<i32, P>\n+            212..231 '{     ... *p; }': ()\n+            222..223 'a': i32\n+            226..228 '*p': i32\n+            227..228 'p': PointerFamily::Pointer<i32, P>\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn gats_with_impl_trait() {\n+    // FIXME: the last function (`fn h()`) is not valid Rust as of this writing because you cannot\n+    // specify the same associated type multiple times even if their arguments are different.\n+    // Reconsider how to treat these invalid types.\n+    check_infer_with_mismatches(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+\n+trait Trait {\n+    type Assoc<T>: Deref<Target = T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<T>(v: impl Trait) {\n+    v.get::<i32>().deref();\n+    v.get::<T>().deref();\n+}\n+fn g<T>(v: impl Trait<Assoc<T> = &'a T>) {\n+    let a = v.get::<T>();\n+    let a = v.get::<()>();\n+}\n+fn h(v: impl Trait<Assoc<i32> = &'a i32, Assoc<i64> = &'a i64> {\n+    let a = v.get::<i32>();\n+    let a = v.get::<i64>();\n+}\n+    \"#,\n+        expect![[r#\"\n+            90..94 'self': &Self\n+            126..127 'v': impl Trait\n+            141..198 '{     ...f(); }': ()\n+            147..148 'v': impl Trait\n+            147..161 'v.get::<i32>()': Trait::Assoc<i32, impl Trait>\n+            147..169 'v.get:...eref()': &i32\n+            175..176 'v': impl Trait\n+            175..187 'v.get::<T>()': Trait::Assoc<T, impl Trait>\n+            175..195 'v.get:...eref()': &T\n+            207..208 'v': impl Trait<Assoc<T> = &T>\n+            240..296 '{     ...>(); }': ()\n+            250..251 'a': &T\n+            254..255 'v': impl Trait<Assoc<T> = &T>\n+            254..266 'v.get::<T>()': &T\n+            276..277 'a': Trait::Assoc<(), impl Trait<Assoc<T> = &T>>\n+            280..281 'v': impl Trait<Assoc<T> = &T>\n+            280..293 'v.get::<()>()': Trait::Assoc<(), impl Trait<Assoc<T> = &T>>\n+            302..303 'v': impl Trait<Assoc<i32> = &i32, Assoc<i64> = &i64>\n+            360..419 '{     ...>(); }': ()\n+            370..371 'a': &i32\n+            374..375 'v': impl Trait<Assoc<i32> = &i32, Assoc<i64> = &i64>\n+            374..388 'v.get::<i32>()': &i32\n+            398..399 'a': &i64\n+            402..403 'v': impl Trait<Assoc<i32> = &i32, Assoc<i64> = &i64>\n+            402..416 'v.get::<i64>()': &i64\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn gats_with_dyn() {\n+    // This test is here to keep track of how we infer things despite traits with GATs being not\n+    // object-safe currently.\n+    // FIXME: reconsider how to treat these invalid types.\n+    check_infer_with_mismatches(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+\n+trait Trait {\n+    type Assoc<T>: Deref<Target = T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<'a>(v: &dyn Trait<Assoc<i32> = &'a i32>) {\n+    v.get::<i32>().deref();\n+}\n+    \"#,\n+        expect![[r#\"\n+            90..94 'self': &Self\n+            127..128 'v': &(dyn Trait<Assoc<i32> = &i32>)\n+            164..195 '{     ...f(); }': ()\n+            170..171 'v': &(dyn Trait<Assoc<i32> = &i32>)\n+            170..184 'v.get::<i32>()': &i32\n+            170..192 'v.get:...eref()': &i32\n+        \"#]],\n+    );\n+}"}]}