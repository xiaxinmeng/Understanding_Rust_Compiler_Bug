{"sha": "a92669638461836f41f54f95e396f9082bb91391", "node_id": "C_kwDOAAsO6NoAKGE5MjY2OTYzODQ2MTgzNmY0MWY1NGY5NWUzOTZmOTA4MmJiOTEzOTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-14T15:19:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-14T15:19:12Z"}, "message": "Auto merge of #101805 - Dylan-DPC:rollup-mpdlbin, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #101433 (Emit a note that static bounds from HRTBs are a bug)\n - #101684 (smol grammar changes to README.md)\n - #101769 (rustdoc: remove redundant CSS `.out-of-band > span.since { position }`)\n - #101772 (Also replace the placeholder for the stable_features lint)\n - #101773 (rustdoc: remove outdated CSS `.content table` etc)\n - #101779 (Update test output for drop tracking)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a15b9529a3211770abe582f803a89cbbf7ff191b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a15b9529a3211770abe582f803a89cbbf7ff191b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a92669638461836f41f54f95e396f9082bb91391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a92669638461836f41f54f95e396f9082bb91391", "html_url": "https://github.com/rust-lang/rust/commit/a92669638461836f41f54f95e396f9082bb91391", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a92669638461836f41f54f95e396f9082bb91391/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c97922dca563cb7f9385b18dbf7ca8c97f8e1597", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97922dca563cb7f9385b18dbf7ca8c97f8e1597", "html_url": "https://github.com/rust-lang/rust/commit/c97922dca563cb7f9385b18dbf7ca8c97f8e1597"}, {"sha": "15a5bc9c52fdf8268544efb239bf9455b795c424", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a5bc9c52fdf8268544efb239bf9455b795c424", "html_url": "https://github.com/rust-lang/rust/commit/15a5bc9c52fdf8268544efb239bf9455b795c424"}], "stats": {"total": 1223, "additions": 947, "deletions": 276}, "files": [{"sha": "27e7145c5a99e4afadff029b4685473f0423ac5f", "filename": "README.md", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -22,7 +22,7 @@ Read [\"Installation\"] from [The Book].\n ## Installing from Source\n \n The Rust build system uses a Python script called `x.py` to build the compiler,\n-which manages the bootstrapping process. It lives in the root of the project.\n+which manages the bootstrapping process. It lives at the root of the project.\n \n The `x.py` command can be run directly on most systems in the following format:\n \n@@ -32,7 +32,7 @@ The `x.py` command can be run directly on most systems in the following format:\n \n This is how the documentation and examples assume you are running `x.py`.\n \n-Systems such as Ubuntu 20.04 LTS do not create the necessary `python` command by default when Python is installed that allows `x.py` to be run directly. In that case you can either create a symlink for `python` (Ubuntu provides the `python-is-python3` package for this), or run `x.py` using Python itself:\n+Systems such as Ubuntu 20.04 LTS do not create the necessary `python` command by default when Python is installed that allows `x.py` to be run directly. In that case, you can either create a symlink for `python` (Ubuntu provides the `python-is-python3` package for this), or run `x.py` using Python itself:\n \n ```sh\n # Python 3\n@@ -103,22 +103,21 @@ by running it with the `--help` flag or reading the [rustc dev guide][rustcguide\n ### Building on Windows\n \n There are two prominent ABIs in use on Windows: the native (MSVC) ABI used by\n-Visual Studio, and the GNU ABI used by the GCC toolchain. Which version of Rust\n-you need depends largely on what C/C++ libraries you want to interoperate with:\n-for interop with software produced by Visual Studio use the MSVC build of Rust;\n-for interop with GNU software built using the MinGW/MSYS2 toolchain use the GNU\n-build.\n+Visual Studio and the GNU ABI used by the GCC toolchain. Which version of Rust\n+you need depends largely on what C/C++ libraries you want to interoperate with.\n+Use the MSVC build of Rust to interop with software produced by Visual Studio and\n+the GNU build to interop with GNU software built using the MinGW/MSYS2 toolchain.\n \n #### MinGW\n \n [MSYS2][msys2] can be used to easily build Rust on Windows:\n \n [msys2]: https://www.msys2.org/\n \n-1. Grab the latest [MSYS2 installer][msys2] and go through the installer.\n+1. Download the latest [MSYS2 installer][msys2] and go through the installer.\n \n-2. Run `mingw32_shell.bat` or `mingw64_shell.bat` from wherever you installed\n-   MSYS2 (i.e. `C:\\msys64`), depending on whether you want 32-bit or 64-bit\n+2. Run `mingw32_shell.bat` or `mingw64_shell.bat` from the MSYS2 installation\n+   directory (e.g. `C:\\msys64`), depending on whether you want 32-bit or 64-bit\n    Rust. (As of the latest version of MSYS2 you have to run `msys2_shell.cmd\n    -mingw32` or `msys2_shell.cmd -mingw64` from the command line instead)\n \n@@ -168,7 +167,7 @@ shell with:\n python x.py build\n ```\n \n-Currently, building Rust only works with some known versions of Visual Studio. If\n+Right now, building Rust only works with some known versions of Visual Studio. If\n you have a more recent version installed and the build system doesn't understand,\n you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n@@ -225,7 +224,7 @@ the ABI used. I.e., if the ABI was `x86_64-pc-windows-msvc`, the directory will\n \n Since the Rust compiler is written in Rust, it must be built by a\n precompiled \"snapshot\" version of itself (made in an earlier stage of\n-development). As such, source builds require a connection to the Internet, to\n+development). As such, source builds require an Internet connection to\n fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n Snapshot binaries are currently built and tested on several platforms:"}, {"sha": "753f62dd589d05f048bd805da0e042c952cd2088", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -21,6 +21,12 @@ use crate::session_diagnostics::{self, IncorrectReprFormatGenericCause};\n /// For more, see [this pull request](https://github.com/rust-lang/rust/pull/100591).\n pub const VERSION_PLACEHOLDER: &str = \"CURRENT_RUSTC_VERSION\";\n \n+pub fn rust_version_symbol() -> Symbol {\n+    let version = option_env!(\"CFG_VERSION\").unwrap_or(\"<current>\");\n+    let version = version.split(' ').next().unwrap();\n+    Symbol::intern(&version)\n+}\n+\n pub fn is_builtin_attr(attr: &Attribute) -> bool {\n     attr.is_doc_comment() || attr.ident().filter(|ident| is_builtin_attr_name(ident.name)).is_some()\n }\n@@ -495,9 +501,7 @@ where\n                     }\n \n                     if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n-                        let version = option_env!(\"CFG_VERSION\").unwrap_or(\"<current>\");\n-                        let version = version.split(' ').next().unwrap();\n-                        since = Some(Symbol::intern(&version));\n+                        since = Some(rust_version_symbol());\n                     }\n \n                     match (feature, since) {"}, {"sha": "df04128135b8986c2a976af99df433447e1f1af2", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -21,10 +21,7 @@ pub(crate) struct OutlivesConstraintSet<'tcx> {\n \n impl<'tcx> OutlivesConstraintSet<'tcx> {\n     pub(crate) fn push(&mut self, constraint: OutlivesConstraint<'tcx>) {\n-        debug!(\n-            \"OutlivesConstraintSet::push({:?}: {:?} @ {:?}\",\n-            constraint.sup, constraint.sub, constraint.locations\n-        );\n+        debug!(\"OutlivesConstraintSet::push({:?})\", constraint);\n         if constraint.sup == constraint.sub {\n             // 'a: 'a is pretty uninteresting\n             return;\n@@ -73,7 +70,7 @@ impl<'tcx> Index<OutlivesConstraintIndex> for OutlivesConstraintSet<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n pub struct OutlivesConstraint<'tcx> {\n     // NB. The ordering here is not significant for correctness, but\n     // it is for convenience. Before we dump the constraints in the"}, {"sha": "1c01e78abd422ed097b440c49ce32bb56a54863b", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{sym, DesugaringKind, Span};\n \n-use crate::region_infer::BlameConstraint;\n+use crate::region_infer::{BlameConstraint, ExtraConstraintInfo};\n use crate::{\n     borrow_set::BorrowData, nll::ConstraintDescription, region_infer::Cause, MirBorrowckCtxt,\n     WriteKind,\n@@ -38,6 +38,7 @@ pub(crate) enum BorrowExplanation<'tcx> {\n         span: Span,\n         region_name: RegionName,\n         opt_place_desc: Option<String>,\n+        extra_info: Vec<ExtraConstraintInfo>,\n     },\n     Unexplained,\n }\n@@ -243,6 +244,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 ref region_name,\n                 ref opt_place_desc,\n                 from_closure: _,\n+                ref extra_info,\n             } => {\n                 region_name.highlight_region_name(err);\n \n@@ -268,6 +270,14 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     );\n                 };\n \n+                for extra in extra_info {\n+                    match extra {\n+                        ExtraConstraintInfo::PlaceholderFromPredicate(span) => {\n+                            err.span_note(*span, format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\"));\n+                        }\n+                    }\n+                }\n+\n                 self.add_lifetime_bound_suggestion_to_diagnostic(err, &category, span, region_name);\n             }\n             _ => {}\n@@ -309,18 +319,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n-    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>) {\n-        let BlameConstraint { category, from_closure, cause, variance_info: _ } =\n-            self.regioncx.best_blame_constraint(\n-                &self.body,\n-                borrow_region,\n-                NllRegionVariableOrigin::FreeRegion,\n-                |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n-            );\n+    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n+        let (blame_constraint, extra_info) = self.regioncx.best_blame_constraint(\n+            borrow_region,\n+            NllRegionVariableOrigin::FreeRegion,\n+            |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n+        );\n+        let BlameConstraint { category, from_closure, cause, .. } = blame_constraint;\n \n         let outlived_fr_name = self.give_region_a_name(outlived_region);\n \n-        (category, from_closure, cause.span, outlived_fr_name)\n+        (category, from_closure, cause.span, outlived_fr_name, extra_info)\n     }\n \n     /// Returns structured explanation for *why* the borrow contains the\n@@ -392,7 +401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             None => {\n                 if let Some(region) = self.to_error_region_vid(borrow_region_vid) {\n-                    let (category, from_closure, span, region_name) =\n+                    let (category, from_closure, span, region_name, extra_info) =\n                         self.free_region_constraint_info(borrow_region_vid, region);\n                     if let Some(region_name) = region_name {\n                         let opt_place_desc = self.describe_place(borrow.borrowed_place.as_ref());\n@@ -402,6 +411,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             span,\n                             region_name,\n                             opt_place_desc,\n+                            extra_info,\n                         }\n                     } else {\n                         debug!(\"Could not generate a region name\");"}, {"sha": "34be2874fcb738d527c9f64923eb2aa7921f006e", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -31,7 +31,7 @@ use crate::session_diagnostics::{\n };\n \n use super::{OutlivesSuggestionBuilder, RegionName};\n-use crate::region_infer::BlameConstraint;\n+use crate::region_infer::{BlameConstraint, ExtraConstraintInfo};\n use crate::{\n     nll::ConstraintDescription,\n     region_infer::{values::RegionElement, TypeTest},\n@@ -234,7 +234,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                     // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n                     let (_, cause) = self.regioncx.find_outlives_blame_span(\n-                        &self.body,\n                         longer_fr,\n                         NllRegionVariableOrigin::Placeholder(placeholder),\n                         error_vid,\n@@ -355,10 +354,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"report_region_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let BlameConstraint { category, cause, variance_info, from_closure: _ } =\n-            self.regioncx.best_blame_constraint(&self.body, fr, fr_origin, |r| {\n+        let (blame_constraint, extra_info) =\n+            self.regioncx.best_blame_constraint(fr, fr_origin, |r| {\n                 self.regioncx.provides_universal_region(r, fr, outlived_fr)\n             });\n+        let BlameConstraint { category, cause, variance_info, .. } = blame_constraint;\n \n         debug!(\"report_region_error: category={:?} {:?} {:?}\", category, cause, variance_info);\n \n@@ -467,6 +467,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         }\n \n+        for extra in extra_info {\n+            match extra {\n+                ExtraConstraintInfo::PlaceholderFromPredicate(span) => {\n+                    diag.span_note(span, format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\"));\n+                }\n+            }\n+        }\n+\n         self.buffer_error(diag);\n     }\n \n@@ -558,6 +566,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// LL |     ref_obj(x)\n     ///    |     ^^^^^^^^^^ `x` escapes the function body here\n     /// ```\n+    #[instrument(level = \"debug\", skip(self))]\n     fn report_escaping_data_error(\n         &self,\n         errci: &ErrorConstraintInfo<'tcx>,"}, {"sha": "244e6e3422d83d0dcdee8ff0b7214727e530cb1c", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 69, "deletions": 72, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -245,6 +245,11 @@ enum Trace<'tcx> {\n     NotVisited,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum ExtraConstraintInfo {\n+    PlaceholderFromPredicate(Span),\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -590,13 +595,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // constraints were too strong, and if so, emit or propagate those errors.\n         if infcx.tcx.sess.opts.unstable_opts.polonius {\n             self.check_polonius_subset_errors(\n-                body,\n                 outlives_requirements.as_mut(),\n                 &mut errors_buffer,\n                 polonius_output.expect(\"Polonius output is unavailable despite `-Z polonius`\"),\n             );\n         } else {\n-            self.check_universal_regions(body, outlives_requirements.as_mut(), &mut errors_buffer);\n+            self.check_universal_regions(outlives_requirements.as_mut(), &mut errors_buffer);\n         }\n \n         if errors_buffer.is_empty() {\n@@ -1409,7 +1413,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// report them as errors.\n     fn check_universal_regions(\n         &self,\n-        body: &Body<'tcx>,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n@@ -1420,7 +1423,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     // they did not grow too large, accumulating any requirements\n                     // for our caller into the `outlives_requirements` vector.\n                     self.check_universal_region(\n-                        body,\n                         fr,\n                         &mut propagated_outlives_requirements,\n                         errors_buffer,\n@@ -1461,7 +1463,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// report them as errors.\n     fn check_polonius_subset_errors(\n         &self,\n-        body: &Body<'tcx>,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n         polonius_output: Rc<PoloniusOutput>,\n@@ -1508,7 +1509,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let propagated = self.try_propagate_universal_region_error(\n                 *longer_fr,\n                 *shorter_fr,\n-                body,\n                 &mut propagated_outlives_requirements,\n             );\n             if propagated == RegionRelationCheckResult::Error {\n@@ -1548,13 +1548,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Things that are to be propagated are accumulated into the\n     /// `outlives_requirements` vector.\n-    #[instrument(\n-        skip(self, body, propagated_outlives_requirements, errors_buffer),\n-        level = \"debug\"\n-    )]\n+    #[instrument(skip(self, propagated_outlives_requirements, errors_buffer), level = \"debug\")]\n     fn check_universal_region(\n         &self,\n-        body: &Body<'tcx>,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n@@ -1577,7 +1573,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let RegionRelationCheckResult::Error = self.check_universal_region_relation(\n                 longer_fr,\n                 representative,\n-                body,\n                 propagated_outlives_requirements,\n             ) {\n                 errors_buffer.push(RegionErrorKind::RegionError {\n@@ -1597,7 +1592,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let RegionRelationCheckResult::Error = self.check_universal_region_relation(\n                 longer_fr,\n                 shorter_fr,\n-                body,\n                 propagated_outlives_requirements,\n             ) {\n                 // We only report the first region error. Subsequent errors are hidden so as\n@@ -1622,7 +1616,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         longer_fr: RegionVid,\n         shorter_fr: RegionVid,\n-        body: &Body<'tcx>,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n     ) -> RegionRelationCheckResult {\n         // If it is known that `fr: o`, carry on.\n@@ -1638,7 +1631,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.try_propagate_universal_region_error(\n                 longer_fr,\n                 shorter_fr,\n-                body,\n                 propagated_outlives_requirements,\n             )\n         }\n@@ -1650,7 +1642,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         longer_fr: RegionVid,\n         shorter_fr: RegionVid,\n-        body: &Body<'tcx>,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n     ) -> RegionRelationCheckResult {\n         if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n@@ -1662,7 +1653,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 debug!(\"try_propagate_universal_region_error: fr_minus={:?}\", fr_minus);\n \n                 let blame_span_category = self.find_outlives_blame_span(\n-                    body,\n                     longer_fr,\n                     NllRegionVariableOrigin::FreeRegion,\n                     shorter_fr,\n@@ -1816,50 +1806,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     pub(crate) fn retrieve_closure_constraint_info(\n         &self,\n-        _body: &Body<'tcx>,\n-        constraint: &OutlivesConstraint<'tcx>,\n-    ) -> BlameConstraint<'tcx> {\n-        let loc = match constraint.locations {\n-            Locations::All(span) => {\n-                return BlameConstraint {\n-                    category: constraint.category,\n-                    from_closure: false,\n-                    cause: ObligationCause::dummy_with_span(span),\n-                    variance_info: constraint.variance_info,\n-                };\n+        constraint: OutlivesConstraint<'tcx>,\n+    ) -> Option<(ConstraintCategory<'tcx>, Span)> {\n+        match constraint.locations {\n+            Locations::All(_) => None,\n+            Locations::Single(loc) => {\n+                self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub)).copied()\n             }\n-            Locations::Single(loc) => loc,\n-        };\n-\n-        let opt_span_category =\n-            self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n-        opt_span_category\n-            .map(|&(category, span)| BlameConstraint {\n-                category,\n-                from_closure: true,\n-                cause: ObligationCause::dummy_with_span(span),\n-                variance_info: constraint.variance_info,\n-            })\n-            .unwrap_or(BlameConstraint {\n-                category: constraint.category,\n-                from_closure: false,\n-                cause: ObligationCause::dummy_with_span(constraint.span),\n-                variance_info: constraint.variance_info,\n-            })\n+        }\n     }\n \n     /// Finds a good `ObligationCause` to blame for the fact that `fr1` outlives `fr2`.\n     pub(crate) fn find_outlives_blame_span(\n         &self,\n-        body: &Body<'tcx>,\n         fr1: RegionVid,\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory<'tcx>, ObligationCause<'tcx>) {\n-        let BlameConstraint { category, cause, .. } =\n-            self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n-                self.provides_universal_region(r, fr1, fr2)\n-            });\n+        let BlameConstraint { category, cause, .. } = self\n+            .best_blame_constraint(fr1, fr1_origin, |r| self.provides_universal_region(r, fr1, fr2))\n+            .0;\n         (category, cause)\n     }\n \n@@ -2045,11 +2011,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(level = \"debug\", skip(self, target_test))]\n     pub(crate) fn best_blame_constraint(\n         &self,\n-        body: &Body<'tcx>,\n         from_region: RegionVid,\n         from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> BlameConstraint<'tcx> {\n+    ) -> (BlameConstraint<'tcx>, Vec<ExtraConstraintInfo>) {\n         // Find all paths\n         let (path, target_region) =\n             self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n@@ -2065,6 +2030,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .collect::<Vec<_>>()\n         );\n \n+        let mut extra_info = vec![];\n+        for constraint in path.iter() {\n+            let outlived = constraint.sub;\n+            let Some(origin) = self.var_infos.get(outlived) else { continue; };\n+            let RegionVariableOrigin::Nll(NllRegionVariableOrigin::Placeholder(p)) = origin.origin else { continue; };\n+            debug!(?constraint, ?p);\n+            let ConstraintCategory::Predicate(span) = constraint.category else { continue; };\n+            extra_info.push(ExtraConstraintInfo::PlaceholderFromPredicate(span));\n+            // We only want to point to one\n+            break;\n+        }\n+\n         // We try to avoid reporting a `ConstraintCategory::Predicate` as our best constraint.\n         // Instead, we use it to produce an improved `ObligationCauseCode`.\n         // FIXME - determine what we should do if we encounter multiple `ConstraintCategory::Predicate`\n@@ -2090,19 +2067,29 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut categorized_path: Vec<BlameConstraint<'tcx>> = path\n             .iter()\n             .map(|constraint| {\n-                if constraint.category == ConstraintCategory::ClosureBounds {\n-                    self.retrieve_closure_constraint_info(body, &constraint)\n-                } else {\n-                    BlameConstraint {\n-                        category: constraint.category,\n-                        from_closure: false,\n-                        cause: ObligationCause::new(\n-                            constraint.span,\n-                            CRATE_HIR_ID,\n-                            cause_code.clone(),\n-                        ),\n-                        variance_info: constraint.variance_info,\n-                    }\n+                let (category, span, from_closure, cause_code) =\n+                    if constraint.category == ConstraintCategory::ClosureBounds {\n+                        if let Some((category, span)) =\n+                            self.retrieve_closure_constraint_info(*constraint)\n+                        {\n+                            (category, span, true, ObligationCauseCode::MiscObligation)\n+                        } else {\n+                            (\n+                                constraint.category,\n+                                constraint.span,\n+                                false,\n+                                ObligationCauseCode::MiscObligation,\n+                            )\n+                        }\n+                    } else {\n+                        (constraint.category, constraint.span, false, cause_code.clone())\n+                    };\n+                BlameConstraint {\n+                    category,\n+                    from_closure,\n+                    cause: ObligationCause::new(span, CRATE_HIR_ID, cause_code),\n+                    variance_info: constraint.variance_info,\n+                    outlives_constraint: *constraint,\n                 }\n             })\n             .collect();\n@@ -2204,7 +2191,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let best_choice =\n             if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n \n-        debug!(?best_choice, ?blame_source);\n+        debug!(?best_choice, ?blame_source, ?extra_info);\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n@@ -2213,7 +2200,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 {\n                     // The return expression is being influenced by the return type being\n                     // impl Trait, point at the return type and not the return expr.\n-                    return next.clone();\n+                    return (next.clone(), extra_info);\n                 }\n             }\n \n@@ -2233,7 +2220,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n             }\n \n-            return categorized_path[i].clone();\n+            return (categorized_path[i].clone(), extra_info);\n         }\n \n         // If that search fails, that is.. unusual. Maybe everything\n@@ -2243,7 +2230,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n         debug!(\"sorted_path={:#?}\", categorized_path);\n \n-        categorized_path.remove(0)\n+        (categorized_path.remove(0), extra_info)\n     }\n \n     pub(crate) fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n@@ -2325,7 +2312,13 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                              outlives_requirement={:?}\",\n                             region, outlived_region, outlives_requirement,\n                         );\n-                        ty::Binder::dummy(ty::OutlivesPredicate(region.into(), outlived_region))\n+                        (\n+                            ty::Binder::dummy(ty::OutlivesPredicate(\n+                                region.into(),\n+                                outlived_region,\n+                            )),\n+                            ConstraintCategory::BoringNoLocation,\n+                        )\n                     }\n \n                     ClosureOutlivesSubject::Ty(ty) => {\n@@ -2335,7 +2328,10 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                              outlives_requirement={:?}\",\n                             ty, outlived_region, outlives_requirement,\n                         );\n-                        ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                        (\n+                            ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region)),\n+                            ConstraintCategory::BoringNoLocation,\n+                        )\n                     }\n                 }\n             })\n@@ -2349,4 +2345,5 @@ pub struct BlameConstraint<'tcx> {\n     pub from_closure: bool,\n     pub cause: ObligationCause<'tcx>,\n     pub variance_info: ty::VarianceDiagInfo<'tcx>,\n+    pub outlives_constraint: OutlivesConstraint<'tcx>,\n }"}, {"sha": "9271a2f4dc718f345fb32bad3814386fda2b2738", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// constraints should occur within this method so that those\n     /// constraints can be properly localized!**\n     #[instrument(skip(self, op), level = \"trace\")]\n-    pub(super) fn fully_perform_op<R, Op>(\n+    pub(super) fn fully_perform_op<R: fmt::Debug, Op>(\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n@@ -39,6 +39,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n         let TypeOpOutput { output, constraints, error_info } = op.fully_perform(self.infcx)?;\n \n+        debug!(?output, ?constraints);\n+\n         if let Some(data) = constraints {\n             self.push_region_constraints(locations, category, data);\n         }\n@@ -102,6 +104,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn normalize_and_prove_instantiated_predicates(\n         &mut self,\n         // Keep this parameter for now, in case we start using\n@@ -116,8 +119,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             .zip(instantiated_predicates.spans.into_iter())\n         {\n             debug!(?predicate);\n-            let predicate = self.normalize(predicate, locations);\n-            self.prove_predicate(predicate, locations, ConstraintCategory::Predicate(span));\n+            let category = ConstraintCategory::Predicate(span);\n+            let predicate = self.normalize_with_category(predicate, locations, category);\n+            self.prove_predicate(predicate, locations, category);\n         }\n     }\n \n@@ -153,15 +157,27 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         })\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     pub(super) fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n+    where\n+        T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,\n+    {\n+        self.normalize_with_category(value, location, ConstraintCategory::Boring)\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn normalize_with_category<T>(\n+        &mut self,\n+        value: T,\n+        location: impl NormalizeLocation,\n+        category: ConstraintCategory<'tcx>,\n+    ) -> T\n     where\n         T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,\n     {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             location.to_locations(),\n-            ConstraintCategory::Boring,\n+            category,\n             param_env.and(type_op::normalize::Normalize::new(value)),\n         )\n         .unwrap_or_else(|NoSolution| {"}, {"sha": "71eae0583cb483870b4a612d8442a36436602310", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n+    fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below.\n@@ -98,15 +98,18 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         // region constraints like `for<'a> 'a: 'b`. At some point\n         // when we move to universes, we will, and this assertion\n         // will start to fail.\n-        let ty::OutlivesPredicate(k1, r2) = query_constraint.no_bound_vars().unwrap_or_else(|| {\n-            bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n-        });\n+        let ty::OutlivesPredicate(k1, r2) =\n+            query_constraint.0.no_bound_vars().unwrap_or_else(|| {\n+                bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n+            });\n+\n+        let constraint_category = query_constraint.1;\n \n         match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n                 let r1_vid = self.to_region_vid(r1);\n                 let r2_vid = self.to_region_vid(r2);\n-                self.add_outlives(r1_vid, r2_vid);\n+                self.add_outlives(r1_vid, r2_vid, constraint_category);\n             }\n \n             GenericArgKind::Type(t1) => {\n@@ -121,7 +124,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                     Some(implicit_region_bound),\n                     param_env,\n                 )\n-                .type_must_outlive(origin, t1, r2);\n+                .type_must_outlive(origin, t1, r2, constraint_category);\n             }\n \n             GenericArgKind::Const(_) => {\n@@ -168,10 +171,19 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n+    fn add_outlives(\n+        &mut self,\n+        sup: ty::RegionVid,\n+        sub: ty::RegionVid,\n+        category: ConstraintCategory<'tcx>,\n+    ) {\n+        let category = match self.category {\n+            ConstraintCategory::Boring | ConstraintCategory::BoringNoLocation => category,\n+            _ => self.category,\n+        };\n         self.constraints.outlives_constraints.push(OutlivesConstraint {\n             locations: self.locations,\n-            category: self.category,\n+            category,\n             span: self.span,\n             sub,\n             sup,\n@@ -191,10 +203,11 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         _origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n+        constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);\n-        self.add_outlives(b, a);\n+        self.add_outlives(b, a, constraint_category);\n     }\n \n     fn push_verify("}, {"sha": "3ad89cfe02fc1ac3d923e2be1f5348da91176af2", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -311,6 +311,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n     }\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n+        debug!(?constant, ?location, \"visit_constant\");\n+\n         self.super_constant(constant, location);\n         let ty = self.sanitize_type(constant, constant.literal.ty());\n \n@@ -1810,6 +1812,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     }\n \n     fn check_operand(&mut self, op: &Operand<'tcx>, location: Location) {\n+        debug!(?op, ?location, \"check_operand\");\n+\n         if let Operand::Constant(constant) = op {\n             let maybe_uneval = match constant.literal {\n                 ConstantKind::Ty(ct) => match ct.kind() {\n@@ -2560,7 +2564,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 .enumerate()\n                 .filter_map(|(idx, constraint)| {\n                     let ty::OutlivesPredicate(k1, r2) =\n-                        constraint.no_bound_vars().unwrap_or_else(|| {\n+                        constraint.0.no_bound_vars().unwrap_or_else(|| {\n                             bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n                         });\n "}, {"sha": "65371a285911e22f03a45c7cb8a1811b9593f63c", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -110,6 +110,7 @@ infer_relate_param_bound = ...so that the type `{$name}` will meet its required\n infer_relate_param_bound_2 = ...that is required by this bound\n infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n+infer_ascribe_user_type_prove_predicate = ...so that the where clause holds\n \n infer_nothing = {\"\"}\n "}, {"sha": "56e83489879516f0659329050dfb4848fa218c40", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -22,6 +22,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::arena::ArenaAllocatable;\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n@@ -129,7 +130,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n             make_query_region_constraints(\n                 tcx,\n-                region_obligations.iter().map(|r_o| (r_o.sup_type, r_o.sub_region)),\n+                region_obligations\n+                    .iter()\n+                    .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category())),\n                 region_constraints,\n             )\n         });\n@@ -248,6 +251,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n \n+        let constraint_category = cause.to_constraint_category();\n+\n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n             let result_value = query_response.substitute_projected(self.tcx, &result_subst, |v| {\n@@ -263,12 +268,14 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 (GenericArgKind::Lifetime(v_o), GenericArgKind::Lifetime(v_r)) => {\n                     // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n                     if v_o != v_r {\n-                        output_query_region_constraints\n-                            .outlives\n-                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)));\n-                        output_query_region_constraints\n-                            .outlives\n-                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)));\n+                        output_query_region_constraints.outlives.push((\n+                            ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)),\n+                            constraint_category,\n+                        ));\n+                        output_query_region_constraints.outlives.push((\n+                            ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)),\n+                            constraint_category,\n+                        ));\n                     }\n                 }\n \n@@ -314,7 +321,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 // Screen out `'a: 'a` cases -- we skip the binder here but\n                 // only compare the inner values to one another, so they are still at\n                 // consistent binding levels.\n-                let ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n+                let ty::OutlivesPredicate(k1, r2) = r_c.0.skip_binder();\n                 if k1 != r2.into() { Some(r_c) } else { None }\n             }),\n         );\n@@ -559,7 +566,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Obligation<'tcx, ty::Predicate<'tcx>> {\n-        let ty::OutlivesPredicate(k1, r2) = predicate.skip_binder();\n+        let ty::OutlivesPredicate(k1, r2) = predicate.0.skip_binder();\n \n         let atom = match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n@@ -574,7 +581,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 span_bug!(cause.span, \"unexpected const outlives {:?}\", predicate);\n             }\n         };\n-        let predicate = predicate.rebind(atom).to_predicate(self.tcx);\n+        let predicate = predicate.0.rebind(atom).to_predicate(self.tcx);\n \n         Obligation::new(cause, param_env, predicate)\n     }\n@@ -625,7 +632,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n /// creates query region constraints.\n pub fn make_query_region_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n+    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n     let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n@@ -638,26 +645,31 @@ pub fn make_query_region_constraints<'tcx>(\n \n     let outlives: Vec<_> = constraints\n         .iter()\n-        .map(|(k, _)| match *k {\n-            // Swap regions because we are going from sub (<=) to outlives\n-            // (>=).\n-            Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                tcx.mk_region(ty::ReVar(v2)).into(),\n-                tcx.mk_region(ty::ReVar(v1)),\n-            ),\n-            Constraint::VarSubReg(v1, r2) => {\n-                ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n-            }\n-            Constraint::RegSubVar(r1, v2) => {\n-                ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n-            }\n-            Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+        .map(|(k, origin)| {\n+            // no bound vars in the code above\n+            let constraint = ty::Binder::dummy(match *k {\n+                // Swap regions because we are going from sub (<=) to outlives\n+                // (>=).\n+                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                    tcx.mk_region(ty::ReVar(v2)).into(),\n+                    tcx.mk_region(ty::ReVar(v1)),\n+                ),\n+                Constraint::VarSubReg(v1, r2) => {\n+                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+                }\n+                Constraint::RegSubVar(r1, v2) => {\n+                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+                }\n+                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+            });\n+            (constraint, origin.to_constraint_category())\n         })\n-        .map(ty::Binder::dummy) // no bound vars in the code above\n         .chain(\n             outlives_obligations\n-                .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n-                .map(ty::Binder::dummy), // no bound vars in the code above\n+                // no bound vars in the code above\n+                .map(|(ty, r, constraint_category)| {\n+                    (ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), r)), constraint_category)\n+                }),\n         )\n         .collect();\n "}, {"sha": "adaa47c01402303a297990a385fb1910f0826a55", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -77,6 +77,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n                 self.note_region_origin(err, &parent);\n             }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                RegionOriginNote::Plain {\n+                    span,\n+                    msg: fluent::infer::ascribe_user_type_prove_predicate,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n         }\n     }\n \n@@ -356,6 +363,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 err\n             }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"lifetime instantiated with \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but lifetime must outlive \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n         }\n     }\n "}, {"sha": "efcb6c92998b0a8cce7013762aef963be195fbff", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::select;\n use rustc_middle::ty::abstract_const::{AbstractConst, FailureKind};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n@@ -408,20 +409,36 @@ pub enum SubregionOrigin<'tcx> {\n \n     /// Comparing the signature and requirements of an impl method against\n     /// the containing trait.\n-    CompareImplItemObligation { span: Span, impl_item_def_id: LocalDefId, trait_item_def_id: DefId },\n+    CompareImplItemObligation {\n+        span: Span,\n+        impl_item_def_id: LocalDefId,\n+        trait_item_def_id: DefId,\n+    },\n \n     /// Checking that the bounds of a trait's associated type hold for a given impl\n     CheckAssociatedTypeBounds {\n         parent: Box<SubregionOrigin<'tcx>>,\n         impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n     },\n+\n+    AscribeUserTypeProvePredicate(Span),\n }\n \n // `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(SubregionOrigin<'_>, 32);\n \n+impl<'tcx> SubregionOrigin<'tcx> {\n+    pub fn to_constraint_category(&self) -> ConstraintCategory<'tcx> {\n+        match self {\n+            Self::Subtype(type_trace) => type_trace.cause.to_constraint_category(),\n+            Self::AscribeUserTypeProvePredicate(span) => ConstraintCategory::Predicate(*span),\n+            _ => ConstraintCategory::BoringNoLocation,\n+        }\n+    }\n+}\n+\n /// Times when we replace late-bound regions with variables:\n #[derive(Clone, Copy, Debug)]\n pub enum LateBoundRegionConversionTime {\n@@ -1991,6 +2008,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n             CompareImplItemObligation { span, .. } => span,\n+            AscribeUserTypeProvePredicate(span) => span,\n             CheckAssociatedTypeBounds { ref parent, .. } => parent.span(),\n         }\n     }\n@@ -2023,6 +2041,10 @@ impl<'tcx> SubregionOrigin<'tcx> {\n                 parent: Box::new(default()),\n             },\n \n+            traits::ObligationCauseCode::AscribeUserTypeProvePredicate(span) => {\n+                SubregionOrigin::AscribeUserTypeProvePredicate(span)\n+            }\n+\n             _ => default(),\n         }\n     }"}, {"sha": "b65080e74c4fde65c467857ba73dc3ecc7e2bb80", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -69,6 +69,7 @@ use crate::infer::{\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeVisitable};\n use smallvec::smallvec;\n@@ -163,7 +164,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n             let outlives =\n                 &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n-            outlives.type_must_outlive(origin, sup_type, sub_region);\n+            let category = origin.to_constraint_category();\n+            outlives.type_must_outlive(origin, sup_type, sub_region, category);\n         }\n     }\n \n@@ -207,6 +209,7 @@ pub trait TypeOutlivesDelegate<'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n+        constraint_category: ConstraintCategory<'tcx>,\n     );\n \n     fn push_verify(\n@@ -255,25 +258,27 @@ where\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         assert!(!ty.has_escaping_bound_vars());\n \n         let mut components = smallvec![];\n         push_outlives_components(self.tcx, ty, &mut components);\n-        self.components_must_outlive(origin, &components, region);\n+        self.components_must_outlive(origin, &components, region, category);\n     }\n \n     fn components_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         components: &[Component<'tcx>],\n         region: ty::Region<'tcx>,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         for component in components.iter() {\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n-                    self.delegate.push_sub_region_constraint(origin, region, *region1);\n+                    self.delegate.push_sub_region_constraint(origin, region, *region1, category);\n                 }\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, *param_ty);\n@@ -282,7 +287,7 @@ where\n                     self.projection_must_outlive(origin, region, *projection_ty);\n                 }\n                 Component::EscapingProjection(subcomponents) => {\n-                    self.components_must_outlive(origin, &subcomponents, region);\n+                    self.components_must_outlive(origin, &subcomponents, region, category);\n                 }\n                 Component::UnresolvedInferenceVariable(v) => {\n                     // ignore this, we presume it will yield an error\n@@ -392,10 +397,20 @@ where\n             for k in projection_ty.substs {\n                 match k.unpack() {\n                     GenericArgKind::Lifetime(lt) => {\n-                        self.delegate.push_sub_region_constraint(origin.clone(), region, lt);\n+                        self.delegate.push_sub_region_constraint(\n+                            origin.clone(),\n+                            region,\n+                            lt,\n+                            origin.to_constraint_category(),\n+                        );\n                     }\n                     GenericArgKind::Type(ty) => {\n-                        self.type_must_outlive(origin.clone(), ty, region);\n+                        self.type_must_outlive(\n+                            origin.clone(),\n+                            ty,\n+                            region,\n+                            origin.to_constraint_category(),\n+                        );\n                     }\n                     GenericArgKind::Const(_) => {\n                         // Const parameters don't impose constraints.\n@@ -433,7 +448,8 @@ where\n             let unique_bound = trait_bounds[0];\n             debug!(\"projection_must_outlive: unique trait bound = {:?}\", unique_bound);\n             debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-            self.delegate.push_sub_region_constraint(origin, region, unique_bound);\n+            let category = origin.to_constraint_category();\n+            self.delegate.push_sub_region_constraint(origin, region, unique_bound, category);\n             return;\n         }\n \n@@ -455,6 +471,7 @@ impl<'cx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n+        _constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         self.sub_regions(origin, a, b)\n     }"}, {"sha": "e467ca13c8e50d21288f09ae79b4f241f4d1029d", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -22,6 +22,7 @@\n //! [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html\n \n use crate::infer::MemberConstraint;\n+use crate::mir::ConstraintCategory;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, List, Region, Ty, TyCtxt};\n use rustc_index::vec::IndexVec;\n@@ -290,8 +291,10 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     }\n }\n \n-pub type QueryOutlivesConstraint<'tcx> =\n-    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n+pub type QueryOutlivesConstraint<'tcx> = (\n+    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>,\n+    ConstraintCategory<'tcx>,\n+);\n \n TrivialTypeTraversalAndLiftImpls! {\n     for <'tcx> {"}, {"sha": "d89efe2b3f024a68a19ab18cb42ea3fd57f94f2b", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -327,7 +327,7 @@ rustc_data_structures::static_assert_size!(ConstraintCategory<'_>, 16);\n ///\n /// See also `rustc_const_eval::borrow_check::constraints`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable, Lift, TypeVisitable, TypeFoldable)]\n pub enum ConstraintCategory<'tcx> {\n     Return(ReturnConstraint),\n     Yield,\n@@ -369,7 +369,7 @@ pub enum ConstraintCategory<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeVisitable, TypeFoldable)]\n pub enum ReturnConstraint {\n     Normal,\n     ClosureUpvar(Field),"}, {"sha": "68a7af0b8c8d75669028135952d7f8e921431d45", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -10,6 +10,7 @@ mod structural_impls;\n pub mod util;\n \n use crate::infer::canonical::Canonical;\n+use crate::mir::ConstraintCategory;\n use crate::ty::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n@@ -183,6 +184,16 @@ impl<'tcx> ObligationCause<'tcx> {\n             variant(DerivedObligationCause { parent_trait_pred, parent_code: self.code }).into();\n         self\n     }\n+\n+    pub fn to_constraint_category(&self) -> ConstraintCategory<'tcx> {\n+        match self.code() {\n+            MatchImpl(cause, _) => cause.to_constraint_category(),\n+            AscribeUserTypeProvePredicate(predicate_span) => {\n+                ConstraintCategory::Predicate(*predicate_span)\n+            }\n+            _ => ConstraintCategory::BoringNoLocation,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n@@ -418,6 +429,8 @@ pub enum ObligationCauseCode<'tcx> {\n         is_lit: bool,\n         output_ty: Option<Ty<'tcx>>,\n     },\n+\n+    AscribeUserTypeProvePredicate(Span),\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking."}, {"sha": "37f88016f6013aac9917bf1bc951a2be3e1944d0", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -3,7 +3,7 @@\n //! hand, though we've recently added some macros and proc-macros to help with the tedium.\n \n use crate::mir::interpret;\n-use crate::mir::ProjectionKind;\n+use crate::mir::{Field, ProjectionKind};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable};\n use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n@@ -648,6 +648,20 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     }\n }\n \n+impl<'tcx> Lift<'tcx> for Field {\n+    type Lifted = Field;\n+    fn lift_to_tcx(self, _tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        Some(self)\n+    }\n+}\n+\n+impl<'tcx> Lift<'tcx> for crate::mir::ReturnConstraint {\n+    type Lifted = crate::mir::ReturnConstraint;\n+    fn lift_to_tcx(self, _tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        Some(self)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n "}, {"sha": "04173c792a979442457a6dcd88015adf7f3bea5b", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -5,7 +5,7 @@\n //! collect them instead.\n \n use rustc_ast::{Attribute, MetaItemKind};\n-use rustc_attr::VERSION_PLACEHOLDER;\n+use rustc_attr::{rust_version_symbol, VERSION_PLACEHOLDER};\n use rustc_errors::struct_span_err;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n@@ -57,9 +57,7 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n                 }\n \n                 if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n-                    let version = option_env!(\"CFG_VERSION\").unwrap_or(\"<current>\");\n-                    let version = version.split(' ').next().unwrap();\n-                    since = Some(Symbol::intern(&version));\n+                    since = Some(rust_version_symbol());\n                 }\n \n                 if let Some(feature) = feature {"}, {"sha": "9ba1276099db513581bcd7c6637735ccd8dcd77f", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -2,7 +2,8 @@\n //! propagating default levels lexically from parent to children ast nodes.\n \n use rustc_attr::{\n-    self as attr, ConstStability, Stability, StabilityLevel, Unstable, UnstableReason,\n+    self as attr, rust_version_symbol, ConstStability, Stability, StabilityLevel, Unstable,\n+    UnstableReason, VERSION_PLACEHOLDER,\n };\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_errors::{struct_span_err, Applicability};\n@@ -1106,7 +1107,15 @@ fn unnecessary_partially_stable_feature_lint(\n     });\n }\n \n-fn unnecessary_stable_feature_lint(tcx: TyCtxt<'_>, span: Span, feature: Symbol, since: Symbol) {\n+fn unnecessary_stable_feature_lint(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    feature: Symbol,\n+    mut since: Symbol,\n+) {\n+    if since.as_str() == VERSION_PLACEHOLDER {\n+        since = rust_version_symbol();\n+    }\n     tcx.struct_span_lint_hir(lint::builtin::STABLE_FEATURES, hir::CRATE_HIR_ID, span, |lint| {\n         lint.build(&format!(\n             \"the feature `{feature}` has been stable since {since} and no longer requires an \\"}, {"sha": "99c5ab6aacd678256838eb131b8b109f358e8610", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -2256,7 +2256,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::QuestionMark\n             | ObligationCauseCode::CheckAssociatedTypeBounds { .. }\n             | ObligationCauseCode::LetElse\n-            | ObligationCauseCode::BinOp { .. } => {}\n+            | ObligationCauseCode::BinOp { .. }\n+            | ObligationCauseCode::AscribeUserTypeProvePredicate(..) => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "a3f8f4e2ed0eda65b37b5b5920ba082a82618d2c", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -48,10 +48,11 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         debug!(\n-            \"normalize::<{}>(value={:?}, param_env={:?})\",\n+            \"normalize::<{}>(value={:?}, param_env={:?}, cause={:?})\",\n             std::any::type_name::<T>(),\n             value,\n             self.param_env,\n+            self.cause,\n         );\n         if !needs_normalization(&value, self.param_env.reveal()) {\n             return Ok(Normalized { value, obligations: vec![] });"}, {"sha": "18988861add136646170b71408ee69b9efc297e0", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -23,7 +23,7 @@ impl<F, G> CustomTypeOp<F, G> {\n     }\n }\n \n-impl<'tcx, F, R, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n+impl<'tcx, F, R: fmt::Debug, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n where\n     F: for<'a, 'cx> FnOnce(&'a InferCtxt<'cx, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n     G: Fn() -> String,\n@@ -89,8 +89,8 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n         infcx.tcx,\n         region_obligations\n             .iter()\n-            .map(|r_o| (r_o.sup_type, r_o.sub_region))\n-            .map(|(ty, r)| (infcx.resolve_vars_if_possible(ty), r)),\n+            .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category()))\n+            .map(|(ty, r, cc)| (infcx.resolve_vars_if_possible(ty), r, cc)),\n         &region_constraint_data,\n     );\n "}, {"sha": "8a79165702ca3f6f52252063db779268241c0a9b", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -26,7 +26,7 @@ pub use rustc_middle::traits::query::type_op::*;\n /// extract out the resulting region constraints (or an error if it\n /// cannot be completed).\n pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n-    type Output;\n+    type Output: fmt::Debug;\n     type ErrorInfo;\n \n     /// Processes the operation and all resulting obligations,"}, {"sha": "1a63f853211ed77ba87a71df5abbaec89a6c22f4", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::TraitEngineExt as _;\n+use rustc_infer::traits::{ObligationCauseCode, TraitEngineExt as _};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArg, Subst, UserSelfTy, UserSubsts};\n use rustc_middle::ty::{\n@@ -22,6 +22,7 @@ use rustc_trait_selection::traits::query::type_op::subtype::Subtype;\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, TraitEngine};\n use std::fmt;\n+use std::iter::zip;\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers {\n@@ -61,14 +62,15 @@ pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n         mir_ty, def_id, user_substs\n     );\n \n-    let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n-    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs, span)?;\n+    let mut cx = AscribeUserTypeCx { infcx, param_env, span: span.unwrap_or(DUMMY_SP), fulfill_cx };\n+    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n     Ok(())\n }\n \n struct AscribeUserTypeCx<'me, 'tcx> {\n     infcx: &'me InferCtxt<'me, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n+    span: Span,\n     fulfill_cx: &'me mut dyn TraitEngine<'tcx>,\n }\n \n@@ -79,7 +81,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n     {\n         self.infcx\n             .partially_normalize_associated_types_in(\n-                ObligationCause::misc(DUMMY_SP, hir::CRATE_HIR_ID),\n+                ObligationCause::misc(self.span, hir::CRATE_HIR_ID),\n                 self.param_env,\n                 value,\n             )\n@@ -91,18 +93,13 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         T: ToTrace<'tcx>,\n     {\n         self.infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n+            .at(&ObligationCause::dummy_with_span(self.span), self.param_env)\n             .relate(a, variance, b)?\n             .into_value_registering_obligations(self.infcx, self.fulfill_cx);\n         Ok(())\n     }\n \n-    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, span: Option<Span>) {\n-        let cause = if let Some(span) = span {\n-            ObligationCause::dummy_with_span(span)\n-        } else {\n-            ObligationCause::dummy()\n-        };\n+    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n         self.fulfill_cx.register_predicate_obligation(\n             self.infcx,\n             Obligation::new(cause, self.param_env, predicate),\n@@ -126,7 +123,6 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         mir_ty: Ty<'tcx>,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n-        span: Option<Span>,\n     ) -> Result<(), NoSolution> {\n         let UserSubsts { user_self_ty, substs } = user_substs;\n         let tcx = self.tcx();\n@@ -145,10 +141,20 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // outlives\" error messages.\n         let instantiated_predicates =\n             self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+\n+        let cause = ObligationCause::dummy_with_span(self.span);\n+\n         debug!(?instantiated_predicates);\n-        for instantiated_predicate in instantiated_predicates.predicates {\n-            let instantiated_predicate = self.normalize(instantiated_predicate);\n-            self.prove_predicate(instantiated_predicate, span);\n+        for (instantiated_predicate, predicate_span) in\n+            zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n+        {\n+            let span = if self.span == DUMMY_SP { predicate_span } else { self.span };\n+            let cause = ObligationCause::new(\n+                span,\n+                hir::CRATE_HIR_ID,\n+                ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n+            );\n+            self.prove_predicate(instantiated_predicate, cause);\n         }\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n@@ -161,7 +167,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n             self.prove_predicate(\n                 ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()))\n                     .to_predicate(self.tcx()),\n-                span,\n+                cause.clone(),\n             );\n         }\n \n@@ -178,7 +184,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // which...could happen with normalization...\n         self.prove_predicate(\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(self.tcx()),\n-            span,\n+            cause,\n         );\n         Ok(())\n     }"}, {"sha": "27b3da8ab3dfa7af14518069da365100021c6b7a", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::{OutlivesEnvironment, RegionBoundPairs};\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -663,7 +664,7 @@ fn ty_known_to_outlive<'tcx>(\n     resolve_regions_with_wf_tys(tcx, id, param_env, &wf_tys, |infcx, region_bound_pairs| {\n         let origin = infer::RelateParamBound(DUMMY_SP, ty, None);\n         let outlives = &mut TypeOutlives::new(infcx, tcx, region_bound_pairs, None, param_env);\n-        outlives.type_must_outlive(origin, ty, region);\n+        outlives.type_must_outlive(origin, ty, region, ConstraintCategory::BoringNoLocation);\n     })\n }\n \n@@ -681,7 +682,12 @@ fn region_known_to_outlive<'tcx>(\n         use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n         let origin = infer::RelateRegionParamBound(DUMMY_SP);\n         // `region_a: region_b` -> `region_b <= region_a`\n-        infcx.push_sub_region_constraint(origin, region_b, region_a);\n+        infcx.push_sub_region_constraint(\n+            origin,\n+            region_b,\n+            region_a,\n+            ConstraintCategory::BoringNoLocation,\n+        );\n     })\n }\n "}, {"sha": "9af2b61c0378213051bbf7f17ff042238e96afa4", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -686,15 +686,6 @@ pre, .rustdoc.source .example-wrap {\n \tposition: relative;\n }\n \n-.content table {\n-\tborder-spacing: 0 5px;\n-}\n-.content td { vertical-align: top; }\n-.content td:first-child { padding-right: 20px; }\n-.content td p:first-child { margin-top: 0; }\n-.content td h1, .content td h2 { margin-left: 0; font-size: 1.125rem; }\n-.content tr:first-child td { border-top: 0; }\n-\n .docblock table {\n \tmargin: .5em 0;\n \twidth: calc(100% - 2px);\n@@ -705,6 +696,7 @@ pre, .rustdoc.source .example-wrap {\n .docblock table td {\n \tpadding: .5em;\n \tborder: 1px dashed var(--border-color);\n+\tvertical-align: top;\n }\n \n .docblock table th {\n@@ -1267,7 +1259,6 @@ a.test-arrow:hover {\n }\n \n .out-of-band > span.since {\n-\tposition: initial;\n \tfont-size: 1.25rem;\n }\n "}, {"sha": "3be7f370da3f59cc176d6270805c719250085b9e", "filename": "src/test/ui/async-await/async-await-let-else.drop-tracking.stderr", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,110 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:48:13\n+   |\n+LL |     is_send(foo(Some(true)));\n+   |             ^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:11:14\n+   |\n+LL |         let r = Rc::new(());\n+   |             - has type `Rc<()>` which is not `Send`\n+LL |         bar().await\n+   |              ^^^^^^ await occurs here, with `r` maybe used later\n+LL |     };\n+   |     - `r` is later dropped here\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:19:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error[E0277]: `Rc<()>` cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:50:13\n+   |\n+LL | async fn foo2(x: Option<bool>) {\n+   |                                - within this `impl Future<Output = ()>`\n+...\n+LL |     is_send(foo2(Some(true)));\n+   |     ------- ^^^^^^^^^^^^^^^^ `Rc<()>` cannot be sent between threads safely\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: required because it's used within this `async fn` body\n+  --> $DIR/async-await-let-else.rs:27:29\n+   |\n+LL |   async fn bar2<T>(_: T) -> ! {\n+   |  _____________________________^\n+LL | |     panic!()\n+LL | | }\n+   | |_^\n+   = note: required because it captures the following types: `ResumeTy`, `Option<bool>`, `impl Future<Output = !>`, `()`\n+note: required because it's used within this `async fn` body\n+  --> $DIR/async-await-let-else.rs:21:32\n+   |\n+LL |   async fn foo2(x: Option<bool>) {\n+   |  ________________________________^\n+LL | |     let Some(_) = x else {\n+LL | |         bar2(Rc::new(())).await\n+LL | |     };\n+LL | | }\n+   | |_^\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:19:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:52:13\n+   |\n+LL |     is_send(foo3(Some(true)));\n+   |             ^^^^^^^^^^^^^^^^ future returned by `foo3` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:33:28\n+   |\n+LL |         (Rc::new(()), bar().await);\n+   |          -----------       ^^^^^^ await occurs here, with `Rc::new(())` maybe used later\n+   |          |\n+   |          has type `Rc<()>` which is not `Send`\n+note: `Rc::new(())` is later dropped here\n+  --> $DIR/async-await-let-else.rs:33:35\n+   |\n+LL |         (Rc::new(()), bar().await);\n+   |                                   ^\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:19:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:54:13\n+   |\n+LL |     is_send(foo4(Some(true)));\n+   |             ^^^^^^^^^^^^^^^^ future returned by `foo4` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:41:14\n+   |\n+LL |         let r = Rc::new(());\n+   |             - has type `Rc<()>` which is not `Send`\n+LL |         bar().await;\n+   |              ^^^^^^ await occurs here, with `r` maybe used later\n+...\n+LL |     };\n+   |     - `r` is later dropped here\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:19:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "435cc845870f626619d5fd90d37acd691b27778d", "filename": "src/test/ui/async-await/async-await-let-else.no-drop-tracking.stderr", "status": "renamed", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,12 +1,12 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/async-await-let-else.rs:45:13\n+  --> $DIR/async-await-let-else.rs:48:13\n    |\n LL |     is_send(foo(Some(true)));\n    |             ^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/async-await-let-else.rs:8:14\n+  --> $DIR/async-await-let-else.rs:11:14\n    |\n LL |         let r = Rc::new(());\n    |             - has type `Rc<()>` which is not `Send`\n@@ -15,20 +15,20 @@ LL |         bar().await\n LL |     };\n    |     - `r` is later dropped here\n note: required by a bound in `is_send`\n-  --> $DIR/async-await-let-else.rs:16:15\n+  --> $DIR/async-await-let-else.rs:19:15\n    |\n LL | fn is_send<T: Send>(_: T) {}\n    |               ^^^^ required by this bound in `is_send`\n \n error: future cannot be sent between threads safely\n-  --> $DIR/async-await-let-else.rs:47:13\n+  --> $DIR/async-await-let-else.rs:50:13\n    |\n LL |     is_send(foo2(Some(true)));\n    |             ^^^^^^^^^^^^^^^^ future returned by `foo2` is not `Send`\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/async-await-let-else.rs:20:26\n+  --> $DIR/async-await-let-else.rs:23:26\n    |\n LL |         bar2(Rc::new(())).await\n    |              ----------- ^^^^^^ await occurs here, with `Rc::new(())` maybe used later\n@@ -37,45 +37,45 @@ LL |         bar2(Rc::new(())).await\n LL |     };\n    |      - `Rc::new(())` is later dropped here\n note: required by a bound in `is_send`\n-  --> $DIR/async-await-let-else.rs:16:15\n+  --> $DIR/async-await-let-else.rs:19:15\n    |\n LL | fn is_send<T: Send>(_: T) {}\n    |               ^^^^ required by this bound in `is_send`\n \n error: future cannot be sent between threads safely\n-  --> $DIR/async-await-let-else.rs:49:13\n+  --> $DIR/async-await-let-else.rs:52:13\n    |\n LL |     is_send(foo3(Some(true)));\n    |             ^^^^^^^^^^^^^^^^ future returned by `foo3` is not `Send`\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/async-await-let-else.rs:30:28\n+  --> $DIR/async-await-let-else.rs:33:28\n    |\n LL |         (Rc::new(()), bar().await);\n    |          -----------       ^^^^^^ await occurs here, with `Rc::new(())` maybe used later\n    |          |\n    |          has type `Rc<()>` which is not `Send`\n note: `Rc::new(())` is later dropped here\n-  --> $DIR/async-await-let-else.rs:30:35\n+  --> $DIR/async-await-let-else.rs:33:35\n    |\n LL |         (Rc::new(()), bar().await);\n    |                                   ^\n note: required by a bound in `is_send`\n-  --> $DIR/async-await-let-else.rs:16:15\n+  --> $DIR/async-await-let-else.rs:19:15\n    |\n LL | fn is_send<T: Send>(_: T) {}\n    |               ^^^^ required by this bound in `is_send`\n \n error: future cannot be sent between threads safely\n-  --> $DIR/async-await-let-else.rs:51:13\n+  --> $DIR/async-await-let-else.rs:54:13\n    |\n LL |     is_send(foo4(Some(true)));\n    |             ^^^^^^^^^^^^^^^^ future returned by `foo4` is not `Send`\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/async-await-let-else.rs:38:14\n+  --> $DIR/async-await-let-else.rs:41:14\n    |\n LL |         let r = Rc::new(());\n    |             - has type `Rc<()>` which is not `Send`\n@@ -85,7 +85,7 @@ LL |         bar().await;\n LL |     };\n    |     - `r` is later dropped here\n note: required by a bound in `is_send`\n-  --> $DIR/async-await-let-else.rs:16:15\n+  --> $DIR/async-await-let-else.rs:19:15\n    |\n LL | fn is_send<T: Send>(_: T) {}\n    |               ^^^^ required by this bound in `is_send`", "previous_filename": "src/test/ui/async-await/async-await-let-else.stderr"}, {"sha": "4b287159d13e7791cf22ceeb4387de450d069dc0", "filename": "src/test/ui/async-await/async-await-let-else.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,4 +1,7 @@\n // edition:2021\n+// revisions: drop-tracking no-drop-tracking\n+// [drop-tracking] compile-flags: -Zdrop-tracking=yes\n+// [no-drop-tracking] compile-flags: -Zdrop-tracking=no\n #![feature(let_else)]\n use std::rc::Rc;\n \n@@ -43,11 +46,11 @@ async fn foo4(x: Option<bool>) {\n \n fn main() {\n     is_send(foo(Some(true)));\n-    //~^ ERROR future cannot be sent between threads safely\n+    //~^ ERROR cannot be sent between threads safely\n     is_send(foo2(Some(true)));\n-    //~^ ERROR future cannot be sent between threads safely\n+    //~^ ERROR cannot be sent between threads safely\n     is_send(foo3(Some(true)));\n-    //~^ ERROR future cannot be sent between threads safely\n+    //~^ ERROR cannot be sent between threads safely\n     is_send(foo4(Some(true)));\n-    //~^ ERROR future cannot be sent between threads safely\n+    //~^ ERROR cannot be sent between threads safely\n }"}, {"sha": "f609e36362c440e0e8b5d87995d40027e39f2e19", "filename": "src/test/ui/async-await/issue-64130-4-async-move.drop-tracking.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.drop-tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.drop-tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.drop-tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,12 +1,12 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-64130-4-async-move.rs:15:17\n+  --> $DIR/issue-64130-4-async-move.rs:19:17\n    |\n LL | pub fn foo() -> impl Future + Send {\n    |                 ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `(dyn Any + Send + 'static)`\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/issue-64130-4-async-move.rs:21:31\n+  --> $DIR/issue-64130-4-async-move.rs:25:31\n    |\n LL |         match client.status() {\n    |               ------ has type `&Client` which is not `Send`\n@@ -17,7 +17,7 @@ LL |                 let _x = get().await;\n LL |     }\n    |     - `client` is later dropped here\n help: consider moving this into a `let` binding to create a shorter lived borrow\n-  --> $DIR/issue-64130-4-async-move.rs:19:15\n+  --> $DIR/issue-64130-4-async-move.rs:23:15\n    |\n LL |         match client.status() {\n    |               ^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/async-await/issue-64130-4-async-move.stderr"}, {"sha": "f609e36362c440e0e8b5d87995d40027e39f2e19", "filename": "src/test/ui/async-await/issue-64130-4-async-move.no_drop_tracking.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.no_drop_tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,26 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/issue-64130-4-async-move.rs:19:17\n+   |\n+LL | pub fn foo() -> impl Future + Send {\n+   |                 ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n+   |\n+   = help: the trait `Sync` is not implemented for `(dyn Any + Send + 'static)`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/issue-64130-4-async-move.rs:25:31\n+   |\n+LL |         match client.status() {\n+   |               ------ has type `&Client` which is not `Send`\n+LL |             200 => {\n+LL |                 let _x = get().await;\n+   |                               ^^^^^^ await occurs here, with `client` maybe used later\n+...\n+LL |     }\n+   |     - `client` is later dropped here\n+help: consider moving this into a `let` binding to create a shorter lived borrow\n+  --> $DIR/issue-64130-4-async-move.rs:23:15\n+   |\n+LL |         match client.status() {\n+   |               ^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "a38428fc00f0bb63be5c6cda36ef22f81cc10536", "filename": "src/test/ui/async-await/issue-64130-4-async-move.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,4 +1,8 @@\n // edition:2018\n+// revisions: no_drop_tracking drop_tracking\n+// [drop_tracking] check-pass\n+// [drop_tracking] compile-flags: -Zdrop-tracking=yes\n+// [no_drop_tracking] compile-flags: -Zdrop-tracking=no\n use std::any::Any;\n use std::future::Future;\n \n@@ -10,16 +14,16 @@ impl Client {\n     }\n }\n \n-async fn get() { }\n+async fn get() {}\n \n pub fn foo() -> impl Future + Send {\n-    //~^ ERROR future cannot be sent between threads safely\n+    //[no_drop_tracking]~^ ERROR future cannot be sent between threads safely\n     let client = Client(Box::new(true));\n     async move {\n         match client.status() {\n             200 => {\n                 let _x = get().await;\n-            },\n+            }\n             _ => (),\n         }\n     }"}, {"sha": "c915164cfce86939c0d902138dc25f0bb80eb7e4", "filename": "src/test/ui/async-await/issue-68112.drop_tracking.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,79 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/issue-68112.rs:37:18\n+   |\n+LL |     require_send(send_fut);\n+   |                  ^^^^^^^^ future created by async block is not `Send`\n+   |\n+   = help: the trait `Sync` is not implemented for `RefCell<i32>`\n+note: future is not `Send` as it awaits another future which is not `Send`\n+  --> $DIR/issue-68112.rs:34:17\n+   |\n+LL |         let _ = non_send_fut.await;\n+   |                 ^^^^^^^^^^^^ await occurs here on type `impl Future<Output = Arc<RefCell<i32>>>`, which is not `Send`\n+note: required by a bound in `require_send`\n+  --> $DIR/issue-68112.rs:14:25\n+   |\n+LL | fn require_send(_: impl Send) {}\n+   |                         ^^^^ required by this bound in `require_send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/issue-68112.rs:46:18\n+   |\n+LL |     require_send(send_fut);\n+   |                  ^^^^^^^^ future created by async block is not `Send`\n+   |\n+   = help: the trait `Sync` is not implemented for `RefCell<i32>`\n+note: future is not `Send` as it awaits another future which is not `Send`\n+  --> $DIR/issue-68112.rs:43:17\n+   |\n+LL |         let _ = make_non_send_future1().await;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^ await occurs here on type `impl Future<Output = Arc<RefCell<i32>>>`, which is not `Send`\n+note: required by a bound in `require_send`\n+  --> $DIR/issue-68112.rs:14:25\n+   |\n+LL | fn require_send(_: impl Send) {}\n+   |                         ^^^^ required by this bound in `require_send`\n+\n+error[E0277]: `RefCell<i32>` cannot be shared between threads safely\n+  --> $DIR/issue-68112.rs:65:18\n+   |\n+LL |     require_send(send_fut);\n+   |     ------------ ^^^^^^^^ `RefCell<i32>` cannot be shared between threads safely\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `Sync` is not implemented for `RefCell<i32>`\n+   = note: required for `Arc<RefCell<i32>>` to implement `Send`\n+note: required because it's used within this `async fn` body\n+  --> $DIR/issue-68112.rs:50:31\n+   |\n+LL |   async fn ready2<T>(t: T) -> T {\n+   |  _______________________________^\n+LL | |     t\n+LL | | }\n+   | |_^\n+note: required because it appears within the type `impl Future<Output = Arc<RefCell<i32>>>`\n+  --> $DIR/issue-68112.rs:53:31\n+   |\n+LL | fn make_non_send_future2() -> impl Future<Output = Arc<RefCell<i32>>> {\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `Ready<i32>`\n+note: required because it's used within this `async` block\n+  --> $DIR/issue-68112.rs:60:26\n+   |\n+LL |       let send_fut = async {\n+   |  __________________________^\n+LL | |         let non_send_fut = make_non_send_future2();\n+LL | |         let _ = non_send_fut.await;\n+LL | |         ready(0).await;\n+LL | |     };\n+   | |_____^\n+note: required by a bound in `require_send`\n+  --> $DIR/issue-68112.rs:14:25\n+   |\n+LL | fn require_send(_: impl Send) {}\n+   |                         ^^^^ required by this bound in `require_send`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "11b7d1aaaa6c72621050a9c7c1337f4d103a7bed", "filename": "src/test/ui/async-await/issue-68112.no_drop_tracking.stderr", "status": "renamed", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,41 +1,41 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-68112.rs:34:18\n+  --> $DIR/issue-68112.rs:37:18\n    |\n LL |     require_send(send_fut);\n    |                  ^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `RefCell<i32>`\n note: future is not `Send` as it awaits another future which is not `Send`\n-  --> $DIR/issue-68112.rs:31:17\n+  --> $DIR/issue-68112.rs:34:17\n    |\n LL |         let _ = non_send_fut.await;\n    |                 ^^^^^^^^^^^^ await occurs here on type `impl Future<Output = Arc<RefCell<i32>>>`, which is not `Send`\n note: required by a bound in `require_send`\n-  --> $DIR/issue-68112.rs:11:25\n+  --> $DIR/issue-68112.rs:14:25\n    |\n LL | fn require_send(_: impl Send) {}\n    |                         ^^^^ required by this bound in `require_send`\n \n error: future cannot be sent between threads safely\n-  --> $DIR/issue-68112.rs:43:18\n+  --> $DIR/issue-68112.rs:46:18\n    |\n LL |     require_send(send_fut);\n    |                  ^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `RefCell<i32>`\n note: future is not `Send` as it awaits another future which is not `Send`\n-  --> $DIR/issue-68112.rs:40:17\n+  --> $DIR/issue-68112.rs:43:17\n    |\n LL |         let _ = make_non_send_future1().await;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^ await occurs here on type `impl Future<Output = Arc<RefCell<i32>>>`, which is not `Send`\n note: required by a bound in `require_send`\n-  --> $DIR/issue-68112.rs:11:25\n+  --> $DIR/issue-68112.rs:14:25\n    |\n LL | fn require_send(_: impl Send) {}\n    |                         ^^^^ required by this bound in `require_send`\n \n error[E0277]: `RefCell<i32>` cannot be shared between threads safely\n-  --> $DIR/issue-68112.rs:60:18\n+  --> $DIR/issue-68112.rs:65:18\n    |\n LL |     require_send(send_fut);\n    |     ------------ ^^^^^^^^ `RefCell<i32>` cannot be shared between threads safely\n@@ -45,18 +45,21 @@ LL |     require_send(send_fut);\n    = help: the trait `Sync` is not implemented for `RefCell<i32>`\n    = note: required for `Arc<RefCell<i32>>` to implement `Send`\n note: required because it's used within this `async fn` body\n-  --> $DIR/issue-68112.rs:47:31\n+  --> $DIR/issue-68112.rs:50:31\n    |\n-LL | async fn ready2<T>(t: T) -> T { t }\n-   |                               ^^^^^\n+LL |   async fn ready2<T>(t: T) -> T {\n+   |  _______________________________^\n+LL | |     t\n+LL | | }\n+   | |_^\n note: required because it appears within the type `impl Future<Output = Arc<RefCell<i32>>>`\n-  --> $DIR/issue-68112.rs:48:31\n+  --> $DIR/issue-68112.rs:53:31\n    |\n LL | fn make_non_send_future2() -> impl Future<Output = Arc<RefCell<i32>>> {\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `i32`, `Ready<i32>`\n note: required because it's used within this `async` block\n-  --> $DIR/issue-68112.rs:55:26\n+  --> $DIR/issue-68112.rs:60:26\n    |\n LL |       let send_fut = async {\n    |  __________________________^\n@@ -66,7 +69,7 @@ LL | |         ready(0).await;\n LL | |     };\n    | |_____^\n note: required by a bound in `require_send`\n-  --> $DIR/issue-68112.rs:11:25\n+  --> $DIR/issue-68112.rs:14:25\n    |\n LL | fn require_send(_: impl Send) {}\n    |                         ^^^^ required by this bound in `require_send`", "previous_filename": "src/test/ui/async-await/issue-68112.stderr"}, {"sha": "9c705137a10564580ae16023f193c355ee6672d5", "filename": "src/test/ui/async-await/issue-68112.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,10 +1,13 @@\n // edition:2018\n+// revisions: no_drop_tracking drop_tracking\n+// [drop_tracking] compile-flags: -Zdrop-tracking=yes\n+// [no_drop_tracking] compile-flags: -Zdrop-tracking=no\n \n use std::{\n-    future::Future,\n     cell::RefCell,\n-    sync::Arc,\n+    future::Future,\n     pin::Pin,\n+    sync::Arc,\n     task::{Context, Poll},\n };\n \n@@ -44,7 +47,9 @@ fn test1_no_let() {\n     //~^ ERROR future cannot be sent between threads\n }\n \n-async fn ready2<T>(t: T) -> T { t }\n+async fn ready2<T>(t: T) -> T {\n+    t\n+}\n fn make_non_send_future2() -> impl Future<Output = Arc<RefCell<i32>>> {\n     ready2(Arc::new(RefCell::new(0)))\n }"}, {"sha": "198de7bf79f3668394cd1fbe5f9a1bce88b59bf9", "filename": "src/test/ui/async-await/issue-70935-complex-spans.drop_tracking.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,26 +1,26 @@\n error[E0277]: `Sender<i32>` cannot be shared between threads safely\n-  --> $DIR/issue-70935-complex-spans.rs:12:45\n+  --> $DIR/issue-70935-complex-spans.rs:13:45\n    |\n LL | fn foo(tx: std::sync::mpsc::Sender<i32>) -> impl Future + Send {\n    |                                             ^^^^^^^^^^^^^^^^^^ `Sender<i32>` cannot be shared between threads safely\n    |\n    = help: the trait `Sync` is not implemented for `Sender<i32>`\n    = note: required for `&Sender<i32>` to implement `Send`\n note: required because it's used within this closure\n-  --> $DIR/issue-70935-complex-spans.rs:16:13\n+  --> $DIR/issue-70935-complex-spans.rs:17:13\n    |\n LL |         baz(|| async{\n    |             ^^\n note: required because it's used within this `async fn` body\n-  --> $DIR/issue-70935-complex-spans.rs:9:67\n+  --> $DIR/issue-70935-complex-spans.rs:10:67\n    |\n LL |   async fn baz<T>(_c: impl FnMut() -> T) where T: Future<Output=()> {\n    |  ___________________________________________________________________^\n LL | | }\n    | |_^\n    = note: required because it captures the following types: `ResumeTy`, `impl for<'r, 's, 't0> Future<Output = ()>`, `()`\n note: required because it's used within this `async` block\n-  --> $DIR/issue-70935-complex-spans.rs:15:16\n+  --> $DIR/issue-70935-complex-spans.rs:16:16\n    |\n LL |       async move {\n    |  ________________^"}, {"sha": "34b31198e4f613a16a485e4d1d5a0ea144e7f9e8", "filename": "src/test/ui/async-await/issue-70935-complex-spans.no_drop_tracking.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.no_drop_tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,22 +1,22 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-70935-complex-spans.rs:12:45\n+  --> $DIR/issue-70935-complex-spans.rs:13:45\n    |\n LL | fn foo(tx: std::sync::mpsc::Sender<i32>) -> impl Future + Send {\n    |                                             ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `Sender<i32>`\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/issue-70935-complex-spans.rs:18:11\n+  --> $DIR/issue-70935-complex-spans.rs:19:11\n    |\n LL |           baz(|| async{\n    |  _____________-\n LL | |             foo(tx.clone());\n LL | |         }).await;\n    | |         - ^^^^^^ await occurs here, with the value maybe used later\n    | |_________|\n-   |           has type `[closure@$DIR/issue-70935-complex-spans.rs:16:13: 16:15]` which is not `Send`\n+   |           has type `[closure@$DIR/issue-70935-complex-spans.rs:17:13: 17:15]` which is not `Send`\n note: the value is later dropped here\n-  --> $DIR/issue-70935-complex-spans.rs:18:17\n+  --> $DIR/issue-70935-complex-spans.rs:19:17\n    |\n LL |         }).await;\n    |                 ^", "previous_filename": "src/test/ui/async-await/issue-70935-complex-spans.normal.stderr"}, {"sha": "b6d17f93a6675119914d4467741fea2fbcac046e", "filename": "src/test/ui/async-await/issue-70935-complex-spans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,5 +1,6 @@\n // edition:2018\n-// revisions: normal drop_tracking\n+// revisions: no_drop_tracking drop_tracking\n+// [no_drop_tracking]compile-flags:-Zdrop-tracking=no\n // [drop_tracking]compile-flags:-Zdrop-tracking\n // #70935: Check if we do not emit snippet\n // with newlines which lead complex diagnostics.\n@@ -10,7 +11,7 @@ async fn baz<T>(_c: impl FnMut() -> T) where T: Future<Output=()> {\n }\n \n fn foo(tx: std::sync::mpsc::Sender<i32>) -> impl Future + Send {\n-    //[normal]~^ ERROR future cannot be sent between threads safely\n+    //[no_drop_tracking]~^ ERROR future cannot be sent between threads safely\n     //[drop_tracking]~^^ ERROR `Sender<i32>` cannot be shared between threads\n     async move {\n         baz(|| async{"}, {"sha": "a723503776b9dba540788737919ff36e740ba197", "filename": "src/test/ui/async-await/issues/issue-65436-raw-ptr-not-send.no_drop_tracking.stderr", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.no_drop_tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,5 +1,5 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-65436-raw-ptr-not-send.rs:12:17\n+  --> $DIR/issue-65436-raw-ptr-not-send.rs:16:17\n    |\n LL |       assert_send(async {\n    |  _________________^\n@@ -10,24 +10,24 @@ LL | |     })\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `*const u8`\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/issue-65436-raw-ptr-not-send.rs:14:35\n+  --> $DIR/issue-65436-raw-ptr-not-send.rs:18:35\n    |\n LL |         bar(Foo(std::ptr::null())).await;\n    |                 ----------------  ^^^^^^ await occurs here, with `std::ptr::null()` maybe used later\n    |                 |\n    |                 has type `*const u8` which is not `Send`\n note: `std::ptr::null()` is later dropped here\n-  --> $DIR/issue-65436-raw-ptr-not-send.rs:14:41\n+  --> $DIR/issue-65436-raw-ptr-not-send.rs:18:41\n    |\n LL |         bar(Foo(std::ptr::null())).await;\n    |                                         ^\n help: consider moving this into a `let` binding to create a shorter lived borrow\n-  --> $DIR/issue-65436-raw-ptr-not-send.rs:14:13\n+  --> $DIR/issue-65436-raw-ptr-not-send.rs:18:13\n    |\n LL |         bar(Foo(std::ptr::null())).await;\n    |             ^^^^^^^^^^^^^^^^^^^^^\n note: required by a bound in `assert_send`\n-  --> $DIR/issue-65436-raw-ptr-not-send.rs:9:19\n+  --> $DIR/issue-65436-raw-ptr-not-send.rs:13:19\n    |\n LL | fn assert_send<T: Send>(_: T) {}\n    |                   ^^^^ required by this bound in `assert_send`", "previous_filename": "src/test/ui/async-await/issues/issue-65436-raw-ptr-not-send.stderr"}, {"sha": "91edbc10dc0d770adbf874b234f86a8d30f6e2c0", "filename": "src/test/ui/async-await/issues/issue-65436-raw-ptr-not-send.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,4 +1,8 @@\n // edition:2018\n+// revisions: no_drop_tracking drop_tracking\n+// [drop_tracking] check-pass\n+// [drop_tracking] compile-flags: -Zdrop-tracking=yes\n+// [no_drop_tracking] compile-flags: -Zdrop-tracking=no\n \n struct Foo(*const u8);\n \n@@ -10,7 +14,7 @@ fn assert_send<T: Send>(_: T) {}\n \n fn main() {\n     assert_send(async {\n-    //~^ ERROR future cannot be sent between threads safely\n+        //[no_drop_tracking]~^ ERROR future cannot be sent between threads safely\n         bar(Foo(std::ptr::null())).await;\n     })\n }"}, {"sha": "17b4ef7bdc671705abd27ca37e8423cb94878cc2", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.drop_tracking.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.drop_tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: `NotSend` cannot be sent between threads safely\n+  --> $DIR/partial-drop-partial-reinit.rs:9:16\n+   |\n+LL |     gimme_send(foo());\n+   |     ---------- ^^^^^ `NotSend` cannot be sent between threads safely\n+   |     |\n+   |     required by a bound introduced by this call\n+...\n+LL | async fn foo() {\n+   |                - within this `impl Future<Output = ()>`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `NotSend`\n+   = note: required because it appears within the type `(NotSend,)`\n+   = note: required because it captures the following types: `ResumeTy`, `(NotSend,)`, `()`, `impl Future<Output = ()>`\n+note: required because it's used within this `async fn` body\n+  --> $DIR/partial-drop-partial-reinit.rs:31:16\n+   |\n+LL |   async fn foo() {\n+   |  ________________^\n+LL | |\n+LL | |\n+LL | |     let mut x = (NotSend {},);\n+...  |\n+LL | |     bar().await;\n+LL | | }\n+   | |_^\n+note: required by a bound in `gimme_send`\n+  --> $DIR/partial-drop-partial-reinit.rs:17:18\n+   |\n+LL | fn gimme_send<T: Send>(t: T) {\n+   |                  ^^^^ required by this bound in `gimme_send`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "34d8a159f1064bf05c1e448b9be5303830be108f", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.no_drop_tracking.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.no_drop_tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: `NotSend` cannot be sent between threads safely\n-  --> $DIR/partial-drop-partial-reinit.rs:6:16\n+  --> $DIR/partial-drop-partial-reinit.rs:9:16\n    |\n LL |     gimme_send(foo());\n    |     ---------- ^^^^^ `NotSend` cannot be sent between threads safely\n@@ -13,7 +13,7 @@ LL | async fn foo() {\n    = note: required because it appears within the type `(NotSend,)`\n    = note: required because it captures the following types: `ResumeTy`, `(NotSend,)`, `impl Future<Output = ()>`, `()`\n note: required because it's used within this `async fn` body\n-  --> $DIR/partial-drop-partial-reinit.rs:28:16\n+  --> $DIR/partial-drop-partial-reinit.rs:31:16\n    |\n LL |   async fn foo() {\n    |  ________________^\n@@ -25,7 +25,7 @@ LL | |     bar().await;\n LL | | }\n    | |_^\n note: required by a bound in `gimme_send`\n-  --> $DIR/partial-drop-partial-reinit.rs:14:18\n+  --> $DIR/partial-drop-partial-reinit.rs:17:18\n    |\n LL | fn gimme_send<T: Send>(t: T) {\n    |                  ^^^^ required by this bound in `gimme_send`", "previous_filename": "src/test/ui/async-await/partial-drop-partial-reinit.stderr"}, {"sha": "7d097e72fb49d4d99ee370a87bd65347b7bcb5eb", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,4 +1,7 @@\n // edition:2021\n+// revisions: no_drop_tracking drop_tracking\n+// [drop_tracking] compile-flags: -Zdrop-tracking=yes\n+// [no_drop_tracking] compile-flags: -Zdrop-tracking=no\n #![feature(negative_impls)]\n #![allow(unused)]\n \n@@ -12,8 +15,8 @@ fn main() {\n }\n \n fn gimme_send<T: Send>(t: T) {\n-//~^ NOTE required by this bound\n-//~| NOTE required by a bound\n+    //~^ NOTE required by this bound\n+    //~| NOTE required by a bound\n     drop(t);\n }\n \n@@ -26,8 +29,8 @@ impl Drop for NotSend {\n impl !Send for NotSend {}\n \n async fn foo() {\n-//~^ NOTE used within this `async fn` body\n-//~| NOTE within this `impl Future\n+    //~^ NOTE used within this `async fn` body\n+    //~| NOTE within this `impl Future\n     let mut x = (NotSend {},);\n     drop(x.0);\n     x.0 = NotSend {};"}, {"sha": "719d1bd5a4c7dabf518cdb41e5718b511632d482", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,35 @@\n+// check-fail\n+// known-bug\n+\n+// This gives us problems because `for<'a> I::Item<'a>: Debug` should mean \"for\n+// all 'a where I::Item<'a> is WF\", but really means \"for all 'a possible\"\n+\n+use std::fmt::Debug;\n+\n+pub trait LendingIterator {\n+    type Item<'this>\n+    where\n+        Self: 'this;\n+}\n+\n+pub struct WindowsMut<'x> {\n+    slice: &'x (),\n+}\n+\n+impl<'y> LendingIterator for WindowsMut<'y> {\n+    type Item<'this> = &'this mut () where 'y: 'this;\n+}\n+\n+fn print_items<I>(_iter: I)\n+where\n+    I: LendingIterator,\n+    for<'a> I::Item<'a>: Debug,\n+{\n+}\n+\n+fn main() {\n+    let slice = &mut ();\n+    //~^ temporary value dropped while borrowed\n+    let windows = WindowsMut { slice };\n+    print_items::<WindowsMut<'_>>(windows);\n+}"}, {"sha": "414999881d4701cb5ab2a7e72b72e86ad1e7934a", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-1.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,20 @@\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/hrtb-implied-1.rs:31:22\n+   |\n+LL |     let slice = &mut ();\n+   |                      ^^ creates a temporary which is freed while still in use\n+...\n+LL |     print_items::<WindowsMut<'_>>(windows);\n+   |     -------------------------------------- argument requires that borrow lasts for `'static`\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/hrtb-implied-1.rs:26:26\n+   |\n+LL |     for<'a> I::Item<'a>: Debug,\n+   |                          ^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0716`."}, {"sha": "8e6c5348e71cab2194056bdb3d980a0ccc99fb8c", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-2.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,40 @@\n+// check-fail\n+// known-bug\n+\n+// This gives us problems because `for<'a> I::Item<'a>: Debug` should mean \"for\n+// all 'a where I::Item<'a> is WF\", but really means \"for all 'a possible\"\n+\n+trait LendingIterator: Sized {\n+    type Item<'a>\n+    where\n+        Self: 'a;\n+    fn next(&mut self) -> Self::Item<'_>;\n+}\n+fn fails<I: LendingIterator, F>(iter: &mut I, f: F) -> bool\n+where\n+    F: FnMut(I::Item<'_>),\n+{\n+    let mut iter2 = Eat(iter, f);\n+    let _next = iter2.next();\n+    //~^ borrowed data escapes\n+    true\n+}\n+impl<I: LendingIterator> LendingIterator for &mut I {\n+    type Item<'a> = I::Item<'a> where Self:'a;\n+    fn next(&mut self) -> Self::Item<'_> {\n+        (**self).next()\n+    }\n+}\n+\n+struct Eat<I, F>(I, F);\n+impl<I: LendingIterator, F> Iterator for Eat<I, F>\n+where\n+    F: FnMut(I::Item<'_>),\n+{\n+    type Item = ();\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1ee270398de4dcf16e1274793b6e4ffc610bcafc", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-2.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,22 @@\n+error[E0521]: borrowed data escapes outside of function\n+  --> $DIR/hrtb-implied-2.rs:18:17\n+   |\n+LL | fn fails<I: LendingIterator, F>(iter: &mut I, f: F) -> bool\n+   |                                 ----  - let's call the lifetime of this reference `'1`\n+   |                                 |\n+   |                                 `iter` is a reference that is only valid in the function body\n+...\n+LL |     let _next = iter2.next();\n+   |                 ^^^^^^^^^^^^\n+   |                 |\n+   |                 `iter` escapes the function body here\n+   |                 argument requires that `'1` must outlive `'static`\n+   |\n+   = note: requirement occurs because of a mutable reference to `Eat<&mut I, F>`\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n+   = note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0521`."}, {"sha": "bc9e6c8aea85e59d40bf00efc7dc86b20f7eda9e", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-3.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,23 @@\n+trait LendingIterator {\n+    type Item<'a>\n+    where\n+        Self: 'a;\n+}\n+\n+impl LendingIterator for &str {\n+    type Item<'a> = () where Self:'a;\n+}\n+\n+fn trivial_bound<I>(_: I)\n+where\n+    I: LendingIterator,\n+    for<'a> I::Item<'a>: Sized,\n+{\n+}\n+\n+fn fails(iter: &str) {\n+    trivial_bound(iter);\n+    //~^ borrowed data escapes\n+}\n+\n+fn main() {}"}, {"sha": "c67e02437cd8dcdbd5dce54305f40d2ae3ed8210", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-3.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,22 @@\n+error[E0521]: borrowed data escapes outside of function\n+  --> $DIR/hrtb-implied-3.rs:19:5\n+   |\n+LL | fn fails(iter: &str) {\n+   |          ----  - let's call the lifetime of this reference `'1`\n+   |          |\n+   |          `iter` is a reference that is only valid in the function body\n+LL |     trivial_bound(iter);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     `iter` escapes the function body here\n+   |     argument requires that `'1` must outlive `'static`\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/hrtb-implied-3.rs:14:26\n+   |\n+LL |     for<'a> I::Item<'a>: Sized,\n+   |                          ^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0521`."}, {"sha": "45b64d2b0248376fcbf0d65067ab7410be818f3e", "filename": "src/test/ui/generic-associated-types/trait-objects.extended.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Ftrait-objects.extended.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fgeneric-associated-types%2Ftrait-objects.extended.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Ftrait-objects.extended.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -11,6 +11,8 @@ LL |     x.size_hint().0\n    |     |\n    |     `x` escapes the function body here\n    |     argument requires that `'1` must outlive `'static`\n+   |\n+   = note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n \n error: aborting due to previous error\n "}, {"sha": "31e11e12835166a4aca0c219a9cfd58ecc0f3b0b", "filename": "src/test/ui/higher-rank-trait-bounds/hrtb-just-for-static.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-just-for-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-just-for-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-just-for-static.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -14,6 +14,12 @@ LL | fn give_some<'a>() {\n    |              -- lifetime `'a` defined here\n LL |     want_hrtb::<&'a u32>()\n    |     ^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/hrtb-just-for-static.rs:9:15\n+   |\n+LL |     where T : for<'a> Foo<&'a isize>\n+   |               ^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-just-for-static.rs:30:5"}, {"sha": "5e75a4cc8afa5021cb0da986e4d1c29990ce3e1c", "filename": "src/test/ui/higher-rank-trait-bounds/hrtb-perfect-forwarding.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-perfect-forwarding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-perfect-forwarding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-perfect-forwarding.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -46,6 +46,12 @@ LL | fn foo_hrtb_bar_not<'b, T>(mut t: T)\n ...\n LL |     foo_hrtb_bar_not(&mut t);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/hrtb-perfect-forwarding.rs:37:8\n+   |\n+LL |     T: for<'a> Foo<&'a isize> + Bar<&'b isize>,\n+   |        ^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of `Bar` is not general enough\n   --> $DIR/hrtb-perfect-forwarding.rs:43:5"}, {"sha": "73c772205c3dadb34e48d29c2bb9369afaf3d5a6", "filename": "src/test/ui/issues/issue-26217.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -5,6 +5,12 @@ LL | fn bar<'a>() {\n    |        -- lifetime `'a` defined here\n LL |     foo::<&'a i32>();\n    |     ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/issue-26217.rs:1:30\n+   |\n+LL | fn foo<T>() where for<'a> T: 'a {}\n+   |                              ^^\n \n error: aborting due to previous error\n "}, {"sha": "0157c8b7fe10c98a802f027311308a0ac6bde278", "filename": "src/test/ui/lint/must_not_suspend/ref.drop_tracking.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fref.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fref.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fref.drop_tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -0,0 +1,27 @@\n+error: reference to `Umm` held across a suspend point, but should not be\n+  --> $DIR/ref.rs:21:13\n+   |\n+LL |         let guard = &mut self.u;\n+   |             ^^^^^\n+LL |\n+LL |         other().await;\n+   |                ------ the value is held across this suspend point\n+   |\n+note: the lint level is defined here\n+  --> $DIR/ref.rs:6:9\n+   |\n+LL | #![deny(must_not_suspend)]\n+   |         ^^^^^^^^^^^^^^^^\n+note: You gotta use Umm's, ya know?\n+  --> $DIR/ref.rs:21:13\n+   |\n+LL |         let guard = &mut self.u;\n+   |             ^^^^^\n+help: consider using a block (`{ ... }`) to shrink the value's scope, ending before the suspend point\n+  --> $DIR/ref.rs:21:13\n+   |\n+LL |         let guard = &mut self.u;\n+   |             ^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "438e6489e31c41f5d4cb440b060bee0e2f76d25e", "filename": "src/test/ui/lint/must_not_suspend/ref.no_drop_tracking.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fref.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fref.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fref.no_drop_tracking.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,5 +1,5 @@\n error: `Umm` held across a suspend point, but should not be\n-  --> $DIR/ref.rs:18:26\n+  --> $DIR/ref.rs:21:26\n    |\n LL |         let guard = &mut self.u;\n    |                          ^^^^^^\n@@ -8,17 +8,17 @@ LL |         other().await;\n    |                ------ the value is held across this suspend point\n    |\n note: the lint level is defined here\n-  --> $DIR/ref.rs:3:9\n+  --> $DIR/ref.rs:6:9\n    |\n LL | #![deny(must_not_suspend)]\n    |         ^^^^^^^^^^^^^^^^\n note: You gotta use Umm's, ya know?\n-  --> $DIR/ref.rs:18:26\n+  --> $DIR/ref.rs:21:26\n    |\n LL |         let guard = &mut self.u;\n    |                          ^^^^^^\n help: consider using a block (`{ ... }`) to shrink the value's scope, ending before the suspend point\n-  --> $DIR/ref.rs:18:26\n+  --> $DIR/ref.rs:21:26\n    |\n LL |         let guard = &mut self.u;\n    |                          ^^^^^^", "previous_filename": "src/test/ui/lint/must_not_suspend/ref.stderr"}, {"sha": "f6b23746fef130f7f6c5afe68762ec24de3b4f39", "filename": "src/test/ui/lint/must_not_suspend/ref.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Fref.rs?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -1,10 +1,13 @@\n // edition:2018\n+// revisions: no_drop_tracking drop_tracking\n+// [drop_tracking] compile-flags: -Zdrop-tracking=yes\n+// [no_drop_tracking] compile-flags: -Zdrop-tracking=no\n #![feature(must_not_suspend)]\n #![deny(must_not_suspend)]\n \n #[must_not_suspend = \"You gotta use Umm's, ya know?\"]\n struct Umm {\n-    i: i64\n+    i: i64,\n }\n \n struct Bar {\n@@ -19,11 +22,8 @@ impl Bar {\n \n         other().await;\n \n-        *guard = Umm {\n-            i: 2\n-        }\n+        *guard = Umm { i: 2 }\n     }\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "f5c10f3ddea0ea0686342e06ab87b16a6b4d63fb", "filename": "src/test/ui/nll/local-outlives-static-via-hrtb.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -9,6 +9,12 @@ LL |     assert_static_via_hrtb(&local);\n LL |     assert_static_via_hrtb_with_assoc_type(&&local);\n LL | }\n    | - `local` dropped here while still borrowed\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/local-outlives-static-via-hrtb.rs:15:53\n+   |\n+LL | fn assert_static_via_hrtb<G>(_: G) where for<'a> G: Outlives<'a> {}\n+   |                                                     ^^^^^^^^^^^^\n \n error[E0597]: `local` does not live long enough\n   --> $DIR/local-outlives-static-via-hrtb.rs:25:45\n@@ -20,6 +26,12 @@ LL |     assert_static_via_hrtb_with_assoc_type(&&local);\n    |     argument requires that `local` is borrowed for `'static`\n LL | }\n    | - `local` dropped here while still borrowed\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/local-outlives-static-via-hrtb.rs:19:20\n+   |\n+LL |     for<'a> &'a T: Reference<AssociatedType = &'a ()>,\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "31e17d64b8caf4b41165d3da1e29aa3270bc3695", "filename": "src/test/ui/nll/type-test-universe.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a92669638461836f41f54f95e396f9082bb91391/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.stderr?ref=a92669638461836f41f54f95e396f9082bb91391", "patch": "@@ -11,6 +11,12 @@ LL | fn test2<'a>() {\n    |          -- lifetime `'a` defined here\n LL |     outlives_forall::<Value<'a>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/type-test-universe.rs:6:16\n+   |\n+LL |     for<'u> T: 'u,\n+   |                ^^\n \n error: aborting due to 2 previous errors\n "}]}