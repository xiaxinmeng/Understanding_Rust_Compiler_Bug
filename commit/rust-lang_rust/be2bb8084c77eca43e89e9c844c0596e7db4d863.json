{"sha": "be2bb8084c77eca43e89e9c844c0596e7db4d863", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMmJiODA4NGM3N2VjYTQzZTg5ZTljODQ0YzA1OTZlN2RiNGQ4NjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-22T22:43:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-22T23:05:42Z"}, "message": "thread info about `CrateLint` through more deeply", "tree": {"sha": "b8b6a7871f7ab78a989e3423a1e053c3885a91fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8b6a7871f7ab78a989e3423a1e053c3885a91fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be2bb8084c77eca43e89e9c844c0596e7db4d863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be2bb8084c77eca43e89e9c844c0596e7db4d863", "html_url": "https://github.com/rust-lang/rust/commit/be2bb8084c77eca43e89e9c844c0596e7db4d863", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be2bb8084c77eca43e89e9c844c0596e7db4d863/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9e8514ca076118267875a1a640551a7e2524801", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e8514ca076118267875a1a640551a7e2524801", "html_url": "https://github.com/rust-lang/rust/commit/e9e8514ca076118267875a1a640551a7e2524801"}], "stats": {"total": 78, "additions": 63, "deletions": 15}, "files": [{"sha": "acd3e159524ea3bb582cd980b973f63c290911d0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 63, "deletions": 15, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/be2bb8084c77eca43e89e9c844c0596e7db4d863/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2bb8084c77eca43e89e9c844c0596e7db4d863/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=be2bb8084c77eca43e89e9c844c0596e7db4d863", "patch": "@@ -2247,7 +2247,13 @@ impl<'a> Resolver<'a> {\n \n                 if items.len() == 0 {\n                     // Resolve prefix of an import with empty braces (issue #28388).\n-                    self.smart_resolve_path(id, None, &path, PathSource::ImportPrefix);\n+                    self.smart_resolve_path_with_crate_lint(\n+                        id,\n+                        None,\n+                        &path,\n+                        PathSource::ImportPrefix,\n+                        CrateLint::SimplePath(id), // TODO seems wrong\n+                    );\n                 } else {\n                     for &(ref tree, nested_id) in items {\n                         self.resolve_use_tree(nested_id, tree, &path);\n@@ -2354,7 +2360,8 @@ impl<'a> Resolver<'a> {\n                 None,\n                 &path,\n                 trait_ref.path.span,\n-                PathSource::Trait(AliasPossibility::No)\n+                PathSource::Trait(AliasPossibility::No),\n+                CrateLint::SimplePath(trait_ref.ref_id),\n             ).base_def();\n             if def != Def::Err {\n                 new_id = Some(def.def_id());\n@@ -2787,18 +2794,38 @@ impl<'a> Resolver<'a> {\n                           path: &Path,\n                           source: PathSource)\n                           -> PathResolution {\n+        self.smart_resolve_path_with_crate_lint(id, qself, path, source, CrateLint::SimplePath(id))\n+    }\n+\n+    /// A variant of `smart_resolve_path` where you also specify extra\n+    /// information about where the path came from; this extra info is\n+    /// sometimes needed for the lint that recommends rewriting\n+    /// absoluate paths to `crate`, so that it knows how to frame the\n+    /// suggestion. If you are just resolving a path like `foo::bar`\n+    /// that appears...somewhere, though, then you just want\n+    /// `CrateLint::SimplePath`, which is what `smart_resolve_path`\n+    /// already provides.\n+    fn smart_resolve_path_with_crate_lint(\n+        &mut self,\n+        id: NodeId,\n+        qself: Option<&QSelf>,\n+        path: &Path,\n+        source: PathSource,\n+        crate_lint: CrateLint\n+    ) -> PathResolution {\n         let segments = &path.segments.iter()\n             .map(|seg| seg.ident)\n             .collect::<Vec<_>>();\n-        self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n+        self.smart_resolve_path_fragment(id, qself, segments, path.span, source, crate_lint)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n                                    path: &[Ident],\n                                    span: Span,\n-                                   source: PathSource)\n+                                   source: PathSource,\n+                                   crate_lint: CrateLint)\n                                    -> PathResolution {\n         let ident_span = path.last().map_or(span, |ident| ident.span);\n         let ns = source.namespace();\n@@ -2999,9 +3026,16 @@ impl<'a> Resolver<'a> {\n             err_path_resolution()\n         };\n \n-        let resolution = match self.resolve_qpath_anywhere(id, qself, path, ns, span,\n-                                                           source.defer_to_typeck(),\n-                                                           source.global_by_default()) {\n+        let resolution = match self.resolve_qpath_anywhere(\n+            id,\n+            qself,\n+            path,\n+            ns,\n+            span,\n+            source.defer_to_typeck(),\n+            source.global_by_default(),\n+            crate_lint,\n+        ) {\n             Some(resolution) if resolution.unresolved_segments() == 0 => {\n                 if is_expected(resolution.base_def()) || resolution.base_def() == Def::Err {\n                     resolution\n@@ -3102,14 +3136,15 @@ impl<'a> Resolver<'a> {\n                               primary_ns: Namespace,\n                               span: Span,\n                               defer_to_typeck: bool,\n-                              global_by_default: bool)\n+                              global_by_default: bool,\n+                              crate_lint: CrateLint)\n                               -> Option<PathResolution> {\n         let mut fin_res = None;\n         // FIXME: can't resolve paths in macro namespace yet, macros are\n         // processed by the little special hack below.\n         for (i, ns) in [primary_ns, TypeNS, ValueNS, /*MacroNS*/].iter().cloned().enumerate() {\n             if i == 0 || ns != primary_ns {\n-                match self.resolve_qpath(id, qself, path, ns, span, global_by_default) {\n+                match self.resolve_qpath(id, qself, path, ns, span, global_by_default, crate_lint) {\n                     // If defer_to_typeck, then resolution > no resolution,\n                     // otherwise full resolution > partial resolution > no resolution.\n                     Some(res) if res.unresolved_segments() == 0 || defer_to_typeck =>\n@@ -3137,7 +3172,8 @@ impl<'a> Resolver<'a> {\n                      path: &[Ident],\n                      ns: Namespace,\n                      span: Span,\n-                     global_by_default: bool)\n+                     global_by_default: bool,\n+                     crate_lint: CrateLint)\n                      -> Option<PathResolution> {\n         debug!(\n             \"resolve_qpath(id={:?}, qself={:?}, path={:?}, \\\n@@ -3159,8 +3195,14 @@ impl<'a> Resolver<'a> {\n             }\n             // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n-            let res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n-                                                       span, PathSource::TraitItem(ns));\n+            let res = self.smart_resolve_path_fragment(\n+                id,\n+                None,\n+                &path[..qself.position + 1],\n+                span,\n+                PathSource::TraitItem(ns),\n+                crate_lint, // TODO wrong\n+            );\n             return Some(PathResolution::with_unresolved_segments(\n                 res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n             ));\n@@ -4113,8 +4155,14 @@ impl<'a> Resolver<'a> {\n                 let segments = path.make_root().iter().chain(path.segments.iter())\n                     .map(|seg| seg.ident)\n                     .collect::<Vec<_>>();\n-                let def = self.smart_resolve_path_fragment(id, None, &segments, path.span,\n-                                                           PathSource::Visibility).base_def();\n+                let def = self.smart_resolve_path_fragment(\n+                    id,\n+                    None,\n+                    &segments,\n+                    path.span,\n+                    PathSource::Visibility,\n+                    CrateLint::SimplePath(id),\n+                ).base_def();\n                 if def == Def::Err {\n                     ty::Visibility::Public\n                 } else {\n@@ -4474,7 +4522,7 @@ pub enum MakeGlobMap {\n     No,\n }\n \n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug)]\n enum CrateLint {\n     /// Do not issue the lint\n     No,"}]}