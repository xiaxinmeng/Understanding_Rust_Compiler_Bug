{"sha": "f4befa6712487141610b2a3618384a238b8a4409", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YmVmYTY3MTI0ODcxNDE2MTBiMmEzNjE4Mzg0YTIzOGI4YTQ0MDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-15T19:44:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-15T19:44:33Z"}, "message": "Auto merge of #30890 - nagisa:mir-tuple-adts, r=nikomatsakis\n\nThis PR changes translation of tuple-like ADTs from being calls to being proper aggregates. This change is done in hope to make code generation better. Namely, now we can avoid:\n\n1. Call overhead;\n2. Generating landingpads in presence of cleanups (we know for sure constructing ADTs can\u2019t panic);\n3. And probably much more, gaining better MIR introspectablilty.\n\nAlong with that a few serious deficiencies with translation of ADTs and switches have been fixed as well (commits 2 and 3).\n\nr? @nikomatsakis\ncc @tsion", "tree": {"sha": "cd7f9b7328b367f55cc928225bd83d54e66797fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd7f9b7328b367f55cc928225bd83d54e66797fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4befa6712487141610b2a3618384a238b8a4409", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4befa6712487141610b2a3618384a238b8a4409", "html_url": "https://github.com/rust-lang/rust/commit/f4befa6712487141610b2a3618384a238b8a4409", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4befa6712487141610b2a3618384a238b8a4409/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd51c3a7c1f69a2160da914d1f308916263b7044", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd51c3a7c1f69a2160da914d1f308916263b7044", "html_url": "https://github.com/rust-lang/rust/commit/dd51c3a7c1f69a2160da914d1f308916263b7044"}, {"sha": "7d6da8e4216544aa5dc33f7079789a69484e730c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d6da8e4216544aa5dc33f7079789a69484e730c", "html_url": "https://github.com/rust-lang/rust/commit/7d6da8e4216544aa5dc33f7079789a69484e730c"}], "stats": {"total": 174, "additions": 152, "deletions": 22}, "files": [{"sha": "8090fca66bb6247904341cb8f1de0cd3bb5e33a4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f4befa6712487141610b2a3618384a238b8a4409/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4befa6712487141610b2a3618384a238b8a4409/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=f4befa6712487141610b2a3618384a238b8a4409", "patch": "@@ -53,7 +53,6 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     // Find the actual method implementation being called and\n                     // build the appropriate UFCS call expression with the\n                     // callee-object as self parameter.\n-\n                     let method = method_callee(cx, self, ty::MethodCall::expr(self.id));\n                     let mut argrefs = vec![fun.to_ref()];\n                     argrefs.extend(args.iter().map(|a| a.to_ref()));\n@@ -64,12 +63,40 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                         args: argrefs,\n                     }\n                 } else {\n-                    ExprKind::Call {\n-                        ty: &cx.tcx.node_id_to_type(fun.id),\n-                        fun: fun.to_ref(),\n-                        args: args.to_ref(),\n+                    let adt_data = if let hir::ExprPath(..) = fun.node {\n+                        // Tuple-like ADTs are represented as ExprCall. We convert them here.\n+                        expr_ty.ty_adt_def().and_then(|adt_def|{\n+                            match cx.tcx.def_map.borrow()[&fun.id].full_def() {\n+                                def::DefVariant(_, variant_id, false) => {\n+                                    Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n+                                },\n+                                def::DefStruct(_) => {\n+                                    Some((adt_def, 0))\n+                                },\n+                                _ => None\n+                            }\n+                        })\n+                    } else { None };\n+                    if let Some((adt_def, index)) = adt_data {\n+                        let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(fun.id).substs);\n+                        let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n+                            name: Field::new(idx),\n+                            expr: e.to_ref()\n+                        }).collect();\n+                        ExprKind::Adt {\n+                            adt_def: adt_def,\n+                            substs: substs,\n+                            variant_index: index,\n+                            fields: field_refs,\n+                            base: None\n+                        }\n+                    } else {\n+                        ExprKind::Call {\n+                            ty: cx.tcx.node_id_to_type(fun.id),\n+                            fun: fun.to_ref(),\n+                            args: args.to_ref(),\n+                        }\n                     }\n-\n                 }\n             }\n \n@@ -549,10 +576,11 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n         def::DefFn(def_id, _) => (def_id, ItemKind::Function),\n         def::DefMethod(def_id) => (def_id, ItemKind::Method),\n         def::DefStruct(def_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A tuple-struct constructor.\n+            // A tuple-struct constructor. Should only be reached if not called in the same\n+            // expression.\n             ty::TyBareFn(..) => (def_id, ItemKind::Function),\n-            // This is a special case: a unit struct which is used as a value. We return a\n-            // completely different ExprKind here to account for this special case.\n+            // A unit struct which is used as a value. We return a completely different ExprKind\n+            // here to account for this special case.\n             ty::TyStruct(adt_def, substs) => return ExprKind::Adt {\n                 adt_def: adt_def,\n                 variant_index: 0,\n@@ -563,7 +591,8 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n             ref sty => panic!(\"unexpected sty: {:?}\", sty)\n         },\n         def::DefVariant(enum_id, variant_id, false) => match cx.tcx.node_id_to_type(expr.id).sty {\n-            // A variant constructor.\n+            // A variant constructor. Should only be reached if not called in the same\n+            // expression.\n             ty::TyBareFn(..) => (variant_id, ItemKind::Function),\n             // A unit variant, similar special case to the struct case above.\n             ty::TyEnum(adt_def, substs) => {\n@@ -900,6 +929,7 @@ fn loop_label<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> Cod\n     }\n }\n \n+/// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'tcx>(variant: VariantDef<'tcx>,\n                     fields: &'tcx [hir::Field])\n                     -> Vec<FieldExprRef<'tcx>>"}, {"sha": "ad5b0069a48d9b17ef578e9a1b996b439528c41e", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f4befa6712487141610b2a3618384a238b8a4409/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4befa6712487141610b2a3618384a238b8a4409/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=f4befa6712487141610b2a3618384a238b8a4409", "patch": "@@ -48,11 +48,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Terminator::Switch { ref discr, ref adt_def, ref targets } => {\n-                let adt_ty = bcx.tcx().lookup_item_type(adt_def.did).ty;\n-                let represented_ty = adt::represent_type(bcx.ccx(), adt_ty);\n-\n                 let discr_lvalue = self.trans_lvalue(bcx, discr);\n-                let discr = adt::trans_get_discr(bcx, &represented_ty, discr_lvalue.llval, None);\n+                let ty = discr_lvalue.ty.to_ty(bcx.tcx());\n+                let repr = adt::represent_type(bcx.ccx(), ty);\n+                let discr = adt::trans_get_discr(bcx, &repr, discr_lvalue.llval, None);\n \n                 // The else branch of the Switch can't be hit, so branch to an unreachable\n                 // instruction so LLVM knows that\n@@ -61,7 +60,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let switch = build::Switch(bcx, discr, unreachable_blk.llbb, targets.len());\n                 assert_eq!(adt_def.variants.len(), targets.len());\n                 for (adt_variant, target) in adt_def.variants.iter().zip(targets) {\n-                    let llval = adt::trans_case(bcx, &*represented_ty, adt_variant.disr_val);\n+                    let llval = adt::trans_case(bcx, &*repr, adt_variant.disr_val);\n                     let llbb = self.llblock(*target);\n \n                     build::AddCase(switch, llval, llbb)"}, {"sha": "7b9eac4317d24b06e88ab426801db348a18f436e", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4befa6712487141610b2a3618384a238b8a4409/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4befa6712487141610b2a3618384a238b8a4409/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=f4befa6712487141610b2a3618384a238b8a4409", "patch": "@@ -98,13 +98,19 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match *kind {\n-                    // Unit struct or variant; both are translated very differently compared to any\n-                    // other aggregate\n-                    mir::AggregateKind::Adt(adt_def, index, _)\n-                    if adt_def.variants[index].kind() == ty::VariantKind::Unit => {\n+                    mir::AggregateKind::Adt(adt_def, index, _) => {\n                         let repr = adt::represent_type(bcx.ccx(), dest.ty.to_ty(bcx.tcx()));\n                         let disr = adt_def.variants[index].disr_val;\n                         adt::trans_set_discr(bcx, &*repr, dest.llval, disr);\n+                        for (i, operand) in operands.iter().enumerate() {\n+                            let op = self.trans_operand(bcx, operand);\n+                            // Do not generate stores and GEPis for zero-sized fields.\n+                            if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n+                                let val = adt::MaybeSizedValue::sized(dest.llval);\n+                                let lldest_i = adt::trans_field_ptr(bcx, &*repr, val, disr, i);\n+                                self.store_operand(bcx, lldest_i, op);\n+                            }\n+                        }\n                     },\n                     _ => {\n                         for (i, operand) in operands.iter().enumerate() {"}, {"sha": "4526c40af84cf8d1fadb5847c0a26218a664ec4c", "filename": "src/test/run-pass/mir_adt_construction.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f4befa6712487141610b2a3618384a238b8a4409/src%2Ftest%2Frun-pass%2Fmir_adt_construction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4befa6712487141610b2a3618384a238b8a4409/src%2Ftest%2Frun-pass%2Fmir_adt_construction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_adt_construction.rs?ref=f4befa6712487141610b2a3618384a238b8a4409", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[repr(C, u32)]\n+enum CEnum {\n+    Hello = 30,\n+    World = 60\n+}\n+\n+#[rustc_mir]\n+fn test1(c: CEnum) -> i32 {\n+  let c2 = CEnum::Hello;\n+  match (c, c2) {\n+    (CEnum::Hello, CEnum::Hello) => 42,\n+    (CEnum::World, CEnum::Hello) => 0,\n+    _ => 1\n+  }\n+}\n+\n+#[repr(packed)]\n+#[derive(PartialEq, Debug)]\n+struct Pakd {\n+    a: u64,\n+    b: u32,\n+    c: u16,\n+    d: u8,\n+    e: ()\n+}\n+\n+impl Drop for Pakd {\n+    fn drop(&mut self) {}\n+}\n+\n+#[rustc_mir]\n+fn test2() -> Pakd {\n+    Pakd { a: 42, b: 42, c: 42, d: 42, e: () }\n+}\n+\n+#[derive(PartialEq, Debug)]\n+struct TupleLike(u64, u32);\n+\n+#[rustc_mir]\n+fn test3() -> TupleLike {\n+    TupleLike(42, 42)\n+}\n+\n+#[rustc_mir]\n+fn test4(x: fn(u64, u32) -> TupleLike) -> (TupleLike, TupleLike) {\n+    let y = TupleLike;\n+    (x(42, 84), y(42, 84))\n+}\n+\n+#[rustc_mir]\n+fn test5(x: fn(u32) -> Option<u32>) -> (Option<u32>, Option<u32>) {\n+    let y = Some;\n+    (x(42), y(42))\n+}\n+\n+fn main() {\n+  assert_eq!(test1(CEnum::Hello), 42);\n+  assert_eq!(test1(CEnum::World), 0);\n+  assert_eq!(test2(), Pakd { a: 42, b: 42, c: 42, d: 42, e: () });\n+  assert_eq!(test3(), TupleLike(42, 42));\n+  let t4 = test4(TupleLike);\n+  assert_eq!(t4.0, t4.1);\n+  let t5 = test5(Some);\n+  assert_eq!(t5.0, t5.1);\n+}"}, {"sha": "ad24e39d4f93fb05e43ebfacdbd4288c76b50b75", "filename": "src/test/run-pass/mir_build_match_comparisons.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f4befa6712487141610b2a3618384a238b8a4409/src%2Ftest%2Frun-pass%2Fmir_build_match_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4befa6712487141610b2a3618384a238b8a4409/src%2Ftest%2Frun-pass%2Fmir_build_match_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_build_match_comparisons.rs?ref=f4befa6712487141610b2a3618384a238b8a4409", "patch": "@@ -11,7 +11,7 @@\n #![feature(rustc_attrs)]\n \n #[rustc_mir]\n-pub fn test1(x: i8) -> i32 {\n+fn test1(x: i8) -> i32 {\n   match x {\n     1...10 => 0,\n     _ => 1,\n@@ -22,21 +22,36 @@ const U: Option<i8> = Some(10);\n const S: &'static str = \"hello\";\n \n #[rustc_mir]\n-pub fn test2(x: i8) -> i32 {\n+fn test2(x: i8) -> i32 {\n   match Some(x) {\n     U => 0,\n     _ => 1,\n   }\n }\n \n #[rustc_mir]\n-pub fn test3(x: &'static str) -> i32 {\n+fn test3(x: &'static str) -> i32 {\n   match x {\n     S => 0,\n     _ => 1,\n   }\n }\n \n+enum Opt<T> {\n+    Some { v: T },\n+    None\n+}\n+\n+#[rustc_mir]\n+fn test4(x: u64) -> i32 {\n+  let opt = Opt::Some{ v: x };\n+  match opt {\n+    Opt::Some { v: 10 } => 0,\n+    _ => 1,\n+  }\n+}\n+\n+\n fn main() {\n   assert_eq!(test1(0), 1);\n   assert_eq!(test1(1), 0);\n@@ -52,4 +67,7 @@ fn main() {\n   assert_eq!(test3(\"hello\"), 0);\n   assert_eq!(test3(\"\"), 1);\n   assert_eq!(test3(\"world\"), 1);\n+  assert_eq!(test4(10), 0);\n+  assert_eq!(test4(0), 1);\n+  assert_eq!(test4(20), 1);\n }"}]}