{"sha": "35ba9715fafe14c96081049327c808fd0c5a2792", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YmE5NzE1ZmFmZTE0Yzk2MDgxMDQ5MzI3YzgwOGZkMGM1YTI3OTI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-08T02:34:04Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-08T23:42:51Z"}, "message": "core: Add task::spawn_sched\n\nThis function creates a new scheduler with a specified number of threads and\nimmediately executes a task on it. The scheduler is configured to terminate\nwhen the task dies. This is the minimum API necessary to enable blocking C\ncalls.", "tree": {"sha": "dc35189d1d7ffaa1097646d3a82f115578167653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc35189d1d7ffaa1097646d3a82f115578167653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35ba9715fafe14c96081049327c808fd0c5a2792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35ba9715fafe14c96081049327c808fd0c5a2792", "html_url": "https://github.com/rust-lang/rust/commit/35ba9715fafe14c96081049327c808fd0c5a2792", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35ba9715fafe14c96081049327c808fd0c5a2792/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f4e7c157eb3ab9cd8270c3e9fffedd03f0cb055", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f4e7c157eb3ab9cd8270c3e9fffedd03f0cb055", "html_url": "https://github.com/rust-lang/rust/commit/2f4e7c157eb3ab9cd8270c3e9fffedd03f0cb055"}], "stats": {"total": 107, "additions": 100, "deletions": 7}, "files": [{"sha": "a62dafbadaf69e173114cf0f96e23fc4410c6a34", "filename": "src/libcore/task.rs", "status": "modified", "additions": 98, "deletions": 5, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/35ba9715fafe14c96081049327c808fd0c5a2792/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ba9715fafe14c96081049327c808fd0c5a2792/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=35ba9715fafe14c96081049327c808fd0c5a2792", "patch": "@@ -44,6 +44,7 @@ export get_task;\n export spawn;\n export spawn_joinable;\n export spawn_connected;\n+export spawn_sched;\n export connected_fn;\n export connected_task;\n export currently_unwinding;\n@@ -62,10 +63,15 @@ type rust_closure = {\n #[link_name = \"rustrt\"]\n #[abi = \"cdecl\"]\n native mod rustrt {\n+    fn rust_get_sched_id() -> sched_id;\n+    fn rust_new_sched(num_threads: c::uintptr_t) -> sched_id;\n+\n     fn get_task_id() -> task_id;\n     fn rust_get_task() -> *rust_task;\n \n     fn new_task() -> task_id;\n+    fn rust_new_task_in_sched(id: sched_id) -> task_id;\n+\n     fn drop_task(task_id: *rust_task);\n     fn get_task_pointer(id: task_id) -> *rust_task;\n \n@@ -85,6 +91,7 @@ type rust_task =\n \n resource rust_task_ptr(task: *rust_task) { rustrt::drop_task(task); }\n \n+type sched_id = int;\n type task_id = int;\n \n /*\n@@ -111,14 +118,17 @@ Returns:\n A handle to the new task\n */\n fn spawn(+f: fn~()) -> task {\n-    spawn_inner(f, none)\n+    spawn_inner(f, none, new_task_in_this_sched)\n }\n \n-fn spawn_inner(-f: fn~(),\n-            notify: option<comm::chan<task_notification>>) -> task unsafe {\n+fn spawn_inner(\n+    -f: fn~(),\n+    notify: option<comm::chan<task_notification>>,\n+    new_task: fn() -> task_id\n+) -> task unsafe {\n     let closure: *rust_closure = unsafe::reinterpret_cast(ptr::addr_of(f));\n     #debug(\"spawn: closure={%x,%x}\", (*closure).fnptr, (*closure).envptr);\n-    let id = rustrt::new_task();\n+    let id = new_task();\n \n     // set up notifications if they are enabled.\n     option::may(notify) {|c|\n@@ -132,6 +142,39 @@ fn spawn_inner(-f: fn~(),\n     ret id;\n }\n \n+fn new_task_in_this_sched() -> task_id {\n+    rustrt::new_task()\n+}\n+\n+fn new_task_in_new_sched(num_threads: uint) -> task_id {\n+    let sched_id = rustrt::rust_new_sched(num_threads);\n+    rustrt::rust_new_task_in_sched(sched_id)\n+}\n+\n+/*\n+Function: spawn_sched\n+\n+Creates a new scheduler and executes a task on it. Tasks subsequently\n+spawned by that task will also execute on the new scheduler. When\n+there are no more tasks to execute the scheduler terminates.\n+\n+Arguments:\n+\n+num_threads - The number of OS threads to dedicate schedule tasks on\n+f - A unique closure to execute as a task on the new scheduler\n+\n+Failure:\n+\n+The number of threads must be greater than 0\n+\n+*/\n+fn spawn_sched(num_threads: uint, +f: fn~()) -> task {\n+    if num_threads < 1u {\n+        fail \"Can not create a scheduler with no threads\";\n+    }\n+    spawn_inner(f, none, bind new_task_in_new_sched(num_threads))\n+}\n+\n /*\n Type: joinable_task\n \n@@ -142,7 +185,7 @@ type joinable_task = (task, comm::port<task_notification>);\n fn spawn_joinable(+f: fn~()) -> joinable_task {\n     let notify_port = comm::port();\n     let notify_chan = comm::chan(notify_port);\n-    let task = spawn_inner(f, some(notify_chan));\n+    let task = spawn_inner(f, some(notify_chan), new_task_in_this_sched);\n     ret (task, notify_port);\n     /*\n     resource notify_rsrc(data: (comm::chan<task_notification>,\n@@ -411,6 +454,56 @@ mod tests {\n             _ { fail; }\n         }\n     }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn spawn_sched_no_threads() {\n+        spawn_sched(0u) {|| };\n+    }\n+\n+    #[test]\n+    fn spawn_sched_1() {\n+        let po = comm::port();\n+        let ch = comm::chan(po);\n+\n+        fn f(i: int, ch: comm::chan<()>) {\n+            let parent_sched_id = rustrt::rust_get_sched_id();\n+\n+            spawn_sched(1u) {||\n+                let child_sched_id = rustrt::rust_get_sched_id();\n+                assert parent_sched_id != child_sched_id;\n+\n+                if (i == 0) {\n+                    comm::send(ch, ());\n+                } else {\n+                    f(i - 1, ch);\n+                }\n+            };\n+\n+        }\n+        f(10, ch);\n+        comm::recv(po);\n+    }\n+\n+    #[test]\n+    fn spawn_sched_childs_on_same_sched() {\n+        let po = comm::port();\n+        let ch = comm::chan(po);\n+\n+        spawn_sched(1u) {||\n+            let parent_sched_id = rustrt::rust_get_sched_id();\n+            spawn {||\n+                let child_sched_id = rustrt::rust_get_sched_id();\n+                // This should be on the same scheduler\n+                assert parent_sched_id == child_sched_id;\n+                comm::send(ch, ());\n+            };\n+        };\n+\n+        comm::recv(po);\n+    }\n+\n }\n \n "}, {"sha": "c228aa9159fcf590d0a4a6bef88918704361b6cb", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35ba9715fafe14c96081049327c808fd0c5a2792/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/35ba9715fafe14c96081049327c808fd0c5a2792/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=35ba9715fafe14c96081049327c808fd0c5a2792", "patch": "@@ -438,7 +438,7 @@ rust_get_sched_id() {\n }\n \n extern \"C\" CDECL rust_sched_id\n-rust_new_sched(size_t threads) {\n+rust_new_sched(uintptr_t threads) {\n     rust_task *task = rust_task_thread::get_task();\n     A(task->thread, threads > 0,\n       \"Can't create a scheduler with no threads, silly!\");"}, {"sha": "67cdf6d5c9e06ef433f255fcfb71dc03f8fff99e", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35ba9715fafe14c96081049327c808fd0c5a2792/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ba9715fafe14c96081049327c808fd0c5a2792/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=35ba9715fafe14c96081049327c808fd0c5a2792", "patch": "@@ -7,7 +7,7 @@ type task = *ctypes::void;\n type closure = *ctypes::void;\n \n native mod rustrt {\n-    fn rust_new_sched(num_threads: ctypes::size_t) -> sched_id;\n+    fn rust_new_sched(num_threads: uint) -> sched_id;\n     fn rust_get_sched_id() -> sched_id;\n     fn rust_new_task_in_sched(id: sched_id) -> task_id;\n     fn start_task(id: task_id, f: closure);"}]}