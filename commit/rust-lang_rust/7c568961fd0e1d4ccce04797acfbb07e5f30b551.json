{"sha": "7c568961fd0e1d4ccce04797acfbb07e5f30b551", "node_id": "C_kwDOAAsO6NoAKDdjNTY4OTYxZmQwZTFkNGNjY2UwNDc5N2FjZmJiMDdlNWYzMGI1NTE", "commit": {"author": {"name": "Tiddo Langerak", "email": "tiddolangerak@gmail.com", "date": "2022-08-09T06:41:56Z"}, "committer": {"name": "Tiddo Langerak", "email": "tiddolangerak@gmail.com", "date": "2022-08-10T10:07:02Z"}, "message": "Feat: extracted method from trait impl is placed in existing impl\n\nPreviously, when triggering a method extraction from within a trait\nimpl block, then this would always create a new impl block for\nthe struct, even if there already is one. Now, it'll put the extracted\nmethod in the matching existing block if it exists.", "tree": {"sha": "67494464e90aef7ec51bbe568422206c0ba8b4d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67494464e90aef7ec51bbe568422206c0ba8b4d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c568961fd0e1d4ccce04797acfbb07e5f30b551", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQHXBAABCgBBFiEEgTJEf2e6XVuOaUO2fnru5IfHUwAFAmLzg0cjHHRpZGRvbGFu\nZ2VyYWsrbGFwdG9wMjAyMkBnbWFpbC5jb20ACgkQfnru5IfHUwDWWAv8DSLE1ywB\n7q0x184mVe2E5/xsYI2jMhXeQRO90WhUvf/iQdX6L+l7AKP2MRphrUrEoYoX5OXZ\nFdWlR1el9o1+bcL4KacD3kXcjkE/yEz2U13gR6Mx8ihXhOUKiR3t/Dbawgl5UKi7\nRz8ZO4uZ52wf/ovJ1oaM3RK18NVAWuxAAqel1uRBd5LRaU5zECPc2VyQrIjoKC25\ntimMJ+CehIQWsgeXZsN+s89SUD+Oz1eyHAMEsWqYnwHWCKHMYDW0iH8FlbWcdGuX\n24C3Zlb542qL/TC/TrEc1sekXPamUlMo0jAAV+9s6GK5ZceufqKDKTu0xLimjZs3\n258u3lO+w6zV93RU3dknkX104czx0obVSzB5cTGBzfyXWqSePTZ1il5MiJ2r5e5w\ngObi+jocqMAiAHAqhmVj+e+hJMg3sxgOIhGaZQVT/2Qvvkgu5LwVgvgeWUGnM9Xa\noUGRwMefrviJQ88XyDPGUTCaDVNWQ9l0pvQApATWTIDt2EPYIjbwGPac\n=dA3n\n-----END PGP SIGNATURE-----", "payload": "tree 67494464e90aef7ec51bbe568422206c0ba8b4d8\nparent d186986af23cb42b19d4058ca67b5da9e73d2cb0\nauthor Tiddo Langerak <tiddolangerak@gmail.com> 1660027316 +0300\ncommitter Tiddo Langerak <tiddolangerak@gmail.com> 1660126022 +0300\n\nFeat: extracted method from trait impl is placed in existing impl\n\nPreviously, when triggering a method extraction from within a trait\nimpl block, then this would always create a new impl block for\nthe struct, even if there already is one. Now, it'll put the extracted\nmethod in the matching existing block if it exists.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c568961fd0e1d4ccce04797acfbb07e5f30b551", "html_url": "https://github.com/rust-lang/rust/commit/7c568961fd0e1d4ccce04797acfbb07e5f30b551", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c568961fd0e1d4ccce04797acfbb07e5f30b551/comments", "author": {"login": "TiddoLangerak", "id": 1759192, "node_id": "MDQ6VXNlcjE3NTkxOTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1759192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TiddoLangerak", "html_url": "https://github.com/TiddoLangerak", "followers_url": "https://api.github.com/users/TiddoLangerak/followers", "following_url": "https://api.github.com/users/TiddoLangerak/following{/other_user}", "gists_url": "https://api.github.com/users/TiddoLangerak/gists{/gist_id}", "starred_url": "https://api.github.com/users/TiddoLangerak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TiddoLangerak/subscriptions", "organizations_url": "https://api.github.com/users/TiddoLangerak/orgs", "repos_url": "https://api.github.com/users/TiddoLangerak/repos", "events_url": "https://api.github.com/users/TiddoLangerak/events{/privacy}", "received_events_url": "https://api.github.com/users/TiddoLangerak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TiddoLangerak", "id": 1759192, "node_id": "MDQ6VXNlcjE3NTkxOTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1759192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TiddoLangerak", "html_url": "https://github.com/TiddoLangerak", "followers_url": "https://api.github.com/users/TiddoLangerak/followers", "following_url": "https://api.github.com/users/TiddoLangerak/following{/other_user}", "gists_url": "https://api.github.com/users/TiddoLangerak/gists{/gist_id}", "starred_url": "https://api.github.com/users/TiddoLangerak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TiddoLangerak/subscriptions", "organizations_url": "https://api.github.com/users/TiddoLangerak/orgs", "repos_url": "https://api.github.com/users/TiddoLangerak/repos", "events_url": "https://api.github.com/users/TiddoLangerak/events{/privacy}", "received_events_url": "https://api.github.com/users/TiddoLangerak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d186986af23cb42b19d4058ca67b5da9e73d2cb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d186986af23cb42b19d4058ca67b5da9e73d2cb0", "html_url": "https://github.com/rust-lang/rust/commit/d186986af23cb42b19d4058ca67b5da9e73d2cb0"}], "stats": {"total": 272, "additions": 268, "deletions": 4}, "files": [{"sha": "40d0327ef71884bde29c91de0a2c0b906530e8e1", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 268, "deletions": 4, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/7c568961fd0e1d4ccce04797acfbb07e5f30b551/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c568961fd0e1d4ccce04797acfbb07e5f30b551/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=7c568961fd0e1d4ccce04797acfbb07e5f30b551", "patch": "@@ -109,8 +109,6 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n             let params =\n                 body.extracted_function_params(ctx, &container_info, locals_used.iter().copied());\n \n-            let extracted_from_trait_impl = body.extracted_from_trait_impl();\n-\n             let name = make_function_name(&semantics_scope);\n \n             let fun = Function {\n@@ -129,8 +127,13 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n \n             builder.replace(target_range, make_call(ctx, &fun, old_indent));\n \n+            let has_impl_wrapper = insert_after\n+                .ancestors()\n+                .find(|a| a.kind() == SyntaxKind::IMPL && a != &insert_after)\n+                .is_some();\n+\n             let fn_def = match fun.self_param_adt(ctx) {\n-                Some(adt) if extracted_from_trait_impl => {\n+                Some(adt) if anchor == Anchor::Method && !has_impl_wrapper => {\n                     let fn_def = format_function(ctx, module, &fun, old_indent, new_indent + 1);\n                     generate_impl_text(&adt, &fn_def).replace(\"{\\n\\n\", \"{\")\n                 }\n@@ -271,7 +274,7 @@ enum FunType {\n }\n \n /// Where to put extracted function definition\n-#[derive(Debug)]\n+#[derive(Debug, Eq, PartialEq, Clone, Copy)]\n enum Anchor {\n     /// Extract free function and put right after current top-level function\n     Freestanding,\n@@ -1244,6 +1247,15 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     while let Some(next_ancestor) = ancestors.next() {\n         match next_ancestor.kind() {\n             SyntaxKind::SOURCE_FILE => break,\n+            SyntaxKind::IMPL => {\n+                if body.extracted_from_trait_impl() && matches!(anchor, Anchor::Method) {\n+                    let impl_node = find_non_trait_impl(&next_ancestor);\n+                    let target_node = impl_node.as_ref().and_then(last_impl_member);\n+                    if target_node.is_some() {\n+                        return target_node;\n+                    }\n+                }\n+            }\n             SyntaxKind::ITEM_LIST if !matches!(anchor, Anchor::Freestanding) => continue,\n             SyntaxKind::ITEM_LIST => {\n                 if ancestors.peek().map(SyntaxNode::kind) == Some(SyntaxKind::MODULE) {\n@@ -1264,6 +1276,28 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     last_ancestor\n }\n \n+fn find_non_trait_impl(trait_impl: &SyntaxNode) -> Option<SyntaxNode> {\n+    let impl_type = Some(impl_type_name(trait_impl)?);\n+\n+    let mut sibblings = trait_impl.parent()?.children();\n+    sibblings.find(|s| impl_type_name(s) == impl_type && !is_trait_impl(s))\n+}\n+\n+fn last_impl_member(impl_node: &SyntaxNode) -> Option<SyntaxNode> {\n+    impl_node.children().find(|c| c.kind() == SyntaxKind::ASSOC_ITEM_LIST)?.last_child()\n+}\n+\n+fn is_trait_impl(node: &SyntaxNode) -> bool {\n+    match ast::Impl::cast(node.clone()) {\n+        Some(c) => c.trait_().is_some(),\n+        None => false,\n+    }\n+}\n+\n+fn impl_type_name(impl_node: &SyntaxNode) -> Option<String> {\n+    Some(ast::Impl::cast(impl_node.clone())?.self_ty()?.to_string())\n+}\n+\n fn make_call(ctx: &AssistContext<'_>, fun: &Function, indent: IndentLevel) -> String {\n     let ret_ty = fun.return_type(ctx);\n \n@@ -5058,6 +5092,236 @@ impl Struct {\n         );\n     }\n \n+    #[test]\n+    fn extract_method_from_trait_with_existing_non_empty_impl_block() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_function_from_trait_with_existing_non_empty_impl_block() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        let three_squared = $03 * 3$0;\n+        self.0 + three_squared\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl Struct {\n+    fn foo() {}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        let three_squared = fun_name();\n+        self.0 + three_squared\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    3 * 3\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_method_from_trait_with_multiple_existing_impl_blocks() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+struct StructBefore(i32);\n+struct StructAfter(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl StructBefore {\n+    fn foo(){}\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+}\n+\n+impl StructAfter {\n+    fn foo(){}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+struct StructBefore(i32);\n+struct StructAfter(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+\n+impl StructBefore {\n+    fn foo(){}\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl StructAfter {\n+    fn foo(){}\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_method_from_trait_with_multiple_existing_trait_impl_blocks() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+trait TraitBefore {\n+    fn before(&self) -> i32;\n+}\n+trait TraitAfter {\n+    fn after(&self) -> i32;\n+}\n+\n+impl TraitBefore for Struct {\n+    fn before(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+}\n+\n+impl TraitAfter for Struct {\n+    fn after(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        $0self.0 + 2$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct(i32);\n+trait Trait {\n+    fn bar(&self) -> i32;\n+}\n+trait TraitBefore {\n+    fn before(&self) -> i32;\n+}\n+trait TraitAfter {\n+    fn after(&self) -> i32;\n+}\n+\n+impl TraitBefore for Struct {\n+    fn before(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Struct {\n+    fn foo(){}\n+\n+    fn $0fun_name(&self) -> i32 {\n+        self.0 + 2\n+    }\n+}\n+\n+impl TraitAfter for Struct {\n+    fn after(&self) -> i32 {\n+        42\n+    }\n+}\n+\n+impl Trait for Struct {\n+    fn bar(&self) -> i32 {\n+        self.fun_name()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn closure_arguments() {\n         check_assist("}]}