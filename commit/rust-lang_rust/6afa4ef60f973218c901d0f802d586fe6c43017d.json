{"sha": "6afa4ef60f973218c901d0f802d586fe6c43017d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZmE0ZWY2MGY5NzMyMThjOTAxZDBmODAyZDU4NmZlNmM0MzAxN2Q=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-08-16T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-08-16T21:30:33Z"}, "message": "Introduce function for comparing expression values\n\nIntroduce `eq_expr_value(cx, a, b)` as a shortcut for\n`SpanlessEq::new(cx).ignore_fn().eq_expr(cx, a, b)`.\n\nNo functional changes intended.", "tree": {"sha": "52fae4ca8ee0e74ad075a8ec8bc7b659fc8fbc0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52fae4ca8ee0e74ad075a8ec8bc7b659fc8fbc0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6afa4ef60f973218c901d0f802d586fe6c43017d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6afa4ef60f973218c901d0f802d586fe6c43017d", "html_url": "https://github.com/rust-lang/rust/commit/6afa4ef60f973218c901d0f802d586fe6c43017d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6afa4ef60f973218c901d0f802d586fe6c43017d/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "html_url": "https://github.com/rust-lang/rust/commit/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7"}], "stats": {"total": 94, "additions": 45, "deletions": 49}, "files": [{"sha": "b3185b88840142253648eb1eb033dca657d20aa6", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method, SpanlessEq,\n+    eq_expr_value, get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method,\n };\n use crate::utils::{higher, sugg};\n use if_chain::if_chain;\n@@ -70,11 +70,11 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n                         return;\n                     }\n                     // lhs op= l op r\n-                    if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n+                    if eq_expr_value(cx, lhs, l) {\n                         lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n                     }\n                     // lhs op= l commutative_op r\n-                    if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n+                    if is_commutative(op.node) && eq_expr_value(cx, lhs, r) {\n                         lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n                     }\n                 }\n@@ -161,14 +161,12 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n \n                     if visitor.counter == 1 {\n                         // a = a op b\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, l) {\n+                        if eq_expr_value(cx, assignee, l) {\n                             lint(assignee, r);\n                         }\n                         // a = b commutative_op a\n                         // Limited to primitive type as these ops are know to be commutative\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r)\n-                            && cx.typeck_results().expr_ty(assignee).is_primitive_ty()\n-                        {\n+                        if eq_expr_value(cx, assignee, r) && cx.typeck_results().expr_ty(assignee).is_primitive_ty() {\n                             match op.node {\n                                 hir::BinOpKind::Add\n                                 | hir::BinOpKind::Mul\n@@ -253,7 +251,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if SpanlessEq::new(self.cx).ignore_fn().eq_expr(self.assignee, expr) {\n+        if eq_expr_value(self.cx, self.assignee, expr) {\n             self.counter += 1;\n         }\n "}, {"sha": "280a2c7fe6770c68987354a8c7bfc7f8c527ef02", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, in_macro, is_type_diagnostic_item, paths, snippet_opt, span_lint_and_sugg,\n-    span_lint_and_then, SpanlessEq,\n+    eq_expr_value, get_trait_def_id, implements_trait, in_macro, is_type_diagnostic_item, paths, snippet_opt,\n+    span_lint_and_sugg, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -128,7 +128,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n             }\n         }\n         for (n, expr) in self.terminals.iter().enumerate() {\n-            if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e, expr) {\n+            if eq_expr_value(self.cx, e, expr) {\n                 #[allow(clippy::cast_possible_truncation)]\n                 return Ok(Bool::Term(n as u8));\n             }\n@@ -138,8 +138,8 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 if implements_ord(self.cx, e_lhs);\n                 if let ExprKind::Binary(expr_binop, expr_lhs, expr_rhs) = &expr.kind;\n                 if negate(e_binop.node) == Some(expr_binop.node);\n-                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_lhs, expr_lhs);\n-                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_rhs, expr_rhs);\n+                if eq_expr_value(self.cx, e_lhs, expr_lhs);\n+                if eq_expr_value(self.cx, e_rhs, expr_rhs);\n                 then {\n                     #[allow(clippy::cast_possible_truncation)]\n                     return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));"}, {"sha": "10a64769585e543bdbfd46ae8cd59287080bfd5f", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -1,5 +1,5 @@\n+use crate::utils::{eq_expr_value, SpanlessEq, SpanlessHash};\n use crate::utils::{get_parent_expr, higher, if_sequence, snippet, span_lint_and_note, span_lint_and_then};\n-use crate::utils::{SpanlessEq, SpanlessHash};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{Arm, Block, Expr, ExprKind, MatchSource, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -197,8 +197,7 @@ fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n         h.finish()\n     };\n \n-    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool =\n-        &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) };\n+    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool { eq_expr_value(cx, lhs, rhs) };\n \n     for (i, j) in search_same(conds, hash, eq) {\n         span_lint_and_note(\n@@ -222,7 +221,7 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n \n     let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool {\n         // Do not spawn warning if `IFS_SAME_COND` already produced it.\n-        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) {\n+        if eq_expr_value(cx, lhs, rhs) {\n             return false;\n         }\n         SpanlessEq::new(cx).eq_expr(lhs, rhs)"}, {"sha": "19f56195ec1b483d693c8e20d6464ca4864c0fa9", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -6,7 +6,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+use crate::utils::{eq_expr_value, snippet_with_applicability, span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for double comparisons that could be simplified to a single expression.\n@@ -46,8 +46,7 @@ impl<'tcx> DoubleComparisons {\n             },\n             _ => return,\n         };\n-        let mut spanless_eq = SpanlessEq::new(cx).ignore_fn();\n-        if !(spanless_eq.eq_expr(&llhs, &rlhs) && spanless_eq.eq_expr(&lrhs, &rrhs)) {\n+        if !(eq_expr_value(cx, &llhs, &rlhs) && eq_expr_value(cx, &lrhs, &rrhs)) {\n             return;\n         }\n         macro_rules! lint_double_comparison {"}, {"sha": "e16ec783fab79c6c6744bcfaa958786ca7e912e5", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then, SpanlessEq,\n+    eq_expr_value, implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then,\n };\n use rustc_errors::Applicability;\n use rustc_hir::{BinOp, BinOpKind, BorrowKind, Expr, ExprKind};\n@@ -69,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n             if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n                 return;\n             }\n-            if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n+            if is_valid_operator(op) && eq_expr_value(cx, left, right) {\n                 span_lint(\n                     cx,\n                     EQ_OP,"}, {"sha": "1b02cee126d03b71af78ed69cba56e3cddbd9905", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -2,7 +2,7 @@ use crate::consts::{\n     constant, constant_simple, Constant,\n     Constant::{Int, F32, F64},\n };\n-use crate::utils::{get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg, SpanlessEq};\n+use crate::utils::{eq_expr_value, get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n@@ -363,8 +363,8 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lmul_lhs, ref lmul_rhs) = add_lhs.kind;\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref rmul_lhs, ref rmul_rhs) = add_rhs.kind;\n-            if are_exprs_equal(cx, lmul_lhs, lmul_rhs);\n-            if are_exprs_equal(cx, rmul_lhs, rmul_rhs);\n+            if eq_expr_value(cx, lmul_lhs, lmul_rhs);\n+            if eq_expr_value(cx, rmul_lhs, rmul_rhs);\n             then {\n                 return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &lmul_lhs, \"..\"), Sugg::hir(cx, &rmul_lhs, \"..\")));\n             }\n@@ -502,8 +502,8 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n fn is_testing_positive(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n     if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n         match op {\n-            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n-            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && eq_expr_value(cx, left, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, left) && eq_expr_value(cx, right, test),\n             _ => false,\n         }\n     } else {\n@@ -515,19 +515,15 @@ fn is_testing_positive(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -\n fn is_testing_negative(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n     if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n         match op {\n-            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n-            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && eq_expr_value(cx, right, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, right) && eq_expr_value(cx, left, test),\n             _ => false,\n         }\n     } else {\n         false\n     }\n }\n \n-fn are_exprs_equal(cx: &LateContext<'_>, expr1: &Expr<'_>, expr2: &Expr<'_>) -> bool {\n-    SpanlessEq::new(cx).ignore_fn().eq_expr(expr1, expr2)\n-}\n-\n /// Returns true iff expr is some zero literal\n fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match constant_simple(cx, cx.typeck_results(), expr) {\n@@ -546,12 +542,12 @@ fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n /// returns None.\n fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a>) -> Option<(bool, &'a Expr<'a>)> {\n     if let ExprKind::Unary(UnOp::UnNeg, expr1_negated) = &expr1.kind {\n-        if are_exprs_equal(cx, expr1_negated, expr2) {\n+        if eq_expr_value(cx, expr1_negated, expr2) {\n             return Some((false, expr2));\n         }\n     }\n     if let ExprKind::Unary(UnOp::UnNeg, expr2_negated) = &expr2.kind {\n-        if are_exprs_equal(cx, expr1, expr2_negated) {\n+        if eq_expr_value(cx, expr1, expr2_negated) {\n             return Some((true, expr1));\n         }\n     }\n@@ -614,7 +610,7 @@ fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>\n                 args_a.len() == args_b.len() &&\n                 (\n                     [\"ln\", \"log2\", \"log10\"].contains(&&*method_name_a.as_str()) ||\n-                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && are_exprs_equal(cx, &args_a[1], &args_b[1])\n+                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && eq_expr_value(cx, &args_a[1], &args_b[1])\n                 );\n         }\n     }"}, {"sha": "dbc676ae22408b139172a742361ca9ac7e511003", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -7,8 +7,8 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n-    span_lint_and_sugg, SpanlessEq,\n+    eq_expr_value, higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n+    span_lint_and_sugg,\n };\n \n declare_clippy_lint! {\n@@ -65,7 +65,7 @@ impl QuestionMark {\n                         if let ExprKind::Block(block, None) = &else_.kind;\n                         if block.stmts.is_empty();\n                         if let Some(block_expr) = &block.expr;\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(subject, block_expr);\n+                        if eq_expr_value(cx, subject, block_expr);\n                         then {\n                             replacement = Some(format!(\"Some({}?)\", receiver_str));\n                         }"}, {"sha": "cc39f060fc7f3929a69ed1860ca789a6dfbc6e54", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    differing_macro_contexts, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_then, walk_ptrs_ty,\n-    SpanlessEq,\n+    differing_macro_contexts, eq_expr_value, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_then,\n+    walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -92,8 +92,8 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if rhs2.segments.len() == 1;\n \n             if ident.as_str() == rhs2.segments[0].ident.as_str();\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1);\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2);\n+            if eq_expr_value(cx, tmp_init, lhs1);\n+            if eq_expr_value(cx, rhs1, lhs2);\n             then {\n                 if let ExprKind::Field(ref lhs1, _) = lhs1.kind {\n                     if let ExprKind::Field(ref lhs2, _) = lhs2.kind {\n@@ -193,7 +193,7 @@ enum Slice<'a> {\n fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n     if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n         if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n+            if eq_expr_value(cx, lhs1, lhs2) {\n                 let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(lhs1));\n \n                 if matches!(ty.kind, ty::Slice(_))\n@@ -221,8 +221,8 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if !differing_macro_contexts(first.span, second.span);\n             if let ExprKind::Assign(ref lhs0, ref rhs0, _) = first.kind;\n             if let ExprKind::Assign(ref lhs1, ref rhs1, _) = second.kind;\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1);\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0);\n+            if eq_expr_value(cx, lhs0, rhs1);\n+            if eq_expr_value(cx, lhs1, rhs0);\n             then {\n                 let lhs0 = Sugg::hir_opt(cx, lhs0);\n                 let rhs0 = Sugg::hir_opt(cx, rhs0);"}, {"sha": "785c409260ee99d13d7ef5cebda149014e81f2dd", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -340,6 +340,11 @@ pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n+/// Checks if two expressions evaluate to the same value, and don't contain any side effects.\n+pub fn eq_expr_value(cx: &LateContext<'_>, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+    SpanlessEq::new(cx).ignore_fn().eq_expr(left, right)\n+}\n+\n /// Type used to hash an ast element. This is different from the `Hash` trait\n /// on ast types as this\n /// trait would consider IDs and spans."}, {"sha": "0b8d0bd9e11181b632b80f2db7bf14a2f6199e96", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -1,7 +1,6 @@\n-use crate::utils::SpanlessEq;\n use crate::utils::{\n     is_expn_of, match_def_path, match_qpath, match_type, method_calls, paths, run_lints, snippet, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty,\n+    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, NodeId};"}, {"sha": "530552f79405c8acefd4a0bf945fbb89bf615feb", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afa4ef60f973218c901d0f802d586fe6c43017d/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=6afa4ef60f973218c901d0f802d586fe6c43017d", "patch": "@@ -21,7 +21,7 @@ pub mod sugg;\n pub mod usage;\n pub use self::attrs::*;\n pub use self::diagnostics::*;\n-pub use self::hir_utils::{both, over, SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n \n use std::borrow::Cow;\n use std::mem;"}]}