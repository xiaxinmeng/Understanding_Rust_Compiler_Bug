{"sha": "0e8e176b69d7f96da6c9832acf11ca9c95271815", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlOGUxNzZiNjlkN2Y5NmRhNmM5ODMyYWNmMTFjYTljOTUyNzE4MTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-07T17:19:41Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-14T12:40:42Z"}, "message": "TAIT: parse recursively instead of hack.", "tree": {"sha": "89e93ec3479a9cf1207f0dd5795556ba5c678d40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89e93ec3479a9cf1207f0dd5795556ba5c678d40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e8e176b69d7f96da6c9832acf11ca9c95271815", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8e176b69d7f96da6c9832acf11ca9c95271815", "html_url": "https://github.com/rust-lang/rust/commit/0e8e176b69d7f96da6c9832acf11ca9c95271815", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e8e176b69d7f96da6c9832acf11ca9c95271815/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d8e300e350a7b91c86a616477e40d678cb71f5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d8e300e350a7b91c86a616477e40d678cb71f5a", "html_url": "https://github.com/rust-lang/rust/commit/6d8e300e350a7b91c86a616477e40d678cb71f5a"}], "stats": {"total": 61, "additions": 13, "deletions": 48}, "files": [{"sha": "4b0f6a625f5de21012dfa16ff0efc27845db0fb3", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 13, "deletions": 48, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0e8e176b69d7f96da6c9832acf11ca9c95271815/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8e176b69d7f96da6c9832acf11ca9c95271815/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=0e8e176b69d7f96da6c9832acf11ca9c95271815", "patch": "@@ -7,7 +7,7 @@ use syntax::ast::{self, Abi, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyl\n use syntax::ast::{ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n-use syntax::ast::{Ty, TyKind, Generics, GenericBounds, TraitRef, EnumDef, VariantData, StructField};\n+use syntax::ast::{Ty, TyKind, Generics, TraitRef, EnumDef, VariantData, StructField};\n use syntax::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n use syntax::ptr::P;\n use syntax::ThinVec;\n@@ -21,15 +21,6 @@ use log::debug;\n use std::mem;\n use errors::{PResult, Applicability, DiagnosticBuilder, DiagnosticId, StashKey};\n \n-/// Whether the type alias or associated type is a concrete type or an opaque type.\n-#[derive(Debug)]\n-pub(super) enum AliasKind {\n-    /// Just a new name for the same type.\n-    Weak(P<Ty>),\n-    /// Only trait impls of the type will be usable, not the actual type itself.\n-    OpaqueTy(GenericBounds),\n-}\n-\n pub(super) type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute>>);\n \n impl<'a> Parser<'a> {\n@@ -266,15 +257,11 @@ impl<'a> Parser<'a> {\n             return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n \n-        if let Some(type_) = self.eat_type() {\n-            let (ident, alias, generics) = type_?;\n+        if self.eat_keyword(kw::Type) {\n             // TYPE ITEM\n-            let item_ = match alias {\n-                AliasKind::Weak(ty) => ItemKind::TyAlias(ty, generics),\n-                AliasKind::OpaqueTy(bounds) => ItemKind::OpaqueTy(bounds, generics),\n-            };\n-            let span = lo.to(self.prev_span);\n-            return Ok(Some(self.mk_item(span, ident, item_, vis, attrs)));\n+            let (ident, ty, generics) = self.parse_type_alias()?;\n+            let kind = ItemKind::TyAlias(ty, generics);\n+            return self.mk_item_with_info(attrs, lo, vis, (ident, kind, None));\n         }\n \n         if self.eat_keyword(kw::Enum) {\n@@ -708,13 +695,9 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(false)?;\n         let defaultness = self.parse_defaultness();\n-        let (name, kind, generics) = if let Some(type_) = self.eat_type() {\n-            let (name, alias, generics) = type_?;\n-            let kind = match alias {\n-                AliasKind::Weak(typ) => ast::ImplItemKind::TyAlias(typ),\n-                AliasKind::OpaqueTy(bounds) => ast::ImplItemKind::OpaqueTy(bounds),\n-            };\n-            (name, kind, generics)\n+        let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n+            let (name, ty, generics) = self.parse_type_alias()?;\n+            (name, ast::ImplItemKind::TyAlias(ty), generics)\n         } else if self.is_const_item() {\n             self.parse_impl_const()?\n         } else if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(&vis), at_end)? {\n@@ -1318,34 +1301,16 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Parses `type Foo = Bar;` or returns `None`\n-    /// without modifying the parser state.\n-    fn eat_type(&mut self) -> Option<PResult<'a, (Ident, AliasKind, Generics)>> {\n-        // This parses the grammar:\n-        //     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n-        if self.eat_keyword(kw::Type) {\n-            Some(self.parse_type_alias())\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Parses a type alias or opaque type.\n-    fn parse_type_alias(&mut self) -> PResult<'a, (Ident, AliasKind, Generics)> {\n+    /// Parses the grammar:\n+    ///     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n+    fn parse_type_alias(&mut self) -> PResult<'a, (Ident, P<Ty>, Generics)> {\n         let ident = self.parse_ident()?;\n         let mut tps = self.parse_generics()?;\n         tps.where_clause = self.parse_where_clause()?;\n         self.expect(&token::Eq)?;\n-        let alias = if self.check_keyword(kw::Impl) {\n-            self.bump();\n-            let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n-            AliasKind::OpaqueTy(bounds)\n-        } else {\n-            let ty = self.parse_ty()?;\n-            AliasKind::Weak(ty)\n-        };\n+        let ty = self.parse_ty()?;\n         self.expect_semi()?;\n-        Ok((ident, alias, tps))\n+        Ok((ident, ty, tps))\n     }\n \n     /// Parses an enum declaration."}]}