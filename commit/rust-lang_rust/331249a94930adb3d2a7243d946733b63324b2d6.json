{"sha": "331249a94930adb3d2a7243d946733b63324b2d6", "node_id": "C_kwDOAAsO6NoAKDMzMTI0OWE5NDkzMGFkYjNkMmE3MjQzZDk0NjczM2I2MzMyNGIyZDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-15T16:05:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-15T16:05:33Z"}, "message": "Auto merge of #112661 - matthiaskrgr:rollup-9u5i2zy, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #111212 (Add casting suggestion when assigning negative 2's complement bin or hex literal to a size compatible signed integer)\n - #112304 (Add chapter in rustdoc book for re-exports and add a regression test for `#[doc(hidden)]` behaviour)\n - #112486 (Fix suggestion for E0404 not dealing with multiple generics)\n - #112562 (rustdoc-gui: allow running on Windows)\n - #112621 (Mention `env!` in `option_env!`'s docs)\n - #112634 (add InlineConst check)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e6626108410a63816f8cb94eed1ba481a2361514", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6626108410a63816f8cb94eed1ba481a2361514"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/331249a94930adb3d2a7243d946733b63324b2d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/331249a94930adb3d2a7243d946733b63324b2d6", "html_url": "https://github.com/rust-lang/rust/commit/331249a94930adb3d2a7243d946733b63324b2d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/331249a94930adb3d2a7243d946733b63324b2d6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9097f87c9c094f80826fb60a1a624b5f9f1ed82", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9097f87c9c094f80826fb60a1a624b5f9f1ed82", "html_url": "https://github.com/rust-lang/rust/commit/f9097f87c9c094f80826fb60a1a624b5f9f1ed82"}, {"sha": "c0a089e118d86f150009db3bcfd8ef7f2775b361", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a089e118d86f150009db3bcfd8ef7f2775b361", "html_url": "https://github.com/rust-lang/rust/commit/c0a089e118d86f150009db3bcfd8ef7f2775b361"}], "stats": {"total": 678, "additions": 629, "deletions": 49}, "files": [{"sha": "83b7e13905aee7d7e8c01b0285a777bc9c782895", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -32,6 +32,10 @@ pub fn bounds_to_string(bounds: &[ast::GenericBound]) -> String {\n     State::new().bounds_to_string(bounds)\n }\n \n+pub fn where_bound_predicate_to_string(where_bound_predicate: &ast::WhereBoundPredicate) -> String {\n+    State::new().where_bound_predicate_to_string(where_bound_predicate)\n+}\n+\n pub fn pat_to_string(pat: &ast::Pat) -> String {\n     State::new().pat_to_string(pat)\n }"}, {"sha": "59239b49eddd81414a3747dd3c379e18f04479ac", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -824,6 +824,13 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         Self::to_string(|s| s.print_type_bounds(bounds))\n     }\n \n+    fn where_bound_predicate_to_string(\n+        &self,\n+        where_bound_predicate: &ast::WhereBoundPredicate,\n+    ) -> String {\n+        Self::to_string(|s| s.print_where_bound_predicate(where_bound_predicate))\n+    }\n+\n     fn pat_to_string(&self, pat: &ast::Pat) -> String {\n         Self::to_string(|s| s.print_pat(pat))\n     }"}, {"sha": "5c01b7ea70a13419ffecebbd2e325c0fc79c65af", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -623,19 +623,8 @@ impl<'a> State<'a> {\n \n     pub fn print_where_predicate(&mut self, predicate: &ast::WherePredicate) {\n         match predicate {\n-            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                bound_generic_params,\n-                bounded_ty,\n-                bounds,\n-                ..\n-            }) => {\n-                self.print_formal_generic_params(bound_generic_params);\n-                self.print_type(bounded_ty);\n-                self.word(\":\");\n-                if !bounds.is_empty() {\n-                    self.nbsp();\n-                    self.print_type_bounds(bounds);\n-                }\n+            ast::WherePredicate::BoundPredicate(where_bound_predicate) => {\n+                self.print_where_bound_predicate(where_bound_predicate);\n             }\n             ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n                 lifetime,\n@@ -658,6 +647,19 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    pub fn print_where_bound_predicate(\n+        &mut self,\n+        where_bound_predicate: &ast::WhereBoundPredicate,\n+    ) {\n+        self.print_formal_generic_params(&where_bound_predicate.bound_generic_params);\n+        self.print_type(&where_bound_predicate.bounded_ty);\n+        self.word(\":\");\n+        if !where_bound_predicate.bounds.is_empty() {\n+            self.nbsp();\n+            self.print_type_bounds(&where_bound_predicate.bounds);\n+        }\n+    }\n+\n     fn print_use_tree(&mut self, tree: &ast::UseTree) {\n         match &tree.kind {\n             ast::UseTreeKind::Simple(rename) => {"}, {"sha": "c66fcdec7164c83839db0c7c166ff0ed838365ee", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -425,6 +425,7 @@ lint_overflowing_bin_hex = literal out of range for `{$ty}`\n     .negative_becomes_note = and the value `-{$lit}` will become `{$actually}{$ty}`\n     .positive_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}` and will become `{$actually}{$ty}`\n     .suggestion = consider using the type `{$suggestion_ty}` instead\n+    .sign_bit_suggestion = to use as a negative number (decimal `{$negative_val}`), consider using the type `{$uint_ty}` for the literal and cast it to `{$int_ty}`\n     .help = consider using the type `{$suggestion_ty}` instead\n \n lint_overflowing_int = literal out of range for `{$ty}`"}, {"sha": "89fa5713b73ef23c4f53aa1e5e4e3eeacbb9c460", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -1342,6 +1342,8 @@ pub struct OverflowingBinHex<'a> {\n     pub sign: OverflowingBinHexSign,\n     #[subdiagnostic]\n     pub sub: Option<OverflowingBinHexSub<'a>>,\n+    #[subdiagnostic]\n+    pub sign_bit_sub: Option<OverflowingBinHexSignBitSub<'a>>,\n }\n \n pub enum OverflowingBinHexSign {\n@@ -1386,6 +1388,21 @@ pub enum OverflowingBinHexSub<'a> {\n     Help { suggestion_ty: &'a str },\n }\n \n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    lint_sign_bit_suggestion,\n+    code = \"{lit_no_suffix}{uint_ty} as {int_ty}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct OverflowingBinHexSignBitSub<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub lit_no_suffix: &'a str,\n+    pub negative_val: String,\n+    pub uint_ty: &'a str,\n+    pub int_ty: &'a str,\n+}\n+\n #[derive(LintDiagnostic)]\n #[diag(lint_overflowing_int)]\n #[note]"}, {"sha": "ec9e7c7fdae83a1297cdc2e764fbd4c43d553491", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -3,9 +3,10 @@ use crate::{\n     lints::{\n         AtomicOrderingFence, AtomicOrderingLoad, AtomicOrderingStore, ImproperCTypes,\n         InvalidAtomicOrderingDiag, InvalidNanComparisons, InvalidNanComparisonsSuggestion,\n-        OnlyCastu8ToChar, OverflowingBinHex, OverflowingBinHexSign, OverflowingBinHexSub,\n-        OverflowingInt, OverflowingIntHelp, OverflowingLiteral, OverflowingUInt,\n-        RangeEndpointOutOfRange, UnusedComparisons, UseInclusiveRange, VariantSizeDifferencesDiag,\n+        OnlyCastu8ToChar, OverflowingBinHex, OverflowingBinHexSign, OverflowingBinHexSignBitSub,\n+        OverflowingBinHexSub, OverflowingInt, OverflowingIntHelp, OverflowingLiteral,\n+        OverflowingUInt, RangeEndpointOutOfRange, UnusedComparisons, UseInclusiveRange,\n+        VariantSizeDifferencesDiag,\n     },\n };\n use crate::{LateContext, LateLintPass, LintContext};\n@@ -297,10 +298,50 @@ fn report_bin_hex_error(\n             }\n         },\n     );\n+    let sign_bit_sub = (!negative)\n+        .then(|| {\n+            let ty::Int(int_ty) = cx.typeck_results().node_type(expr.hir_id).kind() else {\n+                return None;\n+            };\n+\n+            let Some(bit_width) = int_ty.bit_width() else {\n+                return None; // isize case\n+            };\n+\n+            // Skip if sign bit is not set\n+            if (val & (1 << (bit_width - 1))) == 0 {\n+                return None;\n+            }\n+\n+            let lit_no_suffix =\n+                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+                    repr_str.split_at(pos).0\n+                } else {\n+                    &repr_str\n+                };\n+\n+            Some(OverflowingBinHexSignBitSub {\n+                span: expr.span,\n+                lit_no_suffix,\n+                negative_val: actually.clone(),\n+                int_ty: int_ty.name_str(),\n+                uint_ty: int_ty.to_unsigned().name_str(),\n+            })\n+        })\n+        .flatten();\n+\n     cx.emit_spanned_lint(\n         OVERFLOWING_LITERALS,\n         expr.span,\n-        OverflowingBinHex { ty: t, lit: repr_str.clone(), dec: val, actually, sign, sub },\n+        OverflowingBinHex {\n+            ty: t,\n+            lit: repr_str.clone(),\n+            dec: val,\n+            actually,\n+            sign,\n+            sub,\n+            sign_bit_sub,\n+        },\n     )\n }\n "}, {"sha": "ae32a54be3ded66876bcb9ffc507de84326fe8c1", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -95,7 +95,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                     // used generic parameters is a bug of evaluation, so checking for it\n                     // here does feel somewhat sensible.\n                     if !self.features().generic_const_exprs && ct.substs.has_non_region_param() {\n-                        assert!(matches!(self.def_kind(ct.def), DefKind::AnonConst));\n+                        assert!(matches!(\n+                            self.def_kind(ct.def),\n+                            DefKind::InlineConst | DefKind::AnonConst\n+                        ));\n                         let mir_body = self.mir_for_ctfe(ct.def);\n                         if mir_body.is_polymorphic {\n                             let Some(local_def_id) = ct.def.as_local() else { return };"}, {"sha": "7284b33f09d8e57d21a7b7fb13dbc68a24dfffa5", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 69, "deletions": 23, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -10,7 +10,7 @@ use rustc_ast::{\n     self as ast, AssocItemKind, Expr, ExprKind, GenericParam, GenericParamKind, Item, ItemKind,\n     MethodCall, NodeId, Path, Ty, TyKind, DUMMY_NODE_ID,\n };\n-use rustc_ast_pretty::pprust::path_segment_to_string;\n+use rustc_ast_pretty::pprust::where_bound_predicate_to_string;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n@@ -1050,7 +1050,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             };\n \n         // Confirm that the target is an associated type.\n-        let (ty, position, path) = if let ast::TyKind::Path(Some(qself), path) = &bounded_ty.kind {\n+        let (ty, _, path) = if let ast::TyKind::Path(Some(qself), path) = &bounded_ty.kind {\n             // use this to verify that ident is a type param.\n             let Some(partial_res) = self.r.partial_res_map.get(&bounded_ty.id) else {\n                 return false;\n@@ -1079,37 +1079,19 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 return false;\n             }\n             if let (\n-                [ast::PathSegment { ident: constrain_ident, args: None, .. }],\n+                [ast::PathSegment { args: None, .. }],\n                 [ast::GenericBound::Trait(poly_trait_ref, ast::TraitBoundModifier::None)],\n             ) = (&type_param_path.segments[..], &bounds[..])\n             {\n                 if let [ast::PathSegment { ident, args: None, .. }] =\n                     &poly_trait_ref.trait_ref.path.segments[..]\n                 {\n                     if ident.span == span {\n+                        let Some(new_where_bound_predicate) = mk_where_bound_predicate(path, poly_trait_ref, ty) else { return false; };\n                         err.span_suggestion_verbose(\n                             *where_span,\n                             format!(\"constrain the associated type to `{}`\", ident),\n-                            format!(\n-                                \"{}: {}<{} = {}>\",\n-                                self.r\n-                                    .tcx\n-                                    .sess\n-                                    .source_map()\n-                                    .span_to_snippet(ty.span) // Account for `<&'a T as Foo>::Bar`.\n-                                    .unwrap_or_else(|_| constrain_ident.to_string()),\n-                                path.segments[..position]\n-                                    .iter()\n-                                    .map(|segment| path_segment_to_string(segment))\n-                                    .collect::<Vec<_>>()\n-                                    .join(\"::\"),\n-                                path.segments[position..]\n-                                    .iter()\n-                                    .map(|segment| path_segment_to_string(segment))\n-                                    .collect::<Vec<_>>()\n-                                    .join(\"::\"),\n-                                ident,\n-                            ),\n+                            where_bound_predicate_to_string(&new_where_bound_predicate),\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n@@ -2605,6 +2587,70 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n     }\n }\n \n+fn mk_where_bound_predicate(\n+    path: &Path,\n+    poly_trait_ref: &ast::PolyTraitRef,\n+    ty: &ast::Ty,\n+) -> Option<ast::WhereBoundPredicate> {\n+    use rustc_span::DUMMY_SP;\n+    let modified_segments = {\n+        let mut segments = path.segments.clone();\n+        let [preceding @ .., second_last, last] = segments.as_mut_slice() else { return None; };\n+        let mut segments = ThinVec::from(preceding);\n+\n+        let added_constraint = ast::AngleBracketedArg::Constraint(ast::AssocConstraint {\n+            id: DUMMY_NODE_ID,\n+            ident: last.ident,\n+            gen_args: None,\n+            kind: ast::AssocConstraintKind::Equality {\n+                term: ast::Term::Ty(ast::ptr::P(ast::Ty {\n+                    kind: ast::TyKind::Path(None, poly_trait_ref.trait_ref.path.clone()),\n+                    id: DUMMY_NODE_ID,\n+                    span: DUMMY_SP,\n+                    tokens: None,\n+                })),\n+            },\n+            span: DUMMY_SP,\n+        });\n+\n+        match second_last.args.as_deref_mut() {\n+            Some(ast::GenericArgs::AngleBracketed(ast::AngleBracketedArgs { args, .. })) => {\n+                args.push(added_constraint);\n+            }\n+            Some(_) => return None,\n+            None => {\n+                second_last.args =\n+                    Some(ast::ptr::P(ast::GenericArgs::AngleBracketed(ast::AngleBracketedArgs {\n+                        args: ThinVec::from([added_constraint]),\n+                        span: DUMMY_SP,\n+                    })));\n+            }\n+        }\n+\n+        segments.push(second_last.clone());\n+        segments\n+    };\n+\n+    let new_where_bound_predicate = ast::WhereBoundPredicate {\n+        span: DUMMY_SP,\n+        bound_generic_params: ThinVec::new(),\n+        bounded_ty: ast::ptr::P(ty.clone()),\n+        bounds: vec![ast::GenericBound::Trait(\n+            ast::PolyTraitRef {\n+                bound_generic_params: ThinVec::new(),\n+                trait_ref: ast::TraitRef {\n+                    path: ast::Path { segments: modified_segments, span: DUMMY_SP, tokens: None },\n+                    ref_id: DUMMY_NODE_ID,\n+                },\n+                span: DUMMY_SP,\n+            },\n+            ast::TraitBoundModifier::None,\n+        )],\n+    };\n+\n+    Some(new_where_bound_predicate)\n+}\n+\n /// Report lifetime/lifetime shadowing as an error.\n pub(super) fn signal_lifetime_shadowing(sess: &Session, orig: Ident, shadower: Ident) {\n     let mut err = struct_span_err!("}, {"sha": "0c65b25fe1389827d0034c90d39b31852a234a23", "filename": "config.example.toml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/config.example.toml", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/config.example.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.example.toml?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -250,6 +250,13 @@ changelog-seen = 2\n # target when running tests, otherwise this can be omitted.\n #nodejs = \"node\"\n \n+# The npm executable to use. Note that this is used for rustdoc-gui tests,\n+# otherwise this can be omitted.\n+#\n+# Under Windows this should be `npm.cmd` or path to it (verified on nodejs v18.06), or\n+# error will be emitted.\n+#npm = \"npm\"\n+\n # Python interpreter to use for various tasks throughout the build, notably\n # rustdoc tests, the lldb python interpreter, and some dist bits and pieces.\n #"}, {"sha": "45e5b76272e1d40321fd0de95f5f522b861e937f", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -960,6 +960,8 @@ pub(crate) mod builtin {\n     ///\n     /// A compile time error is never emitted when using this macro regardless\n     /// of whether the environment variable is present or not.\n+    /// To emit a compile error if the environment variable is not present,\n+    /// use the [`env!`] macro instead.\n     ///\n     /// # Examples\n     ///"}, {"sha": "12a8b2b8db4b6d24ad2c2f59a3d628615a99e47f", "filename": "src/doc/rustdoc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -7,6 +7,7 @@\n - [How to write documentation](how-to-write-documentation.md)\n     - [What to include (and exclude)](write-documentation/what-to-include.md)\n     - [The `#[doc]` attribute](write-documentation/the-doc-attribute.md)\n+    - [Re-exports](write-documentation/re-exports.md)\n     - [Linking to items by name](write-documentation/linking-to-items-by-name.md)\n     - [Documentation tests](write-documentation/documentation-tests.md)\n - [Rustdoc-specific lints](lints.md)"}, {"sha": "593428b8a70a5920479d56255a8a5e8e05ccb035", "filename": "src/doc/rustdoc/src/write-documentation/re-exports.md", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fre-exports.md", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fre-exports.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fre-exports.md?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -0,0 +1,172 @@\n+# Re-exports\n+\n+Let's start by explaining what are re-exports. To do so, we will use an example where we are\n+writing a library (named `lib`) with some types dispatched in sub-modules:\n+\n+```rust\n+pub mod sub_module1 {\n+    pub struct Foo;\n+}\n+pub mod sub_module2 {\n+    pub struct AnotherFoo;\n+}\n+```\n+\n+Users can import them like this:\n+\n+```rust,ignore (inline)\n+use lib::sub_module1::Foo;\n+use lib::sub_module2::AnotherFoo;\n+```\n+\n+But what if you want the types to be available directly at the crate root or if we don't want the\n+modules to be visible for users? That's where re-exports come in:\n+\n+```rust,ignore (inline)\n+// `sub_module1` and `sub_module2` are not visible outside.\n+mod sub_module1 {\n+    pub struct Foo;\n+}\n+mod sub_module2 {\n+    pub struct AnotherFoo;\n+}\n+// We re-export both types:\n+pub use crate::sub_module1::Foo;\n+pub use crate::sub_module2::AnotherFoo;\n+```\n+\n+And now users will be able to do:\n+\n+```rust,ignore (inline)\n+use lib::{Foo, AnotherFoo};\n+```\n+\n+And since both `sub_module1` and `sub_module2` are private, users won't be able to import them.\n+\n+Now what's interesting is that the generated documentation for this crate will show both `Foo` and\n+`AnotherFoo` directly at the crate root, meaning they have been inlined. There are a few rules to\n+know whether or not a re-exported item will be inlined.\n+\n+## Inlining rules\n+\n+If a public item comes from a private module, it will be inlined:\n+\n+```rust,ignore (inline)\n+mod private_module {\n+    pub struct Public;\n+}\n+pub mod public_mod {\n+    // `Public` will inlined here since `private_module` is private.\n+    pub use super::private_module::Public;\n+}\n+// `Public` will not be inlined here since `public_mod` is public.\n+pub use self::public_mod::Public;\n+```\n+\n+Likewise, if an item inherits `#[doc(hidden)]` from any of its ancestors, it will be inlined:\n+\n+```rust,ignore (inline)\n+#[doc(hidden)]\n+pub mod public_mod {\n+    pub struct Public;\n+}\n+// `Public` be inlined since its parent (`public_mod`) has `#[doc(hidden)]`.\n+pub use self::public_mod::Public;\n+```\n+\n+If an item has `#[doc(hidden)]`, it won't be inlined (nor visible in the generated documentation):\n+\n+```rust,ignore (inline)\n+// This struct won't be visible.\n+#[doc(hidden)]\n+pub struct Hidden;\n+\n+// This re-export won't be visible.\n+pub use self::Hidden as InlinedHidden;\n+```\n+\n+The same applies on re-exports themselves: if you have multiple re-exports and some of them have\n+`#[doc(hidden)]`, then these ones (and only these) own't appear in the documentation:\n+\n+```rust,ignore (inline)\n+mod private_mod {\n+    /// First\n+    pub struct InPrivate;\n+}\n+\n+/// Second\n+#[doc(hidden)]\n+pub use self::private_mod::InPrivate as Hidden;\n+/// Third\n+pub use self::Hidden as Visible;\n+```\n+\n+In this case, `InPrivate` will be inlined as `Visible`. However, its documentation will be\n+`First Third` and not `First Second Third` because the re-export with `Second` as documentation has\n+`#[doc(hidden)]`, therefore, all its attributes are ignored.\n+\n+## Inlining with `#[doc(inline)]`\n+\n+You can use the `#[doc(inline)]` attribute if you want to force an item to be inlined:\n+\n+```rust,ignore (inline)\n+pub mod public_mod {\n+    pub struct Public;\n+}\n+#[doc(inline)]\n+pub use self::public_mod::Public;\n+```\n+\n+With this code, even though `public_mod::Public` is public and present in the documentation, the\n+`Public` type will be present both at the crate root and in the `public_mod` module.\n+\n+## Preventing inlining with `#[doc(no_inline)]`\n+\n+On the opposite of the `#[doc(inline)]` attribute, if you want to prevent an item from being\n+inlined, you can use `#[doc(no_inline)]`:\n+\n+```rust,ignore (inline)\n+mod private_mod {\n+    pub struct Public;\n+}\n+#[doc(no_inline)]\n+pub use self::private_mod::Public;\n+```\n+\n+In the generated documentation, you will see a re-export at the crate root and not the type\n+directly.\n+\n+## Attributes\n+\n+When an item is inlined, its doc comments and most of its attributes will be inlined along with it:\n+\n+```rust,ignore (inline)\n+mod private_mod {\n+    /// First\n+    #[cfg(a)]\n+    pub struct InPrivate;\n+    /// Second\n+    #[cfg(b)]\n+    pub use self::InPrivate as Second;\n+}\n+\n+/// Third\n+#[doc(inline)]\n+#[cfg(c)]\n+pub use self::private_mod::Second as Visible;\n+```\n+\n+In this case, `Visible` will have as documentation `First Second Third` and will also have as `cfg`:\n+`#[cfg(a, b, c)]`.\n+\n+[Intra-doc links](./linking-to-items-by-name.md) are resolved relative to where the doc comment is\n+defined.\n+\n+There are a few attributes which are not inlined though:\n+ * `#[doc(alias=\"\")]`\n+ * `#[doc(inline)]`\n+ * `#[doc(no_inline)]`\n+ * `#[doc(hidden)]` (because the re-export itself and its attributes are ignored).\n+\n+All other attributes are inherited when inlined, so that the documentation matches the behavior if\n+the inlined item was directly defined at the spot where it's shown."}, {"sha": "046d018543f386135de35978cbfd9ef5d3763240", "filename": "src/doc/rustdoc/src/write-documentation/the-doc-attribute.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fwrite-documentation%2Fthe-doc-attribute.md?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -223,12 +223,18 @@ Now we'll have a `Re-exports` line, and `Bar` will not link to anywhere.\n One special case: In Rust 2018 and later, if you `pub use` one of your dependencies, `rustdoc` will\n not eagerly inline it as a module unless you add `#[doc(inline)]`.\n \n+If you want to know more about inlining rules, take a look at the\n+[`re-exports` chapter](./re-exports.md).\n+\n ### `hidden`\n \n <span id=\"dochidden\"></span>\n \n Any item annotated with `#[doc(hidden)]` will not appear in the documentation, unless\n-the `strip-hidden` pass is removed.\n+the `strip-hidden` pass is removed. Re-exported items where one of its ancestors has\n+`#[doc(hidden)]` will be considered the same as private.\n+\n+You can find more information in the [`re-exports` chapter](./re-exports.md).\n \n ### `alias`\n "}, {"sha": "dc902f8cb024262a98f0ef51b4a157fed0aa0ba8", "filename": "src/tools/rustdoc-gui-test/src/main.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -14,13 +14,19 @@ fn get_browser_ui_test_version_inner(npm: &Path, global: bool) -> Option<String>\n     if global {\n         command.arg(\"--global\");\n     }\n-    let lines = command\n-        .output()\n-        .map(|output| String::from_utf8_lossy(&output.stdout).into_owned())\n-        .unwrap_or(String::new());\n+    let lines = match command.output() {\n+        Ok(output) => String::from_utf8_lossy(&output.stdout).into_owned(),\n+        Err(e) => {\n+            eprintln!(\n+                \"path to npm can be wrong, provided path: {npm:?}. Try to set npm path \\\n+            in config.toml in [build.npm]\",\n+            );\n+            panic!(\"{:?}\", e)\n+        }\n+    };\n     lines\n         .lines()\n-        .find_map(|l| l.split(':').nth(1)?.strip_prefix(\"browser-ui-test@\"))\n+        .find_map(|l| l.rsplit(':').next()?.strip_prefix(\"browser-ui-test@\"))\n         .map(|v| v.to_owned())\n }\n "}, {"sha": "b0c22540180487a644bb4168db6640f8b432efbd", "filename": "tests/rustdoc/issue-109449-doc-hidden-reexports.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Frustdoc%2Fissue-109449-doc-hidden-reexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Frustdoc%2Fissue-109449-doc-hidden-reexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-109449-doc-hidden-reexports.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -0,0 +1,143 @@\n+// Test to enforce rules over re-exports inlining from\n+// <https://github.com/rust-lang/rust/issues/109449>.\n+\n+#![crate_name = \"foo\"]\n+\n+mod private_module {\n+    #[doc(hidden)]\n+    pub struct Public;\n+    #[doc(hidden)]\n+    pub type Bar = ();\n+}\n+\n+#[doc(hidden)]\n+mod module {\n+    pub struct Public2;\n+    pub type Bar2 = ();\n+}\n+\n+#[doc(hidden)]\n+pub type Bar3 = ();\n+#[doc(hidden)]\n+pub struct FooFoo;\n+\n+// Checking that re-exporting a `#[doc(hidden)]` item will NOT inline it.\n+pub mod single_reexport {\n+    // @has 'foo/single_reexport/index.html'\n+\n+    // First we check that we have 4 type aliases.\n+    // @count - '//*[@id=\"main-content\"]/*[@class=\"item-table\"]//code' 4\n+\n+    // Then we check that we have the correct link for each re-export.\n+\n+    // @!has - '//*[@href=\"struct.Foo.html\"]' 'Foo'\n+    // @has - '//*[@id=\"reexport.Foo\"]/code' 'pub use crate::private_module::Public as Foo;'\n+    pub use crate::private_module::Public as Foo;\n+    // @!has - '//*[@href=\"type.Foo2.html\"]' 'Foo2'\n+    // @has - '//*[@id=\"reexport.Foo2\"]/code' 'pub use crate::private_module::Bar as Foo2;'\n+    pub use crate::private_module::Bar as Foo2;\n+    // @!has - '//*[@href=\"type.Yo.html\"]' 'Yo'\n+    // @has - '//*[@id=\"reexport.Yo\"]/code' 'pub use crate::Bar3 as Yo;'\n+    pub use crate::Bar3 as Yo;\n+    // @!has - '//*[@href=\"struct.Yo2.html\"]' 'Yo2'\n+    // @has - '//*[@id=\"reexport.Yo2\"]/code' 'pub use crate::FooFoo as Yo2;'\n+    pub use crate::FooFoo as Yo2;\n+\n+    // Checking that each file is also created as expected.\n+    // @!has 'foo/single_reexport/struct.Foo.html'\n+    // @!has 'foo/single_reexport/type.Foo2.html'\n+    // @!has 'foo/single_reexport/type.Yo.html'\n+    // @!has 'foo/single_reexport/struct.Yo2.html'\n+}\n+\n+// However, re-exporting an item inheriting `#[doc(hidden)]` will inline it.\n+pub mod single_reexport_inherit_hidden {\n+    // @has 'foo/single_reexport_inherit_hidden/index.html'\n+\n+    // @has - '//*[@href=\"struct.Foo3.html\"]' 'Foo3'\n+    pub use crate::module::Public2 as Foo3;\n+    // @has - '//*[@href=\"type.Foo4.html\"]' 'Foo4'\n+    pub use crate::module::Bar2 as Foo4;\n+\n+    // @has 'foo/single_reexport_inherit_hidden/struct.Foo3.html'\n+    // @has 'foo/single_reexport_inherit_hidden/type.Foo4.html'\n+}\n+\n+pub mod single_reexport_no_inline {\n+    // First we ensure that we only have re-exports and no inlined items.\n+    // @has 'foo/single_reexport_no_inline/index.html'\n+    // @count - '//*[@id=\"main-content\"]/*[@class=\"small-section-header\"]' 1\n+    // @has - '//*[@id=\"main-content\"]/*[@class=\"small-section-header\"]' 'Re-exports'\n+\n+    // Now we check that we don't have links to the items, just `pub use`.\n+    // @has - '//*[@id=\"main-content\"]//*' 'pub use crate::private_module::Public as XFoo;'\n+    // @!has - '//*[@id=\"main-content\"]//a' 'XFoo'\n+    #[doc(no_inline)]\n+    pub use crate::private_module::Public as XFoo;\n+    // @has - '//*[@id=\"main-content\"]//*' 'pub use crate::private_module::Bar as Foo2;'\n+    // @!has - '//*[@id=\"main-content\"]//a' 'Foo2'\n+    #[doc(no_inline)]\n+    pub use crate::private_module::Bar as Foo2;\n+    // @has - '//*[@id=\"main-content\"]//*' 'pub use crate::Bar3 as Yo;'\n+    // @!has - '//*[@id=\"main-content\"]//a' 'Yo'\n+    #[doc(no_inline)]\n+    pub use crate::Bar3 as Yo;\n+    // @has - '//*[@id=\"main-content\"]//*' 'pub use crate::FooFoo as Yo2;'\n+    // @!has - '//*[@id=\"main-content\"]//a' 'Yo2'\n+    #[doc(no_inline)]\n+    pub use crate::FooFoo as Yo2;\n+    // @has - '//*[@id=\"main-content\"]//*' 'pub use crate::module::Public2 as Foo3;'\n+    // @!has - '//*[@id=\"main-content\"]//a' 'Foo3'\n+    #[doc(no_inline)]\n+    pub use crate::module::Public2 as Foo3;\n+    // @has - '//*[@id=\"main-content\"]//*' 'pub use crate::module::Bar2 as Foo4;'\n+    // @!has - '//*[@id=\"main-content\"]//a' 'Foo4'\n+    #[doc(no_inline)]\n+    pub use crate::module::Bar2 as Foo4;\n+}\n+\n+// Checking that glob re-exports don't inline `#[doc(hidden)]` items.\n+pub mod glob_reexport {\n+    // With glob re-exports, we don't inline `#[doc(hidden)]` items so only `module` items\n+    // should be inlined.\n+    // @has 'foo/glob_reexport/index.html'\n+    // @count - '//*[@id=\"main-content\"]/*[@class=\"small-section-header\"]' 3\n+    // @has - '//*[@id=\"main-content\"]/*[@class=\"small-section-header\"]' 'Re-exports'\n+    // @has - '//*[@id=\"main-content\"]/*[@class=\"small-section-header\"]' 'Structs'\n+    // @has - '//*[@id=\"main-content\"]/*[@class=\"small-section-header\"]' 'Type Definitions'\n+\n+    // Now we check we have 1 re-export and 2 inlined items.\n+    // If not item from a glob re-export is visible, we don't show the re-export.\n+    // @!has - '//*[@id=\"main-content\"]//*' 'pub use crate::private_module::*;'\n+    pub use crate::private_module::*;\n+    // @has - '//*[@id=\"main-content\"]//*' 'pub use crate::*;'\n+    pub use crate::*;\n+    // This one should be inlined.\n+    // @!has - '//*[@id=\"main-content\"]//*' 'pub use crate::module::*;'\n+    // @has - '//*[@id=\"main-content\"]//a[@href=\"struct.Public2.html\"]' 'Public2'\n+    // @has - '//*[@id=\"main-content\"]//a[@href=\"type.Bar2.html\"]' 'Bar2'\n+    // And we check that the two files were created too.\n+    // @has 'foo/glob_reexport/struct.Public2.html'\n+    // @has 'foo/glob_reexport/type.Bar2.html'\n+    pub use crate::module::*;\n+}\n+\n+mod private {\n+    /// Original.\n+    pub struct Bar3;\n+}\n+\n+// Checking that `#[doc(hidden)]` re-exports documentation isn't generated.\n+pub mod doc_hidden_reexport {\n+    // @has 'foo/doc_hidden_reexport/index.html'\n+    // Ensure there is only one item in this page and that it's a struct.\n+    // @count - '//*[@class=\"item-name\"]' 1\n+    // @has - '//a[@class=\"struct\"]' 'Reexport'\n+    // Check that the `#[doc(hidden)]` re-export's attributes are not taken into account.\n+    // @has - '//*[@class=\"desc docblock-short\"]' 'Visible. Original.'\n+    /// Hidden.\n+    #[doc(hidden)]\n+    pub use crate::private::Bar3;\n+    /// Visible.\n+    pub use self::Bar3 as Reexport;\n+}"}, {"sha": "e7c90dcc81bb206861c209d4f252416ade1d5042", "filename": "tests/ui/lint/type-overflow.stderr", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Fui%2Flint%2Ftype-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Fui%2Flint%2Ftype-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Ftype-overflow.stderr?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -16,17 +16,33 @@ warning: literal out of range for `i8`\n   --> $DIR/type-overflow.rs:10:16\n    |\n LL |     let fail = 0b1000_0001i8;\n-   |                ^^^^^^^^^^^^^ help: consider using the type `u8` instead: `0b1000_0001u8`\n+   |                ^^^^^^^^^^^^^\n    |\n    = note: the literal `0b1000_0001i8` (decimal `129`) does not fit into the type `i8` and will become `-127i8`\n+help: consider using the type `u8` instead\n+   |\n+LL |     let fail = 0b1000_0001u8;\n+   |                ~~~~~~~~~~~~~\n+help: to use as a negative number (decimal `-127`), consider using the type `u8` for the literal and cast it to `i8`\n+   |\n+LL |     let fail = 0b1000_0001u8 as i8;\n+   |                ~~~~~~~~~~~~~~~~~~~\n \n warning: literal out of range for `i64`\n   --> $DIR/type-overflow.rs:12:16\n    |\n LL |     let fail = 0x8000_0000_0000_0000i64;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using the type `u64` instead: `0x8000_0000_0000_0000u64`\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the literal `0x8000_0000_0000_0000i64` (decimal `9223372036854775808`) does not fit into the type `i64` and will become `-9223372036854775808i64`\n+help: consider using the type `u64` instead\n+   |\n+LL |     let fail = 0x8000_0000_0000_0000u64;\n+   |                ~~~~~~~~~~~~~~~~~~~~~~~~\n+help: to use as a negative number (decimal `-9223372036854775808`), consider using the type `u64` for the literal and cast it to `i64`\n+   |\n+LL |     let fail = 0x8000_0000_0000_0000u64 as i64;\n+   |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n warning: literal out of range for `u32`\n   --> $DIR/type-overflow.rs:14:16\n@@ -44,6 +60,10 @@ LL |     let fail: i128 = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n    |\n    = note: the literal `0x8000_0000_0000_0000_0000_0000_0000_0000` (decimal `170141183460469231731687303715884105728`) does not fit into the type `i128` and will become `-170141183460469231731687303715884105728i128`\n    = help: consider using the type `u128` instead\n+help: to use as a negative number (decimal `-170141183460469231731687303715884105728`), consider using the type `u128` for the literal and cast it to `i128`\n+   |\n+LL |     let fail: i128 = 0x8000_0000_0000_0000_0000_0000_0000_0000u128 as i128;\n+   |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n warning: literal out of range for `i32`\n   --> $DIR/type-overflow.rs:19:16\n@@ -53,6 +73,10 @@ LL |     let fail = 0x8FFF_FFFF_FFFF_FFFE;\n    |\n    = note: the literal `0x8FFF_FFFF_FFFF_FFFE` (decimal `10376293541461622782`) does not fit into the type `i32` and will become `-2i32`\n    = help: consider using the type `i128` instead\n+help: to use as a negative number (decimal `-2`), consider using the type `u32` for the literal and cast it to `i32`\n+   |\n+LL |     let fail = 0x8FFF_FFFF_FFFF_FFFEu32 as i32;\n+   |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n warning: literal out of range for `i8`\n   --> $DIR/type-overflow.rs:21:17"}, {"sha": "15f380f7fb471032b17d3645176b15adbc37e01a", "filename": "tests/ui/match/issue-112438.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Fui%2Fmatch%2Fissue-112438.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Fui%2Fmatch%2Fissue-112438.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch%2Fissue-112438.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+#![feature(inline_const_pat)]\n+#![allow(dead_code)]\n+#![allow(incomplete_features)]\n+fn foo<const V: usize>() {\n+    match 0 {\n+        const { 1 << 5 } | _ => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "892697493b7a9a41302540ec099843ac2fcca93b", "filename": "tests/ui/resolve/issue-112472-multi-generics-suggestion.fixed", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Fui%2Fresolve%2Fissue-112472-multi-generics-suggestion.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Fui%2Fresolve%2Fissue-112472-multi-generics-suggestion.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fissue-112472-multi-generics-suggestion.fixed?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -0,0 +1,31 @@\n+// run-rustfix\n+\n+use std::fmt::Debug;\n+use std::marker::PhantomData;\n+use std::convert::{self, TryFrom};\n+\n+#[allow(unused)]\n+struct Codec<EncodeLine, DecodeLine> {\n+    phantom_decode: PhantomData<DecodeLine>,\n+    phantom_encode: PhantomData<EncodeLine>,\n+}\n+\n+pub enum ParseError {}\n+\n+impl<EncodeLine, DecodeLine> Codec<EncodeLine, DecodeLine> where\n+    DecodeLine: Debug + convert::TryFrom<String>,\n+    DecodeLine: convert::TryFrom<String, Error = ParseError>,\n+    //~^ ERROR expected trait, found enum `ParseError`\n+    //~| HELP constrain the associated type to `ParseError`\n+{\n+}\n+\n+impl<EncodeLine, DecodeLine> Codec<EncodeLine, DecodeLine> where\n+    DecodeLine: Debug + TryFrom<String>,\n+    DecodeLine: TryFrom<String, Error = ParseError>,\n+    //~^ ERROR expected trait, found enum `ParseError`\n+    //~| HELP constrain the associated type to `ParseError`\n+{\n+}\n+\n+fn main() {}"}, {"sha": "2b2f5f1ad8d0798973b554d9fb4ce8b489d94615", "filename": "tests/ui/resolve/issue-112472-multi-generics-suggestion.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Fui%2Fresolve%2Fissue-112472-multi-generics-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Fui%2Fresolve%2Fissue-112472-multi-generics-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fissue-112472-multi-generics-suggestion.rs?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -0,0 +1,31 @@\n+// run-rustfix\n+\n+use std::fmt::Debug;\n+use std::marker::PhantomData;\n+use std::convert::{self, TryFrom};\n+\n+#[allow(unused)]\n+struct Codec<EncodeLine, DecodeLine> {\n+    phantom_decode: PhantomData<DecodeLine>,\n+    phantom_encode: PhantomData<EncodeLine>,\n+}\n+\n+pub enum ParseError {}\n+\n+impl<EncodeLine, DecodeLine> Codec<EncodeLine, DecodeLine> where\n+    DecodeLine: Debug + convert::TryFrom<String>,\n+    <DecodeLine as convert::TryFrom<String>>::Error: ParseError,\n+    //~^ ERROR expected trait, found enum `ParseError`\n+    //~| HELP constrain the associated type to `ParseError`\n+{\n+}\n+\n+impl<EncodeLine, DecodeLine> Codec<EncodeLine, DecodeLine> where\n+    DecodeLine: Debug + TryFrom<String>,\n+    <DecodeLine as TryFrom<String>>::Error: ParseError,\n+    //~^ ERROR expected trait, found enum `ParseError`\n+    //~| HELP constrain the associated type to `ParseError`\n+{\n+}\n+\n+fn main() {}"}, {"sha": "f463e2dad2cfc987a286784799bfe66ad11349f3", "filename": "tests/ui/resolve/issue-112472-multi-generics-suggestion.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Fui%2Fresolve%2Fissue-112472-multi-generics-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/331249a94930adb3d2a7243d946733b63324b2d6/tests%2Fui%2Fresolve%2Fissue-112472-multi-generics-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fissue-112472-multi-generics-suggestion.stderr?ref=331249a94930adb3d2a7243d946733b63324b2d6", "patch": "@@ -0,0 +1,25 @@\n+error[E0404]: expected trait, found enum `ParseError`\n+  --> $DIR/issue-112472-multi-generics-suggestion.rs:17:54\n+   |\n+LL |     <DecodeLine as convert::TryFrom<String>>::Error: ParseError,\n+   |                                                      ^^^^^^^^^^ not a trait\n+   |\n+help: constrain the associated type to `ParseError`\n+   |\n+LL |     DecodeLine: convert::TryFrom<String, Error = ParseError>,\n+   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error[E0404]: expected trait, found enum `ParseError`\n+  --> $DIR/issue-112472-multi-generics-suggestion.rs:25:45\n+   |\n+LL |     <DecodeLine as TryFrom<String>>::Error: ParseError,\n+   |                                             ^^^^^^^^^^ not a trait\n+   |\n+help: constrain the associated type to `ParseError`\n+   |\n+LL |     DecodeLine: TryFrom<String, Error = ParseError>,\n+   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0404`."}]}